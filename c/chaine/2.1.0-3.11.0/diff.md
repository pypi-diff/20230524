# Comparing `tmp/chaine-2.1.0-cp311-cp311-win_amd64.whl.zip` & `tmp/chaine-3.11.0-cp311-cp311-manylinux_2_17_i686.manylinux_2_12_i686.manylinux2010_i686.manylinux2014_i686.whl.zip`

## zipinfo {}

```diff
@@ -1,134 +1,87 @@
-Zip file size: 623923 bytes, number of entries: 132
--rw-r--r--  2.0 fat       99 b- defN 80-Jan-01 00:00 chaine/__init__.py
--rw-r--r--  2.0 fat   538278 b- defN 80-Jan-01 00:00 chaine/_core/crf.cpp
--rw-r--r--  2.0 fat     9364 b- defN 80-Jan-01 00:00 chaine/_core/crf.pyx
--rw-r--r--  2.0 fat     1562 b- defN 80-Jan-01 00:00 chaine/_core/crfsuite/COPYING
--rw-r--r--  2.0 fat    39708 b- defN 80-Jan-01 00:00 chaine/_core/crfsuite/include/crfsuite.h
--rw-r--r--  2.0 fat    19242 b- defN 80-Jan-01 00:00 chaine/_core/crfsuite/include/crfsuite.hpp
--rw-r--r--  2.0 fat    14504 b- defN 80-Jan-01 00:00 chaine/_core/crfsuite/include/crfsuite_api.hpp
--rw-r--r--  2.0 fat     2303 b- defN 80-Jan-01 00:00 chaine/_core/crfsuite/include/os.h
--rw-r--r--  2.0 fat     1601 b- defN 80-Jan-01 00:00 chaine/_core/crfsuite/lib/cqdb/COPYING
--rw-r--r--  2.0 fat    19246 b- defN 80-Jan-01 00:00 chaine/_core/crfsuite/lib/cqdb/include/cqdb.h
--rw-r--r--  2.0 fat    17907 b- defN 80-Jan-01 00:00 chaine/_core/crfsuite/lib/cqdb/src/cqdb.c
--rw-r--r--  2.0 fat    37835 b- defN 80-Jan-01 00:00 chaine/_core/crfsuite/lib/cqdb/src/lookup3.c
--rw-r--r--  2.0 fat     5166 b- defN 80-Jan-01 00:00 chaine/_core/crfsuite/lib/cqdb/src/main.c
--rw-r--r--  2.0 fat    11066 b- defN 80-Jan-01 00:00 chaine/_core/crfsuite/lib/crf/src/crf1d.h
--rw-r--r--  2.0 fat    23406 b- defN 80-Jan-01 00:00 chaine/_core/crfsuite/lib/crf/src/crf1d_context.c
--rw-r--r--  2.0 fat    30244 b- defN 80-Jan-01 00:00 chaine/_core/crfsuite/lib/crf/src/crf1d_encode.c
--rw-r--r--  2.0 fat    10971 b- defN 80-Jan-01 00:00 chaine/_core/crfsuite/lib/crf/src/crf1d_feature.c
--rw-r--r--  2.0 fat    27779 b- defN 80-Jan-01 00:00 chaine/_core/crfsuite/lib/crf/src/crf1d_model.c
--rw-r--r--  2.0 fat    17330 b- defN 80-Jan-01 00:00 chaine/_core/crfsuite/lib/crf/src/crf1d_tag.c
--rw-r--r--  2.0 fat    14580 b- defN 80-Jan-01 00:00 chaine/_core/crfsuite/lib/crf/src/crfsuite.c
--rw-r--r--  2.0 fat     7780 b- defN 80-Jan-01 00:00 chaine/_core/crfsuite/lib/crf/src/crfsuite_internal.h
--rw-r--r--  2.0 fat     8851 b- defN 80-Jan-01 00:00 chaine/_core/crfsuite/lib/crf/src/crfsuite_train.c
--rw-r--r--  2.0 fat     3369 b- defN 80-Jan-01 00:00 chaine/_core/crfsuite/lib/crf/src/dataset.c
--rw-r--r--  2.0 fat     4005 b- defN 80-Jan-01 00:00 chaine/_core/crfsuite/lib/crf/src/dictionary.c
--rw-r--r--  2.0 fat     2948 b- defN 80-Jan-01 00:00 chaine/_core/crfsuite/lib/crf/src/holdout.c
--rw-r--r--  2.0 fat    30708 b- defN 80-Jan-01 00:00 chaine/_core/crfsuite/lib/crf/src/json.c
--rw-r--r--  2.0 fat     3509 b- defN 80-Jan-01 00:00 chaine/_core/crfsuite/lib/crf/src/json.h
--rw-r--r--  2.0 fat     2725 b- defN 80-Jan-01 00:00 chaine/_core/crfsuite/lib/crf/src/logging.c
--rw-r--r--  2.0 fat     2112 b- defN 80-Jan-01 00:00 chaine/_core/crfsuite/lib/crf/src/logging.h
--rw-r--r--  2.0 fat    10389 b- defN 80-Jan-01 00:00 chaine/_core/crfsuite/lib/crf/src/params.c
--rw-r--r--  2.0 fat     3838 b- defN 80-Jan-01 00:00 chaine/_core/crfsuite/lib/crf/src/params.h
--rw-r--r--  2.0 fat     5022 b- defN 80-Jan-01 00:00 chaine/_core/crfsuite/lib/crf/src/quark.c
--rw-r--r--  2.0 fat     2029 b- defN 80-Jan-01 00:00 chaine/_core/crfsuite/lib/crf/src/quark.h
--rw-r--r--  2.0 fat    35165 b- defN 80-Jan-01 00:00 chaine/_core/crfsuite/lib/crf/src/rumavl.c
--rw-r--r--  2.0 fat     5680 b- defN 80-Jan-01 00:00 chaine/_core/crfsuite/lib/crf/src/rumavl.h
--rw-r--r--  2.0 fat    11267 b- defN 80-Jan-01 00:00 chaine/_core/crfsuite/lib/crf/src/train_arow.c
--rw-r--r--  2.0 fat     6941 b- defN 80-Jan-01 00:00 chaine/_core/crfsuite/lib/crf/src/train_averaged_perceptron.c
--rw-r--r--  2.0 fat    14438 b- defN 80-Jan-01 00:00 chaine/_core/crfsuite/lib/crf/src/train_l2sgd.c
--rw-r--r--  2.0 fat     9770 b- defN 80-Jan-01 00:00 chaine/_core/crfsuite/lib/crf/src/train_lbfgs.c
--rw-r--r--  2.0 fat    12007 b- defN 80-Jan-01 00:00 chaine/_core/crfsuite/lib/crf/src/train_passive_aggressive.c
--rw-r--r--  2.0 fat    10273 b- defN 80-Jan-01 00:00 chaine/_core/crfsuite/lib/crf/src/vecmath.h
--rw-r--r--  2.0 fat     8156 b- defN 80-Jan-01 00:00 chaine/_core/crfsuite/README
--rw-r--r--  2.0 fat       25 b- defN 80-Jan-01 00:00 chaine/_core/crfsuite/swig/crfsuite.cpp
--rw-r--r--  2.0 fat     2070 b- defN 80-Jan-01 00:00 chaine/_core/crfsuite_api.pxd
--rw-r--r--  2.0 fat     1135 b- defN 80-Jan-01 00:00 chaine/_core/liblbfgs/COPYING
--rw-r--r--  2.0 fat    33591 b- defN 80-Jan-01 00:00 chaine/_core/liblbfgs/include/lbfgs.h
--rw-r--r--  2.0 fat     3569 b- defN 80-Jan-01 00:00 chaine/_core/liblbfgs/lib/arithmetic_ansi.h
--rw-r--r--  2.0 fat    14108 b- defN 80-Jan-01 00:00 chaine/_core/liblbfgs/lib/arithmetic_sse_double.h
--rw-r--r--  2.0 fat    13668 b- defN 80-Jan-01 00:00 chaine/_core/liblbfgs/lib/arithmetic_sse_float.h
--rw-r--r--  2.0 fat    45236 b- defN 80-Jan-01 00:00 chaine/_core/liblbfgs/lib/lbfgs.c
--rw-r--r--  2.0 fat     2716 b- defN 80-Jan-01 00:00 chaine/_core/liblbfgs/README
--rw-r--r--  2.0 fat     1370 b- defN 80-Jan-01 00:00 chaine/_core/tagger_wrapper.hpp
--rw-r--r--  2.0 fat      777 b- defN 80-Jan-01 00:00 chaine/_core/trainer_wrapper.cpp
--rw-r--r--  2.0 fat      599 b- defN 80-Jan-01 00:00 chaine/_core/trainer_wrapper.hpp
--rw-r--r--  2.0 fat    18508 b- defN 80-Jan-01 00:00 chaine/crf.py
--rw-r--r--  2.0 fat     5470 b- defN 80-Jan-01 00:00 chaine/logging.py
--rw-r--r--  2.0 fat      267 b- defN 80-Jan-01 00:00 chaine/optimization/__init__.py
--rw-r--r--  2.0 fat     3845 b- defN 80-Jan-01 00:00 chaine/optimization/metrics.py
--rw-r--r--  2.0 fat    18191 b- defN 80-Jan-01 00:00 chaine/optimization/spaces.py
--rw-r--r--  2.0 fat     3669 b- defN 80-Jan-01 00:00 chaine/optimization/trial.py
--rw-r--r--  2.0 fat     3416 b- defN 80-Jan-01 00:00 chaine/optimization/utils.py
--rw-r--r--  2.0 fat     8585 b- defN 80-Jan-01 00:00 chaine/training.py
--rw-r--r--  2.0 fat      411 b- defN 80-Jan-01 00:00 chaine/typing.py
--rw-r--r--  2.0 fat     1038 b- defN 80-Jan-01 00:00 chaine/validation.py
--rw-r--r--  2.0 fat    18508 b- defN 80-Jan-01 00:00 chaine/crf.py
--rw-r--r--  2.0 fat     5470 b- defN 80-Jan-01 00:00 chaine/logging.py
--rw-r--r--  2.0 fat     8585 b- defN 80-Jan-01 00:00 chaine/training.py
--rw-r--r--  2.0 fat      411 b- defN 80-Jan-01 00:00 chaine/typing.py
--rw-r--r--  2.0 fat     1038 b- defN 80-Jan-01 00:00 chaine/validation.py
--rw-r--r--  2.0 fat       99 b- defN 80-Jan-01 00:00 chaine/__init__.py
--rw-r--r--  2.0 fat     3845 b- defN 80-Jan-01 00:00 chaine/optimization/metrics.py
--rw-r--r--  2.0 fat    18191 b- defN 80-Jan-01 00:00 chaine/optimization/spaces.py
--rw-r--r--  2.0 fat     3669 b- defN 80-Jan-01 00:00 chaine/optimization/trial.py
--rw-r--r--  2.0 fat     3416 b- defN 80-Jan-01 00:00 chaine/optimization/utils.py
--rw-r--r--  2.0 fat      267 b- defN 80-Jan-01 00:00 chaine/optimization/__init__.py
--rw-r--r--  2.0 fat   238592 b- defN 80-Jan-01 00:00 chaine/_core/crf.cp311-win_amd64.pyd
--rw-r--r--  2.0 fat   538278 b- defN 80-Jan-01 00:00 chaine/_core/crf.cpp
--rw-r--r--  2.0 fat     9364 b- defN 80-Jan-01 00:00 chaine/_core/crf.pyx
--rw-r--r--  2.0 fat     2070 b- defN 80-Jan-01 00:00 chaine/_core/crfsuite_api.pxd
--rw-r--r--  2.0 fat     1370 b- defN 80-Jan-01 00:00 chaine/_core/tagger_wrapper.hpp
--rw-r--r--  2.0 fat      777 b- defN 80-Jan-01 00:00 chaine/_core/trainer_wrapper.cpp
--rw-r--r--  2.0 fat      599 b- defN 80-Jan-01 00:00 chaine/_core/trainer_wrapper.hpp
--rw-r--r--  2.0 fat     1562 b- defN 80-Jan-01 00:00 chaine/_core/crfsuite/COPYING
--rw-r--r--  2.0 fat     8156 b- defN 80-Jan-01 00:00 chaine/_core/crfsuite/README
--rw-r--r--  2.0 fat    39708 b- defN 80-Jan-01 00:00 chaine/_core/crfsuite/include/crfsuite.h
--rw-r--r--  2.0 fat    19242 b- defN 80-Jan-01 00:00 chaine/_core/crfsuite/include/crfsuite.hpp
--rw-r--r--  2.0 fat    14504 b- defN 80-Jan-01 00:00 chaine/_core/crfsuite/include/crfsuite_api.hpp
--rw-r--r--  2.0 fat     2303 b- defN 80-Jan-01 00:00 chaine/_core/crfsuite/include/os.h
--rw-r--r--  2.0 fat     1601 b- defN 80-Jan-01 00:00 chaine/_core/crfsuite/lib/cqdb/COPYING
--rw-r--r--  2.0 fat    19246 b- defN 80-Jan-01 00:00 chaine/_core/crfsuite/lib/cqdb/include/cqdb.h
--rw-r--r--  2.0 fat    17907 b- defN 80-Jan-01 00:00 chaine/_core/crfsuite/lib/cqdb/src/cqdb.c
--rw-r--r--  2.0 fat    37835 b- defN 80-Jan-01 00:00 chaine/_core/crfsuite/lib/cqdb/src/lookup3.c
--rw-r--r--  2.0 fat     5166 b- defN 80-Jan-01 00:00 chaine/_core/crfsuite/lib/cqdb/src/main.c
--rw-r--r--  2.0 fat    11066 b- defN 80-Jan-01 00:00 chaine/_core/crfsuite/lib/crf/src/crf1d.h
--rw-r--r--  2.0 fat    23406 b- defN 80-Jan-01 00:00 chaine/_core/crfsuite/lib/crf/src/crf1d_context.c
--rw-r--r--  2.0 fat    30244 b- defN 80-Jan-01 00:00 chaine/_core/crfsuite/lib/crf/src/crf1d_encode.c
--rw-r--r--  2.0 fat    10971 b- defN 80-Jan-01 00:00 chaine/_core/crfsuite/lib/crf/src/crf1d_feature.c
--rw-r--r--  2.0 fat    27779 b- defN 80-Jan-01 00:00 chaine/_core/crfsuite/lib/crf/src/crf1d_model.c
--rw-r--r--  2.0 fat    17330 b- defN 80-Jan-01 00:00 chaine/_core/crfsuite/lib/crf/src/crf1d_tag.c
--rw-r--r--  2.0 fat    14580 b- defN 80-Jan-01 00:00 chaine/_core/crfsuite/lib/crf/src/crfsuite.c
--rw-r--r--  2.0 fat     7780 b- defN 80-Jan-01 00:00 chaine/_core/crfsuite/lib/crf/src/crfsuite_internal.h
--rw-r--r--  2.0 fat     8851 b- defN 80-Jan-01 00:00 chaine/_core/crfsuite/lib/crf/src/crfsuite_train.c
--rw-r--r--  2.0 fat     3369 b- defN 80-Jan-01 00:00 chaine/_core/crfsuite/lib/crf/src/dataset.c
--rw-r--r--  2.0 fat     4005 b- defN 80-Jan-01 00:00 chaine/_core/crfsuite/lib/crf/src/dictionary.c
--rw-r--r--  2.0 fat     2948 b- defN 80-Jan-01 00:00 chaine/_core/crfsuite/lib/crf/src/holdout.c
--rw-r--r--  2.0 fat    30708 b- defN 80-Jan-01 00:00 chaine/_core/crfsuite/lib/crf/src/json.c
--rw-r--r--  2.0 fat     3509 b- defN 80-Jan-01 00:00 chaine/_core/crfsuite/lib/crf/src/json.h
--rw-r--r--  2.0 fat     2725 b- defN 80-Jan-01 00:00 chaine/_core/crfsuite/lib/crf/src/logging.c
--rw-r--r--  2.0 fat     2112 b- defN 80-Jan-01 00:00 chaine/_core/crfsuite/lib/crf/src/logging.h
--rw-r--r--  2.0 fat    10389 b- defN 80-Jan-01 00:00 chaine/_core/crfsuite/lib/crf/src/params.c
--rw-r--r--  2.0 fat     3838 b- defN 80-Jan-01 00:00 chaine/_core/crfsuite/lib/crf/src/params.h
--rw-r--r--  2.0 fat     5022 b- defN 80-Jan-01 00:00 chaine/_core/crfsuite/lib/crf/src/quark.c
--rw-r--r--  2.0 fat     2029 b- defN 80-Jan-01 00:00 chaine/_core/crfsuite/lib/crf/src/quark.h
--rw-r--r--  2.0 fat    35165 b- defN 80-Jan-01 00:00 chaine/_core/crfsuite/lib/crf/src/rumavl.c
--rw-r--r--  2.0 fat     5680 b- defN 80-Jan-01 00:00 chaine/_core/crfsuite/lib/crf/src/rumavl.h
--rw-r--r--  2.0 fat    11267 b- defN 80-Jan-01 00:00 chaine/_core/crfsuite/lib/crf/src/train_arow.c
--rw-r--r--  2.0 fat     6941 b- defN 80-Jan-01 00:00 chaine/_core/crfsuite/lib/crf/src/train_averaged_perceptron.c
--rw-r--r--  2.0 fat    14438 b- defN 80-Jan-01 00:00 chaine/_core/crfsuite/lib/crf/src/train_l2sgd.c
--rw-r--r--  2.0 fat     9770 b- defN 80-Jan-01 00:00 chaine/_core/crfsuite/lib/crf/src/train_lbfgs.c
--rw-r--r--  2.0 fat    12007 b- defN 80-Jan-01 00:00 chaine/_core/crfsuite/lib/crf/src/train_passive_aggressive.c
--rw-r--r--  2.0 fat    10273 b- defN 80-Jan-01 00:00 chaine/_core/crfsuite/lib/crf/src/vecmath.h
--rw-r--r--  2.0 fat       25 b- defN 80-Jan-01 00:00 chaine/_core/crfsuite/swig/crfsuite.cpp
--rw-r--r--  2.0 fat     1135 b- defN 80-Jan-01 00:00 chaine/_core/liblbfgs/COPYING
--rw-r--r--  2.0 fat     2716 b- defN 80-Jan-01 00:00 chaine/_core/liblbfgs/README
--rw-r--r--  2.0 fat    33591 b- defN 80-Jan-01 00:00 chaine/_core/liblbfgs/include/lbfgs.h
--rw-r--r--  2.0 fat     3569 b- defN 80-Jan-01 00:00 chaine/_core/liblbfgs/lib/arithmetic_ansi.h
--rw-r--r--  2.0 fat    14108 b- defN 80-Jan-01 00:00 chaine/_core/liblbfgs/lib/arithmetic_sse_double.h
--rw-r--r--  2.0 fat    13668 b- defN 80-Jan-01 00:00 chaine/_core/liblbfgs/lib/arithmetic_sse_float.h
--rw-r--r--  2.0 fat    45236 b- defN 80-Jan-01 00:00 chaine/_core/liblbfgs/lib/lbfgs.c
--rw-r--r--  2.0 fat    12530 b- defN 80-Jan-01 00:00 chaine-2.1.0.dist-info/METADATA
--rw-r--r--  2.0 fat       98 b- defN 80-Jan-01 00:00 chaine-2.1.0.dist-info/WHEEL
-?rw-r--r--  2.0 fat    12483 b- defN 16-Jan-01 00:00 chaine-2.1.0.dist-info/RECORD
-132 files, 2714577 bytes uncompressed, 603925 bytes compressed:  77.8%
+Zip file size: 1121328 bytes, number of entries: 85
+drwxr-xr-x  2.0 unx        0 b- stor 23-May-24 09:14 chaine-3.11.0.dist-info/
+drwxr-xr-x  2.0 unx        0 b- stor 23-May-24 09:14 chaine/
+drwxr-xr-x  2.0 unx        0 b- stor 23-May-24 09:14 chaine.libs/
+-rw-r--r--  2.0 unx     6472 b- defN 23-May-24 09:14 chaine-3.11.0.dist-info/RECORD
+-rw-r--r--  2.0 unx      218 b- defN 23-May-24 09:14 chaine-3.11.0.dist-info/WHEEL
+-rw-r--r--  2.0 unx    12528 b- defN 23-May-24 09:14 chaine-3.11.0.dist-info/METADATA
+drwxr-xr-x  2.0 unx        0 b- stor 23-May-24 09:14 chaine/_core/
+drwxr-xr-x  2.0 unx        0 b- stor 23-May-24 09:14 chaine/optimization/
+-rwxr-xr-x  2.0 unx    18003 b- defN 23-May-24 09:14 chaine/crf.py
+-rwxr-xr-x  2.0 unx     5256 b- defN 23-May-24 09:14 chaine/logging.py
+-rwxr-xr-x  2.0 unx      393 b- defN 23-May-24 09:14 chaine/typing.py
+-rwxr-xr-x  2.0 unx       97 b- defN 23-May-24 09:14 chaine/__init__.py
+-rwxr-xr-x  2.0 unx      995 b- defN 23-May-24 09:14 chaine/validation.py
+-rwxr-xr-x  2.0 unx     8401 b- defN 23-May-24 09:14 chaine/training.py
+drwxr-xr-x  2.0 unx        0 b- stor 23-May-24 09:14 chaine/_core/crfsuite/
+drwxr-xr-x  2.0 unx        0 b- stor 23-May-24 09:14 chaine/_core/liblbfgs/
+-rwxr-xr-x  2.0 unx  2385380 b- defN 23-May-24 09:14 chaine/_core/crf.cpython-311-i386-linux-gnu.so
+-rwxr-xr-x  2.0 unx     2003 b- defN 23-May-24 09:14 chaine/_core/crfsuite_api.pxd
+-rwxr-xr-x  2.0 unx      745 b- defN 23-May-24 09:14 chaine/_core/trainer_wrapper.cpp
+-rwxr-xr-x  2.0 unx     1312 b- defN 23-May-24 09:14 chaine/_core/tagger_wrapper.hpp
+-rwxr-xr-x  2.0 unx      573 b- defN 23-May-24 09:14 chaine/_core/trainer_wrapper.hpp
+-rwxr-xr-x  2.0 unx     9093 b- defN 23-May-24 09:14 chaine/_core/crf.pyx
+-rw-r--r--  2.0 unx   525023 b- defN 23-May-24 09:14 chaine/_core/crf.cpp
+drwxr-xr-x  2.0 unx        0 b- stor 23-May-24 09:14 chaine/_core/crfsuite/lib/
+drwxr-xr-x  2.0 unx        0 b- stor 23-May-24 09:14 chaine/_core/crfsuite/swig/
+drwxr-xr-x  2.0 unx        0 b- stor 23-May-24 09:14 chaine/_core/crfsuite/include/
+-rwxr-xr-x  2.0 unx     1535 b- defN 23-May-24 09:14 chaine/_core/crfsuite/COPYING
+-rwxr-xr-x  2.0 unx     7973 b- defN 23-May-24 09:14 chaine/_core/crfsuite/README
+drwxr-xr-x  2.0 unx        0 b- stor 23-May-24 09:14 chaine/_core/crfsuite/lib/crf/
+drwxr-xr-x  2.0 unx        0 b- stor 23-May-24 09:14 chaine/_core/crfsuite/lib/cqdb/
+drwxr-xr-x  2.0 unx        0 b- stor 23-May-24 09:14 chaine/_core/crfsuite/lib/crf/src/
+-rwxr-xr-x  2.0 unx    10019 b- defN 23-May-24 09:14 chaine/_core/crfsuite/lib/crf/src/params.c
+-rwxr-xr-x  2.0 unx     9913 b- defN 23-May-24 09:14 chaine/_core/crfsuite/lib/crf/src/vecmath.h
+-rwxr-xr-x  2.0 unx    33987 b- defN 23-May-24 09:14 chaine/_core/crfsuite/lib/crf/src/rumavl.c
+-rwxr-xr-x  2.0 unx     2063 b- defN 23-May-24 09:14 chaine/_core/crfsuite/lib/crf/src/logging.h
+-rwxr-xr-x  2.0 unx    26694 b- defN 23-May-24 09:14 chaine/_core/crfsuite/lib/crf/src/crf1d_model.c
+-rwxr-xr-x  2.0 unx    29211 b- defN 23-May-24 09:14 chaine/_core/crfsuite/lib/crf/src/json.c
+-rwxr-xr-x  2.0 unx     2865 b- defN 23-May-24 09:14 chaine/_core/crfsuite/lib/crf/src/holdout.c
+-rwxr-xr-x  2.0 unx     2640 b- defN 23-May-24 09:14 chaine/_core/crfsuite/lib/crf/src/logging.c
+-rwxr-xr-x  2.0 unx    16748 b- defN 23-May-24 09:14 chaine/_core/crfsuite/lib/crf/src/crf1d_tag.c
+-rwxr-xr-x  2.0 unx    10712 b- defN 23-May-24 09:14 chaine/_core/crfsuite/lib/crf/src/crf1d.h
+-rwxr-xr-x  2.0 unx     3254 b- defN 23-May-24 09:14 chaine/_core/crfsuite/lib/crf/src/dataset.c
+-rwxr-xr-x  2.0 unx    10858 b- defN 23-May-24 09:14 chaine/_core/crfsuite/lib/crf/src/train_arow.c
+-rwxr-xr-x  2.0 unx    11565 b- defN 23-May-24 09:14 chaine/_core/crfsuite/lib/crf/src/train_passive_aggressive.c
+-rwxr-xr-x  2.0 unx    13947 b- defN 23-May-24 09:14 chaine/_core/crfsuite/lib/crf/src/train_l2sgd.c
+-rwxr-xr-x  2.0 unx     3754 b- defN 23-May-24 09:14 chaine/_core/crfsuite/lib/crf/src/params.h
+-rwxr-xr-x  2.0 unx    14080 b- defN 23-May-24 09:14 chaine/_core/crfsuite/lib/crf/src/crfsuite.c
+-rwxr-xr-x  2.0 unx     3389 b- defN 23-May-24 09:14 chaine/_core/crfsuite/lib/crf/src/json.h
+-rwxr-xr-x  2.0 unx     9447 b- defN 23-May-24 09:14 chaine/_core/crfsuite/lib/crf/src/train_lbfgs.c
+-rwxr-xr-x  2.0 unx     6704 b- defN 23-May-24 09:14 chaine/_core/crfsuite/lib/crf/src/train_averaged_perceptron.c
+-rwxr-xr-x  2.0 unx    10589 b- defN 23-May-24 09:14 chaine/_core/crfsuite/lib/crf/src/crf1d_feature.c
+-rwxr-xr-x  2.0 unx    29224 b- defN 23-May-24 09:14 chaine/_core/crfsuite/lib/crf/src/crf1d_encode.c
+-rwxr-xr-x  2.0 unx    22618 b- defN 23-May-24 09:14 chaine/_core/crfsuite/lib/crf/src/crf1d_context.c
+-rwxr-xr-x  2.0 unx     1983 b- defN 23-May-24 09:14 chaine/_core/crfsuite/lib/crf/src/quark.h
+-rwxr-xr-x  2.0 unx     7547 b- defN 23-May-24 09:14 chaine/_core/crfsuite/lib/crf/src/crfsuite_internal.h
+-rwxr-xr-x  2.0 unx     4842 b- defN 23-May-24 09:14 chaine/_core/crfsuite/lib/crf/src/quark.c
+-rwxr-xr-x  2.0 unx     8549 b- defN 23-May-24 09:14 chaine/_core/crfsuite/lib/crf/src/crfsuite_train.c
+-rwxr-xr-x  2.0 unx     5536 b- defN 23-May-24 09:14 chaine/_core/crfsuite/lib/crf/src/rumavl.h
+-rwxr-xr-x  2.0 unx     3878 b- defN 23-May-24 09:14 chaine/_core/crfsuite/lib/crf/src/dictionary.c
+drwxr-xr-x  2.0 unx        0 b- stor 23-May-24 09:14 chaine/_core/crfsuite/lib/cqdb/src/
+drwxr-xr-x  2.0 unx        0 b- stor 23-May-24 09:14 chaine/_core/crfsuite/lib/cqdb/include/
+-rwxr-xr-x  2.0 unx     1573 b- defN 23-May-24 09:14 chaine/_core/crfsuite/lib/cqdb/COPYING
+-rwxr-xr-x  2.0 unx    17268 b- defN 23-May-24 09:14 chaine/_core/crfsuite/lib/cqdb/src/cqdb.c
+-rwxr-xr-x  2.0 unx    36564 b- defN 23-May-24 09:14 chaine/_core/crfsuite/lib/cqdb/src/lookup3.c
+-rwxr-xr-x  2.0 unx     4982 b- defN 23-May-24 09:14 chaine/_core/crfsuite/lib/cqdb/src/main.c
+-rwxr-xr-x  2.0 unx    18728 b- defN 23-May-24 09:14 chaine/_core/crfsuite/lib/cqdb/include/cqdb.h
+-rwxr-xr-x  2.0 unx       24 b- defN 23-May-24 09:14 chaine/_core/crfsuite/swig/crfsuite.cpp
+-rwxr-xr-x  2.0 unx    14098 b- defN 23-May-24 09:14 chaine/_core/crfsuite/include/crfsuite_api.hpp
+-rwxr-xr-x  2.0 unx    38631 b- defN 23-May-24 09:14 chaine/_core/crfsuite/include/crfsuite.h
+-rwxr-xr-x  2.0 unx     2238 b- defN 23-May-24 09:14 chaine/_core/crfsuite/include/os.h
+-rwxr-xr-x  2.0 unx    18593 b- defN 23-May-24 09:14 chaine/_core/crfsuite/include/crfsuite.hpp
+drwxr-xr-x  2.0 unx        0 b- stor 23-May-24 09:14 chaine/_core/liblbfgs/lib/
+drwxr-xr-x  2.0 unx        0 b- stor 23-May-24 09:14 chaine/_core/liblbfgs/include/
+-rwxr-xr-x  2.0 unx     1113 b- defN 23-May-24 09:14 chaine/_core/liblbfgs/COPYING
+-rwxr-xr-x  2.0 unx     2645 b- defN 23-May-24 09:14 chaine/_core/liblbfgs/README
+-rwxr-xr-x  2.0 unx    43705 b- defN 23-May-24 09:14 chaine/_core/liblbfgs/lib/lbfgs.c
+-rwxr-xr-x  2.0 unx    13356 b- defN 23-May-24 09:14 chaine/_core/liblbfgs/lib/arithmetic_sse_float.h
+-rwxr-xr-x  2.0 unx     3427 b- defN 23-May-24 09:14 chaine/_core/liblbfgs/lib/arithmetic_ansi.h
+-rwxr-xr-x  2.0 unx    13805 b- defN 23-May-24 09:14 chaine/_core/liblbfgs/lib/arithmetic_sse_double.h
+-rwxr-xr-x  2.0 unx    32846 b- defN 23-May-24 09:14 chaine/_core/liblbfgs/include/lbfgs.h
+-rwxr-xr-x  2.0 unx     3716 b- defN 23-May-24 09:14 chaine/optimization/metrics.py
+-rwxr-xr-x  2.0 unx      257 b- defN 23-May-24 09:14 chaine/optimization/__init__.py
+-rwxr-xr-x  2.0 unx     3297 b- defN 23-May-24 09:14 chaine/optimization/utils.py
+-rwxr-xr-x  2.0 unx     3566 b- defN 23-May-24 09:14 chaine/optimization/trial.py
+-rwxr-xr-x  2.0 unx    17797 b- defN 23-May-24 09:14 chaine/optimization/spaces.py
+85 files, 3594845 bytes uncompressed, 1108868 bytes compressed:  69.2%
```

## zipnote {}

```diff
@@ -1,397 +1,256 @@
-Filename: chaine/__init__.py
-Comment: 
-
-Filename: chaine/_core/crf.cpp
-Comment: 
-
-Filename: chaine/_core/crf.pyx
-Comment: 
-
-Filename: chaine/_core/crfsuite/COPYING
-Comment: 
-
-Filename: chaine/_core/crfsuite/include/crfsuite.h
-Comment: 
-
-Filename: chaine/_core/crfsuite/include/crfsuite.hpp
-Comment: 
-
-Filename: chaine/_core/crfsuite/include/crfsuite_api.hpp
-Comment: 
-
-Filename: chaine/_core/crfsuite/include/os.h
-Comment: 
-
-Filename: chaine/_core/crfsuite/lib/cqdb/COPYING
-Comment: 
-
-Filename: chaine/_core/crfsuite/lib/cqdb/include/cqdb.h
-Comment: 
-
-Filename: chaine/_core/crfsuite/lib/cqdb/src/cqdb.c
-Comment: 
-
-Filename: chaine/_core/crfsuite/lib/cqdb/src/lookup3.c
-Comment: 
-
-Filename: chaine/_core/crfsuite/lib/cqdb/src/main.c
-Comment: 
-
-Filename: chaine/_core/crfsuite/lib/crf/src/crf1d.h
-Comment: 
-
-Filename: chaine/_core/crfsuite/lib/crf/src/crf1d_context.c
-Comment: 
-
-Filename: chaine/_core/crfsuite/lib/crf/src/crf1d_encode.c
-Comment: 
-
-Filename: chaine/_core/crfsuite/lib/crf/src/crf1d_feature.c
-Comment: 
-
-Filename: chaine/_core/crfsuite/lib/crf/src/crf1d_model.c
-Comment: 
-
-Filename: chaine/_core/crfsuite/lib/crf/src/crf1d_tag.c
-Comment: 
-
-Filename: chaine/_core/crfsuite/lib/crf/src/crfsuite.c
-Comment: 
-
-Filename: chaine/_core/crfsuite/lib/crf/src/crfsuite_internal.h
-Comment: 
-
-Filename: chaine/_core/crfsuite/lib/crf/src/crfsuite_train.c
-Comment: 
-
-Filename: chaine/_core/crfsuite/lib/crf/src/dataset.c
-Comment: 
-
-Filename: chaine/_core/crfsuite/lib/crf/src/dictionary.c
+Filename: chaine-3.11.0.dist-info/
 Comment: 
 
-Filename: chaine/_core/crfsuite/lib/crf/src/holdout.c
+Filename: chaine/
 Comment: 
 
-Filename: chaine/_core/crfsuite/lib/crf/src/json.c
+Filename: chaine.libs/
 Comment: 
 
-Filename: chaine/_core/crfsuite/lib/crf/src/json.h
+Filename: chaine-3.11.0.dist-info/RECORD
 Comment: 
 
-Filename: chaine/_core/crfsuite/lib/crf/src/logging.c
+Filename: chaine-3.11.0.dist-info/WHEEL
 Comment: 
 
-Filename: chaine/_core/crfsuite/lib/crf/src/logging.h
+Filename: chaine-3.11.0.dist-info/METADATA
 Comment: 
 
-Filename: chaine/_core/crfsuite/lib/crf/src/params.c
-Comment: 
-
-Filename: chaine/_core/crfsuite/lib/crf/src/params.h
-Comment: 
-
-Filename: chaine/_core/crfsuite/lib/crf/src/quark.c
-Comment: 
-
-Filename: chaine/_core/crfsuite/lib/crf/src/quark.h
+Filename: chaine/_core/
 Comment: 
 
-Filename: chaine/_core/crfsuite/lib/crf/src/rumavl.c
+Filename: chaine/optimization/
 Comment: 
 
-Filename: chaine/_core/crfsuite/lib/crf/src/rumavl.h
+Filename: chaine/crf.py
 Comment: 
 
-Filename: chaine/_core/crfsuite/lib/crf/src/train_arow.c
+Filename: chaine/logging.py
 Comment: 
 
-Filename: chaine/_core/crfsuite/lib/crf/src/train_averaged_perceptron.c
+Filename: chaine/typing.py
 Comment: 
 
-Filename: chaine/_core/crfsuite/lib/crf/src/train_l2sgd.c
+Filename: chaine/__init__.py
 Comment: 
 
-Filename: chaine/_core/crfsuite/lib/crf/src/train_lbfgs.c
+Filename: chaine/validation.py
 Comment: 
 
-Filename: chaine/_core/crfsuite/lib/crf/src/train_passive_aggressive.c
+Filename: chaine/training.py
 Comment: 
 
-Filename: chaine/_core/crfsuite/lib/crf/src/vecmath.h
+Filename: chaine/_core/crfsuite/
 Comment: 
 
-Filename: chaine/_core/crfsuite/README
+Filename: chaine/_core/liblbfgs/
 Comment: 
 
-Filename: chaine/_core/crfsuite/swig/crfsuite.cpp
+Filename: chaine/_core/crf.cpython-311-i386-linux-gnu.so
 Comment: 
 
 Filename: chaine/_core/crfsuite_api.pxd
 Comment: 
 
-Filename: chaine/_core/liblbfgs/COPYING
-Comment: 
-
-Filename: chaine/_core/liblbfgs/include/lbfgs.h
-Comment: 
-
-Filename: chaine/_core/liblbfgs/lib/arithmetic_ansi.h
-Comment: 
-
-Filename: chaine/_core/liblbfgs/lib/arithmetic_sse_double.h
-Comment: 
-
-Filename: chaine/_core/liblbfgs/lib/arithmetic_sse_float.h
-Comment: 
-
-Filename: chaine/_core/liblbfgs/lib/lbfgs.c
-Comment: 
-
-Filename: chaine/_core/liblbfgs/README
+Filename: chaine/_core/trainer_wrapper.cpp
 Comment: 
 
 Filename: chaine/_core/tagger_wrapper.hpp
 Comment: 
 
-Filename: chaine/_core/trainer_wrapper.cpp
-Comment: 
-
 Filename: chaine/_core/trainer_wrapper.hpp
 Comment: 
 
-Filename: chaine/crf.py
-Comment: 
-
-Filename: chaine/logging.py
-Comment: 
-
-Filename: chaine/optimization/__init__.py
-Comment: 
-
-Filename: chaine/optimization/metrics.py
-Comment: 
-
-Filename: chaine/optimization/spaces.py
-Comment: 
-
-Filename: chaine/optimization/trial.py
-Comment: 
-
-Filename: chaine/optimization/utils.py
-Comment: 
-
-Filename: chaine/training.py
-Comment: 
-
-Filename: chaine/typing.py
-Comment: 
-
-Filename: chaine/validation.py
-Comment: 
-
-Filename: chaine/crf.py
+Filename: chaine/_core/crf.pyx
 Comment: 
 
-Filename: chaine/logging.py
+Filename: chaine/_core/crf.cpp
 Comment: 
 
-Filename: chaine/training.py
+Filename: chaine/_core/crfsuite/lib/
 Comment: 
 
-Filename: chaine/typing.py
+Filename: chaine/_core/crfsuite/swig/
 Comment: 
 
-Filename: chaine/validation.py
+Filename: chaine/_core/crfsuite/include/
 Comment: 
 
-Filename: chaine/__init__.py
-Comment: 
-
-Filename: chaine/optimization/metrics.py
+Filename: chaine/_core/crfsuite/COPYING
 Comment: 
 
-Filename: chaine/optimization/spaces.py
+Filename: chaine/_core/crfsuite/README
 Comment: 
 
-Filename: chaine/optimization/trial.py
+Filename: chaine/_core/crfsuite/lib/crf/
 Comment: 
 
-Filename: chaine/optimization/utils.py
+Filename: chaine/_core/crfsuite/lib/cqdb/
 Comment: 
 
-Filename: chaine/optimization/__init__.py
+Filename: chaine/_core/crfsuite/lib/crf/src/
 Comment: 
 
-Filename: chaine/_core/crf.cp311-win_amd64.pyd
+Filename: chaine/_core/crfsuite/lib/crf/src/params.c
 Comment: 
 
-Filename: chaine/_core/crf.cpp
+Filename: chaine/_core/crfsuite/lib/crf/src/vecmath.h
 Comment: 
 
-Filename: chaine/_core/crf.pyx
+Filename: chaine/_core/crfsuite/lib/crf/src/rumavl.c
 Comment: 
 
-Filename: chaine/_core/crfsuite_api.pxd
+Filename: chaine/_core/crfsuite/lib/crf/src/logging.h
 Comment: 
 
-Filename: chaine/_core/tagger_wrapper.hpp
+Filename: chaine/_core/crfsuite/lib/crf/src/crf1d_model.c
 Comment: 
 
-Filename: chaine/_core/trainer_wrapper.cpp
+Filename: chaine/_core/crfsuite/lib/crf/src/json.c
 Comment: 
 
-Filename: chaine/_core/trainer_wrapper.hpp
+Filename: chaine/_core/crfsuite/lib/crf/src/holdout.c
 Comment: 
 
-Filename: chaine/_core/crfsuite/COPYING
+Filename: chaine/_core/crfsuite/lib/crf/src/logging.c
 Comment: 
 
-Filename: chaine/_core/crfsuite/README
+Filename: chaine/_core/crfsuite/lib/crf/src/crf1d_tag.c
 Comment: 
 
-Filename: chaine/_core/crfsuite/include/crfsuite.h
+Filename: chaine/_core/crfsuite/lib/crf/src/crf1d.h
 Comment: 
 
-Filename: chaine/_core/crfsuite/include/crfsuite.hpp
+Filename: chaine/_core/crfsuite/lib/crf/src/dataset.c
 Comment: 
 
-Filename: chaine/_core/crfsuite/include/crfsuite_api.hpp
+Filename: chaine/_core/crfsuite/lib/crf/src/train_arow.c
 Comment: 
 
-Filename: chaine/_core/crfsuite/include/os.h
+Filename: chaine/_core/crfsuite/lib/crf/src/train_passive_aggressive.c
 Comment: 
 
-Filename: chaine/_core/crfsuite/lib/cqdb/COPYING
+Filename: chaine/_core/crfsuite/lib/crf/src/train_l2sgd.c
 Comment: 
 
-Filename: chaine/_core/crfsuite/lib/cqdb/include/cqdb.h
+Filename: chaine/_core/crfsuite/lib/crf/src/params.h
 Comment: 
 
-Filename: chaine/_core/crfsuite/lib/cqdb/src/cqdb.c
+Filename: chaine/_core/crfsuite/lib/crf/src/crfsuite.c
 Comment: 
 
-Filename: chaine/_core/crfsuite/lib/cqdb/src/lookup3.c
+Filename: chaine/_core/crfsuite/lib/crf/src/json.h
 Comment: 
 
-Filename: chaine/_core/crfsuite/lib/cqdb/src/main.c
+Filename: chaine/_core/crfsuite/lib/crf/src/train_lbfgs.c
 Comment: 
 
-Filename: chaine/_core/crfsuite/lib/crf/src/crf1d.h
+Filename: chaine/_core/crfsuite/lib/crf/src/train_averaged_perceptron.c
 Comment: 
 
-Filename: chaine/_core/crfsuite/lib/crf/src/crf1d_context.c
+Filename: chaine/_core/crfsuite/lib/crf/src/crf1d_feature.c
 Comment: 
 
 Filename: chaine/_core/crfsuite/lib/crf/src/crf1d_encode.c
 Comment: 
 
-Filename: chaine/_core/crfsuite/lib/crf/src/crf1d_feature.c
-Comment: 
-
-Filename: chaine/_core/crfsuite/lib/crf/src/crf1d_model.c
+Filename: chaine/_core/crfsuite/lib/crf/src/crf1d_context.c
 Comment: 
 
-Filename: chaine/_core/crfsuite/lib/crf/src/crf1d_tag.c
+Filename: chaine/_core/crfsuite/lib/crf/src/quark.h
 Comment: 
 
-Filename: chaine/_core/crfsuite/lib/crf/src/crfsuite.c
+Filename: chaine/_core/crfsuite/lib/crf/src/crfsuite_internal.h
 Comment: 
 
-Filename: chaine/_core/crfsuite/lib/crf/src/crfsuite_internal.h
+Filename: chaine/_core/crfsuite/lib/crf/src/quark.c
 Comment: 
 
 Filename: chaine/_core/crfsuite/lib/crf/src/crfsuite_train.c
 Comment: 
 
-Filename: chaine/_core/crfsuite/lib/crf/src/dataset.c
+Filename: chaine/_core/crfsuite/lib/crf/src/rumavl.h
 Comment: 
 
 Filename: chaine/_core/crfsuite/lib/crf/src/dictionary.c
 Comment: 
 
-Filename: chaine/_core/crfsuite/lib/crf/src/holdout.c
+Filename: chaine/_core/crfsuite/lib/cqdb/src/
 Comment: 
 
-Filename: chaine/_core/crfsuite/lib/crf/src/json.c
+Filename: chaine/_core/crfsuite/lib/cqdb/include/
 Comment: 
 
-Filename: chaine/_core/crfsuite/lib/crf/src/json.h
+Filename: chaine/_core/crfsuite/lib/cqdb/COPYING
 Comment: 
 
-Filename: chaine/_core/crfsuite/lib/crf/src/logging.c
+Filename: chaine/_core/crfsuite/lib/cqdb/src/cqdb.c
 Comment: 
 
-Filename: chaine/_core/crfsuite/lib/crf/src/logging.h
+Filename: chaine/_core/crfsuite/lib/cqdb/src/lookup3.c
 Comment: 
 
-Filename: chaine/_core/crfsuite/lib/crf/src/params.c
+Filename: chaine/_core/crfsuite/lib/cqdb/src/main.c
 Comment: 
 
-Filename: chaine/_core/crfsuite/lib/crf/src/params.h
+Filename: chaine/_core/crfsuite/lib/cqdb/include/cqdb.h
 Comment: 
 
-Filename: chaine/_core/crfsuite/lib/crf/src/quark.c
+Filename: chaine/_core/crfsuite/swig/crfsuite.cpp
 Comment: 
 
-Filename: chaine/_core/crfsuite/lib/crf/src/quark.h
+Filename: chaine/_core/crfsuite/include/crfsuite_api.hpp
 Comment: 
 
-Filename: chaine/_core/crfsuite/lib/crf/src/rumavl.c
+Filename: chaine/_core/crfsuite/include/crfsuite.h
 Comment: 
 
-Filename: chaine/_core/crfsuite/lib/crf/src/rumavl.h
+Filename: chaine/_core/crfsuite/include/os.h
 Comment: 
 
-Filename: chaine/_core/crfsuite/lib/crf/src/train_arow.c
+Filename: chaine/_core/crfsuite/include/crfsuite.hpp
 Comment: 
 
-Filename: chaine/_core/crfsuite/lib/crf/src/train_averaged_perceptron.c
+Filename: chaine/_core/liblbfgs/lib/
 Comment: 
 
-Filename: chaine/_core/crfsuite/lib/crf/src/train_l2sgd.c
+Filename: chaine/_core/liblbfgs/include/
 Comment: 
 
-Filename: chaine/_core/crfsuite/lib/crf/src/train_lbfgs.c
+Filename: chaine/_core/liblbfgs/COPYING
 Comment: 
 
-Filename: chaine/_core/crfsuite/lib/crf/src/train_passive_aggressive.c
+Filename: chaine/_core/liblbfgs/README
 Comment: 
 
-Filename: chaine/_core/crfsuite/lib/crf/src/vecmath.h
+Filename: chaine/_core/liblbfgs/lib/lbfgs.c
 Comment: 
 
-Filename: chaine/_core/crfsuite/swig/crfsuite.cpp
+Filename: chaine/_core/liblbfgs/lib/arithmetic_sse_float.h
 Comment: 
 
-Filename: chaine/_core/liblbfgs/COPYING
+Filename: chaine/_core/liblbfgs/lib/arithmetic_ansi.h
 Comment: 
 
-Filename: chaine/_core/liblbfgs/README
+Filename: chaine/_core/liblbfgs/lib/arithmetic_sse_double.h
 Comment: 
 
 Filename: chaine/_core/liblbfgs/include/lbfgs.h
 Comment: 
 
-Filename: chaine/_core/liblbfgs/lib/arithmetic_ansi.h
-Comment: 
-
-Filename: chaine/_core/liblbfgs/lib/arithmetic_sse_double.h
-Comment: 
-
-Filename: chaine/_core/liblbfgs/lib/arithmetic_sse_float.h
+Filename: chaine/optimization/metrics.py
 Comment: 
 
-Filename: chaine/_core/liblbfgs/lib/lbfgs.c
+Filename: chaine/optimization/__init__.py
 Comment: 
 
-Filename: chaine-2.1.0.dist-info/METADATA
+Filename: chaine/optimization/utils.py
 Comment: 
 
-Filename: chaine-2.1.0.dist-info/WHEEL
+Filename: chaine/optimization/trial.py
 Comment: 
 
-Filename: chaine-2.1.0.dist-info/RECORD
+Filename: chaine/optimization/spaces.py
 Comment: 
 
 Zip file comment:
```

## filetype from file(1)

```diff
@@ -1 +1 @@
-Zip archive data, at least v2.0 to extract, compression method=deflate
+Zip archive data, at least v2.0 to extract, compression method=store
```

## chaine/__init__.py

 * *Ordering differences only*

```diff
@@ -1,2 +1,2 @@
-from chaine.crf import HyperparameterOptimizer, Model, Trainer
-from chaine.training import train
+from chaine.crf import HyperparameterOptimizer, Model, Trainer
+from chaine.training import train
```

## chaine/_core/crf.cpp

 * *Ordering differences only*

```diff
@@ -1,13255 +1,13255 @@
-/* Generated by Cython 0.29.32 */
-
-/* BEGIN: Cython Metadata
-{
-    "distutils": {
-        "depends": [],
-        "language": "c++",
-        "name": "crf",
-        "sources": [
-            "/home/severin/git/chaine/chaine/_core/crf.pyx"
-        ]
-    },
-    "module_name": "crf"
-}
-END: Cython Metadata */
-
-#ifndef PY_SSIZE_T_CLEAN
-#define PY_SSIZE_T_CLEAN
-#endif /* PY_SSIZE_T_CLEAN */
-#include "Python.h"
-#ifndef Py_PYTHON_H
-    #error Python headers needed to compile C extensions, please install development version of Python.
-#elif PY_VERSION_HEX < 0x02060000 || (0x03000000 <= PY_VERSION_HEX && PY_VERSION_HEX < 0x03030000)
-    #error Cython requires Python 2.6+ or Python 3.3+.
-#else
-#define CYTHON_ABI "0_29_32"
-#define CYTHON_HEX_VERSION 0x001D20F0
-#define CYTHON_FUTURE_DIVISION 0
-#include <stddef.h>
-#ifndef offsetof
-  #define offsetof(type, member) ( (size_t) & ((type*)0) -> member )
-#endif
-#if !defined(WIN32) && !defined(MS_WINDOWS)
-  #ifndef __stdcall
-    #define __stdcall
-  #endif
-  #ifndef __cdecl
-    #define __cdecl
-  #endif
-  #ifndef __fastcall
-    #define __fastcall
-  #endif
-#endif
-#ifndef DL_IMPORT
-  #define DL_IMPORT(t) t
-#endif
-#ifndef DL_EXPORT
-  #define DL_EXPORT(t) t
-#endif
-#define __PYX_COMMA ,
-#ifndef HAVE_LONG_LONG
-  #if PY_VERSION_HEX >= 0x02070000
-    #define HAVE_LONG_LONG
-  #endif
-#endif
-#ifndef PY_LONG_LONG
-  #define PY_LONG_LONG LONG_LONG
-#endif
-#ifndef Py_HUGE_VAL
-  #define Py_HUGE_VAL HUGE_VAL
-#endif
-#ifdef PYPY_VERSION
-  #define CYTHON_COMPILING_IN_PYPY 1
-  #define CYTHON_COMPILING_IN_PYSTON 0
-  #define CYTHON_COMPILING_IN_CPYTHON 0
-  #define CYTHON_COMPILING_IN_NOGIL 0
-  #undef CYTHON_USE_TYPE_SLOTS
-  #define CYTHON_USE_TYPE_SLOTS 0
-  #undef CYTHON_USE_PYTYPE_LOOKUP
-  #define CYTHON_USE_PYTYPE_LOOKUP 0
-  #if PY_VERSION_HEX < 0x03050000
-    #undef CYTHON_USE_ASYNC_SLOTS
-    #define CYTHON_USE_ASYNC_SLOTS 0
-  #elif !defined(CYTHON_USE_ASYNC_SLOTS)
-    #define CYTHON_USE_ASYNC_SLOTS 1
-  #endif
-  #undef CYTHON_USE_PYLIST_INTERNALS
-  #define CYTHON_USE_PYLIST_INTERNALS 0
-  #undef CYTHON_USE_UNICODE_INTERNALS
-  #define CYTHON_USE_UNICODE_INTERNALS 0
-  #undef CYTHON_USE_UNICODE_WRITER
-  #define CYTHON_USE_UNICODE_WRITER 0
-  #undef CYTHON_USE_PYLONG_INTERNALS
-  #define CYTHON_USE_PYLONG_INTERNALS 0
-  #undef CYTHON_AVOID_BORROWED_REFS
-  #define CYTHON_AVOID_BORROWED_REFS 1
-  #undef CYTHON_ASSUME_SAFE_MACROS
-  #define CYTHON_ASSUME_SAFE_MACROS 0
-  #undef CYTHON_UNPACK_METHODS
-  #define CYTHON_UNPACK_METHODS 0
-  #undef CYTHON_FAST_THREAD_STATE
-  #define CYTHON_FAST_THREAD_STATE 0
-  #undef CYTHON_FAST_PYCALL
-  #define CYTHON_FAST_PYCALL 0
-  #undef CYTHON_PEP489_MULTI_PHASE_INIT
-  #define CYTHON_PEP489_MULTI_PHASE_INIT 0
-  #undef CYTHON_USE_TP_FINALIZE
-  #define CYTHON_USE_TP_FINALIZE 0
-  #undef CYTHON_USE_DICT_VERSIONS
-  #define CYTHON_USE_DICT_VERSIONS 0
-  #undef CYTHON_USE_EXC_INFO_STACK
-  #define CYTHON_USE_EXC_INFO_STACK 0
-  #ifndef CYTHON_UPDATE_DESCRIPTOR_DOC
-    #define CYTHON_UPDATE_DESCRIPTOR_DOC (PYPY_VERSION_HEX >= 0x07030900)
-  #endif
-#elif defined(PYSTON_VERSION)
-  #define CYTHON_COMPILING_IN_PYPY 0
-  #define CYTHON_COMPILING_IN_PYSTON 1
-  #define CYTHON_COMPILING_IN_CPYTHON 0
-  #define CYTHON_COMPILING_IN_NOGIL 0
-  #ifndef CYTHON_USE_TYPE_SLOTS
-    #define CYTHON_USE_TYPE_SLOTS 1
-  #endif
-  #undef CYTHON_USE_PYTYPE_LOOKUP
-  #define CYTHON_USE_PYTYPE_LOOKUP 0
-  #undef CYTHON_USE_ASYNC_SLOTS
-  #define CYTHON_USE_ASYNC_SLOTS 0
-  #undef CYTHON_USE_PYLIST_INTERNALS
-  #define CYTHON_USE_PYLIST_INTERNALS 0
-  #ifndef CYTHON_USE_UNICODE_INTERNALS
-    #define CYTHON_USE_UNICODE_INTERNALS 1
-  #endif
-  #undef CYTHON_USE_UNICODE_WRITER
-  #define CYTHON_USE_UNICODE_WRITER 0
-  #undef CYTHON_USE_PYLONG_INTERNALS
-  #define CYTHON_USE_PYLONG_INTERNALS 0
-  #ifndef CYTHON_AVOID_BORROWED_REFS
-    #define CYTHON_AVOID_BORROWED_REFS 0
-  #endif
-  #ifndef CYTHON_ASSUME_SAFE_MACROS
-    #define CYTHON_ASSUME_SAFE_MACROS 1
-  #endif
-  #ifndef CYTHON_UNPACK_METHODS
-    #define CYTHON_UNPACK_METHODS 1
-  #endif
-  #undef CYTHON_FAST_THREAD_STATE
-  #define CYTHON_FAST_THREAD_STATE 0
-  #undef CYTHON_FAST_PYCALL
-  #define CYTHON_FAST_PYCALL 0
-  #undef CYTHON_PEP489_MULTI_PHASE_INIT
-  #define CYTHON_PEP489_MULTI_PHASE_INIT 0
-  #undef CYTHON_USE_TP_FINALIZE
-  #define CYTHON_USE_TP_FINALIZE 0
-  #undef CYTHON_USE_DICT_VERSIONS
-  #define CYTHON_USE_DICT_VERSIONS 0
-  #undef CYTHON_USE_EXC_INFO_STACK
-  #define CYTHON_USE_EXC_INFO_STACK 0
-  #ifndef CYTHON_UPDATE_DESCRIPTOR_DOC
-    #define CYTHON_UPDATE_DESCRIPTOR_DOC 0
-  #endif
-#elif defined(PY_NOGIL)
-  #define CYTHON_COMPILING_IN_PYPY 0
-  #define CYTHON_COMPILING_IN_PYSTON 0
-  #define CYTHON_COMPILING_IN_CPYTHON 0
-  #define CYTHON_COMPILING_IN_NOGIL 1
-  #ifndef CYTHON_USE_TYPE_SLOTS
-    #define CYTHON_USE_TYPE_SLOTS 1
-  #endif
-  #undef CYTHON_USE_PYTYPE_LOOKUP
-  #define CYTHON_USE_PYTYPE_LOOKUP 0
-  #ifndef CYTHON_USE_ASYNC_SLOTS
-    #define CYTHON_USE_ASYNC_SLOTS 1
-  #endif
-  #undef CYTHON_USE_PYLIST_INTERNALS
-  #define CYTHON_USE_PYLIST_INTERNALS 0
-  #ifndef CYTHON_USE_UNICODE_INTERNALS
-    #define CYTHON_USE_UNICODE_INTERNALS 1
-  #endif
-  #undef CYTHON_USE_UNICODE_WRITER
-  #define CYTHON_USE_UNICODE_WRITER 0
-  #undef CYTHON_USE_PYLONG_INTERNALS
-  #define CYTHON_USE_PYLONG_INTERNALS 0
-  #ifndef CYTHON_AVOID_BORROWED_REFS
-    #define CYTHON_AVOID_BORROWED_REFS 0
-  #endif
-  #ifndef CYTHON_ASSUME_SAFE_MACROS
-    #define CYTHON_ASSUME_SAFE_MACROS 1
-  #endif
-  #ifndef CYTHON_UNPACK_METHODS
-    #define CYTHON_UNPACK_METHODS 1
-  #endif
-  #undef CYTHON_FAST_THREAD_STATE
-  #define CYTHON_FAST_THREAD_STATE 0
-  #undef CYTHON_FAST_PYCALL
-  #define CYTHON_FAST_PYCALL 0
-  #ifndef CYTHON_PEP489_MULTI_PHASE_INIT
-    #define CYTHON_PEP489_MULTI_PHASE_INIT 1
-  #endif
-  #ifndef CYTHON_USE_TP_FINALIZE
-    #define CYTHON_USE_TP_FINALIZE 1
-  #endif
-  #undef CYTHON_USE_DICT_VERSIONS
-  #define CYTHON_USE_DICT_VERSIONS 0
-  #undef CYTHON_USE_EXC_INFO_STACK
-  #define CYTHON_USE_EXC_INFO_STACK 0
-#else
-  #define CYTHON_COMPILING_IN_PYPY 0
-  #define CYTHON_COMPILING_IN_PYSTON 0
-  #define CYTHON_COMPILING_IN_CPYTHON 1
-  #define CYTHON_COMPILING_IN_NOGIL 0
-  #ifndef CYTHON_USE_TYPE_SLOTS
-    #define CYTHON_USE_TYPE_SLOTS 1
-  #endif
-  #if PY_VERSION_HEX < 0x02070000
-    #undef CYTHON_USE_PYTYPE_LOOKUP
-    #define CYTHON_USE_PYTYPE_LOOKUP 0
-  #elif !defined(CYTHON_USE_PYTYPE_LOOKUP)
-    #define CYTHON_USE_PYTYPE_LOOKUP 1
-  #endif
-  #if PY_MAJOR_VERSION < 3
-    #undef CYTHON_USE_ASYNC_SLOTS
-    #define CYTHON_USE_ASYNC_SLOTS 0
-  #elif !defined(CYTHON_USE_ASYNC_SLOTS)
-    #define CYTHON_USE_ASYNC_SLOTS 1
-  #endif
-  #if PY_VERSION_HEX < 0x02070000
-    #undef CYTHON_USE_PYLONG_INTERNALS
-    #define CYTHON_USE_PYLONG_INTERNALS 0
-  #elif !defined(CYTHON_USE_PYLONG_INTERNALS)
-    #define CYTHON_USE_PYLONG_INTERNALS 1
-  #endif
-  #ifndef CYTHON_USE_PYLIST_INTERNALS
-    #define CYTHON_USE_PYLIST_INTERNALS 1
-  #endif
-  #ifndef CYTHON_USE_UNICODE_INTERNALS
-    #define CYTHON_USE_UNICODE_INTERNALS 1
-  #endif
-  #if PY_VERSION_HEX < 0x030300F0 || PY_VERSION_HEX >= 0x030B00A2
-    #undef CYTHON_USE_UNICODE_WRITER
-    #define CYTHON_USE_UNICODE_WRITER 0
-  #elif !defined(CYTHON_USE_UNICODE_WRITER)
-    #define CYTHON_USE_UNICODE_WRITER 1
-  #endif
-  #ifndef CYTHON_AVOID_BORROWED_REFS
-    #define CYTHON_AVOID_BORROWED_REFS 0
-  #endif
-  #ifndef CYTHON_ASSUME_SAFE_MACROS
-    #define CYTHON_ASSUME_SAFE_MACROS 1
-  #endif
-  #ifndef CYTHON_UNPACK_METHODS
-    #define CYTHON_UNPACK_METHODS 1
-  #endif
-  #if PY_VERSION_HEX >= 0x030B00A4
-    #undef CYTHON_FAST_THREAD_STATE
-    #define CYTHON_FAST_THREAD_STATE 0
-  #elif !defined(CYTHON_FAST_THREAD_STATE)
-    #define CYTHON_FAST_THREAD_STATE 1
-  #endif
-  #ifndef CYTHON_FAST_PYCALL
-    #define CYTHON_FAST_PYCALL (PY_VERSION_HEX < 0x030A0000)
-  #endif
-  #ifndef CYTHON_PEP489_MULTI_PHASE_INIT
-    #define CYTHON_PEP489_MULTI_PHASE_INIT (PY_VERSION_HEX >= 0x03050000)
-  #endif
-  #ifndef CYTHON_USE_TP_FINALIZE
-    #define CYTHON_USE_TP_FINALIZE (PY_VERSION_HEX >= 0x030400a1)
-  #endif
-  #ifndef CYTHON_USE_DICT_VERSIONS
-    #define CYTHON_USE_DICT_VERSIONS (PY_VERSION_HEX >= 0x030600B1)
-  #endif
-  #if PY_VERSION_HEX >= 0x030B00A4
-    #undef CYTHON_USE_EXC_INFO_STACK
-    #define CYTHON_USE_EXC_INFO_STACK 0
-  #elif !defined(CYTHON_USE_EXC_INFO_STACK)
-    #define CYTHON_USE_EXC_INFO_STACK (PY_VERSION_HEX >= 0x030700A3)
-  #endif
-  #ifndef CYTHON_UPDATE_DESCRIPTOR_DOC
-    #define CYTHON_UPDATE_DESCRIPTOR_DOC 1
-  #endif
-#endif
-#if !defined(CYTHON_FAST_PYCCALL)
-#define CYTHON_FAST_PYCCALL  (CYTHON_FAST_PYCALL && PY_VERSION_HEX >= 0x030600B1)
-#endif
-#if CYTHON_USE_PYLONG_INTERNALS
-  #if PY_MAJOR_VERSION < 3
-    #include "longintrepr.h"
-  #endif
-  #undef SHIFT
-  #undef BASE
-  #undef MASK
-  #ifdef SIZEOF_VOID_P
-    enum { __pyx_check_sizeof_voidp = 1 / (int)(SIZEOF_VOID_P == sizeof(void*)) };
-  #endif
-#endif
-#ifndef __has_attribute
-  #define __has_attribute(x) 0
-#endif
-#ifndef __has_cpp_attribute
-  #define __has_cpp_attribute(x) 0
-#endif
-#ifndef CYTHON_RESTRICT
-  #if defined(__GNUC__)
-    #define CYTHON_RESTRICT __restrict__
-  #elif defined(_MSC_VER) && _MSC_VER >= 1400
-    #define CYTHON_RESTRICT __restrict
-  #elif defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
-    #define CYTHON_RESTRICT restrict
-  #else
-    #define CYTHON_RESTRICT
-  #endif
-#endif
-#ifndef CYTHON_UNUSED
-# if defined(__GNUC__)
-#   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
-#     define CYTHON_UNUSED __attribute__ ((__unused__))
-#   else
-#     define CYTHON_UNUSED
-#   endif
-# elif defined(__ICC) || (defined(__INTEL_COMPILER) && !defined(_MSC_VER))
-#   define CYTHON_UNUSED __attribute__ ((__unused__))
-# else
-#   define CYTHON_UNUSED
-# endif
-#endif
-#ifndef CYTHON_MAYBE_UNUSED_VAR
-#  if defined(__cplusplus)
-     template<class T> void CYTHON_MAYBE_UNUSED_VAR( const T& ) { }
-#  else
-#    define CYTHON_MAYBE_UNUSED_VAR(x) (void)(x)
-#  endif
-#endif
-#ifndef CYTHON_NCP_UNUSED
-# if CYTHON_COMPILING_IN_CPYTHON
-#  define CYTHON_NCP_UNUSED
-# else
-#  define CYTHON_NCP_UNUSED CYTHON_UNUSED
-# endif
-#endif
-#define __Pyx_void_to_None(void_result) ((void)(void_result), Py_INCREF(Py_None), Py_None)
-#ifdef _MSC_VER
-    #ifndef _MSC_STDINT_H_
-        #if _MSC_VER < 1300
-           typedef unsigned char     uint8_t;
-           typedef unsigned int      uint32_t;
-        #else
-           typedef unsigned __int8   uint8_t;
-           typedef unsigned __int32  uint32_t;
-        #endif
-    #endif
-#else
-   #include <stdint.h>
-#endif
-#ifndef CYTHON_FALLTHROUGH
-  #if defined(__cplusplus) && __cplusplus >= 201103L
-    #if __has_cpp_attribute(fallthrough)
-      #define CYTHON_FALLTHROUGH [[fallthrough]]
-    #elif __has_cpp_attribute(clang::fallthrough)
-      #define CYTHON_FALLTHROUGH [[clang::fallthrough]]
-    #elif __has_cpp_attribute(gnu::fallthrough)
-      #define CYTHON_FALLTHROUGH [[gnu::fallthrough]]
-    #endif
-  #endif
-  #ifndef CYTHON_FALLTHROUGH
-    #if __has_attribute(fallthrough)
-      #define CYTHON_FALLTHROUGH __attribute__((fallthrough))
-    #else
-      #define CYTHON_FALLTHROUGH
-    #endif
-  #endif
-  #if defined(__clang__ ) && defined(__apple_build_version__)
-    #if __apple_build_version__ < 7000000
-      #undef  CYTHON_FALLTHROUGH
-      #define CYTHON_FALLTHROUGH
-    #endif
-  #endif
-#endif
-
-#ifndef __cplusplus
-  #error "Cython files generated with the C++ option must be compiled with a C++ compiler."
-#endif
-#ifndef CYTHON_INLINE
-  #if defined(__clang__)
-    #define CYTHON_INLINE __inline__ __attribute__ ((__unused__))
-  #else
-    #define CYTHON_INLINE inline
-  #endif
-#endif
-template<typename T>
-void __Pyx_call_destructor(T& x) {
-    x.~T();
-}
-template<typename T>
-class __Pyx_FakeReference {
-  public:
-    __Pyx_FakeReference() : ptr(NULL) { }
-    __Pyx_FakeReference(const T& ref) : ptr(const_cast<T*>(&ref)) { }
-    T *operator->() { return ptr; }
-    T *operator&() { return ptr; }
-    operator T&() { return *ptr; }
-    template<typename U> bool operator ==(U other) { return *ptr == other; }
-    template<typename U> bool operator !=(U other) { return *ptr != other; }
-  private:
-    T *ptr;
-};
-
-#if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX < 0x02070600 && !defined(Py_OptimizeFlag)
-  #define Py_OptimizeFlag 0
-#endif
-#define __PYX_BUILD_PY_SSIZE_T "n"
-#define CYTHON_FORMAT_SSIZE_T "z"
-#if PY_MAJOR_VERSION < 3
-  #define __Pyx_BUILTIN_MODULE_NAME "__builtin__"
-  #define __Pyx_PyCode_New(a, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)\
-          PyCode_New(a+k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)
-  #define __Pyx_DefaultClassType PyClass_Type
-#else
-  #define __Pyx_BUILTIN_MODULE_NAME "builtins"
-  #define __Pyx_DefaultClassType PyType_Type
-#if PY_VERSION_HEX >= 0x030B00A1
-    static CYTHON_INLINE PyCodeObject* __Pyx_PyCode_New(int a, int k, int l, int s, int f,
-                                                    PyObject *code, PyObject *c, PyObject* n, PyObject *v,
-                                                    PyObject *fv, PyObject *cell, PyObject* fn,
-                                                    PyObject *name, int fline, PyObject *lnos) {
-        PyObject *kwds=NULL, *argcount=NULL, *posonlyargcount=NULL, *kwonlyargcount=NULL;
-        PyObject *nlocals=NULL, *stacksize=NULL, *flags=NULL, *replace=NULL, *call_result=NULL, *empty=NULL;
-        const char *fn_cstr=NULL;
-        const char *name_cstr=NULL;
-        PyCodeObject* co=NULL;
-        PyObject *type, *value, *traceback;
-        PyErr_Fetch(&type, &value, &traceback);
-        if (!(kwds=PyDict_New())) goto end;
-        if (!(argcount=PyLong_FromLong(a))) goto end;
-        if (PyDict_SetItemString(kwds, "co_argcount", argcount) != 0) goto end;
-        if (!(posonlyargcount=PyLong_FromLong(0))) goto end;
-        if (PyDict_SetItemString(kwds, "co_posonlyargcount", posonlyargcount) != 0) goto end;
-        if (!(kwonlyargcount=PyLong_FromLong(k))) goto end;
-        if (PyDict_SetItemString(kwds, "co_kwonlyargcount", kwonlyargcount) != 0) goto end;
-        if (!(nlocals=PyLong_FromLong(l))) goto end;
-        if (PyDict_SetItemString(kwds, "co_nlocals", nlocals) != 0) goto end;
-        if (!(stacksize=PyLong_FromLong(s))) goto end;
-        if (PyDict_SetItemString(kwds, "co_stacksize", stacksize) != 0) goto end;
-        if (!(flags=PyLong_FromLong(f))) goto end;
-        if (PyDict_SetItemString(kwds, "co_flags", flags) != 0) goto end;
-        if (PyDict_SetItemString(kwds, "co_code", code) != 0) goto end;
-        if (PyDict_SetItemString(kwds, "co_consts", c) != 0) goto end;
-        if (PyDict_SetItemString(kwds, "co_names", n) != 0) goto end;
-        if (PyDict_SetItemString(kwds, "co_varnames", v) != 0) goto end;
-        if (PyDict_SetItemString(kwds, "co_freevars", fv) != 0) goto end;
-        if (PyDict_SetItemString(kwds, "co_cellvars", cell) != 0) goto end;
-        if (PyDict_SetItemString(kwds, "co_linetable", lnos) != 0) goto end;
-        if (!(fn_cstr=PyUnicode_AsUTF8AndSize(fn, NULL))) goto end;
-        if (!(name_cstr=PyUnicode_AsUTF8AndSize(name, NULL))) goto end;
-        if (!(co = PyCode_NewEmpty(fn_cstr, name_cstr, fline))) goto end;
-        if (!(replace = PyObject_GetAttrString((PyObject*)co, "replace"))) goto cleanup_code_too;
-        if (!(empty = PyTuple_New(0))) goto cleanup_code_too; // unfortunately __pyx_empty_tuple isn't available here
-        if (!(call_result = PyObject_Call(replace, empty, kwds))) goto cleanup_code_too;
-        Py_XDECREF((PyObject*)co);
-        co = (PyCodeObject*)call_result;
-        call_result = NULL;
-        if (0) {
-            cleanup_code_too:
-            Py_XDECREF((PyObject*)co);
-            co = NULL;
-        }
-        end:
-        Py_XDECREF(kwds);
-        Py_XDECREF(argcount);
-        Py_XDECREF(posonlyargcount);
-        Py_XDECREF(kwonlyargcount);
-        Py_XDECREF(nlocals);
-        Py_XDECREF(stacksize);
-        Py_XDECREF(replace);
-        Py_XDECREF(call_result);
-        Py_XDECREF(empty);
-        if (type) {
-            PyErr_Restore(type, value, traceback);
-        }
-        return co;
-    }
-#else
-  #define __Pyx_PyCode_New(a, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)\
-          PyCode_New(a, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)
-#endif
-  #define __Pyx_DefaultClassType PyType_Type
-#endif
-#ifndef Py_TPFLAGS_CHECKTYPES
-  #define Py_TPFLAGS_CHECKTYPES 0
-#endif
-#ifndef Py_TPFLAGS_HAVE_INDEX
-  #define Py_TPFLAGS_HAVE_INDEX 0
-#endif
-#ifndef Py_TPFLAGS_HAVE_NEWBUFFER
-  #define Py_TPFLAGS_HAVE_NEWBUFFER 0
-#endif
-#ifndef Py_TPFLAGS_HAVE_FINALIZE
-  #define Py_TPFLAGS_HAVE_FINALIZE 0
-#endif
-#ifndef METH_STACKLESS
-  #define METH_STACKLESS 0
-#endif
-#if PY_VERSION_HEX <= 0x030700A3 || !defined(METH_FASTCALL)
-  #ifndef METH_FASTCALL
-     #define METH_FASTCALL 0x80
-  #endif
-  typedef PyObject *(*__Pyx_PyCFunctionFast) (PyObject *self, PyObject *const *args, Py_ssize_t nargs);
-  typedef PyObject *(*__Pyx_PyCFunctionFastWithKeywords) (PyObject *self, PyObject *const *args,
-                                                          Py_ssize_t nargs, PyObject *kwnames);
-#else
-  #define __Pyx_PyCFunctionFast _PyCFunctionFast
-  #define __Pyx_PyCFunctionFastWithKeywords _PyCFunctionFastWithKeywords
-#endif
-#if CYTHON_FAST_PYCCALL
-#define __Pyx_PyFastCFunction_Check(func)\
-    ((PyCFunction_Check(func) && (METH_FASTCALL == (PyCFunction_GET_FLAGS(func) & ~(METH_CLASS | METH_STATIC | METH_COEXIST | METH_KEYWORDS | METH_STACKLESS)))))
-#else
-#define __Pyx_PyFastCFunction_Check(func) 0
-#endif
-#if CYTHON_COMPILING_IN_PYPY && !defined(PyObject_Malloc)
-  #define PyObject_Malloc(s)   PyMem_Malloc(s)
-  #define PyObject_Free(p)     PyMem_Free(p)
-  #define PyObject_Realloc(p)  PyMem_Realloc(p)
-#endif
-#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX < 0x030400A1
-  #define PyMem_RawMalloc(n)           PyMem_Malloc(n)
-  #define PyMem_RawRealloc(p, n)       PyMem_Realloc(p, n)
-  #define PyMem_RawFree(p)             PyMem_Free(p)
-#endif
-#if CYTHON_COMPILING_IN_PYSTON
-  #define __Pyx_PyCode_HasFreeVars(co)  PyCode_HasFreeVars(co)
-  #define __Pyx_PyFrame_SetLineNumber(frame, lineno) PyFrame_SetLineNumber(frame, lineno)
-#else
-  #define __Pyx_PyCode_HasFreeVars(co)  (PyCode_GetNumFree(co) > 0)
-  #define __Pyx_PyFrame_SetLineNumber(frame, lineno)  (frame)->f_lineno = (lineno)
-#endif
-#if !CYTHON_FAST_THREAD_STATE || PY_VERSION_HEX < 0x02070000
-  #define __Pyx_PyThreadState_Current PyThreadState_GET()
-#elif PY_VERSION_HEX >= 0x03060000
-  #define __Pyx_PyThreadState_Current _PyThreadState_UncheckedGet()
-#elif PY_VERSION_HEX >= 0x03000000
-  #define __Pyx_PyThreadState_Current PyThreadState_GET()
-#else
-  #define __Pyx_PyThreadState_Current _PyThreadState_Current
-#endif
-#if PY_VERSION_HEX < 0x030700A2 && !defined(PyThread_tss_create) && !defined(Py_tss_NEEDS_INIT)
-#include "pythread.h"
-#define Py_tss_NEEDS_INIT 0
-typedef int Py_tss_t;
-static CYTHON_INLINE int PyThread_tss_create(Py_tss_t *key) {
-  *key = PyThread_create_key();
-  return 0;
-}
-static CYTHON_INLINE Py_tss_t * PyThread_tss_alloc(void) {
-  Py_tss_t *key = (Py_tss_t *)PyObject_Malloc(sizeof(Py_tss_t));
-  *key = Py_tss_NEEDS_INIT;
-  return key;
-}
-static CYTHON_INLINE void PyThread_tss_free(Py_tss_t *key) {
-  PyObject_Free(key);
-}
-static CYTHON_INLINE int PyThread_tss_is_created(Py_tss_t *key) {
-  return *key != Py_tss_NEEDS_INIT;
-}
-static CYTHON_INLINE void PyThread_tss_delete(Py_tss_t *key) {
-  PyThread_delete_key(*key);
-  *key = Py_tss_NEEDS_INIT;
-}
-static CYTHON_INLINE int PyThread_tss_set(Py_tss_t *key, void *value) {
-  return PyThread_set_key_value(*key, value);
-}
-static CYTHON_INLINE void * PyThread_tss_get(Py_tss_t *key) {
-  return PyThread_get_key_value(*key);
-}
-#endif
-#if CYTHON_COMPILING_IN_CPYTHON || defined(_PyDict_NewPresized)
-#define __Pyx_PyDict_NewPresized(n)  ((n <= 8) ? PyDict_New() : _PyDict_NewPresized(n))
-#else
-#define __Pyx_PyDict_NewPresized(n)  PyDict_New()
-#endif
-#if PY_MAJOR_VERSION >= 3 || CYTHON_FUTURE_DIVISION
-  #define __Pyx_PyNumber_Divide(x,y)         PyNumber_TrueDivide(x,y)
-  #define __Pyx_PyNumber_InPlaceDivide(x,y)  PyNumber_InPlaceTrueDivide(x,y)
-#else
-  #define __Pyx_PyNumber_Divide(x,y)         PyNumber_Divide(x,y)
-  #define __Pyx_PyNumber_InPlaceDivide(x,y)  PyNumber_InPlaceDivide(x,y)
-#endif
-#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX >= 0x030500A1 && CYTHON_USE_UNICODE_INTERNALS
-#define __Pyx_PyDict_GetItemStr(dict, name)  _PyDict_GetItem_KnownHash(dict, name, ((PyASCIIObject *) name)->hash)
-#else
-#define __Pyx_PyDict_GetItemStr(dict, name)  PyDict_GetItem(dict, name)
-#endif
-#if PY_VERSION_HEX > 0x03030000 && defined(PyUnicode_KIND)
-  #define CYTHON_PEP393_ENABLED 1
-  #if defined(PyUnicode_IS_READY)
-  #define __Pyx_PyUnicode_READY(op)       (likely(PyUnicode_IS_READY(op)) ?\
-                                              0 : _PyUnicode_Ready((PyObject *)(op)))
-  #else
-  #define __Pyx_PyUnicode_READY(op)       (0)
-  #endif
-  #define __Pyx_PyUnicode_GET_LENGTH(u)   PyUnicode_GET_LENGTH(u)
-  #define __Pyx_PyUnicode_READ_CHAR(u, i) PyUnicode_READ_CHAR(u, i)
-  #define __Pyx_PyUnicode_MAX_CHAR_VALUE(u)   PyUnicode_MAX_CHAR_VALUE(u)
-  #define __Pyx_PyUnicode_KIND(u)         PyUnicode_KIND(u)
-  #define __Pyx_PyUnicode_DATA(u)         PyUnicode_DATA(u)
-  #define __Pyx_PyUnicode_READ(k, d, i)   PyUnicode_READ(k, d, i)
-  #define __Pyx_PyUnicode_WRITE(k, d, i, ch)  PyUnicode_WRITE(k, d, i, ch)
-  #if defined(PyUnicode_IS_READY) && defined(PyUnicode_GET_SIZE)
-  #if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX >= 0x03090000
-  #define __Pyx_PyUnicode_IS_TRUE(u)      (0 != (likely(PyUnicode_IS_READY(u)) ? PyUnicode_GET_LENGTH(u) : ((PyCompactUnicodeObject *)(u))->wstr_length))
-  #else
-  #define __Pyx_PyUnicode_IS_TRUE(u)      (0 != (likely(PyUnicode_IS_READY(u)) ? PyUnicode_GET_LENGTH(u) : PyUnicode_GET_SIZE(u)))
-  #endif
-  #else
-  #define __Pyx_PyUnicode_IS_TRUE(u)      (0 != PyUnicode_GET_LENGTH(u))
-  #endif
-#else
-  #define CYTHON_PEP393_ENABLED 0
-  #define PyUnicode_1BYTE_KIND  1
-  #define PyUnicode_2BYTE_KIND  2
-  #define PyUnicode_4BYTE_KIND  4
-  #define __Pyx_PyUnicode_READY(op)       (0)
-  #define __Pyx_PyUnicode_GET_LENGTH(u)   PyUnicode_GET_SIZE(u)
-  #define __Pyx_PyUnicode_READ_CHAR(u, i) ((Py_UCS4)(PyUnicode_AS_UNICODE(u)[i]))
-  #define __Pyx_PyUnicode_MAX_CHAR_VALUE(u)   ((sizeof(Py_UNICODE) == 2) ? 65535 : 1114111)
-  #define __Pyx_PyUnicode_KIND(u)         (sizeof(Py_UNICODE))
-  #define __Pyx_PyUnicode_DATA(u)         ((void*)PyUnicode_AS_UNICODE(u))
-  #define __Pyx_PyUnicode_READ(k, d, i)   ((void)(k), (Py_UCS4)(((Py_UNICODE*)d)[i]))
-  #define __Pyx_PyUnicode_WRITE(k, d, i, ch)  (((void)(k)), ((Py_UNICODE*)d)[i] = ch)
-  #define __Pyx_PyUnicode_IS_TRUE(u)      (0 != PyUnicode_GET_SIZE(u))
-#endif
-#if CYTHON_COMPILING_IN_PYPY
-  #define __Pyx_PyUnicode_Concat(a, b)      PyNumber_Add(a, b)
-  #define __Pyx_PyUnicode_ConcatSafe(a, b)  PyNumber_Add(a, b)
-#else
-  #define __Pyx_PyUnicode_Concat(a, b)      PyUnicode_Concat(a, b)
-  #define __Pyx_PyUnicode_ConcatSafe(a, b)  ((unlikely((a) == Py_None) || unlikely((b) == Py_None)) ?\
-      PyNumber_Add(a, b) : __Pyx_PyUnicode_Concat(a, b))
-#endif
-#if CYTHON_COMPILING_IN_PYPY && !defined(PyUnicode_Contains)
-  #define PyUnicode_Contains(u, s)  PySequence_Contains(u, s)
-#endif
-#if CYTHON_COMPILING_IN_PYPY && !defined(PyByteArray_Check)
-  #define PyByteArray_Check(obj)  PyObject_TypeCheck(obj, &PyByteArray_Type)
-#endif
-#if CYTHON_COMPILING_IN_PYPY && !defined(PyObject_Format)
-  #define PyObject_Format(obj, fmt)  PyObject_CallMethod(obj, "__format__", "O", fmt)
-#endif
-#define __Pyx_PyString_FormatSafe(a, b)   ((unlikely((a) == Py_None || (PyString_Check(b) && !PyString_CheckExact(b)))) ? PyNumber_Remainder(a, b) : __Pyx_PyString_Format(a, b))
-#define __Pyx_PyUnicode_FormatSafe(a, b)  ((unlikely((a) == Py_None || (PyUnicode_Check(b) && !PyUnicode_CheckExact(b)))) ? PyNumber_Remainder(a, b) : PyUnicode_Format(a, b))
-#if PY_MAJOR_VERSION >= 3
-  #define __Pyx_PyString_Format(a, b)  PyUnicode_Format(a, b)
-#else
-  #define __Pyx_PyString_Format(a, b)  PyString_Format(a, b)
-#endif
-#if PY_MAJOR_VERSION < 3 && !defined(PyObject_ASCII)
-  #define PyObject_ASCII(o)            PyObject_Repr(o)
-#endif
-#if PY_MAJOR_VERSION >= 3
-  #define PyBaseString_Type            PyUnicode_Type
-  #define PyStringObject               PyUnicodeObject
-  #define PyString_Type                PyUnicode_Type
-  #define PyString_Check               PyUnicode_Check
-  #define PyString_CheckExact          PyUnicode_CheckExact
-#ifndef PyObject_Unicode
-  #define PyObject_Unicode             PyObject_Str
-#endif
-#endif
-#if PY_MAJOR_VERSION >= 3
-  #define __Pyx_PyBaseString_Check(obj) PyUnicode_Check(obj)
-  #define __Pyx_PyBaseString_CheckExact(obj) PyUnicode_CheckExact(obj)
-#else
-  #define __Pyx_PyBaseString_Check(obj) (PyString_Check(obj) || PyUnicode_Check(obj))
-  #define __Pyx_PyBaseString_CheckExact(obj) (PyString_CheckExact(obj) || PyUnicode_CheckExact(obj))
-#endif
-#ifndef PySet_CheckExact
-  #define PySet_CheckExact(obj)        (Py_TYPE(obj) == &PySet_Type)
-#endif
-#if PY_VERSION_HEX >= 0x030900A4
-  #define __Pyx_SET_REFCNT(obj, refcnt) Py_SET_REFCNT(obj, refcnt)
-  #define __Pyx_SET_SIZE(obj, size) Py_SET_SIZE(obj, size)
-#else
-  #define __Pyx_SET_REFCNT(obj, refcnt) Py_REFCNT(obj) = (refcnt)
-  #define __Pyx_SET_SIZE(obj, size) Py_SIZE(obj) = (size)
-#endif
-#if CYTHON_ASSUME_SAFE_MACROS
-  #define __Pyx_PySequence_SIZE(seq)  Py_SIZE(seq)
-#else
-  #define __Pyx_PySequence_SIZE(seq)  PySequence_Size(seq)
-#endif
-#if PY_MAJOR_VERSION >= 3
-  #define PyIntObject                  PyLongObject
-  #define PyInt_Type                   PyLong_Type
-  #define PyInt_Check(op)              PyLong_Check(op)
-  #define PyInt_CheckExact(op)         PyLong_CheckExact(op)
-  #define PyInt_FromString             PyLong_FromString
-  #define PyInt_FromUnicode            PyLong_FromUnicode
-  #define PyInt_FromLong               PyLong_FromLong
-  #define PyInt_FromSize_t             PyLong_FromSize_t
-  #define PyInt_FromSsize_t            PyLong_FromSsize_t
-  #define PyInt_AsLong                 PyLong_AsLong
-  #define PyInt_AS_LONG                PyLong_AS_LONG
-  #define PyInt_AsSsize_t              PyLong_AsSsize_t
-  #define PyInt_AsUnsignedLongMask     PyLong_AsUnsignedLongMask
-  #define PyInt_AsUnsignedLongLongMask PyLong_AsUnsignedLongLongMask
-  #define PyNumber_Int                 PyNumber_Long
-#endif
-#if PY_MAJOR_VERSION >= 3
-  #define PyBoolObject                 PyLongObject
-#endif
-#if PY_MAJOR_VERSION >= 3 && CYTHON_COMPILING_IN_PYPY
-  #ifndef PyUnicode_InternFromString
-    #define PyUnicode_InternFromString(s) PyUnicode_FromString(s)
-  #endif
-#endif
-#if PY_VERSION_HEX < 0x030200A4
-  typedef long Py_hash_t;
-  #define __Pyx_PyInt_FromHash_t PyInt_FromLong
-  #define __Pyx_PyInt_AsHash_t   __Pyx_PyIndex_AsHash_t
-#else
-  #define __Pyx_PyInt_FromHash_t PyInt_FromSsize_t
-  #define __Pyx_PyInt_AsHash_t   __Pyx_PyIndex_AsSsize_t
-#endif
-#if PY_MAJOR_VERSION >= 3
-  #define __Pyx_PyMethod_New(func, self, klass) ((self) ? ((void)(klass), PyMethod_New(func, self)) : __Pyx_NewRef(func))
-#else
-  #define __Pyx_PyMethod_New(func, self, klass) PyMethod_New(func, self, klass)
-#endif
-#if CYTHON_USE_ASYNC_SLOTS
-  #if PY_VERSION_HEX >= 0x030500B1
-    #define __Pyx_PyAsyncMethodsStruct PyAsyncMethods
-    #define __Pyx_PyType_AsAsync(obj) (Py_TYPE(obj)->tp_as_async)
-  #else
-    #define __Pyx_PyType_AsAsync(obj) ((__Pyx_PyAsyncMethodsStruct*) (Py_TYPE(obj)->tp_reserved))
-  #endif
-#else
-  #define __Pyx_PyType_AsAsync(obj) NULL
-#endif
-#ifndef __Pyx_PyAsyncMethodsStruct
-    typedef struct {
-        unaryfunc am_await;
-        unaryfunc am_aiter;
-        unaryfunc am_anext;
-    } __Pyx_PyAsyncMethodsStruct;
-#endif
-
-#if defined(_WIN32) || defined(WIN32) || defined(MS_WINDOWS)
-  #if !defined(_USE_MATH_DEFINES)
-    #define _USE_MATH_DEFINES
-  #endif
-#endif
-#include <math.h>
-#ifdef NAN
-#define __PYX_NAN() ((float) NAN)
-#else
-static CYTHON_INLINE float __PYX_NAN() {
-  float value;
-  memset(&value, 0xFF, sizeof(value));
-  return value;
-}
-#endif
-#if defined(__CYGWIN__) && defined(_LDBL_EQ_DBL)
-#define __Pyx_truncl trunc
-#else
-#define __Pyx_truncl truncl
-#endif
-
-#define __PYX_MARK_ERR_POS(f_index, lineno) \
-    { __pyx_filename = __pyx_f[f_index]; (void)__pyx_filename; __pyx_lineno = lineno; (void)__pyx_lineno; __pyx_clineno = __LINE__; (void)__pyx_clineno; }
-#define __PYX_ERR(f_index, lineno, Ln_error) \
-    { __PYX_MARK_ERR_POS(f_index, lineno) goto Ln_error; }
-
-#ifndef __PYX_EXTERN_C
-  #ifdef __cplusplus
-    #define __PYX_EXTERN_C extern "C"
-  #else
-    #define __PYX_EXTERN_C extern
-  #endif
-#endif
-
-#define __PYX_HAVE__crf
-#define __PYX_HAVE_API__crf
-/* Early includes */
-#include <string.h>
-#include <string>
-#include "ios"
-#include "new"
-#include "stdexcept"
-#include "typeinfo"
-#include <vector>
-#include "crfsuite/include/crfsuite.h"
-#include "crfsuite/include/crfsuite_api.hpp"
-#include "trainer_wrapper.hpp"
-#include "tagger_wrapper.hpp"
-#ifdef _OPENMP
-#include <omp.h>
-#endif /* _OPENMP */
-
-#if defined(PYREX_WITHOUT_ASSERTIONS) && !defined(CYTHON_WITHOUT_ASSERTIONS)
-#define CYTHON_WITHOUT_ASSERTIONS
-#endif
-
-typedef struct {PyObject **p; const char *s; const Py_ssize_t n; const char* encoding;
-                const char is_unicode; const char is_str; const char intern; } __Pyx_StringTabEntry;
-
-#define __PYX_DEFAULT_STRING_ENCODING_IS_ASCII 0
-#define __PYX_DEFAULT_STRING_ENCODING_IS_UTF8 1
-#define __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT (PY_MAJOR_VERSION >= 3 && __PYX_DEFAULT_STRING_ENCODING_IS_UTF8)
-#define __PYX_DEFAULT_STRING_ENCODING "utf8"
-#define __Pyx_PyObject_FromString __Pyx_PyStr_FromString
-#define __Pyx_PyObject_FromStringAndSize __Pyx_PyStr_FromStringAndSize
-#define __Pyx_uchar_cast(c) ((unsigned char)c)
-#define __Pyx_long_cast(x) ((long)x)
-#define __Pyx_fits_Py_ssize_t(v, type, is_signed)  (\
-    (sizeof(type) < sizeof(Py_ssize_t))  ||\
-    (sizeof(type) > sizeof(Py_ssize_t) &&\
-          likely(v < (type)PY_SSIZE_T_MAX ||\
-                 v == (type)PY_SSIZE_T_MAX)  &&\
-          (!is_signed || likely(v > (type)PY_SSIZE_T_MIN ||\
-                                v == (type)PY_SSIZE_T_MIN)))  ||\
-    (sizeof(type) == sizeof(Py_ssize_t) &&\
-          (is_signed || likely(v < (type)PY_SSIZE_T_MAX ||\
-                               v == (type)PY_SSIZE_T_MAX)))  )
-static CYTHON_INLINE int __Pyx_is_valid_index(Py_ssize_t i, Py_ssize_t limit) {
-    return (size_t) i < (size_t) limit;
-}
-#if defined (__cplusplus) && __cplusplus >= 201103L
-    #include <cstdlib>
-    #define __Pyx_sst_abs(value) std::abs(value)
-#elif SIZEOF_INT >= SIZEOF_SIZE_T
-    #define __Pyx_sst_abs(value) abs(value)
-#elif SIZEOF_LONG >= SIZEOF_SIZE_T
-    #define __Pyx_sst_abs(value) labs(value)
-#elif defined (_MSC_VER)
-    #define __Pyx_sst_abs(value) ((Py_ssize_t)_abs64(value))
-#elif defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
-    #define __Pyx_sst_abs(value) llabs(value)
-#elif defined (__GNUC__)
-    #define __Pyx_sst_abs(value) __builtin_llabs(value)
-#else
-    #define __Pyx_sst_abs(value) ((value<0) ? -value : value)
-#endif
-static CYTHON_INLINE const char* __Pyx_PyObject_AsString(PyObject*);
-static CYTHON_INLINE const char* __Pyx_PyObject_AsStringAndSize(PyObject*, Py_ssize_t* length);
-#define __Pyx_PyByteArray_FromString(s) PyByteArray_FromStringAndSize((const char*)s, strlen((const char*)s))
-#define __Pyx_PyByteArray_FromStringAndSize(s, l) PyByteArray_FromStringAndSize((const char*)s, l)
-#define __Pyx_PyBytes_FromString        PyBytes_FromString
-#define __Pyx_PyBytes_FromStringAndSize PyBytes_FromStringAndSize
-static CYTHON_INLINE PyObject* __Pyx_PyUnicode_FromString(const char*);
-#if PY_MAJOR_VERSION < 3
-    #define __Pyx_PyStr_FromString        __Pyx_PyBytes_FromString
-    #define __Pyx_PyStr_FromStringAndSize __Pyx_PyBytes_FromStringAndSize
-#else
-    #define __Pyx_PyStr_FromString        __Pyx_PyUnicode_FromString
-    #define __Pyx_PyStr_FromStringAndSize __Pyx_PyUnicode_FromStringAndSize
-#endif
-#define __Pyx_PyBytes_AsWritableString(s)     ((char*) PyBytes_AS_STRING(s))
-#define __Pyx_PyBytes_AsWritableSString(s)    ((signed char*) PyBytes_AS_STRING(s))
-#define __Pyx_PyBytes_AsWritableUString(s)    ((unsigned char*) PyBytes_AS_STRING(s))
-#define __Pyx_PyBytes_AsString(s)     ((const char*) PyBytes_AS_STRING(s))
-#define __Pyx_PyBytes_AsSString(s)    ((const signed char*) PyBytes_AS_STRING(s))
-#define __Pyx_PyBytes_AsUString(s)    ((const unsigned char*) PyBytes_AS_STRING(s))
-#define __Pyx_PyObject_AsWritableString(s)    ((char*) __Pyx_PyObject_AsString(s))
-#define __Pyx_PyObject_AsWritableSString(s)    ((signed char*) __Pyx_PyObject_AsString(s))
-#define __Pyx_PyObject_AsWritableUString(s)    ((unsigned char*) __Pyx_PyObject_AsString(s))
-#define __Pyx_PyObject_AsSString(s)    ((const signed char*) __Pyx_PyObject_AsString(s))
-#define __Pyx_PyObject_AsUString(s)    ((const unsigned char*) __Pyx_PyObject_AsString(s))
-#define __Pyx_PyObject_FromCString(s)  __Pyx_PyObject_FromString((const char*)s)
-#define __Pyx_PyBytes_FromCString(s)   __Pyx_PyBytes_FromString((const char*)s)
-#define __Pyx_PyByteArray_FromCString(s)   __Pyx_PyByteArray_FromString((const char*)s)
-#define __Pyx_PyStr_FromCString(s)     __Pyx_PyStr_FromString((const char*)s)
-#define __Pyx_PyUnicode_FromCString(s) __Pyx_PyUnicode_FromString((const char*)s)
-static CYTHON_INLINE size_t __Pyx_Py_UNICODE_strlen(const Py_UNICODE *u) {
-    const Py_UNICODE *u_end = u;
-    while (*u_end++) ;
-    return (size_t)(u_end - u - 1);
-}
-#define __Pyx_PyUnicode_FromUnicode(u)       PyUnicode_FromUnicode(u, __Pyx_Py_UNICODE_strlen(u))
-#define __Pyx_PyUnicode_FromUnicodeAndLength PyUnicode_FromUnicode
-#define __Pyx_PyUnicode_AsUnicode            PyUnicode_AsUnicode
-#define __Pyx_NewRef(obj) (Py_INCREF(obj), obj)
-#define __Pyx_Owned_Py_None(b) __Pyx_NewRef(Py_None)
-static CYTHON_INLINE PyObject * __Pyx_PyBool_FromLong(long b);
-static CYTHON_INLINE int __Pyx_PyObject_IsTrue(PyObject*);
-static CYTHON_INLINE int __Pyx_PyObject_IsTrueAndDecref(PyObject*);
-static CYTHON_INLINE PyObject* __Pyx_PyNumber_IntOrLong(PyObject* x);
-#define __Pyx_PySequence_Tuple(obj)\
-    (likely(PyTuple_CheckExact(obj)) ? __Pyx_NewRef(obj) : PySequence_Tuple(obj))
-static CYTHON_INLINE Py_ssize_t __Pyx_PyIndex_AsSsize_t(PyObject*);
-static CYTHON_INLINE PyObject * __Pyx_PyInt_FromSize_t(size_t);
-static CYTHON_INLINE Py_hash_t __Pyx_PyIndex_AsHash_t(PyObject*);
-#if CYTHON_ASSUME_SAFE_MACROS
-#define __pyx_PyFloat_AsDouble(x) (PyFloat_CheckExact(x) ? PyFloat_AS_DOUBLE(x) : PyFloat_AsDouble(x))
-#else
-#define __pyx_PyFloat_AsDouble(x) PyFloat_AsDouble(x)
-#endif
-#define __pyx_PyFloat_AsFloat(x) ((float) __pyx_PyFloat_AsDouble(x))
-#if PY_MAJOR_VERSION >= 3
-#define __Pyx_PyNumber_Int(x) (PyLong_CheckExact(x) ? __Pyx_NewRef(x) : PyNumber_Long(x))
-#else
-#define __Pyx_PyNumber_Int(x) (PyInt_CheckExact(x) ? __Pyx_NewRef(x) : PyNumber_Int(x))
-#endif
-#define __Pyx_PyNumber_Float(x) (PyFloat_CheckExact(x) ? __Pyx_NewRef(x) : PyNumber_Float(x))
-#if PY_MAJOR_VERSION < 3 && __PYX_DEFAULT_STRING_ENCODING_IS_ASCII
-static int __Pyx_sys_getdefaultencoding_not_ascii;
-static int __Pyx_init_sys_getdefaultencoding_params(void) {
-    PyObject* sys;
-    PyObject* default_encoding = NULL;
-    PyObject* ascii_chars_u = NULL;
-    PyObject* ascii_chars_b = NULL;
-    const char* default_encoding_c;
-    sys = PyImport_ImportModule("sys");
-    if (!sys) goto bad;
-    default_encoding = PyObject_CallMethod(sys, (char*) "getdefaultencoding", NULL);
-    Py_DECREF(sys);
-    if (!default_encoding) goto bad;
-    default_encoding_c = PyBytes_AsString(default_encoding);
-    if (!default_encoding_c) goto bad;
-    if (strcmp(default_encoding_c, "ascii") == 0) {
-        __Pyx_sys_getdefaultencoding_not_ascii = 0;
-    } else {
-        char ascii_chars[128];
-        int c;
-        for (c = 0; c < 128; c++) {
-            ascii_chars[c] = c;
-        }
-        __Pyx_sys_getdefaultencoding_not_ascii = 1;
-        ascii_chars_u = PyUnicode_DecodeASCII(ascii_chars, 128, NULL);
-        if (!ascii_chars_u) goto bad;
-        ascii_chars_b = PyUnicode_AsEncodedString(ascii_chars_u, default_encoding_c, NULL);
-        if (!ascii_chars_b || !PyBytes_Check(ascii_chars_b) || memcmp(ascii_chars, PyBytes_AS_STRING(ascii_chars_b), 128) != 0) {
-            PyErr_Format(
-                PyExc_ValueError,
-                "This module compiled with c_string_encoding=ascii, but default encoding '%.200s' is not a superset of ascii.",
-                default_encoding_c);
-            goto bad;
-        }
-        Py_DECREF(ascii_chars_u);
-        Py_DECREF(ascii_chars_b);
-    }
-    Py_DECREF(default_encoding);
-    return 0;
-bad:
-    Py_XDECREF(default_encoding);
-    Py_XDECREF(ascii_chars_u);
-    Py_XDECREF(ascii_chars_b);
-    return -1;
-}
-#endif
-#if __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT && PY_MAJOR_VERSION >= 3
-#define __Pyx_PyUnicode_FromStringAndSize(c_str, size) PyUnicode_DecodeUTF8(c_str, size, NULL)
-#else
-#define __Pyx_PyUnicode_FromStringAndSize(c_str, size) PyUnicode_Decode(c_str, size, __PYX_DEFAULT_STRING_ENCODING, NULL)
-#if __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT
-static char* __PYX_DEFAULT_STRING_ENCODING;
-static int __Pyx_init_sys_getdefaultencoding_params(void) {
-    PyObject* sys;
-    PyObject* default_encoding = NULL;
-    char* default_encoding_c;
-    sys = PyImport_ImportModule("sys");
-    if (!sys) goto bad;
-    default_encoding = PyObject_CallMethod(sys, (char*) (const char*) "getdefaultencoding", NULL);
-    Py_DECREF(sys);
-    if (!default_encoding) goto bad;
-    default_encoding_c = PyBytes_AsString(default_encoding);
-    if (!default_encoding_c) goto bad;
-    __PYX_DEFAULT_STRING_ENCODING = (char*) malloc(strlen(default_encoding_c) + 1);
-    if (!__PYX_DEFAULT_STRING_ENCODING) goto bad;
-    strcpy(__PYX_DEFAULT_STRING_ENCODING, default_encoding_c);
-    Py_DECREF(default_encoding);
-    return 0;
-bad:
-    Py_XDECREF(default_encoding);
-    return -1;
-}
-#endif
-#endif
-
-
-/* Test for GCC > 2.95 */
-#if defined(__GNUC__)     && (__GNUC__ > 2 || (__GNUC__ == 2 && (__GNUC_MINOR__ > 95)))
-  #define likely(x)   __builtin_expect(!!(x), 1)
-  #define unlikely(x) __builtin_expect(!!(x), 0)
-#else /* !__GNUC__ or GCC < 2.95 */
-  #define likely(x)   (x)
-  #define unlikely(x) (x)
-#endif /* __GNUC__ */
-static CYTHON_INLINE void __Pyx_pretend_to_initialize(void* ptr) { (void)ptr; }
-
-static PyObject *__pyx_m = NULL;
-static PyObject *__pyx_d;
-static PyObject *__pyx_b;
-static PyObject *__pyx_cython_runtime = NULL;
-static PyObject *__pyx_empty_tuple;
-static PyObject *__pyx_empty_bytes;
-static PyObject *__pyx_empty_unicode;
-static int __pyx_lineno;
-static int __pyx_clineno = 0;
-static const char * __pyx_cfilenm= __FILE__;
-static const char *__pyx_filename;
-
-
-static const char *__pyx_f[] = {
-  "chaine/_core/crf.pyx",
-  "stringsource",
-};
-
-/*--- Type declarations ---*/
-struct __pyx_obj_3crf_Trainer;
-struct __pyx_obj_3crf_Model;
-struct __pyx_obj_3crf_ItemSequence;
-
-/* "crf.pyx":18
- * 
- * 
- * cdef class Trainer:             # <<<<<<<<<<<<<<
- *     cdef crfsuite_api.Trainer _trainer
- * 
- */
-struct __pyx_obj_3crf_Trainer {
-  PyObject_HEAD
-  struct __pyx_vtabstruct_3crf_Trainer *__pyx_vtab;
-  CRFSuiteWrapper::Trainer _trainer;
-};
-
-
-/* "crf.pyx":145
- * 
- * 
- * cdef class Model:             # <<<<<<<<<<<<<<
- *     cdef crfsuite_api.Tagger _tagger
- * 
- */
-struct __pyx_obj_3crf_Model {
-  PyObject_HEAD
-  struct __pyx_vtabstruct_3crf_Model *__pyx_vtab;
-  CRFSuiteWrapper::Tagger _tagger;
-};
-
-
-/* "crf.pyx":247
- * 
- * 
- * cdef class ItemSequence:             # <<<<<<<<<<<<<<
- *     cdef crfsuite_api.ItemSequence c_sequence
- * 
- */
-struct __pyx_obj_3crf_ItemSequence {
-  PyObject_HEAD
-  CRFSuite::ItemSequence c_sequence;
-};
-
-
-
-/* "crf.pyx":18
- * 
- * 
- * cdef class Trainer:             # <<<<<<<<<<<<<<
- *     cdef crfsuite_api.Trainer _trainer
- * 
- */
-
-struct __pyx_vtabstruct_3crf_Trainer {
-  PyObject *(*_on_message)(struct __pyx_obj_3crf_Trainer *, std::string);
-};
-static struct __pyx_vtabstruct_3crf_Trainer *__pyx_vtabptr_3crf_Trainer;
-
-
-/* "crf.pyx":145
- * 
- * 
- * cdef class Model:             # <<<<<<<<<<<<<<
- *     cdef crfsuite_api.Tagger _tagger
- * 
- */
-
-struct __pyx_vtabstruct_3crf_Model {
-  PyObject *(*set_sequence)(struct __pyx_obj_3crf_Model *, PyObject *, int __pyx_skip_dispatch);
-};
-static struct __pyx_vtabstruct_3crf_Model *__pyx_vtabptr_3crf_Model;
-
-/* --- Runtime support code (head) --- */
-/* Refnanny.proto */
-#ifndef CYTHON_REFNANNY
-  #define CYTHON_REFNANNY 0
-#endif
-#if CYTHON_REFNANNY
-  typedef struct {
-    void (*INCREF)(void*, PyObject*, int);
-    void (*DECREF)(void*, PyObject*, int);
-    void (*GOTREF)(void*, PyObject*, int);
-    void (*GIVEREF)(void*, PyObject*, int);
-    void* (*SetupContext)(const char*, int, const char*);
-    void (*FinishContext)(void**);
-  } __Pyx_RefNannyAPIStruct;
-  static __Pyx_RefNannyAPIStruct *__Pyx_RefNanny = NULL;
-  static __Pyx_RefNannyAPIStruct *__Pyx_RefNannyImportAPI(const char *modname);
-  #define __Pyx_RefNannyDeclarations void *__pyx_refnanny = NULL;
-#ifdef WITH_THREAD
-  #define __Pyx_RefNannySetupContext(name, acquire_gil)\
-          if (acquire_gil) {\
-              PyGILState_STATE __pyx_gilstate_save = PyGILState_Ensure();\
-              __pyx_refnanny = __Pyx_RefNanny->SetupContext((name), __LINE__, __FILE__);\
-              PyGILState_Release(__pyx_gilstate_save);\
-          } else {\
-              __pyx_refnanny = __Pyx_RefNanny->SetupContext((name), __LINE__, __FILE__);\
-          }
-#else
-  #define __Pyx_RefNannySetupContext(name, acquire_gil)\
-          __pyx_refnanny = __Pyx_RefNanny->SetupContext((name), __LINE__, __FILE__)
-#endif
-  #define __Pyx_RefNannyFinishContext()\
-          __Pyx_RefNanny->FinishContext(&__pyx_refnanny)
-  #define __Pyx_INCREF(r)  __Pyx_RefNanny->INCREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
-  #define __Pyx_DECREF(r)  __Pyx_RefNanny->DECREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
-  #define __Pyx_GOTREF(r)  __Pyx_RefNanny->GOTREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
-  #define __Pyx_GIVEREF(r) __Pyx_RefNanny->GIVEREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
-  #define __Pyx_XINCREF(r)  do { if((r) != NULL) {__Pyx_INCREF(r); }} while(0)
-  #define __Pyx_XDECREF(r)  do { if((r) != NULL) {__Pyx_DECREF(r); }} while(0)
-  #define __Pyx_XGOTREF(r)  do { if((r) != NULL) {__Pyx_GOTREF(r); }} while(0)
-  #define __Pyx_XGIVEREF(r) do { if((r) != NULL) {__Pyx_GIVEREF(r);}} while(0)
-#else
-  #define __Pyx_RefNannyDeclarations
-  #define __Pyx_RefNannySetupContext(name, acquire_gil)
-  #define __Pyx_RefNannyFinishContext()
-  #define __Pyx_INCREF(r) Py_INCREF(r)
-  #define __Pyx_DECREF(r) Py_DECREF(r)
-  #define __Pyx_GOTREF(r)
-  #define __Pyx_GIVEREF(r)
-  #define __Pyx_XINCREF(r) Py_XINCREF(r)
-  #define __Pyx_XDECREF(r) Py_XDECREF(r)
-  #define __Pyx_XGOTREF(r)
-  #define __Pyx_XGIVEREF(r)
-#endif
-#define __Pyx_XDECREF_SET(r, v) do {\
-        PyObject *tmp = (PyObject *) r;\
-        r = v; __Pyx_XDECREF(tmp);\
-    } while (0)
-#define __Pyx_DECREF_SET(r, v) do {\
-        PyObject *tmp = (PyObject *) r;\
-        r = v; __Pyx_DECREF(tmp);\
-    } while (0)
-#define __Pyx_CLEAR(r)    do { PyObject* tmp = ((PyObject*)(r)); r = NULL; __Pyx_DECREF(tmp);} while(0)
-#define __Pyx_XCLEAR(r)   do { if((r) != NULL) {PyObject* tmp = ((PyObject*)(r)); r = NULL; __Pyx_DECREF(tmp);}} while(0)
-
-/* PyObjectGetAttrStr.proto */
-#if CYTHON_USE_TYPE_SLOTS
-static CYTHON_INLINE PyObject* __Pyx_PyObject_GetAttrStr(PyObject* obj, PyObject* attr_name);
-#else
-#define __Pyx_PyObject_GetAttrStr(o,n) PyObject_GetAttr(o,n)
-#endif
-
-/* GetBuiltinName.proto */
-static PyObject *__Pyx_GetBuiltinName(PyObject *name);
-
-/* RaiseDoubleKeywords.proto */
-static void __Pyx_RaiseDoubleKeywordsError(const char* func_name, PyObject* kw_name);
-
-/* ParseKeywords.proto */
-static int __Pyx_ParseOptionalKeywords(PyObject *kwds, PyObject **argnames[],\
-    PyObject *kwds2, PyObject *values[], Py_ssize_t num_pos_args,\
-    const char* function_name);
-
-/* RaiseArgTupleInvalid.proto */
-static void __Pyx_RaiseArgtupleInvalid(const char* func_name, int exact,
-    Py_ssize_t num_min, Py_ssize_t num_max, Py_ssize_t num_found);
-
-/* ArgTypeTest.proto */
-#define __Pyx_ArgTypeTest(obj, type, none_allowed, name, exact)\
-    ((likely((Py_TYPE(obj) == type) | (none_allowed && (obj == Py_None)))) ? 1 :\
-        __Pyx__ArgTypeTest(obj, type, name, exact))
-static int __Pyx__ArgTypeTest(PyObject *obj, PyTypeObject *type, const char *name, int exact);
-
-/* PyCFunctionFastCall.proto */
-#if CYTHON_FAST_PYCCALL
-static CYTHON_INLINE PyObject *__Pyx_PyCFunction_FastCall(PyObject *func, PyObject **args, Py_ssize_t nargs);
-#else
-#define __Pyx_PyCFunction_FastCall(func, args, nargs)  (assert(0), NULL)
-#endif
-
-/* PyFunctionFastCall.proto */
-#if CYTHON_FAST_PYCALL
-#define __Pyx_PyFunction_FastCall(func, args, nargs)\
-    __Pyx_PyFunction_FastCallDict((func), (args), (nargs), NULL)
-#if 1 || PY_VERSION_HEX < 0x030600B1
-static PyObject *__Pyx_PyFunction_FastCallDict(PyObject *func, PyObject **args, Py_ssize_t nargs, PyObject *kwargs);
-#else
-#define __Pyx_PyFunction_FastCallDict(func, args, nargs, kwargs) _PyFunction_FastCallDict(func, args, nargs, kwargs)
-#endif
-#define __Pyx_BUILD_ASSERT_EXPR(cond)\
-    (sizeof(char [1 - 2*!(cond)]) - 1)
-#ifndef Py_MEMBER_SIZE
-#define Py_MEMBER_SIZE(type, member) sizeof(((type *)0)->member)
-#endif
-#if CYTHON_FAST_PYCALL
-  static size_t __pyx_pyframe_localsplus_offset = 0;
-  #include "frameobject.h"
-#if PY_VERSION_HEX >= 0x030b00a6
-  #ifndef Py_BUILD_CORE
-    #define Py_BUILD_CORE 1
-  #endif
-  #include "internal/pycore_frame.h"
-#endif
-  #define __Pxy_PyFrame_Initialize_Offsets()\
-    ((void)__Pyx_BUILD_ASSERT_EXPR(sizeof(PyFrameObject) == offsetof(PyFrameObject, f_localsplus) + Py_MEMBER_SIZE(PyFrameObject, f_localsplus)),\
-     (void)(__pyx_pyframe_localsplus_offset = ((size_t)PyFrame_Type.tp_basicsize) - Py_MEMBER_SIZE(PyFrameObject, f_localsplus)))
-  #define __Pyx_PyFrame_GetLocalsplus(frame)\
-    (assert(__pyx_pyframe_localsplus_offset), (PyObject **)(((char *)(frame)) + __pyx_pyframe_localsplus_offset))
-#endif // CYTHON_FAST_PYCALL
-#endif
-
-/* PyObjectCall.proto */
-#if CYTHON_COMPILING_IN_CPYTHON
-static CYTHON_INLINE PyObject* __Pyx_PyObject_Call(PyObject *func, PyObject *arg, PyObject *kw);
-#else
-#define __Pyx_PyObject_Call(func, arg, kw) PyObject_Call(func, arg, kw)
-#endif
-
-/* PyObjectCall2Args.proto */
-static CYTHON_UNUSED PyObject* __Pyx_PyObject_Call2Args(PyObject* function, PyObject* arg1, PyObject* arg2);
-
-/* PyObjectCallMethO.proto */
-#if CYTHON_COMPILING_IN_CPYTHON
-static CYTHON_INLINE PyObject* __Pyx_PyObject_CallMethO(PyObject *func, PyObject *arg);
-#endif
-
-/* PyObjectCallOneArg.proto */
-static CYTHON_INLINE PyObject* __Pyx_PyObject_CallOneArg(PyObject *func, PyObject *arg);
-
-/* KeywordStringCheck.proto */
-static int __Pyx_CheckKeywordStrings(PyObject *kwdict, const char* function_name, int kw_allowed);
-
-/* PyDictVersioning.proto */
-#if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_TYPE_SLOTS
-#define __PYX_DICT_VERSION_INIT  ((PY_UINT64_T) -1)
-#define __PYX_GET_DICT_VERSION(dict)  (((PyDictObject*)(dict))->ma_version_tag)
-#define __PYX_UPDATE_DICT_CACHE(dict, value, cache_var, version_var)\
-    (version_var) = __PYX_GET_DICT_VERSION(dict);\
-    (cache_var) = (value);
-#define __PYX_PY_DICT_LOOKUP_IF_MODIFIED(VAR, DICT, LOOKUP) {\
-    static PY_UINT64_T __pyx_dict_version = 0;\
-    static PyObject *__pyx_dict_cached_value = NULL;\
-    if (likely(__PYX_GET_DICT_VERSION(DICT) == __pyx_dict_version)) {\
-        (VAR) = __pyx_dict_cached_value;\
-    } else {\
-        (VAR) = __pyx_dict_cached_value = (LOOKUP);\
-        __pyx_dict_version = __PYX_GET_DICT_VERSION(DICT);\
-    }\
-}
-static CYTHON_INLINE PY_UINT64_T __Pyx_get_tp_dict_version(PyObject *obj);
-static CYTHON_INLINE PY_UINT64_T __Pyx_get_object_dict_version(PyObject *obj);
-static CYTHON_INLINE int __Pyx_object_dict_version_matches(PyObject* obj, PY_UINT64_T tp_dict_version, PY_UINT64_T obj_dict_version);
-#else
-#define __PYX_GET_DICT_VERSION(dict)  (0)
-#define __PYX_UPDATE_DICT_CACHE(dict, value, cache_var, version_var)
-#define __PYX_PY_DICT_LOOKUP_IF_MODIFIED(VAR, DICT, LOOKUP)  (VAR) = (LOOKUP);
-#endif
-
-/* GetModuleGlobalName.proto */
-#if CYTHON_USE_DICT_VERSIONS
-#define __Pyx_GetModuleGlobalName(var, name)  {\
-    static PY_UINT64_T __pyx_dict_version = 0;\
-    static PyObject *__pyx_dict_cached_value = NULL;\
-    (var) = (likely(__pyx_dict_version == __PYX_GET_DICT_VERSION(__pyx_d))) ?\
-        (likely(__pyx_dict_cached_value) ? __Pyx_NewRef(__pyx_dict_cached_value) : __Pyx_GetBuiltinName(name)) :\
-        __Pyx__GetModuleGlobalName(name, &__pyx_dict_version, &__pyx_dict_cached_value);\
-}
-#define __Pyx_GetModuleGlobalNameUncached(var, name)  {\
-    PY_UINT64_T __pyx_dict_version;\
-    PyObject *__pyx_dict_cached_value;\
-    (var) = __Pyx__GetModuleGlobalName(name, &__pyx_dict_version, &__pyx_dict_cached_value);\
-}
-static PyObject *__Pyx__GetModuleGlobalName(PyObject *name, PY_UINT64_T *dict_version, PyObject **dict_cached_value);
-#else
-#define __Pyx_GetModuleGlobalName(var, name)  (var) = __Pyx__GetModuleGlobalName(name)
-#define __Pyx_GetModuleGlobalNameUncached(var, name)  (var) = __Pyx__GetModuleGlobalName(name)
-static CYTHON_INLINE PyObject *__Pyx__GetModuleGlobalName(PyObject *name);
-#endif
-
-/* ListCompAppend.proto */
-#if CYTHON_USE_PYLIST_INTERNALS && CYTHON_ASSUME_SAFE_MACROS
-static CYTHON_INLINE int __Pyx_ListComp_Append(PyObject* list, PyObject* x) {
-    PyListObject* L = (PyListObject*) list;
-    Py_ssize_t len = Py_SIZE(list);
-    if (likely(L->allocated > len)) {
-        Py_INCREF(x);
-        PyList_SET_ITEM(list, len, x);
-        __Pyx_SET_SIZE(list, len + 1);
-        return 0;
-    }
-    return PyList_Append(list, x);
-}
-#else
-#define __Pyx_ListComp_Append(L,x) PyList_Append(L,x)
-#endif
-
-/* PyObjectCallNoArg.proto */
-#if CYTHON_COMPILING_IN_CPYTHON
-static CYTHON_INLINE PyObject* __Pyx_PyObject_CallNoArg(PyObject *func);
-#else
-#define __Pyx_PyObject_CallNoArg(func) __Pyx_PyObject_Call(func, __pyx_empty_tuple, NULL)
-#endif
-
-/* RaiseTooManyValuesToUnpack.proto */
-static CYTHON_INLINE void __Pyx_RaiseTooManyValuesError(Py_ssize_t expected);
-
-/* RaiseNeedMoreValuesToUnpack.proto */
-static CYTHON_INLINE void __Pyx_RaiseNeedMoreValuesError(Py_ssize_t index);
-
-/* IterFinish.proto */
-static CYTHON_INLINE int __Pyx_IterFinish(void);
-
-/* UnpackItemEndCheck.proto */
-static int __Pyx_IternextUnpackEndCheck(PyObject *retval, Py_ssize_t expected);
-
-/* UnpackUnboundCMethod.proto */
-typedef struct {
-    PyObject *type;
-    PyObject **method_name;
-    PyCFunction func;
-    PyObject *method;
-    int flag;
-} __Pyx_CachedCFunction;
-
-/* CallUnboundCMethod0.proto */
-static PyObject* __Pyx__CallUnboundCMethod0(__Pyx_CachedCFunction* cfunc, PyObject* self);
-#if CYTHON_COMPILING_IN_CPYTHON
-#define __Pyx_CallUnboundCMethod0(cfunc, self)\
-    (likely((cfunc)->func) ?\
-        (likely((cfunc)->flag == METH_NOARGS) ?  (*((cfunc)->func))(self, NULL) :\
-         (PY_VERSION_HEX >= 0x030600B1 && likely((cfunc)->flag == METH_FASTCALL) ?\
-            (PY_VERSION_HEX >= 0x030700A0 ?\
-                (*(__Pyx_PyCFunctionFast)(void*)(PyCFunction)(cfunc)->func)(self, &__pyx_empty_tuple, 0) :\
-                (*(__Pyx_PyCFunctionFastWithKeywords)(void*)(PyCFunction)(cfunc)->func)(self, &__pyx_empty_tuple, 0, NULL)) :\
-          (PY_VERSION_HEX >= 0x030700A0 && (cfunc)->flag == (METH_FASTCALL | METH_KEYWORDS) ?\
-            (*(__Pyx_PyCFunctionFastWithKeywords)(void*)(PyCFunction)(cfunc)->func)(self, &__pyx_empty_tuple, 0, NULL) :\
-            (likely((cfunc)->flag == (METH_VARARGS | METH_KEYWORDS)) ?  ((*(PyCFunctionWithKeywords)(void*)(PyCFunction)(cfunc)->func)(self, __pyx_empty_tuple, NULL)) :\
-               ((cfunc)->flag == METH_VARARGS ?  (*((cfunc)->func))(self, __pyx_empty_tuple) :\
-               __Pyx__CallUnboundCMethod0(cfunc, self)))))) :\
-        __Pyx__CallUnboundCMethod0(cfunc, self))
-#else
-#define __Pyx_CallUnboundCMethod0(cfunc, self)  __Pyx__CallUnboundCMethod0(cfunc, self)
-#endif
-
-/* GetItemInt.proto */
-#define __Pyx_GetItemInt(o, i, type, is_signed, to_py_func, is_list, wraparound, boundscheck)\
-    (__Pyx_fits_Py_ssize_t(i, type, is_signed) ?\
-    __Pyx_GetItemInt_Fast(o, (Py_ssize_t)i, is_list, wraparound, boundscheck) :\
-    (is_list ? (PyErr_SetString(PyExc_IndexError, "list index out of range"), (PyObject*)NULL) :\
-               __Pyx_GetItemInt_Generic(o, to_py_func(i))))
-#define __Pyx_GetItemInt_List(o, i, type, is_signed, to_py_func, is_list, wraparound, boundscheck)\
-    (__Pyx_fits_Py_ssize_t(i, type, is_signed) ?\
-    __Pyx_GetItemInt_List_Fast(o, (Py_ssize_t)i, wraparound, boundscheck) :\
-    (PyErr_SetString(PyExc_IndexError, "list index out of range"), (PyObject*)NULL))
-static CYTHON_INLINE PyObject *__Pyx_GetItemInt_List_Fast(PyObject *o, Py_ssize_t i,
-                                                              int wraparound, int boundscheck);
-#define __Pyx_GetItemInt_Tuple(o, i, type, is_signed, to_py_func, is_list, wraparound, boundscheck)\
-    (__Pyx_fits_Py_ssize_t(i, type, is_signed) ?\
-    __Pyx_GetItemInt_Tuple_Fast(o, (Py_ssize_t)i, wraparound, boundscheck) :\
-    (PyErr_SetString(PyExc_IndexError, "tuple index out of range"), (PyObject*)NULL))
-static CYTHON_INLINE PyObject *__Pyx_GetItemInt_Tuple_Fast(PyObject *o, Py_ssize_t i,
-                                                              int wraparound, int boundscheck);
-static PyObject *__Pyx_GetItemInt_Generic(PyObject *o, PyObject* j);
-static CYTHON_INLINE PyObject *__Pyx_GetItemInt_Fast(PyObject *o, Py_ssize_t i,
-                                                     int is_list, int wraparound, int boundscheck);
-
-/* ObjectGetItem.proto */
-#if CYTHON_USE_TYPE_SLOTS
-static CYTHON_INLINE PyObject *__Pyx_PyObject_GetItem(PyObject *obj, PyObject* key);
-#else
-#define __Pyx_PyObject_GetItem(obj, key)  PyObject_GetItem(obj, key)
-#endif
-
-/* GetTopmostException.proto */
-#if CYTHON_USE_EXC_INFO_STACK
-static _PyErr_StackItem * __Pyx_PyErr_GetTopmostException(PyThreadState *tstate);
-#endif
-
-/* PyThreadStateGet.proto */
-#if CYTHON_FAST_THREAD_STATE
-#define __Pyx_PyThreadState_declare  PyThreadState *__pyx_tstate;
-#define __Pyx_PyThreadState_assign  __pyx_tstate = __Pyx_PyThreadState_Current;
-#define __Pyx_PyErr_Occurred()  __pyx_tstate->curexc_type
-#else
-#define __Pyx_PyThreadState_declare
-#define __Pyx_PyThreadState_assign
-#define __Pyx_PyErr_Occurred()  PyErr_Occurred()
-#endif
-
-/* SaveResetException.proto */
-#if CYTHON_FAST_THREAD_STATE
-#define __Pyx_ExceptionSave(type, value, tb)  __Pyx__ExceptionSave(__pyx_tstate, type, value, tb)
-static CYTHON_INLINE void __Pyx__ExceptionSave(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb);
-#define __Pyx_ExceptionReset(type, value, tb)  __Pyx__ExceptionReset(__pyx_tstate, type, value, tb)
-static CYTHON_INLINE void __Pyx__ExceptionReset(PyThreadState *tstate, PyObject *type, PyObject *value, PyObject *tb);
-#else
-#define __Pyx_ExceptionSave(type, value, tb)   PyErr_GetExcInfo(type, value, tb)
-#define __Pyx_ExceptionReset(type, value, tb)  PyErr_SetExcInfo(type, value, tb)
-#endif
-
-/* GetException.proto */
-#if CYTHON_FAST_THREAD_STATE
-#define __Pyx_GetException(type, value, tb)  __Pyx__GetException(__pyx_tstate, type, value, tb)
-static int __Pyx__GetException(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb);
-#else
-static int __Pyx_GetException(PyObject **type, PyObject **value, PyObject **tb);
-#endif
-
-/* PyObjectFormatSimple.proto */
-#if CYTHON_COMPILING_IN_PYPY
-    #define __Pyx_PyObject_FormatSimple(s, f) (\
-        likely(PyUnicode_CheckExact(s)) ? (Py_INCREF(s), s) :\
-        PyObject_Format(s, f))
-#elif PY_MAJOR_VERSION < 3
-    #define __Pyx_PyObject_FormatSimple(s, f) (\
-        likely(PyUnicode_CheckExact(s)) ? (Py_INCREF(s), s) :\
-        likely(PyString_CheckExact(s)) ? PyUnicode_FromEncodedObject(s, NULL, "strict") :\
-        PyObject_Format(s, f))
-#elif CYTHON_USE_TYPE_SLOTS
-    #define __Pyx_PyObject_FormatSimple(s, f) (\
-        likely(PyUnicode_CheckExact(s)) ? (Py_INCREF(s), s) :\
-        likely(PyLong_CheckExact(s)) ? PyLong_Type.tp_str(s) :\
-        likely(PyFloat_CheckExact(s)) ? PyFloat_Type.tp_str(s) :\
-        PyObject_Format(s, f))
-#else
-    #define __Pyx_PyObject_FormatSimple(s, f) (\
-        likely(PyUnicode_CheckExact(s)) ? (Py_INCREF(s), s) :\
-        PyObject_Format(s, f))
-#endif
-
-/* PyErrFetchRestore.proto */
-#if CYTHON_FAST_THREAD_STATE
-#define __Pyx_PyErr_Clear() __Pyx_ErrRestore(NULL, NULL, NULL)
-#define __Pyx_ErrRestoreWithState(type, value, tb)  __Pyx_ErrRestoreInState(PyThreadState_GET(), type, value, tb)
-#define __Pyx_ErrFetchWithState(type, value, tb)    __Pyx_ErrFetchInState(PyThreadState_GET(), type, value, tb)
-#define __Pyx_ErrRestore(type, value, tb)  __Pyx_ErrRestoreInState(__pyx_tstate, type, value, tb)
-#define __Pyx_ErrFetch(type, value, tb)    __Pyx_ErrFetchInState(__pyx_tstate, type, value, tb)
-static CYTHON_INLINE void __Pyx_ErrRestoreInState(PyThreadState *tstate, PyObject *type, PyObject *value, PyObject *tb);
-static CYTHON_INLINE void __Pyx_ErrFetchInState(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb);
-#if CYTHON_COMPILING_IN_CPYTHON
-#define __Pyx_PyErr_SetNone(exc) (Py_INCREF(exc), __Pyx_ErrRestore((exc), NULL, NULL))
-#else
-#define __Pyx_PyErr_SetNone(exc) PyErr_SetNone(exc)
-#endif
-#else
-#define __Pyx_PyErr_Clear() PyErr_Clear()
-#define __Pyx_PyErr_SetNone(exc) PyErr_SetNone(exc)
-#define __Pyx_ErrRestoreWithState(type, value, tb)  PyErr_Restore(type, value, tb)
-#define __Pyx_ErrFetchWithState(type, value, tb)  PyErr_Fetch(type, value, tb)
-#define __Pyx_ErrRestoreInState(tstate, type, value, tb)  PyErr_Restore(type, value, tb)
-#define __Pyx_ErrFetchInState(tstate, type, value, tb)  PyErr_Fetch(type, value, tb)
-#define __Pyx_ErrRestore(type, value, tb)  PyErr_Restore(type, value, tb)
-#define __Pyx_ErrFetch(type, value, tb)  PyErr_Fetch(type, value, tb)
-#endif
-
-/* RaiseException.proto */
-static void __Pyx_Raise(PyObject *type, PyObject *value, PyObject *tb, PyObject *cause);
-
-/* PySequenceContains.proto */
-static CYTHON_INLINE int __Pyx_PySequence_ContainsTF(PyObject* item, PyObject* seq, int eq) {
-    int result = PySequence_Contains(seq, item);
-    return unlikely(result < 0) ? result : (result == (eq == Py_EQ));
-}
-
-/* DictGetItem.proto */
-#if PY_MAJOR_VERSION >= 3 && !CYTHON_COMPILING_IN_PYPY
-static PyObject *__Pyx_PyDict_GetItem(PyObject *d, PyObject* key);
-#define __Pyx_PyObject_Dict_GetItem(obj, name)\
-    (likely(PyDict_CheckExact(obj)) ?\
-     __Pyx_PyDict_GetItem(obj, name) : PyObject_GetItem(obj, name))
-#else
-#define __Pyx_PyDict_GetItem(d, key) PyObject_GetItem(d, key)
-#define __Pyx_PyObject_Dict_GetItem(obj, name)  PyObject_GetItem(obj, name)
-#endif
-
-/* PyObjectLookupSpecial.proto */
-#if CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
-static CYTHON_INLINE PyObject* __Pyx_PyObject_LookupSpecial(PyObject* obj, PyObject* attr_name) {
-    PyObject *res;
-    PyTypeObject *tp = Py_TYPE(obj);
-#if PY_MAJOR_VERSION < 3
-    if (unlikely(PyInstance_Check(obj)))
-        return __Pyx_PyObject_GetAttrStr(obj, attr_name);
-#endif
-    res = _PyType_Lookup(tp, attr_name);
-    if (likely(res)) {
-        descrgetfunc f = Py_TYPE(res)->tp_descr_get;
-        if (!f) {
-            Py_INCREF(res);
-        } else {
-            res = f(res, obj, (PyObject *)tp);
-        }
-    } else {
-        PyErr_SetObject(PyExc_AttributeError, attr_name);
-    }
-    return res;
-}
-#else
-#define __Pyx_PyObject_LookupSpecial(o,n) __Pyx_PyObject_GetAttrStr(o,n)
-#endif
-
-/* IncludeStringH.proto */
-#include <string.h>
-
-/* BytesEquals.proto */
-static CYTHON_INLINE int __Pyx_PyBytes_Equals(PyObject* s1, PyObject* s2, int equals);
-
-/* JoinPyUnicode.proto */
-static PyObject* __Pyx_PyUnicode_Join(PyObject* value_tuple, Py_ssize_t value_count, Py_ssize_t result_ulength,
-                                      Py_UCS4 max_char);
-
-/* decode_c_string_utf16.proto */
-static CYTHON_INLINE PyObject *__Pyx_PyUnicode_DecodeUTF16(const char *s, Py_ssize_t size, const char *errors) {
-    int byteorder = 0;
-    return PyUnicode_DecodeUTF16(s, size, errors, &byteorder);
-}
-static CYTHON_INLINE PyObject *__Pyx_PyUnicode_DecodeUTF16LE(const char *s, Py_ssize_t size, const char *errors) {
-    int byteorder = -1;
-    return PyUnicode_DecodeUTF16(s, size, errors, &byteorder);
-}
-static CYTHON_INLINE PyObject *__Pyx_PyUnicode_DecodeUTF16BE(const char *s, Py_ssize_t size, const char *errors) {
-    int byteorder = 1;
-    return PyUnicode_DecodeUTF16(s, size, errors, &byteorder);
-}
-
-/* decode_c_bytes.proto */
-static CYTHON_INLINE PyObject* __Pyx_decode_c_bytes(
-         const char* cstring, Py_ssize_t length, Py_ssize_t start, Py_ssize_t stop,
-         const char* encoding, const char* errors,
-         PyObject* (*decode_func)(const char *s, Py_ssize_t size, const char *errors));
-
-/* decode_bytes.proto */
-static CYTHON_INLINE PyObject* __Pyx_decode_bytes(
-         PyObject* string, Py_ssize_t start, Py_ssize_t stop,
-         const char* encoding, const char* errors,
-         PyObject* (*decode_func)(const char *s, Py_ssize_t size, const char *errors)) {
-    return __Pyx_decode_c_bytes(
-        PyBytes_AS_STRING(string), PyBytes_GET_SIZE(string),
-        start, stop, encoding, errors, decode_func);
-}
-
-/* ListAppend.proto */
-#if CYTHON_USE_PYLIST_INTERNALS && CYTHON_ASSUME_SAFE_MACROS
-static CYTHON_INLINE int __Pyx_PyList_Append(PyObject* list, PyObject* x) {
-    PyListObject* L = (PyListObject*) list;
-    Py_ssize_t len = Py_SIZE(list);
-    if (likely(L->allocated > len) & likely(len > (L->allocated >> 1))) {
-        Py_INCREF(x);
-        PyList_SET_ITEM(list, len, x);
-        __Pyx_SET_SIZE(list, len + 1);
-        return 0;
-    }
-    return PyList_Append(list, x);
-}
-#else
-#define __Pyx_PyList_Append(L,x) PyList_Append(L,x)
-#endif
-
-/* GCCDiagnostics.proto */
-#if defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 6))
-#define __Pyx_HAS_GCC_DIAGNOSTIC
-#endif
-
-/* BuildPyUnicode.proto */
-static PyObject* __Pyx_PyUnicode_BuildFromAscii(Py_ssize_t ulength, char* chars, int clength,
-                                                int prepend_sign, char padding_char);
-
-/* CIntToPyUnicode.proto */
-static CYTHON_INLINE PyObject* __Pyx_PyUnicode_From_Py_ssize_t(Py_ssize_t value, Py_ssize_t width, char padding_char, char format_char);
-
-/* PyObject_GenericGetAttrNoDict.proto */
-#if CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP && PY_VERSION_HEX < 0x03070000
-static CYTHON_INLINE PyObject* __Pyx_PyObject_GenericGetAttrNoDict(PyObject* obj, PyObject* attr_name);
-#else
-#define __Pyx_PyObject_GenericGetAttrNoDict PyObject_GenericGetAttr
-#endif
-
-/* PyObject_GenericGetAttr.proto */
-#if CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP && PY_VERSION_HEX < 0x03070000
-static PyObject* __Pyx_PyObject_GenericGetAttr(PyObject* obj, PyObject* attr_name);
-#else
-#define __Pyx_PyObject_GenericGetAttr PyObject_GenericGetAttr
-#endif
-
-/* SetVTable.proto */
-static int __Pyx_SetVtable(PyObject *dict, void *vtable);
-
-/* PyErrExceptionMatches.proto */
-#if CYTHON_FAST_THREAD_STATE
-#define __Pyx_PyErr_ExceptionMatches(err) __Pyx_PyErr_ExceptionMatchesInState(__pyx_tstate, err)
-static CYTHON_INLINE int __Pyx_PyErr_ExceptionMatchesInState(PyThreadState* tstate, PyObject* err);
-#else
-#define __Pyx_PyErr_ExceptionMatches(err)  PyErr_ExceptionMatches(err)
-#endif
-
-/* PyObjectGetAttrStrNoError.proto */
-static CYTHON_INLINE PyObject* __Pyx_PyObject_GetAttrStrNoError(PyObject* obj, PyObject* attr_name);
-
-/* SetupReduce.proto */
-static int __Pyx_setup_reduce(PyObject* type_obj);
-
-/* Import.proto */
-static PyObject *__Pyx_Import(PyObject *name, PyObject *from_list, int level);
-
-/* ImportFrom.proto */
-static PyObject* __Pyx_ImportFrom(PyObject* module, PyObject* name);
-
-/* FetchCommonType.proto */
-static PyTypeObject* __Pyx_FetchCommonType(PyTypeObject* type);
-
-/* CythonFunctionShared.proto */
-#define __Pyx_CyFunction_USED 1
-#define __Pyx_CYFUNCTION_STATICMETHOD  0x01
-#define __Pyx_CYFUNCTION_CLASSMETHOD   0x02
-#define __Pyx_CYFUNCTION_CCLASS        0x04
-#define __Pyx_CyFunction_GetClosure(f)\
-    (((__pyx_CyFunctionObject *) (f))->func_closure)
-#define __Pyx_CyFunction_GetClassObj(f)\
-    (((__pyx_CyFunctionObject *) (f))->func_classobj)
-#define __Pyx_CyFunction_Defaults(type, f)\
-    ((type *)(((__pyx_CyFunctionObject *) (f))->defaults))
-#define __Pyx_CyFunction_SetDefaultsGetter(f, g)\
-    ((__pyx_CyFunctionObject *) (f))->defaults_getter = (g)
-typedef struct {
-    PyCFunctionObject func;
-#if PY_VERSION_HEX < 0x030500A0
-    PyObject *func_weakreflist;
-#endif
-    PyObject *func_dict;
-    PyObject *func_name;
-    PyObject *func_qualname;
-    PyObject *func_doc;
-    PyObject *func_globals;
-    PyObject *func_code;
-    PyObject *func_closure;
-    PyObject *func_classobj;
-    void *defaults;
-    int defaults_pyobjects;
-    size_t defaults_size;  // used by FusedFunction for copying defaults
-    int flags;
-    PyObject *defaults_tuple;
-    PyObject *defaults_kwdict;
-    PyObject *(*defaults_getter)(PyObject *);
-    PyObject *func_annotations;
-} __pyx_CyFunctionObject;
-static PyTypeObject *__pyx_CyFunctionType = 0;
-#define __Pyx_CyFunction_Check(obj)  (__Pyx_TypeCheck(obj, __pyx_CyFunctionType))
-static PyObject *__Pyx_CyFunction_Init(__pyx_CyFunctionObject* op, PyMethodDef *ml,
-                                      int flags, PyObject* qualname,
-                                      PyObject *self,
-                                      PyObject *module, PyObject *globals,
-                                      PyObject* code);
-static CYTHON_INLINE void *__Pyx_CyFunction_InitDefaults(PyObject *m,
-                                                         size_t size,
-                                                         int pyobjects);
-static CYTHON_INLINE void __Pyx_CyFunction_SetDefaultsTuple(PyObject *m,
-                                                            PyObject *tuple);
-static CYTHON_INLINE void __Pyx_CyFunction_SetDefaultsKwDict(PyObject *m,
-                                                             PyObject *dict);
-static CYTHON_INLINE void __Pyx_CyFunction_SetAnnotationsDict(PyObject *m,
-                                                              PyObject *dict);
-static int __pyx_CyFunction_init(void);
-
-/* CythonFunction.proto */
-static PyObject *__Pyx_CyFunction_New(PyMethodDef *ml,
-                                      int flags, PyObject* qualname,
-                                      PyObject *closure,
-                                      PyObject *module, PyObject *globals,
-                                      PyObject* code);
-
-/* GetNameInClass.proto */
-#define __Pyx_GetNameInClass(var, nmspace, name)  (var) = __Pyx__GetNameInClass(nmspace, name)
-static PyObject *__Pyx__GetNameInClass(PyObject *nmspace, PyObject *name);
-
-/* CLineInTraceback.proto */
-#ifdef CYTHON_CLINE_IN_TRACEBACK
-#define __Pyx_CLineForTraceback(tstate, c_line)  (((CYTHON_CLINE_IN_TRACEBACK)) ? c_line : 0)
-#else
-static int __Pyx_CLineForTraceback(PyThreadState *tstate, int c_line);
-#endif
-
-/* CodeObjectCache.proto */
-typedef struct {
-    PyCodeObject* code_object;
-    int code_line;
-} __Pyx_CodeObjectCacheEntry;
-struct __Pyx_CodeObjectCache {
-    int count;
-    int max_count;
-    __Pyx_CodeObjectCacheEntry* entries;
-};
-static struct __Pyx_CodeObjectCache __pyx_code_cache = {0,0,NULL};
-static int __pyx_bisect_code_objects(__Pyx_CodeObjectCacheEntry* entries, int count, int code_line);
-static PyCodeObject *__pyx_find_code_object(int code_line);
-static void __pyx_insert_code_object(int code_line, PyCodeObject* code_object);
-
-/* AddTraceback.proto */
-static void __Pyx_AddTraceback(const char *funcname, int c_line,
-                               int py_line, const char *filename);
-
-/* None.proto */
-#include <new>
-
-/* CppExceptionConversion.proto */
-#ifndef __Pyx_CppExn2PyErr
-#include <new>
-#include <typeinfo>
-#include <stdexcept>
-#include <ios>
-static void __Pyx_CppExn2PyErr() {
-  try {
-    if (PyErr_Occurred())
-      ; // let the latest Python exn pass through and ignore the current one
-    else
-      throw;
-  } catch (const std::bad_alloc& exn) {
-    PyErr_SetString(PyExc_MemoryError, exn.what());
-  } catch (const std::bad_cast& exn) {
-    PyErr_SetString(PyExc_TypeError, exn.what());
-  } catch (const std::bad_typeid& exn) {
-    PyErr_SetString(PyExc_TypeError, exn.what());
-  } catch (const std::domain_error& exn) {
-    PyErr_SetString(PyExc_ValueError, exn.what());
-  } catch (const std::invalid_argument& exn) {
-    PyErr_SetString(PyExc_ValueError, exn.what());
-  } catch (const std::ios_base::failure& exn) {
-    PyErr_SetString(PyExc_IOError, exn.what());
-  } catch (const std::out_of_range& exn) {
-    PyErr_SetString(PyExc_IndexError, exn.what());
-  } catch (const std::overflow_error& exn) {
-    PyErr_SetString(PyExc_OverflowError, exn.what());
-  } catch (const std::range_error& exn) {
-    PyErr_SetString(PyExc_ArithmeticError, exn.what());
-  } catch (const std::underflow_error& exn) {
-    PyErr_SetString(PyExc_ArithmeticError, exn.what());
-  } catch (const std::exception& exn) {
-    PyErr_SetString(PyExc_RuntimeError, exn.what());
-  }
-  catch (...)
-  {
-    PyErr_SetString(PyExc_RuntimeError, "Unknown exception");
-  }
-}
-#endif
-
-/* CIntFromPy.proto */
-static CYTHON_INLINE int __Pyx_PyInt_As_int(PyObject *);
-
-/* CIntFromPy.proto */
-static CYTHON_INLINE size_t __Pyx_PyInt_As_size_t(PyObject *);
-
-/* CIntToPy.proto */
-static CYTHON_INLINE PyObject* __Pyx_PyInt_From_long(long value);
-
-/* CIntFromPy.proto */
-static CYTHON_INLINE long __Pyx_PyInt_As_long(PyObject *);
-
-/* FastTypeChecks.proto */
-#if CYTHON_COMPILING_IN_CPYTHON
-#define __Pyx_TypeCheck(obj, type) __Pyx_IsSubtype(Py_TYPE(obj), (PyTypeObject *)type)
-static CYTHON_INLINE int __Pyx_IsSubtype(PyTypeObject *a, PyTypeObject *b);
-static CYTHON_INLINE int __Pyx_PyErr_GivenExceptionMatches(PyObject *err, PyObject *type);
-static CYTHON_INLINE int __Pyx_PyErr_GivenExceptionMatches2(PyObject *err, PyObject *type1, PyObject *type2);
-#else
-#define __Pyx_TypeCheck(obj, type) PyObject_TypeCheck(obj, (PyTypeObject *)type)
-#define __Pyx_PyErr_GivenExceptionMatches(err, type) PyErr_GivenExceptionMatches(err, type)
-#define __Pyx_PyErr_GivenExceptionMatches2(err, type1, type2) (PyErr_GivenExceptionMatches(err, type1) || PyErr_GivenExceptionMatches(err, type2))
-#endif
-#define __Pyx_PyException_Check(obj) __Pyx_TypeCheck(obj, PyExc_Exception)
-
-/* CheckBinaryVersion.proto */
-static int __Pyx_check_binary_version(void);
-
-/* InitStrings.proto */
-static int __Pyx_InitStrings(__Pyx_StringTabEntry *t);
-
-static PyObject *__pyx_f_3crf_7Trainer__on_message(struct __pyx_obj_3crf_Trainer *__pyx_v_self, std::string __pyx_v_message); /* proto*/
-static PyObject *__pyx_f_3crf_5Model_set_sequence(struct __pyx_obj_3crf_Model *__pyx_v_self, PyObject *__pyx_v_sequence, int __pyx_skip_dispatch); /* proto*/
-
-/* Module declarations from 'libc.string' */
-
-/* Module declarations from 'libcpp.string' */
-
-/* Module declarations from 'libcpp.vector' */
-
-/* Module declarations from 'crfsuite_api' */
-
-/* Module declarations from 'crf' */
-static PyTypeObject *__pyx_ptype_3crf_Trainer = 0;
-static PyTypeObject *__pyx_ptype_3crf_Model = 0;
-static PyTypeObject *__pyx_ptype_3crf_ItemSequence = 0;
-static CRFSuite::Item __pyx_f_3crf_to_item(PyObject *); /*proto*/
-static CRFSuite::ItemSequence __pyx_f_3crf_to_seq(PyObject *); /*proto*/
-static std::string __pyx_convert_string_from_py_std__in_string(PyObject *); /*proto*/
-static CYTHON_INLINE PyObject *__pyx_convert_PyObject_string_to_py_std__in_string(std::string const &); /*proto*/
-static CYTHON_INLINE PyObject *__pyx_convert_PyUnicode_string_to_py_std__in_string(std::string const &); /*proto*/
-static CYTHON_INLINE PyObject *__pyx_convert_PyStr_string_to_py_std__in_string(std::string const &); /*proto*/
-static CYTHON_INLINE PyObject *__pyx_convert_PyBytes_string_to_py_std__in_string(std::string const &); /*proto*/
-static CYTHON_INLINE PyObject *__pyx_convert_PyByteArray_string_to_py_std__in_string(std::string const &); /*proto*/
-static PyObject *__pyx_convert_vector_to_py_std_3a__3a_string(const std::vector<std::string>  &); /*proto*/
-static std::vector<std::string>  __pyx_convert_vector_from_py_std_3a__3a_string(PyObject *); /*proto*/
-#define __Pyx_MODULE_NAME "crf"
-extern int __pyx_module_is_main_crf;
-int __pyx_module_is_main_crf = 0;
-
-/* Implementation of 'crf' */
-static PyObject *__pyx_builtin_staticmethod;
-static PyObject *__pyx_builtin_ValueError;
-static PyObject *__pyx_builtin_TypeError;
-static PyObject *__pyx_builtin_range;
-static PyObject *__pyx_builtin_open;
-static const char __pyx_k_c[] = "c";
-static const char __pyx_k__6[] = ":";
-static const char __pyx_k__7[] = ")>";
-static const char __pyx_k_ap[] = "ap";
-static const char __pyx_k_c1[] = "c1";
-static const char __pyx_k_c2[] = "c2";
-static const char __pyx_k_os[] = "os";
-static const char __pyx_k_pa[] = "pa";
-static const char __pyx_k_rb[] = "rb";
-static const char __pyx_k_crf[] = "crf";
-static const char __pyx_k_get[] = "get";
-static const char __pyx_k_log[] = "_log";
-static const char __pyx_k_sgd[] = "sgd";
-static const char __pyx_k_arow[] = "arow";
-static const char __pyx_k_exit[] = "__exit__";
-static const char __pyx_k_info[] = "info";
-static const char __pyx_k_lCRF[] = "lCRF";
-static const char __pyx_k_load[] = "load";
-static const char __pyx_k_main[] = "__main__";
-static const char __pyx_k_name[] = "__name__";
-static const char __pyx_k_open[] = "open";
-static const char __pyx_k_read[] = "read";
-static const char __pyx_k_seek[] = "seek";
-static const char __pyx_k_tell[] = "tell";
-static const char __pyx_k_test[] = "__test__";
-static const char __pyx_k_type[] = "type";
-static const char __pyx_k_Model[] = "Model";
-static const char __pyx_k_crf1d[] = "crf1d";
-static const char __pyx_k_delta[] = "delta";
-static const char __pyx_k_enter[] = "__enter__";
-static const char __pyx_k_gamma[] = "gamma";
-static const char __pyx_k_group[] = "group";
-static const char __pyx_k_index[] = "index";
-static const char __pyx_k_items[] = "items";
-static const char __pyx_k_l2sgd[] = "l2sgd";
-static const char __pyx_k_label[] = "label";
-static const char __pyx_k_lbfgs[] = "lbfgs";
-static const char __pyx_k_lower[] = "lower";
-static const char __pyx_k_magic[] = "magic";
-static const char __pyx_k_model[] = "model";
-static const char __pyx_k_param[] = "param";
-static const char __pyx_k_range[] = "range";
-static const char __pyx_k_value[] = "value";
-static const char __pyx_k_LOGGER[] = "LOGGER";
-static const char __pyx_k_Labels[] = "Labels";
-static const char __pyx_k_Logger[] = "Logger";
-static const char __pyx_k_import[] = "__import__";
-static const char __pyx_k_labels[] = "labels";
-static const char __pyx_k_period[] = "period";
-static const char __pyx_k_reduce[] = "__reduce__";
-static const char __pyx_k_O_CREAT[] = "O_CREAT";
-static const char __pyx_k_Trainer[] = "Trainer";
-static const char __pyx_k_epsilon[] = "epsilon";
-static const char __pyx_k_pa_type[] = "pa_type";
-static const char __pyx_k_Filepath[] = "Filepath";
-static const char __pyx_k_O_WRONLY[] = "O_WRONLY";
-static const char __pyx_k_SEEK_END[] = "SEEK_END";
-static const char __pyx_k_Sequence[] = "Sequence";
-static const char __pyx_k_filepath[] = "filepath";
-static const char __pyx_k_getstate[] = "__getstate__";
-static const char __pyx_k_marginal[] = "marginal";
-static const char __pyx_k_min_freq[] = "min_freq";
-static const char __pyx_k_sequence[] = "sequence";
-static const char __pyx_k_setstate[] = "__setstate__";
-static const char __pyx_k_variance[] = "variance";
-static const char __pyx_k_TypeError[] = "TypeError";
-static const char __pyx_k_algorithm[] = "algorithm";
-static const char __pyx_k_averaging[] = "averaging";
-static const char __pyx_k_reduce_ex[] = "__reduce_ex__";
-static const char __pyx_k_set_param[] = "set_param";
-static const char __pyx_k_Model_file[] = "Model file ";
-static const char __pyx_k_ValueError[] = "ValueError";
-static const char __pyx_k_linesearch[] = "linesearch";
-static const char __pyx_k_pyx_vtable[] = "__pyx_vtable__";
-static const char __pyx_k_set_params[] = "set_params";
-static const char __pyx_k_check_model[] = "check_model";
-static const char __pyx_k_kwarg2param[] = "kwarg2param";
-static const char __pyx_k_param2kwarg[] = "param2kwarg";
-static const char __pyx_k_ItemSequence[] = "<ItemSequence (";
-static const char __pyx_k_num_memories[] = "num_memories";
-static const char __pyx_k_set_sequence[] = "set_sequence";
-static const char __pyx_k_staticmethod[] = "staticmethod";
-static const char __pyx_k_chaine_typing[] = "chaine.typing";
-static const char __pyx_k_reduce_cython[] = "__reduce_cython__";
-static const char __pyx_k_ItemSequence_2[] = "ItemSequence";
-static const char __pyx_k_Trainer_lambda[] = "Trainer.<lambda>";
-static const char __pyx_k_cast_parameter[] = "cast_parameter";
-static const char __pyx_k_chaine_logging[] = "chaine.logging";
-static const char __pyx_k_max_iterations[] = "max_iterations";
-static const char __pyx_k_max_linesearch[] = "max_linesearch";
-static const char __pyx_k_model_filepath[] = "model_filepath";
-static const char __pyx_k_calibration_eta[] = "calibration.eta";
-static const char __pyx_k_error_sensitive[] = "error_sensitive";
-static const char __pyx_k_feature_minfreq[] = "feature.minfreq";
-static const char __pyx_k_parameter_types[] = "_parameter_types";
-static const char __pyx_k_setstate_cython[] = "__setstate_cython__";
-static const char __pyx_k_calibration_rate[] = "calibration.rate";
-static const char __pyx_k_select_algorithm[] = "select_algorithm";
-static const char __pyx_k_translate_params[] = "translate_params";
-static const char __pyx_k_algorithm_aliases[] = "_algorithm_aliases";
-static const char __pyx_k_calibration_eta_2[] = "calibration_eta";
-static const char __pyx_k_Invalid_model_file[] = "Invalid model file ";
-static const char __pyx_k_calibration_rate_2[] = "calibration_rate";
-static const char __pyx_k_cline_in_traceback[] = "cline_in_traceback";
-static const char __pyx_k_passive_aggressive[] = "passive-aggressive";
-static const char __pyx_k_all_possible_states[] = "all_possible_states";
-static const char __pyx_k_averaged_perceptron[] = "averaged-perceptron";
-static const char __pyx_k_calibration_samples[] = "calibration.samples";
-static const char __pyx_k_limited_memory_bfgs[] = "limited-memory-bfgs";
-static const char __pyx_k_chaine__core_crf_pyx[] = "chaine/_core/crf.pyx";
-static const char __pyx_k_calibration_samples_2[] = "calibration_samples";
-static const char __pyx_k_Cannot_load_model_file[] = "Cannot load model file ";
-static const char __pyx_k_calibration_candidates[] = "calibration.candidates";
-static const char __pyx_k_calibration_max_trials[] = "calibration.max_trials";
-static const char __pyx_k_feature_possible_states[] = "feature.possible_states";
-static const char __pyx_k_all_possible_transitions[] = "all_possible_transitions";
-static const char __pyx_k_calibration_candidates_2[] = "calibration_candidates";
-static const char __pyx_k_calibration_max_trials_2[] = "calibration_max_trials";
-static const char __pyx_k_is_no_available_algorithm[] = " is no available algorithm";
-static const char __pyx_k_stochastic_gradient_descent[] = "stochastic-gradient-descent";
-static const char __pyx_k_feature_possible_transitions[] = "feature.possible_transitions";
-static const char __pyx_k_does_not_have_a_complete_header[] = " does not have a complete header";
-static const char __pyx_k_no_default___reduce___due_to_non[] = "no default __reduce__ due to non-trivial __cinit__";
-static const char __pyx_k_self__tagger_cannot_be_converted[] = "self._tagger cannot be converted to a Python object for pickling";
-static const char __pyx_k_self_c_sequence_cannot_be_conver[] = "self.c_sequence cannot be converted to a Python object for pickling";
-static PyObject *__pyx_kp_u_Cannot_load_model_file;
-static PyObject *__pyx_n_s_Filepath;
-static PyObject *__pyx_kp_u_Invalid_model_file;
-static PyObject *__pyx_kp_u_ItemSequence;
-static PyObject *__pyx_n_s_ItemSequence_2;
-static PyObject *__pyx_n_s_LOGGER;
-static PyObject *__pyx_n_s_Labels;
-static PyObject *__pyx_n_s_Logger;
-static PyObject *__pyx_n_s_Model;
-static PyObject *__pyx_kp_u_Model_file;
-static PyObject *__pyx_n_s_O_CREAT;
-static PyObject *__pyx_n_s_O_WRONLY;
-static PyObject *__pyx_n_s_SEEK_END;
-static PyObject *__pyx_n_s_Sequence;
-static PyObject *__pyx_n_s_Trainer;
-static PyObject *__pyx_n_s_Trainer_lambda;
-static PyObject *__pyx_n_s_TypeError;
-static PyObject *__pyx_n_s_ValueError;
-static PyObject *__pyx_kp_b__6;
-static PyObject *__pyx_kp_u__7;
-static PyObject *__pyx_n_s_algorithm;
-static PyObject *__pyx_n_s_algorithm_aliases;
-static PyObject *__pyx_n_s_all_possible_states;
-static PyObject *__pyx_n_s_all_possible_transitions;
-static PyObject *__pyx_n_s_ap;
-static PyObject *__pyx_n_s_arow;
-static PyObject *__pyx_kp_s_averaged_perceptron;
-static PyObject *__pyx_n_s_averaging;
-static PyObject *__pyx_n_s_c;
-static PyObject *__pyx_n_s_c1;
-static PyObject *__pyx_n_s_c2;
-static PyObject *__pyx_kp_s_calibration_candidates;
-static PyObject *__pyx_n_s_calibration_candidates_2;
-static PyObject *__pyx_kp_s_calibration_eta;
-static PyObject *__pyx_n_s_calibration_eta_2;
-static PyObject *__pyx_kp_s_calibration_max_trials;
-static PyObject *__pyx_n_s_calibration_max_trials_2;
-static PyObject *__pyx_kp_s_calibration_rate;
-static PyObject *__pyx_n_s_calibration_rate_2;
-static PyObject *__pyx_kp_s_calibration_samples;
-static PyObject *__pyx_n_s_calibration_samples_2;
-static PyObject *__pyx_n_s_cast_parameter;
-static PyObject *__pyx_kp_s_chaine__core_crf_pyx;
-static PyObject *__pyx_n_s_chaine_logging;
-static PyObject *__pyx_n_s_chaine_typing;
-static PyObject *__pyx_n_s_check_model;
-static PyObject *__pyx_n_s_cline_in_traceback;
-static PyObject *__pyx_n_s_crf;
-static PyObject *__pyx_n_b_crf1d;
-static PyObject *__pyx_n_s_delta;
-static PyObject *__pyx_kp_u_does_not_have_a_complete_header;
-static PyObject *__pyx_n_s_enter;
-static PyObject *__pyx_n_s_epsilon;
-static PyObject *__pyx_n_s_error_sensitive;
-static PyObject *__pyx_n_s_exit;
-static PyObject *__pyx_kp_s_feature_minfreq;
-static PyObject *__pyx_kp_s_feature_possible_states;
-static PyObject *__pyx_kp_s_feature_possible_transitions;
-static PyObject *__pyx_n_s_filepath;
-static PyObject *__pyx_n_s_gamma;
-static PyObject *__pyx_n_s_get;
-static PyObject *__pyx_n_s_getstate;
-static PyObject *__pyx_n_s_group;
-static PyObject *__pyx_n_s_import;
-static PyObject *__pyx_n_s_index;
-static PyObject *__pyx_n_s_info;
-static PyObject *__pyx_kp_u_is_no_available_algorithm;
-static PyObject *__pyx_n_s_items;
-static PyObject *__pyx_n_s_kwarg2param;
-static PyObject *__pyx_n_b_l2sgd;
-static PyObject *__pyx_n_s_l2sgd;
-static PyObject *__pyx_n_b_lCRF;
-static PyObject *__pyx_n_s_label;
-static PyObject *__pyx_n_s_labels;
-static PyObject *__pyx_n_s_lbfgs;
-static PyObject *__pyx_kp_s_limited_memory_bfgs;
-static PyObject *__pyx_n_s_linesearch;
-static PyObject *__pyx_n_s_load;
-static PyObject *__pyx_n_s_log;
-static PyObject *__pyx_n_s_lower;
-static PyObject *__pyx_n_s_magic;
-static PyObject *__pyx_n_s_main;
-static PyObject *__pyx_n_s_marginal;
-static PyObject *__pyx_n_s_max_iterations;
-static PyObject *__pyx_n_s_max_linesearch;
-static PyObject *__pyx_n_s_min_freq;
-static PyObject *__pyx_n_s_model;
-static PyObject *__pyx_n_s_model_filepath;
-static PyObject *__pyx_n_s_name;
-static PyObject *__pyx_kp_s_no_default___reduce___due_to_non;
-static PyObject *__pyx_n_s_num_memories;
-static PyObject *__pyx_n_s_open;
-static PyObject *__pyx_n_s_os;
-static PyObject *__pyx_n_s_pa;
-static PyObject *__pyx_n_s_pa_type;
-static PyObject *__pyx_n_s_param;
-static PyObject *__pyx_n_s_param2kwarg;
-static PyObject *__pyx_n_s_parameter_types;
-static PyObject *__pyx_kp_s_passive_aggressive;
-static PyObject *__pyx_n_s_period;
-static PyObject *__pyx_n_s_pyx_vtable;
-static PyObject *__pyx_n_s_range;
-static PyObject *__pyx_n_s_rb;
-static PyObject *__pyx_n_s_read;
-static PyObject *__pyx_n_s_reduce;
-static PyObject *__pyx_n_s_reduce_cython;
-static PyObject *__pyx_n_s_reduce_ex;
-static PyObject *__pyx_n_s_seek;
-static PyObject *__pyx_n_s_select_algorithm;
-static PyObject *__pyx_kp_s_self__tagger_cannot_be_converted;
-static PyObject *__pyx_kp_s_self_c_sequence_cannot_be_conver;
-static PyObject *__pyx_n_s_sequence;
-static PyObject *__pyx_n_s_set_param;
-static PyObject *__pyx_n_s_set_params;
-static PyObject *__pyx_n_s_set_sequence;
-static PyObject *__pyx_n_s_setstate;
-static PyObject *__pyx_n_s_setstate_cython;
-static PyObject *__pyx_n_s_sgd;
-static PyObject *__pyx_n_s_staticmethod;
-static PyObject *__pyx_kp_s_stochastic_gradient_descent;
-static PyObject *__pyx_n_s_tell;
-static PyObject *__pyx_n_s_test;
-static PyObject *__pyx_n_s_translate_params;
-static PyObject *__pyx_n_s_type;
-static PyObject *__pyx_n_s_value;
-static PyObject *__pyx_n_s_variance;
-static PyObject *__pyx_lambda_funcdef_3crf_7Trainer_lambda(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_value); /* proto */
-static PyObject *__pyx_lambda_funcdef_3crf_7Trainer_lambda1(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_value); /* proto */
-static PyObject *__pyx_lambda_funcdef_3crf_7Trainer_lambda2(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_value); /* proto */
-static PyObject *__pyx_lambda_funcdef_3crf_7Trainer_lambda3(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_value); /* proto */
-static int __pyx_pf_3crf_7Trainer___init__(struct __pyx_obj_3crf_Trainer *__pyx_v_self, PyObject *__pyx_v_algorithm, PyObject *__pyx_v_kwargs); /* proto */
-static int __pyx_pf_3crf_7Trainer_2__cinit__(struct __pyx_obj_3crf_Trainer *__pyx_v_self); /* proto */
-static PyObject *__pyx_pf_3crf_7Trainer_6params___get__(struct __pyx_obj_3crf_Trainer *__pyx_v_self); /* proto */
-static PyObject *__pyx_pf_3crf_7Trainer_4train(struct __pyx_obj_3crf_Trainer *__pyx_v_self, PyObject *__pyx_v_model_filepath); /* proto */
-static PyObject *__pyx_pf_3crf_7Trainer_6_log(CYTHON_UNUSED struct __pyx_obj_3crf_Trainer *__pyx_v_self, PyObject *__pyx_v_message); /* proto */
-static PyObject *__pyx_pf_3crf_7Trainer_8append(struct __pyx_obj_3crf_Trainer *__pyx_v_self, PyObject *__pyx_v_sequence, PyObject *__pyx_v_labels, int __pyx_v_group); /* proto */
-static PyObject *__pyx_pf_3crf_7Trainer_10translate_params(struct __pyx_obj_3crf_Trainer *__pyx_v_self, PyObject *__pyx_v_kwargs); /* proto */
-static PyObject *__pyx_pf_3crf_7Trainer_12select_algorithm(struct __pyx_obj_3crf_Trainer *__pyx_v_self, PyObject *__pyx_v_algorithm); /* proto */
-static PyObject *__pyx_pf_3crf_7Trainer_14set_params(struct __pyx_obj_3crf_Trainer *__pyx_v_self, PyObject *__pyx_v_params); /* proto */
-static PyObject *__pyx_pf_3crf_7Trainer_16set_param(struct __pyx_obj_3crf_Trainer *__pyx_v_self, PyObject *__pyx_v_param, PyObject *__pyx_v_value); /* proto */
-static PyObject *__pyx_pf_3crf_7Trainer_18get_param(struct __pyx_obj_3crf_Trainer *__pyx_v_self, PyObject *__pyx_v_param); /* proto */
-static PyObject *__pyx_pf_3crf_7Trainer_20cast_parameter(struct __pyx_obj_3crf_Trainer *__pyx_v_self, PyObject *__pyx_v_param, PyObject *__pyx_v_value); /* proto */
-static PyObject *__pyx_pf_3crf_7Trainer_26__reduce_cython__(CYTHON_UNUSED struct __pyx_obj_3crf_Trainer *__pyx_v_self); /* proto */
-static PyObject *__pyx_pf_3crf_7Trainer_28__setstate_cython__(CYTHON_UNUSED struct __pyx_obj_3crf_Trainer *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v___pyx_state); /* proto */
-static int __pyx_pf_3crf_5Model___init__(struct __pyx_obj_3crf_Model *__pyx_v_self, PyObject *__pyx_v_model_filepath); /* proto */
-static PyObject *__pyx_pf_3crf_5Model_6labels___get__(struct __pyx_obj_3crf_Model *__pyx_v_self); /* proto */
-static PyObject *__pyx_pf_3crf_5Model_2predict_single(struct __pyx_obj_3crf_Model *__pyx_v_self, PyObject *__pyx_v_sequence); /* proto */
-static PyObject *__pyx_pf_3crf_5Model_4predict_proba_single(struct __pyx_obj_3crf_Model *__pyx_v_self, PyObject *__pyx_v_sequence); /* proto */
-static PyObject *__pyx_pf_3crf_5Model_6load(struct __pyx_obj_3crf_Model *__pyx_v_self, PyObject *__pyx_v_filepath); /* proto */
-static PyObject *__pyx_pf_3crf_5Model_8marginal(struct __pyx_obj_3crf_Model *__pyx_v_self, PyObject *__pyx_v_label, PyObject *__pyx_v_index); /* proto */
-static PyObject *__pyx_pf_3crf_5Model_10set_sequence(struct __pyx_obj_3crf_Model *__pyx_v_self, PyObject *__pyx_v_sequence); /* proto */
-static PyObject *__pyx_pf_3crf_5Model_12check_model(PyObject *__pyx_v_filepath); /* proto */
-static PyObject *__pyx_pf_3crf_5Model_14dump_transitions(struct __pyx_obj_3crf_Model *__pyx_v_self, PyObject *__pyx_v_filepath); /* proto */
-static PyObject *__pyx_pf_3crf_5Model_16dump_states(struct __pyx_obj_3crf_Model *__pyx_v_self, PyObject *__pyx_v_filepath); /* proto */
-static PyObject *__pyx_pf_3crf_5Model_18__reduce_cython__(CYTHON_UNUSED struct __pyx_obj_3crf_Model *__pyx_v_self); /* proto */
-static PyObject *__pyx_pf_3crf_5Model_20__setstate_cython__(CYTHON_UNUSED struct __pyx_obj_3crf_Model *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v___pyx_state); /* proto */
-static int __pyx_pf_3crf_12ItemSequence___init__(struct __pyx_obj_3crf_ItemSequence *__pyx_v_self, PyObject *__pyx_v_sequence); /* proto */
-static PyObject *__pyx_pf_3crf_12ItemSequence_2items(struct __pyx_obj_3crf_ItemSequence *__pyx_v_self); /* proto */
-static Py_ssize_t __pyx_pf_3crf_12ItemSequence_4__len__(struct __pyx_obj_3crf_ItemSequence *__pyx_v_self); /* proto */
-static PyObject *__pyx_pf_3crf_12ItemSequence_6__repr__(struct __pyx_obj_3crf_ItemSequence *__pyx_v_self); /* proto */
-static PyObject *__pyx_pf_3crf_12ItemSequence_8__reduce_cython__(CYTHON_UNUSED struct __pyx_obj_3crf_ItemSequence *__pyx_v_self); /* proto */
-static PyObject *__pyx_pf_3crf_12ItemSequence_10__setstate_cython__(CYTHON_UNUSED struct __pyx_obj_3crf_ItemSequence *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v___pyx_state); /* proto */
-static PyObject *__pyx_tp_new_3crf_Trainer(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
-static PyObject *__pyx_tp_new_3crf_Model(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
-static PyObject *__pyx_tp_new_3crf_ItemSequence(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
-static __Pyx_CachedCFunction __pyx_umethod_PyString_Type_lower = {0, &__pyx_n_s_lower, 0, 0, 0};
-static PyObject *__pyx_int_0;
-static PyObject *__pyx_int_4;
-static PyObject *__pyx_int_48;
-static PyObject *__pyx_tuple_;
-static PyObject *__pyx_tuple__2;
-static PyObject *__pyx_tuple__3;
-static PyObject *__pyx_tuple__4;
-static PyObject *__pyx_tuple__5;
-static PyObject *__pyx_tuple__8;
-static PyObject *__pyx_tuple__9;
-static PyObject *__pyx_tuple__10;
-static PyObject *__pyx_codeobj__11;
-/* Late includes */
-
-/* "crf.pyx":57
- *     _parameter_types = {
- *             "feature.minfreq": float,
- *             "feature.possible_states": lambda value: bool(int(value)),             # <<<<<<<<<<<<<<
- *             "feature.possible_transitions": lambda value: bool(int(value)),
- *             "c1": float,
- */
-
-/* Python wrapper */
-static PyObject *__pyx_pw_3crf_7Trainer_22lambda(PyObject *__pyx_self, PyObject *__pyx_v_value); /*proto*/
-static PyMethodDef __pyx_mdef_3crf_7Trainer_22lambda = {"lambda", (PyCFunction)__pyx_pw_3crf_7Trainer_22lambda, METH_O, 0};
-static PyObject *__pyx_pw_3crf_7Trainer_22lambda(PyObject *__pyx_self, PyObject *__pyx_v_value) {
-  PyObject *__pyx_r = 0;
-  __Pyx_RefNannyDeclarations
-  __Pyx_RefNannySetupContext("lambda (wrapper)", 0);
-  __pyx_r = __pyx_lambda_funcdef_3crf_7Trainer_lambda(__pyx_self, ((PyObject *)__pyx_v_value));
-
-  /* function exit code */
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-static PyObject *__pyx_lambda_funcdef_3crf_7Trainer_lambda(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_value) {
-  PyObject *__pyx_r = NULL;
-  __Pyx_RefNannyDeclarations
-  PyObject *__pyx_t_1 = NULL;
-  int __pyx_t_2;
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("lambda", 0);
-  __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = __Pyx_PyNumber_Int(__pyx_v_value); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 57, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 57, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_t_1 = __Pyx_PyBool_FromLong((!(!__pyx_t_2))); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 57, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __pyx_r = __pyx_t_1;
-  __pyx_t_1 = 0;
-  goto __pyx_L0;
-
-  /* function exit code */
-  __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_1);
-  __Pyx_AddTraceback("crf.Trainer.lambda", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __pyx_r = NULL;
-  __pyx_L0:;
-  __Pyx_XGIVEREF(__pyx_r);
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-/* "crf.pyx":58
- *             "feature.minfreq": float,
- *             "feature.possible_states": lambda value: bool(int(value)),
- *             "feature.possible_transitions": lambda value: bool(int(value)),             # <<<<<<<<<<<<<<
- *             "c1": float,
- *             "c2": float,
- */
-
-/* Python wrapper */
-static PyObject *__pyx_pw_3crf_7Trainer_23lambda1(PyObject *__pyx_self, PyObject *__pyx_v_value); /*proto*/
-static PyMethodDef __pyx_mdef_3crf_7Trainer_23lambda1 = {"lambda1", (PyCFunction)__pyx_pw_3crf_7Trainer_23lambda1, METH_O, 0};
-static PyObject *__pyx_pw_3crf_7Trainer_23lambda1(PyObject *__pyx_self, PyObject *__pyx_v_value) {
-  PyObject *__pyx_r = 0;
-  __Pyx_RefNannyDeclarations
-  __Pyx_RefNannySetupContext("lambda1 (wrapper)", 0);
-  __pyx_r = __pyx_lambda_funcdef_3crf_7Trainer_lambda1(__pyx_self, ((PyObject *)__pyx_v_value));
-
-  /* function exit code */
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-static PyObject *__pyx_lambda_funcdef_3crf_7Trainer_lambda1(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_value) {
-  PyObject *__pyx_r = NULL;
-  __Pyx_RefNannyDeclarations
-  PyObject *__pyx_t_1 = NULL;
-  int __pyx_t_2;
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("lambda1", 0);
-  __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = __Pyx_PyNumber_Int(__pyx_v_value); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 58, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 58, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_t_1 = __Pyx_PyBool_FromLong((!(!__pyx_t_2))); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 58, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __pyx_r = __pyx_t_1;
-  __pyx_t_1 = 0;
-  goto __pyx_L0;
-
-  /* function exit code */
-  __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_1);
-  __Pyx_AddTraceback("crf.Trainer.lambda1", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __pyx_r = NULL;
-  __pyx_L0:;
-  __Pyx_XGIVEREF(__pyx_r);
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-/* "crf.pyx":75
- *             "type": int,
- *             "c": float,
- *             "error_sensitive": lambda value: bool(int(value)),             # <<<<<<<<<<<<<<
- *             "averaging": lambda value: bool(int(value)),
- *             "variance": float,
- */
-
-/* Python wrapper */
-static PyObject *__pyx_pw_3crf_7Trainer_24lambda2(PyObject *__pyx_self, PyObject *__pyx_v_value); /*proto*/
-static PyMethodDef __pyx_mdef_3crf_7Trainer_24lambda2 = {"lambda2", (PyCFunction)__pyx_pw_3crf_7Trainer_24lambda2, METH_O, 0};
-static PyObject *__pyx_pw_3crf_7Trainer_24lambda2(PyObject *__pyx_self, PyObject *__pyx_v_value) {
-  PyObject *__pyx_r = 0;
-  __Pyx_RefNannyDeclarations
-  __Pyx_RefNannySetupContext("lambda2 (wrapper)", 0);
-  __pyx_r = __pyx_lambda_funcdef_3crf_7Trainer_lambda2(__pyx_self, ((PyObject *)__pyx_v_value));
-
-  /* function exit code */
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-static PyObject *__pyx_lambda_funcdef_3crf_7Trainer_lambda2(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_value) {
-  PyObject *__pyx_r = NULL;
-  __Pyx_RefNannyDeclarations
-  PyObject *__pyx_t_1 = NULL;
-  int __pyx_t_2;
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("lambda2", 0);
-  __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = __Pyx_PyNumber_Int(__pyx_v_value); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 75, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 75, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_t_1 = __Pyx_PyBool_FromLong((!(!__pyx_t_2))); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 75, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __pyx_r = __pyx_t_1;
-  __pyx_t_1 = 0;
-  goto __pyx_L0;
-
-  /* function exit code */
-  __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_1);
-  __Pyx_AddTraceback("crf.Trainer.lambda2", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __pyx_r = NULL;
-  __pyx_L0:;
-  __Pyx_XGIVEREF(__pyx_r);
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-/* "crf.pyx":76
- *             "c": float,
- *             "error_sensitive": lambda value: bool(int(value)),
- *             "averaging": lambda value: bool(int(value)),             # <<<<<<<<<<<<<<
- *             "variance": float,
- *             "gamma": float,
- */
-
-/* Python wrapper */
-static PyObject *__pyx_pw_3crf_7Trainer_25lambda3(PyObject *__pyx_self, PyObject *__pyx_v_value); /*proto*/
-static PyMethodDef __pyx_mdef_3crf_7Trainer_25lambda3 = {"lambda3", (PyCFunction)__pyx_pw_3crf_7Trainer_25lambda3, METH_O, 0};
-static PyObject *__pyx_pw_3crf_7Trainer_25lambda3(PyObject *__pyx_self, PyObject *__pyx_v_value) {
-  PyObject *__pyx_r = 0;
-  __Pyx_RefNannyDeclarations
-  __Pyx_RefNannySetupContext("lambda3 (wrapper)", 0);
-  __pyx_r = __pyx_lambda_funcdef_3crf_7Trainer_lambda3(__pyx_self, ((PyObject *)__pyx_v_value));
-
-  /* function exit code */
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-static PyObject *__pyx_lambda_funcdef_3crf_7Trainer_lambda3(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_value) {
-  PyObject *__pyx_r = NULL;
-  __Pyx_RefNannyDeclarations
-  PyObject *__pyx_t_1 = NULL;
-  int __pyx_t_2;
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("lambda3", 0);
-  __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = __Pyx_PyNumber_Int(__pyx_v_value); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 76, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 76, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_t_1 = __Pyx_PyBool_FromLong((!(!__pyx_t_2))); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 76, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __pyx_r = __pyx_t_1;
-  __pyx_t_1 = 0;
-  goto __pyx_L0;
-
-  /* function exit code */
-  __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_1);
-  __Pyx_AddTraceback("crf.Trainer.lambda3", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __pyx_r = NULL;
-  __pyx_L0:;
-  __Pyx_XGIVEREF(__pyx_r);
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-/* "crf.pyx":81
- *         }
- * 
- *     def __init__(self, algorithm: str, **kwargs):             # <<<<<<<<<<<<<<
- *         self.select_algorithm(algorithm)
- *         self.set_params(self.translate_params(kwargs))
- */
-
-/* Python wrapper */
-static int __pyx_pw_3crf_7Trainer_1__init__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
-static int __pyx_pw_3crf_7Trainer_1__init__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
-  PyObject *__pyx_v_algorithm = 0;
-  PyObject *__pyx_v_kwargs = 0;
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-  int __pyx_r;
-  __Pyx_RefNannyDeclarations
-  __Pyx_RefNannySetupContext("__init__ (wrapper)", 0);
-  __pyx_v_kwargs = PyDict_New(); if (unlikely(!__pyx_v_kwargs)) return -1;
-  __Pyx_GOTREF(__pyx_v_kwargs);
-  {
-    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_algorithm,0};
-    PyObject* values[1] = {0};
-    if (unlikely(__pyx_kwds)) {
-      Py_ssize_t kw_args;
-      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
-      switch (pos_args) {
-        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
-        CYTHON_FALLTHROUGH;
-        case  0: break;
-        default: goto __pyx_L5_argtuple_error;
-      }
-      kw_args = PyDict_Size(__pyx_kwds);
-      switch (pos_args) {
-        case  0:
-        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_algorithm)) != 0)) kw_args--;
-        else goto __pyx_L5_argtuple_error;
-      }
-      if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, __pyx_v_kwargs, values, pos_args, "__init__") < 0)) __PYX_ERR(0, 81, __pyx_L3_error)
-      }
-    } else if (PyTuple_GET_SIZE(__pyx_args) != 1) {
-      goto __pyx_L5_argtuple_error;
-    } else {
-      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
-    }
-    __pyx_v_algorithm = ((PyObject*)values[0]);
-  }
-  goto __pyx_L4_argument_unpacking_done;
-  __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("__init__", 1, 1, 1, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 81, __pyx_L3_error)
-  __pyx_L3_error:;
-  __Pyx_DECREF(__pyx_v_kwargs); __pyx_v_kwargs = 0;
-  __Pyx_AddTraceback("crf.Trainer.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __Pyx_RefNannyFinishContext();
-  return -1;
-  __pyx_L4_argument_unpacking_done:;
-  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_algorithm), (&PyString_Type), 1, "algorithm", 1))) __PYX_ERR(0, 81, __pyx_L1_error)
-  __pyx_r = __pyx_pf_3crf_7Trainer___init__(((struct __pyx_obj_3crf_Trainer *)__pyx_v_self), __pyx_v_algorithm, __pyx_v_kwargs);
-
-  /* function exit code */
-  goto __pyx_L0;
-  __pyx_L1_error:;
-  __pyx_r = -1;
-  __pyx_L0:;
-  __Pyx_XDECREF(__pyx_v_kwargs);
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-static int __pyx_pf_3crf_7Trainer___init__(struct __pyx_obj_3crf_Trainer *__pyx_v_self, PyObject *__pyx_v_algorithm, PyObject *__pyx_v_kwargs) {
-  int __pyx_r;
-  __Pyx_RefNannyDeclarations
-  PyObject *__pyx_t_1 = NULL;
-  PyObject *__pyx_t_2 = NULL;
-  PyObject *__pyx_t_3 = NULL;
-  PyObject *__pyx_t_4 = NULL;
-  PyObject *__pyx_t_5 = NULL;
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("__init__", 0);
-
-  /* "crf.pyx":82
- * 
- *     def __init__(self, algorithm: str, **kwargs):
- *         self.select_algorithm(algorithm)             # <<<<<<<<<<<<<<
- *         self.set_params(self.translate_params(kwargs))
- * 
- */
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_select_algorithm); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 82, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_3 = NULL;
-  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
-    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
-    if (likely(__pyx_t_3)) {
-      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
-      __Pyx_INCREF(__pyx_t_3);
-      __Pyx_INCREF(function);
-      __Pyx_DECREF_SET(__pyx_t_2, function);
-    }
-  }
-  __pyx_t_1 = (__pyx_t_3) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_3, __pyx_v_algorithm) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_v_algorithm);
-  __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
-  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 82, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-
-  /* "crf.pyx":83
- *     def __init__(self, algorithm: str, **kwargs):
- *         self.select_algorithm(algorithm)
- *         self.set_params(self.translate_params(kwargs))             # <<<<<<<<<<<<<<
- * 
- *     def __cinit__(self):
- */
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_set_params); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 83, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_translate_params); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 83, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_4);
-  __pyx_t_5 = NULL;
-  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_4))) {
-    __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_4);
-    if (likely(__pyx_t_5)) {
-      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
-      __Pyx_INCREF(__pyx_t_5);
-      __Pyx_INCREF(function);
-      __Pyx_DECREF_SET(__pyx_t_4, function);
-    }
-  }
-  __pyx_t_3 = (__pyx_t_5) ? __Pyx_PyObject_Call2Args(__pyx_t_4, __pyx_t_5, __pyx_v_kwargs) : __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_v_kwargs);
-  __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
-  if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 83, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-  __pyx_t_4 = NULL;
-  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
-    __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_2);
-    if (likely(__pyx_t_4)) {
-      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
-      __Pyx_INCREF(__pyx_t_4);
-      __Pyx_INCREF(function);
-      __Pyx_DECREF_SET(__pyx_t_2, function);
-    }
-  }
-  __pyx_t_1 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_4, __pyx_t_3) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_3);
-  __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 83, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-
-  /* "crf.pyx":81
- *         }
- * 
- *     def __init__(self, algorithm: str, **kwargs):             # <<<<<<<<<<<<<<
- *         self.select_algorithm(algorithm)
- *         self.set_params(self.translate_params(kwargs))
- */
-
-  /* function exit code */
-  __pyx_r = 0;
-  goto __pyx_L0;
-  __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_1);
-  __Pyx_XDECREF(__pyx_t_2);
-  __Pyx_XDECREF(__pyx_t_3);
-  __Pyx_XDECREF(__pyx_t_4);
-  __Pyx_XDECREF(__pyx_t_5);
-  __Pyx_AddTraceback("crf.Trainer.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __pyx_r = -1;
-  __pyx_L0:;
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-/* "crf.pyx":85
- *         self.set_params(self.translate_params(kwargs))
- * 
- *     def __cinit__(self):             # <<<<<<<<<<<<<<
- *         self._trainer.set_handler(self, <crfsuite_api.messagefunc>self._on_message)
- *         self._trainer.select("l2sgd", "crf1d")
- */
-
-/* Python wrapper */
-static int __pyx_pw_3crf_7Trainer_3__cinit__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
-static int __pyx_pw_3crf_7Trainer_3__cinit__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
-  int __pyx_r;
-  __Pyx_RefNannyDeclarations
-  __Pyx_RefNannySetupContext("__cinit__ (wrapper)", 0);
-  if (unlikely(PyTuple_GET_SIZE(__pyx_args) > 0)) {
-    __Pyx_RaiseArgtupleInvalid("__cinit__", 1, 0, 0, PyTuple_GET_SIZE(__pyx_args)); return -1;}
-  if (unlikely(__pyx_kwds) && unlikely(PyDict_Size(__pyx_kwds) > 0) && unlikely(!__Pyx_CheckKeywordStrings(__pyx_kwds, "__cinit__", 0))) return -1;
-  __pyx_r = __pyx_pf_3crf_7Trainer_2__cinit__(((struct __pyx_obj_3crf_Trainer *)__pyx_v_self));
-
-  /* function exit code */
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-static int __pyx_pf_3crf_7Trainer_2__cinit__(struct __pyx_obj_3crf_Trainer *__pyx_v_self) {
-  int __pyx_r;
-  __Pyx_RefNannyDeclarations
-  std::string __pyx_t_1;
-  std::string __pyx_t_2;
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("__cinit__", 0);
-
-  /* "crf.pyx":86
- * 
- *     def __cinit__(self):
- *         self._trainer.set_handler(self, <crfsuite_api.messagefunc>self._on_message)             # <<<<<<<<<<<<<<
- *         self._trainer.select("l2sgd", "crf1d")
- *         self._trainer._init_trainer()
- */
-  try {
-    __pyx_v_self->_trainer.set_handler(((PyObject *)__pyx_v_self), ((CRFSuiteWrapper::messagefunc)((struct __pyx_vtabstruct_3crf_Trainer *)__pyx_v_self->__pyx_vtab)->_on_message));
-  } catch(...) {
-    __Pyx_CppExn2PyErr();
-    __PYX_ERR(0, 86, __pyx_L1_error)
-  }
-
-  /* "crf.pyx":87
- *     def __cinit__(self):
- *         self._trainer.set_handler(self, <crfsuite_api.messagefunc>self._on_message)
- *         self._trainer.select("l2sgd", "crf1d")             # <<<<<<<<<<<<<<
- *         self._trainer._init_trainer()
- * 
- */
-  __pyx_t_1 = __pyx_convert_string_from_py_std__in_string(__pyx_n_b_l2sgd); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 87, __pyx_L1_error)
-  __pyx_t_2 = __pyx_convert_string_from_py_std__in_string(__pyx_n_b_crf1d); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 87, __pyx_L1_error)
-  try {
-    __pyx_v_self->_trainer.select(__pyx_t_1, __pyx_t_2);
-  } catch(...) {
-    __Pyx_CppExn2PyErr();
-    __PYX_ERR(0, 87, __pyx_L1_error)
-  }
-
-  /* "crf.pyx":88
- *         self._trainer.set_handler(self, <crfsuite_api.messagefunc>self._on_message)
- *         self._trainer.select("l2sgd", "crf1d")
- *         self._trainer._init_trainer()             # <<<<<<<<<<<<<<
- * 
- *     @property
- */
-  try {
-    __pyx_v_self->_trainer._init_trainer();
-  } catch(...) {
-    __Pyx_CppExn2PyErr();
-    __PYX_ERR(0, 88, __pyx_L1_error)
-  }
-
-  /* "crf.pyx":85
- *         self.set_params(self.translate_params(kwargs))
- * 
- *     def __cinit__(self):             # <<<<<<<<<<<<<<
- *         self._trainer.set_handler(self, <crfsuite_api.messagefunc>self._on_message)
- *         self._trainer.select("l2sgd", "crf1d")
- */
-
-  /* function exit code */
-  __pyx_r = 0;
-  goto __pyx_L0;
-  __pyx_L1_error:;
-  __Pyx_AddTraceback("crf.Trainer.__cinit__", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __pyx_r = -1;
-  __pyx_L0:;
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-/* "crf.pyx":91
- * 
- *     @property
- *     def params(self):             # <<<<<<<<<<<<<<
- *         return self._trainer.params()
- * 
- */
-
-/* Python wrapper */
-static PyObject *__pyx_pw_3crf_7Trainer_6params_1__get__(PyObject *__pyx_v_self); /*proto*/
-static PyObject *__pyx_pw_3crf_7Trainer_6params_1__get__(PyObject *__pyx_v_self) {
-  PyObject *__pyx_r = 0;
-  __Pyx_RefNannyDeclarations
-  __Pyx_RefNannySetupContext("__get__ (wrapper)", 0);
-  __pyx_r = __pyx_pf_3crf_7Trainer_6params___get__(((struct __pyx_obj_3crf_Trainer *)__pyx_v_self));
-
-  /* function exit code */
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-static PyObject *__pyx_pf_3crf_7Trainer_6params___get__(struct __pyx_obj_3crf_Trainer *__pyx_v_self) {
-  PyObject *__pyx_r = NULL;
-  __Pyx_RefNannyDeclarations
-  CRFSuite::StringList __pyx_t_1;
-  PyObject *__pyx_t_2 = NULL;
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("__get__", 0);
-
-  /* "crf.pyx":92
- *     @property
- *     def params(self):
- *         return self._trainer.params()             # <<<<<<<<<<<<<<
- * 
- *     def train(self, model_filepath: Filepath):
- */
-  __Pyx_XDECREF(__pyx_r);
-  try {
-    __pyx_t_1 = __pyx_v_self->_trainer.params();
-  } catch(...) {
-    __Pyx_CppExn2PyErr();
-    __PYX_ERR(0, 92, __pyx_L1_error)
-  }
-  __pyx_t_2 = __pyx_convert_vector_to_py_std_3a__3a_string(__pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 92, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  __pyx_r = __pyx_t_2;
-  __pyx_t_2 = 0;
-  goto __pyx_L0;
-
-  /* "crf.pyx":91
- * 
- *     @property
- *     def params(self):             # <<<<<<<<<<<<<<
- *         return self._trainer.params()
- * 
- */
-
-  /* function exit code */
-  __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_2);
-  __Pyx_AddTraceback("crf.Trainer.params.__get__", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __pyx_r = NULL;
-  __pyx_L0:;
-  __Pyx_XGIVEREF(__pyx_r);
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-/* "crf.pyx":94
- *         return self._trainer.params()
- * 
- *     def train(self, model_filepath: Filepath):             # <<<<<<<<<<<<<<
- *         self._trainer.train(str(model_filepath), -1)
- * 
- */
-
-/* Python wrapper */
-static PyObject *__pyx_pw_3crf_7Trainer_5train(PyObject *__pyx_v_self, PyObject *__pyx_v_model_filepath); /*proto*/
-static char __pyx_doc_3crf_7Trainer_4train[] = "Trainer.train(self, model_filepath: Filepath)";
-static PyObject *__pyx_pw_3crf_7Trainer_5train(PyObject *__pyx_v_self, PyObject *__pyx_v_model_filepath) {
-  PyObject *__pyx_r = 0;
-  __Pyx_RefNannyDeclarations
-  __Pyx_RefNannySetupContext("train (wrapper)", 0);
-  __pyx_r = __pyx_pf_3crf_7Trainer_4train(((struct __pyx_obj_3crf_Trainer *)__pyx_v_self), ((PyObject *)__pyx_v_model_filepath));
-
-  /* function exit code */
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-static PyObject *__pyx_pf_3crf_7Trainer_4train(struct __pyx_obj_3crf_Trainer *__pyx_v_self, PyObject *__pyx_v_model_filepath) {
-  PyObject *__pyx_r = NULL;
-  __Pyx_RefNannyDeclarations
-  PyObject *__pyx_t_1 = NULL;
-  std::string __pyx_t_2;
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("train", 0);
-
-  /* "crf.pyx":95
- * 
- *     def train(self, model_filepath: Filepath):
- *         self._trainer.train(str(model_filepath), -1)             # <<<<<<<<<<<<<<
- * 
- *     def _log(self, message: str):
- */
-  __pyx_t_1 = __Pyx_PyObject_CallOneArg(((PyObject *)(&PyString_Type)), __pyx_v_model_filepath); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 95, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = __pyx_convert_string_from_py_std__in_string(__pyx_t_1); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 95, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  try {
-    __pyx_v_self->_trainer.train(__pyx_t_2, -1);
-  } catch(...) {
-    __Pyx_CppExn2PyErr();
-    __PYX_ERR(0, 95, __pyx_L1_error)
-  }
-
-  /* "crf.pyx":94
- *         return self._trainer.params()
- * 
- *     def train(self, model_filepath: Filepath):             # <<<<<<<<<<<<<<
- *         self._trainer.train(str(model_filepath), -1)
- * 
- */
-
-  /* function exit code */
-  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
-  goto __pyx_L0;
-  __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_1);
-  __Pyx_AddTraceback("crf.Trainer.train", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __pyx_r = NULL;
-  __pyx_L0:;
-  __Pyx_XGIVEREF(__pyx_r);
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-/* "crf.pyx":97
- *         self._trainer.train(str(model_filepath), -1)
- * 
- *     def _log(self, message: str):             # <<<<<<<<<<<<<<
- *         LOGGER.info(message)
- * 
- */
-
-/* Python wrapper */
-static PyObject *__pyx_pw_3crf_7Trainer_7_log(PyObject *__pyx_v_self, PyObject *__pyx_v_message); /*proto*/
-static char __pyx_doc_3crf_7Trainer_6_log[] = "Trainer._log(self, str message: str)";
-static PyObject *__pyx_pw_3crf_7Trainer_7_log(PyObject *__pyx_v_self, PyObject *__pyx_v_message) {
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-  PyObject *__pyx_r = 0;
-  __Pyx_RefNannyDeclarations
-  __Pyx_RefNannySetupContext("_log (wrapper)", 0);
-  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_message), (&PyString_Type), 1, "message", 1))) __PYX_ERR(0, 97, __pyx_L1_error)
-  __pyx_r = __pyx_pf_3crf_7Trainer_6_log(((struct __pyx_obj_3crf_Trainer *)__pyx_v_self), ((PyObject*)__pyx_v_message));
-
-  /* function exit code */
-  goto __pyx_L0;
-  __pyx_L1_error:;
-  __pyx_r = NULL;
-  __pyx_L0:;
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-static PyObject *__pyx_pf_3crf_7Trainer_6_log(CYTHON_UNUSED struct __pyx_obj_3crf_Trainer *__pyx_v_self, PyObject *__pyx_v_message) {
-  PyObject *__pyx_r = NULL;
-  __Pyx_RefNannyDeclarations
-  PyObject *__pyx_t_1 = NULL;
-  PyObject *__pyx_t_2 = NULL;
-  PyObject *__pyx_t_3 = NULL;
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("_log", 0);
-
-  /* "crf.pyx":98
- * 
- *     def _log(self, message: str):
- *         LOGGER.info(message)             # <<<<<<<<<<<<<<
- * 
- *     cdef _on_message(self, string message):
- */
-  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_LOGGER); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 98, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_info); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 98, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_t_2 = NULL;
-  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
-    __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_3);
-    if (likely(__pyx_t_2)) {
-      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
-      __Pyx_INCREF(__pyx_t_2);
-      __Pyx_INCREF(function);
-      __Pyx_DECREF_SET(__pyx_t_3, function);
-    }
-  }
-  __pyx_t_1 = (__pyx_t_2) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_2, __pyx_v_message) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_v_message);
-  __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
-  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 98, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-
-  /* "crf.pyx":97
- *         self._trainer.train(str(model_filepath), -1)
- * 
- *     def _log(self, message: str):             # <<<<<<<<<<<<<<
- *         LOGGER.info(message)
- * 
- */
-
-  /* function exit code */
-  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
-  goto __pyx_L0;
-  __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_1);
-  __Pyx_XDECREF(__pyx_t_2);
-  __Pyx_XDECREF(__pyx_t_3);
-  __Pyx_AddTraceback("crf.Trainer._log", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __pyx_r = NULL;
-  __pyx_L0:;
-  __Pyx_XGIVEREF(__pyx_r);
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-/* "crf.pyx":100
- *         LOGGER.info(message)
- * 
- *     cdef _on_message(self, string message):             # <<<<<<<<<<<<<<
- *         self._log(message)
- * 
- */
-
-static PyObject *__pyx_f_3crf_7Trainer__on_message(struct __pyx_obj_3crf_Trainer *__pyx_v_self, std::string __pyx_v_message) {
-  PyObject *__pyx_r = NULL;
-  __Pyx_RefNannyDeclarations
-  PyObject *__pyx_t_1 = NULL;
-  PyObject *__pyx_t_2 = NULL;
-  PyObject *__pyx_t_3 = NULL;
-  PyObject *__pyx_t_4 = NULL;
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("_on_message", 0);
-
-  /* "crf.pyx":101
- * 
- *     cdef _on_message(self, string message):
- *         self._log(message)             # <<<<<<<<<<<<<<
- * 
- *     def append(self, sequence: Sequence, labels: Labels, int group=0):
- */
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_log); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 101, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_3 = __pyx_convert_PyStr_string_to_py_std__in_string(__pyx_v_message); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 101, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  __pyx_t_4 = NULL;
-  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
-    __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_2);
-    if (likely(__pyx_t_4)) {
-      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
-      __Pyx_INCREF(__pyx_t_4);
-      __Pyx_INCREF(function);
-      __Pyx_DECREF_SET(__pyx_t_2, function);
-    }
-  }
-  __pyx_t_1 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_4, __pyx_t_3) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_3);
-  __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 101, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-
-  /* "crf.pyx":100
- *         LOGGER.info(message)
- * 
- *     cdef _on_message(self, string message):             # <<<<<<<<<<<<<<
- *         self._log(message)
- * 
- */
-
-  /* function exit code */
-  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
-  goto __pyx_L0;
-  __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_1);
-  __Pyx_XDECREF(__pyx_t_2);
-  __Pyx_XDECREF(__pyx_t_3);
-  __Pyx_XDECREF(__pyx_t_4);
-  __Pyx_AddTraceback("crf.Trainer._on_message", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __pyx_r = 0;
-  __pyx_L0:;
-  __Pyx_XGIVEREF(__pyx_r);
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-/* "crf.pyx":103
- *         self._log(message)
- * 
- *     def append(self, sequence: Sequence, labels: Labels, int group=0):             # <<<<<<<<<<<<<<
- *         # no generators allowed
- *         if not isinstance(sequence, list):
- */
-
-/* Python wrapper */
-static PyObject *__pyx_pw_3crf_7Trainer_9append(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
-static char __pyx_doc_3crf_7Trainer_8append[] = "Trainer.append(self, sequence: Sequence, labels: Labels, int group=0)";
-static PyObject *__pyx_pw_3crf_7Trainer_9append(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
-  PyObject *__pyx_v_sequence = 0;
-  PyObject *__pyx_v_labels = 0;
-  int __pyx_v_group;
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-  PyObject *__pyx_r = 0;
-  __Pyx_RefNannyDeclarations
-  __Pyx_RefNannySetupContext("append (wrapper)", 0);
-  {
-    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_sequence,&__pyx_n_s_labels,&__pyx_n_s_group,0};
-    PyObject* values[3] = {0,0,0};
-    if (unlikely(__pyx_kwds)) {
-      Py_ssize_t kw_args;
-      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
-      switch (pos_args) {
-        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
-        CYTHON_FALLTHROUGH;
-        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
-        CYTHON_FALLTHROUGH;
-        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
-        CYTHON_FALLTHROUGH;
-        case  0: break;
-        default: goto __pyx_L5_argtuple_error;
-      }
-      kw_args = PyDict_Size(__pyx_kwds);
-      switch (pos_args) {
-        case  0:
-        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_sequence)) != 0)) kw_args--;
-        else goto __pyx_L5_argtuple_error;
-        CYTHON_FALLTHROUGH;
-        case  1:
-        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_labels)) != 0)) kw_args--;
-        else {
-          __Pyx_RaiseArgtupleInvalid("append", 0, 2, 3, 1); __PYX_ERR(0, 103, __pyx_L3_error)
-        }
-        CYTHON_FALLTHROUGH;
-        case  2:
-        if (kw_args > 0) {
-          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_group);
-          if (value) { values[2] = value; kw_args--; }
-        }
-      }
-      if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "append") < 0)) __PYX_ERR(0, 103, __pyx_L3_error)
-      }
-    } else {
-      switch (PyTuple_GET_SIZE(__pyx_args)) {
-        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
-        CYTHON_FALLTHROUGH;
-        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
-        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
-        break;
-        default: goto __pyx_L5_argtuple_error;
-      }
-    }
-    __pyx_v_sequence = values[0];
-    __pyx_v_labels = values[1];
-    if (values[2]) {
-      __pyx_v_group = __Pyx_PyInt_As_int(values[2]); if (unlikely((__pyx_v_group == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 103, __pyx_L3_error)
-    } else {
-      __pyx_v_group = ((int)0);
-    }
-  }
-  goto __pyx_L4_argument_unpacking_done;
-  __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("append", 0, 2, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 103, __pyx_L3_error)
-  __pyx_L3_error:;
-  __Pyx_AddTraceback("crf.Trainer.append", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __Pyx_RefNannyFinishContext();
-  return NULL;
-  __pyx_L4_argument_unpacking_done:;
-  __pyx_r = __pyx_pf_3crf_7Trainer_8append(((struct __pyx_obj_3crf_Trainer *)__pyx_v_self), __pyx_v_sequence, __pyx_v_labels, __pyx_v_group);
-
-  /* function exit code */
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-static PyObject *__pyx_pf_3crf_7Trainer_8append(struct __pyx_obj_3crf_Trainer *__pyx_v_self, PyObject *__pyx_v_sequence, PyObject *__pyx_v_labels, int __pyx_v_group) {
-  PyObject *__pyx_v_item = NULL;
-  PyObject *__pyx_v_label = NULL;
-  PyObject *__pyx_r = NULL;
-  __Pyx_RefNannyDeclarations
-  int __pyx_t_1;
-  int __pyx_t_2;
-  PyObject *__pyx_t_3 = NULL;
-  PyObject *__pyx_t_4 = NULL;
-  Py_ssize_t __pyx_t_5;
-  PyObject *(*__pyx_t_6)(PyObject *);
-  PyObject *__pyx_t_7 = NULL;
-  CRFSuite::ItemSequence __pyx_t_8;
-  CRFSuite::StringList __pyx_t_9;
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("append", 0);
-  __Pyx_INCREF(__pyx_v_sequence);
-  __Pyx_INCREF(__pyx_v_labels);
-
-  /* "crf.pyx":105
- *     def append(self, sequence: Sequence, labels: Labels, int group=0):
- *         # no generators allowed
- *         if not isinstance(sequence, list):             # <<<<<<<<<<<<<<
- *             sequence = [item for item in sequence]
- *         if not isinstance(labels, list):
- */
-  __pyx_t_1 = PyList_Check(__pyx_v_sequence); 
-  __pyx_t_2 = ((!(__pyx_t_1 != 0)) != 0);
-  if (__pyx_t_2) {
-
-    /* "crf.pyx":106
- *         # no generators allowed
- *         if not isinstance(sequence, list):
- *             sequence = [item for item in sequence]             # <<<<<<<<<<<<<<
- *         if not isinstance(labels, list):
- *             # labels must be strings
- */
-    __pyx_t_3 = PyList_New(0); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 106, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_3);
-    if (likely(PyList_CheckExact(__pyx_v_sequence)) || PyTuple_CheckExact(__pyx_v_sequence)) {
-      __pyx_t_4 = __pyx_v_sequence; __Pyx_INCREF(__pyx_t_4); __pyx_t_5 = 0;
-      __pyx_t_6 = NULL;
-    } else {
-      __pyx_t_5 = -1; __pyx_t_4 = PyObject_GetIter(__pyx_v_sequence); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 106, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_4);
-      __pyx_t_6 = Py_TYPE(__pyx_t_4)->tp_iternext; if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 106, __pyx_L1_error)
-    }
-    for (;;) {
-      if (likely(!__pyx_t_6)) {
-        if (likely(PyList_CheckExact(__pyx_t_4))) {
-          if (__pyx_t_5 >= PyList_GET_SIZE(__pyx_t_4)) break;
-          #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-          __pyx_t_7 = PyList_GET_ITEM(__pyx_t_4, __pyx_t_5); __Pyx_INCREF(__pyx_t_7); __pyx_t_5++; if (unlikely(0 < 0)) __PYX_ERR(0, 106, __pyx_L1_error)
-          #else
-          __pyx_t_7 = PySequence_ITEM(__pyx_t_4, __pyx_t_5); __pyx_t_5++; if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 106, __pyx_L1_error)
-          __Pyx_GOTREF(__pyx_t_7);
-          #endif
-        } else {
-          if (__pyx_t_5 >= PyTuple_GET_SIZE(__pyx_t_4)) break;
-          #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-          __pyx_t_7 = PyTuple_GET_ITEM(__pyx_t_4, __pyx_t_5); __Pyx_INCREF(__pyx_t_7); __pyx_t_5++; if (unlikely(0 < 0)) __PYX_ERR(0, 106, __pyx_L1_error)
-          #else
-          __pyx_t_7 = PySequence_ITEM(__pyx_t_4, __pyx_t_5); __pyx_t_5++; if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 106, __pyx_L1_error)
-          __Pyx_GOTREF(__pyx_t_7);
-          #endif
-        }
-      } else {
-        __pyx_t_7 = __pyx_t_6(__pyx_t_4);
-        if (unlikely(!__pyx_t_7)) {
-          PyObject* exc_type = PyErr_Occurred();
-          if (exc_type) {
-            if (likely(__Pyx_PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
-            else __PYX_ERR(0, 106, __pyx_L1_error)
-          }
-          break;
-        }
-        __Pyx_GOTREF(__pyx_t_7);
-      }
-      __Pyx_XDECREF_SET(__pyx_v_item, __pyx_t_7);
-      __pyx_t_7 = 0;
-      if (unlikely(__Pyx_ListComp_Append(__pyx_t_3, (PyObject*)__pyx_v_item))) __PYX_ERR(0, 106, __pyx_L1_error)
-    }
-    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-    __Pyx_DECREF_SET(__pyx_v_sequence, __pyx_t_3);
-    __pyx_t_3 = 0;
-
-    /* "crf.pyx":105
- *     def append(self, sequence: Sequence, labels: Labels, int group=0):
- *         # no generators allowed
- *         if not isinstance(sequence, list):             # <<<<<<<<<<<<<<
- *             sequence = [item for item in sequence]
- *         if not isinstance(labels, list):
- */
-  }
-
-  /* "crf.pyx":107
- *         if not isinstance(sequence, list):
- *             sequence = [item for item in sequence]
- *         if not isinstance(labels, list):             # <<<<<<<<<<<<<<
- *             # labels must be strings
- *             labels = [str(label) for label in labels]
- */
-  __pyx_t_2 = PyList_Check(__pyx_v_labels); 
-  __pyx_t_1 = ((!(__pyx_t_2 != 0)) != 0);
-  if (__pyx_t_1) {
-
-    /* "crf.pyx":109
- *         if not isinstance(labels, list):
- *             # labels must be strings
- *             labels = [str(label) for label in labels]             # <<<<<<<<<<<<<<
- * 
- *         self._trainer.append(to_seq(sequence), labels, group)
- */
-    __pyx_t_3 = PyList_New(0); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 109, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_3);
-    if (likely(PyList_CheckExact(__pyx_v_labels)) || PyTuple_CheckExact(__pyx_v_labels)) {
-      __pyx_t_4 = __pyx_v_labels; __Pyx_INCREF(__pyx_t_4); __pyx_t_5 = 0;
-      __pyx_t_6 = NULL;
-    } else {
-      __pyx_t_5 = -1; __pyx_t_4 = PyObject_GetIter(__pyx_v_labels); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 109, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_4);
-      __pyx_t_6 = Py_TYPE(__pyx_t_4)->tp_iternext; if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 109, __pyx_L1_error)
-    }
-    for (;;) {
-      if (likely(!__pyx_t_6)) {
-        if (likely(PyList_CheckExact(__pyx_t_4))) {
-          if (__pyx_t_5 >= PyList_GET_SIZE(__pyx_t_4)) break;
-          #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-          __pyx_t_7 = PyList_GET_ITEM(__pyx_t_4, __pyx_t_5); __Pyx_INCREF(__pyx_t_7); __pyx_t_5++; if (unlikely(0 < 0)) __PYX_ERR(0, 109, __pyx_L1_error)
-          #else
-          __pyx_t_7 = PySequence_ITEM(__pyx_t_4, __pyx_t_5); __pyx_t_5++; if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 109, __pyx_L1_error)
-          __Pyx_GOTREF(__pyx_t_7);
-          #endif
-        } else {
-          if (__pyx_t_5 >= PyTuple_GET_SIZE(__pyx_t_4)) break;
-          #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-          __pyx_t_7 = PyTuple_GET_ITEM(__pyx_t_4, __pyx_t_5); __Pyx_INCREF(__pyx_t_7); __pyx_t_5++; if (unlikely(0 < 0)) __PYX_ERR(0, 109, __pyx_L1_error)
-          #else
-          __pyx_t_7 = PySequence_ITEM(__pyx_t_4, __pyx_t_5); __pyx_t_5++; if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 109, __pyx_L1_error)
-          __Pyx_GOTREF(__pyx_t_7);
-          #endif
-        }
-      } else {
-        __pyx_t_7 = __pyx_t_6(__pyx_t_4);
-        if (unlikely(!__pyx_t_7)) {
-          PyObject* exc_type = PyErr_Occurred();
-          if (exc_type) {
-            if (likely(__Pyx_PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
-            else __PYX_ERR(0, 109, __pyx_L1_error)
-          }
-          break;
-        }
-        __Pyx_GOTREF(__pyx_t_7);
-      }
-      __Pyx_XDECREF_SET(__pyx_v_label, __pyx_t_7);
-      __pyx_t_7 = 0;
-      __pyx_t_7 = __Pyx_PyObject_CallOneArg(((PyObject *)(&PyString_Type)), __pyx_v_label); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 109, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_7);
-      if (unlikely(__Pyx_ListComp_Append(__pyx_t_3, (PyObject*)__pyx_t_7))) __PYX_ERR(0, 109, __pyx_L1_error)
-      __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
-    }
-    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-    __Pyx_DECREF_SET(__pyx_v_labels, __pyx_t_3);
-    __pyx_t_3 = 0;
-
-    /* "crf.pyx":107
- *         if not isinstance(sequence, list):
- *             sequence = [item for item in sequence]
- *         if not isinstance(labels, list):             # <<<<<<<<<<<<<<
- *             # labels must be strings
- *             labels = [str(label) for label in labels]
- */
-  }
-
-  /* "crf.pyx":111
- *             labels = [str(label) for label in labels]
- * 
- *         self._trainer.append(to_seq(sequence), labels, group)             # <<<<<<<<<<<<<<
- * 
- *     def translate_params(self, kwargs: dict[str, str | int | float | bool]):
- */
-  try {
-    __pyx_t_8 = __pyx_f_3crf_to_seq(__pyx_v_sequence);
-  } catch(...) {
-    __Pyx_CppExn2PyErr();
-    __PYX_ERR(0, 111, __pyx_L1_error)
-  }
-  __pyx_t_9 = __pyx_convert_vector_from_py_std_3a__3a_string(__pyx_v_labels); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 111, __pyx_L1_error)
-  try {
-    __pyx_v_self->_trainer.append(__pyx_t_8, __pyx_t_9, __pyx_v_group);
-  } catch(...) {
-    __Pyx_CppExn2PyErr();
-    __PYX_ERR(0, 111, __pyx_L1_error)
-  }
-
-  /* "crf.pyx":103
- *         self._log(message)
- * 
- *     def append(self, sequence: Sequence, labels: Labels, int group=0):             # <<<<<<<<<<<<<<
- *         # no generators allowed
- *         if not isinstance(sequence, list):
- */
-
-  /* function exit code */
-  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
-  goto __pyx_L0;
-  __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_3);
-  __Pyx_XDECREF(__pyx_t_4);
-  __Pyx_XDECREF(__pyx_t_7);
-  __Pyx_AddTraceback("crf.Trainer.append", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __pyx_r = NULL;
-  __pyx_L0:;
-  __Pyx_XDECREF(__pyx_v_item);
-  __Pyx_XDECREF(__pyx_v_label);
-  __Pyx_XDECREF(__pyx_v_sequence);
-  __Pyx_XDECREF(__pyx_v_labels);
-  __Pyx_XGIVEREF(__pyx_r);
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-/* "crf.pyx":113
- *         self._trainer.append(to_seq(sequence), labels, group)
- * 
- *     def translate_params(self, kwargs: dict[str, str | int | float | bool]):             # <<<<<<<<<<<<<<
- *         return {
- *             self.kwarg2param.get(kwarg, kwarg): value
- */
-
-/* Python wrapper */
-static PyObject *__pyx_pw_3crf_7Trainer_11translate_params(PyObject *__pyx_v_self, PyObject *__pyx_v_kwargs); /*proto*/
-static char __pyx_doc_3crf_7Trainer_10translate_params[] = "Trainer.translate_params(self, kwargs: dict[str, str | int | float | bool])";
-static PyObject *__pyx_pw_3crf_7Trainer_11translate_params(PyObject *__pyx_v_self, PyObject *__pyx_v_kwargs) {
-  PyObject *__pyx_r = 0;
-  __Pyx_RefNannyDeclarations
-  __Pyx_RefNannySetupContext("translate_params (wrapper)", 0);
-  __pyx_r = __pyx_pf_3crf_7Trainer_10translate_params(((struct __pyx_obj_3crf_Trainer *)__pyx_v_self), ((PyObject *)__pyx_v_kwargs));
-
-  /* function exit code */
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-static PyObject *__pyx_pf_3crf_7Trainer_10translate_params(struct __pyx_obj_3crf_Trainer *__pyx_v_self, PyObject *__pyx_v_kwargs) {
-  PyObject *__pyx_7genexpr__pyx_v_kwarg = NULL;
-  PyObject *__pyx_7genexpr__pyx_v_value = NULL;
-  PyObject *__pyx_r = NULL;
-  __Pyx_RefNannyDeclarations
-  PyObject *__pyx_t_1 = NULL;
-  PyObject *__pyx_t_2 = NULL;
-  PyObject *__pyx_t_3 = NULL;
-  PyObject *__pyx_t_4 = NULL;
-  Py_ssize_t __pyx_t_5;
-  PyObject *(*__pyx_t_6)(PyObject *);
-  PyObject *__pyx_t_7 = NULL;
-  PyObject *__pyx_t_8 = NULL;
-  PyObject *(*__pyx_t_9)(PyObject *);
-  int __pyx_t_10;
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("translate_params", 0);
-
-  /* "crf.pyx":114
- * 
- *     def translate_params(self, kwargs: dict[str, str | int | float | bool]):
- *         return {             # <<<<<<<<<<<<<<
- *             self.kwarg2param.get(kwarg, kwarg): value
- *             for kwarg, value in kwargs.items()
- */
-  __Pyx_XDECREF(__pyx_r);
-  { /* enter inner scope */
-    __pyx_t_1 = PyDict_New(); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 114, __pyx_L5_error)
-    __Pyx_GOTREF(__pyx_t_1);
-
-    /* "crf.pyx":116
- *         return {
- *             self.kwarg2param.get(kwarg, kwarg): value
- *             for kwarg, value in kwargs.items()             # <<<<<<<<<<<<<<
- *         }
- * 
- */
-    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_kwargs, __pyx_n_s_items); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 116, __pyx_L5_error)
-    __Pyx_GOTREF(__pyx_t_3);
-    __pyx_t_4 = NULL;
-    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
-      __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
-      if (likely(__pyx_t_4)) {
-        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
-        __Pyx_INCREF(__pyx_t_4);
-        __Pyx_INCREF(function);
-        __Pyx_DECREF_SET(__pyx_t_3, function);
-      }
-    }
-    __pyx_t_2 = (__pyx_t_4) ? __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_4) : __Pyx_PyObject_CallNoArg(__pyx_t_3);
-    __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
-    if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 116, __pyx_L5_error)
-    __Pyx_GOTREF(__pyx_t_2);
-    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-    if (likely(PyList_CheckExact(__pyx_t_2)) || PyTuple_CheckExact(__pyx_t_2)) {
-      __pyx_t_3 = __pyx_t_2; __Pyx_INCREF(__pyx_t_3); __pyx_t_5 = 0;
-      __pyx_t_6 = NULL;
-    } else {
-      __pyx_t_5 = -1; __pyx_t_3 = PyObject_GetIter(__pyx_t_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 116, __pyx_L5_error)
-      __Pyx_GOTREF(__pyx_t_3);
-      __pyx_t_6 = Py_TYPE(__pyx_t_3)->tp_iternext; if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 116, __pyx_L5_error)
-    }
-    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-    for (;;) {
-      if (likely(!__pyx_t_6)) {
-        if (likely(PyList_CheckExact(__pyx_t_3))) {
-          if (__pyx_t_5 >= PyList_GET_SIZE(__pyx_t_3)) break;
-          #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-          __pyx_t_2 = PyList_GET_ITEM(__pyx_t_3, __pyx_t_5); __Pyx_INCREF(__pyx_t_2); __pyx_t_5++; if (unlikely(0 < 0)) __PYX_ERR(0, 116, __pyx_L5_error)
-          #else
-          __pyx_t_2 = PySequence_ITEM(__pyx_t_3, __pyx_t_5); __pyx_t_5++; if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 116, __pyx_L5_error)
-          __Pyx_GOTREF(__pyx_t_2);
-          #endif
-        } else {
-          if (__pyx_t_5 >= PyTuple_GET_SIZE(__pyx_t_3)) break;
-          #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-          __pyx_t_2 = PyTuple_GET_ITEM(__pyx_t_3, __pyx_t_5); __Pyx_INCREF(__pyx_t_2); __pyx_t_5++; if (unlikely(0 < 0)) __PYX_ERR(0, 116, __pyx_L5_error)
-          #else
-          __pyx_t_2 = PySequence_ITEM(__pyx_t_3, __pyx_t_5); __pyx_t_5++; if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 116, __pyx_L5_error)
-          __Pyx_GOTREF(__pyx_t_2);
-          #endif
-        }
-      } else {
-        __pyx_t_2 = __pyx_t_6(__pyx_t_3);
-        if (unlikely(!__pyx_t_2)) {
-          PyObject* exc_type = PyErr_Occurred();
-          if (exc_type) {
-            if (likely(__Pyx_PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
-            else __PYX_ERR(0, 116, __pyx_L5_error)
-          }
-          break;
-        }
-        __Pyx_GOTREF(__pyx_t_2);
-      }
-      if ((likely(PyTuple_CheckExact(__pyx_t_2))) || (PyList_CheckExact(__pyx_t_2))) {
-        PyObject* sequence = __pyx_t_2;
-        Py_ssize_t size = __Pyx_PySequence_SIZE(sequence);
-        if (unlikely(size != 2)) {
-          if (size > 2) __Pyx_RaiseTooManyValuesError(2);
-          else if (size >= 0) __Pyx_RaiseNeedMoreValuesError(size);
-          __PYX_ERR(0, 116, __pyx_L5_error)
-        }
-        #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-        if (likely(PyTuple_CheckExact(sequence))) {
-          __pyx_t_4 = PyTuple_GET_ITEM(sequence, 0); 
-          __pyx_t_7 = PyTuple_GET_ITEM(sequence, 1); 
-        } else {
-          __pyx_t_4 = PyList_GET_ITEM(sequence, 0); 
-          __pyx_t_7 = PyList_GET_ITEM(sequence, 1); 
-        }
-        __Pyx_INCREF(__pyx_t_4);
-        __Pyx_INCREF(__pyx_t_7);
-        #else
-        __pyx_t_4 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 116, __pyx_L5_error)
-        __Pyx_GOTREF(__pyx_t_4);
-        __pyx_t_7 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 116, __pyx_L5_error)
-        __Pyx_GOTREF(__pyx_t_7);
-        #endif
-        __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-      } else {
-        Py_ssize_t index = -1;
-        __pyx_t_8 = PyObject_GetIter(__pyx_t_2); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 116, __pyx_L5_error)
-        __Pyx_GOTREF(__pyx_t_8);
-        __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-        __pyx_t_9 = Py_TYPE(__pyx_t_8)->tp_iternext;
-        index = 0; __pyx_t_4 = __pyx_t_9(__pyx_t_8); if (unlikely(!__pyx_t_4)) goto __pyx_L8_unpacking_failed;
-        __Pyx_GOTREF(__pyx_t_4);
-        index = 1; __pyx_t_7 = __pyx_t_9(__pyx_t_8); if (unlikely(!__pyx_t_7)) goto __pyx_L8_unpacking_failed;
-        __Pyx_GOTREF(__pyx_t_7);
-        if (__Pyx_IternextUnpackEndCheck(__pyx_t_9(__pyx_t_8), 2) < 0) __PYX_ERR(0, 116, __pyx_L5_error)
-        __pyx_t_9 = NULL;
-        __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
-        goto __pyx_L9_unpacking_done;
-        __pyx_L8_unpacking_failed:;
-        __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
-        __pyx_t_9 = NULL;
-        if (__Pyx_IterFinish() == 0) __Pyx_RaiseNeedMoreValuesError(index);
-        __PYX_ERR(0, 116, __pyx_L5_error)
-        __pyx_L9_unpacking_done:;
-      }
-      __Pyx_XDECREF_SET(__pyx_7genexpr__pyx_v_kwarg, __pyx_t_4);
-      __pyx_t_4 = 0;
-      __Pyx_XDECREF_SET(__pyx_7genexpr__pyx_v_value, __pyx_t_7);
-      __pyx_t_7 = 0;
-
-      /* "crf.pyx":115
- *     def translate_params(self, kwargs: dict[str, str | int | float | bool]):
- *         return {
- *             self.kwarg2param.get(kwarg, kwarg): value             # <<<<<<<<<<<<<<
- *             for kwarg, value in kwargs.items()
- *         }
- */
-      __pyx_t_7 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_kwarg2param); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 115, __pyx_L5_error)
-      __Pyx_GOTREF(__pyx_t_7);
-      __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_get); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 115, __pyx_L5_error)
-      __Pyx_GOTREF(__pyx_t_4);
-      __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
-      __pyx_t_7 = NULL;
-      __pyx_t_10 = 0;
-      if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_4))) {
-        __pyx_t_7 = PyMethod_GET_SELF(__pyx_t_4);
-        if (likely(__pyx_t_7)) {
-          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
-          __Pyx_INCREF(__pyx_t_7);
-          __Pyx_INCREF(function);
-          __Pyx_DECREF_SET(__pyx_t_4, function);
-          __pyx_t_10 = 1;
-        }
-      }
-      #if CYTHON_FAST_PYCALL
-      if (PyFunction_Check(__pyx_t_4)) {
-        PyObject *__pyx_temp[3] = {__pyx_t_7, __pyx_7genexpr__pyx_v_kwarg, __pyx_7genexpr__pyx_v_kwarg};
-        __pyx_t_2 = __Pyx_PyFunction_FastCall(__pyx_t_4, __pyx_temp+1-__pyx_t_10, 2+__pyx_t_10); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 115, __pyx_L5_error)
-        __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
-        __Pyx_GOTREF(__pyx_t_2);
-      } else
-      #endif
-      #if CYTHON_FAST_PYCCALL
-      if (__Pyx_PyFastCFunction_Check(__pyx_t_4)) {
-        PyObject *__pyx_temp[3] = {__pyx_t_7, __pyx_7genexpr__pyx_v_kwarg, __pyx_7genexpr__pyx_v_kwarg};
-        __pyx_t_2 = __Pyx_PyCFunction_FastCall(__pyx_t_4, __pyx_temp+1-__pyx_t_10, 2+__pyx_t_10); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 115, __pyx_L5_error)
-        __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
-        __Pyx_GOTREF(__pyx_t_2);
-      } else
-      #endif
-      {
-        __pyx_t_8 = PyTuple_New(2+__pyx_t_10); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 115, __pyx_L5_error)
-        __Pyx_GOTREF(__pyx_t_8);
-        if (__pyx_t_7) {
-          __Pyx_GIVEREF(__pyx_t_7); PyTuple_SET_ITEM(__pyx_t_8, 0, __pyx_t_7); __pyx_t_7 = NULL;
-        }
-        __Pyx_INCREF(__pyx_7genexpr__pyx_v_kwarg);
-        __Pyx_GIVEREF(__pyx_7genexpr__pyx_v_kwarg);
-        PyTuple_SET_ITEM(__pyx_t_8, 0+__pyx_t_10, __pyx_7genexpr__pyx_v_kwarg);
-        __Pyx_INCREF(__pyx_7genexpr__pyx_v_kwarg);
-        __Pyx_GIVEREF(__pyx_7genexpr__pyx_v_kwarg);
-        PyTuple_SET_ITEM(__pyx_t_8, 1+__pyx_t_10, __pyx_7genexpr__pyx_v_kwarg);
-        __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_t_8, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 115, __pyx_L5_error)
-        __Pyx_GOTREF(__pyx_t_2);
-        __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
-      }
-      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-      if (unlikely(PyDict_SetItem(__pyx_t_1, (PyObject*)__pyx_t_2, (PyObject*)__pyx_7genexpr__pyx_v_value))) __PYX_ERR(0, 115, __pyx_L5_error)
-      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-
-      /* "crf.pyx":116
- *         return {
- *             self.kwarg2param.get(kwarg, kwarg): value
- *             for kwarg, value in kwargs.items()             # <<<<<<<<<<<<<<
- *         }
- * 
- */
-    }
-    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-    __Pyx_XDECREF(__pyx_7genexpr__pyx_v_kwarg); __pyx_7genexpr__pyx_v_kwarg = 0;
-    __Pyx_XDECREF(__pyx_7genexpr__pyx_v_value); __pyx_7genexpr__pyx_v_value = 0;
-    goto __pyx_L10_exit_scope;
-    __pyx_L5_error:;
-    __Pyx_XDECREF(__pyx_7genexpr__pyx_v_kwarg); __pyx_7genexpr__pyx_v_kwarg = 0;
-    __Pyx_XDECREF(__pyx_7genexpr__pyx_v_value); __pyx_7genexpr__pyx_v_value = 0;
-    goto __pyx_L1_error;
-    __pyx_L10_exit_scope:;
-  } /* exit inner scope */
-  __pyx_r = __pyx_t_1;
-  __pyx_t_1 = 0;
-  goto __pyx_L0;
-
-  /* "crf.pyx":113
- *         self._trainer.append(to_seq(sequence), labels, group)
- * 
- *     def translate_params(self, kwargs: dict[str, str | int | float | bool]):             # <<<<<<<<<<<<<<
- *         return {
- *             self.kwarg2param.get(kwarg, kwarg): value
- */
-
-  /* function exit code */
-  __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_1);
-  __Pyx_XDECREF(__pyx_t_2);
-  __Pyx_XDECREF(__pyx_t_3);
-  __Pyx_XDECREF(__pyx_t_4);
-  __Pyx_XDECREF(__pyx_t_7);
-  __Pyx_XDECREF(__pyx_t_8);
-  __Pyx_AddTraceback("crf.Trainer.translate_params", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __pyx_r = NULL;
-  __pyx_L0:;
-  __Pyx_XDECREF(__pyx_7genexpr__pyx_v_kwarg);
-  __Pyx_XDECREF(__pyx_7genexpr__pyx_v_value);
-  __Pyx_XGIVEREF(__pyx_r);
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-/* "crf.pyx":119
- *         }
- * 
- *     def select_algorithm(self, algorithm: str):             # <<<<<<<<<<<<<<
- *         try:
- *             algorithm = self._algorithm_aliases[algorithm.lower()]
- */
-
-/* Python wrapper */
-static PyObject *__pyx_pw_3crf_7Trainer_13select_algorithm(PyObject *__pyx_v_self, PyObject *__pyx_v_algorithm); /*proto*/
-static char __pyx_doc_3crf_7Trainer_12select_algorithm[] = "Trainer.select_algorithm(self, str algorithm: str)";
-static PyObject *__pyx_pw_3crf_7Trainer_13select_algorithm(PyObject *__pyx_v_self, PyObject *__pyx_v_algorithm) {
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-  PyObject *__pyx_r = 0;
-  __Pyx_RefNannyDeclarations
-  __Pyx_RefNannySetupContext("select_algorithm (wrapper)", 0);
-  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_algorithm), (&PyString_Type), 1, "algorithm", 1))) __PYX_ERR(0, 119, __pyx_L1_error)
-  __pyx_r = __pyx_pf_3crf_7Trainer_12select_algorithm(((struct __pyx_obj_3crf_Trainer *)__pyx_v_self), ((PyObject*)__pyx_v_algorithm));
-
-  /* function exit code */
-  goto __pyx_L0;
-  __pyx_L1_error:;
-  __pyx_r = NULL;
-  __pyx_L0:;
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-static PyObject *__pyx_pf_3crf_7Trainer_12select_algorithm(struct __pyx_obj_3crf_Trainer *__pyx_v_self, PyObject *__pyx_v_algorithm) {
-  PyObject *__pyx_r = NULL;
-  __Pyx_RefNannyDeclarations
-  PyObject *__pyx_t_1 = NULL;
-  PyObject *__pyx_t_2 = NULL;
-  PyObject *__pyx_t_3 = NULL;
-  PyObject *__pyx_t_4 = NULL;
-  PyObject *__pyx_t_5 = NULL;
-  PyObject *__pyx_t_6 = NULL;
-  PyObject *__pyx_t_7 = NULL;
-  PyObject *__pyx_t_8 = NULL;
-  std::string __pyx_t_9;
-  std::string __pyx_t_10;
-  int __pyx_t_11;
-  int __pyx_t_12;
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("select_algorithm", 0);
-  __Pyx_INCREF(__pyx_v_algorithm);
-
-  /* "crf.pyx":120
- * 
- *     def select_algorithm(self, algorithm: str):
- *         try:             # <<<<<<<<<<<<<<
- *             algorithm = self._algorithm_aliases[algorithm.lower()]
- *         except:
- */
-  {
-    __Pyx_PyThreadState_declare
-    __Pyx_PyThreadState_assign
-    __Pyx_ExceptionSave(&__pyx_t_1, &__pyx_t_2, &__pyx_t_3);
-    __Pyx_XGOTREF(__pyx_t_1);
-    __Pyx_XGOTREF(__pyx_t_2);
-    __Pyx_XGOTREF(__pyx_t_3);
-    /*try:*/ {
-
-      /* "crf.pyx":121
- *     def select_algorithm(self, algorithm: str):
- *         try:
- *             algorithm = self._algorithm_aliases[algorithm.lower()]             # <<<<<<<<<<<<<<
- *         except:
- *             raise ValueError(f"{algorithm} is no available algorithm")
- */
-      __pyx_t_4 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_algorithm_aliases); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 121, __pyx_L3_error)
-      __Pyx_GOTREF(__pyx_t_4);
-      __pyx_t_5 = __Pyx_CallUnboundCMethod0(&__pyx_umethod_PyString_Type_lower, __pyx_v_algorithm); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 121, __pyx_L3_error)
-      __Pyx_GOTREF(__pyx_t_5);
-      __pyx_t_6 = __Pyx_PyObject_GetItem(__pyx_t_4, __pyx_t_5); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 121, __pyx_L3_error)
-      __Pyx_GOTREF(__pyx_t_6);
-      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-      if (!(likely(PyString_CheckExact(__pyx_t_6))||((__pyx_t_6) == Py_None)||(PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "str", Py_TYPE(__pyx_t_6)->tp_name), 0))) __PYX_ERR(0, 121, __pyx_L3_error)
-      __Pyx_DECREF_SET(__pyx_v_algorithm, ((PyObject*)__pyx_t_6));
-      __pyx_t_6 = 0;
-
-      /* "crf.pyx":120
- * 
- *     def select_algorithm(self, algorithm: str):
- *         try:             # <<<<<<<<<<<<<<
- *             algorithm = self._algorithm_aliases[algorithm.lower()]
- *         except:
- */
-    }
-    __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
-    __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
-    __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
-    goto __pyx_L8_try_end;
-    __pyx_L3_error:;
-    __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
-    __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
-    __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
-
-    /* "crf.pyx":122
- *         try:
- *             algorithm = self._algorithm_aliases[algorithm.lower()]
- *         except:             # <<<<<<<<<<<<<<
- *             raise ValueError(f"{algorithm} is no available algorithm")
- *         if not self._trainer.select(algorithm, "crf1d"):
- */
-    /*except:*/ {
-      __Pyx_AddTraceback("crf.Trainer.select_algorithm", __pyx_clineno, __pyx_lineno, __pyx_filename);
-      if (__Pyx_GetException(&__pyx_t_6, &__pyx_t_5, &__pyx_t_4) < 0) __PYX_ERR(0, 122, __pyx_L5_except_error)
-      __Pyx_GOTREF(__pyx_t_6);
-      __Pyx_GOTREF(__pyx_t_5);
-      __Pyx_GOTREF(__pyx_t_4);
-
-      /* "crf.pyx":123
- *             algorithm = self._algorithm_aliases[algorithm.lower()]
- *         except:
- *             raise ValueError(f"{algorithm} is no available algorithm")             # <<<<<<<<<<<<<<
- *         if not self._trainer.select(algorithm, "crf1d"):
- *             raise ValueError(f"{algorithm} is no available algorithm")
- */
-      __pyx_t_7 = __Pyx_PyObject_FormatSimple(__pyx_v_algorithm, __pyx_empty_unicode); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 123, __pyx_L5_except_error)
-      __Pyx_GOTREF(__pyx_t_7);
-      __pyx_t_8 = __Pyx_PyUnicode_Concat(__pyx_t_7, __pyx_kp_u_is_no_available_algorithm); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 123, __pyx_L5_except_error)
-      __Pyx_GOTREF(__pyx_t_8);
-      __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
-      __pyx_t_7 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_8); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 123, __pyx_L5_except_error)
-      __Pyx_GOTREF(__pyx_t_7);
-      __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
-      __Pyx_Raise(__pyx_t_7, 0, 0, 0);
-      __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
-      __PYX_ERR(0, 123, __pyx_L5_except_error)
-    }
-    __pyx_L5_except_error:;
-
-    /* "crf.pyx":120
- * 
- *     def select_algorithm(self, algorithm: str):
- *         try:             # <<<<<<<<<<<<<<
- *             algorithm = self._algorithm_aliases[algorithm.lower()]
- *         except:
- */
-    __Pyx_XGIVEREF(__pyx_t_1);
-    __Pyx_XGIVEREF(__pyx_t_2);
-    __Pyx_XGIVEREF(__pyx_t_3);
-    __Pyx_ExceptionReset(__pyx_t_1, __pyx_t_2, __pyx_t_3);
-    goto __pyx_L1_error;
-    __pyx_L8_try_end:;
-  }
-
-  /* "crf.pyx":124
- *         except:
- *             raise ValueError(f"{algorithm} is no available algorithm")
- *         if not self._trainer.select(algorithm, "crf1d"):             # <<<<<<<<<<<<<<
- *             raise ValueError(f"{algorithm} is no available algorithm")
- * 
- */
-  __pyx_t_9 = __pyx_convert_string_from_py_std__in_string(__pyx_v_algorithm); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 124, __pyx_L1_error)
-  __pyx_t_10 = __pyx_convert_string_from_py_std__in_string(__pyx_n_b_crf1d); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 124, __pyx_L1_error)
-  try {
-    __pyx_t_11 = __pyx_v_self->_trainer.select(__pyx_t_9, __pyx_t_10);
-  } catch(...) {
-    __Pyx_CppExn2PyErr();
-    __PYX_ERR(0, 124, __pyx_L1_error)
-  }
-  __pyx_t_12 = ((!(__pyx_t_11 != 0)) != 0);
-  if (unlikely(__pyx_t_12)) {
-
-    /* "crf.pyx":125
- *             raise ValueError(f"{algorithm} is no available algorithm")
- *         if not self._trainer.select(algorithm, "crf1d"):
- *             raise ValueError(f"{algorithm} is no available algorithm")             # <<<<<<<<<<<<<<
- * 
- *     def set_params(self, params: dict[str, str | int | float | bool]):
- */
-    __pyx_t_4 = __Pyx_PyObject_FormatSimple(__pyx_v_algorithm, __pyx_empty_unicode); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 125, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_4);
-    __pyx_t_5 = __Pyx_PyUnicode_Concat(__pyx_t_4, __pyx_kp_u_is_no_available_algorithm); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 125, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_5);
-    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-    __pyx_t_4 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_5); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 125, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_4);
-    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-    __Pyx_Raise(__pyx_t_4, 0, 0, 0);
-    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-    __PYX_ERR(0, 125, __pyx_L1_error)
-
-    /* "crf.pyx":124
- *         except:
- *             raise ValueError(f"{algorithm} is no available algorithm")
- *         if not self._trainer.select(algorithm, "crf1d"):             # <<<<<<<<<<<<<<
- *             raise ValueError(f"{algorithm} is no available algorithm")
- * 
- */
-  }
-
-  /* "crf.pyx":119
- *         }
- * 
- *     def select_algorithm(self, algorithm: str):             # <<<<<<<<<<<<<<
- *         try:
- *             algorithm = self._algorithm_aliases[algorithm.lower()]
- */
-
-  /* function exit code */
-  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
-  goto __pyx_L0;
-  __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_4);
-  __Pyx_XDECREF(__pyx_t_5);
-  __Pyx_XDECREF(__pyx_t_6);
-  __Pyx_XDECREF(__pyx_t_7);
-  __Pyx_XDECREF(__pyx_t_8);
-  __Pyx_AddTraceback("crf.Trainer.select_algorithm", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __pyx_r = NULL;
-  __pyx_L0:;
-  __Pyx_XDECREF(__pyx_v_algorithm);
-  __Pyx_XGIVEREF(__pyx_r);
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-/* "crf.pyx":127
- *             raise ValueError(f"{algorithm} is no available algorithm")
- * 
- *     def set_params(self, params: dict[str, str | int | float | bool]):             # <<<<<<<<<<<<<<
- *         for param, value in params.items():
- *             self.set_param(param, value)
- */
-
-/* Python wrapper */
-static PyObject *__pyx_pw_3crf_7Trainer_15set_params(PyObject *__pyx_v_self, PyObject *__pyx_v_params); /*proto*/
-static char __pyx_doc_3crf_7Trainer_14set_params[] = "Trainer.set_params(self, params: dict[str, str | int | float | bool])";
-static PyObject *__pyx_pw_3crf_7Trainer_15set_params(PyObject *__pyx_v_self, PyObject *__pyx_v_params) {
-  PyObject *__pyx_r = 0;
-  __Pyx_RefNannyDeclarations
-  __Pyx_RefNannySetupContext("set_params (wrapper)", 0);
-  __pyx_r = __pyx_pf_3crf_7Trainer_14set_params(((struct __pyx_obj_3crf_Trainer *)__pyx_v_self), ((PyObject *)__pyx_v_params));
-
-  /* function exit code */
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-static PyObject *__pyx_pf_3crf_7Trainer_14set_params(struct __pyx_obj_3crf_Trainer *__pyx_v_self, PyObject *__pyx_v_params) {
-  PyObject *__pyx_v_param = NULL;
-  PyObject *__pyx_v_value = NULL;
-  PyObject *__pyx_r = NULL;
-  __Pyx_RefNannyDeclarations
-  PyObject *__pyx_t_1 = NULL;
-  PyObject *__pyx_t_2 = NULL;
-  PyObject *__pyx_t_3 = NULL;
-  Py_ssize_t __pyx_t_4;
-  PyObject *(*__pyx_t_5)(PyObject *);
-  PyObject *__pyx_t_6 = NULL;
-  PyObject *__pyx_t_7 = NULL;
-  PyObject *(*__pyx_t_8)(PyObject *);
-  int __pyx_t_9;
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("set_params", 0);
-
-  /* "crf.pyx":128
- * 
- *     def set_params(self, params: dict[str, str | int | float | bool]):
- *         for param, value in params.items():             # <<<<<<<<<<<<<<
- *             self.set_param(param, value)
- * 
- */
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_params, __pyx_n_s_items); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 128, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_3 = NULL;
-  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
-    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
-    if (likely(__pyx_t_3)) {
-      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
-      __Pyx_INCREF(__pyx_t_3);
-      __Pyx_INCREF(function);
-      __Pyx_DECREF_SET(__pyx_t_2, function);
-    }
-  }
-  __pyx_t_1 = (__pyx_t_3) ? __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_3) : __Pyx_PyObject_CallNoArg(__pyx_t_2);
-  __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
-  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 128, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  if (likely(PyList_CheckExact(__pyx_t_1)) || PyTuple_CheckExact(__pyx_t_1)) {
-    __pyx_t_2 = __pyx_t_1; __Pyx_INCREF(__pyx_t_2); __pyx_t_4 = 0;
-    __pyx_t_5 = NULL;
-  } else {
-    __pyx_t_4 = -1; __pyx_t_2 = PyObject_GetIter(__pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 128, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_2);
-    __pyx_t_5 = Py_TYPE(__pyx_t_2)->tp_iternext; if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 128, __pyx_L1_error)
-  }
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  for (;;) {
-    if (likely(!__pyx_t_5)) {
-      if (likely(PyList_CheckExact(__pyx_t_2))) {
-        if (__pyx_t_4 >= PyList_GET_SIZE(__pyx_t_2)) break;
-        #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-        __pyx_t_1 = PyList_GET_ITEM(__pyx_t_2, __pyx_t_4); __Pyx_INCREF(__pyx_t_1); __pyx_t_4++; if (unlikely(0 < 0)) __PYX_ERR(0, 128, __pyx_L1_error)
-        #else
-        __pyx_t_1 = PySequence_ITEM(__pyx_t_2, __pyx_t_4); __pyx_t_4++; if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 128, __pyx_L1_error)
-        __Pyx_GOTREF(__pyx_t_1);
-        #endif
-      } else {
-        if (__pyx_t_4 >= PyTuple_GET_SIZE(__pyx_t_2)) break;
-        #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-        __pyx_t_1 = PyTuple_GET_ITEM(__pyx_t_2, __pyx_t_4); __Pyx_INCREF(__pyx_t_1); __pyx_t_4++; if (unlikely(0 < 0)) __PYX_ERR(0, 128, __pyx_L1_error)
-        #else
-        __pyx_t_1 = PySequence_ITEM(__pyx_t_2, __pyx_t_4); __pyx_t_4++; if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 128, __pyx_L1_error)
-        __Pyx_GOTREF(__pyx_t_1);
-        #endif
-      }
-    } else {
-      __pyx_t_1 = __pyx_t_5(__pyx_t_2);
-      if (unlikely(!__pyx_t_1)) {
-        PyObject* exc_type = PyErr_Occurred();
-        if (exc_type) {
-          if (likely(__Pyx_PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
-          else __PYX_ERR(0, 128, __pyx_L1_error)
-        }
-        break;
-      }
-      __Pyx_GOTREF(__pyx_t_1);
-    }
-    if ((likely(PyTuple_CheckExact(__pyx_t_1))) || (PyList_CheckExact(__pyx_t_1))) {
-      PyObject* sequence = __pyx_t_1;
-      Py_ssize_t size = __Pyx_PySequence_SIZE(sequence);
-      if (unlikely(size != 2)) {
-        if (size > 2) __Pyx_RaiseTooManyValuesError(2);
-        else if (size >= 0) __Pyx_RaiseNeedMoreValuesError(size);
-        __PYX_ERR(0, 128, __pyx_L1_error)
-      }
-      #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-      if (likely(PyTuple_CheckExact(sequence))) {
-        __pyx_t_3 = PyTuple_GET_ITEM(sequence, 0); 
-        __pyx_t_6 = PyTuple_GET_ITEM(sequence, 1); 
-      } else {
-        __pyx_t_3 = PyList_GET_ITEM(sequence, 0); 
-        __pyx_t_6 = PyList_GET_ITEM(sequence, 1); 
-      }
-      __Pyx_INCREF(__pyx_t_3);
-      __Pyx_INCREF(__pyx_t_6);
-      #else
-      __pyx_t_3 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 128, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_3);
-      __pyx_t_6 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 128, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_6);
-      #endif
-      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-    } else {
-      Py_ssize_t index = -1;
-      __pyx_t_7 = PyObject_GetIter(__pyx_t_1); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 128, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_7);
-      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-      __pyx_t_8 = Py_TYPE(__pyx_t_7)->tp_iternext;
-      index = 0; __pyx_t_3 = __pyx_t_8(__pyx_t_7); if (unlikely(!__pyx_t_3)) goto __pyx_L5_unpacking_failed;
-      __Pyx_GOTREF(__pyx_t_3);
-      index = 1; __pyx_t_6 = __pyx_t_8(__pyx_t_7); if (unlikely(!__pyx_t_6)) goto __pyx_L5_unpacking_failed;
-      __Pyx_GOTREF(__pyx_t_6);
-      if (__Pyx_IternextUnpackEndCheck(__pyx_t_8(__pyx_t_7), 2) < 0) __PYX_ERR(0, 128, __pyx_L1_error)
-      __pyx_t_8 = NULL;
-      __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
-      goto __pyx_L6_unpacking_done;
-      __pyx_L5_unpacking_failed:;
-      __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
-      __pyx_t_8 = NULL;
-      if (__Pyx_IterFinish() == 0) __Pyx_RaiseNeedMoreValuesError(index);
-      __PYX_ERR(0, 128, __pyx_L1_error)
-      __pyx_L6_unpacking_done:;
-    }
-    __Pyx_XDECREF_SET(__pyx_v_param, __pyx_t_3);
-    __pyx_t_3 = 0;
-    __Pyx_XDECREF_SET(__pyx_v_value, __pyx_t_6);
-    __pyx_t_6 = 0;
-
-    /* "crf.pyx":129
- *     def set_params(self, params: dict[str, str | int | float | bool]):
- *         for param, value in params.items():
- *             self.set_param(param, value)             # <<<<<<<<<<<<<<
- * 
- *     def set_param(self, param: str, value: str | int | float | bool):
- */
-    __pyx_t_6 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_set_param); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 129, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_6);
-    __pyx_t_3 = NULL;
-    __pyx_t_9 = 0;
-    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_6))) {
-      __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_6);
-      if (likely(__pyx_t_3)) {
-        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_6);
-        __Pyx_INCREF(__pyx_t_3);
-        __Pyx_INCREF(function);
-        __Pyx_DECREF_SET(__pyx_t_6, function);
-        __pyx_t_9 = 1;
-      }
-    }
-    #if CYTHON_FAST_PYCALL
-    if (PyFunction_Check(__pyx_t_6)) {
-      PyObject *__pyx_temp[3] = {__pyx_t_3, __pyx_v_param, __pyx_v_value};
-      __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_6, __pyx_temp+1-__pyx_t_9, 2+__pyx_t_9); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 129, __pyx_L1_error)
-      __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
-      __Pyx_GOTREF(__pyx_t_1);
-    } else
-    #endif
-    #if CYTHON_FAST_PYCCALL
-    if (__Pyx_PyFastCFunction_Check(__pyx_t_6)) {
-      PyObject *__pyx_temp[3] = {__pyx_t_3, __pyx_v_param, __pyx_v_value};
-      __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_6, __pyx_temp+1-__pyx_t_9, 2+__pyx_t_9); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 129, __pyx_L1_error)
-      __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
-      __Pyx_GOTREF(__pyx_t_1);
-    } else
-    #endif
-    {
-      __pyx_t_7 = PyTuple_New(2+__pyx_t_9); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 129, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_7);
-      if (__pyx_t_3) {
-        __Pyx_GIVEREF(__pyx_t_3); PyTuple_SET_ITEM(__pyx_t_7, 0, __pyx_t_3); __pyx_t_3 = NULL;
-      }
-      __Pyx_INCREF(__pyx_v_param);
-      __Pyx_GIVEREF(__pyx_v_param);
-      PyTuple_SET_ITEM(__pyx_t_7, 0+__pyx_t_9, __pyx_v_param);
-      __Pyx_INCREF(__pyx_v_value);
-      __Pyx_GIVEREF(__pyx_v_value);
-      PyTuple_SET_ITEM(__pyx_t_7, 1+__pyx_t_9, __pyx_v_value);
-      __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_6, __pyx_t_7, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 129, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_1);
-      __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
-    }
-    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
-    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-
-    /* "crf.pyx":128
- * 
- *     def set_params(self, params: dict[str, str | int | float | bool]):
- *         for param, value in params.items():             # <<<<<<<<<<<<<<
- *             self.set_param(param, value)
- * 
- */
-  }
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-
-  /* "crf.pyx":127
- *             raise ValueError(f"{algorithm} is no available algorithm")
- * 
- *     def set_params(self, params: dict[str, str | int | float | bool]):             # <<<<<<<<<<<<<<
- *         for param, value in params.items():
- *             self.set_param(param, value)
- */
-
-  /* function exit code */
-  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
-  goto __pyx_L0;
-  __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_1);
-  __Pyx_XDECREF(__pyx_t_2);
-  __Pyx_XDECREF(__pyx_t_3);
-  __Pyx_XDECREF(__pyx_t_6);
-  __Pyx_XDECREF(__pyx_t_7);
-  __Pyx_AddTraceback("crf.Trainer.set_params", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __pyx_r = NULL;
-  __pyx_L0:;
-  __Pyx_XDECREF(__pyx_v_param);
-  __Pyx_XDECREF(__pyx_v_value);
-  __Pyx_XGIVEREF(__pyx_r);
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-/* "crf.pyx":131
- *             self.set_param(param, value)
- * 
- *     def set_param(self, param: str, value: str | int | float | bool):             # <<<<<<<<<<<<<<
- *         if isinstance(value, bool):
- *             value = int(value)
- */
-
-/* Python wrapper */
-static PyObject *__pyx_pw_3crf_7Trainer_17set_param(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
-static char __pyx_doc_3crf_7Trainer_16set_param[] = "Trainer.set_param(self, str param: str, value: str | int | float | bool)";
-static PyObject *__pyx_pw_3crf_7Trainer_17set_param(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
-  PyObject *__pyx_v_param = 0;
-  PyObject *__pyx_v_value = 0;
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-  PyObject *__pyx_r = 0;
-  __Pyx_RefNannyDeclarations
-  __Pyx_RefNannySetupContext("set_param (wrapper)", 0);
-  {
-    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_param,&__pyx_n_s_value,0};
-    PyObject* values[2] = {0,0};
-    if (unlikely(__pyx_kwds)) {
-      Py_ssize_t kw_args;
-      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
-      switch (pos_args) {
-        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
-        CYTHON_FALLTHROUGH;
-        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
-        CYTHON_FALLTHROUGH;
-        case  0: break;
-        default: goto __pyx_L5_argtuple_error;
-      }
-      kw_args = PyDict_Size(__pyx_kwds);
-      switch (pos_args) {
-        case  0:
-        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_param)) != 0)) kw_args--;
-        else goto __pyx_L5_argtuple_error;
-        CYTHON_FALLTHROUGH;
-        case  1:
-        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_value)) != 0)) kw_args--;
-        else {
-          __Pyx_RaiseArgtupleInvalid("set_param", 1, 2, 2, 1); __PYX_ERR(0, 131, __pyx_L3_error)
-        }
-      }
-      if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "set_param") < 0)) __PYX_ERR(0, 131, __pyx_L3_error)
-      }
-    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
-      goto __pyx_L5_argtuple_error;
-    } else {
-      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
-      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
-    }
-    __pyx_v_param = ((PyObject*)values[0]);
-    __pyx_v_value = values[1];
-  }
-  goto __pyx_L4_argument_unpacking_done;
-  __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("set_param", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 131, __pyx_L3_error)
-  __pyx_L3_error:;
-  __Pyx_AddTraceback("crf.Trainer.set_param", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __Pyx_RefNannyFinishContext();
-  return NULL;
-  __pyx_L4_argument_unpacking_done:;
-  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_param), (&PyString_Type), 1, "param", 1))) __PYX_ERR(0, 131, __pyx_L1_error)
-  __pyx_r = __pyx_pf_3crf_7Trainer_16set_param(((struct __pyx_obj_3crf_Trainer *)__pyx_v_self), __pyx_v_param, __pyx_v_value);
-
-  /* function exit code */
-  goto __pyx_L0;
-  __pyx_L1_error:;
-  __pyx_r = NULL;
-  __pyx_L0:;
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-static PyObject *__pyx_pf_3crf_7Trainer_16set_param(struct __pyx_obj_3crf_Trainer *__pyx_v_self, PyObject *__pyx_v_param, PyObject *__pyx_v_value) {
-  PyObject *__pyx_r = NULL;
-  __Pyx_RefNannyDeclarations
-  PyObject *__pyx_t_1 = NULL;
-  int __pyx_t_2;
-  int __pyx_t_3;
-  std::string __pyx_t_4;
-  std::string __pyx_t_5;
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("set_param", 0);
-  __Pyx_INCREF(__pyx_v_value);
-
-  /* "crf.pyx":132
- * 
- *     def set_param(self, param: str, value: str | int | float | bool):
- *         if isinstance(value, bool):             # <<<<<<<<<<<<<<
- *             value = int(value)
- *         self._trainer.set(param, str(value))
- */
-  __pyx_t_1 = ((PyObject*)&PyBool_Type);
-  __Pyx_INCREF(__pyx_t_1);
-  __pyx_t_2 = PyObject_IsInstance(__pyx_v_value, __pyx_t_1); if (unlikely(__pyx_t_2 == ((int)-1))) __PYX_ERR(0, 132, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_t_3 = (__pyx_t_2 != 0);
-  if (__pyx_t_3) {
-
-    /* "crf.pyx":133
- *     def set_param(self, param: str, value: str | int | float | bool):
- *         if isinstance(value, bool):
- *             value = int(value)             # <<<<<<<<<<<<<<
- *         self._trainer.set(param, str(value))
- * 
- */
-    __pyx_t_1 = __Pyx_PyNumber_Int(__pyx_v_value); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 133, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_1);
-    __Pyx_DECREF_SET(__pyx_v_value, __pyx_t_1);
-    __pyx_t_1 = 0;
-
-    /* "crf.pyx":132
- * 
- *     def set_param(self, param: str, value: str | int | float | bool):
- *         if isinstance(value, bool):             # <<<<<<<<<<<<<<
- *             value = int(value)
- *         self._trainer.set(param, str(value))
- */
-  }
-
-  /* "crf.pyx":134
- *         if isinstance(value, bool):
- *             value = int(value)
- *         self._trainer.set(param, str(value))             # <<<<<<<<<<<<<<
- * 
- *     def get_param(self, param: str):
- */
-  __pyx_t_4 = __pyx_convert_string_from_py_std__in_string(__pyx_v_param); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 134, __pyx_L1_error)
-  __pyx_t_1 = __Pyx_PyObject_CallOneArg(((PyObject *)(&PyString_Type)), __pyx_v_value); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 134, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_5 = __pyx_convert_string_from_py_std__in_string(__pyx_t_1); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 134, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  try {
-    __pyx_v_self->_trainer.set(__pyx_t_4, __pyx_t_5);
-  } catch(...) {
-    __Pyx_CppExn2PyErr();
-    __PYX_ERR(0, 134, __pyx_L1_error)
-  }
-
-  /* "crf.pyx":131
- *             self.set_param(param, value)
- * 
- *     def set_param(self, param: str, value: str | int | float | bool):             # <<<<<<<<<<<<<<
- *         if isinstance(value, bool):
- *             value = int(value)
- */
-
-  /* function exit code */
-  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
-  goto __pyx_L0;
-  __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_1);
-  __Pyx_AddTraceback("crf.Trainer.set_param", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __pyx_r = NULL;
-  __pyx_L0:;
-  __Pyx_XDECREF(__pyx_v_value);
-  __Pyx_XGIVEREF(__pyx_r);
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-/* "crf.pyx":136
- *         self._trainer.set(param, str(value))
- * 
- *     def get_param(self, param: str):             # <<<<<<<<<<<<<<
- *         return self.cast_parameter(param, self._trainer.get(param))
- * 
- */
-
-/* Python wrapper */
-static PyObject *__pyx_pw_3crf_7Trainer_19get_param(PyObject *__pyx_v_self, PyObject *__pyx_v_param); /*proto*/
-static char __pyx_doc_3crf_7Trainer_18get_param[] = "Trainer.get_param(self, str param: str)";
-static PyObject *__pyx_pw_3crf_7Trainer_19get_param(PyObject *__pyx_v_self, PyObject *__pyx_v_param) {
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-  PyObject *__pyx_r = 0;
-  __Pyx_RefNannyDeclarations
-  __Pyx_RefNannySetupContext("get_param (wrapper)", 0);
-  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_param), (&PyString_Type), 1, "param", 1))) __PYX_ERR(0, 136, __pyx_L1_error)
-  __pyx_r = __pyx_pf_3crf_7Trainer_18get_param(((struct __pyx_obj_3crf_Trainer *)__pyx_v_self), ((PyObject*)__pyx_v_param));
-
-  /* function exit code */
-  goto __pyx_L0;
-  __pyx_L1_error:;
-  __pyx_r = NULL;
-  __pyx_L0:;
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-static PyObject *__pyx_pf_3crf_7Trainer_18get_param(struct __pyx_obj_3crf_Trainer *__pyx_v_self, PyObject *__pyx_v_param) {
-  PyObject *__pyx_r = NULL;
-  __Pyx_RefNannyDeclarations
-  PyObject *__pyx_t_1 = NULL;
-  PyObject *__pyx_t_2 = NULL;
-  std::string __pyx_t_3;
-  std::string __pyx_t_4;
-  PyObject *__pyx_t_5 = NULL;
-  PyObject *__pyx_t_6 = NULL;
-  int __pyx_t_7;
-  PyObject *__pyx_t_8 = NULL;
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("get_param", 0);
-
-  /* "crf.pyx":137
- * 
- *     def get_param(self, param: str):
- *         return self.cast_parameter(param, self._trainer.get(param))             # <<<<<<<<<<<<<<
- * 
- *     def cast_parameter(self, param: str, value: str | int | float | bool):
- */
-  __Pyx_XDECREF(__pyx_r);
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_cast_parameter); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 137, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_3 = __pyx_convert_string_from_py_std__in_string(__pyx_v_param); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 137, __pyx_L1_error)
-  try {
-    __pyx_t_4 = __pyx_v_self->_trainer.get(__pyx_t_3);
-  } catch(...) {
-    __Pyx_CppExn2PyErr();
-    __PYX_ERR(0, 137, __pyx_L1_error)
-  }
-  __pyx_t_5 = __pyx_convert_PyStr_string_to_py_std__in_string(__pyx_t_4); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 137, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_5);
-  __pyx_t_6 = NULL;
-  __pyx_t_7 = 0;
-  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
-    __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_2);
-    if (likely(__pyx_t_6)) {
-      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
-      __Pyx_INCREF(__pyx_t_6);
-      __Pyx_INCREF(function);
-      __Pyx_DECREF_SET(__pyx_t_2, function);
-      __pyx_t_7 = 1;
-    }
-  }
-  #if CYTHON_FAST_PYCALL
-  if (PyFunction_Check(__pyx_t_2)) {
-    PyObject *__pyx_temp[3] = {__pyx_t_6, __pyx_v_param, __pyx_t_5};
-    __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_7, 2+__pyx_t_7); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 137, __pyx_L1_error)
-    __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
-    __Pyx_GOTREF(__pyx_t_1);
-    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-  } else
-  #endif
-  #if CYTHON_FAST_PYCCALL
-  if (__Pyx_PyFastCFunction_Check(__pyx_t_2)) {
-    PyObject *__pyx_temp[3] = {__pyx_t_6, __pyx_v_param, __pyx_t_5};
-    __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_7, 2+__pyx_t_7); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 137, __pyx_L1_error)
-    __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
-    __Pyx_GOTREF(__pyx_t_1);
-    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-  } else
-  #endif
-  {
-    __pyx_t_8 = PyTuple_New(2+__pyx_t_7); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 137, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_8);
-    if (__pyx_t_6) {
-      __Pyx_GIVEREF(__pyx_t_6); PyTuple_SET_ITEM(__pyx_t_8, 0, __pyx_t_6); __pyx_t_6 = NULL;
-    }
-    __Pyx_INCREF(__pyx_v_param);
-    __Pyx_GIVEREF(__pyx_v_param);
-    PyTuple_SET_ITEM(__pyx_t_8, 0+__pyx_t_7, __pyx_v_param);
-    __Pyx_GIVEREF(__pyx_t_5);
-    PyTuple_SET_ITEM(__pyx_t_8, 1+__pyx_t_7, __pyx_t_5);
-    __pyx_t_5 = 0;
-    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_8, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 137, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_1);
-    __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
-  }
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_r = __pyx_t_1;
-  __pyx_t_1 = 0;
-  goto __pyx_L0;
-
-  /* "crf.pyx":136
- *         self._trainer.set(param, str(value))
- * 
- *     def get_param(self, param: str):             # <<<<<<<<<<<<<<
- *         return self.cast_parameter(param, self._trainer.get(param))
- * 
- */
-
-  /* function exit code */
-  __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_1);
-  __Pyx_XDECREF(__pyx_t_2);
-  __Pyx_XDECREF(__pyx_t_5);
-  __Pyx_XDECREF(__pyx_t_6);
-  __Pyx_XDECREF(__pyx_t_8);
-  __Pyx_AddTraceback("crf.Trainer.get_param", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __pyx_r = NULL;
-  __pyx_L0:;
-  __Pyx_XGIVEREF(__pyx_r);
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-/* "crf.pyx":139
- *         return self.cast_parameter(param, self._trainer.get(param))
- * 
- *     def cast_parameter(self, param: str, value: str | int | float | bool):             # <<<<<<<<<<<<<<
- *         if param in self._parameter_types:
- *             return self._parameter_types[param](value)
- */
-
-/* Python wrapper */
-static PyObject *__pyx_pw_3crf_7Trainer_21cast_parameter(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
-static char __pyx_doc_3crf_7Trainer_20cast_parameter[] = "Trainer.cast_parameter(self, str param: str, value: str | int | float | bool)";
-static PyObject *__pyx_pw_3crf_7Trainer_21cast_parameter(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
-  PyObject *__pyx_v_param = 0;
-  PyObject *__pyx_v_value = 0;
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-  PyObject *__pyx_r = 0;
-  __Pyx_RefNannyDeclarations
-  __Pyx_RefNannySetupContext("cast_parameter (wrapper)", 0);
-  {
-    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_param,&__pyx_n_s_value,0};
-    PyObject* values[2] = {0,0};
-    if (unlikely(__pyx_kwds)) {
-      Py_ssize_t kw_args;
-      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
-      switch (pos_args) {
-        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
-        CYTHON_FALLTHROUGH;
-        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
-        CYTHON_FALLTHROUGH;
-        case  0: break;
-        default: goto __pyx_L5_argtuple_error;
-      }
-      kw_args = PyDict_Size(__pyx_kwds);
-      switch (pos_args) {
-        case  0:
-        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_param)) != 0)) kw_args--;
-        else goto __pyx_L5_argtuple_error;
-        CYTHON_FALLTHROUGH;
-        case  1:
-        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_value)) != 0)) kw_args--;
-        else {
-          __Pyx_RaiseArgtupleInvalid("cast_parameter", 1, 2, 2, 1); __PYX_ERR(0, 139, __pyx_L3_error)
-        }
-      }
-      if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "cast_parameter") < 0)) __PYX_ERR(0, 139, __pyx_L3_error)
-      }
-    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
-      goto __pyx_L5_argtuple_error;
-    } else {
-      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
-      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
-    }
-    __pyx_v_param = ((PyObject*)values[0]);
-    __pyx_v_value = values[1];
-  }
-  goto __pyx_L4_argument_unpacking_done;
-  __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("cast_parameter", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 139, __pyx_L3_error)
-  __pyx_L3_error:;
-  __Pyx_AddTraceback("crf.Trainer.cast_parameter", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __Pyx_RefNannyFinishContext();
-  return NULL;
-  __pyx_L4_argument_unpacking_done:;
-  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_param), (&PyString_Type), 1, "param", 1))) __PYX_ERR(0, 139, __pyx_L1_error)
-  __pyx_r = __pyx_pf_3crf_7Trainer_20cast_parameter(((struct __pyx_obj_3crf_Trainer *)__pyx_v_self), __pyx_v_param, __pyx_v_value);
-
-  /* function exit code */
-  goto __pyx_L0;
-  __pyx_L1_error:;
-  __pyx_r = NULL;
-  __pyx_L0:;
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-static PyObject *__pyx_pf_3crf_7Trainer_20cast_parameter(struct __pyx_obj_3crf_Trainer *__pyx_v_self, PyObject *__pyx_v_param, PyObject *__pyx_v_value) {
-  PyObject *__pyx_r = NULL;
-  __Pyx_RefNannyDeclarations
-  PyObject *__pyx_t_1 = NULL;
-  int __pyx_t_2;
-  int __pyx_t_3;
-  PyObject *__pyx_t_4 = NULL;
-  PyObject *__pyx_t_5 = NULL;
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("cast_parameter", 0);
-
-  /* "crf.pyx":140
- * 
- *     def cast_parameter(self, param: str, value: str | int | float | bool):
- *         if param in self._parameter_types:             # <<<<<<<<<<<<<<
- *             return self._parameter_types[param](value)
- *         return value
- */
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_parameter_types); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 140, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = (__Pyx_PySequence_ContainsTF(__pyx_v_param, __pyx_t_1, Py_EQ)); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 140, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_t_3 = (__pyx_t_2 != 0);
-  if (__pyx_t_3) {
-
-    /* "crf.pyx":141
- *     def cast_parameter(self, param: str, value: str | int | float | bool):
- *         if param in self._parameter_types:
- *             return self._parameter_types[param](value)             # <<<<<<<<<<<<<<
- *         return value
- * 
- */
-    __Pyx_XDECREF(__pyx_r);
-    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_parameter_types); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 141, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_4);
-    __pyx_t_5 = __Pyx_PyObject_Dict_GetItem(__pyx_t_4, __pyx_v_param); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 141, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_5);
-    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-    __pyx_t_4 = NULL;
-    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_5))) {
-      __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_5);
-      if (likely(__pyx_t_4)) {
-        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
-        __Pyx_INCREF(__pyx_t_4);
-        __Pyx_INCREF(function);
-        __Pyx_DECREF_SET(__pyx_t_5, function);
-      }
-    }
-    __pyx_t_1 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_5, __pyx_t_4, __pyx_v_value) : __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_v_value);
-    __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
-    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 141, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_1);
-    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-    __pyx_r = __pyx_t_1;
-    __pyx_t_1 = 0;
-    goto __pyx_L0;
-
-    /* "crf.pyx":140
- * 
- *     def cast_parameter(self, param: str, value: str | int | float | bool):
- *         if param in self._parameter_types:             # <<<<<<<<<<<<<<
- *             return self._parameter_types[param](value)
- *         return value
- */
-  }
-
-  /* "crf.pyx":142
- *         if param in self._parameter_types:
- *             return self._parameter_types[param](value)
- *         return value             # <<<<<<<<<<<<<<
- * 
- * 
- */
-  __Pyx_XDECREF(__pyx_r);
-  __Pyx_INCREF(__pyx_v_value);
-  __pyx_r = __pyx_v_value;
-  goto __pyx_L0;
-
-  /* "crf.pyx":139
- *         return self.cast_parameter(param, self._trainer.get(param))
- * 
- *     def cast_parameter(self, param: str, value: str | int | float | bool):             # <<<<<<<<<<<<<<
- *         if param in self._parameter_types:
- *             return self._parameter_types[param](value)
- */
-
-  /* function exit code */
-  __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_1);
-  __Pyx_XDECREF(__pyx_t_4);
-  __Pyx_XDECREF(__pyx_t_5);
-  __Pyx_AddTraceback("crf.Trainer.cast_parameter", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __pyx_r = NULL;
-  __pyx_L0:;
-  __Pyx_XGIVEREF(__pyx_r);
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-/* "(tree fragment)":1
- * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
- *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
- * def __setstate_cython__(self, __pyx_state):
- */
-
-/* Python wrapper */
-static PyObject *__pyx_pw_3crf_7Trainer_27__reduce_cython__(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
-static char __pyx_doc_3crf_7Trainer_26__reduce_cython__[] = "Trainer.__reduce_cython__(self)";
-static PyObject *__pyx_pw_3crf_7Trainer_27__reduce_cython__(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
-  PyObject *__pyx_r = 0;
-  __Pyx_RefNannyDeclarations
-  __Pyx_RefNannySetupContext("__reduce_cython__ (wrapper)", 0);
-  __pyx_r = __pyx_pf_3crf_7Trainer_26__reduce_cython__(((struct __pyx_obj_3crf_Trainer *)__pyx_v_self));
-
-  /* function exit code */
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-static PyObject *__pyx_pf_3crf_7Trainer_26__reduce_cython__(CYTHON_UNUSED struct __pyx_obj_3crf_Trainer *__pyx_v_self) {
-  PyObject *__pyx_r = NULL;
-  __Pyx_RefNannyDeclarations
-  PyObject *__pyx_t_1 = NULL;
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("__reduce_cython__", 0);
-
-  /* "(tree fragment)":2
- * def __reduce_cython__(self):
- *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
- * def __setstate_cython__(self, __pyx_state):
- *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
- */
-  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple_, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 2, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __Pyx_Raise(__pyx_t_1, 0, 0, 0);
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __PYX_ERR(1, 2, __pyx_L1_error)
-
-  /* "(tree fragment)":1
- * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
- *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
- * def __setstate_cython__(self, __pyx_state):
- */
-
-  /* function exit code */
-  __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_1);
-  __Pyx_AddTraceback("crf.Trainer.__reduce_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __pyx_r = NULL;
-  __Pyx_XGIVEREF(__pyx_r);
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-/* "(tree fragment)":3
- * def __reduce_cython__(self):
- *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
- * def __setstate_cython__(self, __pyx_state):             # <<<<<<<<<<<<<<
- *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
- */
-
-/* Python wrapper */
-static PyObject *__pyx_pw_3crf_7Trainer_29__setstate_cython__(PyObject *__pyx_v_self, PyObject *__pyx_v___pyx_state); /*proto*/
-static char __pyx_doc_3crf_7Trainer_28__setstate_cython__[] = "Trainer.__setstate_cython__(self, __pyx_state)";
-static PyObject *__pyx_pw_3crf_7Trainer_29__setstate_cython__(PyObject *__pyx_v_self, PyObject *__pyx_v___pyx_state) {
-  PyObject *__pyx_r = 0;
-  __Pyx_RefNannyDeclarations
-  __Pyx_RefNannySetupContext("__setstate_cython__ (wrapper)", 0);
-  __pyx_r = __pyx_pf_3crf_7Trainer_28__setstate_cython__(((struct __pyx_obj_3crf_Trainer *)__pyx_v_self), ((PyObject *)__pyx_v___pyx_state));
-
-  /* function exit code */
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-static PyObject *__pyx_pf_3crf_7Trainer_28__setstate_cython__(CYTHON_UNUSED struct __pyx_obj_3crf_Trainer *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v___pyx_state) {
-  PyObject *__pyx_r = NULL;
-  __Pyx_RefNannyDeclarations
-  PyObject *__pyx_t_1 = NULL;
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("__setstate_cython__", 0);
-
-  /* "(tree fragment)":4
- *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
- * def __setstate_cython__(self, __pyx_state):
- *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
- */
-  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__2, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 4, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __Pyx_Raise(__pyx_t_1, 0, 0, 0);
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __PYX_ERR(1, 4, __pyx_L1_error)
-
-  /* "(tree fragment)":3
- * def __reduce_cython__(self):
- *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
- * def __setstate_cython__(self, __pyx_state):             # <<<<<<<<<<<<<<
- *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
- */
-
-  /* function exit code */
-  __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_1);
-  __Pyx_AddTraceback("crf.Trainer.__setstate_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __pyx_r = NULL;
-  __Pyx_XGIVEREF(__pyx_r);
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-/* "crf.pyx":148
- *     cdef crfsuite_api.Tagger _tagger
- * 
- *     def __init__(self, model_filepath: Filepath):             # <<<<<<<<<<<<<<
- *         self.load(model_filepath)
- * 
- */
-
-/* Python wrapper */
-static int __pyx_pw_3crf_5Model_1__init__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
-static int __pyx_pw_3crf_5Model_1__init__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
-  PyObject *__pyx_v_model_filepath = 0;
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-  int __pyx_r;
-  __Pyx_RefNannyDeclarations
-  __Pyx_RefNannySetupContext("__init__ (wrapper)", 0);
-  {
-    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_model_filepath,0};
-    PyObject* values[1] = {0};
-    if (unlikely(__pyx_kwds)) {
-      Py_ssize_t kw_args;
-      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
-      switch (pos_args) {
-        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
-        CYTHON_FALLTHROUGH;
-        case  0: break;
-        default: goto __pyx_L5_argtuple_error;
-      }
-      kw_args = PyDict_Size(__pyx_kwds);
-      switch (pos_args) {
-        case  0:
-        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_model_filepath)) != 0)) kw_args--;
-        else goto __pyx_L5_argtuple_error;
-      }
-      if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__init__") < 0)) __PYX_ERR(0, 148, __pyx_L3_error)
-      }
-    } else if (PyTuple_GET_SIZE(__pyx_args) != 1) {
-      goto __pyx_L5_argtuple_error;
-    } else {
-      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
-    }
-    __pyx_v_model_filepath = values[0];
-  }
-  goto __pyx_L4_argument_unpacking_done;
-  __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("__init__", 1, 1, 1, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 148, __pyx_L3_error)
-  __pyx_L3_error:;
-  __Pyx_AddTraceback("crf.Model.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __Pyx_RefNannyFinishContext();
-  return -1;
-  __pyx_L4_argument_unpacking_done:;
-  __pyx_r = __pyx_pf_3crf_5Model___init__(((struct __pyx_obj_3crf_Model *)__pyx_v_self), __pyx_v_model_filepath);
-
-  /* function exit code */
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-static int __pyx_pf_3crf_5Model___init__(struct __pyx_obj_3crf_Model *__pyx_v_self, PyObject *__pyx_v_model_filepath) {
-  int __pyx_r;
-  __Pyx_RefNannyDeclarations
-  PyObject *__pyx_t_1 = NULL;
-  PyObject *__pyx_t_2 = NULL;
-  PyObject *__pyx_t_3 = NULL;
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("__init__", 0);
-
-  /* "crf.pyx":149
- * 
- *     def __init__(self, model_filepath: Filepath):
- *         self.load(model_filepath)             # <<<<<<<<<<<<<<
- * 
- *     @property
- */
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_load); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 149, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_3 = NULL;
-  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
-    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
-    if (likely(__pyx_t_3)) {
-      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
-      __Pyx_INCREF(__pyx_t_3);
-      __Pyx_INCREF(function);
-      __Pyx_DECREF_SET(__pyx_t_2, function);
-    }
-  }
-  __pyx_t_1 = (__pyx_t_3) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_3, __pyx_v_model_filepath) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_v_model_filepath);
-  __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
-  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 149, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-
-  /* "crf.pyx":148
- *     cdef crfsuite_api.Tagger _tagger
- * 
- *     def __init__(self, model_filepath: Filepath):             # <<<<<<<<<<<<<<
- *         self.load(model_filepath)
- * 
- */
-
-  /* function exit code */
-  __pyx_r = 0;
-  goto __pyx_L0;
-  __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_1);
-  __Pyx_XDECREF(__pyx_t_2);
-  __Pyx_XDECREF(__pyx_t_3);
-  __Pyx_AddTraceback("crf.Model.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __pyx_r = -1;
-  __pyx_L0:;
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-/* "crf.pyx":152
- * 
- *     @property
- *     def labels(self):             # <<<<<<<<<<<<<<
- *         return self._tagger.labels()
- * 
- */
-
-/* Python wrapper */
-static PyObject *__pyx_pw_3crf_5Model_6labels_1__get__(PyObject *__pyx_v_self); /*proto*/
-static PyObject *__pyx_pw_3crf_5Model_6labels_1__get__(PyObject *__pyx_v_self) {
-  PyObject *__pyx_r = 0;
-  __Pyx_RefNannyDeclarations
-  __Pyx_RefNannySetupContext("__get__ (wrapper)", 0);
-  __pyx_r = __pyx_pf_3crf_5Model_6labels___get__(((struct __pyx_obj_3crf_Model *)__pyx_v_self));
-
-  /* function exit code */
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-static PyObject *__pyx_pf_3crf_5Model_6labels___get__(struct __pyx_obj_3crf_Model *__pyx_v_self) {
-  PyObject *__pyx_r = NULL;
-  __Pyx_RefNannyDeclarations
-  CRFSuite::StringList __pyx_t_1;
-  PyObject *__pyx_t_2 = NULL;
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("__get__", 0);
-
-  /* "crf.pyx":153
- *     @property
- *     def labels(self):
- *         return self._tagger.labels()             # <<<<<<<<<<<<<<
- * 
- *     def predict_single(self, sequence: Sequence) -> list[str]:
- */
-  __Pyx_XDECREF(__pyx_r);
-  try {
-    __pyx_t_1 = __pyx_v_self->_tagger.labels();
-  } catch(...) {
-    __Pyx_CppExn2PyErr();
-    __PYX_ERR(0, 153, __pyx_L1_error)
-  }
-  __pyx_t_2 = __pyx_convert_vector_to_py_std_3a__3a_string(__pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 153, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  __pyx_r = __pyx_t_2;
-  __pyx_t_2 = 0;
-  goto __pyx_L0;
-
-  /* "crf.pyx":152
- * 
- *     @property
- *     def labels(self):             # <<<<<<<<<<<<<<
- *         return self._tagger.labels()
- * 
- */
-
-  /* function exit code */
-  __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_2);
-  __Pyx_AddTraceback("crf.Model.labels.__get__", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __pyx_r = NULL;
-  __pyx_L0:;
-  __Pyx_XGIVEREF(__pyx_r);
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-/* "crf.pyx":155
- *         return self._tagger.labels()
- * 
- *     def predict_single(self, sequence: Sequence) -> list[str]:             # <<<<<<<<<<<<<<
- *         self.set_sequence(sequence)
- *         return self._tagger.viterbi()
- */
-
-/* Python wrapper */
-static PyObject *__pyx_pw_3crf_5Model_3predict_single(PyObject *__pyx_v_self, PyObject *__pyx_v_sequence); /*proto*/
-static char __pyx_doc_3crf_5Model_2predict_single[] = "Model.predict_single(self, sequence: Sequence) -> list[str]";
-static PyObject *__pyx_pw_3crf_5Model_3predict_single(PyObject *__pyx_v_self, PyObject *__pyx_v_sequence) {
-  PyObject *__pyx_r = 0;
-  __Pyx_RefNannyDeclarations
-  __Pyx_RefNannySetupContext("predict_single (wrapper)", 0);
-  __pyx_r = __pyx_pf_3crf_5Model_2predict_single(((struct __pyx_obj_3crf_Model *)__pyx_v_self), ((PyObject *)__pyx_v_sequence));
-
-  /* function exit code */
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-static PyObject *__pyx_pf_3crf_5Model_2predict_single(struct __pyx_obj_3crf_Model *__pyx_v_self, PyObject *__pyx_v_sequence) {
-  PyObject *__pyx_r = NULL;
-  __Pyx_RefNannyDeclarations
-  PyObject *__pyx_t_1 = NULL;
-  CRFSuite::StringList __pyx_t_2;
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("predict_single", 0);
-
-  /* "crf.pyx":156
- * 
- *     def predict_single(self, sequence: Sequence) -> list[str]:
- *         self.set_sequence(sequence)             # <<<<<<<<<<<<<<
- *         return self._tagger.viterbi()
- * 
- */
-  try {
-    __pyx_t_1 = ((struct __pyx_vtabstruct_3crf_Model *)__pyx_v_self->__pyx_vtab)->set_sequence(__pyx_v_self, __pyx_v_sequence, 0);
-    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 156, __pyx_L1_error)
-  } catch(...) {
-    __Pyx_CppExn2PyErr();
-    __PYX_ERR(0, 156, __pyx_L1_error)
-  }
-  __Pyx_GOTREF(__pyx_t_1);
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-
-  /* "crf.pyx":157
- *     def predict_single(self, sequence: Sequence) -> list[str]:
- *         self.set_sequence(sequence)
- *         return self._tagger.viterbi()             # <<<<<<<<<<<<<<
- * 
- *     def predict_proba_single(self, sequence: Sequence) -> list[dict[str, float]]:
- */
-  __Pyx_XDECREF(__pyx_r);
-  try {
-    __pyx_t_2 = __pyx_v_self->_tagger.viterbi();
-  } catch(...) {
-    __Pyx_CppExn2PyErr();
-    __PYX_ERR(0, 157, __pyx_L1_error)
-  }
-  __pyx_t_1 = __pyx_convert_vector_to_py_std_3a__3a_string(__pyx_t_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 157, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __pyx_r = __pyx_t_1;
-  __pyx_t_1 = 0;
-  goto __pyx_L0;
-
-  /* "crf.pyx":155
- *         return self._tagger.labels()
- * 
- *     def predict_single(self, sequence: Sequence) -> list[str]:             # <<<<<<<<<<<<<<
- *         self.set_sequence(sequence)
- *         return self._tagger.viterbi()
- */
-
-  /* function exit code */
-  __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_1);
-  __Pyx_AddTraceback("crf.Model.predict_single", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __pyx_r = NULL;
-  __pyx_L0:;
-  __Pyx_XGIVEREF(__pyx_r);
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-/* "crf.pyx":159
- *         return self._tagger.viterbi()
- * 
- *     def predict_proba_single(self, sequence: Sequence) -> list[dict[str, float]]:             # <<<<<<<<<<<<<<
- *         self.set_sequence(sequence)
- *         return [
- */
-
-/* Python wrapper */
-static PyObject *__pyx_pw_3crf_5Model_5predict_proba_single(PyObject *__pyx_v_self, PyObject *__pyx_v_sequence); /*proto*/
-static char __pyx_doc_3crf_5Model_4predict_proba_single[] = "Model.predict_proba_single(self, sequence: Sequence) -> list[dict[str, float]]";
-static PyObject *__pyx_pw_3crf_5Model_5predict_proba_single(PyObject *__pyx_v_self, PyObject *__pyx_v_sequence) {
-  PyObject *__pyx_r = 0;
-  __Pyx_RefNannyDeclarations
-  __Pyx_RefNannySetupContext("predict_proba_single (wrapper)", 0);
-  __pyx_r = __pyx_pf_3crf_5Model_4predict_proba_single(((struct __pyx_obj_3crf_Model *)__pyx_v_self), ((PyObject *)__pyx_v_sequence));
-
-  /* function exit code */
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-static PyObject *__pyx_pf_3crf_5Model_4predict_proba_single(struct __pyx_obj_3crf_Model *__pyx_v_self, PyObject *__pyx_v_sequence) {
-  Py_ssize_t __pyx_v_index;
-  PyObject *__pyx_8genexpr1__pyx_v_label = NULL;
-  PyObject *__pyx_r = NULL;
-  __Pyx_RefNannyDeclarations
-  PyObject *__pyx_t_1 = NULL;
-  Py_ssize_t __pyx_t_2;
-  Py_ssize_t __pyx_t_3;
-  Py_ssize_t __pyx_t_4;
-  PyObject *__pyx_t_5 = NULL;
-  PyObject *__pyx_t_6 = NULL;
-  PyObject *__pyx_t_7 = NULL;
-  Py_ssize_t __pyx_t_8;
-  PyObject *(*__pyx_t_9)(PyObject *);
-  PyObject *__pyx_t_10 = NULL;
-  PyObject *__pyx_t_11 = NULL;
-  PyObject *__pyx_t_12 = NULL;
-  int __pyx_t_13;
-  PyObject *__pyx_t_14 = NULL;
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("predict_proba_single", 0);
-
-  /* "crf.pyx":160
- * 
- *     def predict_proba_single(self, sequence: Sequence) -> list[dict[str, float]]:
- *         self.set_sequence(sequence)             # <<<<<<<<<<<<<<
- *         return [
- *             {label: self.marginal(label, index) for label in self.labels}
- */
-  try {
-    __pyx_t_1 = ((struct __pyx_vtabstruct_3crf_Model *)__pyx_v_self->__pyx_vtab)->set_sequence(__pyx_v_self, __pyx_v_sequence, 0);
-    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 160, __pyx_L1_error)
-  } catch(...) {
-    __Pyx_CppExn2PyErr();
-    __PYX_ERR(0, 160, __pyx_L1_error)
-  }
-  __Pyx_GOTREF(__pyx_t_1);
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-
-  /* "crf.pyx":161
- *     def predict_proba_single(self, sequence: Sequence) -> list[dict[str, float]]:
- *         self.set_sequence(sequence)
- *         return [             # <<<<<<<<<<<<<<
- *             {label: self.marginal(label, index) for label in self.labels}
- *             for index in range(len(sequence))
- */
-  __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = PyList_New(0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 161, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-
-  /* "crf.pyx":163
- *         return [
- *             {label: self.marginal(label, index) for label in self.labels}
- *             for index in range(len(sequence))             # <<<<<<<<<<<<<<
- *         ]
- * 
- */
-  __pyx_t_2 = PyObject_Length(__pyx_v_sequence); if (unlikely(__pyx_t_2 == ((Py_ssize_t)-1))) __PYX_ERR(0, 163, __pyx_L1_error)
-  __pyx_t_3 = __pyx_t_2;
-  for (__pyx_t_4 = 0; __pyx_t_4 < __pyx_t_3; __pyx_t_4+=1) {
-    __pyx_v_index = __pyx_t_4;
-    { /* enter inner scope */
-
-      /* "crf.pyx":162
- *         self.set_sequence(sequence)
- *         return [
- *             {label: self.marginal(label, index) for label in self.labels}             # <<<<<<<<<<<<<<
- *             for index in range(len(sequence))
- *         ]
- */
-      __pyx_t_5 = PyDict_New(); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 162, __pyx_L7_error)
-      __Pyx_GOTREF(__pyx_t_5);
-      __pyx_t_6 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_labels); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 162, __pyx_L7_error)
-      __Pyx_GOTREF(__pyx_t_6);
-      if (likely(PyList_CheckExact(__pyx_t_6)) || PyTuple_CheckExact(__pyx_t_6)) {
-        __pyx_t_7 = __pyx_t_6; __Pyx_INCREF(__pyx_t_7); __pyx_t_8 = 0;
-        __pyx_t_9 = NULL;
-      } else {
-        __pyx_t_8 = -1; __pyx_t_7 = PyObject_GetIter(__pyx_t_6); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 162, __pyx_L7_error)
-        __Pyx_GOTREF(__pyx_t_7);
-        __pyx_t_9 = Py_TYPE(__pyx_t_7)->tp_iternext; if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 162, __pyx_L7_error)
-      }
-      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
-      for (;;) {
-        if (likely(!__pyx_t_9)) {
-          if (likely(PyList_CheckExact(__pyx_t_7))) {
-            if (__pyx_t_8 >= PyList_GET_SIZE(__pyx_t_7)) break;
-            #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-            __pyx_t_6 = PyList_GET_ITEM(__pyx_t_7, __pyx_t_8); __Pyx_INCREF(__pyx_t_6); __pyx_t_8++; if (unlikely(0 < 0)) __PYX_ERR(0, 162, __pyx_L7_error)
-            #else
-            __pyx_t_6 = PySequence_ITEM(__pyx_t_7, __pyx_t_8); __pyx_t_8++; if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 162, __pyx_L7_error)
-            __Pyx_GOTREF(__pyx_t_6);
-            #endif
-          } else {
-            if (__pyx_t_8 >= PyTuple_GET_SIZE(__pyx_t_7)) break;
-            #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-            __pyx_t_6 = PyTuple_GET_ITEM(__pyx_t_7, __pyx_t_8); __Pyx_INCREF(__pyx_t_6); __pyx_t_8++; if (unlikely(0 < 0)) __PYX_ERR(0, 162, __pyx_L7_error)
-            #else
-            __pyx_t_6 = PySequence_ITEM(__pyx_t_7, __pyx_t_8); __pyx_t_8++; if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 162, __pyx_L7_error)
-            __Pyx_GOTREF(__pyx_t_6);
-            #endif
-          }
-        } else {
-          __pyx_t_6 = __pyx_t_9(__pyx_t_7);
-          if (unlikely(!__pyx_t_6)) {
-            PyObject* exc_type = PyErr_Occurred();
-            if (exc_type) {
-              if (likely(__Pyx_PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
-              else __PYX_ERR(0, 162, __pyx_L7_error)
-            }
-            break;
-          }
-          __Pyx_GOTREF(__pyx_t_6);
-        }
-        __Pyx_XDECREF_SET(__pyx_8genexpr1__pyx_v_label, __pyx_t_6);
-        __pyx_t_6 = 0;
-        __pyx_t_10 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_marginal); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 162, __pyx_L7_error)
-        __Pyx_GOTREF(__pyx_t_10);
-        __pyx_t_11 = PyInt_FromSsize_t(__pyx_v_index); if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 162, __pyx_L7_error)
-        __Pyx_GOTREF(__pyx_t_11);
-        __pyx_t_12 = NULL;
-        __pyx_t_13 = 0;
-        if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_10))) {
-          __pyx_t_12 = PyMethod_GET_SELF(__pyx_t_10);
-          if (likely(__pyx_t_12)) {
-            PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_10);
-            __Pyx_INCREF(__pyx_t_12);
-            __Pyx_INCREF(function);
-            __Pyx_DECREF_SET(__pyx_t_10, function);
-            __pyx_t_13 = 1;
-          }
-        }
-        #if CYTHON_FAST_PYCALL
-        if (PyFunction_Check(__pyx_t_10)) {
-          PyObject *__pyx_temp[3] = {__pyx_t_12, __pyx_8genexpr1__pyx_v_label, __pyx_t_11};
-          __pyx_t_6 = __Pyx_PyFunction_FastCall(__pyx_t_10, __pyx_temp+1-__pyx_t_13, 2+__pyx_t_13); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 162, __pyx_L7_error)
-          __Pyx_XDECREF(__pyx_t_12); __pyx_t_12 = 0;
-          __Pyx_GOTREF(__pyx_t_6);
-          __Pyx_DECREF(__pyx_t_11); __pyx_t_11 = 0;
-        } else
-        #endif
-        #if CYTHON_FAST_PYCCALL
-        if (__Pyx_PyFastCFunction_Check(__pyx_t_10)) {
-          PyObject *__pyx_temp[3] = {__pyx_t_12, __pyx_8genexpr1__pyx_v_label, __pyx_t_11};
-          __pyx_t_6 = __Pyx_PyCFunction_FastCall(__pyx_t_10, __pyx_temp+1-__pyx_t_13, 2+__pyx_t_13); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 162, __pyx_L7_error)
-          __Pyx_XDECREF(__pyx_t_12); __pyx_t_12 = 0;
-          __Pyx_GOTREF(__pyx_t_6);
-          __Pyx_DECREF(__pyx_t_11); __pyx_t_11 = 0;
-        } else
-        #endif
-        {
-          __pyx_t_14 = PyTuple_New(2+__pyx_t_13); if (unlikely(!__pyx_t_14)) __PYX_ERR(0, 162, __pyx_L7_error)
-          __Pyx_GOTREF(__pyx_t_14);
-          if (__pyx_t_12) {
-            __Pyx_GIVEREF(__pyx_t_12); PyTuple_SET_ITEM(__pyx_t_14, 0, __pyx_t_12); __pyx_t_12 = NULL;
-          }
-          __Pyx_INCREF(__pyx_8genexpr1__pyx_v_label);
-          __Pyx_GIVEREF(__pyx_8genexpr1__pyx_v_label);
-          PyTuple_SET_ITEM(__pyx_t_14, 0+__pyx_t_13, __pyx_8genexpr1__pyx_v_label);
-          __Pyx_GIVEREF(__pyx_t_11);
-          PyTuple_SET_ITEM(__pyx_t_14, 1+__pyx_t_13, __pyx_t_11);
-          __pyx_t_11 = 0;
-          __pyx_t_6 = __Pyx_PyObject_Call(__pyx_t_10, __pyx_t_14, NULL); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 162, __pyx_L7_error)
-          __Pyx_GOTREF(__pyx_t_6);
-          __Pyx_DECREF(__pyx_t_14); __pyx_t_14 = 0;
-        }
-        __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
-        if (unlikely(PyDict_SetItem(__pyx_t_5, (PyObject*)__pyx_8genexpr1__pyx_v_label, (PyObject*)__pyx_t_6))) __PYX_ERR(0, 162, __pyx_L7_error)
-        __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
-      }
-      __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
-      __Pyx_XDECREF(__pyx_8genexpr1__pyx_v_label); __pyx_8genexpr1__pyx_v_label = 0;
-      goto __pyx_L10_exit_scope;
-      __pyx_L7_error:;
-      __Pyx_XDECREF(__pyx_8genexpr1__pyx_v_label); __pyx_8genexpr1__pyx_v_label = 0;
-      goto __pyx_L1_error;
-      __pyx_L10_exit_scope:;
-    } /* exit inner scope */
-    if (unlikely(__Pyx_ListComp_Append(__pyx_t_1, (PyObject*)__pyx_t_5))) __PYX_ERR(0, 161, __pyx_L1_error)
-    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-  }
-  __pyx_r = __pyx_t_1;
-  __pyx_t_1 = 0;
-  goto __pyx_L0;
-
-  /* "crf.pyx":159
- *         return self._tagger.viterbi()
- * 
- *     def predict_proba_single(self, sequence: Sequence) -> list[dict[str, float]]:             # <<<<<<<<<<<<<<
- *         self.set_sequence(sequence)
- *         return [
- */
-
-  /* function exit code */
-  __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_1);
-  __Pyx_XDECREF(__pyx_t_5);
-  __Pyx_XDECREF(__pyx_t_6);
-  __Pyx_XDECREF(__pyx_t_7);
-  __Pyx_XDECREF(__pyx_t_10);
-  __Pyx_XDECREF(__pyx_t_11);
-  __Pyx_XDECREF(__pyx_t_12);
-  __Pyx_XDECREF(__pyx_t_14);
-  __Pyx_AddTraceback("crf.Model.predict_proba_single", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __pyx_r = NULL;
-  __pyx_L0:;
-  __Pyx_XDECREF(__pyx_8genexpr1__pyx_v_label);
-  __Pyx_XGIVEREF(__pyx_r);
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-/* "crf.pyx":166
- *         ]
- * 
- *     def load(self, filepath: Filepath):             # <<<<<<<<<<<<<<
- *         filepath = str(filepath)
- *         self.check_model(filepath)
- */
-
-/* Python wrapper */
-static PyObject *__pyx_pw_3crf_5Model_7load(PyObject *__pyx_v_self, PyObject *__pyx_v_filepath); /*proto*/
-static char __pyx_doc_3crf_5Model_6load[] = "Model.load(self, filepath: Filepath)";
-static PyObject *__pyx_pw_3crf_5Model_7load(PyObject *__pyx_v_self, PyObject *__pyx_v_filepath) {
-  PyObject *__pyx_r = 0;
-  __Pyx_RefNannyDeclarations
-  __Pyx_RefNannySetupContext("load (wrapper)", 0);
-  __pyx_r = __pyx_pf_3crf_5Model_6load(((struct __pyx_obj_3crf_Model *)__pyx_v_self), ((PyObject *)__pyx_v_filepath));
-
-  /* function exit code */
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-static PyObject *__pyx_pf_3crf_5Model_6load(struct __pyx_obj_3crf_Model *__pyx_v_self, PyObject *__pyx_v_filepath) {
-  PyObject *__pyx_r = NULL;
-  __Pyx_RefNannyDeclarations
-  PyObject *__pyx_t_1 = NULL;
-  PyObject *__pyx_t_2 = NULL;
-  PyObject *__pyx_t_3 = NULL;
-  std::string __pyx_t_4;
-  int __pyx_t_5;
-  int __pyx_t_6;
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("load", 0);
-  __Pyx_INCREF(__pyx_v_filepath);
-
-  /* "crf.pyx":167
- * 
- *     def load(self, filepath: Filepath):
- *         filepath = str(filepath)             # <<<<<<<<<<<<<<
- *         self.check_model(filepath)
- *         if not self._tagger.open(filepath):
- */
-  __pyx_t_1 = __Pyx_PyObject_CallOneArg(((PyObject *)(&PyString_Type)), __pyx_v_filepath); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 167, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __Pyx_DECREF_SET(__pyx_v_filepath, __pyx_t_1);
-  __pyx_t_1 = 0;
-
-  /* "crf.pyx":168
- *     def load(self, filepath: Filepath):
- *         filepath = str(filepath)
- *         self.check_model(filepath)             # <<<<<<<<<<<<<<
- *         if not self._tagger.open(filepath):
- *             raise ValueError(f"Cannot load model file {filepath}")
- */
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_check_model); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 168, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_3 = NULL;
-  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
-    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
-    if (likely(__pyx_t_3)) {
-      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
-      __Pyx_INCREF(__pyx_t_3);
-      __Pyx_INCREF(function);
-      __Pyx_DECREF_SET(__pyx_t_2, function);
-    }
-  }
-  __pyx_t_1 = (__pyx_t_3) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_3, __pyx_v_filepath) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_v_filepath);
-  __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
-  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 168, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-
-  /* "crf.pyx":169
- *         filepath = str(filepath)
- *         self.check_model(filepath)
- *         if not self._tagger.open(filepath):             # <<<<<<<<<<<<<<
- *             raise ValueError(f"Cannot load model file {filepath}")
- * 
- */
-  __pyx_t_4 = __pyx_convert_string_from_py_std__in_string(__pyx_v_filepath); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 169, __pyx_L1_error)
-  try {
-    __pyx_t_5 = __pyx_v_self->_tagger.open(__pyx_t_4);
-  } catch(...) {
-    __Pyx_CppExn2PyErr();
-    __PYX_ERR(0, 169, __pyx_L1_error)
-  }
-  __pyx_t_6 = ((!(__pyx_t_5 != 0)) != 0);
-  if (unlikely(__pyx_t_6)) {
-
-    /* "crf.pyx":170
- *         self.check_model(filepath)
- *         if not self._tagger.open(filepath):
- *             raise ValueError(f"Cannot load model file {filepath}")             # <<<<<<<<<<<<<<
- * 
- *     def marginal(self, label: str, index: int):
- */
-    __pyx_t_1 = __Pyx_PyObject_FormatSimple(__pyx_v_filepath, __pyx_empty_unicode); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 170, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_1);
-    __pyx_t_2 = __Pyx_PyUnicode_Concat(__pyx_kp_u_Cannot_load_model_file, __pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 170, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_2);
-    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-    __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 170, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_1);
-    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-    __Pyx_Raise(__pyx_t_1, 0, 0, 0);
-    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-    __PYX_ERR(0, 170, __pyx_L1_error)
-
-    /* "crf.pyx":169
- *         filepath = str(filepath)
- *         self.check_model(filepath)
- *         if not self._tagger.open(filepath):             # <<<<<<<<<<<<<<
- *             raise ValueError(f"Cannot load model file {filepath}")
- * 
- */
-  }
-
-  /* "crf.pyx":166
- *         ]
- * 
- *     def load(self, filepath: Filepath):             # <<<<<<<<<<<<<<
- *         filepath = str(filepath)
- *         self.check_model(filepath)
- */
-
-  /* function exit code */
-  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
-  goto __pyx_L0;
-  __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_1);
-  __Pyx_XDECREF(__pyx_t_2);
-  __Pyx_XDECREF(__pyx_t_3);
-  __Pyx_AddTraceback("crf.Model.load", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __pyx_r = NULL;
-  __pyx_L0:;
-  __Pyx_XDECREF(__pyx_v_filepath);
-  __Pyx_XGIVEREF(__pyx_r);
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-/* "crf.pyx":172
- *             raise ValueError(f"Cannot load model file {filepath}")
- * 
- *     def marginal(self, label: str, index: int):             # <<<<<<<<<<<<<<
- *         return self._tagger.marginal(label, index)
- * 
- */
-
-/* Python wrapper */
-static PyObject *__pyx_pw_3crf_5Model_9marginal(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
-static char __pyx_doc_3crf_5Model_8marginal[] = "Model.marginal(self, str label: str, index: int)";
-static PyObject *__pyx_pw_3crf_5Model_9marginal(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
-  PyObject *__pyx_v_label = 0;
-  PyObject *__pyx_v_index = 0;
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-  PyObject *__pyx_r = 0;
-  __Pyx_RefNannyDeclarations
-  __Pyx_RefNannySetupContext("marginal (wrapper)", 0);
-  {
-    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_label,&__pyx_n_s_index,0};
-    PyObject* values[2] = {0,0};
-    if (unlikely(__pyx_kwds)) {
-      Py_ssize_t kw_args;
-      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
-      switch (pos_args) {
-        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
-        CYTHON_FALLTHROUGH;
-        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
-        CYTHON_FALLTHROUGH;
-        case  0: break;
-        default: goto __pyx_L5_argtuple_error;
-      }
-      kw_args = PyDict_Size(__pyx_kwds);
-      switch (pos_args) {
-        case  0:
-        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_label)) != 0)) kw_args--;
-        else goto __pyx_L5_argtuple_error;
-        CYTHON_FALLTHROUGH;
-        case  1:
-        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_index)) != 0)) kw_args--;
-        else {
-          __Pyx_RaiseArgtupleInvalid("marginal", 1, 2, 2, 1); __PYX_ERR(0, 172, __pyx_L3_error)
-        }
-      }
-      if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "marginal") < 0)) __PYX_ERR(0, 172, __pyx_L3_error)
-      }
-    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
-      goto __pyx_L5_argtuple_error;
-    } else {
-      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
-      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
-    }
-    __pyx_v_label = ((PyObject*)values[0]);
-    __pyx_v_index = values[1];
-  }
-  goto __pyx_L4_argument_unpacking_done;
-  __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("marginal", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 172, __pyx_L3_error)
-  __pyx_L3_error:;
-  __Pyx_AddTraceback("crf.Model.marginal", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __Pyx_RefNannyFinishContext();
-  return NULL;
-  __pyx_L4_argument_unpacking_done:;
-  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_label), (&PyString_Type), 1, "label", 1))) __PYX_ERR(0, 172, __pyx_L1_error)
-  __pyx_r = __pyx_pf_3crf_5Model_8marginal(((struct __pyx_obj_3crf_Model *)__pyx_v_self), __pyx_v_label, __pyx_v_index);
-
-  /* function exit code */
-  goto __pyx_L0;
-  __pyx_L1_error:;
-  __pyx_r = NULL;
-  __pyx_L0:;
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-static PyObject *__pyx_pf_3crf_5Model_8marginal(struct __pyx_obj_3crf_Model *__pyx_v_self, PyObject *__pyx_v_label, PyObject *__pyx_v_index) {
-  PyObject *__pyx_r = NULL;
-  __Pyx_RefNannyDeclarations
-  std::string __pyx_t_1;
-  int __pyx_t_2;
-  double __pyx_t_3;
-  PyObject *__pyx_t_4 = NULL;
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("marginal", 0);
-
-  /* "crf.pyx":173
- * 
- *     def marginal(self, label: str, index: int):
- *         return self._tagger.marginal(label, index)             # <<<<<<<<<<<<<<
- * 
- *     cpdef set_sequence(self, sequence) except +:
- */
-  __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = __pyx_convert_string_from_py_std__in_string(__pyx_v_label); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 173, __pyx_L1_error)
-  __pyx_t_2 = __Pyx_PyInt_As_int(__pyx_v_index); if (unlikely((__pyx_t_2 == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 173, __pyx_L1_error)
-  try {
-    __pyx_t_3 = __pyx_v_self->_tagger.marginal(__pyx_t_1, __pyx_t_2);
-  } catch(...) {
-    __Pyx_CppExn2PyErr();
-    __PYX_ERR(0, 173, __pyx_L1_error)
-  }
-  __pyx_t_4 = PyFloat_FromDouble(__pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 173, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_4);
-  __pyx_r = __pyx_t_4;
-  __pyx_t_4 = 0;
-  goto __pyx_L0;
-
-  /* "crf.pyx":172
- *             raise ValueError(f"Cannot load model file {filepath}")
- * 
- *     def marginal(self, label: str, index: int):             # <<<<<<<<<<<<<<
- *         return self._tagger.marginal(label, index)
- * 
- */
-
-  /* function exit code */
-  __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_4);
-  __Pyx_AddTraceback("crf.Model.marginal", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __pyx_r = NULL;
-  __pyx_L0:;
-  __Pyx_XGIVEREF(__pyx_r);
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-/* "crf.pyx":175
- *         return self._tagger.marginal(label, index)
- * 
- *     cpdef set_sequence(self, sequence) except +:             # <<<<<<<<<<<<<<
- *         self._tagger.set(to_seq(sequence))
- * 
- */
-
-static PyObject *__pyx_pw_3crf_5Model_11set_sequence(PyObject *__pyx_v_self, PyObject *__pyx_v_sequence); /*proto*/
-static PyObject *__pyx_f_3crf_5Model_set_sequence(struct __pyx_obj_3crf_Model *__pyx_v_self, PyObject *__pyx_v_sequence, int __pyx_skip_dispatch) {
-  PyObject *__pyx_r = NULL;
-  __Pyx_RefNannyDeclarations
-  PyObject *__pyx_t_1 = NULL;
-  PyObject *__pyx_t_2 = NULL;
-  PyObject *__pyx_t_3 = NULL;
-  PyObject *__pyx_t_4 = NULL;
-  CRFSuite::ItemSequence __pyx_t_5;
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("set_sequence", 0);
-  /* Check if called by wrapper */
-  if (unlikely(__pyx_skip_dispatch)) ;
-  /* Check if overridden in Python */
-  else if (unlikely((Py_TYPE(((PyObject *)__pyx_v_self))->tp_dictoffset != 0) || (Py_TYPE(((PyObject *)__pyx_v_self))->tp_flags & (Py_TPFLAGS_IS_ABSTRACT | Py_TPFLAGS_HEAPTYPE)))) {
-    #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
-    static PY_UINT64_T __pyx_tp_dict_version = __PYX_DICT_VERSION_INIT, __pyx_obj_dict_version = __PYX_DICT_VERSION_INIT;
-    if (unlikely(!__Pyx_object_dict_version_matches(((PyObject *)__pyx_v_self), __pyx_tp_dict_version, __pyx_obj_dict_version))) {
-      PY_UINT64_T __pyx_type_dict_guard = __Pyx_get_tp_dict_version(((PyObject *)__pyx_v_self));
-      #endif
-      __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_set_sequence); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 175, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_1);
-      if (!PyCFunction_Check(__pyx_t_1) || (PyCFunction_GET_FUNCTION(__pyx_t_1) != (PyCFunction)(void*)__pyx_pw_3crf_5Model_11set_sequence)) {
-        __Pyx_XDECREF(__pyx_r);
-        __Pyx_INCREF(__pyx_t_1);
-        __pyx_t_3 = __pyx_t_1; __pyx_t_4 = NULL;
-        if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
-          __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
-          if (likely(__pyx_t_4)) {
-            PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
-            __Pyx_INCREF(__pyx_t_4);
-            __Pyx_INCREF(function);
-            __Pyx_DECREF_SET(__pyx_t_3, function);
-          }
-        }
-        __pyx_t_2 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_4, __pyx_v_sequence) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_v_sequence);
-        __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
-        if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 175, __pyx_L1_error)
-        __Pyx_GOTREF(__pyx_t_2);
-        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-        __pyx_r = __pyx_t_2;
-        __pyx_t_2 = 0;
-        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-        goto __pyx_L0;
-      }
-      #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
-      __pyx_tp_dict_version = __Pyx_get_tp_dict_version(((PyObject *)__pyx_v_self));
-      __pyx_obj_dict_version = __Pyx_get_object_dict_version(((PyObject *)__pyx_v_self));
-      if (unlikely(__pyx_type_dict_guard != __pyx_tp_dict_version)) {
-        __pyx_tp_dict_version = __pyx_obj_dict_version = __PYX_DICT_VERSION_INIT;
-      }
-      #endif
-      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-      #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
-    }
-    #endif
-  }
-
-  /* "crf.pyx":176
- * 
- *     cpdef set_sequence(self, sequence) except +:
- *         self._tagger.set(to_seq(sequence))             # <<<<<<<<<<<<<<
- * 
- *     @staticmethod
- */
-  try {
-    __pyx_t_5 = __pyx_f_3crf_to_seq(__pyx_v_sequence);
-  } catch(...) {
-    __Pyx_CppExn2PyErr();
-    __PYX_ERR(0, 176, __pyx_L1_error)
-  }
-  try {
-    __pyx_v_self->_tagger.set(__pyx_t_5);
-  } catch(...) {
-    __Pyx_CppExn2PyErr();
-    __PYX_ERR(0, 176, __pyx_L1_error)
-  }
-
-  /* "crf.pyx":175
- *         return self._tagger.marginal(label, index)
- * 
- *     cpdef set_sequence(self, sequence) except +:             # <<<<<<<<<<<<<<
- *         self._tagger.set(to_seq(sequence))
- * 
- */
-
-  /* function exit code */
-  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
-  goto __pyx_L0;
-  __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_1);
-  __Pyx_XDECREF(__pyx_t_2);
-  __Pyx_XDECREF(__pyx_t_3);
-  __Pyx_XDECREF(__pyx_t_4);
-  __Pyx_AddTraceback("crf.Model.set_sequence", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __pyx_r = 0;
-  __pyx_L0:;
-  __Pyx_XGIVEREF(__pyx_r);
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-/* Python wrapper */
-static PyObject *__pyx_pw_3crf_5Model_11set_sequence(PyObject *__pyx_v_self, PyObject *__pyx_v_sequence); /*proto*/
-static char __pyx_doc_3crf_5Model_10set_sequence[] = "Model.set_sequence(self, sequence)";
-static PyObject *__pyx_pw_3crf_5Model_11set_sequence(PyObject *__pyx_v_self, PyObject *__pyx_v_sequence) {
-  PyObject *__pyx_r = 0;
-  __Pyx_RefNannyDeclarations
-  __Pyx_RefNannySetupContext("set_sequence (wrapper)", 0);
-  __pyx_r = __pyx_pf_3crf_5Model_10set_sequence(((struct __pyx_obj_3crf_Model *)__pyx_v_self), ((PyObject *)__pyx_v_sequence));
-
-  /* function exit code */
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-static PyObject *__pyx_pf_3crf_5Model_10set_sequence(struct __pyx_obj_3crf_Model *__pyx_v_self, PyObject *__pyx_v_sequence) {
-  PyObject *__pyx_r = NULL;
-  __Pyx_RefNannyDeclarations
-  PyObject *__pyx_t_1 = NULL;
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("set_sequence", 0);
-  __Pyx_XDECREF(__pyx_r);
-  try {
-    __pyx_t_1 = __pyx_f_3crf_5Model_set_sequence(__pyx_v_self, __pyx_v_sequence, 1);
-    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 175, __pyx_L1_error)
-  } catch(...) {
-    __Pyx_CppExn2PyErr();
-    __PYX_ERR(0, 175, __pyx_L1_error)
-  }
-  __Pyx_GOTREF(__pyx_t_1);
-  __pyx_r = __pyx_t_1;
-  __pyx_t_1 = 0;
-  goto __pyx_L0;
-
-  /* function exit code */
-  __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_1);
-  __Pyx_AddTraceback("crf.Model.set_sequence", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __pyx_r = NULL;
-  __pyx_L0:;
-  __Pyx_XGIVEREF(__pyx_r);
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-/* "crf.pyx":179
- * 
- *     @staticmethod
- *     def check_model(filepath: str):             # <<<<<<<<<<<<<<
- *         with open(filepath, "rb") as model:
- *             magic = model.read(4)
- */
-
-/* Python wrapper */
-static PyObject *__pyx_pw_3crf_5Model_13check_model(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
-static char __pyx_doc_3crf_5Model_12check_model[] = "Model.check_model(str filepath: str)";
-static PyMethodDef __pyx_mdef_3crf_5Model_13check_model = {"check_model", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_3crf_5Model_13check_model, METH_VARARGS|METH_KEYWORDS, __pyx_doc_3crf_5Model_12check_model};
-static PyObject *__pyx_pw_3crf_5Model_13check_model(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
-  PyObject *__pyx_v_filepath = 0;
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-  PyObject *__pyx_r = 0;
-  __Pyx_RefNannyDeclarations
-  __Pyx_RefNannySetupContext("check_model (wrapper)", 0);
-  {
-    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_filepath,0};
-    PyObject* values[1] = {0};
-    if (unlikely(__pyx_kwds)) {
-      Py_ssize_t kw_args;
-      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
-      switch (pos_args) {
-        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
-        CYTHON_FALLTHROUGH;
-        case  0: break;
-        default: goto __pyx_L5_argtuple_error;
-      }
-      kw_args = PyDict_Size(__pyx_kwds);
-      switch (pos_args) {
-        case  0:
-        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_filepath)) != 0)) kw_args--;
-        else goto __pyx_L5_argtuple_error;
-      }
-      if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "check_model") < 0)) __PYX_ERR(0, 179, __pyx_L3_error)
-      }
-    } else if (PyTuple_GET_SIZE(__pyx_args) != 1) {
-      goto __pyx_L5_argtuple_error;
-    } else {
-      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
-    }
-    __pyx_v_filepath = ((PyObject*)values[0]);
-  }
-  goto __pyx_L4_argument_unpacking_done;
-  __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("check_model", 1, 1, 1, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 179, __pyx_L3_error)
-  __pyx_L3_error:;
-  __Pyx_AddTraceback("crf.Model.check_model", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __Pyx_RefNannyFinishContext();
-  return NULL;
-  __pyx_L4_argument_unpacking_done:;
-  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_filepath), (&PyString_Type), 1, "filepath", 1))) __PYX_ERR(0, 179, __pyx_L1_error)
-  __pyx_r = __pyx_pf_3crf_5Model_12check_model(__pyx_v_filepath);
-
-  /* function exit code */
-  goto __pyx_L0;
-  __pyx_L1_error:;
-  __pyx_r = NULL;
-  __pyx_L0:;
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-static PyObject *__pyx_pf_3crf_5Model_12check_model(PyObject *__pyx_v_filepath) {
-  PyObject *__pyx_v_model = NULL;
-  PyObject *__pyx_v_magic = NULL;
-  PyObject *__pyx_r = NULL;
-  __Pyx_RefNannyDeclarations
-  PyObject *__pyx_t_1 = NULL;
-  PyObject *__pyx_t_2 = NULL;
-  PyObject *__pyx_t_3 = NULL;
-  PyObject *__pyx_t_4 = NULL;
-  PyObject *__pyx_t_5 = NULL;
-  PyObject *__pyx_t_6 = NULL;
-  PyObject *__pyx_t_7 = NULL;
-  PyObject *__pyx_t_8 = NULL;
-  int __pyx_t_9;
-  int __pyx_t_10;
-  PyObject *__pyx_t_11 = NULL;
-  Py_ssize_t __pyx_t_12;
-  Py_UCS4 __pyx_t_13;
-  PyObject *__pyx_t_14 = NULL;
-  int __pyx_t_15;
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("check_model", 0);
-
-  /* "crf.pyx":180
- *     @staticmethod
- *     def check_model(filepath: str):
- *         with open(filepath, "rb") as model:             # <<<<<<<<<<<<<<
- *             magic = model.read(4)
- *             if magic != b"lCRF":
- */
-  /*with:*/ {
-    __pyx_t_1 = PyTuple_New(2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 180, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_1);
-    __Pyx_INCREF(__pyx_v_filepath);
-    __Pyx_GIVEREF(__pyx_v_filepath);
-    PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_v_filepath);
-    __Pyx_INCREF(__pyx_n_s_rb);
-    __Pyx_GIVEREF(__pyx_n_s_rb);
-    PyTuple_SET_ITEM(__pyx_t_1, 1, __pyx_n_s_rb);
-    __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_open, __pyx_t_1, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 180, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_2);
-    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-    __pyx_t_3 = __Pyx_PyObject_LookupSpecial(__pyx_t_2, __pyx_n_s_exit); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 180, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_3);
-    __pyx_t_4 = __Pyx_PyObject_LookupSpecial(__pyx_t_2, __pyx_n_s_enter); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 180, __pyx_L3_error)
-    __Pyx_GOTREF(__pyx_t_4);
-    __pyx_t_5 = NULL;
-    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_4))) {
-      __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_4);
-      if (likely(__pyx_t_5)) {
-        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
-        __Pyx_INCREF(__pyx_t_5);
-        __Pyx_INCREF(function);
-        __Pyx_DECREF_SET(__pyx_t_4, function);
-      }
-    }
-    __pyx_t_1 = (__pyx_t_5) ? __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_t_5) : __Pyx_PyObject_CallNoArg(__pyx_t_4);
-    __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
-    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 180, __pyx_L3_error)
-    __Pyx_GOTREF(__pyx_t_1);
-    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-    __pyx_t_4 = __pyx_t_1;
-    __pyx_t_1 = 0;
-    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-    /*try:*/ {
-      {
-        __Pyx_PyThreadState_declare
-        __Pyx_PyThreadState_assign
-        __Pyx_ExceptionSave(&__pyx_t_6, &__pyx_t_7, &__pyx_t_8);
-        __Pyx_XGOTREF(__pyx_t_6);
-        __Pyx_XGOTREF(__pyx_t_7);
-        __Pyx_XGOTREF(__pyx_t_8);
-        /*try:*/ {
-          __pyx_v_model = __pyx_t_4;
-          __pyx_t_4 = 0;
-
-          /* "crf.pyx":181
- *     def check_model(filepath: str):
- *         with open(filepath, "rb") as model:
- *             magic = model.read(4)             # <<<<<<<<<<<<<<
- *             if magic != b"lCRF":
- *                 raise ValueError(f"Invalid model file {filepath}")
- */
-          __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_model, __pyx_n_s_read); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 181, __pyx_L7_error)
-          __Pyx_GOTREF(__pyx_t_2);
-          __pyx_t_1 = NULL;
-          if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
-            __pyx_t_1 = PyMethod_GET_SELF(__pyx_t_2);
-            if (likely(__pyx_t_1)) {
-              PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
-              __Pyx_INCREF(__pyx_t_1);
-              __Pyx_INCREF(function);
-              __Pyx_DECREF_SET(__pyx_t_2, function);
-            }
-          }
-          __pyx_t_4 = (__pyx_t_1) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_1, __pyx_int_4) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_int_4);
-          __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
-          if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 181, __pyx_L7_error)
-          __Pyx_GOTREF(__pyx_t_4);
-          __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-          __pyx_v_magic = __pyx_t_4;
-          __pyx_t_4 = 0;
-
-          /* "crf.pyx":182
- *         with open(filepath, "rb") as model:
- *             magic = model.read(4)
- *             if magic != b"lCRF":             # <<<<<<<<<<<<<<
- *                 raise ValueError(f"Invalid model file {filepath}")
- *             model.seek(0, os.SEEK_END)
- */
-          __pyx_t_9 = (__Pyx_PyBytes_Equals(__pyx_v_magic, __pyx_n_b_lCRF, Py_NE)); if (unlikely(__pyx_t_9 < 0)) __PYX_ERR(0, 182, __pyx_L7_error)
-          if (unlikely(__pyx_t_9)) {
-
-            /* "crf.pyx":183
- *             magic = model.read(4)
- *             if magic != b"lCRF":
- *                 raise ValueError(f"Invalid model file {filepath}")             # <<<<<<<<<<<<<<
- *             model.seek(0, os.SEEK_END)
- *             if model.tell() <= 48:
- */
-            __pyx_t_4 = __Pyx_PyObject_FormatSimple(__pyx_v_filepath, __pyx_empty_unicode); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 183, __pyx_L7_error)
-            __Pyx_GOTREF(__pyx_t_4);
-            __pyx_t_2 = __Pyx_PyUnicode_Concat(__pyx_kp_u_Invalid_model_file, __pyx_t_4); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 183, __pyx_L7_error)
-            __Pyx_GOTREF(__pyx_t_2);
-            __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-            __pyx_t_4 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_2); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 183, __pyx_L7_error)
-            __Pyx_GOTREF(__pyx_t_4);
-            __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-            __Pyx_Raise(__pyx_t_4, 0, 0, 0);
-            __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-            __PYX_ERR(0, 183, __pyx_L7_error)
-
-            /* "crf.pyx":182
- *         with open(filepath, "rb") as model:
- *             magic = model.read(4)
- *             if magic != b"lCRF":             # <<<<<<<<<<<<<<
- *                 raise ValueError(f"Invalid model file {filepath}")
- *             model.seek(0, os.SEEK_END)
- */
-          }
-
-          /* "crf.pyx":184
- *             if magic != b"lCRF":
- *                 raise ValueError(f"Invalid model file {filepath}")
- *             model.seek(0, os.SEEK_END)             # <<<<<<<<<<<<<<
- *             if model.tell() <= 48:
- *                 raise ValueError(f"Model file {filepath} does not have a complete header")
- */
-          __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_model, __pyx_n_s_seek); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 184, __pyx_L7_error)
-          __Pyx_GOTREF(__pyx_t_2);
-          __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_os); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 184, __pyx_L7_error)
-          __Pyx_GOTREF(__pyx_t_1);
-          __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_SEEK_END); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 184, __pyx_L7_error)
-          __Pyx_GOTREF(__pyx_t_5);
-          __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-          __pyx_t_1 = NULL;
-          __pyx_t_10 = 0;
-          if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
-            __pyx_t_1 = PyMethod_GET_SELF(__pyx_t_2);
-            if (likely(__pyx_t_1)) {
-              PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
-              __Pyx_INCREF(__pyx_t_1);
-              __Pyx_INCREF(function);
-              __Pyx_DECREF_SET(__pyx_t_2, function);
-              __pyx_t_10 = 1;
-            }
-          }
-          #if CYTHON_FAST_PYCALL
-          if (PyFunction_Check(__pyx_t_2)) {
-            PyObject *__pyx_temp[3] = {__pyx_t_1, __pyx_int_0, __pyx_t_5};
-            __pyx_t_4 = __Pyx_PyFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_10, 2+__pyx_t_10); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 184, __pyx_L7_error)
-            __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
-            __Pyx_GOTREF(__pyx_t_4);
-            __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-          } else
-          #endif
-          #if CYTHON_FAST_PYCCALL
-          if (__Pyx_PyFastCFunction_Check(__pyx_t_2)) {
-            PyObject *__pyx_temp[3] = {__pyx_t_1, __pyx_int_0, __pyx_t_5};
-            __pyx_t_4 = __Pyx_PyCFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_10, 2+__pyx_t_10); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 184, __pyx_L7_error)
-            __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
-            __Pyx_GOTREF(__pyx_t_4);
-            __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-          } else
-          #endif
-          {
-            __pyx_t_11 = PyTuple_New(2+__pyx_t_10); if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 184, __pyx_L7_error)
-            __Pyx_GOTREF(__pyx_t_11);
-            if (__pyx_t_1) {
-              __Pyx_GIVEREF(__pyx_t_1); PyTuple_SET_ITEM(__pyx_t_11, 0, __pyx_t_1); __pyx_t_1 = NULL;
-            }
-            __Pyx_INCREF(__pyx_int_0);
-            __Pyx_GIVEREF(__pyx_int_0);
-            PyTuple_SET_ITEM(__pyx_t_11, 0+__pyx_t_10, __pyx_int_0);
-            __Pyx_GIVEREF(__pyx_t_5);
-            PyTuple_SET_ITEM(__pyx_t_11, 1+__pyx_t_10, __pyx_t_5);
-            __pyx_t_5 = 0;
-            __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_11, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 184, __pyx_L7_error)
-            __Pyx_GOTREF(__pyx_t_4);
-            __Pyx_DECREF(__pyx_t_11); __pyx_t_11 = 0;
-          }
-          __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-          __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-
-          /* "crf.pyx":185
- *                 raise ValueError(f"Invalid model file {filepath}")
- *             model.seek(0, os.SEEK_END)
- *             if model.tell() <= 48:             # <<<<<<<<<<<<<<
- *                 raise ValueError(f"Model file {filepath} does not have a complete header")
- * 
- */
-          __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_model, __pyx_n_s_tell); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 185, __pyx_L7_error)
-          __Pyx_GOTREF(__pyx_t_2);
-          __pyx_t_11 = NULL;
-          if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
-            __pyx_t_11 = PyMethod_GET_SELF(__pyx_t_2);
-            if (likely(__pyx_t_11)) {
-              PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
-              __Pyx_INCREF(__pyx_t_11);
-              __Pyx_INCREF(function);
-              __Pyx_DECREF_SET(__pyx_t_2, function);
-            }
-          }
-          __pyx_t_4 = (__pyx_t_11) ? __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_11) : __Pyx_PyObject_CallNoArg(__pyx_t_2);
-          __Pyx_XDECREF(__pyx_t_11); __pyx_t_11 = 0;
-          if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 185, __pyx_L7_error)
-          __Pyx_GOTREF(__pyx_t_4);
-          __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-          __pyx_t_2 = PyObject_RichCompare(__pyx_t_4, __pyx_int_48, Py_LE); __Pyx_XGOTREF(__pyx_t_2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 185, __pyx_L7_error)
-          __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-          __pyx_t_9 = __Pyx_PyObject_IsTrue(__pyx_t_2); if (unlikely(__pyx_t_9 < 0)) __PYX_ERR(0, 185, __pyx_L7_error)
-          __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-          if (unlikely(__pyx_t_9)) {
-
-            /* "crf.pyx":186
- *             model.seek(0, os.SEEK_END)
- *             if model.tell() <= 48:
- *                 raise ValueError(f"Model file {filepath} does not have a complete header")             # <<<<<<<<<<<<<<
- * 
- *     def dump_transitions(self, filepath: Filepath):
- */
-            __pyx_t_2 = PyTuple_New(3); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 186, __pyx_L7_error)
-            __Pyx_GOTREF(__pyx_t_2);
-            __pyx_t_12 = 0;
-            __pyx_t_13 = 127;
-            __Pyx_INCREF(__pyx_kp_u_Model_file);
-            __pyx_t_12 += 11;
-            __Pyx_GIVEREF(__pyx_kp_u_Model_file);
-            PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_kp_u_Model_file);
-            __pyx_t_4 = __Pyx_PyObject_FormatSimple(__pyx_v_filepath, __pyx_empty_unicode); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 186, __pyx_L7_error)
-            __Pyx_GOTREF(__pyx_t_4);
-            __pyx_t_13 = (__Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_4) > __pyx_t_13) ? __Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_4) : __pyx_t_13;
-            __pyx_t_12 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_4);
-            __Pyx_GIVEREF(__pyx_t_4);
-            PyTuple_SET_ITEM(__pyx_t_2, 1, __pyx_t_4);
-            __pyx_t_4 = 0;
-            __Pyx_INCREF(__pyx_kp_u_does_not_have_a_complete_header);
-            __pyx_t_12 += 32;
-            __Pyx_GIVEREF(__pyx_kp_u_does_not_have_a_complete_header);
-            PyTuple_SET_ITEM(__pyx_t_2, 2, __pyx_kp_u_does_not_have_a_complete_header);
-            __pyx_t_4 = __Pyx_PyUnicode_Join(__pyx_t_2, 3, __pyx_t_12, __pyx_t_13); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 186, __pyx_L7_error)
-            __Pyx_GOTREF(__pyx_t_4);
-            __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-            __pyx_t_2 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_4); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 186, __pyx_L7_error)
-            __Pyx_GOTREF(__pyx_t_2);
-            __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-            __Pyx_Raise(__pyx_t_2, 0, 0, 0);
-            __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-            __PYX_ERR(0, 186, __pyx_L7_error)
-
-            /* "crf.pyx":185
- *                 raise ValueError(f"Invalid model file {filepath}")
- *             model.seek(0, os.SEEK_END)
- *             if model.tell() <= 48:             # <<<<<<<<<<<<<<
- *                 raise ValueError(f"Model file {filepath} does not have a complete header")
- * 
- */
-          }
-
-          /* "crf.pyx":180
- *     @staticmethod
- *     def check_model(filepath: str):
- *         with open(filepath, "rb") as model:             # <<<<<<<<<<<<<<
- *             magic = model.read(4)
- *             if magic != b"lCRF":
- */
-        }
-        __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
-        __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
-        __Pyx_XDECREF(__pyx_t_8); __pyx_t_8 = 0;
-        goto __pyx_L12_try_end;
-        __pyx_L7_error:;
-        __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
-        __Pyx_XDECREF(__pyx_t_11); __pyx_t_11 = 0;
-        __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
-        __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
-        __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
-        /*except:*/ {
-          __Pyx_AddTraceback("crf.Model.check_model", __pyx_clineno, __pyx_lineno, __pyx_filename);
-          if (__Pyx_GetException(&__pyx_t_2, &__pyx_t_4, &__pyx_t_11) < 0) __PYX_ERR(0, 180, __pyx_L9_except_error)
-          __Pyx_GOTREF(__pyx_t_2);
-          __Pyx_GOTREF(__pyx_t_4);
-          __Pyx_GOTREF(__pyx_t_11);
-          __pyx_t_5 = PyTuple_Pack(3, __pyx_t_2, __pyx_t_4, __pyx_t_11); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 180, __pyx_L9_except_error)
-          __Pyx_GOTREF(__pyx_t_5);
-          __pyx_t_14 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_5, NULL);
-          __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-          __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-          if (unlikely(!__pyx_t_14)) __PYX_ERR(0, 180, __pyx_L9_except_error)
-          __Pyx_GOTREF(__pyx_t_14);
-          __pyx_t_9 = __Pyx_PyObject_IsTrue(__pyx_t_14);
-          __Pyx_DECREF(__pyx_t_14); __pyx_t_14 = 0;
-          if (__pyx_t_9 < 0) __PYX_ERR(0, 180, __pyx_L9_except_error)
-          __pyx_t_15 = ((!(__pyx_t_9 != 0)) != 0);
-          if (__pyx_t_15) {
-            __Pyx_GIVEREF(__pyx_t_2);
-            __Pyx_GIVEREF(__pyx_t_4);
-            __Pyx_XGIVEREF(__pyx_t_11);
-            __Pyx_ErrRestoreWithState(__pyx_t_2, __pyx_t_4, __pyx_t_11);
-            __pyx_t_2 = 0; __pyx_t_4 = 0; __pyx_t_11 = 0; 
-            __PYX_ERR(0, 180, __pyx_L9_except_error)
-          }
-          __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
-          __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
-          __Pyx_XDECREF(__pyx_t_11); __pyx_t_11 = 0;
-          goto __pyx_L8_exception_handled;
-        }
-        __pyx_L9_except_error:;
-        __Pyx_XGIVEREF(__pyx_t_6);
-        __Pyx_XGIVEREF(__pyx_t_7);
-        __Pyx_XGIVEREF(__pyx_t_8);
-        __Pyx_ExceptionReset(__pyx_t_6, __pyx_t_7, __pyx_t_8);
-        goto __pyx_L1_error;
-        __pyx_L8_exception_handled:;
-        __Pyx_XGIVEREF(__pyx_t_6);
-        __Pyx_XGIVEREF(__pyx_t_7);
-        __Pyx_XGIVEREF(__pyx_t_8);
-        __Pyx_ExceptionReset(__pyx_t_6, __pyx_t_7, __pyx_t_8);
-        __pyx_L12_try_end:;
-      }
-    }
-    /*finally:*/ {
-      /*normal exit:*/{
-        if (__pyx_t_3) {
-          __pyx_t_8 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_tuple__3, NULL);
-          __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-          if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 180, __pyx_L1_error)
-          __Pyx_GOTREF(__pyx_t_8);
-          __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
-        }
-        goto __pyx_L6;
-      }
-      __pyx_L6:;
-    }
-    goto __pyx_L18;
-    __pyx_L3_error:;
-    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-    goto __pyx_L1_error;
-    __pyx_L18:;
-  }
-
-  /* "crf.pyx":179
- * 
- *     @staticmethod
- *     def check_model(filepath: str):             # <<<<<<<<<<<<<<
- *         with open(filepath, "rb") as model:
- *             magic = model.read(4)
- */
-
-  /* function exit code */
-  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
-  goto __pyx_L0;
-  __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_1);
-  __Pyx_XDECREF(__pyx_t_2);
-  __Pyx_XDECREF(__pyx_t_4);
-  __Pyx_XDECREF(__pyx_t_5);
-  __Pyx_XDECREF(__pyx_t_11);
-  __Pyx_AddTraceback("crf.Model.check_model", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __pyx_r = NULL;
-  __pyx_L0:;
-  __Pyx_XDECREF(__pyx_v_model);
-  __Pyx_XDECREF(__pyx_v_magic);
-  __Pyx_XGIVEREF(__pyx_r);
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-/* "crf.pyx":188
- *                 raise ValueError(f"Model file {filepath} does not have a complete header")
- * 
- *     def dump_transitions(self, filepath: Filepath):             # <<<<<<<<<<<<<<
- *         self._tagger.dump_transitions(os.open(str(filepath), os.O_WRONLY | os.O_CREAT))
- * 
- */
-
-/* Python wrapper */
-static PyObject *__pyx_pw_3crf_5Model_15dump_transitions(PyObject *__pyx_v_self, PyObject *__pyx_v_filepath); /*proto*/
-static char __pyx_doc_3crf_5Model_14dump_transitions[] = "Model.dump_transitions(self, filepath: Filepath)";
-static PyObject *__pyx_pw_3crf_5Model_15dump_transitions(PyObject *__pyx_v_self, PyObject *__pyx_v_filepath) {
-  PyObject *__pyx_r = 0;
-  __Pyx_RefNannyDeclarations
-  __Pyx_RefNannySetupContext("dump_transitions (wrapper)", 0);
-  __pyx_r = __pyx_pf_3crf_5Model_14dump_transitions(((struct __pyx_obj_3crf_Model *)__pyx_v_self), ((PyObject *)__pyx_v_filepath));
-
-  /* function exit code */
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-static PyObject *__pyx_pf_3crf_5Model_14dump_transitions(struct __pyx_obj_3crf_Model *__pyx_v_self, PyObject *__pyx_v_filepath) {
-  PyObject *__pyx_r = NULL;
-  __Pyx_RefNannyDeclarations
-  PyObject *__pyx_t_1 = NULL;
-  PyObject *__pyx_t_2 = NULL;
-  PyObject *__pyx_t_3 = NULL;
-  PyObject *__pyx_t_4 = NULL;
-  PyObject *__pyx_t_5 = NULL;
-  PyObject *__pyx_t_6 = NULL;
-  int __pyx_t_7;
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("dump_transitions", 0);
-
-  /* "crf.pyx":189
- * 
- *     def dump_transitions(self, filepath: Filepath):
- *         self._tagger.dump_transitions(os.open(str(filepath), os.O_WRONLY | os.O_CREAT))             # <<<<<<<<<<<<<<
- * 
- *     def dump_states(self, filepath: Filepath):
- */
-  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_os); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 189, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_open); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 189, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_t_2 = __Pyx_PyObject_CallOneArg(((PyObject *)(&PyString_Type)), __pyx_v_filepath); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 189, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_os); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 189, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_4);
-  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_O_WRONLY); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 189, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_5);
-  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-  __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_os); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 189, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_4);
-  __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_O_CREAT); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 189, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_6);
-  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-  __pyx_t_4 = PyNumber_Or(__pyx_t_5, __pyx_t_6); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 189, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_4);
-  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-  __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
-  __pyx_t_6 = NULL;
-  __pyx_t_7 = 0;
-  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
-    __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_3);
-    if (likely(__pyx_t_6)) {
-      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
-      __Pyx_INCREF(__pyx_t_6);
-      __Pyx_INCREF(function);
-      __Pyx_DECREF_SET(__pyx_t_3, function);
-      __pyx_t_7 = 1;
-    }
-  }
-  #if CYTHON_FAST_PYCALL
-  if (PyFunction_Check(__pyx_t_3)) {
-    PyObject *__pyx_temp[3] = {__pyx_t_6, __pyx_t_2, __pyx_t_4};
-    __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_7, 2+__pyx_t_7); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 189, __pyx_L1_error)
-    __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
-    __Pyx_GOTREF(__pyx_t_1);
-    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-  } else
-  #endif
-  #if CYTHON_FAST_PYCCALL
-  if (__Pyx_PyFastCFunction_Check(__pyx_t_3)) {
-    PyObject *__pyx_temp[3] = {__pyx_t_6, __pyx_t_2, __pyx_t_4};
-    __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_7, 2+__pyx_t_7); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 189, __pyx_L1_error)
-    __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
-    __Pyx_GOTREF(__pyx_t_1);
-    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-  } else
-  #endif
-  {
-    __pyx_t_5 = PyTuple_New(2+__pyx_t_7); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 189, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_5);
-    if (__pyx_t_6) {
-      __Pyx_GIVEREF(__pyx_t_6); PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_6); __pyx_t_6 = NULL;
-    }
-    __Pyx_GIVEREF(__pyx_t_2);
-    PyTuple_SET_ITEM(__pyx_t_5, 0+__pyx_t_7, __pyx_t_2);
-    __Pyx_GIVEREF(__pyx_t_4);
-    PyTuple_SET_ITEM(__pyx_t_5, 1+__pyx_t_7, __pyx_t_4);
-    __pyx_t_2 = 0;
-    __pyx_t_4 = 0;
-    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_5, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 189, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_1);
-    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-  }
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  __pyx_t_7 = __Pyx_PyInt_As_int(__pyx_t_1); if (unlikely((__pyx_t_7 == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 189, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  try {
-    __pyx_v_self->_tagger.dump_transitions(__pyx_t_7);
-  } catch(...) {
-    __Pyx_CppExn2PyErr();
-    __PYX_ERR(0, 189, __pyx_L1_error)
-  }
-
-  /* "crf.pyx":188
- *                 raise ValueError(f"Model file {filepath} does not have a complete header")
- * 
- *     def dump_transitions(self, filepath: Filepath):             # <<<<<<<<<<<<<<
- *         self._tagger.dump_transitions(os.open(str(filepath), os.O_WRONLY | os.O_CREAT))
- * 
- */
-
-  /* function exit code */
-  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
-  goto __pyx_L0;
-  __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_1);
-  __Pyx_XDECREF(__pyx_t_2);
-  __Pyx_XDECREF(__pyx_t_3);
-  __Pyx_XDECREF(__pyx_t_4);
-  __Pyx_XDECREF(__pyx_t_5);
-  __Pyx_XDECREF(__pyx_t_6);
-  __Pyx_AddTraceback("crf.Model.dump_transitions", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __pyx_r = NULL;
-  __pyx_L0:;
-  __Pyx_XGIVEREF(__pyx_r);
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-/* "crf.pyx":191
- *         self._tagger.dump_transitions(os.open(str(filepath), os.O_WRONLY | os.O_CREAT))
- * 
- *     def dump_states(self, filepath: Filepath):             # <<<<<<<<<<<<<<
- *         self._tagger.dump_states(os.open(str(filepath), os.O_WRONLY | os.O_CREAT))
- * 
- */
-
-/* Python wrapper */
-static PyObject *__pyx_pw_3crf_5Model_17dump_states(PyObject *__pyx_v_self, PyObject *__pyx_v_filepath); /*proto*/
-static char __pyx_doc_3crf_5Model_16dump_states[] = "Model.dump_states(self, filepath: Filepath)";
-static PyObject *__pyx_pw_3crf_5Model_17dump_states(PyObject *__pyx_v_self, PyObject *__pyx_v_filepath) {
-  PyObject *__pyx_r = 0;
-  __Pyx_RefNannyDeclarations
-  __Pyx_RefNannySetupContext("dump_states (wrapper)", 0);
-  __pyx_r = __pyx_pf_3crf_5Model_16dump_states(((struct __pyx_obj_3crf_Model *)__pyx_v_self), ((PyObject *)__pyx_v_filepath));
-
-  /* function exit code */
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-static PyObject *__pyx_pf_3crf_5Model_16dump_states(struct __pyx_obj_3crf_Model *__pyx_v_self, PyObject *__pyx_v_filepath) {
-  PyObject *__pyx_r = NULL;
-  __Pyx_RefNannyDeclarations
-  PyObject *__pyx_t_1 = NULL;
-  PyObject *__pyx_t_2 = NULL;
-  PyObject *__pyx_t_3 = NULL;
-  PyObject *__pyx_t_4 = NULL;
-  PyObject *__pyx_t_5 = NULL;
-  PyObject *__pyx_t_6 = NULL;
-  int __pyx_t_7;
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("dump_states", 0);
-
-  /* "crf.pyx":192
- * 
- *     def dump_states(self, filepath: Filepath):
- *         self._tagger.dump_states(os.open(str(filepath), os.O_WRONLY | os.O_CREAT))             # <<<<<<<<<<<<<<
- * 
- * cdef crfsuite_api.Item to_item(sequence) except+:
- */
-  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_os); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 192, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_open); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 192, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_t_2 = __Pyx_PyObject_CallOneArg(((PyObject *)(&PyString_Type)), __pyx_v_filepath); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 192, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_os); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 192, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_4);
-  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_O_WRONLY); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 192, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_5);
-  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-  __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_os); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 192, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_4);
-  __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_O_CREAT); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 192, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_6);
-  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-  __pyx_t_4 = PyNumber_Or(__pyx_t_5, __pyx_t_6); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 192, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_4);
-  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-  __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
-  __pyx_t_6 = NULL;
-  __pyx_t_7 = 0;
-  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
-    __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_3);
-    if (likely(__pyx_t_6)) {
-      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
-      __Pyx_INCREF(__pyx_t_6);
-      __Pyx_INCREF(function);
-      __Pyx_DECREF_SET(__pyx_t_3, function);
-      __pyx_t_7 = 1;
-    }
-  }
-  #if CYTHON_FAST_PYCALL
-  if (PyFunction_Check(__pyx_t_3)) {
-    PyObject *__pyx_temp[3] = {__pyx_t_6, __pyx_t_2, __pyx_t_4};
-    __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_7, 2+__pyx_t_7); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 192, __pyx_L1_error)
-    __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
-    __Pyx_GOTREF(__pyx_t_1);
-    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-  } else
-  #endif
-  #if CYTHON_FAST_PYCCALL
-  if (__Pyx_PyFastCFunction_Check(__pyx_t_3)) {
-    PyObject *__pyx_temp[3] = {__pyx_t_6, __pyx_t_2, __pyx_t_4};
-    __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_7, 2+__pyx_t_7); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 192, __pyx_L1_error)
-    __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
-    __Pyx_GOTREF(__pyx_t_1);
-    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-  } else
-  #endif
-  {
-    __pyx_t_5 = PyTuple_New(2+__pyx_t_7); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 192, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_5);
-    if (__pyx_t_6) {
-      __Pyx_GIVEREF(__pyx_t_6); PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_6); __pyx_t_6 = NULL;
-    }
-    __Pyx_GIVEREF(__pyx_t_2);
-    PyTuple_SET_ITEM(__pyx_t_5, 0+__pyx_t_7, __pyx_t_2);
-    __Pyx_GIVEREF(__pyx_t_4);
-    PyTuple_SET_ITEM(__pyx_t_5, 1+__pyx_t_7, __pyx_t_4);
-    __pyx_t_2 = 0;
-    __pyx_t_4 = 0;
-    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_5, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 192, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_1);
-    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-  }
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  __pyx_t_7 = __Pyx_PyInt_As_int(__pyx_t_1); if (unlikely((__pyx_t_7 == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 192, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  try {
-    __pyx_v_self->_tagger.dump_states(__pyx_t_7);
-  } catch(...) {
-    __Pyx_CppExn2PyErr();
-    __PYX_ERR(0, 192, __pyx_L1_error)
-  }
-
-  /* "crf.pyx":191
- *         self._tagger.dump_transitions(os.open(str(filepath), os.O_WRONLY | os.O_CREAT))
- * 
- *     def dump_states(self, filepath: Filepath):             # <<<<<<<<<<<<<<
- *         self._tagger.dump_states(os.open(str(filepath), os.O_WRONLY | os.O_CREAT))
- * 
- */
-
-  /* function exit code */
-  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
-  goto __pyx_L0;
-  __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_1);
-  __Pyx_XDECREF(__pyx_t_2);
-  __Pyx_XDECREF(__pyx_t_3);
-  __Pyx_XDECREF(__pyx_t_4);
-  __Pyx_XDECREF(__pyx_t_5);
-  __Pyx_XDECREF(__pyx_t_6);
-  __Pyx_AddTraceback("crf.Model.dump_states", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __pyx_r = NULL;
-  __pyx_L0:;
-  __Pyx_XGIVEREF(__pyx_r);
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-/* "(tree fragment)":1
- * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
- *     raise TypeError("self._tagger cannot be converted to a Python object for pickling")
- * def __setstate_cython__(self, __pyx_state):
- */
-
-/* Python wrapper */
-static PyObject *__pyx_pw_3crf_5Model_19__reduce_cython__(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
-static char __pyx_doc_3crf_5Model_18__reduce_cython__[] = "Model.__reduce_cython__(self)";
-static PyObject *__pyx_pw_3crf_5Model_19__reduce_cython__(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
-  PyObject *__pyx_r = 0;
-  __Pyx_RefNannyDeclarations
-  __Pyx_RefNannySetupContext("__reduce_cython__ (wrapper)", 0);
-  __pyx_r = __pyx_pf_3crf_5Model_18__reduce_cython__(((struct __pyx_obj_3crf_Model *)__pyx_v_self));
-
-  /* function exit code */
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-static PyObject *__pyx_pf_3crf_5Model_18__reduce_cython__(CYTHON_UNUSED struct __pyx_obj_3crf_Model *__pyx_v_self) {
-  PyObject *__pyx_r = NULL;
-  __Pyx_RefNannyDeclarations
-  PyObject *__pyx_t_1 = NULL;
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("__reduce_cython__", 0);
-
-  /* "(tree fragment)":2
- * def __reduce_cython__(self):
- *     raise TypeError("self._tagger cannot be converted to a Python object for pickling")             # <<<<<<<<<<<<<<
- * def __setstate_cython__(self, __pyx_state):
- *     raise TypeError("self._tagger cannot be converted to a Python object for pickling")
- */
-  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__4, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 2, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __Pyx_Raise(__pyx_t_1, 0, 0, 0);
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __PYX_ERR(1, 2, __pyx_L1_error)
-
-  /* "(tree fragment)":1
- * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
- *     raise TypeError("self._tagger cannot be converted to a Python object for pickling")
- * def __setstate_cython__(self, __pyx_state):
- */
-
-  /* function exit code */
-  __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_1);
-  __Pyx_AddTraceback("crf.Model.__reduce_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __pyx_r = NULL;
-  __Pyx_XGIVEREF(__pyx_r);
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-/* "(tree fragment)":3
- * def __reduce_cython__(self):
- *     raise TypeError("self._tagger cannot be converted to a Python object for pickling")
- * def __setstate_cython__(self, __pyx_state):             # <<<<<<<<<<<<<<
- *     raise TypeError("self._tagger cannot be converted to a Python object for pickling")
- */
-
-/* Python wrapper */
-static PyObject *__pyx_pw_3crf_5Model_21__setstate_cython__(PyObject *__pyx_v_self, PyObject *__pyx_v___pyx_state); /*proto*/
-static char __pyx_doc_3crf_5Model_20__setstate_cython__[] = "Model.__setstate_cython__(self, __pyx_state)";
-static PyObject *__pyx_pw_3crf_5Model_21__setstate_cython__(PyObject *__pyx_v_self, PyObject *__pyx_v___pyx_state) {
-  PyObject *__pyx_r = 0;
-  __Pyx_RefNannyDeclarations
-  __Pyx_RefNannySetupContext("__setstate_cython__ (wrapper)", 0);
-  __pyx_r = __pyx_pf_3crf_5Model_20__setstate_cython__(((struct __pyx_obj_3crf_Model *)__pyx_v_self), ((PyObject *)__pyx_v___pyx_state));
-
-  /* function exit code */
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-static PyObject *__pyx_pf_3crf_5Model_20__setstate_cython__(CYTHON_UNUSED struct __pyx_obj_3crf_Model *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v___pyx_state) {
-  PyObject *__pyx_r = NULL;
-  __Pyx_RefNannyDeclarations
-  PyObject *__pyx_t_1 = NULL;
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("__setstate_cython__", 0);
-
-  /* "(tree fragment)":4
- *     raise TypeError("self._tagger cannot be converted to a Python object for pickling")
- * def __setstate_cython__(self, __pyx_state):
- *     raise TypeError("self._tagger cannot be converted to a Python object for pickling")             # <<<<<<<<<<<<<<
- */
-  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__5, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 4, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __Pyx_Raise(__pyx_t_1, 0, 0, 0);
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __PYX_ERR(1, 4, __pyx_L1_error)
-
-  /* "(tree fragment)":3
- * def __reduce_cython__(self):
- *     raise TypeError("self._tagger cannot be converted to a Python object for pickling")
- * def __setstate_cython__(self, __pyx_state):             # <<<<<<<<<<<<<<
- *     raise TypeError("self._tagger cannot be converted to a Python object for pickling")
- */
-
-  /* function exit code */
-  __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_1);
-  __Pyx_AddTraceback("crf.Model.__setstate_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __pyx_r = NULL;
-  __Pyx_XGIVEREF(__pyx_r);
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-/* "crf.pyx":194
- *         self._tagger.dump_states(os.open(str(filepath), os.O_WRONLY | os.O_CREAT))
- * 
- * cdef crfsuite_api.Item to_item(sequence) except+:             # <<<<<<<<<<<<<<
- *     cdef crfsuite_api.Item c_item
- *     cdef double c_value
- */
-
-static CRFSuite::Item __pyx_f_3crf_to_item(PyObject *__pyx_v_sequence) {
-  CRFSuite::Item __pyx_v_c_item;
-  double __pyx_v_c_value;
-  std::string __pyx_v_c_token;
-  std::string __pyx_v_separator;
-  int __pyx_v_is_dict;
-  PyObject *__pyx_v_token = NULL;
-  PyObject *__pyx_v_value = NULL;
-  CRFSuite::Attribute __pyx_v_attr;
-  CRFSuite::Item __pyx_r;
-  __Pyx_RefNannyDeclarations
-  std::string __pyx_t_1;
-  int __pyx_t_2;
-  CRFSuite::Item __pyx_t_3;
-  Py_ssize_t __pyx_t_4;
-  PyObject *__pyx_t_5 = NULL;
-  PyObject *(*__pyx_t_6)(PyObject *);
-  PyObject *__pyx_t_7 = NULL;
-  int __pyx_t_8;
-  int __pyx_t_9;
-  std::vector<CRFSuite::Attribute> ::iterator __pyx_t_10;
-  CRFSuite::Item *__pyx_t_11;
-  CRFSuite::Attribute __pyx_t_12;
-  std::string __pyx_t_13;
-  double __pyx_t_14;
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("to_item", 0);
-
-  /* "crf.pyx":201
- *     cdef bint is_dict, is_nested_value
- * 
- *     separator = b":"             # <<<<<<<<<<<<<<
- *     is_dict = isinstance(sequence, dict)
- *     c_item = crfsuite_api.Item()
- */
-  __pyx_t_1 = __pyx_convert_string_from_py_std__in_string(__pyx_kp_b__6); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 201, __pyx_L1_error)
-  __pyx_v_separator = __pyx_t_1;
-
-  /* "crf.pyx":202
- * 
- *     separator = b":"
- *     is_dict = isinstance(sequence, dict)             # <<<<<<<<<<<<<<
- *     c_item = crfsuite_api.Item()
- *     c_item.reserve(len(sequence))
- */
-  __pyx_t_2 = PyDict_Check(__pyx_v_sequence); 
-  __pyx_v_is_dict = __pyx_t_2;
-
-  /* "crf.pyx":203
- *     separator = b":"
- *     is_dict = isinstance(sequence, dict)
- *     c_item = crfsuite_api.Item()             # <<<<<<<<<<<<<<
- *     c_item.reserve(len(sequence))
- * 
- */
-  try {
-    __pyx_t_3 = CRFSuite::Item();
-  } catch(...) {
-    __Pyx_CppExn2PyErr();
-    __PYX_ERR(0, 203, __pyx_L1_error)
-  }
-  __pyx_v_c_item = __pyx_t_3;
-
-  /* "crf.pyx":204
- *     is_dict = isinstance(sequence, dict)
- *     c_item = crfsuite_api.Item()
- *     c_item.reserve(len(sequence))             # <<<<<<<<<<<<<<
- * 
- *     for token in sequence:
- */
-  __pyx_t_4 = PyObject_Length(__pyx_v_sequence); if (unlikely(__pyx_t_4 == ((Py_ssize_t)-1))) __PYX_ERR(0, 204, __pyx_L1_error)
-  __pyx_v_c_item.reserve(__pyx_t_4);
-
-  /* "crf.pyx":206
- *     c_item.reserve(len(sequence))
- * 
- *     for token in sequence:             # <<<<<<<<<<<<<<
- *         if isinstance(token, unicode):
- *             c_token = (<unicode>token).encode("utf8")
- */
-  if (likely(PyList_CheckExact(__pyx_v_sequence)) || PyTuple_CheckExact(__pyx_v_sequence)) {
-    __pyx_t_5 = __pyx_v_sequence; __Pyx_INCREF(__pyx_t_5); __pyx_t_4 = 0;
-    __pyx_t_6 = NULL;
-  } else {
-    __pyx_t_4 = -1; __pyx_t_5 = PyObject_GetIter(__pyx_v_sequence); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 206, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_5);
-    __pyx_t_6 = Py_TYPE(__pyx_t_5)->tp_iternext; if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 206, __pyx_L1_error)
-  }
-  for (;;) {
-    if (likely(!__pyx_t_6)) {
-      if (likely(PyList_CheckExact(__pyx_t_5))) {
-        if (__pyx_t_4 >= PyList_GET_SIZE(__pyx_t_5)) break;
-        #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-        __pyx_t_7 = PyList_GET_ITEM(__pyx_t_5, __pyx_t_4); __Pyx_INCREF(__pyx_t_7); __pyx_t_4++; if (unlikely(0 < 0)) __PYX_ERR(0, 206, __pyx_L1_error)
-        #else
-        __pyx_t_7 = PySequence_ITEM(__pyx_t_5, __pyx_t_4); __pyx_t_4++; if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 206, __pyx_L1_error)
-        __Pyx_GOTREF(__pyx_t_7);
-        #endif
-      } else {
-        if (__pyx_t_4 >= PyTuple_GET_SIZE(__pyx_t_5)) break;
-        #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-        __pyx_t_7 = PyTuple_GET_ITEM(__pyx_t_5, __pyx_t_4); __Pyx_INCREF(__pyx_t_7); __pyx_t_4++; if (unlikely(0 < 0)) __PYX_ERR(0, 206, __pyx_L1_error)
-        #else
-        __pyx_t_7 = PySequence_ITEM(__pyx_t_5, __pyx_t_4); __pyx_t_4++; if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 206, __pyx_L1_error)
-        __Pyx_GOTREF(__pyx_t_7);
-        #endif
-      }
-    } else {
-      __pyx_t_7 = __pyx_t_6(__pyx_t_5);
-      if (unlikely(!__pyx_t_7)) {
-        PyObject* exc_type = PyErr_Occurred();
-        if (exc_type) {
-          if (likely(__Pyx_PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
-          else __PYX_ERR(0, 206, __pyx_L1_error)
-        }
-        break;
-      }
-      __Pyx_GOTREF(__pyx_t_7);
-    }
-    __Pyx_XDECREF_SET(__pyx_v_token, __pyx_t_7);
-    __pyx_t_7 = 0;
-
-    /* "crf.pyx":207
- * 
- *     for token in sequence:
- *         if isinstance(token, unicode):             # <<<<<<<<<<<<<<
- *             c_token = (<unicode>token).encode("utf8")
- *         else:
- */
-    __pyx_t_2 = PyUnicode_Check(__pyx_v_token); 
-    __pyx_t_8 = (__pyx_t_2 != 0);
-    if (__pyx_t_8) {
-
-      /* "crf.pyx":208
- *     for token in sequence:
- *         if isinstance(token, unicode):
- *             c_token = (<unicode>token).encode("utf8")             # <<<<<<<<<<<<<<
- *         else:
- *             c_token = token
- */
-      if (unlikely(__pyx_v_token == Py_None)) {
-        PyErr_Format(PyExc_AttributeError, "'NoneType' object has no attribute '%.30s'", "encode");
-        __PYX_ERR(0, 208, __pyx_L1_error)
-      }
-      __pyx_t_7 = PyUnicode_AsUTF8String(((PyObject*)__pyx_v_token)); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 208, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_7);
-      __pyx_t_1 = __pyx_convert_string_from_py_std__in_string(__pyx_t_7); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 208, __pyx_L1_error)
-      __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
-      __pyx_v_c_token = __pyx_t_1;
-
-      /* "crf.pyx":207
- * 
- *     for token in sequence:
- *         if isinstance(token, unicode):             # <<<<<<<<<<<<<<
- *             c_token = (<unicode>token).encode("utf8")
- *         else:
- */
-      goto __pyx_L5;
-    }
-
-    /* "crf.pyx":210
- *             c_token = (<unicode>token).encode("utf8")
- *         else:
- *             c_token = token             # <<<<<<<<<<<<<<
- *         if not is_dict:
- *             c_value = 1.0
- */
-    /*else*/ {
-      __pyx_t_1 = __pyx_convert_string_from_py_std__in_string(__pyx_v_token); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 210, __pyx_L1_error)
-      __pyx_v_c_token = __pyx_t_1;
-    }
-    __pyx_L5:;
-
-    /* "crf.pyx":211
- *         else:
- *             c_token = token
- *         if not is_dict:             # <<<<<<<<<<<<<<
- *             c_value = 1.0
- *             c_item.push_back(crfsuite_api.Attribute(c_token, c_value))
- */
-    __pyx_t_8 = ((!(__pyx_v_is_dict != 0)) != 0);
-    if (__pyx_t_8) {
-
-      /* "crf.pyx":212
- *             c_token = token
- *         if not is_dict:
- *             c_value = 1.0             # <<<<<<<<<<<<<<
- *             c_item.push_back(crfsuite_api.Attribute(c_token, c_value))
- *         else:
- */
-      __pyx_v_c_value = 1.0;
-
-      /* "crf.pyx":213
- *         if not is_dict:
- *             c_value = 1.0
- *             c_item.push_back(crfsuite_api.Attribute(c_token, c_value))             # <<<<<<<<<<<<<<
- *         else:
- *             value = (<dict>sequence)[token]
- */
-      try {
-        __pyx_v_c_item.push_back(CRFSuite::Attribute(__pyx_v_c_token, __pyx_v_c_value));
-      } catch(...) {
-        __Pyx_CppExn2PyErr();
-        __PYX_ERR(0, 213, __pyx_L1_error)
-      }
-
-      /* "crf.pyx":211
- *         else:
- *             c_token = token
- *         if not is_dict:             # <<<<<<<<<<<<<<
- *             c_value = 1.0
- *             c_item.push_back(crfsuite_api.Attribute(c_token, c_value))
- */
-      goto __pyx_L6;
-    }
-
-    /* "crf.pyx":215
- *             c_item.push_back(crfsuite_api.Attribute(c_token, c_value))
- *         else:
- *             value = (<dict>sequence)[token]             # <<<<<<<<<<<<<<
- *             if isinstance(value, (dict, list, set)):
- *                 for attr in to_item(value):
- */
-    /*else*/ {
-      if (unlikely(__pyx_v_sequence == Py_None)) {
-        PyErr_SetString(PyExc_TypeError, "'NoneType' object is not subscriptable");
-        __PYX_ERR(0, 215, __pyx_L1_error)
-      }
-      __pyx_t_7 = __Pyx_PyDict_GetItem(((PyObject*)__pyx_v_sequence), __pyx_v_token); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 215, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_7);
-      __Pyx_XDECREF_SET(__pyx_v_value, __pyx_t_7);
-      __pyx_t_7 = 0;
-
-      /* "crf.pyx":216
- *         else:
- *             value = (<dict>sequence)[token]
- *             if isinstance(value, (dict, list, set)):             # <<<<<<<<<<<<<<
- *                 for attr in to_item(value):
- *                     c_item.push_back(
- */
-      __pyx_t_2 = PyDict_Check(__pyx_v_value); 
-      __pyx_t_9 = (__pyx_t_2 != 0);
-      if (!__pyx_t_9) {
-      } else {
-        __pyx_t_8 = __pyx_t_9;
-        goto __pyx_L8_bool_binop_done;
-      }
-      __pyx_t_9 = PyList_Check(__pyx_v_value); 
-      __pyx_t_2 = (__pyx_t_9 != 0);
-      if (!__pyx_t_2) {
-      } else {
-        __pyx_t_8 = __pyx_t_2;
-        goto __pyx_L8_bool_binop_done;
-      }
-      __pyx_t_2 = PySet_Check(__pyx_v_value); 
-      __pyx_t_9 = (__pyx_t_2 != 0);
-      __pyx_t_8 = __pyx_t_9;
-      __pyx_L8_bool_binop_done:;
-      __pyx_t_9 = (__pyx_t_8 != 0);
-      if (__pyx_t_9) {
-
-        /* "crf.pyx":217
- *             value = (<dict>sequence)[token]
- *             if isinstance(value, (dict, list, set)):
- *                 for attr in to_item(value):             # <<<<<<<<<<<<<<
- *                     c_item.push_back(
- *                         crfsuite_api.Attribute(c_token + separator + attr.attr, attr.value)
- */
-        try {
-          __pyx_t_3 = __pyx_f_3crf_to_item(__pyx_v_value);
-        } catch(...) {
-          __Pyx_CppExn2PyErr();
-          __PYX_ERR(0, 217, __pyx_L1_error)
-        }
-        __pyx_t_11 = &__pyx_t_3;
-        __pyx_t_10 = __pyx_t_11->begin();
-        for (;;) {
-          if (!(__pyx_t_10 != __pyx_t_11->end())) break;
-          __pyx_t_12 = *__pyx_t_10;
-          ++__pyx_t_10;
-          __pyx_v_attr = __pyx_t_12;
-
-          /* "crf.pyx":219
- *                 for attr in to_item(value):
- *                     c_item.push_back(
- *                         crfsuite_api.Attribute(c_token + separator + attr.attr, attr.value)             # <<<<<<<<<<<<<<
- *                     )
- *             else:
- */
-          try {
-            __pyx_t_1 = (__pyx_v_c_token + __pyx_v_separator);
-          } catch(...) {
-            __Pyx_CppExn2PyErr();
-            __PYX_ERR(0, 219, __pyx_L1_error)
-          }
-          try {
-            __pyx_t_13 = (__pyx_t_1 + __pyx_v_attr.attr);
-          } catch(...) {
-            __Pyx_CppExn2PyErr();
-            __PYX_ERR(0, 219, __pyx_L1_error)
-          }
-
-          /* "crf.pyx":218
- *             if isinstance(value, (dict, list, set)):
- *                 for attr in to_item(value):
- *                     c_item.push_back(             # <<<<<<<<<<<<<<
- *                         crfsuite_api.Attribute(c_token + separator + attr.attr, attr.value)
- *                     )
- */
-          try {
-            __pyx_v_c_item.push_back(CRFSuite::Attribute(__pyx_t_13, __pyx_v_attr.value));
-          } catch(...) {
-            __Pyx_CppExn2PyErr();
-            __PYX_ERR(0, 218, __pyx_L1_error)
-          }
-
-          /* "crf.pyx":217
- *             value = (<dict>sequence)[token]
- *             if isinstance(value, (dict, list, set)):
- *                 for attr in to_item(value):             # <<<<<<<<<<<<<<
- *                     c_item.push_back(
- *                         crfsuite_api.Attribute(c_token + separator + attr.attr, attr.value)
- */
-        }
-
-        /* "crf.pyx":216
- *         else:
- *             value = (<dict>sequence)[token]
- *             if isinstance(value, (dict, list, set)):             # <<<<<<<<<<<<<<
- *                 for attr in to_item(value):
- *                     c_item.push_back(
- */
-        goto __pyx_L7;
-      }
-
-      /* "crf.pyx":222
- *                     )
- *             else:
- *                 if isinstance(value, unicode):             # <<<<<<<<<<<<<<
- *                     c_token += separator
- *                     c_token += <string>(<unicode>value).encode("utf8")
- */
-      /*else*/ {
-        __pyx_t_9 = PyUnicode_Check(__pyx_v_value); 
-        __pyx_t_8 = (__pyx_t_9 != 0);
-        if (__pyx_t_8) {
-
-          /* "crf.pyx":223
- *             else:
- *                 if isinstance(value, unicode):
- *                     c_token += separator             # <<<<<<<<<<<<<<
- *                     c_token += <string>(<unicode>value).encode("utf8")
- *                     c_value = 1.0
- */
-          __pyx_v_c_token += __pyx_v_separator;
-
-          /* "crf.pyx":224
- *                 if isinstance(value, unicode):
- *                     c_token += separator
- *                     c_token += <string>(<unicode>value).encode("utf8")             # <<<<<<<<<<<<<<
- *                     c_value = 1.0
- *                 elif isinstance(value, bytes):
- */
-          if (unlikely(__pyx_v_value == Py_None)) {
-            PyErr_Format(PyExc_AttributeError, "'NoneType' object has no attribute '%.30s'", "encode");
-            __PYX_ERR(0, 224, __pyx_L1_error)
-          }
-          __pyx_t_7 = PyUnicode_AsUTF8String(((PyObject*)__pyx_v_value)); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 224, __pyx_L1_error)
-          __Pyx_GOTREF(__pyx_t_7);
-          __pyx_t_13 = __pyx_convert_string_from_py_std__in_string(__pyx_t_7); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 224, __pyx_L1_error)
-          __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
-          __pyx_v_c_token += ((std::string)__pyx_t_13);
-
-          /* "crf.pyx":225
- *                     c_token += separator
- *                     c_token += <string>(<unicode>value).encode("utf8")
- *                     c_value = 1.0             # <<<<<<<<<<<<<<
- *                 elif isinstance(value, bytes):
- *                     c_token += separator
- */
-          __pyx_v_c_value = 1.0;
-
-          /* "crf.pyx":222
- *                     )
- *             else:
- *                 if isinstance(value, unicode):             # <<<<<<<<<<<<<<
- *                     c_token += separator
- *                     c_token += <string>(<unicode>value).encode("utf8")
- */
-          goto __pyx_L13;
-        }
-
-        /* "crf.pyx":226
- *                     c_token += <string>(<unicode>value).encode("utf8")
- *                     c_value = 1.0
- *                 elif isinstance(value, bytes):             # <<<<<<<<<<<<<<
- *                     c_token += separator
- *                     c_token += <string>value
- */
-        __pyx_t_8 = PyBytes_Check(__pyx_v_value); 
-        __pyx_t_9 = (__pyx_t_8 != 0);
-        if (__pyx_t_9) {
-
-          /* "crf.pyx":227
- *                     c_value = 1.0
- *                 elif isinstance(value, bytes):
- *                     c_token += separator             # <<<<<<<<<<<<<<
- *                     c_token += <string>value
- *                     c_value = 1.0
- */
-          __pyx_v_c_token += __pyx_v_separator;
-
-          /* "crf.pyx":228
- *                 elif isinstance(value, bytes):
- *                     c_token += separator
- *                     c_token += <string>value             # <<<<<<<<<<<<<<
- *                     c_value = 1.0
- *                 else:
- */
-          __pyx_t_13 = __pyx_convert_string_from_py_std__in_string(__pyx_v_value); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 228, __pyx_L1_error)
-          __pyx_v_c_token += ((std::string)__pyx_t_13);
-
-          /* "crf.pyx":229
- *                     c_token += separator
- *                     c_token += <string>value
- *                     c_value = 1.0             # <<<<<<<<<<<<<<
- *                 else:
- *                     c_value = value
- */
-          __pyx_v_c_value = 1.0;
-
-          /* "crf.pyx":226
- *                     c_token += <string>(<unicode>value).encode("utf8")
- *                     c_value = 1.0
- *                 elif isinstance(value, bytes):             # <<<<<<<<<<<<<<
- *                     c_token += separator
- *                     c_token += <string>value
- */
-          goto __pyx_L13;
-        }
-
-        /* "crf.pyx":231
- *                     c_value = 1.0
- *                 else:
- *                     c_value = value             # <<<<<<<<<<<<<<
- *                 c_item.push_back(crfsuite_api.Attribute(c_token, c_value))
- *     return c_item
- */
-        /*else*/ {
-          __pyx_t_14 = __pyx_PyFloat_AsDouble(__pyx_v_value); if (unlikely((__pyx_t_14 == (double)-1) && PyErr_Occurred())) __PYX_ERR(0, 231, __pyx_L1_error)
-          __pyx_v_c_value = __pyx_t_14;
-        }
-        __pyx_L13:;
-
-        /* "crf.pyx":232
- *                 else:
- *                     c_value = value
- *                 c_item.push_back(crfsuite_api.Attribute(c_token, c_value))             # <<<<<<<<<<<<<<
- *     return c_item
- * 
- */
-        try {
-          __pyx_v_c_item.push_back(CRFSuite::Attribute(__pyx_v_c_token, __pyx_v_c_value));
-        } catch(...) {
-          __Pyx_CppExn2PyErr();
-          __PYX_ERR(0, 232, __pyx_L1_error)
-        }
-      }
-      __pyx_L7:;
-    }
-    __pyx_L6:;
-
-    /* "crf.pyx":206
- *     c_item.reserve(len(sequence))
- * 
- *     for token in sequence:             # <<<<<<<<<<<<<<
- *         if isinstance(token, unicode):
- *             c_token = (<unicode>token).encode("utf8")
- */
-  }
-  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-
-  /* "crf.pyx":233
- *                     c_value = value
- *                 c_item.push_back(crfsuite_api.Attribute(c_token, c_value))
- *     return c_item             # <<<<<<<<<<<<<<
- * 
- * 
- */
-  __pyx_r = __pyx_v_c_item;
-  goto __pyx_L0;
-
-  /* "crf.pyx":194
- *         self._tagger.dump_states(os.open(str(filepath), os.O_WRONLY | os.O_CREAT))
- * 
- * cdef crfsuite_api.Item to_item(sequence) except+:             # <<<<<<<<<<<<<<
- *     cdef crfsuite_api.Item c_item
- *     cdef double c_value
- */
-
-  /* function exit code */
-  __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_5);
-  __Pyx_XDECREF(__pyx_t_7);
-  __Pyx_AddTraceback("crf.to_item", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __Pyx_pretend_to_initialize(&__pyx_r);
-  __pyx_L0:;
-  __Pyx_XDECREF(__pyx_v_token);
-  __Pyx_XDECREF(__pyx_v_value);
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-/* "crf.pyx":236
- * 
- * 
- * cdef crfsuite_api.ItemSequence to_seq(sequence) except+:             # <<<<<<<<<<<<<<
- *     cdef crfsuite_api.ItemSequence c_sequence
- * 
- */
-
-static CRFSuite::ItemSequence __pyx_f_3crf_to_seq(PyObject *__pyx_v_sequence) {
-  CRFSuite::ItemSequence __pyx_v_c_sequence;
-  PyObject *__pyx_v_s = NULL;
-  CRFSuite::ItemSequence __pyx_r;
-  __Pyx_RefNannyDeclarations
-  int __pyx_t_1;
-  int __pyx_t_2;
-  CRFSuite::ItemSequence __pyx_t_3;
-  PyObject *__pyx_t_4 = NULL;
-  Py_ssize_t __pyx_t_5;
-  PyObject *(*__pyx_t_6)(PyObject *);
-  PyObject *__pyx_t_7 = NULL;
-  CRFSuite::Item __pyx_t_8;
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("to_seq", 0);
-
-  /* "crf.pyx":239
- *     cdef crfsuite_api.ItemSequence c_sequence
- * 
- *     if isinstance(sequence, ItemSequence):             # <<<<<<<<<<<<<<
- *         c_sequence = (<ItemSequence>sequence).c_sequence
- *     else:
- */
-  __pyx_t_1 = __Pyx_TypeCheck(__pyx_v_sequence, __pyx_ptype_3crf_ItemSequence); 
-  __pyx_t_2 = (__pyx_t_1 != 0);
-  if (__pyx_t_2) {
-
-    /* "crf.pyx":240
- * 
- *     if isinstance(sequence, ItemSequence):
- *         c_sequence = (<ItemSequence>sequence).c_sequence             # <<<<<<<<<<<<<<
- *     else:
- *         for s in sequence:
- */
-    __pyx_t_3 = ((struct __pyx_obj_3crf_ItemSequence *)__pyx_v_sequence)->c_sequence;
-    __pyx_v_c_sequence = __pyx_t_3;
-
-    /* "crf.pyx":239
- *     cdef crfsuite_api.ItemSequence c_sequence
- * 
- *     if isinstance(sequence, ItemSequence):             # <<<<<<<<<<<<<<
- *         c_sequence = (<ItemSequence>sequence).c_sequence
- *     else:
- */
-    goto __pyx_L3;
-  }
-
-  /* "crf.pyx":242
- *         c_sequence = (<ItemSequence>sequence).c_sequence
- *     else:
- *         for s in sequence:             # <<<<<<<<<<<<<<
- *             c_sequence.push_back(to_item(s))
- *     return c_sequence
- */
-  /*else*/ {
-    if (likely(PyList_CheckExact(__pyx_v_sequence)) || PyTuple_CheckExact(__pyx_v_sequence)) {
-      __pyx_t_4 = __pyx_v_sequence; __Pyx_INCREF(__pyx_t_4); __pyx_t_5 = 0;
-      __pyx_t_6 = NULL;
-    } else {
-      __pyx_t_5 = -1; __pyx_t_4 = PyObject_GetIter(__pyx_v_sequence); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 242, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_4);
-      __pyx_t_6 = Py_TYPE(__pyx_t_4)->tp_iternext; if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 242, __pyx_L1_error)
-    }
-    for (;;) {
-      if (likely(!__pyx_t_6)) {
-        if (likely(PyList_CheckExact(__pyx_t_4))) {
-          if (__pyx_t_5 >= PyList_GET_SIZE(__pyx_t_4)) break;
-          #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-          __pyx_t_7 = PyList_GET_ITEM(__pyx_t_4, __pyx_t_5); __Pyx_INCREF(__pyx_t_7); __pyx_t_5++; if (unlikely(0 < 0)) __PYX_ERR(0, 242, __pyx_L1_error)
-          #else
-          __pyx_t_7 = PySequence_ITEM(__pyx_t_4, __pyx_t_5); __pyx_t_5++; if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 242, __pyx_L1_error)
-          __Pyx_GOTREF(__pyx_t_7);
-          #endif
-        } else {
-          if (__pyx_t_5 >= PyTuple_GET_SIZE(__pyx_t_4)) break;
-          #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-          __pyx_t_7 = PyTuple_GET_ITEM(__pyx_t_4, __pyx_t_5); __Pyx_INCREF(__pyx_t_7); __pyx_t_5++; if (unlikely(0 < 0)) __PYX_ERR(0, 242, __pyx_L1_error)
-          #else
-          __pyx_t_7 = PySequence_ITEM(__pyx_t_4, __pyx_t_5); __pyx_t_5++; if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 242, __pyx_L1_error)
-          __Pyx_GOTREF(__pyx_t_7);
-          #endif
-        }
-      } else {
-        __pyx_t_7 = __pyx_t_6(__pyx_t_4);
-        if (unlikely(!__pyx_t_7)) {
-          PyObject* exc_type = PyErr_Occurred();
-          if (exc_type) {
-            if (likely(__Pyx_PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
-            else __PYX_ERR(0, 242, __pyx_L1_error)
-          }
-          break;
-        }
-        __Pyx_GOTREF(__pyx_t_7);
-      }
-      __Pyx_XDECREF_SET(__pyx_v_s, __pyx_t_7);
-      __pyx_t_7 = 0;
-
-      /* "crf.pyx":243
- *     else:
- *         for s in sequence:
- *             c_sequence.push_back(to_item(s))             # <<<<<<<<<<<<<<
- *     return c_sequence
- * 
- */
-      try {
-        __pyx_t_8 = __pyx_f_3crf_to_item(__pyx_v_s);
-      } catch(...) {
-        __Pyx_CppExn2PyErr();
-        __PYX_ERR(0, 243, __pyx_L1_error)
-      }
-      try {
-        __pyx_v_c_sequence.push_back(__pyx_t_8);
-      } catch(...) {
-        __Pyx_CppExn2PyErr();
-        __PYX_ERR(0, 243, __pyx_L1_error)
-      }
-
-      /* "crf.pyx":242
- *         c_sequence = (<ItemSequence>sequence).c_sequence
- *     else:
- *         for s in sequence:             # <<<<<<<<<<<<<<
- *             c_sequence.push_back(to_item(s))
- *     return c_sequence
- */
-    }
-    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-  }
-  __pyx_L3:;
-
-  /* "crf.pyx":244
- *         for s in sequence:
- *             c_sequence.push_back(to_item(s))
- *     return c_sequence             # <<<<<<<<<<<<<<
- * 
- * 
- */
-  __pyx_r = __pyx_v_c_sequence;
-  goto __pyx_L0;
-
-  /* "crf.pyx":236
- * 
- * 
- * cdef crfsuite_api.ItemSequence to_seq(sequence) except+:             # <<<<<<<<<<<<<<
- *     cdef crfsuite_api.ItemSequence c_sequence
- * 
- */
-
-  /* function exit code */
-  __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_4);
-  __Pyx_XDECREF(__pyx_t_7);
-  __Pyx_AddTraceback("crf.to_seq", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __Pyx_pretend_to_initialize(&__pyx_r);
-  __pyx_L0:;
-  __Pyx_XDECREF(__pyx_v_s);
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-/* "crf.pyx":250
- *     cdef crfsuite_api.ItemSequence c_sequence
- * 
- *     def __init__(self, sequence):             # <<<<<<<<<<<<<<
- *         self.c_sequence = to_seq(sequence)
- * 
- */
-
-/* Python wrapper */
-static int __pyx_pw_3crf_12ItemSequence_1__init__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
-static int __pyx_pw_3crf_12ItemSequence_1__init__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
-  PyObject *__pyx_v_sequence = 0;
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-  int __pyx_r;
-  __Pyx_RefNannyDeclarations
-  __Pyx_RefNannySetupContext("__init__ (wrapper)", 0);
-  {
-    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_sequence,0};
-    PyObject* values[1] = {0};
-    if (unlikely(__pyx_kwds)) {
-      Py_ssize_t kw_args;
-      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
-      switch (pos_args) {
-        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
-        CYTHON_FALLTHROUGH;
-        case  0: break;
-        default: goto __pyx_L5_argtuple_error;
-      }
-      kw_args = PyDict_Size(__pyx_kwds);
-      switch (pos_args) {
-        case  0:
-        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_sequence)) != 0)) kw_args--;
-        else goto __pyx_L5_argtuple_error;
-      }
-      if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__init__") < 0)) __PYX_ERR(0, 250, __pyx_L3_error)
-      }
-    } else if (PyTuple_GET_SIZE(__pyx_args) != 1) {
-      goto __pyx_L5_argtuple_error;
-    } else {
-      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
-    }
-    __pyx_v_sequence = values[0];
-  }
-  goto __pyx_L4_argument_unpacking_done;
-  __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("__init__", 1, 1, 1, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 250, __pyx_L3_error)
-  __pyx_L3_error:;
-  __Pyx_AddTraceback("crf.ItemSequence.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __Pyx_RefNannyFinishContext();
-  return -1;
-  __pyx_L4_argument_unpacking_done:;
-  __pyx_r = __pyx_pf_3crf_12ItemSequence___init__(((struct __pyx_obj_3crf_ItemSequence *)__pyx_v_self), __pyx_v_sequence);
-
-  /* function exit code */
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-static int __pyx_pf_3crf_12ItemSequence___init__(struct __pyx_obj_3crf_ItemSequence *__pyx_v_self, PyObject *__pyx_v_sequence) {
-  int __pyx_r;
-  __Pyx_RefNannyDeclarations
-  CRFSuite::ItemSequence __pyx_t_1;
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("__init__", 0);
-
-  /* "crf.pyx":251
- * 
- *     def __init__(self, sequence):
- *         self.c_sequence = to_seq(sequence)             # <<<<<<<<<<<<<<
- * 
- *     def items(self):
- */
-  try {
-    __pyx_t_1 = __pyx_f_3crf_to_seq(__pyx_v_sequence);
-  } catch(...) {
-    __Pyx_CppExn2PyErr();
-    __PYX_ERR(0, 251, __pyx_L1_error)
-  }
-  __pyx_v_self->c_sequence = __pyx_t_1;
-
-  /* "crf.pyx":250
- *     cdef crfsuite_api.ItemSequence c_sequence
- * 
- *     def __init__(self, sequence):             # <<<<<<<<<<<<<<
- *         self.c_sequence = to_seq(sequence)
- * 
- */
-
-  /* function exit code */
-  __pyx_r = 0;
-  goto __pyx_L0;
-  __pyx_L1_error:;
-  __Pyx_AddTraceback("crf.ItemSequence.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __pyx_r = -1;
-  __pyx_L0:;
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-/* "crf.pyx":253
- *         self.c_sequence = to_seq(sequence)
- * 
- *     def items(self):             # <<<<<<<<<<<<<<
- *         cdef crfsuite_api.Item c_item
- *         cdef crfsuite_api.Attribute c_attr
- */
-
-/* Python wrapper */
-static PyObject *__pyx_pw_3crf_12ItemSequence_3items(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
-static char __pyx_doc_3crf_12ItemSequence_2items[] = "ItemSequence.items(self)";
-static PyObject *__pyx_pw_3crf_12ItemSequence_3items(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
-  PyObject *__pyx_r = 0;
-  __Pyx_RefNannyDeclarations
-  __Pyx_RefNannySetupContext("items (wrapper)", 0);
-  __pyx_r = __pyx_pf_3crf_12ItemSequence_2items(((struct __pyx_obj_3crf_ItemSequence *)__pyx_v_self));
-
-  /* function exit code */
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-static PyObject *__pyx_pf_3crf_12ItemSequence_2items(struct __pyx_obj_3crf_ItemSequence *__pyx_v_self) {
-  CRFSuite::Item __pyx_v_c_item;
-  CRFSuite::Attribute __pyx_v_c_attr;
-  PyObject *__pyx_v_token = 0;
-  PyObject *__pyx_v_sequence = NULL;
-  PyObject *__pyx_v_x = NULL;
-  PyObject *__pyx_r = NULL;
-  __Pyx_RefNannyDeclarations
-  PyObject *__pyx_t_1 = NULL;
-  std::vector<CRFSuite::Item> ::iterator __pyx_t_2;
-  CRFSuite::ItemSequence *__pyx_t_3;
-  CRFSuite::Item __pyx_t_4;
-  std::vector<CRFSuite::Attribute> ::iterator __pyx_t_5;
-  CRFSuite::Attribute __pyx_t_6;
-  PyObject *__pyx_t_7 = NULL;
-  int __pyx_t_8;
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("items", 0);
-
-  /* "crf.pyx":258
- *         cdef bytes token
- * 
- *         sequence = []             # <<<<<<<<<<<<<<
- *         for c_item in self.c_sequence:
- *             x = {}
- */
-  __pyx_t_1 = PyList_New(0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 258, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __pyx_v_sequence = ((PyObject*)__pyx_t_1);
-  __pyx_t_1 = 0;
-
-  /* "crf.pyx":259
- * 
- *         sequence = []
- *         for c_item in self.c_sequence:             # <<<<<<<<<<<<<<
- *             x = {}
- *             for c_attr in c_item:
- */
-  __pyx_t_3 = &__pyx_v_self->c_sequence;
-  __pyx_t_2 = __pyx_t_3->begin();
-  for (;;) {
-    if (!(__pyx_t_2 != __pyx_t_3->end())) break;
-    __pyx_t_4 = *__pyx_t_2;
-    ++__pyx_t_2;
-    __pyx_v_c_item = __pyx_t_4;
-
-    /* "crf.pyx":260
- *         sequence = []
- *         for c_item in self.c_sequence:
- *             x = {}             # <<<<<<<<<<<<<<
- *             for c_attr in c_item:
- *                 token = <bytes>c_attr.attr.c_str()
- */
-    __pyx_t_1 = __Pyx_PyDict_NewPresized(0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 260, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_1);
-    __Pyx_XDECREF_SET(__pyx_v_x, ((PyObject*)__pyx_t_1));
-    __pyx_t_1 = 0;
-
-    /* "crf.pyx":261
- *         for c_item in self.c_sequence:
- *             x = {}
- *             for c_attr in c_item:             # <<<<<<<<<<<<<<
- *                 token = <bytes>c_attr.attr.c_str()
- *                 x[token.decode("utf8")] = c_attr.value
- */
-    __pyx_t_5 = __pyx_v_c_item.begin();
-    for (;;) {
-      if (!(__pyx_t_5 != __pyx_v_c_item.end())) break;
-      __pyx_t_6 = *__pyx_t_5;
-      ++__pyx_t_5;
-      __pyx_v_c_attr = __pyx_t_6;
-
-      /* "crf.pyx":262
- *             x = {}
- *             for c_attr in c_item:
- *                 token = <bytes>c_attr.attr.c_str()             # <<<<<<<<<<<<<<
- *                 x[token.decode("utf8")] = c_attr.value
- *             sequence.append(x)
- */
-      __pyx_t_1 = __Pyx_PyBytes_FromString(__pyx_v_c_attr.attr.c_str()); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 262, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_1);
-      __pyx_t_7 = __pyx_t_1;
-      __Pyx_INCREF(__pyx_t_7);
-      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-      __Pyx_XDECREF_SET(__pyx_v_token, ((PyObject*)__pyx_t_7));
-      __pyx_t_7 = 0;
-
-      /* "crf.pyx":263
- *             for c_attr in c_item:
- *                 token = <bytes>c_attr.attr.c_str()
- *                 x[token.decode("utf8")] = c_attr.value             # <<<<<<<<<<<<<<
- *             sequence.append(x)
- *         return sequence
- */
-      __pyx_t_7 = PyFloat_FromDouble(__pyx_v_c_attr.value); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 263, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_7);
-      if (unlikely(__pyx_v_token == Py_None)) {
-        PyErr_Format(PyExc_AttributeError, "'NoneType' object has no attribute '%.30s'", "decode");
-        __PYX_ERR(0, 263, __pyx_L1_error)
-      }
-      __pyx_t_1 = __Pyx_decode_bytes(__pyx_v_token, 0, PY_SSIZE_T_MAX, NULL, NULL, PyUnicode_DecodeUTF8); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 263, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_1);
-      if (unlikely(PyDict_SetItem(__pyx_v_x, __pyx_t_1, __pyx_t_7) < 0)) __PYX_ERR(0, 263, __pyx_L1_error)
-      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-      __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
-
-      /* "crf.pyx":261
- *         for c_item in self.c_sequence:
- *             x = {}
- *             for c_attr in c_item:             # <<<<<<<<<<<<<<
- *                 token = <bytes>c_attr.attr.c_str()
- *                 x[token.decode("utf8")] = c_attr.value
- */
-    }
-
-    /* "crf.pyx":264
- *                 token = <bytes>c_attr.attr.c_str()
- *                 x[token.decode("utf8")] = c_attr.value
- *             sequence.append(x)             # <<<<<<<<<<<<<<
- *         return sequence
- * 
- */
-    __pyx_t_8 = __Pyx_PyList_Append(__pyx_v_sequence, __pyx_v_x); if (unlikely(__pyx_t_8 == ((int)-1))) __PYX_ERR(0, 264, __pyx_L1_error)
-
-    /* "crf.pyx":259
- * 
- *         sequence = []
- *         for c_item in self.c_sequence:             # <<<<<<<<<<<<<<
- *             x = {}
- *             for c_attr in c_item:
- */
-  }
-
-  /* "crf.pyx":265
- *                 x[token.decode("utf8")] = c_attr.value
- *             sequence.append(x)
- *         return sequence             # <<<<<<<<<<<<<<
- * 
- *     def __len__(self):
- */
-  __Pyx_XDECREF(__pyx_r);
-  __Pyx_INCREF(__pyx_v_sequence);
-  __pyx_r = __pyx_v_sequence;
-  goto __pyx_L0;
-
-  /* "crf.pyx":253
- *         self.c_sequence = to_seq(sequence)
- * 
- *     def items(self):             # <<<<<<<<<<<<<<
- *         cdef crfsuite_api.Item c_item
- *         cdef crfsuite_api.Attribute c_attr
- */
-
-  /* function exit code */
-  __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_1);
-  __Pyx_XDECREF(__pyx_t_7);
-  __Pyx_AddTraceback("crf.ItemSequence.items", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __pyx_r = NULL;
-  __pyx_L0:;
-  __Pyx_XDECREF(__pyx_v_token);
-  __Pyx_XDECREF(__pyx_v_sequence);
-  __Pyx_XDECREF(__pyx_v_x);
-  __Pyx_XGIVEREF(__pyx_r);
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-/* "crf.pyx":267
- *         return sequence
- * 
- *     def __len__(self):             # <<<<<<<<<<<<<<
- *         return self.c_sequence.size()
- * 
- */
-
-/* Python wrapper */
-static Py_ssize_t __pyx_pw_3crf_12ItemSequence_5__len__(PyObject *__pyx_v_self); /*proto*/
-static Py_ssize_t __pyx_pw_3crf_12ItemSequence_5__len__(PyObject *__pyx_v_self) {
-  Py_ssize_t __pyx_r;
-  __Pyx_RefNannyDeclarations
-  __Pyx_RefNannySetupContext("__len__ (wrapper)", 0);
-  __pyx_r = __pyx_pf_3crf_12ItemSequence_4__len__(((struct __pyx_obj_3crf_ItemSequence *)__pyx_v_self));
-
-  /* function exit code */
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-static Py_ssize_t __pyx_pf_3crf_12ItemSequence_4__len__(struct __pyx_obj_3crf_ItemSequence *__pyx_v_self) {
-  Py_ssize_t __pyx_r;
-  __Pyx_RefNannyDeclarations
-  __Pyx_RefNannySetupContext("__len__", 0);
-
-  /* "crf.pyx":268
- * 
- *     def __len__(self):
- *         return self.c_sequence.size()             # <<<<<<<<<<<<<<
- * 
- *     def __repr__(self):
- */
-  __pyx_r = __pyx_v_self->c_sequence.size();
-  goto __pyx_L0;
-
-  /* "crf.pyx":267
- *         return sequence
- * 
- *     def __len__(self):             # <<<<<<<<<<<<<<
- *         return self.c_sequence.size()
- * 
- */
-
-  /* function exit code */
-  __pyx_L0:;
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-/* "crf.pyx":270
- *         return self.c_sequence.size()
- * 
- *     def __repr__(self):             # <<<<<<<<<<<<<<
- *         return f"<ItemSequence ({len(self)})>"
- */
-
-/* Python wrapper */
-static PyObject *__pyx_pw_3crf_12ItemSequence_7__repr__(PyObject *__pyx_v_self); /*proto*/
-static PyObject *__pyx_pw_3crf_12ItemSequence_7__repr__(PyObject *__pyx_v_self) {
-  PyObject *__pyx_r = 0;
-  __Pyx_RefNannyDeclarations
-  __Pyx_RefNannySetupContext("__repr__ (wrapper)", 0);
-  __pyx_r = __pyx_pf_3crf_12ItemSequence_6__repr__(((struct __pyx_obj_3crf_ItemSequence *)__pyx_v_self));
-
-  /* function exit code */
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-static PyObject *__pyx_pf_3crf_12ItemSequence_6__repr__(struct __pyx_obj_3crf_ItemSequence *__pyx_v_self) {
-  PyObject *__pyx_r = NULL;
-  __Pyx_RefNannyDeclarations
-  PyObject *__pyx_t_1 = NULL;
-  Py_ssize_t __pyx_t_2;
-  Py_UCS4 __pyx_t_3;
-  Py_ssize_t __pyx_t_4;
-  PyObject *__pyx_t_5 = NULL;
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("__repr__", 0);
-
-  /* "crf.pyx":271
- * 
- *     def __repr__(self):
- *         return f"<ItemSequence ({len(self)})>"             # <<<<<<<<<<<<<<
- */
-  __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = PyTuple_New(3); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 271, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = 0;
-  __pyx_t_3 = 127;
-  __Pyx_INCREF(__pyx_kp_u_ItemSequence);
-  __pyx_t_2 += 15;
-  __Pyx_GIVEREF(__pyx_kp_u_ItemSequence);
-  PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_kp_u_ItemSequence);
-  __pyx_t_4 = PyObject_Length(((PyObject *)__pyx_v_self)); if (unlikely(__pyx_t_4 == ((Py_ssize_t)-1))) __PYX_ERR(0, 271, __pyx_L1_error)
-  __pyx_t_5 = __Pyx_PyUnicode_From_Py_ssize_t(__pyx_t_4, 0, ' ', 'd'); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 271, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_5);
-  __pyx_t_2 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_5);
-  __Pyx_GIVEREF(__pyx_t_5);
-  PyTuple_SET_ITEM(__pyx_t_1, 1, __pyx_t_5);
-  __pyx_t_5 = 0;
-  __Pyx_INCREF(__pyx_kp_u__7);
-  __pyx_t_2 += 2;
-  __Pyx_GIVEREF(__pyx_kp_u__7);
-  PyTuple_SET_ITEM(__pyx_t_1, 2, __pyx_kp_u__7);
-  __pyx_t_5 = __Pyx_PyUnicode_Join(__pyx_t_1, 3, __pyx_t_2, __pyx_t_3); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 271, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_5);
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_r = __pyx_t_5;
-  __pyx_t_5 = 0;
-  goto __pyx_L0;
-
-  /* "crf.pyx":270
- *         return self.c_sequence.size()
- * 
- *     def __repr__(self):             # <<<<<<<<<<<<<<
- *         return f"<ItemSequence ({len(self)})>"
- */
-
-  /* function exit code */
-  __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_1);
-  __Pyx_XDECREF(__pyx_t_5);
-  __Pyx_AddTraceback("crf.ItemSequence.__repr__", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __pyx_r = NULL;
-  __pyx_L0:;
-  __Pyx_XGIVEREF(__pyx_r);
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-/* "(tree fragment)":1
- * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
- *     raise TypeError("self.c_sequence cannot be converted to a Python object for pickling")
- * def __setstate_cython__(self, __pyx_state):
- */
-
-/* Python wrapper */
-static PyObject *__pyx_pw_3crf_12ItemSequence_9__reduce_cython__(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
-static char __pyx_doc_3crf_12ItemSequence_8__reduce_cython__[] = "ItemSequence.__reduce_cython__(self)";
-static PyObject *__pyx_pw_3crf_12ItemSequence_9__reduce_cython__(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
-  PyObject *__pyx_r = 0;
-  __Pyx_RefNannyDeclarations
-  __Pyx_RefNannySetupContext("__reduce_cython__ (wrapper)", 0);
-  __pyx_r = __pyx_pf_3crf_12ItemSequence_8__reduce_cython__(((struct __pyx_obj_3crf_ItemSequence *)__pyx_v_self));
-
-  /* function exit code */
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-static PyObject *__pyx_pf_3crf_12ItemSequence_8__reduce_cython__(CYTHON_UNUSED struct __pyx_obj_3crf_ItemSequence *__pyx_v_self) {
-  PyObject *__pyx_r = NULL;
-  __Pyx_RefNannyDeclarations
-  PyObject *__pyx_t_1 = NULL;
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("__reduce_cython__", 0);
-
-  /* "(tree fragment)":2
- * def __reduce_cython__(self):
- *     raise TypeError("self.c_sequence cannot be converted to a Python object for pickling")             # <<<<<<<<<<<<<<
- * def __setstate_cython__(self, __pyx_state):
- *     raise TypeError("self.c_sequence cannot be converted to a Python object for pickling")
- */
-  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__8, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 2, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __Pyx_Raise(__pyx_t_1, 0, 0, 0);
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __PYX_ERR(1, 2, __pyx_L1_error)
-
-  /* "(tree fragment)":1
- * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
- *     raise TypeError("self.c_sequence cannot be converted to a Python object for pickling")
- * def __setstate_cython__(self, __pyx_state):
- */
-
-  /* function exit code */
-  __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_1);
-  __Pyx_AddTraceback("crf.ItemSequence.__reduce_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __pyx_r = NULL;
-  __Pyx_XGIVEREF(__pyx_r);
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-/* "(tree fragment)":3
- * def __reduce_cython__(self):
- *     raise TypeError("self.c_sequence cannot be converted to a Python object for pickling")
- * def __setstate_cython__(self, __pyx_state):             # <<<<<<<<<<<<<<
- *     raise TypeError("self.c_sequence cannot be converted to a Python object for pickling")
- */
-
-/* Python wrapper */
-static PyObject *__pyx_pw_3crf_12ItemSequence_11__setstate_cython__(PyObject *__pyx_v_self, PyObject *__pyx_v___pyx_state); /*proto*/
-static char __pyx_doc_3crf_12ItemSequence_10__setstate_cython__[] = "ItemSequence.__setstate_cython__(self, __pyx_state)";
-static PyObject *__pyx_pw_3crf_12ItemSequence_11__setstate_cython__(PyObject *__pyx_v_self, PyObject *__pyx_v___pyx_state) {
-  PyObject *__pyx_r = 0;
-  __Pyx_RefNannyDeclarations
-  __Pyx_RefNannySetupContext("__setstate_cython__ (wrapper)", 0);
-  __pyx_r = __pyx_pf_3crf_12ItemSequence_10__setstate_cython__(((struct __pyx_obj_3crf_ItemSequence *)__pyx_v_self), ((PyObject *)__pyx_v___pyx_state));
-
-  /* function exit code */
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-static PyObject *__pyx_pf_3crf_12ItemSequence_10__setstate_cython__(CYTHON_UNUSED struct __pyx_obj_3crf_ItemSequence *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v___pyx_state) {
-  PyObject *__pyx_r = NULL;
-  __Pyx_RefNannyDeclarations
-  PyObject *__pyx_t_1 = NULL;
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("__setstate_cython__", 0);
-
-  /* "(tree fragment)":4
- *     raise TypeError("self.c_sequence cannot be converted to a Python object for pickling")
- * def __setstate_cython__(self, __pyx_state):
- *     raise TypeError("self.c_sequence cannot be converted to a Python object for pickling")             # <<<<<<<<<<<<<<
- */
-  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__9, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 4, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __Pyx_Raise(__pyx_t_1, 0, 0, 0);
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __PYX_ERR(1, 4, __pyx_L1_error)
-
-  /* "(tree fragment)":3
- * def __reduce_cython__(self):
- *     raise TypeError("self.c_sequence cannot be converted to a Python object for pickling")
- * def __setstate_cython__(self, __pyx_state):             # <<<<<<<<<<<<<<
- *     raise TypeError("self.c_sequence cannot be converted to a Python object for pickling")
- */
-
-  /* function exit code */
-  __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_1);
-  __Pyx_AddTraceback("crf.ItemSequence.__setstate_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __pyx_r = NULL;
-  __Pyx_XGIVEREF(__pyx_r);
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-/* "string.from_py":13
- * 
- * @cname("__pyx_convert_string_from_py_std__in_string")
- * cdef string __pyx_convert_string_from_py_std__in_string(object o) except *:             # <<<<<<<<<<<<<<
- *     cdef Py_ssize_t length = 0
- *     cdef const char* data = __Pyx_PyObject_AsStringAndSize(o, &length)
- */
-
-static std::string __pyx_convert_string_from_py_std__in_string(PyObject *__pyx_v_o) {
-  Py_ssize_t __pyx_v_length;
-  char const *__pyx_v_data;
-  std::string __pyx_r;
-  __Pyx_RefNannyDeclarations
-  char const *__pyx_t_1;
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("__pyx_convert_string_from_py_std__in_string", 0);
-
-  /* "string.from_py":14
- * @cname("__pyx_convert_string_from_py_std__in_string")
- * cdef string __pyx_convert_string_from_py_std__in_string(object o) except *:
- *     cdef Py_ssize_t length = 0             # <<<<<<<<<<<<<<
- *     cdef const char* data = __Pyx_PyObject_AsStringAndSize(o, &length)
- *     return string(data, length)
- */
-  __pyx_v_length = 0;
-
-  /* "string.from_py":15
- * cdef string __pyx_convert_string_from_py_std__in_string(object o) except *:
- *     cdef Py_ssize_t length = 0
- *     cdef const char* data = __Pyx_PyObject_AsStringAndSize(o, &length)             # <<<<<<<<<<<<<<
- *     return string(data, length)
- * 
- */
-  __pyx_t_1 = __Pyx_PyObject_AsStringAndSize(__pyx_v_o, (&__pyx_v_length)); if (unlikely(__pyx_t_1 == ((char const *)NULL))) __PYX_ERR(1, 15, __pyx_L1_error)
-  __pyx_v_data = __pyx_t_1;
-
-  /* "string.from_py":16
- *     cdef Py_ssize_t length = 0
- *     cdef const char* data = __Pyx_PyObject_AsStringAndSize(o, &length)
- *     return string(data, length)             # <<<<<<<<<<<<<<
- * 
- * 
- */
-  __pyx_r = std::string(__pyx_v_data, __pyx_v_length);
-  goto __pyx_L0;
-
-  /* "string.from_py":13
- * 
- * @cname("__pyx_convert_string_from_py_std__in_string")
- * cdef string __pyx_convert_string_from_py_std__in_string(object o) except *:             # <<<<<<<<<<<<<<
- *     cdef Py_ssize_t length = 0
- *     cdef const char* data = __Pyx_PyObject_AsStringAndSize(o, &length)
- */
-
-  /* function exit code */
-  __pyx_L1_error:;
-  __Pyx_AddTraceback("string.from_py.__pyx_convert_string_from_py_std__in_string", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __Pyx_pretend_to_initialize(&__pyx_r);
-  __pyx_L0:;
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-/* "string.to_py":31
- * 
- * @cname("__pyx_convert_PyObject_string_to_py_std__in_string")
- * cdef inline object __pyx_convert_PyObject_string_to_py_std__in_string(const string& s):             # <<<<<<<<<<<<<<
- *     return __Pyx_PyObject_FromStringAndSize(s.data(), s.size())
- * cdef extern from *:
- */
-
-static CYTHON_INLINE PyObject *__pyx_convert_PyObject_string_to_py_std__in_string(std::string const &__pyx_v_s) {
-  PyObject *__pyx_r = NULL;
-  __Pyx_RefNannyDeclarations
-  PyObject *__pyx_t_1 = NULL;
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("__pyx_convert_PyObject_string_to_py_std__in_string", 0);
-
-  /* "string.to_py":32
- * @cname("__pyx_convert_PyObject_string_to_py_std__in_string")
- * cdef inline object __pyx_convert_PyObject_string_to_py_std__in_string(const string& s):
- *     return __Pyx_PyObject_FromStringAndSize(s.data(), s.size())             # <<<<<<<<<<<<<<
- * cdef extern from *:
- *     cdef object __Pyx_PyUnicode_FromStringAndSize(const char*, size_t)
- */
-  __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = __Pyx_PyObject_FromStringAndSize(__pyx_v_s.data(), __pyx_v_s.size()); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 32, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __pyx_r = __pyx_t_1;
-  __pyx_t_1 = 0;
-  goto __pyx_L0;
-
-  /* "string.to_py":31
- * 
- * @cname("__pyx_convert_PyObject_string_to_py_std__in_string")
- * cdef inline object __pyx_convert_PyObject_string_to_py_std__in_string(const string& s):             # <<<<<<<<<<<<<<
- *     return __Pyx_PyObject_FromStringAndSize(s.data(), s.size())
- * cdef extern from *:
- */
-
-  /* function exit code */
-  __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_1);
-  __Pyx_AddTraceback("string.to_py.__pyx_convert_PyObject_string_to_py_std__in_string", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __pyx_r = 0;
-  __pyx_L0:;
-  __Pyx_XGIVEREF(__pyx_r);
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-/* "string.to_py":37
- * 
- * @cname("__pyx_convert_PyUnicode_string_to_py_std__in_string")
- * cdef inline object __pyx_convert_PyUnicode_string_to_py_std__in_string(const string& s):             # <<<<<<<<<<<<<<
- *     return __Pyx_PyUnicode_FromStringAndSize(s.data(), s.size())
- * cdef extern from *:
- */
-
-static CYTHON_INLINE PyObject *__pyx_convert_PyUnicode_string_to_py_std__in_string(std::string const &__pyx_v_s) {
-  PyObject *__pyx_r = NULL;
-  __Pyx_RefNannyDeclarations
-  PyObject *__pyx_t_1 = NULL;
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("__pyx_convert_PyUnicode_string_to_py_std__in_string", 0);
-
-  /* "string.to_py":38
- * @cname("__pyx_convert_PyUnicode_string_to_py_std__in_string")
- * cdef inline object __pyx_convert_PyUnicode_string_to_py_std__in_string(const string& s):
- *     return __Pyx_PyUnicode_FromStringAndSize(s.data(), s.size())             # <<<<<<<<<<<<<<
- * cdef extern from *:
- *     cdef object __Pyx_PyStr_FromStringAndSize(const char*, size_t)
- */
-  __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = __Pyx_PyUnicode_FromStringAndSize(__pyx_v_s.data(), __pyx_v_s.size()); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 38, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __pyx_r = __pyx_t_1;
-  __pyx_t_1 = 0;
-  goto __pyx_L0;
-
-  /* "string.to_py":37
- * 
- * @cname("__pyx_convert_PyUnicode_string_to_py_std__in_string")
- * cdef inline object __pyx_convert_PyUnicode_string_to_py_std__in_string(const string& s):             # <<<<<<<<<<<<<<
- *     return __Pyx_PyUnicode_FromStringAndSize(s.data(), s.size())
- * cdef extern from *:
- */
-
-  /* function exit code */
-  __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_1);
-  __Pyx_AddTraceback("string.to_py.__pyx_convert_PyUnicode_string_to_py_std__in_string", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __pyx_r = 0;
-  __pyx_L0:;
-  __Pyx_XGIVEREF(__pyx_r);
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-/* "string.to_py":43
- * 
- * @cname("__pyx_convert_PyStr_string_to_py_std__in_string")
- * cdef inline object __pyx_convert_PyStr_string_to_py_std__in_string(const string& s):             # <<<<<<<<<<<<<<
- *     return __Pyx_PyStr_FromStringAndSize(s.data(), s.size())
- * cdef extern from *:
- */
-
-static CYTHON_INLINE PyObject *__pyx_convert_PyStr_string_to_py_std__in_string(std::string const &__pyx_v_s) {
-  PyObject *__pyx_r = NULL;
-  __Pyx_RefNannyDeclarations
-  PyObject *__pyx_t_1 = NULL;
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("__pyx_convert_PyStr_string_to_py_std__in_string", 0);
-
-  /* "string.to_py":44
- * @cname("__pyx_convert_PyStr_string_to_py_std__in_string")
- * cdef inline object __pyx_convert_PyStr_string_to_py_std__in_string(const string& s):
- *     return __Pyx_PyStr_FromStringAndSize(s.data(), s.size())             # <<<<<<<<<<<<<<
- * cdef extern from *:
- *     cdef object __Pyx_PyBytes_FromStringAndSize(const char*, size_t)
- */
-  __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = __Pyx_PyStr_FromStringAndSize(__pyx_v_s.data(), __pyx_v_s.size()); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 44, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __pyx_r = __pyx_t_1;
-  __pyx_t_1 = 0;
-  goto __pyx_L0;
-
-  /* "string.to_py":43
- * 
- * @cname("__pyx_convert_PyStr_string_to_py_std__in_string")
- * cdef inline object __pyx_convert_PyStr_string_to_py_std__in_string(const string& s):             # <<<<<<<<<<<<<<
- *     return __Pyx_PyStr_FromStringAndSize(s.data(), s.size())
- * cdef extern from *:
- */
-
-  /* function exit code */
-  __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_1);
-  __Pyx_AddTraceback("string.to_py.__pyx_convert_PyStr_string_to_py_std__in_string", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __pyx_r = 0;
-  __pyx_L0:;
-  __Pyx_XGIVEREF(__pyx_r);
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-/* "string.to_py":49
- * 
- * @cname("__pyx_convert_PyBytes_string_to_py_std__in_string")
- * cdef inline object __pyx_convert_PyBytes_string_to_py_std__in_string(const string& s):             # <<<<<<<<<<<<<<
- *     return __Pyx_PyBytes_FromStringAndSize(s.data(), s.size())
- * cdef extern from *:
- */
-
-static CYTHON_INLINE PyObject *__pyx_convert_PyBytes_string_to_py_std__in_string(std::string const &__pyx_v_s) {
-  PyObject *__pyx_r = NULL;
-  __Pyx_RefNannyDeclarations
-  PyObject *__pyx_t_1 = NULL;
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("__pyx_convert_PyBytes_string_to_py_std__in_string", 0);
-
-  /* "string.to_py":50
- * @cname("__pyx_convert_PyBytes_string_to_py_std__in_string")
- * cdef inline object __pyx_convert_PyBytes_string_to_py_std__in_string(const string& s):
- *     return __Pyx_PyBytes_FromStringAndSize(s.data(), s.size())             # <<<<<<<<<<<<<<
- * cdef extern from *:
- *     cdef object __Pyx_PyByteArray_FromStringAndSize(const char*, size_t)
- */
-  __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = __Pyx_PyBytes_FromStringAndSize(__pyx_v_s.data(), __pyx_v_s.size()); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 50, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __pyx_r = __pyx_t_1;
-  __pyx_t_1 = 0;
-  goto __pyx_L0;
-
-  /* "string.to_py":49
- * 
- * @cname("__pyx_convert_PyBytes_string_to_py_std__in_string")
- * cdef inline object __pyx_convert_PyBytes_string_to_py_std__in_string(const string& s):             # <<<<<<<<<<<<<<
- *     return __Pyx_PyBytes_FromStringAndSize(s.data(), s.size())
- * cdef extern from *:
- */
-
-  /* function exit code */
-  __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_1);
-  __Pyx_AddTraceback("string.to_py.__pyx_convert_PyBytes_string_to_py_std__in_string", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __pyx_r = 0;
-  __pyx_L0:;
-  __Pyx_XGIVEREF(__pyx_r);
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-/* "string.to_py":55
- * 
- * @cname("__pyx_convert_PyByteArray_string_to_py_std__in_string")
- * cdef inline object __pyx_convert_PyByteArray_string_to_py_std__in_string(const string& s):             # <<<<<<<<<<<<<<
- *     return __Pyx_PyByteArray_FromStringAndSize(s.data(), s.size())
- * 
- */
-
-static CYTHON_INLINE PyObject *__pyx_convert_PyByteArray_string_to_py_std__in_string(std::string const &__pyx_v_s) {
-  PyObject *__pyx_r = NULL;
-  __Pyx_RefNannyDeclarations
-  PyObject *__pyx_t_1 = NULL;
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("__pyx_convert_PyByteArray_string_to_py_std__in_string", 0);
-
-  /* "string.to_py":56
- * @cname("__pyx_convert_PyByteArray_string_to_py_std__in_string")
- * cdef inline object __pyx_convert_PyByteArray_string_to_py_std__in_string(const string& s):
- *     return __Pyx_PyByteArray_FromStringAndSize(s.data(), s.size())             # <<<<<<<<<<<<<<
- * 
- */
-  __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = __Pyx_PyByteArray_FromStringAndSize(__pyx_v_s.data(), __pyx_v_s.size()); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 56, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __pyx_r = __pyx_t_1;
-  __pyx_t_1 = 0;
-  goto __pyx_L0;
-
-  /* "string.to_py":55
- * 
- * @cname("__pyx_convert_PyByteArray_string_to_py_std__in_string")
- * cdef inline object __pyx_convert_PyByteArray_string_to_py_std__in_string(const string& s):             # <<<<<<<<<<<<<<
- *     return __Pyx_PyByteArray_FromStringAndSize(s.data(), s.size())
- * 
- */
-
-  /* function exit code */
-  __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_1);
-  __Pyx_AddTraceback("string.to_py.__pyx_convert_PyByteArray_string_to_py_std__in_string", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __pyx_r = 0;
-  __pyx_L0:;
-  __Pyx_XGIVEREF(__pyx_r);
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-/* "vector.to_py":60
- * 
- * @cname("__pyx_convert_vector_to_py_std_3a__3a_string")
- * cdef object __pyx_convert_vector_to_py_std_3a__3a_string(vector[X]& v):             # <<<<<<<<<<<<<<
- *     return [v[i] for i in range(v.size())]
- * 
- */
-
-static PyObject *__pyx_convert_vector_to_py_std_3a__3a_string(const std::vector<std::string>  &__pyx_v_v) {
-  size_t __pyx_v_i;
-  PyObject *__pyx_r = NULL;
-  __Pyx_RefNannyDeclarations
-  PyObject *__pyx_t_1 = NULL;
-  size_t __pyx_t_2;
-  size_t __pyx_t_3;
-  size_t __pyx_t_4;
-  PyObject *__pyx_t_5 = NULL;
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("__pyx_convert_vector_to_py_std_3a__3a_string", 0);
-
-  /* "vector.to_py":61
- * @cname("__pyx_convert_vector_to_py_std_3a__3a_string")
- * cdef object __pyx_convert_vector_to_py_std_3a__3a_string(vector[X]& v):
- *     return [v[i] for i in range(v.size())]             # <<<<<<<<<<<<<<
- * 
- * 
- */
-  __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = PyList_New(0); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 61, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = __pyx_v_v.size();
-  __pyx_t_3 = __pyx_t_2;
-  for (__pyx_t_4 = 0; __pyx_t_4 < __pyx_t_3; __pyx_t_4+=1) {
-    __pyx_v_i = __pyx_t_4;
-    __pyx_t_5 = __pyx_convert_PyStr_string_to_py_std__in_string((__pyx_v_v[__pyx_v_i])); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 61, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_5);
-    if (unlikely(__Pyx_ListComp_Append(__pyx_t_1, (PyObject*)__pyx_t_5))) __PYX_ERR(1, 61, __pyx_L1_error)
-    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-  }
-  __pyx_r = __pyx_t_1;
-  __pyx_t_1 = 0;
-  goto __pyx_L0;
-
-  /* "vector.to_py":60
- * 
- * @cname("__pyx_convert_vector_to_py_std_3a__3a_string")
- * cdef object __pyx_convert_vector_to_py_std_3a__3a_string(vector[X]& v):             # <<<<<<<<<<<<<<
- *     return [v[i] for i in range(v.size())]
- * 
- */
-
-  /* function exit code */
-  __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_1);
-  __Pyx_XDECREF(__pyx_t_5);
-  __Pyx_AddTraceback("vector.to_py.__pyx_convert_vector_to_py_std_3a__3a_string", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __pyx_r = 0;
-  __pyx_L0:;
-  __Pyx_XGIVEREF(__pyx_r);
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-/* "vector.from_py":45
- * 
- * @cname("__pyx_convert_vector_from_py_std_3a__3a_string")
- * cdef vector[X] __pyx_convert_vector_from_py_std_3a__3a_string(object o) except *:             # <<<<<<<<<<<<<<
- *     cdef vector[X] v
- *     for item in o:
- */
-
-static std::vector<std::string>  __pyx_convert_vector_from_py_std_3a__3a_string(PyObject *__pyx_v_o) {
-  std::vector<std::string>  __pyx_v_v;
-  PyObject *__pyx_v_item = NULL;
-  std::vector<std::string>  __pyx_r;
-  __Pyx_RefNannyDeclarations
-  PyObject *__pyx_t_1 = NULL;
-  Py_ssize_t __pyx_t_2;
-  PyObject *(*__pyx_t_3)(PyObject *);
-  PyObject *__pyx_t_4 = NULL;
-  std::string __pyx_t_5;
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("__pyx_convert_vector_from_py_std_3a__3a_string", 0);
-
-  /* "vector.from_py":47
- * cdef vector[X] __pyx_convert_vector_from_py_std_3a__3a_string(object o) except *:
- *     cdef vector[X] v
- *     for item in o:             # <<<<<<<<<<<<<<
- *         v.push_back(<X>item)
- *     return v
- */
-  if (likely(PyList_CheckExact(__pyx_v_o)) || PyTuple_CheckExact(__pyx_v_o)) {
-    __pyx_t_1 = __pyx_v_o; __Pyx_INCREF(__pyx_t_1); __pyx_t_2 = 0;
-    __pyx_t_3 = NULL;
-  } else {
-    __pyx_t_2 = -1; __pyx_t_1 = PyObject_GetIter(__pyx_v_o); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 47, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_1);
-    __pyx_t_3 = Py_TYPE(__pyx_t_1)->tp_iternext; if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 47, __pyx_L1_error)
-  }
-  for (;;) {
-    if (likely(!__pyx_t_3)) {
-      if (likely(PyList_CheckExact(__pyx_t_1))) {
-        if (__pyx_t_2 >= PyList_GET_SIZE(__pyx_t_1)) break;
-        #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-        __pyx_t_4 = PyList_GET_ITEM(__pyx_t_1, __pyx_t_2); __Pyx_INCREF(__pyx_t_4); __pyx_t_2++; if (unlikely(0 < 0)) __PYX_ERR(1, 47, __pyx_L1_error)
-        #else
-        __pyx_t_4 = PySequence_ITEM(__pyx_t_1, __pyx_t_2); __pyx_t_2++; if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 47, __pyx_L1_error)
-        __Pyx_GOTREF(__pyx_t_4);
-        #endif
-      } else {
-        if (__pyx_t_2 >= PyTuple_GET_SIZE(__pyx_t_1)) break;
-        #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-        __pyx_t_4 = PyTuple_GET_ITEM(__pyx_t_1, __pyx_t_2); __Pyx_INCREF(__pyx_t_4); __pyx_t_2++; if (unlikely(0 < 0)) __PYX_ERR(1, 47, __pyx_L1_error)
-        #else
-        __pyx_t_4 = PySequence_ITEM(__pyx_t_1, __pyx_t_2); __pyx_t_2++; if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 47, __pyx_L1_error)
-        __Pyx_GOTREF(__pyx_t_4);
-        #endif
-      }
-    } else {
-      __pyx_t_4 = __pyx_t_3(__pyx_t_1);
-      if (unlikely(!__pyx_t_4)) {
-        PyObject* exc_type = PyErr_Occurred();
-        if (exc_type) {
-          if (likely(__Pyx_PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
-          else __PYX_ERR(1, 47, __pyx_L1_error)
-        }
-        break;
-      }
-      __Pyx_GOTREF(__pyx_t_4);
-    }
-    __Pyx_XDECREF_SET(__pyx_v_item, __pyx_t_4);
-    __pyx_t_4 = 0;
-
-    /* "vector.from_py":48
- *     cdef vector[X] v
- *     for item in o:
- *         v.push_back(<X>item)             # <<<<<<<<<<<<<<
- *     return v
- * 
- */
-    __pyx_t_5 = __pyx_convert_string_from_py_std__in_string(__pyx_v_item); if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 48, __pyx_L1_error)
-    __pyx_v_v.push_back(((std::string)__pyx_t_5));
-
-    /* "vector.from_py":47
- * cdef vector[X] __pyx_convert_vector_from_py_std_3a__3a_string(object o) except *:
- *     cdef vector[X] v
- *     for item in o:             # <<<<<<<<<<<<<<
- *         v.push_back(<X>item)
- *     return v
- */
-  }
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-
-  /* "vector.from_py":49
- *     for item in o:
- *         v.push_back(<X>item)
- *     return v             # <<<<<<<<<<<<<<
- * 
- * 
- */
-  __pyx_r = __pyx_v_v;
-  goto __pyx_L0;
-
-  /* "vector.from_py":45
- * 
- * @cname("__pyx_convert_vector_from_py_std_3a__3a_string")
- * cdef vector[X] __pyx_convert_vector_from_py_std_3a__3a_string(object o) except *:             # <<<<<<<<<<<<<<
- *     cdef vector[X] v
- *     for item in o:
- */
-
-  /* function exit code */
-  __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_1);
-  __Pyx_XDECREF(__pyx_t_4);
-  __Pyx_AddTraceback("vector.from_py.__pyx_convert_vector_from_py_std_3a__3a_string", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __Pyx_pretend_to_initialize(&__pyx_r);
-  __pyx_L0:;
-  __Pyx_XDECREF(__pyx_v_item);
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-static struct __pyx_vtabstruct_3crf_Trainer __pyx_vtable_3crf_Trainer;
-
-static PyObject *__pyx_tp_new_3crf_Trainer(PyTypeObject *t, CYTHON_UNUSED PyObject *a, CYTHON_UNUSED PyObject *k) {
-  struct __pyx_obj_3crf_Trainer *p;
-  PyObject *o;
-  if (likely((t->tp_flags & Py_TPFLAGS_IS_ABSTRACT) == 0)) {
-    o = (*t->tp_alloc)(t, 0);
-  } else {
-    o = (PyObject *) PyBaseObject_Type.tp_new(t, __pyx_empty_tuple, 0);
-  }
-  if (unlikely(!o)) return 0;
-  p = ((struct __pyx_obj_3crf_Trainer *)o);
-  p->__pyx_vtab = __pyx_vtabptr_3crf_Trainer;
-  new((void*)&(p->_trainer)) CRFSuiteWrapper::Trainer();
-  if (unlikely(__pyx_pw_3crf_7Trainer_3__cinit__(o, __pyx_empty_tuple, NULL) < 0)) goto bad;
-  return o;
-  bad:
-  Py_DECREF(o); o = 0;
-  return NULL;
-}
-
-static void __pyx_tp_dealloc_3crf_Trainer(PyObject *o) {
-  struct __pyx_obj_3crf_Trainer *p = (struct __pyx_obj_3crf_Trainer *)o;
-  #if CYTHON_USE_TP_FINALIZE
-  if (unlikely(PyType_HasFeature(Py_TYPE(o), Py_TPFLAGS_HAVE_FINALIZE) && Py_TYPE(o)->tp_finalize) && (!PyType_IS_GC(Py_TYPE(o)) || !_PyGC_FINALIZED(o))) {
-    if (PyObject_CallFinalizerFromDealloc(o)) return;
-  }
-  #endif
-  __Pyx_call_destructor(p->_trainer);
-  (*Py_TYPE(o)->tp_free)(o);
-}
-
-static PyObject *__pyx_getprop_3crf_7Trainer_params(PyObject *o, CYTHON_UNUSED void *x) {
-  return __pyx_pw_3crf_7Trainer_6params_1__get__(o);
-}
-
-static PyMethodDef __pyx_methods_3crf_Trainer[] = {
-  {"train", (PyCFunction)__pyx_pw_3crf_7Trainer_5train, METH_O, __pyx_doc_3crf_7Trainer_4train},
-  {"_log", (PyCFunction)__pyx_pw_3crf_7Trainer_7_log, METH_O, __pyx_doc_3crf_7Trainer_6_log},
-  {"append", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_3crf_7Trainer_9append, METH_VARARGS|METH_KEYWORDS, __pyx_doc_3crf_7Trainer_8append},
-  {"translate_params", (PyCFunction)__pyx_pw_3crf_7Trainer_11translate_params, METH_O, __pyx_doc_3crf_7Trainer_10translate_params},
-  {"select_algorithm", (PyCFunction)__pyx_pw_3crf_7Trainer_13select_algorithm, METH_O, __pyx_doc_3crf_7Trainer_12select_algorithm},
-  {"set_params", (PyCFunction)__pyx_pw_3crf_7Trainer_15set_params, METH_O, __pyx_doc_3crf_7Trainer_14set_params},
-  {"set_param", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_3crf_7Trainer_17set_param, METH_VARARGS|METH_KEYWORDS, __pyx_doc_3crf_7Trainer_16set_param},
-  {"get_param", (PyCFunction)__pyx_pw_3crf_7Trainer_19get_param, METH_O, __pyx_doc_3crf_7Trainer_18get_param},
-  {"cast_parameter", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_3crf_7Trainer_21cast_parameter, METH_VARARGS|METH_KEYWORDS, __pyx_doc_3crf_7Trainer_20cast_parameter},
-  {"__reduce_cython__", (PyCFunction)__pyx_pw_3crf_7Trainer_27__reduce_cython__, METH_NOARGS, __pyx_doc_3crf_7Trainer_26__reduce_cython__},
-  {"__setstate_cython__", (PyCFunction)__pyx_pw_3crf_7Trainer_29__setstate_cython__, METH_O, __pyx_doc_3crf_7Trainer_28__setstate_cython__},
-  {0, 0, 0, 0}
-};
-
-static struct PyGetSetDef __pyx_getsets_3crf_Trainer[] = {
-  {(char *)"params", __pyx_getprop_3crf_7Trainer_params, 0, (char *)0, 0},
-  {0, 0, 0, 0, 0}
-};
-
-static PyTypeObject __pyx_type_3crf_Trainer = {
-  PyVarObject_HEAD_INIT(0, 0)
-  "crf.Trainer", /*tp_name*/
-  sizeof(struct __pyx_obj_3crf_Trainer), /*tp_basicsize*/
-  0, /*tp_itemsize*/
-  __pyx_tp_dealloc_3crf_Trainer, /*tp_dealloc*/
-  #if PY_VERSION_HEX < 0x030800b4
-  0, /*tp_print*/
-  #endif
-  #if PY_VERSION_HEX >= 0x030800b4
-  0, /*tp_vectorcall_offset*/
-  #endif
-  0, /*tp_getattr*/
-  0, /*tp_setattr*/
-  #if PY_MAJOR_VERSION < 3
-  0, /*tp_compare*/
-  #endif
-  #if PY_MAJOR_VERSION >= 3
-  0, /*tp_as_async*/
-  #endif
-  0, /*tp_repr*/
-  0, /*tp_as_number*/
-  0, /*tp_as_sequence*/
-  0, /*tp_as_mapping*/
-  0, /*tp_hash*/
-  0, /*tp_call*/
-  0, /*tp_str*/
-  0, /*tp_getattro*/
-  0, /*tp_setattro*/
-  0, /*tp_as_buffer*/
-  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE, /*tp_flags*/
-  "Trainer(str algorithm: str, **kwargs)", /*tp_doc*/
-  0, /*tp_traverse*/
-  0, /*tp_clear*/
-  0, /*tp_richcompare*/
-  0, /*tp_weaklistoffset*/
-  0, /*tp_iter*/
-  0, /*tp_iternext*/
-  __pyx_methods_3crf_Trainer, /*tp_methods*/
-  0, /*tp_members*/
-  __pyx_getsets_3crf_Trainer, /*tp_getset*/
-  0, /*tp_base*/
-  0, /*tp_dict*/
-  0, /*tp_descr_get*/
-  0, /*tp_descr_set*/
-  0, /*tp_dictoffset*/
-  __pyx_pw_3crf_7Trainer_1__init__, /*tp_init*/
-  0, /*tp_alloc*/
-  __pyx_tp_new_3crf_Trainer, /*tp_new*/
-  0, /*tp_free*/
-  0, /*tp_is_gc*/
-  0, /*tp_bases*/
-  0, /*tp_mro*/
-  0, /*tp_cache*/
-  0, /*tp_subclasses*/
-  0, /*tp_weaklist*/
-  0, /*tp_del*/
-  0, /*tp_version_tag*/
-  #if PY_VERSION_HEX >= 0x030400a1
-  0, /*tp_finalize*/
-  #endif
-  #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
-  0, /*tp_vectorcall*/
-  #endif
-  #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
-  0, /*tp_print*/
-  #endif
-  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
-  0, /*tp_pypy_flags*/
-  #endif
-};
-static struct __pyx_vtabstruct_3crf_Model __pyx_vtable_3crf_Model;
-
-static PyObject *__pyx_tp_new_3crf_Model(PyTypeObject *t, CYTHON_UNUSED PyObject *a, CYTHON_UNUSED PyObject *k) {
-  struct __pyx_obj_3crf_Model *p;
-  PyObject *o;
-  if (likely((t->tp_flags & Py_TPFLAGS_IS_ABSTRACT) == 0)) {
-    o = (*t->tp_alloc)(t, 0);
-  } else {
-    o = (PyObject *) PyBaseObject_Type.tp_new(t, __pyx_empty_tuple, 0);
-  }
-  if (unlikely(!o)) return 0;
-  p = ((struct __pyx_obj_3crf_Model *)o);
-  p->__pyx_vtab = __pyx_vtabptr_3crf_Model;
-  new((void*)&(p->_tagger)) CRFSuiteWrapper::Tagger();
-  return o;
-}
-
-static void __pyx_tp_dealloc_3crf_Model(PyObject *o) {
-  struct __pyx_obj_3crf_Model *p = (struct __pyx_obj_3crf_Model *)o;
-  #if CYTHON_USE_TP_FINALIZE
-  if (unlikely(PyType_HasFeature(Py_TYPE(o), Py_TPFLAGS_HAVE_FINALIZE) && Py_TYPE(o)->tp_finalize) && (!PyType_IS_GC(Py_TYPE(o)) || !_PyGC_FINALIZED(o))) {
-    if (PyObject_CallFinalizerFromDealloc(o)) return;
-  }
-  #endif
-  __Pyx_call_destructor(p->_tagger);
-  (*Py_TYPE(o)->tp_free)(o);
-}
-
-static PyObject *__pyx_getprop_3crf_5Model_labels(PyObject *o, CYTHON_UNUSED void *x) {
-  return __pyx_pw_3crf_5Model_6labels_1__get__(o);
-}
-
-static PyMethodDef __pyx_methods_3crf_Model[] = {
-  {"predict_single", (PyCFunction)__pyx_pw_3crf_5Model_3predict_single, METH_O, __pyx_doc_3crf_5Model_2predict_single},
-  {"predict_proba_single", (PyCFunction)__pyx_pw_3crf_5Model_5predict_proba_single, METH_O, __pyx_doc_3crf_5Model_4predict_proba_single},
-  {"load", (PyCFunction)__pyx_pw_3crf_5Model_7load, METH_O, __pyx_doc_3crf_5Model_6load},
-  {"marginal", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_3crf_5Model_9marginal, METH_VARARGS|METH_KEYWORDS, __pyx_doc_3crf_5Model_8marginal},
-  {"set_sequence", (PyCFunction)__pyx_pw_3crf_5Model_11set_sequence, METH_O, __pyx_doc_3crf_5Model_10set_sequence},
-  {"check_model", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_3crf_5Model_13check_model, METH_VARARGS|METH_KEYWORDS, __pyx_doc_3crf_5Model_12check_model},
-  {"dump_transitions", (PyCFunction)__pyx_pw_3crf_5Model_15dump_transitions, METH_O, __pyx_doc_3crf_5Model_14dump_transitions},
-  {"dump_states", (PyCFunction)__pyx_pw_3crf_5Model_17dump_states, METH_O, __pyx_doc_3crf_5Model_16dump_states},
-  {"__reduce_cython__", (PyCFunction)__pyx_pw_3crf_5Model_19__reduce_cython__, METH_NOARGS, __pyx_doc_3crf_5Model_18__reduce_cython__},
-  {"__setstate_cython__", (PyCFunction)__pyx_pw_3crf_5Model_21__setstate_cython__, METH_O, __pyx_doc_3crf_5Model_20__setstate_cython__},
-  {0, 0, 0, 0}
-};
-
-static struct PyGetSetDef __pyx_getsets_3crf_Model[] = {
-  {(char *)"labels", __pyx_getprop_3crf_5Model_labels, 0, (char *)0, 0},
-  {0, 0, 0, 0, 0}
-};
-
-static PyTypeObject __pyx_type_3crf_Model = {
-  PyVarObject_HEAD_INIT(0, 0)
-  "crf.Model", /*tp_name*/
-  sizeof(struct __pyx_obj_3crf_Model), /*tp_basicsize*/
-  0, /*tp_itemsize*/
-  __pyx_tp_dealloc_3crf_Model, /*tp_dealloc*/
-  #if PY_VERSION_HEX < 0x030800b4
-  0, /*tp_print*/
-  #endif
-  #if PY_VERSION_HEX >= 0x030800b4
-  0, /*tp_vectorcall_offset*/
-  #endif
-  0, /*tp_getattr*/
-  0, /*tp_setattr*/
-  #if PY_MAJOR_VERSION < 3
-  0, /*tp_compare*/
-  #endif
-  #if PY_MAJOR_VERSION >= 3
-  0, /*tp_as_async*/
-  #endif
-  0, /*tp_repr*/
-  0, /*tp_as_number*/
-  0, /*tp_as_sequence*/
-  0, /*tp_as_mapping*/
-  0, /*tp_hash*/
-  0, /*tp_call*/
-  0, /*tp_str*/
-  0, /*tp_getattro*/
-  0, /*tp_setattro*/
-  0, /*tp_as_buffer*/
-  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE, /*tp_flags*/
-  "Model(model_filepath: Filepath)", /*tp_doc*/
-  0, /*tp_traverse*/
-  0, /*tp_clear*/
-  0, /*tp_richcompare*/
-  0, /*tp_weaklistoffset*/
-  0, /*tp_iter*/
-  0, /*tp_iternext*/
-  __pyx_methods_3crf_Model, /*tp_methods*/
-  0, /*tp_members*/
-  __pyx_getsets_3crf_Model, /*tp_getset*/
-  0, /*tp_base*/
-  0, /*tp_dict*/
-  0, /*tp_descr_get*/
-  0, /*tp_descr_set*/
-  0, /*tp_dictoffset*/
-  __pyx_pw_3crf_5Model_1__init__, /*tp_init*/
-  0, /*tp_alloc*/
-  __pyx_tp_new_3crf_Model, /*tp_new*/
-  0, /*tp_free*/
-  0, /*tp_is_gc*/
-  0, /*tp_bases*/
-  0, /*tp_mro*/
-  0, /*tp_cache*/
-  0, /*tp_subclasses*/
-  0, /*tp_weaklist*/
-  0, /*tp_del*/
-  0, /*tp_version_tag*/
-  #if PY_VERSION_HEX >= 0x030400a1
-  0, /*tp_finalize*/
-  #endif
-  #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
-  0, /*tp_vectorcall*/
-  #endif
-  #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
-  0, /*tp_print*/
-  #endif
-  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
-  0, /*tp_pypy_flags*/
-  #endif
-};
-
-static PyObject *__pyx_tp_new_3crf_ItemSequence(PyTypeObject *t, CYTHON_UNUSED PyObject *a, CYTHON_UNUSED PyObject *k) {
-  struct __pyx_obj_3crf_ItemSequence *p;
-  PyObject *o;
-  if (likely((t->tp_flags & Py_TPFLAGS_IS_ABSTRACT) == 0)) {
-    o = (*t->tp_alloc)(t, 0);
-  } else {
-    o = (PyObject *) PyBaseObject_Type.tp_new(t, __pyx_empty_tuple, 0);
-  }
-  if (unlikely(!o)) return 0;
-  p = ((struct __pyx_obj_3crf_ItemSequence *)o);
-  new((void*)&(p->c_sequence)) CRFSuite::ItemSequence();
-  return o;
-}
-
-static void __pyx_tp_dealloc_3crf_ItemSequence(PyObject *o) {
-  struct __pyx_obj_3crf_ItemSequence *p = (struct __pyx_obj_3crf_ItemSequence *)o;
-  #if CYTHON_USE_TP_FINALIZE
-  if (unlikely(PyType_HasFeature(Py_TYPE(o), Py_TPFLAGS_HAVE_FINALIZE) && Py_TYPE(o)->tp_finalize) && (!PyType_IS_GC(Py_TYPE(o)) || !_PyGC_FINALIZED(o))) {
-    if (PyObject_CallFinalizerFromDealloc(o)) return;
-  }
-  #endif
-  __Pyx_call_destructor(p->c_sequence);
-  (*Py_TYPE(o)->tp_free)(o);
-}
-
-static PyMethodDef __pyx_methods_3crf_ItemSequence[] = {
-  {"items", (PyCFunction)__pyx_pw_3crf_12ItemSequence_3items, METH_NOARGS, __pyx_doc_3crf_12ItemSequence_2items},
-  {"__reduce_cython__", (PyCFunction)__pyx_pw_3crf_12ItemSequence_9__reduce_cython__, METH_NOARGS, __pyx_doc_3crf_12ItemSequence_8__reduce_cython__},
-  {"__setstate_cython__", (PyCFunction)__pyx_pw_3crf_12ItemSequence_11__setstate_cython__, METH_O, __pyx_doc_3crf_12ItemSequence_10__setstate_cython__},
-  {0, 0, 0, 0}
-};
-
-static PySequenceMethods __pyx_tp_as_sequence_ItemSequence = {
-  __pyx_pw_3crf_12ItemSequence_5__len__, /*sq_length*/
-  0, /*sq_concat*/
-  0, /*sq_repeat*/
-  0, /*sq_item*/
-  0, /*sq_slice*/
-  0, /*sq_ass_item*/
-  0, /*sq_ass_slice*/
-  0, /*sq_contains*/
-  0, /*sq_inplace_concat*/
-  0, /*sq_inplace_repeat*/
-};
-
-static PyMappingMethods __pyx_tp_as_mapping_ItemSequence = {
-  __pyx_pw_3crf_12ItemSequence_5__len__, /*mp_length*/
-  0, /*mp_subscript*/
-  0, /*mp_ass_subscript*/
-};
-
-static PyTypeObject __pyx_type_3crf_ItemSequence = {
-  PyVarObject_HEAD_INIT(0, 0)
-  "crf.ItemSequence", /*tp_name*/
-  sizeof(struct __pyx_obj_3crf_ItemSequence), /*tp_basicsize*/
-  0, /*tp_itemsize*/
-  __pyx_tp_dealloc_3crf_ItemSequence, /*tp_dealloc*/
-  #if PY_VERSION_HEX < 0x030800b4
-  0, /*tp_print*/
-  #endif
-  #if PY_VERSION_HEX >= 0x030800b4
-  0, /*tp_vectorcall_offset*/
-  #endif
-  0, /*tp_getattr*/
-  0, /*tp_setattr*/
-  #if PY_MAJOR_VERSION < 3
-  0, /*tp_compare*/
-  #endif
-  #if PY_MAJOR_VERSION >= 3
-  0, /*tp_as_async*/
-  #endif
-  __pyx_pw_3crf_12ItemSequence_7__repr__, /*tp_repr*/
-  0, /*tp_as_number*/
-  &__pyx_tp_as_sequence_ItemSequence, /*tp_as_sequence*/
-  &__pyx_tp_as_mapping_ItemSequence, /*tp_as_mapping*/
-  0, /*tp_hash*/
-  0, /*tp_call*/
-  0, /*tp_str*/
-  0, /*tp_getattro*/
-  0, /*tp_setattro*/
-  0, /*tp_as_buffer*/
-  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE, /*tp_flags*/
-  "ItemSequence(sequence)", /*tp_doc*/
-  0, /*tp_traverse*/
-  0, /*tp_clear*/
-  0, /*tp_richcompare*/
-  0, /*tp_weaklistoffset*/
-  0, /*tp_iter*/
-  0, /*tp_iternext*/
-  __pyx_methods_3crf_ItemSequence, /*tp_methods*/
-  0, /*tp_members*/
-  0, /*tp_getset*/
-  0, /*tp_base*/
-  0, /*tp_dict*/
-  0, /*tp_descr_get*/
-  0, /*tp_descr_set*/
-  0, /*tp_dictoffset*/
-  __pyx_pw_3crf_12ItemSequence_1__init__, /*tp_init*/
-  0, /*tp_alloc*/
-  __pyx_tp_new_3crf_ItemSequence, /*tp_new*/
-  0, /*tp_free*/
-  0, /*tp_is_gc*/
-  0, /*tp_bases*/
-  0, /*tp_mro*/
-  0, /*tp_cache*/
-  0, /*tp_subclasses*/
-  0, /*tp_weaklist*/
-  0, /*tp_del*/
-  0, /*tp_version_tag*/
-  #if PY_VERSION_HEX >= 0x030400a1
-  0, /*tp_finalize*/
-  #endif
-  #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
-  0, /*tp_vectorcall*/
-  #endif
-  #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
-  0, /*tp_print*/
-  #endif
-  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
-  0, /*tp_pypy_flags*/
-  #endif
-};
-
-static PyMethodDef __pyx_methods[] = {
-  {0, 0, 0, 0}
-};
-
-#if PY_MAJOR_VERSION >= 3
-#if CYTHON_PEP489_MULTI_PHASE_INIT
-static PyObject* __pyx_pymod_create(PyObject *spec, PyModuleDef *def); /*proto*/
-static int __pyx_pymod_exec_crf(PyObject* module); /*proto*/
-static PyModuleDef_Slot __pyx_moduledef_slots[] = {
-  {Py_mod_create, (void*)__pyx_pymod_create},
-  {Py_mod_exec, (void*)__pyx_pymod_exec_crf},
-  {0, NULL}
-};
-#endif
-
-static struct PyModuleDef __pyx_moduledef = {
-    PyModuleDef_HEAD_INIT,
-    "crf",
-    0, /* m_doc */
-  #if CYTHON_PEP489_MULTI_PHASE_INIT
-    0, /* m_size */
-  #else
-    -1, /* m_size */
-  #endif
-    __pyx_methods /* m_methods */,
-  #if CYTHON_PEP489_MULTI_PHASE_INIT
-    __pyx_moduledef_slots, /* m_slots */
-  #else
-    NULL, /* m_reload */
-  #endif
-    NULL, /* m_traverse */
-    NULL, /* m_clear */
-    NULL /* m_free */
-};
-#endif
-#ifndef CYTHON_SMALL_CODE
-#if defined(__clang__)
-    #define CYTHON_SMALL_CODE
-#elif defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3))
-    #define CYTHON_SMALL_CODE __attribute__((cold))
-#else
-    #define CYTHON_SMALL_CODE
-#endif
-#endif
-
-static __Pyx_StringTabEntry __pyx_string_tab[] = {
-  {&__pyx_kp_u_Cannot_load_model_file, __pyx_k_Cannot_load_model_file, sizeof(__pyx_k_Cannot_load_model_file), 0, 1, 0, 0},
-  {&__pyx_n_s_Filepath, __pyx_k_Filepath, sizeof(__pyx_k_Filepath), 0, 0, 1, 1},
-  {&__pyx_kp_u_Invalid_model_file, __pyx_k_Invalid_model_file, sizeof(__pyx_k_Invalid_model_file), 0, 1, 0, 0},
-  {&__pyx_kp_u_ItemSequence, __pyx_k_ItemSequence, sizeof(__pyx_k_ItemSequence), 0, 1, 0, 0},
-  {&__pyx_n_s_ItemSequence_2, __pyx_k_ItemSequence_2, sizeof(__pyx_k_ItemSequence_2), 0, 0, 1, 1},
-  {&__pyx_n_s_LOGGER, __pyx_k_LOGGER, sizeof(__pyx_k_LOGGER), 0, 0, 1, 1},
-  {&__pyx_n_s_Labels, __pyx_k_Labels, sizeof(__pyx_k_Labels), 0, 0, 1, 1},
-  {&__pyx_n_s_Logger, __pyx_k_Logger, sizeof(__pyx_k_Logger), 0, 0, 1, 1},
-  {&__pyx_n_s_Model, __pyx_k_Model, sizeof(__pyx_k_Model), 0, 0, 1, 1},
-  {&__pyx_kp_u_Model_file, __pyx_k_Model_file, sizeof(__pyx_k_Model_file), 0, 1, 0, 0},
-  {&__pyx_n_s_O_CREAT, __pyx_k_O_CREAT, sizeof(__pyx_k_O_CREAT), 0, 0, 1, 1},
-  {&__pyx_n_s_O_WRONLY, __pyx_k_O_WRONLY, sizeof(__pyx_k_O_WRONLY), 0, 0, 1, 1},
-  {&__pyx_n_s_SEEK_END, __pyx_k_SEEK_END, sizeof(__pyx_k_SEEK_END), 0, 0, 1, 1},
-  {&__pyx_n_s_Sequence, __pyx_k_Sequence, sizeof(__pyx_k_Sequence), 0, 0, 1, 1},
-  {&__pyx_n_s_Trainer, __pyx_k_Trainer, sizeof(__pyx_k_Trainer), 0, 0, 1, 1},
-  {&__pyx_n_s_Trainer_lambda, __pyx_k_Trainer_lambda, sizeof(__pyx_k_Trainer_lambda), 0, 0, 1, 1},
-  {&__pyx_n_s_TypeError, __pyx_k_TypeError, sizeof(__pyx_k_TypeError), 0, 0, 1, 1},
-  {&__pyx_n_s_ValueError, __pyx_k_ValueError, sizeof(__pyx_k_ValueError), 0, 0, 1, 1},
-  {&__pyx_kp_b__6, __pyx_k__6, sizeof(__pyx_k__6), 0, 0, 0, 0},
-  {&__pyx_kp_u__7, __pyx_k__7, sizeof(__pyx_k__7), 0, 1, 0, 0},
-  {&__pyx_n_s_algorithm, __pyx_k_algorithm, sizeof(__pyx_k_algorithm), 0, 0, 1, 1},
-  {&__pyx_n_s_algorithm_aliases, __pyx_k_algorithm_aliases, sizeof(__pyx_k_algorithm_aliases), 0, 0, 1, 1},
-  {&__pyx_n_s_all_possible_states, __pyx_k_all_possible_states, sizeof(__pyx_k_all_possible_states), 0, 0, 1, 1},
-  {&__pyx_n_s_all_possible_transitions, __pyx_k_all_possible_transitions, sizeof(__pyx_k_all_possible_transitions), 0, 0, 1, 1},
-  {&__pyx_n_s_ap, __pyx_k_ap, sizeof(__pyx_k_ap), 0, 0, 1, 1},
-  {&__pyx_n_s_arow, __pyx_k_arow, sizeof(__pyx_k_arow), 0, 0, 1, 1},
-  {&__pyx_kp_s_averaged_perceptron, __pyx_k_averaged_perceptron, sizeof(__pyx_k_averaged_perceptron), 0, 0, 1, 0},
-  {&__pyx_n_s_averaging, __pyx_k_averaging, sizeof(__pyx_k_averaging), 0, 0, 1, 1},
-  {&__pyx_n_s_c, __pyx_k_c, sizeof(__pyx_k_c), 0, 0, 1, 1},
-  {&__pyx_n_s_c1, __pyx_k_c1, sizeof(__pyx_k_c1), 0, 0, 1, 1},
-  {&__pyx_n_s_c2, __pyx_k_c2, sizeof(__pyx_k_c2), 0, 0, 1, 1},
-  {&__pyx_kp_s_calibration_candidates, __pyx_k_calibration_candidates, sizeof(__pyx_k_calibration_candidates), 0, 0, 1, 0},
-  {&__pyx_n_s_calibration_candidates_2, __pyx_k_calibration_candidates_2, sizeof(__pyx_k_calibration_candidates_2), 0, 0, 1, 1},
-  {&__pyx_kp_s_calibration_eta, __pyx_k_calibration_eta, sizeof(__pyx_k_calibration_eta), 0, 0, 1, 0},
-  {&__pyx_n_s_calibration_eta_2, __pyx_k_calibration_eta_2, sizeof(__pyx_k_calibration_eta_2), 0, 0, 1, 1},
-  {&__pyx_kp_s_calibration_max_trials, __pyx_k_calibration_max_trials, sizeof(__pyx_k_calibration_max_trials), 0, 0, 1, 0},
-  {&__pyx_n_s_calibration_max_trials_2, __pyx_k_calibration_max_trials_2, sizeof(__pyx_k_calibration_max_trials_2), 0, 0, 1, 1},
-  {&__pyx_kp_s_calibration_rate, __pyx_k_calibration_rate, sizeof(__pyx_k_calibration_rate), 0, 0, 1, 0},
-  {&__pyx_n_s_calibration_rate_2, __pyx_k_calibration_rate_2, sizeof(__pyx_k_calibration_rate_2), 0, 0, 1, 1},
-  {&__pyx_kp_s_calibration_samples, __pyx_k_calibration_samples, sizeof(__pyx_k_calibration_samples), 0, 0, 1, 0},
-  {&__pyx_n_s_calibration_samples_2, __pyx_k_calibration_samples_2, sizeof(__pyx_k_calibration_samples_2), 0, 0, 1, 1},
-  {&__pyx_n_s_cast_parameter, __pyx_k_cast_parameter, sizeof(__pyx_k_cast_parameter), 0, 0, 1, 1},
-  {&__pyx_kp_s_chaine__core_crf_pyx, __pyx_k_chaine__core_crf_pyx, sizeof(__pyx_k_chaine__core_crf_pyx), 0, 0, 1, 0},
-  {&__pyx_n_s_chaine_logging, __pyx_k_chaine_logging, sizeof(__pyx_k_chaine_logging), 0, 0, 1, 1},
-  {&__pyx_n_s_chaine_typing, __pyx_k_chaine_typing, sizeof(__pyx_k_chaine_typing), 0, 0, 1, 1},
-  {&__pyx_n_s_check_model, __pyx_k_check_model, sizeof(__pyx_k_check_model), 0, 0, 1, 1},
-  {&__pyx_n_s_cline_in_traceback, __pyx_k_cline_in_traceback, sizeof(__pyx_k_cline_in_traceback), 0, 0, 1, 1},
-  {&__pyx_n_s_crf, __pyx_k_crf, sizeof(__pyx_k_crf), 0, 0, 1, 1},
-  {&__pyx_n_b_crf1d, __pyx_k_crf1d, sizeof(__pyx_k_crf1d), 0, 0, 0, 1},
-  {&__pyx_n_s_delta, __pyx_k_delta, sizeof(__pyx_k_delta), 0, 0, 1, 1},
-  {&__pyx_kp_u_does_not_have_a_complete_header, __pyx_k_does_not_have_a_complete_header, sizeof(__pyx_k_does_not_have_a_complete_header), 0, 1, 0, 0},
-  {&__pyx_n_s_enter, __pyx_k_enter, sizeof(__pyx_k_enter), 0, 0, 1, 1},
-  {&__pyx_n_s_epsilon, __pyx_k_epsilon, sizeof(__pyx_k_epsilon), 0, 0, 1, 1},
-  {&__pyx_n_s_error_sensitive, __pyx_k_error_sensitive, sizeof(__pyx_k_error_sensitive), 0, 0, 1, 1},
-  {&__pyx_n_s_exit, __pyx_k_exit, sizeof(__pyx_k_exit), 0, 0, 1, 1},
-  {&__pyx_kp_s_feature_minfreq, __pyx_k_feature_minfreq, sizeof(__pyx_k_feature_minfreq), 0, 0, 1, 0},
-  {&__pyx_kp_s_feature_possible_states, __pyx_k_feature_possible_states, sizeof(__pyx_k_feature_possible_states), 0, 0, 1, 0},
-  {&__pyx_kp_s_feature_possible_transitions, __pyx_k_feature_possible_transitions, sizeof(__pyx_k_feature_possible_transitions), 0, 0, 1, 0},
-  {&__pyx_n_s_filepath, __pyx_k_filepath, sizeof(__pyx_k_filepath), 0, 0, 1, 1},
-  {&__pyx_n_s_gamma, __pyx_k_gamma, sizeof(__pyx_k_gamma), 0, 0, 1, 1},
-  {&__pyx_n_s_get, __pyx_k_get, sizeof(__pyx_k_get), 0, 0, 1, 1},
-  {&__pyx_n_s_getstate, __pyx_k_getstate, sizeof(__pyx_k_getstate), 0, 0, 1, 1},
-  {&__pyx_n_s_group, __pyx_k_group, sizeof(__pyx_k_group), 0, 0, 1, 1},
-  {&__pyx_n_s_import, __pyx_k_import, sizeof(__pyx_k_import), 0, 0, 1, 1},
-  {&__pyx_n_s_index, __pyx_k_index, sizeof(__pyx_k_index), 0, 0, 1, 1},
-  {&__pyx_n_s_info, __pyx_k_info, sizeof(__pyx_k_info), 0, 0, 1, 1},
-  {&__pyx_kp_u_is_no_available_algorithm, __pyx_k_is_no_available_algorithm, sizeof(__pyx_k_is_no_available_algorithm), 0, 1, 0, 0},
-  {&__pyx_n_s_items, __pyx_k_items, sizeof(__pyx_k_items), 0, 0, 1, 1},
-  {&__pyx_n_s_kwarg2param, __pyx_k_kwarg2param, sizeof(__pyx_k_kwarg2param), 0, 0, 1, 1},
-  {&__pyx_n_b_l2sgd, __pyx_k_l2sgd, sizeof(__pyx_k_l2sgd), 0, 0, 0, 1},
-  {&__pyx_n_s_l2sgd, __pyx_k_l2sgd, sizeof(__pyx_k_l2sgd), 0, 0, 1, 1},
-  {&__pyx_n_b_lCRF, __pyx_k_lCRF, sizeof(__pyx_k_lCRF), 0, 0, 0, 1},
-  {&__pyx_n_s_label, __pyx_k_label, sizeof(__pyx_k_label), 0, 0, 1, 1},
-  {&__pyx_n_s_labels, __pyx_k_labels, sizeof(__pyx_k_labels), 0, 0, 1, 1},
-  {&__pyx_n_s_lbfgs, __pyx_k_lbfgs, sizeof(__pyx_k_lbfgs), 0, 0, 1, 1},
-  {&__pyx_kp_s_limited_memory_bfgs, __pyx_k_limited_memory_bfgs, sizeof(__pyx_k_limited_memory_bfgs), 0, 0, 1, 0},
-  {&__pyx_n_s_linesearch, __pyx_k_linesearch, sizeof(__pyx_k_linesearch), 0, 0, 1, 1},
-  {&__pyx_n_s_load, __pyx_k_load, sizeof(__pyx_k_load), 0, 0, 1, 1},
-  {&__pyx_n_s_log, __pyx_k_log, sizeof(__pyx_k_log), 0, 0, 1, 1},
-  {&__pyx_n_s_lower, __pyx_k_lower, sizeof(__pyx_k_lower), 0, 0, 1, 1},
-  {&__pyx_n_s_magic, __pyx_k_magic, sizeof(__pyx_k_magic), 0, 0, 1, 1},
-  {&__pyx_n_s_main, __pyx_k_main, sizeof(__pyx_k_main), 0, 0, 1, 1},
-  {&__pyx_n_s_marginal, __pyx_k_marginal, sizeof(__pyx_k_marginal), 0, 0, 1, 1},
-  {&__pyx_n_s_max_iterations, __pyx_k_max_iterations, sizeof(__pyx_k_max_iterations), 0, 0, 1, 1},
-  {&__pyx_n_s_max_linesearch, __pyx_k_max_linesearch, sizeof(__pyx_k_max_linesearch), 0, 0, 1, 1},
-  {&__pyx_n_s_min_freq, __pyx_k_min_freq, sizeof(__pyx_k_min_freq), 0, 0, 1, 1},
-  {&__pyx_n_s_model, __pyx_k_model, sizeof(__pyx_k_model), 0, 0, 1, 1},
-  {&__pyx_n_s_model_filepath, __pyx_k_model_filepath, sizeof(__pyx_k_model_filepath), 0, 0, 1, 1},
-  {&__pyx_n_s_name, __pyx_k_name, sizeof(__pyx_k_name), 0, 0, 1, 1},
-  {&__pyx_kp_s_no_default___reduce___due_to_non, __pyx_k_no_default___reduce___due_to_non, sizeof(__pyx_k_no_default___reduce___due_to_non), 0, 0, 1, 0},
-  {&__pyx_n_s_num_memories, __pyx_k_num_memories, sizeof(__pyx_k_num_memories), 0, 0, 1, 1},
-  {&__pyx_n_s_open, __pyx_k_open, sizeof(__pyx_k_open), 0, 0, 1, 1},
-  {&__pyx_n_s_os, __pyx_k_os, sizeof(__pyx_k_os), 0, 0, 1, 1},
-  {&__pyx_n_s_pa, __pyx_k_pa, sizeof(__pyx_k_pa), 0, 0, 1, 1},
-  {&__pyx_n_s_pa_type, __pyx_k_pa_type, sizeof(__pyx_k_pa_type), 0, 0, 1, 1},
-  {&__pyx_n_s_param, __pyx_k_param, sizeof(__pyx_k_param), 0, 0, 1, 1},
-  {&__pyx_n_s_param2kwarg, __pyx_k_param2kwarg, sizeof(__pyx_k_param2kwarg), 0, 0, 1, 1},
-  {&__pyx_n_s_parameter_types, __pyx_k_parameter_types, sizeof(__pyx_k_parameter_types), 0, 0, 1, 1},
-  {&__pyx_kp_s_passive_aggressive, __pyx_k_passive_aggressive, sizeof(__pyx_k_passive_aggressive), 0, 0, 1, 0},
-  {&__pyx_n_s_period, __pyx_k_period, sizeof(__pyx_k_period), 0, 0, 1, 1},
-  {&__pyx_n_s_pyx_vtable, __pyx_k_pyx_vtable, sizeof(__pyx_k_pyx_vtable), 0, 0, 1, 1},
-  {&__pyx_n_s_range, __pyx_k_range, sizeof(__pyx_k_range), 0, 0, 1, 1},
-  {&__pyx_n_s_rb, __pyx_k_rb, sizeof(__pyx_k_rb), 0, 0, 1, 1},
-  {&__pyx_n_s_read, __pyx_k_read, sizeof(__pyx_k_read), 0, 0, 1, 1},
-  {&__pyx_n_s_reduce, __pyx_k_reduce, sizeof(__pyx_k_reduce), 0, 0, 1, 1},
-  {&__pyx_n_s_reduce_cython, __pyx_k_reduce_cython, sizeof(__pyx_k_reduce_cython), 0, 0, 1, 1},
-  {&__pyx_n_s_reduce_ex, __pyx_k_reduce_ex, sizeof(__pyx_k_reduce_ex), 0, 0, 1, 1},
-  {&__pyx_n_s_seek, __pyx_k_seek, sizeof(__pyx_k_seek), 0, 0, 1, 1},
-  {&__pyx_n_s_select_algorithm, __pyx_k_select_algorithm, sizeof(__pyx_k_select_algorithm), 0, 0, 1, 1},
-  {&__pyx_kp_s_self__tagger_cannot_be_converted, __pyx_k_self__tagger_cannot_be_converted, sizeof(__pyx_k_self__tagger_cannot_be_converted), 0, 0, 1, 0},
-  {&__pyx_kp_s_self_c_sequence_cannot_be_conver, __pyx_k_self_c_sequence_cannot_be_conver, sizeof(__pyx_k_self_c_sequence_cannot_be_conver), 0, 0, 1, 0},
-  {&__pyx_n_s_sequence, __pyx_k_sequence, sizeof(__pyx_k_sequence), 0, 0, 1, 1},
-  {&__pyx_n_s_set_param, __pyx_k_set_param, sizeof(__pyx_k_set_param), 0, 0, 1, 1},
-  {&__pyx_n_s_set_params, __pyx_k_set_params, sizeof(__pyx_k_set_params), 0, 0, 1, 1},
-  {&__pyx_n_s_set_sequence, __pyx_k_set_sequence, sizeof(__pyx_k_set_sequence), 0, 0, 1, 1},
-  {&__pyx_n_s_setstate, __pyx_k_setstate, sizeof(__pyx_k_setstate), 0, 0, 1, 1},
-  {&__pyx_n_s_setstate_cython, __pyx_k_setstate_cython, sizeof(__pyx_k_setstate_cython), 0, 0, 1, 1},
-  {&__pyx_n_s_sgd, __pyx_k_sgd, sizeof(__pyx_k_sgd), 0, 0, 1, 1},
-  {&__pyx_n_s_staticmethod, __pyx_k_staticmethod, sizeof(__pyx_k_staticmethod), 0, 0, 1, 1},
-  {&__pyx_kp_s_stochastic_gradient_descent, __pyx_k_stochastic_gradient_descent, sizeof(__pyx_k_stochastic_gradient_descent), 0, 0, 1, 0},
-  {&__pyx_n_s_tell, __pyx_k_tell, sizeof(__pyx_k_tell), 0, 0, 1, 1},
-  {&__pyx_n_s_test, __pyx_k_test, sizeof(__pyx_k_test), 0, 0, 1, 1},
-  {&__pyx_n_s_translate_params, __pyx_k_translate_params, sizeof(__pyx_k_translate_params), 0, 0, 1, 1},
-  {&__pyx_n_s_type, __pyx_k_type, sizeof(__pyx_k_type), 0, 0, 1, 1},
-  {&__pyx_n_s_value, __pyx_k_value, sizeof(__pyx_k_value), 0, 0, 1, 1},
-  {&__pyx_n_s_variance, __pyx_k_variance, sizeof(__pyx_k_variance), 0, 0, 1, 1},
-  {0, 0, 0, 0, 0, 0, 0}
-};
-static CYTHON_SMALL_CODE int __Pyx_InitCachedBuiltins(void) {
-  __pyx_builtin_staticmethod = __Pyx_GetBuiltinName(__pyx_n_s_staticmethod); if (!__pyx_builtin_staticmethod) __PYX_ERR(0, 178, __pyx_L1_error)
-  __pyx_builtin_ValueError = __Pyx_GetBuiltinName(__pyx_n_s_ValueError); if (!__pyx_builtin_ValueError) __PYX_ERR(0, 123, __pyx_L1_error)
-  __pyx_builtin_TypeError = __Pyx_GetBuiltinName(__pyx_n_s_TypeError); if (!__pyx_builtin_TypeError) __PYX_ERR(1, 2, __pyx_L1_error)
-  __pyx_builtin_range = __Pyx_GetBuiltinName(__pyx_n_s_range); if (!__pyx_builtin_range) __PYX_ERR(0, 163, __pyx_L1_error)
-  __pyx_builtin_open = __Pyx_GetBuiltinName(__pyx_n_s_open); if (!__pyx_builtin_open) __PYX_ERR(0, 180, __pyx_L1_error)
-  return 0;
-  __pyx_L1_error:;
-  return -1;
-}
-
-static CYTHON_SMALL_CODE int __Pyx_InitCachedConstants(void) {
-  __Pyx_RefNannyDeclarations
-  __Pyx_RefNannySetupContext("__Pyx_InitCachedConstants", 0);
-
-  /* "(tree fragment)":2
- * def __reduce_cython__(self):
- *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
- * def __setstate_cython__(self, __pyx_state):
- *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
- */
-  __pyx_tuple_ = PyTuple_Pack(1, __pyx_kp_s_no_default___reduce___due_to_non); if (unlikely(!__pyx_tuple_)) __PYX_ERR(1, 2, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple_);
-  __Pyx_GIVEREF(__pyx_tuple_);
-
-  /* "(tree fragment)":4
- *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
- * def __setstate_cython__(self, __pyx_state):
- *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
- */
-  __pyx_tuple__2 = PyTuple_Pack(1, __pyx_kp_s_no_default___reduce___due_to_non); if (unlikely(!__pyx_tuple__2)) __PYX_ERR(1, 4, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__2);
-  __Pyx_GIVEREF(__pyx_tuple__2);
-
-  /* "crf.pyx":180
- *     @staticmethod
- *     def check_model(filepath: str):
- *         with open(filepath, "rb") as model:             # <<<<<<<<<<<<<<
- *             magic = model.read(4)
- *             if magic != b"lCRF":
- */
-  __pyx_tuple__3 = PyTuple_Pack(3, Py_None, Py_None, Py_None); if (unlikely(!__pyx_tuple__3)) __PYX_ERR(0, 180, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__3);
-  __Pyx_GIVEREF(__pyx_tuple__3);
-
-  /* "(tree fragment)":2
- * def __reduce_cython__(self):
- *     raise TypeError("self._tagger cannot be converted to a Python object for pickling")             # <<<<<<<<<<<<<<
- * def __setstate_cython__(self, __pyx_state):
- *     raise TypeError("self._tagger cannot be converted to a Python object for pickling")
- */
-  __pyx_tuple__4 = PyTuple_Pack(1, __pyx_kp_s_self__tagger_cannot_be_converted); if (unlikely(!__pyx_tuple__4)) __PYX_ERR(1, 2, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__4);
-  __Pyx_GIVEREF(__pyx_tuple__4);
-
-  /* "(tree fragment)":4
- *     raise TypeError("self._tagger cannot be converted to a Python object for pickling")
- * def __setstate_cython__(self, __pyx_state):
- *     raise TypeError("self._tagger cannot be converted to a Python object for pickling")             # <<<<<<<<<<<<<<
- */
-  __pyx_tuple__5 = PyTuple_Pack(1, __pyx_kp_s_self__tagger_cannot_be_converted); if (unlikely(!__pyx_tuple__5)) __PYX_ERR(1, 4, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__5);
-  __Pyx_GIVEREF(__pyx_tuple__5);
-
-  /* "(tree fragment)":2
- * def __reduce_cython__(self):
- *     raise TypeError("self.c_sequence cannot be converted to a Python object for pickling")             # <<<<<<<<<<<<<<
- * def __setstate_cython__(self, __pyx_state):
- *     raise TypeError("self.c_sequence cannot be converted to a Python object for pickling")
- */
-  __pyx_tuple__8 = PyTuple_Pack(1, __pyx_kp_s_self_c_sequence_cannot_be_conver); if (unlikely(!__pyx_tuple__8)) __PYX_ERR(1, 2, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__8);
-  __Pyx_GIVEREF(__pyx_tuple__8);
-
-  /* "(tree fragment)":4
- *     raise TypeError("self.c_sequence cannot be converted to a Python object for pickling")
- * def __setstate_cython__(self, __pyx_state):
- *     raise TypeError("self.c_sequence cannot be converted to a Python object for pickling")             # <<<<<<<<<<<<<<
- */
-  __pyx_tuple__9 = PyTuple_Pack(1, __pyx_kp_s_self_c_sequence_cannot_be_conver); if (unlikely(!__pyx_tuple__9)) __PYX_ERR(1, 4, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__9);
-  __Pyx_GIVEREF(__pyx_tuple__9);
-
-  /* "crf.pyx":179
- * 
- *     @staticmethod
- *     def check_model(filepath: str):             # <<<<<<<<<<<<<<
- *         with open(filepath, "rb") as model:
- *             magic = model.read(4)
- */
-  __pyx_tuple__10 = PyTuple_Pack(3, __pyx_n_s_filepath, __pyx_n_s_model, __pyx_n_s_magic); if (unlikely(!__pyx_tuple__10)) __PYX_ERR(0, 179, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__10);
-  __Pyx_GIVEREF(__pyx_tuple__10);
-  __pyx_codeobj__11 = (PyObject*)__Pyx_PyCode_New(1, 0, 3, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__10, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_chaine__core_crf_pyx, __pyx_n_s_check_model, 179, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__11)) __PYX_ERR(0, 179, __pyx_L1_error)
-  __Pyx_RefNannyFinishContext();
-  return 0;
-  __pyx_L1_error:;
-  __Pyx_RefNannyFinishContext();
-  return -1;
-}
-
-static CYTHON_SMALL_CODE int __Pyx_InitGlobals(void) {
-  __pyx_umethod_PyString_Type_lower.type = (PyObject*)&PyString_Type;
-  if (__Pyx_InitStrings(__pyx_string_tab) < 0) __PYX_ERR(0, 1, __pyx_L1_error);
-  __pyx_int_0 = PyInt_FromLong(0); if (unlikely(!__pyx_int_0)) __PYX_ERR(0, 1, __pyx_L1_error)
-  __pyx_int_4 = PyInt_FromLong(4); if (unlikely(!__pyx_int_4)) __PYX_ERR(0, 1, __pyx_L1_error)
-  __pyx_int_48 = PyInt_FromLong(48); if (unlikely(!__pyx_int_48)) __PYX_ERR(0, 1, __pyx_L1_error)
-  return 0;
-  __pyx_L1_error:;
-  return -1;
-}
-
-static CYTHON_SMALL_CODE int __Pyx_modinit_global_init_code(void); /*proto*/
-static CYTHON_SMALL_CODE int __Pyx_modinit_variable_export_code(void); /*proto*/
-static CYTHON_SMALL_CODE int __Pyx_modinit_function_export_code(void); /*proto*/
-static CYTHON_SMALL_CODE int __Pyx_modinit_type_init_code(void); /*proto*/
-static CYTHON_SMALL_CODE int __Pyx_modinit_type_import_code(void); /*proto*/
-static CYTHON_SMALL_CODE int __Pyx_modinit_variable_import_code(void); /*proto*/
-static CYTHON_SMALL_CODE int __Pyx_modinit_function_import_code(void); /*proto*/
-
-static int __Pyx_modinit_global_init_code(void) {
-  __Pyx_RefNannyDeclarations
-  __Pyx_RefNannySetupContext("__Pyx_modinit_global_init_code", 0);
-  /*--- Global init code ---*/
-  __Pyx_RefNannyFinishContext();
-  return 0;
-}
-
-static int __Pyx_modinit_variable_export_code(void) {
-  __Pyx_RefNannyDeclarations
-  __Pyx_RefNannySetupContext("__Pyx_modinit_variable_export_code", 0);
-  /*--- Variable export code ---*/
-  __Pyx_RefNannyFinishContext();
-  return 0;
-}
-
-static int __Pyx_modinit_function_export_code(void) {
-  __Pyx_RefNannyDeclarations
-  __Pyx_RefNannySetupContext("__Pyx_modinit_function_export_code", 0);
-  /*--- Function export code ---*/
-  __Pyx_RefNannyFinishContext();
-  return 0;
-}
-
-static int __Pyx_modinit_type_init_code(void) {
-  __Pyx_RefNannyDeclarations
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("__Pyx_modinit_type_init_code", 0);
-  /*--- Type init code ---*/
-  __pyx_vtabptr_3crf_Trainer = &__pyx_vtable_3crf_Trainer;
-  __pyx_vtable_3crf_Trainer._on_message = (PyObject *(*)(struct __pyx_obj_3crf_Trainer *, std::string))__pyx_f_3crf_7Trainer__on_message;
-  if (PyType_Ready(&__pyx_type_3crf_Trainer) < 0) __PYX_ERR(0, 18, __pyx_L1_error)
-  #if PY_VERSION_HEX < 0x030800B1
-  __pyx_type_3crf_Trainer.tp_print = 0;
-  #endif
-  if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_type_3crf_Trainer.tp_dictoffset && __pyx_type_3crf_Trainer.tp_getattro == PyObject_GenericGetAttr)) {
-    __pyx_type_3crf_Trainer.tp_getattro = __Pyx_PyObject_GenericGetAttr;
-  }
-  if (__Pyx_SetVtable(__pyx_type_3crf_Trainer.tp_dict, __pyx_vtabptr_3crf_Trainer) < 0) __PYX_ERR(0, 18, __pyx_L1_error)
-  if (PyObject_SetAttr(__pyx_m, __pyx_n_s_Trainer, (PyObject *)&__pyx_type_3crf_Trainer) < 0) __PYX_ERR(0, 18, __pyx_L1_error)
-  if (__Pyx_setup_reduce((PyObject*)&__pyx_type_3crf_Trainer) < 0) __PYX_ERR(0, 18, __pyx_L1_error)
-  __pyx_ptype_3crf_Trainer = &__pyx_type_3crf_Trainer;
-  __pyx_vtabptr_3crf_Model = &__pyx_vtable_3crf_Model;
-  __pyx_vtable_3crf_Model.set_sequence = (PyObject *(*)(struct __pyx_obj_3crf_Model *, PyObject *, int __pyx_skip_dispatch))__pyx_f_3crf_5Model_set_sequence;
-  if (PyType_Ready(&__pyx_type_3crf_Model) < 0) __PYX_ERR(0, 145, __pyx_L1_error)
-  #if PY_VERSION_HEX < 0x030800B1
-  __pyx_type_3crf_Model.tp_print = 0;
-  #endif
-  if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_type_3crf_Model.tp_dictoffset && __pyx_type_3crf_Model.tp_getattro == PyObject_GenericGetAttr)) {
-    __pyx_type_3crf_Model.tp_getattro = __Pyx_PyObject_GenericGetAttr;
-  }
-  if (__Pyx_SetVtable(__pyx_type_3crf_Model.tp_dict, __pyx_vtabptr_3crf_Model) < 0) __PYX_ERR(0, 145, __pyx_L1_error)
-  if (PyObject_SetAttr(__pyx_m, __pyx_n_s_Model, (PyObject *)&__pyx_type_3crf_Model) < 0) __PYX_ERR(0, 145, __pyx_L1_error)
-  if (__Pyx_setup_reduce((PyObject*)&__pyx_type_3crf_Model) < 0) __PYX_ERR(0, 145, __pyx_L1_error)
-  __pyx_ptype_3crf_Model = &__pyx_type_3crf_Model;
-  if (PyType_Ready(&__pyx_type_3crf_ItemSequence) < 0) __PYX_ERR(0, 247, __pyx_L1_error)
-  #if PY_VERSION_HEX < 0x030800B1
-  __pyx_type_3crf_ItemSequence.tp_print = 0;
-  #endif
-  if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_type_3crf_ItemSequence.tp_dictoffset && __pyx_type_3crf_ItemSequence.tp_getattro == PyObject_GenericGetAttr)) {
-    __pyx_type_3crf_ItemSequence.tp_getattro = __Pyx_PyObject_GenericGetAttr;
-  }
-  if (PyObject_SetAttr(__pyx_m, __pyx_n_s_ItemSequence_2, (PyObject *)&__pyx_type_3crf_ItemSequence) < 0) __PYX_ERR(0, 247, __pyx_L1_error)
-  if (__Pyx_setup_reduce((PyObject*)&__pyx_type_3crf_ItemSequence) < 0) __PYX_ERR(0, 247, __pyx_L1_error)
-  __pyx_ptype_3crf_ItemSequence = &__pyx_type_3crf_ItemSequence;
-  __Pyx_RefNannyFinishContext();
-  return 0;
-  __pyx_L1_error:;
-  __Pyx_RefNannyFinishContext();
-  return -1;
-}
-
-static int __Pyx_modinit_type_import_code(void) {
-  __Pyx_RefNannyDeclarations
-  __Pyx_RefNannySetupContext("__Pyx_modinit_type_import_code", 0);
-  /*--- Type import code ---*/
-  __Pyx_RefNannyFinishContext();
-  return 0;
-}
-
-static int __Pyx_modinit_variable_import_code(void) {
-  __Pyx_RefNannyDeclarations
-  __Pyx_RefNannySetupContext("__Pyx_modinit_variable_import_code", 0);
-  /*--- Variable import code ---*/
-  __Pyx_RefNannyFinishContext();
-  return 0;
-}
-
-static int __Pyx_modinit_function_import_code(void) {
-  __Pyx_RefNannyDeclarations
-  __Pyx_RefNannySetupContext("__Pyx_modinit_function_import_code", 0);
-  /*--- Function import code ---*/
-  __Pyx_RefNannyFinishContext();
-  return 0;
-}
-
-
-#ifndef CYTHON_NO_PYINIT_EXPORT
-#define __Pyx_PyMODINIT_FUNC PyMODINIT_FUNC
-#elif PY_MAJOR_VERSION < 3
-#ifdef __cplusplus
-#define __Pyx_PyMODINIT_FUNC extern "C" void
-#else
-#define __Pyx_PyMODINIT_FUNC void
-#endif
-#else
-#ifdef __cplusplus
-#define __Pyx_PyMODINIT_FUNC extern "C" PyObject *
-#else
-#define __Pyx_PyMODINIT_FUNC PyObject *
-#endif
-#endif
-
-
-#if PY_MAJOR_VERSION < 3
-__Pyx_PyMODINIT_FUNC initcrf(void) CYTHON_SMALL_CODE; /*proto*/
-__Pyx_PyMODINIT_FUNC initcrf(void)
-#else
-__Pyx_PyMODINIT_FUNC PyInit_crf(void) CYTHON_SMALL_CODE; /*proto*/
-__Pyx_PyMODINIT_FUNC PyInit_crf(void)
-#if CYTHON_PEP489_MULTI_PHASE_INIT
-{
-  return PyModuleDef_Init(&__pyx_moduledef);
-}
-static CYTHON_SMALL_CODE int __Pyx_check_single_interpreter(void) {
-    #if PY_VERSION_HEX >= 0x030700A1
-    static PY_INT64_T main_interpreter_id = -1;
-    PY_INT64_T current_id = PyInterpreterState_GetID(PyThreadState_Get()->interp);
-    if (main_interpreter_id == -1) {
-        main_interpreter_id = current_id;
-        return (unlikely(current_id == -1)) ? -1 : 0;
-    } else if (unlikely(main_interpreter_id != current_id))
-    #else
-    static PyInterpreterState *main_interpreter = NULL;
-    PyInterpreterState *current_interpreter = PyThreadState_Get()->interp;
-    if (!main_interpreter) {
-        main_interpreter = current_interpreter;
-    } else if (unlikely(main_interpreter != current_interpreter))
-    #endif
-    {
-        PyErr_SetString(
-            PyExc_ImportError,
-            "Interpreter change detected - this module can only be loaded into one interpreter per process.");
-        return -1;
-    }
-    return 0;
-}
-static CYTHON_SMALL_CODE int __Pyx_copy_spec_to_module(PyObject *spec, PyObject *moddict, const char* from_name, const char* to_name, int allow_none) {
-    PyObject *value = PyObject_GetAttrString(spec, from_name);
-    int result = 0;
-    if (likely(value)) {
-        if (allow_none || value != Py_None) {
-            result = PyDict_SetItemString(moddict, to_name, value);
-        }
-        Py_DECREF(value);
-    } else if (PyErr_ExceptionMatches(PyExc_AttributeError)) {
-        PyErr_Clear();
-    } else {
-        result = -1;
-    }
-    return result;
-}
-static CYTHON_SMALL_CODE PyObject* __pyx_pymod_create(PyObject *spec, CYTHON_UNUSED PyModuleDef *def) {
-    PyObject *module = NULL, *moddict, *modname;
-    if (__Pyx_check_single_interpreter())
-        return NULL;
-    if (__pyx_m)
-        return __Pyx_NewRef(__pyx_m);
-    modname = PyObject_GetAttrString(spec, "name");
-    if (unlikely(!modname)) goto bad;
-    module = PyModule_NewObject(modname);
-    Py_DECREF(modname);
-    if (unlikely(!module)) goto bad;
-    moddict = PyModule_GetDict(module);
-    if (unlikely(!moddict)) goto bad;
-    if (unlikely(__Pyx_copy_spec_to_module(spec, moddict, "loader", "__loader__", 1) < 0)) goto bad;
-    if (unlikely(__Pyx_copy_spec_to_module(spec, moddict, "origin", "__file__", 1) < 0)) goto bad;
-    if (unlikely(__Pyx_copy_spec_to_module(spec, moddict, "parent", "__package__", 1) < 0)) goto bad;
-    if (unlikely(__Pyx_copy_spec_to_module(spec, moddict, "submodule_search_locations", "__path__", 0) < 0)) goto bad;
-    return module;
-bad:
-    Py_XDECREF(module);
-    return NULL;
-}
-
-
-static CYTHON_SMALL_CODE int __pyx_pymod_exec_crf(PyObject *__pyx_pyinit_module)
-#endif
-#endif
-{
-  PyObject *__pyx_t_1 = NULL;
-  PyObject *__pyx_t_2 = NULL;
-  PyObject *__pyx_t_3 = NULL;
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-  __Pyx_RefNannyDeclarations
-  #if CYTHON_PEP489_MULTI_PHASE_INIT
-  if (__pyx_m) {
-    if (__pyx_m == __pyx_pyinit_module) return 0;
-    PyErr_SetString(PyExc_RuntimeError, "Module 'crf' has already been imported. Re-initialisation is not supported.");
-    return -1;
-  }
-  #elif PY_MAJOR_VERSION >= 3
-  if (__pyx_m) return __Pyx_NewRef(__pyx_m);
-  #endif
-  #if CYTHON_REFNANNY
-__Pyx_RefNanny = __Pyx_RefNannyImportAPI("refnanny");
-if (!__Pyx_RefNanny) {
-  PyErr_Clear();
-  __Pyx_RefNanny = __Pyx_RefNannyImportAPI("Cython.Runtime.refnanny");
-  if (!__Pyx_RefNanny)
-      Py_FatalError("failed to import 'refnanny' module");
-}
-#endif
-  __Pyx_RefNannySetupContext("__Pyx_PyMODINIT_FUNC PyInit_crf(void)", 0);
-  if (__Pyx_check_binary_version() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
-  #ifdef __Pxy_PyFrame_Initialize_Offsets
-  __Pxy_PyFrame_Initialize_Offsets();
-  #endif
-  __pyx_empty_tuple = PyTuple_New(0); if (unlikely(!__pyx_empty_tuple)) __PYX_ERR(0, 1, __pyx_L1_error)
-  __pyx_empty_bytes = PyBytes_FromStringAndSize("", 0); if (unlikely(!__pyx_empty_bytes)) __PYX_ERR(0, 1, __pyx_L1_error)
-  __pyx_empty_unicode = PyUnicode_FromStringAndSize("", 0); if (unlikely(!__pyx_empty_unicode)) __PYX_ERR(0, 1, __pyx_L1_error)
-  #ifdef __Pyx_CyFunction_USED
-  if (__pyx_CyFunction_init() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
-  #endif
-  #ifdef __Pyx_FusedFunction_USED
-  if (__pyx_FusedFunction_init() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
-  #endif
-  #ifdef __Pyx_Coroutine_USED
-  if (__pyx_Coroutine_init() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
-  #endif
-  #ifdef __Pyx_Generator_USED
-  if (__pyx_Generator_init() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
-  #endif
-  #ifdef __Pyx_AsyncGen_USED
-  if (__pyx_AsyncGen_init() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
-  #endif
-  #ifdef __Pyx_StopAsyncIteration_USED
-  if (__pyx_StopAsyncIteration_init() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
-  #endif
-  /*--- Library function declarations ---*/
-  /*--- Threads initialization code ---*/
-  #if defined(WITH_THREAD) && PY_VERSION_HEX < 0x030700F0 && defined(__PYX_FORCE_INIT_THREADS) && __PYX_FORCE_INIT_THREADS
-  PyEval_InitThreads();
-  #endif
-  /*--- Module creation code ---*/
-  #if CYTHON_PEP489_MULTI_PHASE_INIT
-  __pyx_m = __pyx_pyinit_module;
-  Py_INCREF(__pyx_m);
-  #else
-  #if PY_MAJOR_VERSION < 3
-  __pyx_m = Py_InitModule4("crf", __pyx_methods, 0, 0, PYTHON_API_VERSION); Py_XINCREF(__pyx_m);
-  #else
-  __pyx_m = PyModule_Create(&__pyx_moduledef);
-  #endif
-  if (unlikely(!__pyx_m)) __PYX_ERR(0, 1, __pyx_L1_error)
-  #endif
-  __pyx_d = PyModule_GetDict(__pyx_m); if (unlikely(!__pyx_d)) __PYX_ERR(0, 1, __pyx_L1_error)
-  Py_INCREF(__pyx_d);
-  __pyx_b = PyImport_AddModule(__Pyx_BUILTIN_MODULE_NAME); if (unlikely(!__pyx_b)) __PYX_ERR(0, 1, __pyx_L1_error)
-  Py_INCREF(__pyx_b);
-  __pyx_cython_runtime = PyImport_AddModule((char *) "cython_runtime"); if (unlikely(!__pyx_cython_runtime)) __PYX_ERR(0, 1, __pyx_L1_error)
-  Py_INCREF(__pyx_cython_runtime);
-  if (PyObject_SetAttrString(__pyx_m, "__builtins__", __pyx_b) < 0) __PYX_ERR(0, 1, __pyx_L1_error);
-  /*--- Initialize various global constants etc. ---*/
-  if (__Pyx_InitGlobals() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
-  #if PY_MAJOR_VERSION < 3 && (__PYX_DEFAULT_STRING_ENCODING_IS_ASCII || __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT)
-  if (__Pyx_init_sys_getdefaultencoding_params() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
-  #endif
-  if (__pyx_module_is_main_crf) {
-    if (PyObject_SetAttr(__pyx_m, __pyx_n_s_name, __pyx_n_s_main) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
-  }
-  #if PY_MAJOR_VERSION >= 3
-  {
-    PyObject *modules = PyImport_GetModuleDict(); if (unlikely(!modules)) __PYX_ERR(0, 1, __pyx_L1_error)
-    if (!PyDict_GetItemString(modules, "crf")) {
-      if (unlikely(PyDict_SetItemString(modules, "crf", __pyx_m) < 0)) __PYX_ERR(0, 1, __pyx_L1_error)
-    }
-  }
-  #endif
-  /*--- Builtin init code ---*/
-  if (__Pyx_InitCachedBuiltins() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
-  /*--- Constants init code ---*/
-  if (__Pyx_InitCachedConstants() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
-  /*--- Global type/function init code ---*/
-  (void)__Pyx_modinit_global_init_code();
-  (void)__Pyx_modinit_variable_export_code();
-  (void)__Pyx_modinit_function_export_code();
-  if (unlikely(__Pyx_modinit_type_init_code() < 0)) __PYX_ERR(0, 1, __pyx_L1_error)
-  (void)__Pyx_modinit_type_import_code();
-  (void)__Pyx_modinit_variable_import_code();
-  (void)__Pyx_modinit_function_import_code();
-  /*--- Execution code ---*/
-  #if defined(__Pyx_Generator_USED) || defined(__Pyx_Coroutine_USED)
-  if (__Pyx_patch_abc() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
-  #endif
-
-  /* "crf.pyx":10
- * cimport crfsuite_api
- * from libcpp.string cimport string
- * import os             # <<<<<<<<<<<<<<
- * 
- * from chaine.logging import Logger
- */
-  __pyx_t_1 = __Pyx_Import(__pyx_n_s_os, 0, -1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 10, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_os, __pyx_t_1) < 0) __PYX_ERR(0, 10, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-
-  /* "crf.pyx":12
- * import os
- * 
- * from chaine.logging import Logger             # <<<<<<<<<<<<<<
- * from chaine.typing import Filepath, Labels, Sequence
- * 
- */
-  __pyx_t_1 = PyList_New(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 12, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __Pyx_INCREF(__pyx_n_s_Logger);
-  __Pyx_GIVEREF(__pyx_n_s_Logger);
-  PyList_SET_ITEM(__pyx_t_1, 0, __pyx_n_s_Logger);
-  __pyx_t_2 = __Pyx_Import(__pyx_n_s_chaine_logging, __pyx_t_1, -1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 12, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_t_1 = __Pyx_ImportFrom(__pyx_t_2, __pyx_n_s_Logger); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 12, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_Logger, __pyx_t_1) < 0) __PYX_ERR(0, 12, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-
-  /* "crf.pyx":13
- * 
- * from chaine.logging import Logger
- * from chaine.typing import Filepath, Labels, Sequence             # <<<<<<<<<<<<<<
- * 
- * LOGGER = Logger(__name__)
- */
-  __pyx_t_2 = PyList_New(3); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 13, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  __Pyx_INCREF(__pyx_n_s_Filepath);
-  __Pyx_GIVEREF(__pyx_n_s_Filepath);
-  PyList_SET_ITEM(__pyx_t_2, 0, __pyx_n_s_Filepath);
-  __Pyx_INCREF(__pyx_n_s_Labels);
-  __Pyx_GIVEREF(__pyx_n_s_Labels);
-  PyList_SET_ITEM(__pyx_t_2, 1, __pyx_n_s_Labels);
-  __Pyx_INCREF(__pyx_n_s_Sequence);
-  __Pyx_GIVEREF(__pyx_n_s_Sequence);
-  PyList_SET_ITEM(__pyx_t_2, 2, __pyx_n_s_Sequence);
-  __pyx_t_1 = __Pyx_Import(__pyx_n_s_chaine_typing, __pyx_t_2, -1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 13, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_t_2 = __Pyx_ImportFrom(__pyx_t_1, __pyx_n_s_Filepath); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 13, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_Filepath, __pyx_t_2) < 0) __PYX_ERR(0, 13, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_t_2 = __Pyx_ImportFrom(__pyx_t_1, __pyx_n_s_Labels); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 13, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_Labels, __pyx_t_2) < 0) __PYX_ERR(0, 13, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_t_2 = __Pyx_ImportFrom(__pyx_t_1, __pyx_n_s_Sequence); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 13, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_Sequence, __pyx_t_2) < 0) __PYX_ERR(0, 13, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-
-  /* "crf.pyx":15
- * from chaine.typing import Filepath, Labels, Sequence
- * 
- * LOGGER = Logger(__name__)             # <<<<<<<<<<<<<<
- * 
- * 
- */
-  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_Logger); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 15, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_name); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 15, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_3 = __Pyx_PyObject_CallOneArg(__pyx_t_1, __pyx_t_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 15, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_LOGGER, __pyx_t_3) < 0) __PYX_ERR(0, 15, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-
-  /* "crf.pyx":22
- * 
- *     param2kwarg = {
- *         "feature.minfreq": "min_freq",             # <<<<<<<<<<<<<<
- *         "feature.possible_states": "all_possible_states",
- *         "feature.possible_transitions": "all_possible_transitions",
- */
-  __pyx_t_3 = __Pyx_PyDict_NewPresized(9); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 22, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  if (PyDict_SetItem(__pyx_t_3, __pyx_kp_s_feature_minfreq, __pyx_n_s_min_freq) < 0) __PYX_ERR(0, 22, __pyx_L1_error)
-  if (PyDict_SetItem(__pyx_t_3, __pyx_kp_s_feature_possible_states, __pyx_n_s_all_possible_states) < 0) __PYX_ERR(0, 22, __pyx_L1_error)
-  if (PyDict_SetItem(__pyx_t_3, __pyx_kp_s_feature_possible_transitions, __pyx_n_s_all_possible_transitions) < 0) __PYX_ERR(0, 22, __pyx_L1_error)
-  if (PyDict_SetItem(__pyx_t_3, __pyx_kp_s_calibration_eta, __pyx_n_s_calibration_eta_2) < 0) __PYX_ERR(0, 22, __pyx_L1_error)
-  if (PyDict_SetItem(__pyx_t_3, __pyx_kp_s_calibration_rate, __pyx_n_s_calibration_rate_2) < 0) __PYX_ERR(0, 22, __pyx_L1_error)
-  if (PyDict_SetItem(__pyx_t_3, __pyx_kp_s_calibration_samples, __pyx_n_s_calibration_samples_2) < 0) __PYX_ERR(0, 22, __pyx_L1_error)
-  if (PyDict_SetItem(__pyx_t_3, __pyx_kp_s_calibration_candidates, __pyx_n_s_calibration_candidates_2) < 0) __PYX_ERR(0, 22, __pyx_L1_error)
-  if (PyDict_SetItem(__pyx_t_3, __pyx_kp_s_calibration_max_trials, __pyx_n_s_calibration_max_trials_2) < 0) __PYX_ERR(0, 22, __pyx_L1_error)
-  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_type, __pyx_n_s_pa_type) < 0) __PYX_ERR(0, 22, __pyx_L1_error)
-  if (PyDict_SetItem((PyObject *)__pyx_ptype_3crf_Trainer->tp_dict, __pyx_n_s_param2kwarg, __pyx_t_3) < 0) __PYX_ERR(0, 21, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  PyType_Modified(__pyx_ptype_3crf_Trainer);
-
-  /* "crf.pyx":33
- *     }
- *     kwarg2param = {
- *         "min_freq": "feature.minfreq",             # <<<<<<<<<<<<<<
- *         "all_possible_states": "feature.possible_states",
- *         "all_possible_transitions": "feature.possible_transitions",
- */
-  __pyx_t_3 = __Pyx_PyDict_NewPresized(9); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 33, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_min_freq, __pyx_kp_s_feature_minfreq) < 0) __PYX_ERR(0, 33, __pyx_L1_error)
-  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_all_possible_states, __pyx_kp_s_feature_possible_states) < 0) __PYX_ERR(0, 33, __pyx_L1_error)
-  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_all_possible_transitions, __pyx_kp_s_feature_possible_transitions) < 0) __PYX_ERR(0, 33, __pyx_L1_error)
-  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_calibration_eta_2, __pyx_kp_s_calibration_eta) < 0) __PYX_ERR(0, 33, __pyx_L1_error)
-  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_calibration_rate_2, __pyx_kp_s_calibration_rate) < 0) __PYX_ERR(0, 33, __pyx_L1_error)
-  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_calibration_samples_2, __pyx_kp_s_calibration_samples) < 0) __PYX_ERR(0, 33, __pyx_L1_error)
-  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_calibration_candidates_2, __pyx_kp_s_calibration_candidates) < 0) __PYX_ERR(0, 33, __pyx_L1_error)
-  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_calibration_max_trials_2, __pyx_kp_s_calibration_max_trials) < 0) __PYX_ERR(0, 33, __pyx_L1_error)
-  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_pa_type, __pyx_n_s_type) < 0) __PYX_ERR(0, 33, __pyx_L1_error)
-  if (PyDict_SetItem((PyObject *)__pyx_ptype_3crf_Trainer->tp_dict, __pyx_n_s_kwarg2param, __pyx_t_3) < 0) __PYX_ERR(0, 32, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  PyType_Modified(__pyx_ptype_3crf_Trainer);
-
-  /* "crf.pyx":44
- *     }
- *     _algorithm_aliases = {
- *         "lbfgs": "lbfgs",             # <<<<<<<<<<<<<<
- *         "limited-memory-bfgs": "lbfgs",
- *         "l2sgd": "l2sgd",
- */
-  __pyx_t_3 = __Pyx_PyDict_NewPresized(10); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 44, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_lbfgs, __pyx_n_s_lbfgs) < 0) __PYX_ERR(0, 44, __pyx_L1_error)
-  if (PyDict_SetItem(__pyx_t_3, __pyx_kp_s_limited_memory_bfgs, __pyx_n_s_lbfgs) < 0) __PYX_ERR(0, 44, __pyx_L1_error)
-  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_l2sgd, __pyx_n_s_l2sgd) < 0) __PYX_ERR(0, 44, __pyx_L1_error)
-  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_sgd, __pyx_n_s_l2sgd) < 0) __PYX_ERR(0, 44, __pyx_L1_error)
-  if (PyDict_SetItem(__pyx_t_3, __pyx_kp_s_stochastic_gradient_descent, __pyx_n_s_l2sgd) < 0) __PYX_ERR(0, 44, __pyx_L1_error)
-  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_ap, __pyx_kp_s_averaged_perceptron) < 0) __PYX_ERR(0, 44, __pyx_L1_error)
-  if (PyDict_SetItem(__pyx_t_3, __pyx_kp_s_averaged_perceptron, __pyx_kp_s_averaged_perceptron) < 0) __PYX_ERR(0, 44, __pyx_L1_error)
-  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_pa, __pyx_kp_s_passive_aggressive) < 0) __PYX_ERR(0, 44, __pyx_L1_error)
-  if (PyDict_SetItem(__pyx_t_3, __pyx_kp_s_passive_aggressive, __pyx_kp_s_passive_aggressive) < 0) __PYX_ERR(0, 44, __pyx_L1_error)
-  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_arow, __pyx_n_s_arow) < 0) __PYX_ERR(0, 44, __pyx_L1_error)
-  if (PyDict_SetItem((PyObject *)__pyx_ptype_3crf_Trainer->tp_dict, __pyx_n_s_algorithm_aliases, __pyx_t_3) < 0) __PYX_ERR(0, 43, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  PyType_Modified(__pyx_ptype_3crf_Trainer);
-
-  /* "crf.pyx":56
- *     }
- *     _parameter_types = {
- *             "feature.minfreq": float,             # <<<<<<<<<<<<<<
- *             "feature.possible_states": lambda value: bool(int(value)),
- *             "feature.possible_transitions": lambda value: bool(int(value)),
- */
-  __pyx_t_3 = __Pyx_PyDict_NewPresized(23); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 56, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  if (PyDict_SetItem(__pyx_t_3, __pyx_kp_s_feature_minfreq, ((PyObject *)(&PyFloat_Type))) < 0) __PYX_ERR(0, 56, __pyx_L1_error)
-
-  /* "crf.pyx":57
- *     _parameter_types = {
- *             "feature.minfreq": float,
- *             "feature.possible_states": lambda value: bool(int(value)),             # <<<<<<<<<<<<<<
- *             "feature.possible_transitions": lambda value: bool(int(value)),
- *             "c1": float,
- */
-  __pyx_t_2 = __Pyx_CyFunction_New(&__pyx_mdef_3crf_7Trainer_22lambda, 0, __pyx_n_s_Trainer_lambda, NULL, __pyx_n_s_crf, __pyx_d, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 57, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  if (PyDict_SetItem(__pyx_t_3, __pyx_kp_s_feature_possible_states, __pyx_t_2) < 0) __PYX_ERR(0, 56, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-
-  /* "crf.pyx":58
- *             "feature.minfreq": float,
- *             "feature.possible_states": lambda value: bool(int(value)),
- *             "feature.possible_transitions": lambda value: bool(int(value)),             # <<<<<<<<<<<<<<
- *             "c1": float,
- *             "c2": float,
- */
-  __pyx_t_2 = __Pyx_CyFunction_New(&__pyx_mdef_3crf_7Trainer_23lambda1, 0, __pyx_n_s_Trainer_lambda, NULL, __pyx_n_s_crf, __pyx_d, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 58, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  if (PyDict_SetItem(__pyx_t_3, __pyx_kp_s_feature_possible_transitions, __pyx_t_2) < 0) __PYX_ERR(0, 56, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-
-  /* "crf.pyx":59
- *             "feature.possible_states": lambda value: bool(int(value)),
- *             "feature.possible_transitions": lambda value: bool(int(value)),
- *             "c1": float,             # <<<<<<<<<<<<<<
- *             "c2": float,
- *             "max_iterations": int,
- */
-  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_c1, ((PyObject *)(&PyFloat_Type))) < 0) __PYX_ERR(0, 56, __pyx_L1_error)
-
-  /* "crf.pyx":60
- *             "feature.possible_transitions": lambda value: bool(int(value)),
- *             "c1": float,
- *             "c2": float,             # <<<<<<<<<<<<<<
- *             "max_iterations": int,
- *             "num_memories": int,
- */
-  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_c2, ((PyObject *)(&PyFloat_Type))) < 0) __PYX_ERR(0, 56, __pyx_L1_error)
-
-  /* "crf.pyx":61
- *             "c1": float,
- *             "c2": float,
- *             "max_iterations": int,             # <<<<<<<<<<<<<<
- *             "num_memories": int,
- *             "epsilon": float,
- */
-  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_max_iterations, ((PyObject *)(&PyInt_Type))) < 0) __PYX_ERR(0, 56, __pyx_L1_error)
-
-  /* "crf.pyx":62
- *             "c2": float,
- *             "max_iterations": int,
- *             "num_memories": int,             # <<<<<<<<<<<<<<
- *             "epsilon": float,
- *             "period": int,
- */
-  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_num_memories, ((PyObject *)(&PyInt_Type))) < 0) __PYX_ERR(0, 56, __pyx_L1_error)
-
-  /* "crf.pyx":63
- *             "max_iterations": int,
- *             "num_memories": int,
- *             "epsilon": float,             # <<<<<<<<<<<<<<
- *             "period": int,
- *             "delta": float,
- */
-  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_epsilon, ((PyObject *)(&PyFloat_Type))) < 0) __PYX_ERR(0, 56, __pyx_L1_error)
-
-  /* "crf.pyx":64
- *             "num_memories": int,
- *             "epsilon": float,
- *             "period": int,             # <<<<<<<<<<<<<<
- *             "delta": float,
- *             "linesearch": str,
- */
-  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_period, ((PyObject *)(&PyInt_Type))) < 0) __PYX_ERR(0, 56, __pyx_L1_error)
-
-  /* "crf.pyx":65
- *             "epsilon": float,
- *             "period": int,
- *             "delta": float,             # <<<<<<<<<<<<<<
- *             "linesearch": str,
- *             "max_linesearch": int,
- */
-  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_delta, ((PyObject *)(&PyFloat_Type))) < 0) __PYX_ERR(0, 56, __pyx_L1_error)
-
-  /* "crf.pyx":66
- *             "period": int,
- *             "delta": float,
- *             "linesearch": str,             # <<<<<<<<<<<<<<
- *             "max_linesearch": int,
- *             "calibration.eta": float,
- */
-  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_linesearch, ((PyObject *)(&PyString_Type))) < 0) __PYX_ERR(0, 56, __pyx_L1_error)
-
-  /* "crf.pyx":67
- *             "delta": float,
- *             "linesearch": str,
- *             "max_linesearch": int,             # <<<<<<<<<<<<<<
- *             "calibration.eta": float,
- *             "calibration.rate": float,
- */
-  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_max_linesearch, ((PyObject *)(&PyInt_Type))) < 0) __PYX_ERR(0, 56, __pyx_L1_error)
-
-  /* "crf.pyx":68
- *             "linesearch": str,
- *             "max_linesearch": int,
- *             "calibration.eta": float,             # <<<<<<<<<<<<<<
- *             "calibration.rate": float,
- *             "calibration.samples": float,
- */
-  if (PyDict_SetItem(__pyx_t_3, __pyx_kp_s_calibration_eta, ((PyObject *)(&PyFloat_Type))) < 0) __PYX_ERR(0, 56, __pyx_L1_error)
-
-  /* "crf.pyx":69
- *             "max_linesearch": int,
- *             "calibration.eta": float,
- *             "calibration.rate": float,             # <<<<<<<<<<<<<<
- *             "calibration.samples": float,
- *             "calibration.candidates": int,
- */
-  if (PyDict_SetItem(__pyx_t_3, __pyx_kp_s_calibration_rate, ((PyObject *)(&PyFloat_Type))) < 0) __PYX_ERR(0, 56, __pyx_L1_error)
-
-  /* "crf.pyx":70
- *             "calibration.eta": float,
- *             "calibration.rate": float,
- *             "calibration.samples": float,             # <<<<<<<<<<<<<<
- *             "calibration.candidates": int,
- *             "calibration.max_trials": int,
- */
-  if (PyDict_SetItem(__pyx_t_3, __pyx_kp_s_calibration_samples, ((PyObject *)(&PyFloat_Type))) < 0) __PYX_ERR(0, 56, __pyx_L1_error)
-
-  /* "crf.pyx":71
- *             "calibration.rate": float,
- *             "calibration.samples": float,
- *             "calibration.candidates": int,             # <<<<<<<<<<<<<<
- *             "calibration.max_trials": int,
- *             "type": int,
- */
-  if (PyDict_SetItem(__pyx_t_3, __pyx_kp_s_calibration_candidates, ((PyObject *)(&PyInt_Type))) < 0) __PYX_ERR(0, 56, __pyx_L1_error)
-
-  /* "crf.pyx":72
- *             "calibration.samples": float,
- *             "calibration.candidates": int,
- *             "calibration.max_trials": int,             # <<<<<<<<<<<<<<
- *             "type": int,
- *             "c": float,
- */
-  if (PyDict_SetItem(__pyx_t_3, __pyx_kp_s_calibration_max_trials, ((PyObject *)(&PyInt_Type))) < 0) __PYX_ERR(0, 56, __pyx_L1_error)
-
-  /* "crf.pyx":73
- *             "calibration.candidates": int,
- *             "calibration.max_trials": int,
- *             "type": int,             # <<<<<<<<<<<<<<
- *             "c": float,
- *             "error_sensitive": lambda value: bool(int(value)),
- */
-  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_type, ((PyObject *)(&PyInt_Type))) < 0) __PYX_ERR(0, 56, __pyx_L1_error)
-
-  /* "crf.pyx":74
- *             "calibration.max_trials": int,
- *             "type": int,
- *             "c": float,             # <<<<<<<<<<<<<<
- *             "error_sensitive": lambda value: bool(int(value)),
- *             "averaging": lambda value: bool(int(value)),
- */
-  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_c, ((PyObject *)(&PyFloat_Type))) < 0) __PYX_ERR(0, 56, __pyx_L1_error)
-
-  /* "crf.pyx":75
- *             "type": int,
- *             "c": float,
- *             "error_sensitive": lambda value: bool(int(value)),             # <<<<<<<<<<<<<<
- *             "averaging": lambda value: bool(int(value)),
- *             "variance": float,
- */
-  __pyx_t_2 = __Pyx_CyFunction_New(&__pyx_mdef_3crf_7Trainer_24lambda2, 0, __pyx_n_s_Trainer_lambda, NULL, __pyx_n_s_crf, __pyx_d, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 75, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_error_sensitive, __pyx_t_2) < 0) __PYX_ERR(0, 56, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-
-  /* "crf.pyx":76
- *             "c": float,
- *             "error_sensitive": lambda value: bool(int(value)),
- *             "averaging": lambda value: bool(int(value)),             # <<<<<<<<<<<<<<
- *             "variance": float,
- *             "gamma": float,
- */
-  __pyx_t_2 = __Pyx_CyFunction_New(&__pyx_mdef_3crf_7Trainer_25lambda3, 0, __pyx_n_s_Trainer_lambda, NULL, __pyx_n_s_crf, __pyx_d, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 76, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_averaging, __pyx_t_2) < 0) __PYX_ERR(0, 56, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-
-  /* "crf.pyx":77
- *             "error_sensitive": lambda value: bool(int(value)),
- *             "averaging": lambda value: bool(int(value)),
- *             "variance": float,             # <<<<<<<<<<<<<<
- *             "gamma": float,
- *         }
- */
-  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_variance, ((PyObject *)(&PyFloat_Type))) < 0) __PYX_ERR(0, 56, __pyx_L1_error)
-
-  /* "crf.pyx":78
- *             "averaging": lambda value: bool(int(value)),
- *             "variance": float,
- *             "gamma": float,             # <<<<<<<<<<<<<<
- *         }
- * 
- */
-  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_gamma, ((PyObject *)(&PyFloat_Type))) < 0) __PYX_ERR(0, 56, __pyx_L1_error)
-  if (PyDict_SetItem((PyObject *)__pyx_ptype_3crf_Trainer->tp_dict, __pyx_n_s_parameter_types, __pyx_t_3) < 0) __PYX_ERR(0, 55, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  PyType_Modified(__pyx_ptype_3crf_Trainer);
-
-  /* "crf.pyx":179
- * 
- *     @staticmethod
- *     def check_model(filepath: str):             # <<<<<<<<<<<<<<
- *         with open(filepath, "rb") as model:
- *             magic = model.read(4)
- */
-  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_3crf_5Model_13check_model, NULL, __pyx_n_s_crf); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 179, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  if (PyDict_SetItem((PyObject *)__pyx_ptype_3crf_Model->tp_dict, __pyx_n_s_check_model, __pyx_t_3) < 0) __PYX_ERR(0, 179, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  PyType_Modified(__pyx_ptype_3crf_Model);
-
-  /* "crf.pyx":178
- *         self._tagger.set(to_seq(sequence))
- * 
- *     @staticmethod             # <<<<<<<<<<<<<<
- *     def check_model(filepath: str):
- *         with open(filepath, "rb") as model:
- */
-  __Pyx_GetNameInClass(__pyx_t_3, (PyObject *)__pyx_ptype_3crf_Model, __pyx_n_s_check_model); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 179, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  __pyx_t_2 = __Pyx_PyObject_CallOneArg(__pyx_builtin_staticmethod, __pyx_t_3); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 178, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  if (PyDict_SetItem((PyObject *)__pyx_ptype_3crf_Model->tp_dict, __pyx_n_s_check_model, __pyx_t_2) < 0) __PYX_ERR(0, 179, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  PyType_Modified(__pyx_ptype_3crf_Model);
-
-  /* "crf.pyx":1
- * # cython: embedsignature=True             # <<<<<<<<<<<<<<
- * # cython: c_string_type=str
- * # cython: c_string_encoding=utf-8
- */
-  __pyx_t_2 = __Pyx_PyDict_NewPresized(0); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_test, __pyx_t_2) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-
-  /* "vector.from_py":45
- * 
- * @cname("__pyx_convert_vector_from_py_std_3a__3a_string")
- * cdef vector[X] __pyx_convert_vector_from_py_std_3a__3a_string(object o) except *:             # <<<<<<<<<<<<<<
- *     cdef vector[X] v
- *     for item in o:
- */
-
-  /*--- Wrapped vars code ---*/
-
-  goto __pyx_L0;
-  __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_1);
-  __Pyx_XDECREF(__pyx_t_2);
-  __Pyx_XDECREF(__pyx_t_3);
-  if (__pyx_m) {
-    if (__pyx_d) {
-      __Pyx_AddTraceback("init crf", __pyx_clineno, __pyx_lineno, __pyx_filename);
-    }
-    Py_CLEAR(__pyx_m);
-  } else if (!PyErr_Occurred()) {
-    PyErr_SetString(PyExc_ImportError, "init crf");
-  }
-  __pyx_L0:;
-  __Pyx_RefNannyFinishContext();
-  #if CYTHON_PEP489_MULTI_PHASE_INIT
-  return (__pyx_m != NULL) ? 0 : -1;
-  #elif PY_MAJOR_VERSION >= 3
-  return __pyx_m;
-  #else
-  return;
-  #endif
-}
-
-/* --- Runtime support code --- */
-/* Refnanny */
-#if CYTHON_REFNANNY
-static __Pyx_RefNannyAPIStruct *__Pyx_RefNannyImportAPI(const char *modname) {
-    PyObject *m = NULL, *p = NULL;
-    void *r = NULL;
-    m = PyImport_ImportModule(modname);
-    if (!m) goto end;
-    p = PyObject_GetAttrString(m, "RefNannyAPI");
-    if (!p) goto end;
-    r = PyLong_AsVoidPtr(p);
-end:
-    Py_XDECREF(p);
-    Py_XDECREF(m);
-    return (__Pyx_RefNannyAPIStruct *)r;
-}
-#endif
-
-/* PyObjectGetAttrStr */
-#if CYTHON_USE_TYPE_SLOTS
-static CYTHON_INLINE PyObject* __Pyx_PyObject_GetAttrStr(PyObject* obj, PyObject* attr_name) {
-    PyTypeObject* tp = Py_TYPE(obj);
-    if (likely(tp->tp_getattro))
-        return tp->tp_getattro(obj, attr_name);
-#if PY_MAJOR_VERSION < 3
-    if (likely(tp->tp_getattr))
-        return tp->tp_getattr(obj, PyString_AS_STRING(attr_name));
-#endif
-    return PyObject_GetAttr(obj, attr_name);
-}
-#endif
-
-/* GetBuiltinName */
-static PyObject *__Pyx_GetBuiltinName(PyObject *name) {
-    PyObject* result = __Pyx_PyObject_GetAttrStr(__pyx_b, name);
-    if (unlikely(!result)) {
-        PyErr_Format(PyExc_NameError,
-#if PY_MAJOR_VERSION >= 3
-            "name '%U' is not defined", name);
-#else
-            "name '%.200s' is not defined", PyString_AS_STRING(name));
-#endif
-    }
-    return result;
-}
-
-/* RaiseDoubleKeywords */
-static void __Pyx_RaiseDoubleKeywordsError(
-    const char* func_name,
-    PyObject* kw_name)
-{
-    PyErr_Format(PyExc_TypeError,
-        #if PY_MAJOR_VERSION >= 3
-        "%s() got multiple values for keyword argument '%U'", func_name, kw_name);
-        #else
-        "%s() got multiple values for keyword argument '%s'", func_name,
-        PyString_AsString(kw_name));
-        #endif
-}
-
-/* ParseKeywords */
-static int __Pyx_ParseOptionalKeywords(
-    PyObject *kwds,
-    PyObject **argnames[],
-    PyObject *kwds2,
-    PyObject *values[],
-    Py_ssize_t num_pos_args,
-    const char* function_name)
-{
-    PyObject *key = 0, *value = 0;
-    Py_ssize_t pos = 0;
-    PyObject*** name;
-    PyObject*** first_kw_arg = argnames + num_pos_args;
-    while (PyDict_Next(kwds, &pos, &key, &value)) {
-        name = first_kw_arg;
-        while (*name && (**name != key)) name++;
-        if (*name) {
-            values[name-argnames] = value;
-            continue;
-        }
-        name = first_kw_arg;
-        #if PY_MAJOR_VERSION < 3
-        if (likely(PyString_Check(key))) {
-            while (*name) {
-                if ((CYTHON_COMPILING_IN_PYPY || PyString_GET_SIZE(**name) == PyString_GET_SIZE(key))
-                        && _PyString_Eq(**name, key)) {
-                    values[name-argnames] = value;
-                    break;
-                }
-                name++;
-            }
-            if (*name) continue;
-            else {
-                PyObject*** argname = argnames;
-                while (argname != first_kw_arg) {
-                    if ((**argname == key) || (
-                            (CYTHON_COMPILING_IN_PYPY || PyString_GET_SIZE(**argname) == PyString_GET_SIZE(key))
-                             && _PyString_Eq(**argname, key))) {
-                        goto arg_passed_twice;
-                    }
-                    argname++;
-                }
-            }
-        } else
-        #endif
-        if (likely(PyUnicode_Check(key))) {
-            while (*name) {
-                int cmp = (**name == key) ? 0 :
-                #if !CYTHON_COMPILING_IN_PYPY && PY_MAJOR_VERSION >= 3
-                    (__Pyx_PyUnicode_GET_LENGTH(**name) != __Pyx_PyUnicode_GET_LENGTH(key)) ? 1 :
-                #endif
-                    PyUnicode_Compare(**name, key);
-                if (cmp < 0 && unlikely(PyErr_Occurred())) goto bad;
-                if (cmp == 0) {
-                    values[name-argnames] = value;
-                    break;
-                }
-                name++;
-            }
-            if (*name) continue;
-            else {
-                PyObject*** argname = argnames;
-                while (argname != first_kw_arg) {
-                    int cmp = (**argname == key) ? 0 :
-                    #if !CYTHON_COMPILING_IN_PYPY && PY_MAJOR_VERSION >= 3
-                        (__Pyx_PyUnicode_GET_LENGTH(**argname) != __Pyx_PyUnicode_GET_LENGTH(key)) ? 1 :
-                    #endif
-                        PyUnicode_Compare(**argname, key);
-                    if (cmp < 0 && unlikely(PyErr_Occurred())) goto bad;
-                    if (cmp == 0) goto arg_passed_twice;
-                    argname++;
-                }
-            }
-        } else
-            goto invalid_keyword_type;
-        if (kwds2) {
-            if (unlikely(PyDict_SetItem(kwds2, key, value))) goto bad;
-        } else {
-            goto invalid_keyword;
-        }
-    }
-    return 0;
-arg_passed_twice:
-    __Pyx_RaiseDoubleKeywordsError(function_name, key);
-    goto bad;
-invalid_keyword_type:
-    PyErr_Format(PyExc_TypeError,
-        "%.200s() keywords must be strings", function_name);
-    goto bad;
-invalid_keyword:
-    PyErr_Format(PyExc_TypeError,
-    #if PY_MAJOR_VERSION < 3
-        "%.200s() got an unexpected keyword argument '%.200s'",
-        function_name, PyString_AsString(key));
-    #else
-        "%s() got an unexpected keyword argument '%U'",
-        function_name, key);
-    #endif
-bad:
-    return -1;
-}
-
-/* RaiseArgTupleInvalid */
-static void __Pyx_RaiseArgtupleInvalid(
-    const char* func_name,
-    int exact,
-    Py_ssize_t num_min,
-    Py_ssize_t num_max,
-    Py_ssize_t num_found)
-{
-    Py_ssize_t num_expected;
-    const char *more_or_less;
-    if (num_found < num_min) {
-        num_expected = num_min;
-        more_or_less = "at least";
-    } else {
-        num_expected = num_max;
-        more_or_less = "at most";
-    }
-    if (exact) {
-        more_or_less = "exactly";
-    }
-    PyErr_Format(PyExc_TypeError,
-                 "%.200s() takes %.8s %" CYTHON_FORMAT_SSIZE_T "d positional argument%.1s (%" CYTHON_FORMAT_SSIZE_T "d given)",
-                 func_name, more_or_less, num_expected,
-                 (num_expected == 1) ? "" : "s", num_found);
-}
-
-/* ArgTypeTest */
-static int __Pyx__ArgTypeTest(PyObject *obj, PyTypeObject *type, const char *name, int exact)
-{
-    if (unlikely(!type)) {
-        PyErr_SetString(PyExc_SystemError, "Missing type object");
-        return 0;
-    }
-    else if (exact) {
-        #if PY_MAJOR_VERSION == 2
-        if ((type == &PyBaseString_Type) && likely(__Pyx_PyBaseString_CheckExact(obj))) return 1;
-        #endif
-    }
-    else {
-        if (likely(__Pyx_TypeCheck(obj, type))) return 1;
-    }
-    PyErr_Format(PyExc_TypeError,
-        "Argument '%.200s' has incorrect type (expected %.200s, got %.200s)",
-        name, type->tp_name, Py_TYPE(obj)->tp_name);
-    return 0;
-}
-
-/* PyCFunctionFastCall */
-#if CYTHON_FAST_PYCCALL
-static CYTHON_INLINE PyObject * __Pyx_PyCFunction_FastCall(PyObject *func_obj, PyObject **args, Py_ssize_t nargs) {
-    PyCFunctionObject *func = (PyCFunctionObject*)func_obj;
-    PyCFunction meth = PyCFunction_GET_FUNCTION(func);
-    PyObject *self = PyCFunction_GET_SELF(func);
-    int flags = PyCFunction_GET_FLAGS(func);
-    assert(PyCFunction_Check(func));
-    assert(METH_FASTCALL == (flags & ~(METH_CLASS | METH_STATIC | METH_COEXIST | METH_KEYWORDS | METH_STACKLESS)));
-    assert(nargs >= 0);
-    assert(nargs == 0 || args != NULL);
-    /* _PyCFunction_FastCallDict() must not be called with an exception set,
-       because it may clear it (directly or indirectly) and so the
-       caller loses its exception */
-    assert(!PyErr_Occurred());
-    if ((PY_VERSION_HEX < 0x030700A0) || unlikely(flags & METH_KEYWORDS)) {
-        return (*((__Pyx_PyCFunctionFastWithKeywords)(void*)meth)) (self, args, nargs, NULL);
-    } else {
-        return (*((__Pyx_PyCFunctionFast)(void*)meth)) (self, args, nargs);
-    }
-}
-#endif
-
-/* PyFunctionFastCall */
-#if CYTHON_FAST_PYCALL
-static PyObject* __Pyx_PyFunction_FastCallNoKw(PyCodeObject *co, PyObject **args, Py_ssize_t na,
-                                               PyObject *globals) {
-    PyFrameObject *f;
-    PyThreadState *tstate = __Pyx_PyThreadState_Current;
-    PyObject **fastlocals;
-    Py_ssize_t i;
-    PyObject *result;
-    assert(globals != NULL);
-    /* XXX Perhaps we should create a specialized
-       PyFrame_New() that doesn't take locals, but does
-       take builtins without sanity checking them.
-       */
-    assert(tstate != NULL);
-    f = PyFrame_New(tstate, co, globals, NULL);
-    if (f == NULL) {
-        return NULL;
-    }
-    fastlocals = __Pyx_PyFrame_GetLocalsplus(f);
-    for (i = 0; i < na; i++) {
-        Py_INCREF(*args);
-        fastlocals[i] = *args++;
-    }
-    result = PyEval_EvalFrameEx(f,0);
-    ++tstate->recursion_depth;
-    Py_DECREF(f);
-    --tstate->recursion_depth;
-    return result;
-}
-#if 1 || PY_VERSION_HEX < 0x030600B1
-static PyObject *__Pyx_PyFunction_FastCallDict(PyObject *func, PyObject **args, Py_ssize_t nargs, PyObject *kwargs) {
-    PyCodeObject *co = (PyCodeObject *)PyFunction_GET_CODE(func);
-    PyObject *globals = PyFunction_GET_GLOBALS(func);
-    PyObject *argdefs = PyFunction_GET_DEFAULTS(func);
-    PyObject *closure;
-#if PY_MAJOR_VERSION >= 3
-    PyObject *kwdefs;
-#endif
-    PyObject *kwtuple, **k;
-    PyObject **d;
-    Py_ssize_t nd;
-    Py_ssize_t nk;
-    PyObject *result;
-    assert(kwargs == NULL || PyDict_Check(kwargs));
-    nk = kwargs ? PyDict_Size(kwargs) : 0;
-    if (Py_EnterRecursiveCall((char*)" while calling a Python object")) {
-        return NULL;
-    }
-    if (
-#if PY_MAJOR_VERSION >= 3
-            co->co_kwonlyargcount == 0 &&
-#endif
-            likely(kwargs == NULL || nk == 0) &&
-            co->co_flags == (CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE)) {
-        if (argdefs == NULL && co->co_argcount == nargs) {
-            result = __Pyx_PyFunction_FastCallNoKw(co, args, nargs, globals);
-            goto done;
-        }
-        else if (nargs == 0 && argdefs != NULL
-                 && co->co_argcount == Py_SIZE(argdefs)) {
-            /* function called with no arguments, but all parameters have
-               a default value: use default values as arguments .*/
-            args = &PyTuple_GET_ITEM(argdefs, 0);
-            result =__Pyx_PyFunction_FastCallNoKw(co, args, Py_SIZE(argdefs), globals);
-            goto done;
-        }
-    }
-    if (kwargs != NULL) {
-        Py_ssize_t pos, i;
-        kwtuple = PyTuple_New(2 * nk);
-        if (kwtuple == NULL) {
-            result = NULL;
-            goto done;
-        }
-        k = &PyTuple_GET_ITEM(kwtuple, 0);
-        pos = i = 0;
-        while (PyDict_Next(kwargs, &pos, &k[i], &k[i+1])) {
-            Py_INCREF(k[i]);
-            Py_INCREF(k[i+1]);
-            i += 2;
-        }
-        nk = i / 2;
-    }
-    else {
-        kwtuple = NULL;
-        k = NULL;
-    }
-    closure = PyFunction_GET_CLOSURE(func);
-#if PY_MAJOR_VERSION >= 3
-    kwdefs = PyFunction_GET_KW_DEFAULTS(func);
-#endif
-    if (argdefs != NULL) {
-        d = &PyTuple_GET_ITEM(argdefs, 0);
-        nd = Py_SIZE(argdefs);
-    }
-    else {
-        d = NULL;
-        nd = 0;
-    }
-#if PY_MAJOR_VERSION >= 3
-    result = PyEval_EvalCodeEx((PyObject*)co, globals, (PyObject *)NULL,
-                               args, (int)nargs,
-                               k, (int)nk,
-                               d, (int)nd, kwdefs, closure);
-#else
-    result = PyEval_EvalCodeEx(co, globals, (PyObject *)NULL,
-                               args, (int)nargs,
-                               k, (int)nk,
-                               d, (int)nd, closure);
-#endif
-    Py_XDECREF(kwtuple);
-done:
-    Py_LeaveRecursiveCall();
-    return result;
-}
-#endif
-#endif
-
-/* PyObjectCall */
-#if CYTHON_COMPILING_IN_CPYTHON
-static CYTHON_INLINE PyObject* __Pyx_PyObject_Call(PyObject *func, PyObject *arg, PyObject *kw) {
-    PyObject *result;
-    ternaryfunc call = Py_TYPE(func)->tp_call;
-    if (unlikely(!call))
-        return PyObject_Call(func, arg, kw);
-    if (unlikely(Py_EnterRecursiveCall((char*)" while calling a Python object")))
-        return NULL;
-    result = (*call)(func, arg, kw);
-    Py_LeaveRecursiveCall();
-    if (unlikely(!result) && unlikely(!PyErr_Occurred())) {
-        PyErr_SetString(
-            PyExc_SystemError,
-            "NULL result without error in PyObject_Call");
-    }
-    return result;
-}
-#endif
-
-/* PyObjectCall2Args */
-static CYTHON_UNUSED PyObject* __Pyx_PyObject_Call2Args(PyObject* function, PyObject* arg1, PyObject* arg2) {
-    PyObject *args, *result = NULL;
-    #if CYTHON_FAST_PYCALL
-    if (PyFunction_Check(function)) {
-        PyObject *args[2] = {arg1, arg2};
-        return __Pyx_PyFunction_FastCall(function, args, 2);
-    }
-    #endif
-    #if CYTHON_FAST_PYCCALL
-    if (__Pyx_PyFastCFunction_Check(function)) {
-        PyObject *args[2] = {arg1, arg2};
-        return __Pyx_PyCFunction_FastCall(function, args, 2);
-    }
-    #endif
-    args = PyTuple_New(2);
-    if (unlikely(!args)) goto done;
-    Py_INCREF(arg1);
-    PyTuple_SET_ITEM(args, 0, arg1);
-    Py_INCREF(arg2);
-    PyTuple_SET_ITEM(args, 1, arg2);
-    Py_INCREF(function);
-    result = __Pyx_PyObject_Call(function, args, NULL);
-    Py_DECREF(args);
-    Py_DECREF(function);
-done:
-    return result;
-}
-
-/* PyObjectCallMethO */
-#if CYTHON_COMPILING_IN_CPYTHON
-static CYTHON_INLINE PyObject* __Pyx_PyObject_CallMethO(PyObject *func, PyObject *arg) {
-    PyObject *self, *result;
-    PyCFunction cfunc;
-    cfunc = PyCFunction_GET_FUNCTION(func);
-    self = PyCFunction_GET_SELF(func);
-    if (unlikely(Py_EnterRecursiveCall((char*)" while calling a Python object")))
-        return NULL;
-    result = cfunc(self, arg);
-    Py_LeaveRecursiveCall();
-    if (unlikely(!result) && unlikely(!PyErr_Occurred())) {
-        PyErr_SetString(
-            PyExc_SystemError,
-            "NULL result without error in PyObject_Call");
-    }
-    return result;
-}
-#endif
-
-/* PyObjectCallOneArg */
-#if CYTHON_COMPILING_IN_CPYTHON
-static PyObject* __Pyx__PyObject_CallOneArg(PyObject *func, PyObject *arg) {
-    PyObject *result;
-    PyObject *args = PyTuple_New(1);
-    if (unlikely(!args)) return NULL;
-    Py_INCREF(arg);
-    PyTuple_SET_ITEM(args, 0, arg);
-    result = __Pyx_PyObject_Call(func, args, NULL);
-    Py_DECREF(args);
-    return result;
-}
-static CYTHON_INLINE PyObject* __Pyx_PyObject_CallOneArg(PyObject *func, PyObject *arg) {
-#if CYTHON_FAST_PYCALL
-    if (PyFunction_Check(func)) {
-        return __Pyx_PyFunction_FastCall(func, &arg, 1);
-    }
-#endif
-    if (likely(PyCFunction_Check(func))) {
-        if (likely(PyCFunction_GET_FLAGS(func) & METH_O)) {
-            return __Pyx_PyObject_CallMethO(func, arg);
-#if CYTHON_FAST_PYCCALL
-        } else if (__Pyx_PyFastCFunction_Check(func)) {
-            return __Pyx_PyCFunction_FastCall(func, &arg, 1);
-#endif
-        }
-    }
-    return __Pyx__PyObject_CallOneArg(func, arg);
-}
-#else
-static CYTHON_INLINE PyObject* __Pyx_PyObject_CallOneArg(PyObject *func, PyObject *arg) {
-    PyObject *result;
-    PyObject *args = PyTuple_Pack(1, arg);
-    if (unlikely(!args)) return NULL;
-    result = __Pyx_PyObject_Call(func, args, NULL);
-    Py_DECREF(args);
-    return result;
-}
-#endif
-
-/* KeywordStringCheck */
-static int __Pyx_CheckKeywordStrings(
-    PyObject *kwdict,
-    const char* function_name,
-    int kw_allowed)
-{
-    PyObject* key = 0;
-    Py_ssize_t pos = 0;
-#if CYTHON_COMPILING_IN_PYPY
-    if (!kw_allowed && PyDict_Next(kwdict, &pos, &key, 0))
-        goto invalid_keyword;
-    return 1;
-#else
-    while (PyDict_Next(kwdict, &pos, &key, 0)) {
-        #if PY_MAJOR_VERSION < 3
-        if (unlikely(!PyString_Check(key)))
-        #endif
-            if (unlikely(!PyUnicode_Check(key)))
-                goto invalid_keyword_type;
-    }
-    if ((!kw_allowed) && unlikely(key))
-        goto invalid_keyword;
-    return 1;
-invalid_keyword_type:
-    PyErr_Format(PyExc_TypeError,
-        "%.200s() keywords must be strings", function_name);
-    return 0;
-#endif
-invalid_keyword:
-    PyErr_Format(PyExc_TypeError,
-    #if PY_MAJOR_VERSION < 3
-        "%.200s() got an unexpected keyword argument '%.200s'",
-        function_name, PyString_AsString(key));
-    #else
-        "%s() got an unexpected keyword argument '%U'",
-        function_name, key);
-    #endif
-    return 0;
-}
-
-/* PyDictVersioning */
-#if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_TYPE_SLOTS
-static CYTHON_INLINE PY_UINT64_T __Pyx_get_tp_dict_version(PyObject *obj) {
-    PyObject *dict = Py_TYPE(obj)->tp_dict;
-    return likely(dict) ? __PYX_GET_DICT_VERSION(dict) : 0;
-}
-static CYTHON_INLINE PY_UINT64_T __Pyx_get_object_dict_version(PyObject *obj) {
-    PyObject **dictptr = NULL;
-    Py_ssize_t offset = Py_TYPE(obj)->tp_dictoffset;
-    if (offset) {
-#if CYTHON_COMPILING_IN_CPYTHON
-        dictptr = (likely(offset > 0)) ? (PyObject **) ((char *)obj + offset) : _PyObject_GetDictPtr(obj);
-#else
-        dictptr = _PyObject_GetDictPtr(obj);
-#endif
-    }
-    return (dictptr && *dictptr) ? __PYX_GET_DICT_VERSION(*dictptr) : 0;
-}
-static CYTHON_INLINE int __Pyx_object_dict_version_matches(PyObject* obj, PY_UINT64_T tp_dict_version, PY_UINT64_T obj_dict_version) {
-    PyObject *dict = Py_TYPE(obj)->tp_dict;
-    if (unlikely(!dict) || unlikely(tp_dict_version != __PYX_GET_DICT_VERSION(dict)))
-        return 0;
-    return obj_dict_version == __Pyx_get_object_dict_version(obj);
-}
-#endif
-
-/* GetModuleGlobalName */
-#if CYTHON_USE_DICT_VERSIONS
-static PyObject *__Pyx__GetModuleGlobalName(PyObject *name, PY_UINT64_T *dict_version, PyObject **dict_cached_value)
-#else
-static CYTHON_INLINE PyObject *__Pyx__GetModuleGlobalName(PyObject *name)
-#endif
-{
-    PyObject *result;
-#if !CYTHON_AVOID_BORROWED_REFS
-#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX >= 0x030500A1
-    result = _PyDict_GetItem_KnownHash(__pyx_d, name, ((PyASCIIObject *) name)->hash);
-    __PYX_UPDATE_DICT_CACHE(__pyx_d, result, *dict_cached_value, *dict_version)
-    if (likely(result)) {
-        return __Pyx_NewRef(result);
-    } else if (unlikely(PyErr_Occurred())) {
-        return NULL;
-    }
-#else
-    result = PyDict_GetItem(__pyx_d, name);
-    __PYX_UPDATE_DICT_CACHE(__pyx_d, result, *dict_cached_value, *dict_version)
-    if (likely(result)) {
-        return __Pyx_NewRef(result);
-    }
-#endif
-#else
-    result = PyObject_GetItem(__pyx_d, name);
-    __PYX_UPDATE_DICT_CACHE(__pyx_d, result, *dict_cached_value, *dict_version)
-    if (likely(result)) {
-        return __Pyx_NewRef(result);
-    }
-    PyErr_Clear();
-#endif
-    return __Pyx_GetBuiltinName(name);
-}
-
-/* PyObjectCallNoArg */
-#if CYTHON_COMPILING_IN_CPYTHON
-static CYTHON_INLINE PyObject* __Pyx_PyObject_CallNoArg(PyObject *func) {
-#if CYTHON_FAST_PYCALL
-    if (PyFunction_Check(func)) {
-        return __Pyx_PyFunction_FastCall(func, NULL, 0);
-    }
-#endif
-#ifdef __Pyx_CyFunction_USED
-    if (likely(PyCFunction_Check(func) || __Pyx_CyFunction_Check(func)))
-#else
-    if (likely(PyCFunction_Check(func)))
-#endif
-    {
-        if (likely(PyCFunction_GET_FLAGS(func) & METH_NOARGS)) {
-            return __Pyx_PyObject_CallMethO(func, NULL);
-        }
-    }
-    return __Pyx_PyObject_Call(func, __pyx_empty_tuple, NULL);
-}
-#endif
-
-/* RaiseTooManyValuesToUnpack */
-static CYTHON_INLINE void __Pyx_RaiseTooManyValuesError(Py_ssize_t expected) {
-    PyErr_Format(PyExc_ValueError,
-                 "too many values to unpack (expected %" CYTHON_FORMAT_SSIZE_T "d)", expected);
-}
-
-/* RaiseNeedMoreValuesToUnpack */
-static CYTHON_INLINE void __Pyx_RaiseNeedMoreValuesError(Py_ssize_t index) {
-    PyErr_Format(PyExc_ValueError,
-                 "need more than %" CYTHON_FORMAT_SSIZE_T "d value%.1s to unpack",
-                 index, (index == 1) ? "" : "s");
-}
-
-/* IterFinish */
-static CYTHON_INLINE int __Pyx_IterFinish(void) {
-#if CYTHON_FAST_THREAD_STATE
-    PyThreadState *tstate = __Pyx_PyThreadState_Current;
-    PyObject* exc_type = tstate->curexc_type;
-    if (unlikely(exc_type)) {
-        if (likely(__Pyx_PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) {
-            PyObject *exc_value, *exc_tb;
-            exc_value = tstate->curexc_value;
-            exc_tb = tstate->curexc_traceback;
-            tstate->curexc_type = 0;
-            tstate->curexc_value = 0;
-            tstate->curexc_traceback = 0;
-            Py_DECREF(exc_type);
-            Py_XDECREF(exc_value);
-            Py_XDECREF(exc_tb);
-            return 0;
-        } else {
-            return -1;
-        }
-    }
-    return 0;
-#else
-    if (unlikely(PyErr_Occurred())) {
-        if (likely(PyErr_ExceptionMatches(PyExc_StopIteration))) {
-            PyErr_Clear();
-            return 0;
-        } else {
-            return -1;
-        }
-    }
-    return 0;
-#endif
-}
-
-/* UnpackItemEndCheck */
-static int __Pyx_IternextUnpackEndCheck(PyObject *retval, Py_ssize_t expected) {
-    if (unlikely(retval)) {
-        Py_DECREF(retval);
-        __Pyx_RaiseTooManyValuesError(expected);
-        return -1;
-    } else {
-        return __Pyx_IterFinish();
-    }
-    return 0;
-}
-
-/* UnpackUnboundCMethod */
-static int __Pyx_TryUnpackUnboundCMethod(__Pyx_CachedCFunction* target) {
-    PyObject *method;
-    method = __Pyx_PyObject_GetAttrStr(target->type, *target->method_name);
-    if (unlikely(!method))
-        return -1;
-    target->method = method;
-#if CYTHON_COMPILING_IN_CPYTHON
-    #if PY_MAJOR_VERSION >= 3
-    if (likely(__Pyx_TypeCheck(method, &PyMethodDescr_Type)))
-    #endif
-    {
-        PyMethodDescrObject *descr = (PyMethodDescrObject*) method;
-        target->func = descr->d_method->ml_meth;
-        target->flag = descr->d_method->ml_flags & ~(METH_CLASS | METH_STATIC | METH_COEXIST | METH_STACKLESS);
-    }
-#endif
-    return 0;
-}
-
-/* CallUnboundCMethod0 */
-static PyObject* __Pyx__CallUnboundCMethod0(__Pyx_CachedCFunction* cfunc, PyObject* self) {
-    PyObject *args, *result = NULL;
-    if (unlikely(!cfunc->method) && unlikely(__Pyx_TryUnpackUnboundCMethod(cfunc) < 0)) return NULL;
-#if CYTHON_ASSUME_SAFE_MACROS
-    args = PyTuple_New(1);
-    if (unlikely(!args)) goto bad;
-    Py_INCREF(self);
-    PyTuple_SET_ITEM(args, 0, self);
-#else
-    args = PyTuple_Pack(1, self);
-    if (unlikely(!args)) goto bad;
-#endif
-    result = __Pyx_PyObject_Call(cfunc->method, args, NULL);
-    Py_DECREF(args);
-bad:
-    return result;
-}
-
-/* GetItemInt */
-static PyObject *__Pyx_GetItemInt_Generic(PyObject *o, PyObject* j) {
-    PyObject *r;
-    if (!j) return NULL;
-    r = PyObject_GetItem(o, j);
-    Py_DECREF(j);
-    return r;
-}
-static CYTHON_INLINE PyObject *__Pyx_GetItemInt_List_Fast(PyObject *o, Py_ssize_t i,
-                                                              CYTHON_NCP_UNUSED int wraparound,
-                                                              CYTHON_NCP_UNUSED int boundscheck) {
-#if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-    Py_ssize_t wrapped_i = i;
-    if (wraparound & unlikely(i < 0)) {
-        wrapped_i += PyList_GET_SIZE(o);
-    }
-    if ((!boundscheck) || likely(__Pyx_is_valid_index(wrapped_i, PyList_GET_SIZE(o)))) {
-        PyObject *r = PyList_GET_ITEM(o, wrapped_i);
-        Py_INCREF(r);
-        return r;
-    }
-    return __Pyx_GetItemInt_Generic(o, PyInt_FromSsize_t(i));
-#else
-    return PySequence_GetItem(o, i);
-#endif
-}
-static CYTHON_INLINE PyObject *__Pyx_GetItemInt_Tuple_Fast(PyObject *o, Py_ssize_t i,
-                                                              CYTHON_NCP_UNUSED int wraparound,
-                                                              CYTHON_NCP_UNUSED int boundscheck) {
-#if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-    Py_ssize_t wrapped_i = i;
-    if (wraparound & unlikely(i < 0)) {
-        wrapped_i += PyTuple_GET_SIZE(o);
-    }
-    if ((!boundscheck) || likely(__Pyx_is_valid_index(wrapped_i, PyTuple_GET_SIZE(o)))) {
-        PyObject *r = PyTuple_GET_ITEM(o, wrapped_i);
-        Py_INCREF(r);
-        return r;
-    }
-    return __Pyx_GetItemInt_Generic(o, PyInt_FromSsize_t(i));
-#else
-    return PySequence_GetItem(o, i);
-#endif
-}
-static CYTHON_INLINE PyObject *__Pyx_GetItemInt_Fast(PyObject *o, Py_ssize_t i, int is_list,
-                                                     CYTHON_NCP_UNUSED int wraparound,
-                                                     CYTHON_NCP_UNUSED int boundscheck) {
-#if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS && CYTHON_USE_TYPE_SLOTS
-    if (is_list || PyList_CheckExact(o)) {
-        Py_ssize_t n = ((!wraparound) | likely(i >= 0)) ? i : i + PyList_GET_SIZE(o);
-        if ((!boundscheck) || (likely(__Pyx_is_valid_index(n, PyList_GET_SIZE(o))))) {
-            PyObject *r = PyList_GET_ITEM(o, n);
-            Py_INCREF(r);
-            return r;
-        }
-    }
-    else if (PyTuple_CheckExact(o)) {
-        Py_ssize_t n = ((!wraparound) | likely(i >= 0)) ? i : i + PyTuple_GET_SIZE(o);
-        if ((!boundscheck) || likely(__Pyx_is_valid_index(n, PyTuple_GET_SIZE(o)))) {
-            PyObject *r = PyTuple_GET_ITEM(o, n);
-            Py_INCREF(r);
-            return r;
-        }
-    } else {
-        PySequenceMethods *m = Py_TYPE(o)->tp_as_sequence;
-        if (likely(m && m->sq_item)) {
-            if (wraparound && unlikely(i < 0) && likely(m->sq_length)) {
-                Py_ssize_t l = m->sq_length(o);
-                if (likely(l >= 0)) {
-                    i += l;
-                } else {
-                    if (!PyErr_ExceptionMatches(PyExc_OverflowError))
-                        return NULL;
-                    PyErr_Clear();
-                }
-            }
-            return m->sq_item(o, i);
-        }
-    }
-#else
-    if (is_list || PySequence_Check(o)) {
-        return PySequence_GetItem(o, i);
-    }
-#endif
-    return __Pyx_GetItemInt_Generic(o, PyInt_FromSsize_t(i));
-}
-
-/* ObjectGetItem */
-#if CYTHON_USE_TYPE_SLOTS
-static PyObject *__Pyx_PyObject_GetIndex(PyObject *obj, PyObject* index) {
-    PyObject *runerr;
-    Py_ssize_t key_value;
-    PySequenceMethods *m = Py_TYPE(obj)->tp_as_sequence;
-    if (unlikely(!(m && m->sq_item))) {
-        PyErr_Format(PyExc_TypeError, "'%.200s' object is not subscriptable", Py_TYPE(obj)->tp_name);
-        return NULL;
-    }
-    key_value = __Pyx_PyIndex_AsSsize_t(index);
-    if (likely(key_value != -1 || !(runerr = PyErr_Occurred()))) {
-        return __Pyx_GetItemInt_Fast(obj, key_value, 0, 1, 1);
-    }
-    if (PyErr_GivenExceptionMatches(runerr, PyExc_OverflowError)) {
-        PyErr_Clear();
-        PyErr_Format(PyExc_IndexError, "cannot fit '%.200s' into an index-sized integer", Py_TYPE(index)->tp_name);
-    }
-    return NULL;
-}
-static PyObject *__Pyx_PyObject_GetItem(PyObject *obj, PyObject* key) {
-    PyMappingMethods *m = Py_TYPE(obj)->tp_as_mapping;
-    if (likely(m && m->mp_subscript)) {
-        return m->mp_subscript(obj, key);
-    }
-    return __Pyx_PyObject_GetIndex(obj, key);
-}
-#endif
-
-/* GetTopmostException */
-#if CYTHON_USE_EXC_INFO_STACK
-static _PyErr_StackItem *
-__Pyx_PyErr_GetTopmostException(PyThreadState *tstate)
-{
-    _PyErr_StackItem *exc_info = tstate->exc_info;
-    while ((exc_info->exc_type == NULL || exc_info->exc_type == Py_None) &&
-           exc_info->previous_item != NULL)
-    {
-        exc_info = exc_info->previous_item;
-    }
-    return exc_info;
-}
-#endif
-
-/* SaveResetException */
-#if CYTHON_FAST_THREAD_STATE
-static CYTHON_INLINE void __Pyx__ExceptionSave(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb) {
-    #if CYTHON_USE_EXC_INFO_STACK
-    _PyErr_StackItem *exc_info = __Pyx_PyErr_GetTopmostException(tstate);
-    *type = exc_info->exc_type;
-    *value = exc_info->exc_value;
-    *tb = exc_info->exc_traceback;
-    #else
-    *type = tstate->exc_type;
-    *value = tstate->exc_value;
-    *tb = tstate->exc_traceback;
-    #endif
-    Py_XINCREF(*type);
-    Py_XINCREF(*value);
-    Py_XINCREF(*tb);
-}
-static CYTHON_INLINE void __Pyx__ExceptionReset(PyThreadState *tstate, PyObject *type, PyObject *value, PyObject *tb) {
-    PyObject *tmp_type, *tmp_value, *tmp_tb;
-    #if CYTHON_USE_EXC_INFO_STACK
-    _PyErr_StackItem *exc_info = tstate->exc_info;
-    tmp_type = exc_info->exc_type;
-    tmp_value = exc_info->exc_value;
-    tmp_tb = exc_info->exc_traceback;
-    exc_info->exc_type = type;
-    exc_info->exc_value = value;
-    exc_info->exc_traceback = tb;
-    #else
-    tmp_type = tstate->exc_type;
-    tmp_value = tstate->exc_value;
-    tmp_tb = tstate->exc_traceback;
-    tstate->exc_type = type;
-    tstate->exc_value = value;
-    tstate->exc_traceback = tb;
-    #endif
-    Py_XDECREF(tmp_type);
-    Py_XDECREF(tmp_value);
-    Py_XDECREF(tmp_tb);
-}
-#endif
-
-/* GetException */
-#if CYTHON_FAST_THREAD_STATE
-static int __Pyx__GetException(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb)
-#else
-static int __Pyx_GetException(PyObject **type, PyObject **value, PyObject **tb)
-#endif
-{
-    PyObject *local_type, *local_value, *local_tb;
-#if CYTHON_FAST_THREAD_STATE
-    PyObject *tmp_type, *tmp_value, *tmp_tb;
-    local_type = tstate->curexc_type;
-    local_value = tstate->curexc_value;
-    local_tb = tstate->curexc_traceback;
-    tstate->curexc_type = 0;
-    tstate->curexc_value = 0;
-    tstate->curexc_traceback = 0;
-#else
-    PyErr_Fetch(&local_type, &local_value, &local_tb);
-#endif
-    PyErr_NormalizeException(&local_type, &local_value, &local_tb);
-#if CYTHON_FAST_THREAD_STATE
-    if (unlikely(tstate->curexc_type))
-#else
-    if (unlikely(PyErr_Occurred()))
-#endif
-        goto bad;
-    #if PY_MAJOR_VERSION >= 3
-    if (local_tb) {
-        if (unlikely(PyException_SetTraceback(local_value, local_tb) < 0))
-            goto bad;
-    }
-    #endif
-    Py_XINCREF(local_tb);
-    Py_XINCREF(local_type);
-    Py_XINCREF(local_value);
-    *type = local_type;
-    *value = local_value;
-    *tb = local_tb;
-#if CYTHON_FAST_THREAD_STATE
-    #if CYTHON_USE_EXC_INFO_STACK
-    {
-        _PyErr_StackItem *exc_info = tstate->exc_info;
-        tmp_type = exc_info->exc_type;
-        tmp_value = exc_info->exc_value;
-        tmp_tb = exc_info->exc_traceback;
-        exc_info->exc_type = local_type;
-        exc_info->exc_value = local_value;
-        exc_info->exc_traceback = local_tb;
-    }
-    #else
-    tmp_type = tstate->exc_type;
-    tmp_value = tstate->exc_value;
-    tmp_tb = tstate->exc_traceback;
-    tstate->exc_type = local_type;
-    tstate->exc_value = local_value;
-    tstate->exc_traceback = local_tb;
-    #endif
-    Py_XDECREF(tmp_type);
-    Py_XDECREF(tmp_value);
-    Py_XDECREF(tmp_tb);
-#else
-    PyErr_SetExcInfo(local_type, local_value, local_tb);
-#endif
-    return 0;
-bad:
-    *type = 0;
-    *value = 0;
-    *tb = 0;
-    Py_XDECREF(local_type);
-    Py_XDECREF(local_value);
-    Py_XDECREF(local_tb);
-    return -1;
-}
-
-/* PyErrFetchRestore */
-#if CYTHON_FAST_THREAD_STATE
-static CYTHON_INLINE void __Pyx_ErrRestoreInState(PyThreadState *tstate, PyObject *type, PyObject *value, PyObject *tb) {
-    PyObject *tmp_type, *tmp_value, *tmp_tb;
-    tmp_type = tstate->curexc_type;
-    tmp_value = tstate->curexc_value;
-    tmp_tb = tstate->curexc_traceback;
-    tstate->curexc_type = type;
-    tstate->curexc_value = value;
-    tstate->curexc_traceback = tb;
-    Py_XDECREF(tmp_type);
-    Py_XDECREF(tmp_value);
-    Py_XDECREF(tmp_tb);
-}
-static CYTHON_INLINE void __Pyx_ErrFetchInState(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb) {
-    *type = tstate->curexc_type;
-    *value = tstate->curexc_value;
-    *tb = tstate->curexc_traceback;
-    tstate->curexc_type = 0;
-    tstate->curexc_value = 0;
-    tstate->curexc_traceback = 0;
-}
-#endif
-
-/* RaiseException */
-#if PY_MAJOR_VERSION < 3
-static void __Pyx_Raise(PyObject *type, PyObject *value, PyObject *tb,
-                        CYTHON_UNUSED PyObject *cause) {
-    __Pyx_PyThreadState_declare
-    Py_XINCREF(type);
-    if (!value || value == Py_None)
-        value = NULL;
-    else
-        Py_INCREF(value);
-    if (!tb || tb == Py_None)
-        tb = NULL;
-    else {
-        Py_INCREF(tb);
-        if (!PyTraceBack_Check(tb)) {
-            PyErr_SetString(PyExc_TypeError,
-                "raise: arg 3 must be a traceback or None");
-            goto raise_error;
-        }
-    }
-    if (PyType_Check(type)) {
-#if CYTHON_COMPILING_IN_PYPY
-        if (!value) {
-            Py_INCREF(Py_None);
-            value = Py_None;
-        }
-#endif
-        PyErr_NormalizeException(&type, &value, &tb);
-    } else {
-        if (value) {
-            PyErr_SetString(PyExc_TypeError,
-                "instance exception may not have a separate value");
-            goto raise_error;
-        }
-        value = type;
-        type = (PyObject*) Py_TYPE(type);
-        Py_INCREF(type);
-        if (!PyType_IsSubtype((PyTypeObject *)type, (PyTypeObject *)PyExc_BaseException)) {
-            PyErr_SetString(PyExc_TypeError,
-                "raise: exception class must be a subclass of BaseException");
-            goto raise_error;
-        }
-    }
-    __Pyx_PyThreadState_assign
-    __Pyx_ErrRestore(type, value, tb);
-    return;
-raise_error:
-    Py_XDECREF(value);
-    Py_XDECREF(type);
-    Py_XDECREF(tb);
-    return;
-}
-#else
-static void __Pyx_Raise(PyObject *type, PyObject *value, PyObject *tb, PyObject *cause) {
-    PyObject* owned_instance = NULL;
-    if (tb == Py_None) {
-        tb = 0;
-    } else if (tb && !PyTraceBack_Check(tb)) {
-        PyErr_SetString(PyExc_TypeError,
-            "raise: arg 3 must be a traceback or None");
-        goto bad;
-    }
-    if (value == Py_None)
-        value = 0;
-    if (PyExceptionInstance_Check(type)) {
-        if (value) {
-            PyErr_SetString(PyExc_TypeError,
-                "instance exception may not have a separate value");
-            goto bad;
-        }
-        value = type;
-        type = (PyObject*) Py_TYPE(value);
-    } else if (PyExceptionClass_Check(type)) {
-        PyObject *instance_class = NULL;
-        if (value && PyExceptionInstance_Check(value)) {
-            instance_class = (PyObject*) Py_TYPE(value);
-            if (instance_class != type) {
-                int is_subclass = PyObject_IsSubclass(instance_class, type);
-                if (!is_subclass) {
-                    instance_class = NULL;
-                } else if (unlikely(is_subclass == -1)) {
-                    goto bad;
-                } else {
-                    type = instance_class;
-                }
-            }
-        }
-        if (!instance_class) {
-            PyObject *args;
-            if (!value)
-                args = PyTuple_New(0);
-            else if (PyTuple_Check(value)) {
-                Py_INCREF(value);
-                args = value;
-            } else
-                args = PyTuple_Pack(1, value);
-            if (!args)
-                goto bad;
-            owned_instance = PyObject_Call(type, args, NULL);
-            Py_DECREF(args);
-            if (!owned_instance)
-                goto bad;
-            value = owned_instance;
-            if (!PyExceptionInstance_Check(value)) {
-                PyErr_Format(PyExc_TypeError,
-                             "calling %R should have returned an instance of "
-                             "BaseException, not %R",
-                             type, Py_TYPE(value));
-                goto bad;
-            }
-        }
-    } else {
-        PyErr_SetString(PyExc_TypeError,
-            "raise: exception class must be a subclass of BaseException");
-        goto bad;
-    }
-    if (cause) {
-        PyObject *fixed_cause;
-        if (cause == Py_None) {
-            fixed_cause = NULL;
-        } else if (PyExceptionClass_Check(cause)) {
-            fixed_cause = PyObject_CallObject(cause, NULL);
-            if (fixed_cause == NULL)
-                goto bad;
-        } else if (PyExceptionInstance_Check(cause)) {
-            fixed_cause = cause;
-            Py_INCREF(fixed_cause);
-        } else {
-            PyErr_SetString(PyExc_TypeError,
-                            "exception causes must derive from "
-                            "BaseException");
-            goto bad;
-        }
-        PyException_SetCause(value, fixed_cause);
-    }
-    PyErr_SetObject(type, value);
-    if (tb) {
-#if CYTHON_COMPILING_IN_PYPY
-        PyObject *tmp_type, *tmp_value, *tmp_tb;
-        PyErr_Fetch(&tmp_type, &tmp_value, &tmp_tb);
-        Py_INCREF(tb);
-        PyErr_Restore(tmp_type, tmp_value, tb);
-        Py_XDECREF(tmp_tb);
-#else
-        PyThreadState *tstate = __Pyx_PyThreadState_Current;
-        PyObject* tmp_tb = tstate->curexc_traceback;
-        if (tb != tmp_tb) {
-            Py_INCREF(tb);
-            tstate->curexc_traceback = tb;
-            Py_XDECREF(tmp_tb);
-        }
-#endif
-    }
-bad:
-    Py_XDECREF(owned_instance);
-    return;
-}
-#endif
-
-/* DictGetItem */
-#if PY_MAJOR_VERSION >= 3 && !CYTHON_COMPILING_IN_PYPY
-static PyObject *__Pyx_PyDict_GetItem(PyObject *d, PyObject* key) {
-    PyObject *value;
-    value = PyDict_GetItemWithError(d, key);
-    if (unlikely(!value)) {
-        if (!PyErr_Occurred()) {
-            if (unlikely(PyTuple_Check(key))) {
-                PyObject* args = PyTuple_Pack(1, key);
-                if (likely(args)) {
-                    PyErr_SetObject(PyExc_KeyError, args);
-                    Py_DECREF(args);
-                }
-            } else {
-                PyErr_SetObject(PyExc_KeyError, key);
-            }
-        }
-        return NULL;
-    }
-    Py_INCREF(value);
-    return value;
-}
-#endif
-
-/* BytesEquals */
-static CYTHON_INLINE int __Pyx_PyBytes_Equals(PyObject* s1, PyObject* s2, int equals) {
-#if CYTHON_COMPILING_IN_PYPY
-    return PyObject_RichCompareBool(s1, s2, equals);
-#else
-    if (s1 == s2) {
-        return (equals == Py_EQ);
-    } else if (PyBytes_CheckExact(s1) & PyBytes_CheckExact(s2)) {
-        const char *ps1, *ps2;
-        Py_ssize_t length = PyBytes_GET_SIZE(s1);
-        if (length != PyBytes_GET_SIZE(s2))
-            return (equals == Py_NE);
-        ps1 = PyBytes_AS_STRING(s1);
-        ps2 = PyBytes_AS_STRING(s2);
-        if (ps1[0] != ps2[0]) {
-            return (equals == Py_NE);
-        } else if (length == 1) {
-            return (equals == Py_EQ);
-        } else {
-            int result;
-#if CYTHON_USE_UNICODE_INTERNALS && (PY_VERSION_HEX < 0x030B0000)
-            Py_hash_t hash1, hash2;
-            hash1 = ((PyBytesObject*)s1)->ob_shash;
-            hash2 = ((PyBytesObject*)s2)->ob_shash;
-            if (hash1 != hash2 && hash1 != -1 && hash2 != -1) {
-                return (equals == Py_NE);
-            }
-#endif
-            result = memcmp(ps1, ps2, (size_t)length);
-            return (equals == Py_EQ) ? (result == 0) : (result != 0);
-        }
-    } else if ((s1 == Py_None) & PyBytes_CheckExact(s2)) {
-        return (equals == Py_NE);
-    } else if ((s2 == Py_None) & PyBytes_CheckExact(s1)) {
-        return (equals == Py_NE);
-    } else {
-        int result;
-        PyObject* py_result = PyObject_RichCompare(s1, s2, equals);
-        if (!py_result)
-            return -1;
-        result = __Pyx_PyObject_IsTrue(py_result);
-        Py_DECREF(py_result);
-        return result;
-    }
-#endif
-}
-
-/* JoinPyUnicode */
-static PyObject* __Pyx_PyUnicode_Join(PyObject* value_tuple, Py_ssize_t value_count, Py_ssize_t result_ulength,
-                                      CYTHON_UNUSED Py_UCS4 max_char) {
-#if CYTHON_USE_UNICODE_INTERNALS && CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-    PyObject *result_uval;
-    int result_ukind;
-    Py_ssize_t i, char_pos;
-    void *result_udata;
-#if CYTHON_PEP393_ENABLED
-    result_uval = PyUnicode_New(result_ulength, max_char);
-    if (unlikely(!result_uval)) return NULL;
-    result_ukind = (max_char <= 255) ? PyUnicode_1BYTE_KIND : (max_char <= 65535) ? PyUnicode_2BYTE_KIND : PyUnicode_4BYTE_KIND;
-    result_udata = PyUnicode_DATA(result_uval);
-#else
-    result_uval = PyUnicode_FromUnicode(NULL, result_ulength);
-    if (unlikely(!result_uval)) return NULL;
-    result_ukind = sizeof(Py_UNICODE);
-    result_udata = PyUnicode_AS_UNICODE(result_uval);
-#endif
-    char_pos = 0;
-    for (i=0; i < value_count; i++) {
-        int ukind;
-        Py_ssize_t ulength;
-        void *udata;
-        PyObject *uval = PyTuple_GET_ITEM(value_tuple, i);
-        if (unlikely(__Pyx_PyUnicode_READY(uval)))
-            goto bad;
-        ulength = __Pyx_PyUnicode_GET_LENGTH(uval);
-        if (unlikely(!ulength))
-            continue;
-        if (unlikely(char_pos + ulength < 0))
-            goto overflow;
-        ukind = __Pyx_PyUnicode_KIND(uval);
-        udata = __Pyx_PyUnicode_DATA(uval);
-        if (!CYTHON_PEP393_ENABLED || ukind == result_ukind) {
-            memcpy((char *)result_udata + char_pos * result_ukind, udata, (size_t) (ulength * result_ukind));
-        } else {
-            #if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX >= 0x030300F0 || defined(_PyUnicode_FastCopyCharacters)
-            _PyUnicode_FastCopyCharacters(result_uval, char_pos, uval, 0, ulength);
-            #else
-            Py_ssize_t j;
-            for (j=0; j < ulength; j++) {
-                Py_UCS4 uchar = __Pyx_PyUnicode_READ(ukind, udata, j);
-                __Pyx_PyUnicode_WRITE(result_ukind, result_udata, char_pos+j, uchar);
-            }
-            #endif
-        }
-        char_pos += ulength;
-    }
-    return result_uval;
-overflow:
-    PyErr_SetString(PyExc_OverflowError, "join() result is too long for a Python string");
-bad:
-    Py_DECREF(result_uval);
-    return NULL;
-#else
-    result_ulength++;
-    value_count++;
-    return PyUnicode_Join(__pyx_empty_unicode, value_tuple);
-#endif
-}
-
-/* decode_c_bytes */
-static CYTHON_INLINE PyObject* __Pyx_decode_c_bytes(
-         const char* cstring, Py_ssize_t length, Py_ssize_t start, Py_ssize_t stop,
-         const char* encoding, const char* errors,
-         PyObject* (*decode_func)(const char *s, Py_ssize_t size, const char *errors)) {
-    if (unlikely((start < 0) | (stop < 0))) {
-        if (start < 0) {
-            start += length;
-            if (start < 0)
-                start = 0;
-        }
-        if (stop < 0)
-            stop += length;
-    }
-    if (stop > length)
-        stop = length;
-    if (unlikely(stop <= start))
-        return __Pyx_NewRef(__pyx_empty_unicode);
-    length = stop - start;
-    cstring += start;
-    if (decode_func) {
-        return decode_func(cstring, length, errors);
-    } else {
-        return PyUnicode_Decode(cstring, length, encoding, errors);
-    }
-}
-
-/* CIntToDigits */
-static const char DIGIT_PAIRS_10[2*10*10+1] = {
-    "00010203040506070809"
-    "10111213141516171819"
-    "20212223242526272829"
-    "30313233343536373839"
-    "40414243444546474849"
-    "50515253545556575859"
-    "60616263646566676869"
-    "70717273747576777879"
-    "80818283848586878889"
-    "90919293949596979899"
-};
-static const char DIGIT_PAIRS_8[2*8*8+1] = {
-    "0001020304050607"
-    "1011121314151617"
-    "2021222324252627"
-    "3031323334353637"
-    "4041424344454647"
-    "5051525354555657"
-    "6061626364656667"
-    "7071727374757677"
-};
-static const char DIGITS_HEX[2*16+1] = {
-    "0123456789abcdef"
-    "0123456789ABCDEF"
-};
-
-/* BuildPyUnicode */
-static PyObject* __Pyx_PyUnicode_BuildFromAscii(Py_ssize_t ulength, char* chars, int clength,
-                                                int prepend_sign, char padding_char) {
-    PyObject *uval;
-    Py_ssize_t uoffset = ulength - clength;
-#if CYTHON_USE_UNICODE_INTERNALS
-    Py_ssize_t i;
-#if CYTHON_PEP393_ENABLED
-    void *udata;
-    uval = PyUnicode_New(ulength, 127);
-    if (unlikely(!uval)) return NULL;
-    udata = PyUnicode_DATA(uval);
-#else
-    Py_UNICODE *udata;
-    uval = PyUnicode_FromUnicode(NULL, ulength);
-    if (unlikely(!uval)) return NULL;
-    udata = PyUnicode_AS_UNICODE(uval);
-#endif
-    if (uoffset > 0) {
-        i = 0;
-        if (prepend_sign) {
-            __Pyx_PyUnicode_WRITE(PyUnicode_1BYTE_KIND, udata, 0, '-');
-            i++;
-        }
-        for (; i < uoffset; i++) {
-            __Pyx_PyUnicode_WRITE(PyUnicode_1BYTE_KIND, udata, i, padding_char);
-        }
-    }
-    for (i=0; i < clength; i++) {
-        __Pyx_PyUnicode_WRITE(PyUnicode_1BYTE_KIND, udata, uoffset+i, chars[i]);
-    }
-#else
-    {
-        PyObject *sign = NULL, *padding = NULL;
-        uval = NULL;
-        if (uoffset > 0) {
-            prepend_sign = !!prepend_sign;
-            if (uoffset > prepend_sign) {
-                padding = PyUnicode_FromOrdinal(padding_char);
-                if (likely(padding) && uoffset > prepend_sign + 1) {
-                    PyObject *tmp;
-                    PyObject *repeat = PyInt_FromSsize_t(uoffset - prepend_sign);
-                    if (unlikely(!repeat)) goto done_or_error;
-                    tmp = PyNumber_Multiply(padding, repeat);
-                    Py_DECREF(repeat);
-                    Py_DECREF(padding);
-                    padding = tmp;
-                }
-                if (unlikely(!padding)) goto done_or_error;
-            }
-            if (prepend_sign) {
-                sign = PyUnicode_FromOrdinal('-');
-                if (unlikely(!sign)) goto done_or_error;
-            }
-        }
-        uval = PyUnicode_DecodeASCII(chars, clength, NULL);
-        if (likely(uval) && padding) {
-            PyObject *tmp = PyNumber_Add(padding, uval);
-            Py_DECREF(uval);
-            uval = tmp;
-        }
-        if (likely(uval) && sign) {
-            PyObject *tmp = PyNumber_Add(sign, uval);
-            Py_DECREF(uval);
-            uval = tmp;
-        }
-done_or_error:
-        Py_XDECREF(padding);
-        Py_XDECREF(sign);
-    }
-#endif
-    return uval;
-}
-
-/* CIntToPyUnicode */
-static CYTHON_INLINE PyObject* __Pyx_PyUnicode_From_Py_ssize_t(Py_ssize_t value, Py_ssize_t width, char padding_char, char format_char) {
-    char digits[sizeof(Py_ssize_t)*3+2];
-    char *dpos, *end = digits + sizeof(Py_ssize_t)*3+2;
-    const char *hex_digits = DIGITS_HEX;
-    Py_ssize_t length, ulength;
-    int prepend_sign, last_one_off;
-    Py_ssize_t remaining;
-#ifdef __Pyx_HAS_GCC_DIAGNOSTIC
-#pragma GCC diagnostic push
-#pragma GCC diagnostic ignored "-Wconversion"
-#endif
-    const Py_ssize_t neg_one = (Py_ssize_t) -1, const_zero = (Py_ssize_t) 0;
-#ifdef __Pyx_HAS_GCC_DIAGNOSTIC
-#pragma GCC diagnostic pop
-#endif
-    const int is_unsigned = neg_one > const_zero;
-    if (format_char == 'X') {
-        hex_digits += 16;
-        format_char = 'x';
-    }
-    remaining = value;
-    last_one_off = 0;
-    dpos = end;
-    do {
-        int digit_pos;
-        switch (format_char) {
-        case 'o':
-            digit_pos = abs((int)(remaining % (8*8)));
-            remaining = (Py_ssize_t) (remaining / (8*8));
-            dpos -= 2;
-            memcpy(dpos, DIGIT_PAIRS_8 + digit_pos * 2, 2);
-            last_one_off = (digit_pos < 8);
-            break;
-        case 'd':
-            digit_pos = abs((int)(remaining % (10*10)));
-            remaining = (Py_ssize_t) (remaining / (10*10));
-            dpos -= 2;
-            memcpy(dpos, DIGIT_PAIRS_10 + digit_pos * 2, 2);
-            last_one_off = (digit_pos < 10);
-            break;
-        case 'x':
-            *(--dpos) = hex_digits[abs((int)(remaining % 16))];
-            remaining = (Py_ssize_t) (remaining / 16);
-            break;
-        default:
-            assert(0);
-            break;
-        }
-    } while (unlikely(remaining != 0));
-    if (last_one_off) {
-        assert(*dpos == '0');
-        dpos++;
-    }
-    length = end - dpos;
-    ulength = length;
-    prepend_sign = 0;
-    if (!is_unsigned && value <= neg_one) {
-        if (padding_char == ' ' || width <= length + 1) {
-            *(--dpos) = '-';
-            ++length;
-        } else {
-            prepend_sign = 1;
-        }
-        ++ulength;
-    }
-    if (width > ulength) {
-        ulength = width;
-    }
-    if (ulength == 1) {
-        return PyUnicode_FromOrdinal(*dpos);
-    }
-    return __Pyx_PyUnicode_BuildFromAscii(ulength, dpos, (int) length, prepend_sign, padding_char);
-}
-
-/* PyObject_GenericGetAttrNoDict */
-#if CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP && PY_VERSION_HEX < 0x03070000
-static PyObject *__Pyx_RaiseGenericGetAttributeError(PyTypeObject *tp, PyObject *attr_name) {
-    PyErr_Format(PyExc_AttributeError,
-#if PY_MAJOR_VERSION >= 3
-                 "'%.50s' object has no attribute '%U'",
-                 tp->tp_name, attr_name);
-#else
-                 "'%.50s' object has no attribute '%.400s'",
-                 tp->tp_name, PyString_AS_STRING(attr_name));
-#endif
-    return NULL;
-}
-static CYTHON_INLINE PyObject* __Pyx_PyObject_GenericGetAttrNoDict(PyObject* obj, PyObject* attr_name) {
-    PyObject *descr;
-    PyTypeObject *tp = Py_TYPE(obj);
-    if (unlikely(!PyString_Check(attr_name))) {
-        return PyObject_GenericGetAttr(obj, attr_name);
-    }
-    assert(!tp->tp_dictoffset);
-    descr = _PyType_Lookup(tp, attr_name);
-    if (unlikely(!descr)) {
-        return __Pyx_RaiseGenericGetAttributeError(tp, attr_name);
-    }
-    Py_INCREF(descr);
-    #if PY_MAJOR_VERSION < 3
-    if (likely(PyType_HasFeature(Py_TYPE(descr), Py_TPFLAGS_HAVE_CLASS)))
-    #endif
-    {
-        descrgetfunc f = Py_TYPE(descr)->tp_descr_get;
-        if (unlikely(f)) {
-            PyObject *res = f(descr, obj, (PyObject *)tp);
-            Py_DECREF(descr);
-            return res;
-        }
-    }
-    return descr;
-}
-#endif
-
-/* PyObject_GenericGetAttr */
-#if CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP && PY_VERSION_HEX < 0x03070000
-static PyObject* __Pyx_PyObject_GenericGetAttr(PyObject* obj, PyObject* attr_name) {
-    if (unlikely(Py_TYPE(obj)->tp_dictoffset)) {
-        return PyObject_GenericGetAttr(obj, attr_name);
-    }
-    return __Pyx_PyObject_GenericGetAttrNoDict(obj, attr_name);
-}
-#endif
-
-/* SetVTable */
-static int __Pyx_SetVtable(PyObject *dict, void *vtable) {
-#if PY_VERSION_HEX >= 0x02070000
-    PyObject *ob = PyCapsule_New(vtable, 0, 0);
-#else
-    PyObject *ob = PyCObject_FromVoidPtr(vtable, 0);
-#endif
-    if (!ob)
-        goto bad;
-    if (PyDict_SetItem(dict, __pyx_n_s_pyx_vtable, ob) < 0)
-        goto bad;
-    Py_DECREF(ob);
-    return 0;
-bad:
-    Py_XDECREF(ob);
-    return -1;
-}
-
-/* PyErrExceptionMatches */
-#if CYTHON_FAST_THREAD_STATE
-static int __Pyx_PyErr_ExceptionMatchesTuple(PyObject *exc_type, PyObject *tuple) {
-    Py_ssize_t i, n;
-    n = PyTuple_GET_SIZE(tuple);
-#if PY_MAJOR_VERSION >= 3
-    for (i=0; i<n; i++) {
-        if (exc_type == PyTuple_GET_ITEM(tuple, i)) return 1;
-    }
-#endif
-    for (i=0; i<n; i++) {
-        if (__Pyx_PyErr_GivenExceptionMatches(exc_type, PyTuple_GET_ITEM(tuple, i))) return 1;
-    }
-    return 0;
-}
-static CYTHON_INLINE int __Pyx_PyErr_ExceptionMatchesInState(PyThreadState* tstate, PyObject* err) {
-    PyObject *exc_type = tstate->curexc_type;
-    if (exc_type == err) return 1;
-    if (unlikely(!exc_type)) return 0;
-    if (unlikely(PyTuple_Check(err)))
-        return __Pyx_PyErr_ExceptionMatchesTuple(exc_type, err);
-    return __Pyx_PyErr_GivenExceptionMatches(exc_type, err);
-}
-#endif
-
-/* PyObjectGetAttrStrNoError */
-static void __Pyx_PyObject_GetAttrStr_ClearAttributeError(void) {
-    __Pyx_PyThreadState_declare
-    __Pyx_PyThreadState_assign
-    if (likely(__Pyx_PyErr_ExceptionMatches(PyExc_AttributeError)))
-        __Pyx_PyErr_Clear();
-}
-static CYTHON_INLINE PyObject* __Pyx_PyObject_GetAttrStrNoError(PyObject* obj, PyObject* attr_name) {
-    PyObject *result;
-#if CYTHON_COMPILING_IN_CPYTHON && CYTHON_USE_TYPE_SLOTS && PY_VERSION_HEX >= 0x030700B1
-    PyTypeObject* tp = Py_TYPE(obj);
-    if (likely(tp->tp_getattro == PyObject_GenericGetAttr)) {
-        return _PyObject_GenericGetAttrWithDict(obj, attr_name, NULL, 1);
-    }
-#endif
-    result = __Pyx_PyObject_GetAttrStr(obj, attr_name);
-    if (unlikely(!result)) {
-        __Pyx_PyObject_GetAttrStr_ClearAttributeError();
-    }
-    return result;
-}
-
-/* SetupReduce */
-static int __Pyx_setup_reduce_is_named(PyObject* meth, PyObject* name) {
-  int ret;
-  PyObject *name_attr;
-  name_attr = __Pyx_PyObject_GetAttrStr(meth, __pyx_n_s_name);
-  if (likely(name_attr)) {
-      ret = PyObject_RichCompareBool(name_attr, name, Py_EQ);
-  } else {
-      ret = -1;
-  }
-  if (unlikely(ret < 0)) {
-      PyErr_Clear();
-      ret = 0;
-  }
-  Py_XDECREF(name_attr);
-  return ret;
-}
-static int __Pyx_setup_reduce(PyObject* type_obj) {
-    int ret = 0;
-    PyObject *object_reduce = NULL;
-    PyObject *object_getstate = NULL;
-    PyObject *object_reduce_ex = NULL;
-    PyObject *reduce = NULL;
-    PyObject *reduce_ex = NULL;
-    PyObject *reduce_cython = NULL;
-    PyObject *setstate = NULL;
-    PyObject *setstate_cython = NULL;
-    PyObject *getstate = NULL;
-#if CYTHON_USE_PYTYPE_LOOKUP
-    getstate = _PyType_Lookup((PyTypeObject*)type_obj, __pyx_n_s_getstate);
-#else
-    getstate = __Pyx_PyObject_GetAttrStrNoError(type_obj, __pyx_n_s_getstate);
-    if (!getstate && PyErr_Occurred()) {
-        goto __PYX_BAD;
-    }
-#endif
-    if (getstate) {
-#if CYTHON_USE_PYTYPE_LOOKUP
-        object_getstate = _PyType_Lookup(&PyBaseObject_Type, __pyx_n_s_getstate);
-#else
-        object_getstate = __Pyx_PyObject_GetAttrStrNoError((PyObject*)&PyBaseObject_Type, __pyx_n_s_getstate);
-        if (!object_getstate && PyErr_Occurred()) {
-            goto __PYX_BAD;
-        }
-#endif
-        if (object_getstate != getstate) {
-            goto __PYX_GOOD;
-        }
-    }
-#if CYTHON_USE_PYTYPE_LOOKUP
-    object_reduce_ex = _PyType_Lookup(&PyBaseObject_Type, __pyx_n_s_reduce_ex); if (!object_reduce_ex) goto __PYX_BAD;
-#else
-    object_reduce_ex = __Pyx_PyObject_GetAttrStr((PyObject*)&PyBaseObject_Type, __pyx_n_s_reduce_ex); if (!object_reduce_ex) goto __PYX_BAD;
-#endif
-    reduce_ex = __Pyx_PyObject_GetAttrStr(type_obj, __pyx_n_s_reduce_ex); if (unlikely(!reduce_ex)) goto __PYX_BAD;
-    if (reduce_ex == object_reduce_ex) {
-#if CYTHON_USE_PYTYPE_LOOKUP
-        object_reduce = _PyType_Lookup(&PyBaseObject_Type, __pyx_n_s_reduce); if (!object_reduce) goto __PYX_BAD;
-#else
-        object_reduce = __Pyx_PyObject_GetAttrStr((PyObject*)&PyBaseObject_Type, __pyx_n_s_reduce); if (!object_reduce) goto __PYX_BAD;
-#endif
-        reduce = __Pyx_PyObject_GetAttrStr(type_obj, __pyx_n_s_reduce); if (unlikely(!reduce)) goto __PYX_BAD;
-        if (reduce == object_reduce || __Pyx_setup_reduce_is_named(reduce, __pyx_n_s_reduce_cython)) {
-            reduce_cython = __Pyx_PyObject_GetAttrStrNoError(type_obj, __pyx_n_s_reduce_cython);
-            if (likely(reduce_cython)) {
-                ret = PyDict_SetItem(((PyTypeObject*)type_obj)->tp_dict, __pyx_n_s_reduce, reduce_cython); if (unlikely(ret < 0)) goto __PYX_BAD;
-                ret = PyDict_DelItem(((PyTypeObject*)type_obj)->tp_dict, __pyx_n_s_reduce_cython); if (unlikely(ret < 0)) goto __PYX_BAD;
-            } else if (reduce == object_reduce || PyErr_Occurred()) {
-                goto __PYX_BAD;
-            }
-            setstate = __Pyx_PyObject_GetAttrStr(type_obj, __pyx_n_s_setstate);
-            if (!setstate) PyErr_Clear();
-            if (!setstate || __Pyx_setup_reduce_is_named(setstate, __pyx_n_s_setstate_cython)) {
-                setstate_cython = __Pyx_PyObject_GetAttrStrNoError(type_obj, __pyx_n_s_setstate_cython);
-                if (likely(setstate_cython)) {
-                    ret = PyDict_SetItem(((PyTypeObject*)type_obj)->tp_dict, __pyx_n_s_setstate, setstate_cython); if (unlikely(ret < 0)) goto __PYX_BAD;
-                    ret = PyDict_DelItem(((PyTypeObject*)type_obj)->tp_dict, __pyx_n_s_setstate_cython); if (unlikely(ret < 0)) goto __PYX_BAD;
-                } else if (!setstate || PyErr_Occurred()) {
-                    goto __PYX_BAD;
-                }
-            }
-            PyType_Modified((PyTypeObject*)type_obj);
-        }
-    }
-    goto __PYX_GOOD;
-__PYX_BAD:
-    if (!PyErr_Occurred())
-        PyErr_Format(PyExc_RuntimeError, "Unable to initialize pickling for %s", ((PyTypeObject*)type_obj)->tp_name);
-    ret = -1;
-__PYX_GOOD:
-#if !CYTHON_USE_PYTYPE_LOOKUP
-    Py_XDECREF(object_reduce);
-    Py_XDECREF(object_reduce_ex);
-    Py_XDECREF(object_getstate);
-    Py_XDECREF(getstate);
-#endif
-    Py_XDECREF(reduce);
-    Py_XDECREF(reduce_ex);
-    Py_XDECREF(reduce_cython);
-    Py_XDECREF(setstate);
-    Py_XDECREF(setstate_cython);
-    return ret;
-}
-
-/* Import */
-static PyObject *__Pyx_Import(PyObject *name, PyObject *from_list, int level) {
-    PyObject *empty_list = 0;
-    PyObject *module = 0;
-    PyObject *global_dict = 0;
-    PyObject *empty_dict = 0;
-    PyObject *list;
-    #if PY_MAJOR_VERSION < 3
-    PyObject *py_import;
-    py_import = __Pyx_PyObject_GetAttrStr(__pyx_b, __pyx_n_s_import);
-    if (!py_import)
-        goto bad;
-    #endif
-    if (from_list)
-        list = from_list;
-    else {
-        empty_list = PyList_New(0);
-        if (!empty_list)
-            goto bad;
-        list = empty_list;
-    }
-    global_dict = PyModule_GetDict(__pyx_m);
-    if (!global_dict)
-        goto bad;
-    empty_dict = PyDict_New();
-    if (!empty_dict)
-        goto bad;
-    {
-        #if PY_MAJOR_VERSION >= 3
-        if (level == -1) {
-            if ((1) && (strchr(__Pyx_MODULE_NAME, '.'))) {
-                module = PyImport_ImportModuleLevelObject(
-                    name, global_dict, empty_dict, list, 1);
-                if (!module) {
-                    if (!PyErr_ExceptionMatches(PyExc_ImportError))
-                        goto bad;
-                    PyErr_Clear();
-                }
-            }
-            level = 0;
-        }
-        #endif
-        if (!module) {
-            #if PY_MAJOR_VERSION < 3
-            PyObject *py_level = PyInt_FromLong(level);
-            if (!py_level)
-                goto bad;
-            module = PyObject_CallFunctionObjArgs(py_import,
-                name, global_dict, empty_dict, list, py_level, (PyObject *)NULL);
-            Py_DECREF(py_level);
-            #else
-            module = PyImport_ImportModuleLevelObject(
-                name, global_dict, empty_dict, list, level);
-            #endif
-        }
-    }
-bad:
-    #if PY_MAJOR_VERSION < 3
-    Py_XDECREF(py_import);
-    #endif
-    Py_XDECREF(empty_list);
-    Py_XDECREF(empty_dict);
-    return module;
-}
-
-/* ImportFrom */
-static PyObject* __Pyx_ImportFrom(PyObject* module, PyObject* name) {
-    PyObject* value = __Pyx_PyObject_GetAttrStr(module, name);
-    if (unlikely(!value) && PyErr_ExceptionMatches(PyExc_AttributeError)) {
-        PyErr_Format(PyExc_ImportError,
-        #if PY_MAJOR_VERSION < 3
-            "cannot import name %.230s", PyString_AS_STRING(name));
-        #else
-            "cannot import name %S", name);
-        #endif
-    }
-    return value;
-}
-
-/* FetchCommonType */
-static PyTypeObject* __Pyx_FetchCommonType(PyTypeObject* type) {
-    PyObject* fake_module;
-    PyTypeObject* cached_type = NULL;
-    fake_module = PyImport_AddModule((char*) "_cython_" CYTHON_ABI);
-    if (!fake_module) return NULL;
-    Py_INCREF(fake_module);
-    cached_type = (PyTypeObject*) PyObject_GetAttrString(fake_module, type->tp_name);
-    if (cached_type) {
-        if (!PyType_Check((PyObject*)cached_type)) {
-            PyErr_Format(PyExc_TypeError,
-                "Shared Cython type %.200s is not a type object",
-                type->tp_name);
-            goto bad;
-        }
-        if (cached_type->tp_basicsize != type->tp_basicsize) {
-            PyErr_Format(PyExc_TypeError,
-                "Shared Cython type %.200s has the wrong size, try recompiling",
-                type->tp_name);
-            goto bad;
-        }
-    } else {
-        if (!PyErr_ExceptionMatches(PyExc_AttributeError)) goto bad;
-        PyErr_Clear();
-        if (PyType_Ready(type) < 0) goto bad;
-        if (PyObject_SetAttrString(fake_module, type->tp_name, (PyObject*) type) < 0)
-            goto bad;
-        Py_INCREF(type);
-        cached_type = type;
-    }
-done:
-    Py_DECREF(fake_module);
-    return cached_type;
-bad:
-    Py_XDECREF(cached_type);
-    cached_type = NULL;
-    goto done;
-}
-
-/* CythonFunctionShared */
-#include <structmember.h>
-static PyObject *
-__Pyx_CyFunction_get_doc(__pyx_CyFunctionObject *op, CYTHON_UNUSED void *closure)
-{
-    if (unlikely(op->func_doc == NULL)) {
-        if (op->func.m_ml->ml_doc) {
-#if PY_MAJOR_VERSION >= 3
-            op->func_doc = PyUnicode_FromString(op->func.m_ml->ml_doc);
-#else
-            op->func_doc = PyString_FromString(op->func.m_ml->ml_doc);
-#endif
-            if (unlikely(op->func_doc == NULL))
-                return NULL;
-        } else {
-            Py_INCREF(Py_None);
-            return Py_None;
-        }
-    }
-    Py_INCREF(op->func_doc);
-    return op->func_doc;
-}
-static int
-__Pyx_CyFunction_set_doc(__pyx_CyFunctionObject *op, PyObject *value, CYTHON_UNUSED void *context)
-{
-    PyObject *tmp = op->func_doc;
-    if (value == NULL) {
-        value = Py_None;
-    }
-    Py_INCREF(value);
-    op->func_doc = value;
-    Py_XDECREF(tmp);
-    return 0;
-}
-static PyObject *
-__Pyx_CyFunction_get_name(__pyx_CyFunctionObject *op, CYTHON_UNUSED void *context)
-{
-    if (unlikely(op->func_name == NULL)) {
-#if PY_MAJOR_VERSION >= 3
-        op->func_name = PyUnicode_InternFromString(op->func.m_ml->ml_name);
-#else
-        op->func_name = PyString_InternFromString(op->func.m_ml->ml_name);
-#endif
-        if (unlikely(op->func_name == NULL))
-            return NULL;
-    }
-    Py_INCREF(op->func_name);
-    return op->func_name;
-}
-static int
-__Pyx_CyFunction_set_name(__pyx_CyFunctionObject *op, PyObject *value, CYTHON_UNUSED void *context)
-{
-    PyObject *tmp;
-#if PY_MAJOR_VERSION >= 3
-    if (unlikely(value == NULL || !PyUnicode_Check(value)))
-#else
-    if (unlikely(value == NULL || !PyString_Check(value)))
-#endif
-    {
-        PyErr_SetString(PyExc_TypeError,
-                        "__name__ must be set to a string object");
-        return -1;
-    }
-    tmp = op->func_name;
-    Py_INCREF(value);
-    op->func_name = value;
-    Py_XDECREF(tmp);
-    return 0;
-}
-static PyObject *
-__Pyx_CyFunction_get_qualname(__pyx_CyFunctionObject *op, CYTHON_UNUSED void *context)
-{
-    Py_INCREF(op->func_qualname);
-    return op->func_qualname;
-}
-static int
-__Pyx_CyFunction_set_qualname(__pyx_CyFunctionObject *op, PyObject *value, CYTHON_UNUSED void *context)
-{
-    PyObject *tmp;
-#if PY_MAJOR_VERSION >= 3
-    if (unlikely(value == NULL || !PyUnicode_Check(value)))
-#else
-    if (unlikely(value == NULL || !PyString_Check(value)))
-#endif
-    {
-        PyErr_SetString(PyExc_TypeError,
-                        "__qualname__ must be set to a string object");
-        return -1;
-    }
-    tmp = op->func_qualname;
-    Py_INCREF(value);
-    op->func_qualname = value;
-    Py_XDECREF(tmp);
-    return 0;
-}
-static PyObject *
-__Pyx_CyFunction_get_self(__pyx_CyFunctionObject *m, CYTHON_UNUSED void *closure)
-{
-    PyObject *self;
-    self = m->func_closure;
-    if (self == NULL)
-        self = Py_None;
-    Py_INCREF(self);
-    return self;
-}
-static PyObject *
-__Pyx_CyFunction_get_dict(__pyx_CyFunctionObject *op, CYTHON_UNUSED void *context)
-{
-    if (unlikely(op->func_dict == NULL)) {
-        op->func_dict = PyDict_New();
-        if (unlikely(op->func_dict == NULL))
-            return NULL;
-    }
-    Py_INCREF(op->func_dict);
-    return op->func_dict;
-}
-static int
-__Pyx_CyFunction_set_dict(__pyx_CyFunctionObject *op, PyObject *value, CYTHON_UNUSED void *context)
-{
-    PyObject *tmp;
-    if (unlikely(value == NULL)) {
-        PyErr_SetString(PyExc_TypeError,
-               "function's dictionary may not be deleted");
-        return -1;
-    }
-    if (unlikely(!PyDict_Check(value))) {
-        PyErr_SetString(PyExc_TypeError,
-               "setting function's dictionary to a non-dict");
-        return -1;
-    }
-    tmp = op->func_dict;
-    Py_INCREF(value);
-    op->func_dict = value;
-    Py_XDECREF(tmp);
-    return 0;
-}
-static PyObject *
-__Pyx_CyFunction_get_globals(__pyx_CyFunctionObject *op, CYTHON_UNUSED void *context)
-{
-    Py_INCREF(op->func_globals);
-    return op->func_globals;
-}
-static PyObject *
-__Pyx_CyFunction_get_closure(CYTHON_UNUSED __pyx_CyFunctionObject *op, CYTHON_UNUSED void *context)
-{
-    Py_INCREF(Py_None);
-    return Py_None;
-}
-static PyObject *
-__Pyx_CyFunction_get_code(__pyx_CyFunctionObject *op, CYTHON_UNUSED void *context)
-{
-    PyObject* result = (op->func_code) ? op->func_code : Py_None;
-    Py_INCREF(result);
-    return result;
-}
-static int
-__Pyx_CyFunction_init_defaults(__pyx_CyFunctionObject *op) {
-    int result = 0;
-    PyObject *res = op->defaults_getter((PyObject *) op);
-    if (unlikely(!res))
-        return -1;
-    #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-    op->defaults_tuple = PyTuple_GET_ITEM(res, 0);
-    Py_INCREF(op->defaults_tuple);
-    op->defaults_kwdict = PyTuple_GET_ITEM(res, 1);
-    Py_INCREF(op->defaults_kwdict);
-    #else
-    op->defaults_tuple = PySequence_ITEM(res, 0);
-    if (unlikely(!op->defaults_tuple)) result = -1;
-    else {
-        op->defaults_kwdict = PySequence_ITEM(res, 1);
-        if (unlikely(!op->defaults_kwdict)) result = -1;
-    }
-    #endif
-    Py_DECREF(res);
-    return result;
-}
-static int
-__Pyx_CyFunction_set_defaults(__pyx_CyFunctionObject *op, PyObject* value, CYTHON_UNUSED void *context) {
-    PyObject* tmp;
-    if (!value) {
-        value = Py_None;
-    } else if (value != Py_None && !PyTuple_Check(value)) {
-        PyErr_SetString(PyExc_TypeError,
-                        "__defaults__ must be set to a tuple object");
-        return -1;
-    }
-    Py_INCREF(value);
-    tmp = op->defaults_tuple;
-    op->defaults_tuple = value;
-    Py_XDECREF(tmp);
-    return 0;
-}
-static PyObject *
-__Pyx_CyFunction_get_defaults(__pyx_CyFunctionObject *op, CYTHON_UNUSED void *context) {
-    PyObject* result = op->defaults_tuple;
-    if (unlikely(!result)) {
-        if (op->defaults_getter) {
-            if (__Pyx_CyFunction_init_defaults(op) < 0) return NULL;
-            result = op->defaults_tuple;
-        } else {
-            result = Py_None;
-        }
-    }
-    Py_INCREF(result);
-    return result;
-}
-static int
-__Pyx_CyFunction_set_kwdefaults(__pyx_CyFunctionObject *op, PyObject* value, CYTHON_UNUSED void *context) {
-    PyObject* tmp;
-    if (!value) {
-        value = Py_None;
-    } else if (value != Py_None && !PyDict_Check(value)) {
-        PyErr_SetString(PyExc_TypeError,
-                        "__kwdefaults__ must be set to a dict object");
-        return -1;
-    }
-    Py_INCREF(value);
-    tmp = op->defaults_kwdict;
-    op->defaults_kwdict = value;
-    Py_XDECREF(tmp);
-    return 0;
-}
-static PyObject *
-__Pyx_CyFunction_get_kwdefaults(__pyx_CyFunctionObject *op, CYTHON_UNUSED void *context) {
-    PyObject* result = op->defaults_kwdict;
-    if (unlikely(!result)) {
-        if (op->defaults_getter) {
-            if (__Pyx_CyFunction_init_defaults(op) < 0) return NULL;
-            result = op->defaults_kwdict;
-        } else {
-            result = Py_None;
-        }
-    }
-    Py_INCREF(result);
-    return result;
-}
-static int
-__Pyx_CyFunction_set_annotations(__pyx_CyFunctionObject *op, PyObject* value, CYTHON_UNUSED void *context) {
-    PyObject* tmp;
-    if (!value || value == Py_None) {
-        value = NULL;
-    } else if (!PyDict_Check(value)) {
-        PyErr_SetString(PyExc_TypeError,
-                        "__annotations__ must be set to a dict object");
-        return -1;
-    }
-    Py_XINCREF(value);
-    tmp = op->func_annotations;
-    op->func_annotations = value;
-    Py_XDECREF(tmp);
-    return 0;
-}
-static PyObject *
-__Pyx_CyFunction_get_annotations(__pyx_CyFunctionObject *op, CYTHON_UNUSED void *context) {
-    PyObject* result = op->func_annotations;
-    if (unlikely(!result)) {
-        result = PyDict_New();
-        if (unlikely(!result)) return NULL;
-        op->func_annotations = result;
-    }
-    Py_INCREF(result);
-    return result;
-}
-static PyGetSetDef __pyx_CyFunction_getsets[] = {
-    {(char *) "func_doc", (getter)__Pyx_CyFunction_get_doc, (setter)__Pyx_CyFunction_set_doc, 0, 0},
-    {(char *) "__doc__",  (getter)__Pyx_CyFunction_get_doc, (setter)__Pyx_CyFunction_set_doc, 0, 0},
-    {(char *) "func_name", (getter)__Pyx_CyFunction_get_name, (setter)__Pyx_CyFunction_set_name, 0, 0},
-    {(char *) "__name__", (getter)__Pyx_CyFunction_get_name, (setter)__Pyx_CyFunction_set_name, 0, 0},
-    {(char *) "__qualname__", (getter)__Pyx_CyFunction_get_qualname, (setter)__Pyx_CyFunction_set_qualname, 0, 0},
-    {(char *) "__self__", (getter)__Pyx_CyFunction_get_self, 0, 0, 0},
-    {(char *) "func_dict", (getter)__Pyx_CyFunction_get_dict, (setter)__Pyx_CyFunction_set_dict, 0, 0},
-    {(char *) "__dict__", (getter)__Pyx_CyFunction_get_dict, (setter)__Pyx_CyFunction_set_dict, 0, 0},
-    {(char *) "func_globals", (getter)__Pyx_CyFunction_get_globals, 0, 0, 0},
-    {(char *) "__globals__", (getter)__Pyx_CyFunction_get_globals, 0, 0, 0},
-    {(char *) "func_closure", (getter)__Pyx_CyFunction_get_closure, 0, 0, 0},
-    {(char *) "__closure__", (getter)__Pyx_CyFunction_get_closure, 0, 0, 0},
-    {(char *) "func_code", (getter)__Pyx_CyFunction_get_code, 0, 0, 0},
-    {(char *) "__code__", (getter)__Pyx_CyFunction_get_code, 0, 0, 0},
-    {(char *) "func_defaults", (getter)__Pyx_CyFunction_get_defaults, (setter)__Pyx_CyFunction_set_defaults, 0, 0},
-    {(char *) "__defaults__", (getter)__Pyx_CyFunction_get_defaults, (setter)__Pyx_CyFunction_set_defaults, 0, 0},
-    {(char *) "__kwdefaults__", (getter)__Pyx_CyFunction_get_kwdefaults, (setter)__Pyx_CyFunction_set_kwdefaults, 0, 0},
-    {(char *) "__annotations__", (getter)__Pyx_CyFunction_get_annotations, (setter)__Pyx_CyFunction_set_annotations, 0, 0},
-    {0, 0, 0, 0, 0}
-};
-static PyMemberDef __pyx_CyFunction_members[] = {
-    {(char *) "__module__", T_OBJECT, offsetof(PyCFunctionObject, m_module), PY_WRITE_RESTRICTED, 0},
-    {0, 0, 0,  0, 0}
-};
-static PyObject *
-__Pyx_CyFunction_reduce(__pyx_CyFunctionObject *m, CYTHON_UNUSED PyObject *args)
-{
-#if PY_MAJOR_VERSION >= 3
-    Py_INCREF(m->func_qualname);
-    return m->func_qualname;
-#else
-    return PyString_FromString(m->func.m_ml->ml_name);
-#endif
-}
-static PyMethodDef __pyx_CyFunction_methods[] = {
-    {"__reduce__", (PyCFunction)__Pyx_CyFunction_reduce, METH_VARARGS, 0},
-    {0, 0, 0, 0}
-};
-#if PY_VERSION_HEX < 0x030500A0
-#define __Pyx_CyFunction_weakreflist(cyfunc) ((cyfunc)->func_weakreflist)
-#else
-#define __Pyx_CyFunction_weakreflist(cyfunc) ((cyfunc)->func.m_weakreflist)
-#endif
-static PyObject *__Pyx_CyFunction_Init(__pyx_CyFunctionObject *op, PyMethodDef *ml, int flags, PyObject* qualname,
-                                       PyObject *closure, PyObject *module, PyObject* globals, PyObject* code) {
-    if (unlikely(op == NULL))
-        return NULL;
-    op->flags = flags;
-    __Pyx_CyFunction_weakreflist(op) = NULL;
-    op->func.m_ml = ml;
-    op->func.m_self = (PyObject *) op;
-    Py_XINCREF(closure);
-    op->func_closure = closure;
-    Py_XINCREF(module);
-    op->func.m_module = module;
-    op->func_dict = NULL;
-    op->func_name = NULL;
-    Py_INCREF(qualname);
-    op->func_qualname = qualname;
-    op->func_doc = NULL;
-    op->func_classobj = NULL;
-    op->func_globals = globals;
-    Py_INCREF(op->func_globals);
-    Py_XINCREF(code);
-    op->func_code = code;
-    op->defaults_pyobjects = 0;
-    op->defaults_size = 0;
-    op->defaults = NULL;
-    op->defaults_tuple = NULL;
-    op->defaults_kwdict = NULL;
-    op->defaults_getter = NULL;
-    op->func_annotations = NULL;
-    return (PyObject *) op;
-}
-static int
-__Pyx_CyFunction_clear(__pyx_CyFunctionObject *m)
-{
-    Py_CLEAR(m->func_closure);
-    Py_CLEAR(m->func.m_module);
-    Py_CLEAR(m->func_dict);
-    Py_CLEAR(m->func_name);
-    Py_CLEAR(m->func_qualname);
-    Py_CLEAR(m->func_doc);
-    Py_CLEAR(m->func_globals);
-    Py_CLEAR(m->func_code);
-    Py_CLEAR(m->func_classobj);
-    Py_CLEAR(m->defaults_tuple);
-    Py_CLEAR(m->defaults_kwdict);
-    Py_CLEAR(m->func_annotations);
-    if (m->defaults) {
-        PyObject **pydefaults = __Pyx_CyFunction_Defaults(PyObject *, m);
-        int i;
-        for (i = 0; i < m->defaults_pyobjects; i++)
-            Py_XDECREF(pydefaults[i]);
-        PyObject_Free(m->defaults);
-        m->defaults = NULL;
-    }
-    return 0;
-}
-static void __Pyx__CyFunction_dealloc(__pyx_CyFunctionObject *m)
-{
-    if (__Pyx_CyFunction_weakreflist(m) != NULL)
-        PyObject_ClearWeakRefs((PyObject *) m);
-    __Pyx_CyFunction_clear(m);
-    PyObject_GC_Del(m);
-}
-static void __Pyx_CyFunction_dealloc(__pyx_CyFunctionObject *m)
-{
-    PyObject_GC_UnTrack(m);
-    __Pyx__CyFunction_dealloc(m);
-}
-static int __Pyx_CyFunction_traverse(__pyx_CyFunctionObject *m, visitproc visit, void *arg)
-{
-    Py_VISIT(m->func_closure);
-    Py_VISIT(m->func.m_module);
-    Py_VISIT(m->func_dict);
-    Py_VISIT(m->func_name);
-    Py_VISIT(m->func_qualname);
-    Py_VISIT(m->func_doc);
-    Py_VISIT(m->func_globals);
-    Py_VISIT(m->func_code);
-    Py_VISIT(m->func_classobj);
-    Py_VISIT(m->defaults_tuple);
-    Py_VISIT(m->defaults_kwdict);
-    if (m->defaults) {
-        PyObject **pydefaults = __Pyx_CyFunction_Defaults(PyObject *, m);
-        int i;
-        for (i = 0; i < m->defaults_pyobjects; i++)
-            Py_VISIT(pydefaults[i]);
-    }
-    return 0;
-}
-static PyObject *__Pyx_CyFunction_descr_get(PyObject *func, PyObject *obj, PyObject *type)
-{
-#if PY_MAJOR_VERSION < 3
-    __pyx_CyFunctionObject *m = (__pyx_CyFunctionObject *) func;
-    if (m->flags & __Pyx_CYFUNCTION_STATICMETHOD) {
-        Py_INCREF(func);
-        return func;
-    }
-    if (m->flags & __Pyx_CYFUNCTION_CLASSMETHOD) {
-        if (type == NULL)
-            type = (PyObject *)(Py_TYPE(obj));
-        return __Pyx_PyMethod_New(func, type, (PyObject *)(Py_TYPE(type)));
-    }
-    if (obj == Py_None)
-        obj = NULL;
-#endif
-    return __Pyx_PyMethod_New(func, obj, type);
-}
-static PyObject*
-__Pyx_CyFunction_repr(__pyx_CyFunctionObject *op)
-{
-#if PY_MAJOR_VERSION >= 3
-    return PyUnicode_FromFormat("<cyfunction %U at %p>",
-                                op->func_qualname, (void *)op);
-#else
-    return PyString_FromFormat("<cyfunction %s at %p>",
-                               PyString_AsString(op->func_qualname), (void *)op);
-#endif
-}
-static PyObject * __Pyx_CyFunction_CallMethod(PyObject *func, PyObject *self, PyObject *arg, PyObject *kw) {
-    PyCFunctionObject* f = (PyCFunctionObject*)func;
-    PyCFunction meth = f->m_ml->ml_meth;
-    Py_ssize_t size;
-    switch (f->m_ml->ml_flags & (METH_VARARGS | METH_KEYWORDS | METH_NOARGS | METH_O)) {
-    case METH_VARARGS:
-        if (likely(kw == NULL || PyDict_Size(kw) == 0))
-            return (*meth)(self, arg);
-        break;
-    case METH_VARARGS | METH_KEYWORDS:
-        return (*(PyCFunctionWithKeywords)(void*)meth)(self, arg, kw);
-    case METH_NOARGS:
-        if (likely(kw == NULL || PyDict_Size(kw) == 0)) {
-            size = PyTuple_GET_SIZE(arg);
-            if (likely(size == 0))
-                return (*meth)(self, NULL);
-            PyErr_Format(PyExc_TypeError,
-                "%.200s() takes no arguments (%" CYTHON_FORMAT_SSIZE_T "d given)",
-                f->m_ml->ml_name, size);
-            return NULL;
-        }
-        break;
-    case METH_O:
-        if (likely(kw == NULL || PyDict_Size(kw) == 0)) {
-            size = PyTuple_GET_SIZE(arg);
-            if (likely(size == 1)) {
-                PyObject *result, *arg0;
-                #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-                arg0 = PyTuple_GET_ITEM(arg, 0);
-                #else
-                arg0 = PySequence_ITEM(arg, 0); if (unlikely(!arg0)) return NULL;
-                #endif
-                result = (*meth)(self, arg0);
-                #if !(CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS)
-                Py_DECREF(arg0);
-                #endif
-                return result;
-            }
-            PyErr_Format(PyExc_TypeError,
-                "%.200s() takes exactly one argument (%" CYTHON_FORMAT_SSIZE_T "d given)",
-                f->m_ml->ml_name, size);
-            return NULL;
-        }
-        break;
-    default:
-        PyErr_SetString(PyExc_SystemError, "Bad call flags in "
-                        "__Pyx_CyFunction_Call. METH_OLDARGS is no "
-                        "longer supported!");
-        return NULL;
-    }
-    PyErr_Format(PyExc_TypeError, "%.200s() takes no keyword arguments",
-                 f->m_ml->ml_name);
-    return NULL;
-}
-static CYTHON_INLINE PyObject *__Pyx_CyFunction_Call(PyObject *func, PyObject *arg, PyObject *kw) {
-    return __Pyx_CyFunction_CallMethod(func, ((PyCFunctionObject*)func)->m_self, arg, kw);
-}
-static PyObject *__Pyx_CyFunction_CallAsMethod(PyObject *func, PyObject *args, PyObject *kw) {
-    PyObject *result;
-    __pyx_CyFunctionObject *cyfunc = (__pyx_CyFunctionObject *) func;
-    if ((cyfunc->flags & __Pyx_CYFUNCTION_CCLASS) && !(cyfunc->flags & __Pyx_CYFUNCTION_STATICMETHOD)) {
-        Py_ssize_t argc;
-        PyObject *new_args;
-        PyObject *self;
-        argc = PyTuple_GET_SIZE(args);
-        new_args = PyTuple_GetSlice(args, 1, argc);
-        if (unlikely(!new_args))
-            return NULL;
-        self = PyTuple_GetItem(args, 0);
-        if (unlikely(!self)) {
-            Py_DECREF(new_args);
-            PyErr_Format(PyExc_TypeError,
-                         "unbound method %.200S() needs an argument",
-                         cyfunc->func_qualname);
-            return NULL;
-        }
-        result = __Pyx_CyFunction_CallMethod(func, self, new_args, kw);
-        Py_DECREF(new_args);
-    } else {
-        result = __Pyx_CyFunction_Call(func, args, kw);
-    }
-    return result;
-}
-static PyTypeObject __pyx_CyFunctionType_type = {
-    PyVarObject_HEAD_INIT(0, 0)
-    "cython_function_or_method",
-    sizeof(__pyx_CyFunctionObject),
-    0,
-    (destructor) __Pyx_CyFunction_dealloc,
-    0,
-    0,
-    0,
-#if PY_MAJOR_VERSION < 3
-    0,
-#else
-    0,
-#endif
-    (reprfunc) __Pyx_CyFunction_repr,
-    0,
-    0,
-    0,
-    0,
-    __Pyx_CyFunction_CallAsMethod,
-    0,
-    0,
-    0,
-    0,
-    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC,
-    0,
-    (traverseproc) __Pyx_CyFunction_traverse,
-    (inquiry) __Pyx_CyFunction_clear,
-    0,
-#if PY_VERSION_HEX < 0x030500A0
-    offsetof(__pyx_CyFunctionObject, func_weakreflist),
-#else
-    offsetof(PyCFunctionObject, m_weakreflist),
-#endif
-    0,
-    0,
-    __pyx_CyFunction_methods,
-    __pyx_CyFunction_members,
-    __pyx_CyFunction_getsets,
-    0,
-    0,
-    __Pyx_CyFunction_descr_get,
-    0,
-    offsetof(__pyx_CyFunctionObject, func_dict),
-    0,
-    0,
-    0,
-    0,
-    0,
-    0,
-    0,
-    0,
-    0,
-    0,
-    0,
-    0,
-#if PY_VERSION_HEX >= 0x030400a1
-    0,
-#endif
-#if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
-    0,
-#endif
-#if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
-    0,
-#endif
-#if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
-    0,
-#endif
-};
-static int __pyx_CyFunction_init(void) {
-    __pyx_CyFunctionType = __Pyx_FetchCommonType(&__pyx_CyFunctionType_type);
-    if (unlikely(__pyx_CyFunctionType == NULL)) {
-        return -1;
-    }
-    return 0;
-}
-static CYTHON_INLINE void *__Pyx_CyFunction_InitDefaults(PyObject *func, size_t size, int pyobjects) {
-    __pyx_CyFunctionObject *m = (__pyx_CyFunctionObject *) func;
-    m->defaults = PyObject_Malloc(size);
-    if (unlikely(!m->defaults))
-        return PyErr_NoMemory();
-    memset(m->defaults, 0, size);
-    m->defaults_pyobjects = pyobjects;
-    m->defaults_size = size;
-    return m->defaults;
-}
-static CYTHON_INLINE void __Pyx_CyFunction_SetDefaultsTuple(PyObject *func, PyObject *tuple) {
-    __pyx_CyFunctionObject *m = (__pyx_CyFunctionObject *) func;
-    m->defaults_tuple = tuple;
-    Py_INCREF(tuple);
-}
-static CYTHON_INLINE void __Pyx_CyFunction_SetDefaultsKwDict(PyObject *func, PyObject *dict) {
-    __pyx_CyFunctionObject *m = (__pyx_CyFunctionObject *) func;
-    m->defaults_kwdict = dict;
-    Py_INCREF(dict);
-}
-static CYTHON_INLINE void __Pyx_CyFunction_SetAnnotationsDict(PyObject *func, PyObject *dict) {
-    __pyx_CyFunctionObject *m = (__pyx_CyFunctionObject *) func;
-    m->func_annotations = dict;
-    Py_INCREF(dict);
-}
-
-/* CythonFunction */
-static PyObject *__Pyx_CyFunction_New(PyMethodDef *ml, int flags, PyObject* qualname,
-                                      PyObject *closure, PyObject *module, PyObject* globals, PyObject* code) {
-    PyObject *op = __Pyx_CyFunction_Init(
-        PyObject_GC_New(__pyx_CyFunctionObject, __pyx_CyFunctionType),
-        ml, flags, qualname, closure, module, globals, code
-    );
-    if (likely(op)) {
-        PyObject_GC_Track(op);
-    }
-    return op;
-}
-
-/* GetNameInClass */
-static PyObject *__Pyx_GetGlobalNameAfterAttributeLookup(PyObject *name) {
-    PyObject *result;
-    __Pyx_PyThreadState_declare
-    __Pyx_PyThreadState_assign
-    if (unlikely(!__Pyx_PyErr_ExceptionMatches(PyExc_AttributeError)))
-        return NULL;
-    __Pyx_PyErr_Clear();
-    __Pyx_GetModuleGlobalNameUncached(result, name);
-    return result;
-}
-static PyObject *__Pyx__GetNameInClass(PyObject *nmspace, PyObject *name) {
-    PyObject *result;
-    result = __Pyx_PyObject_GetAttrStr(nmspace, name);
-    if (!result) {
-        result = __Pyx_GetGlobalNameAfterAttributeLookup(name);
-    }
-    return result;
-}
-
-/* CLineInTraceback */
-#ifndef CYTHON_CLINE_IN_TRACEBACK
-static int __Pyx_CLineForTraceback(CYTHON_NCP_UNUSED PyThreadState *tstate, int c_line) {
-    PyObject *use_cline;
-    PyObject *ptype, *pvalue, *ptraceback;
-#if CYTHON_COMPILING_IN_CPYTHON
-    PyObject **cython_runtime_dict;
-#endif
-    if (unlikely(!__pyx_cython_runtime)) {
-        return c_line;
-    }
-    __Pyx_ErrFetchInState(tstate, &ptype, &pvalue, &ptraceback);
-#if CYTHON_COMPILING_IN_CPYTHON
-    cython_runtime_dict = _PyObject_GetDictPtr(__pyx_cython_runtime);
-    if (likely(cython_runtime_dict)) {
-        __PYX_PY_DICT_LOOKUP_IF_MODIFIED(
-            use_cline, *cython_runtime_dict,
-            __Pyx_PyDict_GetItemStr(*cython_runtime_dict, __pyx_n_s_cline_in_traceback))
-    } else
-#endif
-    {
-      PyObject *use_cline_obj = __Pyx_PyObject_GetAttrStr(__pyx_cython_runtime, __pyx_n_s_cline_in_traceback);
-      if (use_cline_obj) {
-        use_cline = PyObject_Not(use_cline_obj) ? Py_False : Py_True;
-        Py_DECREF(use_cline_obj);
-      } else {
-        PyErr_Clear();
-        use_cline = NULL;
-      }
-    }
-    if (!use_cline) {
-        c_line = 0;
-        (void) PyObject_SetAttr(__pyx_cython_runtime, __pyx_n_s_cline_in_traceback, Py_False);
-    }
-    else if (use_cline == Py_False || (use_cline != Py_True && PyObject_Not(use_cline) != 0)) {
-        c_line = 0;
-    }
-    __Pyx_ErrRestoreInState(tstate, ptype, pvalue, ptraceback);
-    return c_line;
-}
-#endif
-
-/* CodeObjectCache */
-static int __pyx_bisect_code_objects(__Pyx_CodeObjectCacheEntry* entries, int count, int code_line) {
-    int start = 0, mid = 0, end = count - 1;
-    if (end >= 0 && code_line > entries[end].code_line) {
-        return count;
-    }
-    while (start < end) {
-        mid = start + (end - start) / 2;
-        if (code_line < entries[mid].code_line) {
-            end = mid;
-        } else if (code_line > entries[mid].code_line) {
-             start = mid + 1;
-        } else {
-            return mid;
-        }
-    }
-    if (code_line <= entries[mid].code_line) {
-        return mid;
-    } else {
-        return mid + 1;
-    }
-}
-static PyCodeObject *__pyx_find_code_object(int code_line) {
-    PyCodeObject* code_object;
-    int pos;
-    if (unlikely(!code_line) || unlikely(!__pyx_code_cache.entries)) {
-        return NULL;
-    }
-    pos = __pyx_bisect_code_objects(__pyx_code_cache.entries, __pyx_code_cache.count, code_line);
-    if (unlikely(pos >= __pyx_code_cache.count) || unlikely(__pyx_code_cache.entries[pos].code_line != code_line)) {
-        return NULL;
-    }
-    code_object = __pyx_code_cache.entries[pos].code_object;
-    Py_INCREF(code_object);
-    return code_object;
-}
-static void __pyx_insert_code_object(int code_line, PyCodeObject* code_object) {
-    int pos, i;
-    __Pyx_CodeObjectCacheEntry* entries = __pyx_code_cache.entries;
-    if (unlikely(!code_line)) {
-        return;
-    }
-    if (unlikely(!entries)) {
-        entries = (__Pyx_CodeObjectCacheEntry*)PyMem_Malloc(64*sizeof(__Pyx_CodeObjectCacheEntry));
-        if (likely(entries)) {
-            __pyx_code_cache.entries = entries;
-            __pyx_code_cache.max_count = 64;
-            __pyx_code_cache.count = 1;
-            entries[0].code_line = code_line;
-            entries[0].code_object = code_object;
-            Py_INCREF(code_object);
-        }
-        return;
-    }
-    pos = __pyx_bisect_code_objects(__pyx_code_cache.entries, __pyx_code_cache.count, code_line);
-    if ((pos < __pyx_code_cache.count) && unlikely(__pyx_code_cache.entries[pos].code_line == code_line)) {
-        PyCodeObject* tmp = entries[pos].code_object;
-        entries[pos].code_object = code_object;
-        Py_DECREF(tmp);
-        return;
-    }
-    if (__pyx_code_cache.count == __pyx_code_cache.max_count) {
-        int new_max = __pyx_code_cache.max_count + 64;
-        entries = (__Pyx_CodeObjectCacheEntry*)PyMem_Realloc(
-            __pyx_code_cache.entries, ((size_t)new_max) * sizeof(__Pyx_CodeObjectCacheEntry));
-        if (unlikely(!entries)) {
-            return;
-        }
-        __pyx_code_cache.entries = entries;
-        __pyx_code_cache.max_count = new_max;
-    }
-    for (i=__pyx_code_cache.count; i>pos; i--) {
-        entries[i] = entries[i-1];
-    }
-    entries[pos].code_line = code_line;
-    entries[pos].code_object = code_object;
-    __pyx_code_cache.count++;
-    Py_INCREF(code_object);
-}
-
-/* AddTraceback */
-#include "compile.h"
-#include "frameobject.h"
-#include "traceback.h"
-#if PY_VERSION_HEX >= 0x030b00a6
-  #ifndef Py_BUILD_CORE
-    #define Py_BUILD_CORE 1
-  #endif
-  #include "internal/pycore_frame.h"
-#endif
-static PyCodeObject* __Pyx_CreateCodeObjectForTraceback(
-            const char *funcname, int c_line,
-            int py_line, const char *filename) {
-    PyCodeObject *py_code = NULL;
-    PyObject *py_funcname = NULL;
-    #if PY_MAJOR_VERSION < 3
-    PyObject *py_srcfile = NULL;
-    py_srcfile = PyString_FromString(filename);
-    if (!py_srcfile) goto bad;
-    #endif
-    if (c_line) {
-        #if PY_MAJOR_VERSION < 3
-        py_funcname = PyString_FromFormat( "%s (%s:%d)", funcname, __pyx_cfilenm, c_line);
-        if (!py_funcname) goto bad;
-        #else
-        py_funcname = PyUnicode_FromFormat( "%s (%s:%d)", funcname, __pyx_cfilenm, c_line);
-        if (!py_funcname) goto bad;
-        funcname = PyUnicode_AsUTF8(py_funcname);
-        if (!funcname) goto bad;
-        #endif
-    }
-    else {
-        #if PY_MAJOR_VERSION < 3
-        py_funcname = PyString_FromString(funcname);
-        if (!py_funcname) goto bad;
-        #endif
-    }
-    #if PY_MAJOR_VERSION < 3
-    py_code = __Pyx_PyCode_New(
-        0,
-        0,
-        0,
-        0,
-        0,
-        __pyx_empty_bytes, /*PyObject *code,*/
-        __pyx_empty_tuple, /*PyObject *consts,*/
-        __pyx_empty_tuple, /*PyObject *names,*/
-        __pyx_empty_tuple, /*PyObject *varnames,*/
-        __pyx_empty_tuple, /*PyObject *freevars,*/
-        __pyx_empty_tuple, /*PyObject *cellvars,*/
-        py_srcfile,   /*PyObject *filename,*/
-        py_funcname,  /*PyObject *name,*/
-        py_line,
-        __pyx_empty_bytes  /*PyObject *lnotab*/
-    );
-    Py_DECREF(py_srcfile);
-    #else
-    py_code = PyCode_NewEmpty(filename, funcname, py_line);
-    #endif
-    Py_XDECREF(py_funcname);  // XDECREF since it's only set on Py3 if cline
-    return py_code;
-bad:
-    Py_XDECREF(py_funcname);
-    #if PY_MAJOR_VERSION < 3
-    Py_XDECREF(py_srcfile);
-    #endif
-    return NULL;
-}
-static void __Pyx_AddTraceback(const char *funcname, int c_line,
-                               int py_line, const char *filename) {
-    PyCodeObject *py_code = 0;
-    PyFrameObject *py_frame = 0;
-    PyThreadState *tstate = __Pyx_PyThreadState_Current;
-    PyObject *ptype, *pvalue, *ptraceback;
-    if (c_line) {
-        c_line = __Pyx_CLineForTraceback(tstate, c_line);
-    }
-    py_code = __pyx_find_code_object(c_line ? -c_line : py_line);
-    if (!py_code) {
-        __Pyx_ErrFetchInState(tstate, &ptype, &pvalue, &ptraceback);
-        py_code = __Pyx_CreateCodeObjectForTraceback(
-            funcname, c_line, py_line, filename);
-        if (!py_code) {
-            /* If the code object creation fails, then we should clear the
-               fetched exception references and propagate the new exception */
-            Py_XDECREF(ptype);
-            Py_XDECREF(pvalue);
-            Py_XDECREF(ptraceback);
-            goto bad;
-        }
-        __Pyx_ErrRestoreInState(tstate, ptype, pvalue, ptraceback);
-        __pyx_insert_code_object(c_line ? -c_line : py_line, py_code);
-    }
-    py_frame = PyFrame_New(
-        tstate,            /*PyThreadState *tstate,*/
-        py_code,           /*PyCodeObject *code,*/
-        __pyx_d,    /*PyObject *globals,*/
-        0                  /*PyObject *locals*/
-    );
-    if (!py_frame) goto bad;
-    __Pyx_PyFrame_SetLineNumber(py_frame, py_line);
-    PyTraceBack_Here(py_frame);
-bad:
-    Py_XDECREF(py_code);
-    Py_XDECREF(py_frame);
-}
-
-/* CIntFromPyVerify */
-#define __PYX_VERIFY_RETURN_INT(target_type, func_type, func_value)\
-    __PYX__VERIFY_RETURN_INT(target_type, func_type, func_value, 0)
-#define __PYX_VERIFY_RETURN_INT_EXC(target_type, func_type, func_value)\
-    __PYX__VERIFY_RETURN_INT(target_type, func_type, func_value, 1)
-#define __PYX__VERIFY_RETURN_INT(target_type, func_type, func_value, exc)\
-    {\
-        func_type value = func_value;\
-        if (sizeof(target_type) < sizeof(func_type)) {\
-            if (unlikely(value != (func_type) (target_type) value)) {\
-                func_type zero = 0;\
-                if (exc && unlikely(value == (func_type)-1 && PyErr_Occurred()))\
-                    return (target_type) -1;\
-                if (is_unsigned && unlikely(value < zero))\
-                    goto raise_neg_overflow;\
-                else\
-                    goto raise_overflow;\
-            }\
-        }\
-        return (target_type) value;\
-    }
-
-/* CIntFromPy */
-static CYTHON_INLINE int __Pyx_PyInt_As_int(PyObject *x) {
-#ifdef __Pyx_HAS_GCC_DIAGNOSTIC
-#pragma GCC diagnostic push
-#pragma GCC diagnostic ignored "-Wconversion"
-#endif
-    const int neg_one = (int) -1, const_zero = (int) 0;
-#ifdef __Pyx_HAS_GCC_DIAGNOSTIC
-#pragma GCC diagnostic pop
-#endif
-    const int is_unsigned = neg_one > const_zero;
-#if PY_MAJOR_VERSION < 3
-    if (likely(PyInt_Check(x))) {
-        if (sizeof(int) < sizeof(long)) {
-            __PYX_VERIFY_RETURN_INT(int, long, PyInt_AS_LONG(x))
-        } else {
-            long val = PyInt_AS_LONG(x);
-            if (is_unsigned && unlikely(val < 0)) {
-                goto raise_neg_overflow;
-            }
-            return (int) val;
-        }
-    } else
-#endif
-    if (likely(PyLong_Check(x))) {
-        if (is_unsigned) {
-#if CYTHON_USE_PYLONG_INTERNALS
-            const digit* digits = ((PyLongObject*)x)->ob_digit;
-            switch (Py_SIZE(x)) {
-                case  0: return (int) 0;
-                case  1: __PYX_VERIFY_RETURN_INT(int, digit, digits[0])
-                case 2:
-                    if (8 * sizeof(int) > 1 * PyLong_SHIFT) {
-                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
-                            __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                        } else if (8 * sizeof(int) >= 2 * PyLong_SHIFT) {
-                            return (int) (((((int)digits[1]) << PyLong_SHIFT) | (int)digits[0]));
-                        }
-                    }
-                    break;
-                case 3:
-                    if (8 * sizeof(int) > 2 * PyLong_SHIFT) {
-                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
-                            __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                        } else if (8 * sizeof(int) >= 3 * PyLong_SHIFT) {
-                            return (int) (((((((int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0]));
-                        }
-                    }
-                    break;
-                case 4:
-                    if (8 * sizeof(int) > 3 * PyLong_SHIFT) {
-                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
-                            __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                        } else if (8 * sizeof(int) >= 4 * PyLong_SHIFT) {
-                            return (int) (((((((((int)digits[3]) << PyLong_SHIFT) | (int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0]));
-                        }
-                    }
-                    break;
-            }
-#endif
-#if CYTHON_COMPILING_IN_CPYTHON
-            if (unlikely(Py_SIZE(x) < 0)) {
-                goto raise_neg_overflow;
-            }
-#else
-            {
-                int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
-                if (unlikely(result < 0))
-                    return (int) -1;
-                if (unlikely(result == 1))
-                    goto raise_neg_overflow;
-            }
-#endif
-            if (sizeof(int) <= sizeof(unsigned long)) {
-                __PYX_VERIFY_RETURN_INT_EXC(int, unsigned long, PyLong_AsUnsignedLong(x))
-#ifdef HAVE_LONG_LONG
-            } else if (sizeof(int) <= sizeof(unsigned PY_LONG_LONG)) {
-                __PYX_VERIFY_RETURN_INT_EXC(int, unsigned PY_LONG_LONG, PyLong_AsUnsignedLongLong(x))
-#endif
-            }
-        } else {
-#if CYTHON_USE_PYLONG_INTERNALS
-            const digit* digits = ((PyLongObject*)x)->ob_digit;
-            switch (Py_SIZE(x)) {
-                case  0: return (int) 0;
-                case -1: __PYX_VERIFY_RETURN_INT(int, sdigit, (sdigit) (-(sdigit)digits[0]))
-                case  1: __PYX_VERIFY_RETURN_INT(int,  digit, +digits[0])
-                case -2:
-                    if (8 * sizeof(int) - 1 > 1 * PyLong_SHIFT) {
-                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
-                            __PYX_VERIFY_RETURN_INT(int, long, -(long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                        } else if (8 * sizeof(int) - 1 > 2 * PyLong_SHIFT) {
-                            return (int) (((int)-1)*(((((int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
-                        }
-                    }
-                    break;
-                case 2:
-                    if (8 * sizeof(int) > 1 * PyLong_SHIFT) {
-                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
-                            __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                        } else if (8 * sizeof(int) - 1 > 2 * PyLong_SHIFT) {
-                            return (int) ((((((int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
-                        }
-                    }
-                    break;
-                case -3:
-                    if (8 * sizeof(int) - 1 > 2 * PyLong_SHIFT) {
-                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
-                            __PYX_VERIFY_RETURN_INT(int, long, -(long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                        } else if (8 * sizeof(int) - 1 > 3 * PyLong_SHIFT) {
-                            return (int) (((int)-1)*(((((((int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
-                        }
-                    }
-                    break;
-                case 3:
-                    if (8 * sizeof(int) > 2 * PyLong_SHIFT) {
-                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
-                            __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                        } else if (8 * sizeof(int) - 1 > 3 * PyLong_SHIFT) {
-                            return (int) ((((((((int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
-                        }
-                    }
-                    break;
-                case -4:
-                    if (8 * sizeof(int) - 1 > 3 * PyLong_SHIFT) {
-                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
-                            __PYX_VERIFY_RETURN_INT(int, long, -(long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                        } else if (8 * sizeof(int) - 1 > 4 * PyLong_SHIFT) {
-                            return (int) (((int)-1)*(((((((((int)digits[3]) << PyLong_SHIFT) | (int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
-                        }
-                    }
-                    break;
-                case 4:
-                    if (8 * sizeof(int) > 3 * PyLong_SHIFT) {
-                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
-                            __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                        } else if (8 * sizeof(int) - 1 > 4 * PyLong_SHIFT) {
-                            return (int) ((((((((((int)digits[3]) << PyLong_SHIFT) | (int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
-                        }
-                    }
-                    break;
-            }
-#endif
-            if (sizeof(int) <= sizeof(long)) {
-                __PYX_VERIFY_RETURN_INT_EXC(int, long, PyLong_AsLong(x))
-#ifdef HAVE_LONG_LONG
-            } else if (sizeof(int) <= sizeof(PY_LONG_LONG)) {
-                __PYX_VERIFY_RETURN_INT_EXC(int, PY_LONG_LONG, PyLong_AsLongLong(x))
-#endif
-            }
-        }
-        {
-#if CYTHON_COMPILING_IN_PYPY && !defined(_PyLong_AsByteArray)
-            PyErr_SetString(PyExc_RuntimeError,
-                            "_PyLong_AsByteArray() not available in PyPy, cannot convert large numbers");
-#else
-            int val;
-            PyObject *v = __Pyx_PyNumber_IntOrLong(x);
- #if PY_MAJOR_VERSION < 3
-            if (likely(v) && !PyLong_Check(v)) {
-                PyObject *tmp = v;
-                v = PyNumber_Long(tmp);
-                Py_DECREF(tmp);
-            }
- #endif
-            if (likely(v)) {
-                int one = 1; int is_little = (int)*(unsigned char *)&one;
-                unsigned char *bytes = (unsigned char *)&val;
-                int ret = _PyLong_AsByteArray((PyLongObject *)v,
-                                              bytes, sizeof(val),
-                                              is_little, !is_unsigned);
-                Py_DECREF(v);
-                if (likely(!ret))
-                    return val;
-            }
-#endif
-            return (int) -1;
-        }
-    } else {
-        int val;
-        PyObject *tmp = __Pyx_PyNumber_IntOrLong(x);
-        if (!tmp) return (int) -1;
-        val = __Pyx_PyInt_As_int(tmp);
-        Py_DECREF(tmp);
-        return val;
-    }
-raise_overflow:
-    PyErr_SetString(PyExc_OverflowError,
-        "value too large to convert to int");
-    return (int) -1;
-raise_neg_overflow:
-    PyErr_SetString(PyExc_OverflowError,
-        "can't convert negative value to int");
-    return (int) -1;
-}
-
-/* CIntFromPy */
-static CYTHON_INLINE size_t __Pyx_PyInt_As_size_t(PyObject *x) {
-#ifdef __Pyx_HAS_GCC_DIAGNOSTIC
-#pragma GCC diagnostic push
-#pragma GCC diagnostic ignored "-Wconversion"
-#endif
-    const size_t neg_one = (size_t) -1, const_zero = (size_t) 0;
-#ifdef __Pyx_HAS_GCC_DIAGNOSTIC
-#pragma GCC diagnostic pop
-#endif
-    const int is_unsigned = neg_one > const_zero;
-#if PY_MAJOR_VERSION < 3
-    if (likely(PyInt_Check(x))) {
-        if (sizeof(size_t) < sizeof(long)) {
-            __PYX_VERIFY_RETURN_INT(size_t, long, PyInt_AS_LONG(x))
-        } else {
-            long val = PyInt_AS_LONG(x);
-            if (is_unsigned && unlikely(val < 0)) {
-                goto raise_neg_overflow;
-            }
-            return (size_t) val;
-        }
-    } else
-#endif
-    if (likely(PyLong_Check(x))) {
-        if (is_unsigned) {
-#if CYTHON_USE_PYLONG_INTERNALS
-            const digit* digits = ((PyLongObject*)x)->ob_digit;
-            switch (Py_SIZE(x)) {
-                case  0: return (size_t) 0;
-                case  1: __PYX_VERIFY_RETURN_INT(size_t, digit, digits[0])
-                case 2:
-                    if (8 * sizeof(size_t) > 1 * PyLong_SHIFT) {
-                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
-                            __PYX_VERIFY_RETURN_INT(size_t, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                        } else if (8 * sizeof(size_t) >= 2 * PyLong_SHIFT) {
-                            return (size_t) (((((size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0]));
-                        }
-                    }
-                    break;
-                case 3:
-                    if (8 * sizeof(size_t) > 2 * PyLong_SHIFT) {
-                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
-                            __PYX_VERIFY_RETURN_INT(size_t, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                        } else if (8 * sizeof(size_t) >= 3 * PyLong_SHIFT) {
-                            return (size_t) (((((((size_t)digits[2]) << PyLong_SHIFT) | (size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0]));
-                        }
-                    }
-                    break;
-                case 4:
-                    if (8 * sizeof(size_t) > 3 * PyLong_SHIFT) {
-                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
-                            __PYX_VERIFY_RETURN_INT(size_t, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                        } else if (8 * sizeof(size_t) >= 4 * PyLong_SHIFT) {
-                            return (size_t) (((((((((size_t)digits[3]) << PyLong_SHIFT) | (size_t)digits[2]) << PyLong_SHIFT) | (size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0]));
-                        }
-                    }
-                    break;
-            }
-#endif
-#if CYTHON_COMPILING_IN_CPYTHON
-            if (unlikely(Py_SIZE(x) < 0)) {
-                goto raise_neg_overflow;
-            }
-#else
-            {
-                int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
-                if (unlikely(result < 0))
-                    return (size_t) -1;
-                if (unlikely(result == 1))
-                    goto raise_neg_overflow;
-            }
-#endif
-            if (sizeof(size_t) <= sizeof(unsigned long)) {
-                __PYX_VERIFY_RETURN_INT_EXC(size_t, unsigned long, PyLong_AsUnsignedLong(x))
-#ifdef HAVE_LONG_LONG
-            } else if (sizeof(size_t) <= sizeof(unsigned PY_LONG_LONG)) {
-                __PYX_VERIFY_RETURN_INT_EXC(size_t, unsigned PY_LONG_LONG, PyLong_AsUnsignedLongLong(x))
-#endif
-            }
-        } else {
-#if CYTHON_USE_PYLONG_INTERNALS
-            const digit* digits = ((PyLongObject*)x)->ob_digit;
-            switch (Py_SIZE(x)) {
-                case  0: return (size_t) 0;
-                case -1: __PYX_VERIFY_RETURN_INT(size_t, sdigit, (sdigit) (-(sdigit)digits[0]))
-                case  1: __PYX_VERIFY_RETURN_INT(size_t,  digit, +digits[0])
-                case -2:
-                    if (8 * sizeof(size_t) - 1 > 1 * PyLong_SHIFT) {
-                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
-                            __PYX_VERIFY_RETURN_INT(size_t, long, -(long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                        } else if (8 * sizeof(size_t) - 1 > 2 * PyLong_SHIFT) {
-                            return (size_t) (((size_t)-1)*(((((size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0])));
-                        }
-                    }
-                    break;
-                case 2:
-                    if (8 * sizeof(size_t) > 1 * PyLong_SHIFT) {
-                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
-                            __PYX_VERIFY_RETURN_INT(size_t, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                        } else if (8 * sizeof(size_t) - 1 > 2 * PyLong_SHIFT) {
-                            return (size_t) ((((((size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0])));
-                        }
-                    }
-                    break;
-                case -3:
-                    if (8 * sizeof(size_t) - 1 > 2 * PyLong_SHIFT) {
-                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
-                            __PYX_VERIFY_RETURN_INT(size_t, long, -(long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                        } else if (8 * sizeof(size_t) - 1 > 3 * PyLong_SHIFT) {
-                            return (size_t) (((size_t)-1)*(((((((size_t)digits[2]) << PyLong_SHIFT) | (size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0])));
-                        }
-                    }
-                    break;
-                case 3:
-                    if (8 * sizeof(size_t) > 2 * PyLong_SHIFT) {
-                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
-                            __PYX_VERIFY_RETURN_INT(size_t, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                        } else if (8 * sizeof(size_t) - 1 > 3 * PyLong_SHIFT) {
-                            return (size_t) ((((((((size_t)digits[2]) << PyLong_SHIFT) | (size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0])));
-                        }
-                    }
-                    break;
-                case -4:
-                    if (8 * sizeof(size_t) - 1 > 3 * PyLong_SHIFT) {
-                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
-                            __PYX_VERIFY_RETURN_INT(size_t, long, -(long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                        } else if (8 * sizeof(size_t) - 1 > 4 * PyLong_SHIFT) {
-                            return (size_t) (((size_t)-1)*(((((((((size_t)digits[3]) << PyLong_SHIFT) | (size_t)digits[2]) << PyLong_SHIFT) | (size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0])));
-                        }
-                    }
-                    break;
-                case 4:
-                    if (8 * sizeof(size_t) > 3 * PyLong_SHIFT) {
-                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
-                            __PYX_VERIFY_RETURN_INT(size_t, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                        } else if (8 * sizeof(size_t) - 1 > 4 * PyLong_SHIFT) {
-                            return (size_t) ((((((((((size_t)digits[3]) << PyLong_SHIFT) | (size_t)digits[2]) << PyLong_SHIFT) | (size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0])));
-                        }
-                    }
-                    break;
-            }
-#endif
-            if (sizeof(size_t) <= sizeof(long)) {
-                __PYX_VERIFY_RETURN_INT_EXC(size_t, long, PyLong_AsLong(x))
-#ifdef HAVE_LONG_LONG
-            } else if (sizeof(size_t) <= sizeof(PY_LONG_LONG)) {
-                __PYX_VERIFY_RETURN_INT_EXC(size_t, PY_LONG_LONG, PyLong_AsLongLong(x))
-#endif
-            }
-        }
-        {
-#if CYTHON_COMPILING_IN_PYPY && !defined(_PyLong_AsByteArray)
-            PyErr_SetString(PyExc_RuntimeError,
-                            "_PyLong_AsByteArray() not available in PyPy, cannot convert large numbers");
-#else
-            size_t val;
-            PyObject *v = __Pyx_PyNumber_IntOrLong(x);
- #if PY_MAJOR_VERSION < 3
-            if (likely(v) && !PyLong_Check(v)) {
-                PyObject *tmp = v;
-                v = PyNumber_Long(tmp);
-                Py_DECREF(tmp);
-            }
- #endif
-            if (likely(v)) {
-                int one = 1; int is_little = (int)*(unsigned char *)&one;
-                unsigned char *bytes = (unsigned char *)&val;
-                int ret = _PyLong_AsByteArray((PyLongObject *)v,
-                                              bytes, sizeof(val),
-                                              is_little, !is_unsigned);
-                Py_DECREF(v);
-                if (likely(!ret))
-                    return val;
-            }
-#endif
-            return (size_t) -1;
-        }
-    } else {
-        size_t val;
-        PyObject *tmp = __Pyx_PyNumber_IntOrLong(x);
-        if (!tmp) return (size_t) -1;
-        val = __Pyx_PyInt_As_size_t(tmp);
-        Py_DECREF(tmp);
-        return val;
-    }
-raise_overflow:
-    PyErr_SetString(PyExc_OverflowError,
-        "value too large to convert to size_t");
-    return (size_t) -1;
-raise_neg_overflow:
-    PyErr_SetString(PyExc_OverflowError,
-        "can't convert negative value to size_t");
-    return (size_t) -1;
-}
-
-/* CIntToPy */
-static CYTHON_INLINE PyObject* __Pyx_PyInt_From_long(long value) {
-#ifdef __Pyx_HAS_GCC_DIAGNOSTIC
-#pragma GCC diagnostic push
-#pragma GCC diagnostic ignored "-Wconversion"
-#endif
-    const long neg_one = (long) -1, const_zero = (long) 0;
-#ifdef __Pyx_HAS_GCC_DIAGNOSTIC
-#pragma GCC diagnostic pop
-#endif
-    const int is_unsigned = neg_one > const_zero;
-    if (is_unsigned) {
-        if (sizeof(long) < sizeof(long)) {
-            return PyInt_FromLong((long) value);
-        } else if (sizeof(long) <= sizeof(unsigned long)) {
-            return PyLong_FromUnsignedLong((unsigned long) value);
-#ifdef HAVE_LONG_LONG
-        } else if (sizeof(long) <= sizeof(unsigned PY_LONG_LONG)) {
-            return PyLong_FromUnsignedLongLong((unsigned PY_LONG_LONG) value);
-#endif
-        }
-    } else {
-        if (sizeof(long) <= sizeof(long)) {
-            return PyInt_FromLong((long) value);
-#ifdef HAVE_LONG_LONG
-        } else if (sizeof(long) <= sizeof(PY_LONG_LONG)) {
-            return PyLong_FromLongLong((PY_LONG_LONG) value);
-#endif
-        }
-    }
-    {
-        int one = 1; int little = (int)*(unsigned char *)&one;
-        unsigned char *bytes = (unsigned char *)&value;
-        return _PyLong_FromByteArray(bytes, sizeof(long),
-                                     little, !is_unsigned);
-    }
-}
-
-/* CIntFromPy */
-static CYTHON_INLINE long __Pyx_PyInt_As_long(PyObject *x) {
-#ifdef __Pyx_HAS_GCC_DIAGNOSTIC
-#pragma GCC diagnostic push
-#pragma GCC diagnostic ignored "-Wconversion"
-#endif
-    const long neg_one = (long) -1, const_zero = (long) 0;
-#ifdef __Pyx_HAS_GCC_DIAGNOSTIC
-#pragma GCC diagnostic pop
-#endif
-    const int is_unsigned = neg_one > const_zero;
-#if PY_MAJOR_VERSION < 3
-    if (likely(PyInt_Check(x))) {
-        if (sizeof(long) < sizeof(long)) {
-            __PYX_VERIFY_RETURN_INT(long, long, PyInt_AS_LONG(x))
-        } else {
-            long val = PyInt_AS_LONG(x);
-            if (is_unsigned && unlikely(val < 0)) {
-                goto raise_neg_overflow;
-            }
-            return (long) val;
-        }
-    } else
-#endif
-    if (likely(PyLong_Check(x))) {
-        if (is_unsigned) {
-#if CYTHON_USE_PYLONG_INTERNALS
-            const digit* digits = ((PyLongObject*)x)->ob_digit;
-            switch (Py_SIZE(x)) {
-                case  0: return (long) 0;
-                case  1: __PYX_VERIFY_RETURN_INT(long, digit, digits[0])
-                case 2:
-                    if (8 * sizeof(long) > 1 * PyLong_SHIFT) {
-                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
-                            __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                        } else if (8 * sizeof(long) >= 2 * PyLong_SHIFT) {
-                            return (long) (((((long)digits[1]) << PyLong_SHIFT) | (long)digits[0]));
-                        }
-                    }
-                    break;
-                case 3:
-                    if (8 * sizeof(long) > 2 * PyLong_SHIFT) {
-                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
-                            __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                        } else if (8 * sizeof(long) >= 3 * PyLong_SHIFT) {
-                            return (long) (((((((long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0]));
-                        }
-                    }
-                    break;
-                case 4:
-                    if (8 * sizeof(long) > 3 * PyLong_SHIFT) {
-                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
-                            __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                        } else if (8 * sizeof(long) >= 4 * PyLong_SHIFT) {
-                            return (long) (((((((((long)digits[3]) << PyLong_SHIFT) | (long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0]));
-                        }
-                    }
-                    break;
-            }
-#endif
-#if CYTHON_COMPILING_IN_CPYTHON
-            if (unlikely(Py_SIZE(x) < 0)) {
-                goto raise_neg_overflow;
-            }
-#else
-            {
-                int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
-                if (unlikely(result < 0))
-                    return (long) -1;
-                if (unlikely(result == 1))
-                    goto raise_neg_overflow;
-            }
-#endif
-            if (sizeof(long) <= sizeof(unsigned long)) {
-                __PYX_VERIFY_RETURN_INT_EXC(long, unsigned long, PyLong_AsUnsignedLong(x))
-#ifdef HAVE_LONG_LONG
-            } else if (sizeof(long) <= sizeof(unsigned PY_LONG_LONG)) {
-                __PYX_VERIFY_RETURN_INT_EXC(long, unsigned PY_LONG_LONG, PyLong_AsUnsignedLongLong(x))
-#endif
-            }
-        } else {
-#if CYTHON_USE_PYLONG_INTERNALS
-            const digit* digits = ((PyLongObject*)x)->ob_digit;
-            switch (Py_SIZE(x)) {
-                case  0: return (long) 0;
-                case -1: __PYX_VERIFY_RETURN_INT(long, sdigit, (sdigit) (-(sdigit)digits[0]))
-                case  1: __PYX_VERIFY_RETURN_INT(long,  digit, +digits[0])
-                case -2:
-                    if (8 * sizeof(long) - 1 > 1 * PyLong_SHIFT) {
-                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
-                            __PYX_VERIFY_RETURN_INT(long, long, -(long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                        } else if (8 * sizeof(long) - 1 > 2 * PyLong_SHIFT) {
-                            return (long) (((long)-1)*(((((long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
-                        }
-                    }
-                    break;
-                case 2:
-                    if (8 * sizeof(long) > 1 * PyLong_SHIFT) {
-                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
-                            __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                        } else if (8 * sizeof(long) - 1 > 2 * PyLong_SHIFT) {
-                            return (long) ((((((long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
-                        }
-                    }
-                    break;
-                case -3:
-                    if (8 * sizeof(long) - 1 > 2 * PyLong_SHIFT) {
-                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
-                            __PYX_VERIFY_RETURN_INT(long, long, -(long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                        } else if (8 * sizeof(long) - 1 > 3 * PyLong_SHIFT) {
-                            return (long) (((long)-1)*(((((((long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
-                        }
-                    }
-                    break;
-                case 3:
-                    if (8 * sizeof(long) > 2 * PyLong_SHIFT) {
-                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
-                            __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                        } else if (8 * sizeof(long) - 1 > 3 * PyLong_SHIFT) {
-                            return (long) ((((((((long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
-                        }
-                    }
-                    break;
-                case -4:
-                    if (8 * sizeof(long) - 1 > 3 * PyLong_SHIFT) {
-                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
-                            __PYX_VERIFY_RETURN_INT(long, long, -(long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                        } else if (8 * sizeof(long) - 1 > 4 * PyLong_SHIFT) {
-                            return (long) (((long)-1)*(((((((((long)digits[3]) << PyLong_SHIFT) | (long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
-                        }
-                    }
-                    break;
-                case 4:
-                    if (8 * sizeof(long) > 3 * PyLong_SHIFT) {
-                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
-                            __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                        } else if (8 * sizeof(long) - 1 > 4 * PyLong_SHIFT) {
-                            return (long) ((((((((((long)digits[3]) << PyLong_SHIFT) | (long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
-                        }
-                    }
-                    break;
-            }
-#endif
-            if (sizeof(long) <= sizeof(long)) {
-                __PYX_VERIFY_RETURN_INT_EXC(long, long, PyLong_AsLong(x))
-#ifdef HAVE_LONG_LONG
-            } else if (sizeof(long) <= sizeof(PY_LONG_LONG)) {
-                __PYX_VERIFY_RETURN_INT_EXC(long, PY_LONG_LONG, PyLong_AsLongLong(x))
-#endif
-            }
-        }
-        {
-#if CYTHON_COMPILING_IN_PYPY && !defined(_PyLong_AsByteArray)
-            PyErr_SetString(PyExc_RuntimeError,
-                            "_PyLong_AsByteArray() not available in PyPy, cannot convert large numbers");
-#else
-            long val;
-            PyObject *v = __Pyx_PyNumber_IntOrLong(x);
- #if PY_MAJOR_VERSION < 3
-            if (likely(v) && !PyLong_Check(v)) {
-                PyObject *tmp = v;
-                v = PyNumber_Long(tmp);
-                Py_DECREF(tmp);
-            }
- #endif
-            if (likely(v)) {
-                int one = 1; int is_little = (int)*(unsigned char *)&one;
-                unsigned char *bytes = (unsigned char *)&val;
-                int ret = _PyLong_AsByteArray((PyLongObject *)v,
-                                              bytes, sizeof(val),
-                                              is_little, !is_unsigned);
-                Py_DECREF(v);
-                if (likely(!ret))
-                    return val;
-            }
-#endif
-            return (long) -1;
-        }
-    } else {
-        long val;
-        PyObject *tmp = __Pyx_PyNumber_IntOrLong(x);
-        if (!tmp) return (long) -1;
-        val = __Pyx_PyInt_As_long(tmp);
-        Py_DECREF(tmp);
-        return val;
-    }
-raise_overflow:
-    PyErr_SetString(PyExc_OverflowError,
-        "value too large to convert to long");
-    return (long) -1;
-raise_neg_overflow:
-    PyErr_SetString(PyExc_OverflowError,
-        "can't convert negative value to long");
-    return (long) -1;
-}
-
-/* FastTypeChecks */
-#if CYTHON_COMPILING_IN_CPYTHON
-static int __Pyx_InBases(PyTypeObject *a, PyTypeObject *b) {
-    while (a) {
-        a = a->tp_base;
-        if (a == b)
-            return 1;
-    }
-    return b == &PyBaseObject_Type;
-}
-static CYTHON_INLINE int __Pyx_IsSubtype(PyTypeObject *a, PyTypeObject *b) {
-    PyObject *mro;
-    if (a == b) return 1;
-    mro = a->tp_mro;
-    if (likely(mro)) {
-        Py_ssize_t i, n;
-        n = PyTuple_GET_SIZE(mro);
-        for (i = 0; i < n; i++) {
-            if (PyTuple_GET_ITEM(mro, i) == (PyObject *)b)
-                return 1;
-        }
-        return 0;
-    }
-    return __Pyx_InBases(a, b);
-}
-#if PY_MAJOR_VERSION == 2
-static int __Pyx_inner_PyErr_GivenExceptionMatches2(PyObject *err, PyObject* exc_type1, PyObject* exc_type2) {
-    PyObject *exception, *value, *tb;
-    int res;
-    __Pyx_PyThreadState_declare
-    __Pyx_PyThreadState_assign
-    __Pyx_ErrFetch(&exception, &value, &tb);
-    res = exc_type1 ? PyObject_IsSubclass(err, exc_type1) : 0;
-    if (unlikely(res == -1)) {
-        PyErr_WriteUnraisable(err);
-        res = 0;
-    }
-    if (!res) {
-        res = PyObject_IsSubclass(err, exc_type2);
-        if (unlikely(res == -1)) {
-            PyErr_WriteUnraisable(err);
-            res = 0;
-        }
-    }
-    __Pyx_ErrRestore(exception, value, tb);
-    return res;
-}
-#else
-static CYTHON_INLINE int __Pyx_inner_PyErr_GivenExceptionMatches2(PyObject *err, PyObject* exc_type1, PyObject *exc_type2) {
-    int res = exc_type1 ? __Pyx_IsSubtype((PyTypeObject*)err, (PyTypeObject*)exc_type1) : 0;
-    if (!res) {
-        res = __Pyx_IsSubtype((PyTypeObject*)err, (PyTypeObject*)exc_type2);
-    }
-    return res;
-}
-#endif
-static int __Pyx_PyErr_GivenExceptionMatchesTuple(PyObject *exc_type, PyObject *tuple) {
-    Py_ssize_t i, n;
-    assert(PyExceptionClass_Check(exc_type));
-    n = PyTuple_GET_SIZE(tuple);
-#if PY_MAJOR_VERSION >= 3
-    for (i=0; i<n; i++) {
-        if (exc_type == PyTuple_GET_ITEM(tuple, i)) return 1;
-    }
-#endif
-    for (i=0; i<n; i++) {
-        PyObject *t = PyTuple_GET_ITEM(tuple, i);
-        #if PY_MAJOR_VERSION < 3
-        if (likely(exc_type == t)) return 1;
-        #endif
-        if (likely(PyExceptionClass_Check(t))) {
-            if (__Pyx_inner_PyErr_GivenExceptionMatches2(exc_type, NULL, t)) return 1;
-        } else {
-        }
-    }
-    return 0;
-}
-static CYTHON_INLINE int __Pyx_PyErr_GivenExceptionMatches(PyObject *err, PyObject* exc_type) {
-    if (likely(err == exc_type)) return 1;
-    if (likely(PyExceptionClass_Check(err))) {
-        if (likely(PyExceptionClass_Check(exc_type))) {
-            return __Pyx_inner_PyErr_GivenExceptionMatches2(err, NULL, exc_type);
-        } else if (likely(PyTuple_Check(exc_type))) {
-            return __Pyx_PyErr_GivenExceptionMatchesTuple(err, exc_type);
-        } else {
-        }
-    }
-    return PyErr_GivenExceptionMatches(err, exc_type);
-}
-static CYTHON_INLINE int __Pyx_PyErr_GivenExceptionMatches2(PyObject *err, PyObject *exc_type1, PyObject *exc_type2) {
-    assert(PyExceptionClass_Check(exc_type1));
-    assert(PyExceptionClass_Check(exc_type2));
-    if (likely(err == exc_type1 || err == exc_type2)) return 1;
-    if (likely(PyExceptionClass_Check(err))) {
-        return __Pyx_inner_PyErr_GivenExceptionMatches2(err, exc_type1, exc_type2);
-    }
-    return (PyErr_GivenExceptionMatches(err, exc_type1) || PyErr_GivenExceptionMatches(err, exc_type2));
-}
-#endif
-
-/* CheckBinaryVersion */
-static int __Pyx_check_binary_version(void) {
-    char ctversion[5];
-    int same=1, i, found_dot;
-    const char* rt_from_call = Py_GetVersion();
-    PyOS_snprintf(ctversion, 5, "%d.%d", PY_MAJOR_VERSION, PY_MINOR_VERSION);
-    found_dot = 0;
-    for (i = 0; i < 4; i++) {
-        if (!ctversion[i]) {
-            same = (rt_from_call[i] < '0' || rt_from_call[i] > '9');
-            break;
-        }
-        if (rt_from_call[i] != ctversion[i]) {
-            same = 0;
-            break;
-        }
-    }
-    if (!same) {
-        char rtversion[5] = {'\0'};
-        char message[200];
-        for (i=0; i<4; ++i) {
-            if (rt_from_call[i] == '.') {
-                if (found_dot) break;
-                found_dot = 1;
-            } else if (rt_from_call[i] < '0' || rt_from_call[i] > '9') {
-                break;
-            }
-            rtversion[i] = rt_from_call[i];
-        }
-        PyOS_snprintf(message, sizeof(message),
-                      "compiletime version %s of module '%.100s' "
-                      "does not match runtime version %s",
-                      ctversion, __Pyx_MODULE_NAME, rtversion);
-        return PyErr_WarnEx(NULL, message, 1);
-    }
-    return 0;
-}
-
-/* InitStrings */
-static int __Pyx_InitStrings(__Pyx_StringTabEntry *t) {
-    while (t->p) {
-        #if PY_MAJOR_VERSION < 3
-        if (t->is_unicode) {
-            *t->p = PyUnicode_DecodeUTF8(t->s, t->n - 1, NULL);
-        } else if (t->intern) {
-            *t->p = PyString_InternFromString(t->s);
-        } else {
-            *t->p = PyString_FromStringAndSize(t->s, t->n - 1);
-        }
-        #else
-        if (t->is_unicode | t->is_str) {
-            if (t->intern) {
-                *t->p = PyUnicode_InternFromString(t->s);
-            } else if (t->encoding) {
-                *t->p = PyUnicode_Decode(t->s, t->n - 1, t->encoding, NULL);
-            } else {
-                *t->p = PyUnicode_FromStringAndSize(t->s, t->n - 1);
-            }
-        } else {
-            *t->p = PyBytes_FromStringAndSize(t->s, t->n - 1);
-        }
-        #endif
-        if (!*t->p)
-            return -1;
-        if (PyObject_Hash(*t->p) == -1)
-            return -1;
-        ++t;
-    }
-    return 0;
-}
-
-static CYTHON_INLINE PyObject* __Pyx_PyUnicode_FromString(const char* c_str) {
-    return __Pyx_PyUnicode_FromStringAndSize(c_str, (Py_ssize_t)strlen(c_str));
-}
-static CYTHON_INLINE const char* __Pyx_PyObject_AsString(PyObject* o) {
-    Py_ssize_t ignore;
-    return __Pyx_PyObject_AsStringAndSize(o, &ignore);
-}
-#if __PYX_DEFAULT_STRING_ENCODING_IS_ASCII || __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT
-#if !CYTHON_PEP393_ENABLED
-static const char* __Pyx_PyUnicode_AsStringAndSize(PyObject* o, Py_ssize_t *length) {
-    char* defenc_c;
-    PyObject* defenc = _PyUnicode_AsDefaultEncodedString(o, NULL);
-    if (!defenc) return NULL;
-    defenc_c = PyBytes_AS_STRING(defenc);
-#if __PYX_DEFAULT_STRING_ENCODING_IS_ASCII
-    {
-        char* end = defenc_c + PyBytes_GET_SIZE(defenc);
-        char* c;
-        for (c = defenc_c; c < end; c++) {
-            if ((unsigned char) (*c) >= 128) {
-                PyUnicode_AsASCIIString(o);
-                return NULL;
-            }
-        }
-    }
-#endif
-    *length = PyBytes_GET_SIZE(defenc);
-    return defenc_c;
-}
-#else
-static CYTHON_INLINE const char* __Pyx_PyUnicode_AsStringAndSize(PyObject* o, Py_ssize_t *length) {
-    if (unlikely(__Pyx_PyUnicode_READY(o) == -1)) return NULL;
-#if __PYX_DEFAULT_STRING_ENCODING_IS_ASCII
-    if (likely(PyUnicode_IS_ASCII(o))) {
-        *length = PyUnicode_GET_LENGTH(o);
-        return PyUnicode_AsUTF8(o);
-    } else {
-        PyUnicode_AsASCIIString(o);
-        return NULL;
-    }
-#else
-    return PyUnicode_AsUTF8AndSize(o, length);
-#endif
-}
-#endif
-#endif
-static CYTHON_INLINE const char* __Pyx_PyObject_AsStringAndSize(PyObject* o, Py_ssize_t *length) {
-#if __PYX_DEFAULT_STRING_ENCODING_IS_ASCII || __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT
-    if (
-#if PY_MAJOR_VERSION < 3 && __PYX_DEFAULT_STRING_ENCODING_IS_ASCII
-            __Pyx_sys_getdefaultencoding_not_ascii &&
-#endif
-            PyUnicode_Check(o)) {
-        return __Pyx_PyUnicode_AsStringAndSize(o, length);
-    } else
-#endif
-#if (!CYTHON_COMPILING_IN_PYPY) || (defined(PyByteArray_AS_STRING) && defined(PyByteArray_GET_SIZE))
-    if (PyByteArray_Check(o)) {
-        *length = PyByteArray_GET_SIZE(o);
-        return PyByteArray_AS_STRING(o);
-    } else
-#endif
-    {
-        char* result;
-        int r = PyBytes_AsStringAndSize(o, &result, length);
-        if (unlikely(r < 0)) {
-            return NULL;
-        } else {
-            return result;
-        }
-    }
-}
-static CYTHON_INLINE int __Pyx_PyObject_IsTrue(PyObject* x) {
-   int is_true = x == Py_True;
-   if (is_true | (x == Py_False) | (x == Py_None)) return is_true;
-   else return PyObject_IsTrue(x);
-}
-static CYTHON_INLINE int __Pyx_PyObject_IsTrueAndDecref(PyObject* x) {
-    int retval;
-    if (unlikely(!x)) return -1;
-    retval = __Pyx_PyObject_IsTrue(x);
-    Py_DECREF(x);
-    return retval;
-}
-static PyObject* __Pyx_PyNumber_IntOrLongWrongResultType(PyObject* result, const char* type_name) {
-#if PY_MAJOR_VERSION >= 3
-    if (PyLong_Check(result)) {
-        if (PyErr_WarnFormat(PyExc_DeprecationWarning, 1,
-                "__int__ returned non-int (type %.200s).  "
-                "The ability to return an instance of a strict subclass of int "
-                "is deprecated, and may be removed in a future version of Python.",
-                Py_TYPE(result)->tp_name)) {
-            Py_DECREF(result);
-            return NULL;
-        }
-        return result;
-    }
-#endif
-    PyErr_Format(PyExc_TypeError,
-                 "__%.4s__ returned non-%.4s (type %.200s)",
-                 type_name, type_name, Py_TYPE(result)->tp_name);
-    Py_DECREF(result);
-    return NULL;
-}
-static CYTHON_INLINE PyObject* __Pyx_PyNumber_IntOrLong(PyObject* x) {
-#if CYTHON_USE_TYPE_SLOTS
-  PyNumberMethods *m;
-#endif
-  const char *name = NULL;
-  PyObject *res = NULL;
-#if PY_MAJOR_VERSION < 3
-  if (likely(PyInt_Check(x) || PyLong_Check(x)))
-#else
-  if (likely(PyLong_Check(x)))
-#endif
-    return __Pyx_NewRef(x);
-#if CYTHON_USE_TYPE_SLOTS
-  m = Py_TYPE(x)->tp_as_number;
-  #if PY_MAJOR_VERSION < 3
-  if (m && m->nb_int) {
-    name = "int";
-    res = m->nb_int(x);
-  }
-  else if (m && m->nb_long) {
-    name = "long";
-    res = m->nb_long(x);
-  }
-  #else
-  if (likely(m && m->nb_int)) {
-    name = "int";
-    res = m->nb_int(x);
-  }
-  #endif
-#else
-  if (!PyBytes_CheckExact(x) && !PyUnicode_CheckExact(x)) {
-    res = PyNumber_Int(x);
-  }
-#endif
-  if (likely(res)) {
-#if PY_MAJOR_VERSION < 3
-    if (unlikely(!PyInt_Check(res) && !PyLong_Check(res))) {
-#else
-    if (unlikely(!PyLong_CheckExact(res))) {
-#endif
-        return __Pyx_PyNumber_IntOrLongWrongResultType(res, name);
-    }
-  }
-  else if (!PyErr_Occurred()) {
-    PyErr_SetString(PyExc_TypeError,
-                    "an integer is required");
-  }
-  return res;
-}
-static CYTHON_INLINE Py_ssize_t __Pyx_PyIndex_AsSsize_t(PyObject* b) {
-  Py_ssize_t ival;
-  PyObject *x;
-#if PY_MAJOR_VERSION < 3
-  if (likely(PyInt_CheckExact(b))) {
-    if (sizeof(Py_ssize_t) >= sizeof(long))
-        return PyInt_AS_LONG(b);
-    else
-        return PyInt_AsSsize_t(b);
-  }
-#endif
-  if (likely(PyLong_CheckExact(b))) {
-    #if CYTHON_USE_PYLONG_INTERNALS
-    const digit* digits = ((PyLongObject*)b)->ob_digit;
-    const Py_ssize_t size = Py_SIZE(b);
-    if (likely(__Pyx_sst_abs(size) <= 1)) {
-        ival = likely(size) ? digits[0] : 0;
-        if (size == -1) ival = -ival;
-        return ival;
-    } else {
-      switch (size) {
-         case 2:
-           if (8 * sizeof(Py_ssize_t) > 2 * PyLong_SHIFT) {
-             return (Py_ssize_t) (((((size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0]));
-           }
-           break;
-         case -2:
-           if (8 * sizeof(Py_ssize_t) > 2 * PyLong_SHIFT) {
-             return -(Py_ssize_t) (((((size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0]));
-           }
-           break;
-         case 3:
-           if (8 * sizeof(Py_ssize_t) > 3 * PyLong_SHIFT) {
-             return (Py_ssize_t) (((((((size_t)digits[2]) << PyLong_SHIFT) | (size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0]));
-           }
-           break;
-         case -3:
-           if (8 * sizeof(Py_ssize_t) > 3 * PyLong_SHIFT) {
-             return -(Py_ssize_t) (((((((size_t)digits[2]) << PyLong_SHIFT) | (size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0]));
-           }
-           break;
-         case 4:
-           if (8 * sizeof(Py_ssize_t) > 4 * PyLong_SHIFT) {
-             return (Py_ssize_t) (((((((((size_t)digits[3]) << PyLong_SHIFT) | (size_t)digits[2]) << PyLong_SHIFT) | (size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0]));
-           }
-           break;
-         case -4:
-           if (8 * sizeof(Py_ssize_t) > 4 * PyLong_SHIFT) {
-             return -(Py_ssize_t) (((((((((size_t)digits[3]) << PyLong_SHIFT) | (size_t)digits[2]) << PyLong_SHIFT) | (size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0]));
-           }
-           break;
-      }
-    }
-    #endif
-    return PyLong_AsSsize_t(b);
-  }
-  x = PyNumber_Index(b);
-  if (!x) return -1;
-  ival = PyInt_AsSsize_t(x);
-  Py_DECREF(x);
-  return ival;
-}
-static CYTHON_INLINE Py_hash_t __Pyx_PyIndex_AsHash_t(PyObject* o) {
-  if (sizeof(Py_hash_t) == sizeof(Py_ssize_t)) {
-    return (Py_hash_t) __Pyx_PyIndex_AsSsize_t(o);
-#if PY_MAJOR_VERSION < 3
-  } else if (likely(PyInt_CheckExact(o))) {
-    return PyInt_AS_LONG(o);
-#endif
-  } else {
-    Py_ssize_t ival;
-    PyObject *x;
-    x = PyNumber_Index(o);
-    if (!x) return -1;
-    ival = PyInt_AsLong(x);
-    Py_DECREF(x);
-    return ival;
-  }
-}
-static CYTHON_INLINE PyObject * __Pyx_PyBool_FromLong(long b) {
-  return b ? __Pyx_NewRef(Py_True) : __Pyx_NewRef(Py_False);
-}
-static CYTHON_INLINE PyObject * __Pyx_PyInt_FromSize_t(size_t ival) {
-    return PyInt_FromSize_t(ival);
-}
-
-
-#endif /* Py_PYTHON_H */
+/* Generated by Cython 0.29.32 */
+
+/* BEGIN: Cython Metadata
+{
+    "distutils": {
+        "depends": [],
+        "language": "c++",
+        "name": "crf",
+        "sources": [
+            "/home/severin/git/chaine/chaine/_core/crf.pyx"
+        ]
+    },
+    "module_name": "crf"
+}
+END: Cython Metadata */
+
+#ifndef PY_SSIZE_T_CLEAN
+#define PY_SSIZE_T_CLEAN
+#endif /* PY_SSIZE_T_CLEAN */
+#include "Python.h"
+#ifndef Py_PYTHON_H
+    #error Python headers needed to compile C extensions, please install development version of Python.
+#elif PY_VERSION_HEX < 0x02060000 || (0x03000000 <= PY_VERSION_HEX && PY_VERSION_HEX < 0x03030000)
+    #error Cython requires Python 2.6+ or Python 3.3+.
+#else
+#define CYTHON_ABI "0_29_32"
+#define CYTHON_HEX_VERSION 0x001D20F0
+#define CYTHON_FUTURE_DIVISION 0
+#include <stddef.h>
+#ifndef offsetof
+  #define offsetof(type, member) ( (size_t) & ((type*)0) -> member )
+#endif
+#if !defined(WIN32) && !defined(MS_WINDOWS)
+  #ifndef __stdcall
+    #define __stdcall
+  #endif
+  #ifndef __cdecl
+    #define __cdecl
+  #endif
+  #ifndef __fastcall
+    #define __fastcall
+  #endif
+#endif
+#ifndef DL_IMPORT
+  #define DL_IMPORT(t) t
+#endif
+#ifndef DL_EXPORT
+  #define DL_EXPORT(t) t
+#endif
+#define __PYX_COMMA ,
+#ifndef HAVE_LONG_LONG
+  #if PY_VERSION_HEX >= 0x02070000
+    #define HAVE_LONG_LONG
+  #endif
+#endif
+#ifndef PY_LONG_LONG
+  #define PY_LONG_LONG LONG_LONG
+#endif
+#ifndef Py_HUGE_VAL
+  #define Py_HUGE_VAL HUGE_VAL
+#endif
+#ifdef PYPY_VERSION
+  #define CYTHON_COMPILING_IN_PYPY 1
+  #define CYTHON_COMPILING_IN_PYSTON 0
+  #define CYTHON_COMPILING_IN_CPYTHON 0
+  #define CYTHON_COMPILING_IN_NOGIL 0
+  #undef CYTHON_USE_TYPE_SLOTS
+  #define CYTHON_USE_TYPE_SLOTS 0
+  #undef CYTHON_USE_PYTYPE_LOOKUP
+  #define CYTHON_USE_PYTYPE_LOOKUP 0
+  #if PY_VERSION_HEX < 0x03050000
+    #undef CYTHON_USE_ASYNC_SLOTS
+    #define CYTHON_USE_ASYNC_SLOTS 0
+  #elif !defined(CYTHON_USE_ASYNC_SLOTS)
+    #define CYTHON_USE_ASYNC_SLOTS 1
+  #endif
+  #undef CYTHON_USE_PYLIST_INTERNALS
+  #define CYTHON_USE_PYLIST_INTERNALS 0
+  #undef CYTHON_USE_UNICODE_INTERNALS
+  #define CYTHON_USE_UNICODE_INTERNALS 0
+  #undef CYTHON_USE_UNICODE_WRITER
+  #define CYTHON_USE_UNICODE_WRITER 0
+  #undef CYTHON_USE_PYLONG_INTERNALS
+  #define CYTHON_USE_PYLONG_INTERNALS 0
+  #undef CYTHON_AVOID_BORROWED_REFS
+  #define CYTHON_AVOID_BORROWED_REFS 1
+  #undef CYTHON_ASSUME_SAFE_MACROS
+  #define CYTHON_ASSUME_SAFE_MACROS 0
+  #undef CYTHON_UNPACK_METHODS
+  #define CYTHON_UNPACK_METHODS 0
+  #undef CYTHON_FAST_THREAD_STATE
+  #define CYTHON_FAST_THREAD_STATE 0
+  #undef CYTHON_FAST_PYCALL
+  #define CYTHON_FAST_PYCALL 0
+  #undef CYTHON_PEP489_MULTI_PHASE_INIT
+  #define CYTHON_PEP489_MULTI_PHASE_INIT 0
+  #undef CYTHON_USE_TP_FINALIZE
+  #define CYTHON_USE_TP_FINALIZE 0
+  #undef CYTHON_USE_DICT_VERSIONS
+  #define CYTHON_USE_DICT_VERSIONS 0
+  #undef CYTHON_USE_EXC_INFO_STACK
+  #define CYTHON_USE_EXC_INFO_STACK 0
+  #ifndef CYTHON_UPDATE_DESCRIPTOR_DOC
+    #define CYTHON_UPDATE_DESCRIPTOR_DOC (PYPY_VERSION_HEX >= 0x07030900)
+  #endif
+#elif defined(PYSTON_VERSION)
+  #define CYTHON_COMPILING_IN_PYPY 0
+  #define CYTHON_COMPILING_IN_PYSTON 1
+  #define CYTHON_COMPILING_IN_CPYTHON 0
+  #define CYTHON_COMPILING_IN_NOGIL 0
+  #ifndef CYTHON_USE_TYPE_SLOTS
+    #define CYTHON_USE_TYPE_SLOTS 1
+  #endif
+  #undef CYTHON_USE_PYTYPE_LOOKUP
+  #define CYTHON_USE_PYTYPE_LOOKUP 0
+  #undef CYTHON_USE_ASYNC_SLOTS
+  #define CYTHON_USE_ASYNC_SLOTS 0
+  #undef CYTHON_USE_PYLIST_INTERNALS
+  #define CYTHON_USE_PYLIST_INTERNALS 0
+  #ifndef CYTHON_USE_UNICODE_INTERNALS
+    #define CYTHON_USE_UNICODE_INTERNALS 1
+  #endif
+  #undef CYTHON_USE_UNICODE_WRITER
+  #define CYTHON_USE_UNICODE_WRITER 0
+  #undef CYTHON_USE_PYLONG_INTERNALS
+  #define CYTHON_USE_PYLONG_INTERNALS 0
+  #ifndef CYTHON_AVOID_BORROWED_REFS
+    #define CYTHON_AVOID_BORROWED_REFS 0
+  #endif
+  #ifndef CYTHON_ASSUME_SAFE_MACROS
+    #define CYTHON_ASSUME_SAFE_MACROS 1
+  #endif
+  #ifndef CYTHON_UNPACK_METHODS
+    #define CYTHON_UNPACK_METHODS 1
+  #endif
+  #undef CYTHON_FAST_THREAD_STATE
+  #define CYTHON_FAST_THREAD_STATE 0
+  #undef CYTHON_FAST_PYCALL
+  #define CYTHON_FAST_PYCALL 0
+  #undef CYTHON_PEP489_MULTI_PHASE_INIT
+  #define CYTHON_PEP489_MULTI_PHASE_INIT 0
+  #undef CYTHON_USE_TP_FINALIZE
+  #define CYTHON_USE_TP_FINALIZE 0
+  #undef CYTHON_USE_DICT_VERSIONS
+  #define CYTHON_USE_DICT_VERSIONS 0
+  #undef CYTHON_USE_EXC_INFO_STACK
+  #define CYTHON_USE_EXC_INFO_STACK 0
+  #ifndef CYTHON_UPDATE_DESCRIPTOR_DOC
+    #define CYTHON_UPDATE_DESCRIPTOR_DOC 0
+  #endif
+#elif defined(PY_NOGIL)
+  #define CYTHON_COMPILING_IN_PYPY 0
+  #define CYTHON_COMPILING_IN_PYSTON 0
+  #define CYTHON_COMPILING_IN_CPYTHON 0
+  #define CYTHON_COMPILING_IN_NOGIL 1
+  #ifndef CYTHON_USE_TYPE_SLOTS
+    #define CYTHON_USE_TYPE_SLOTS 1
+  #endif
+  #undef CYTHON_USE_PYTYPE_LOOKUP
+  #define CYTHON_USE_PYTYPE_LOOKUP 0
+  #ifndef CYTHON_USE_ASYNC_SLOTS
+    #define CYTHON_USE_ASYNC_SLOTS 1
+  #endif
+  #undef CYTHON_USE_PYLIST_INTERNALS
+  #define CYTHON_USE_PYLIST_INTERNALS 0
+  #ifndef CYTHON_USE_UNICODE_INTERNALS
+    #define CYTHON_USE_UNICODE_INTERNALS 1
+  #endif
+  #undef CYTHON_USE_UNICODE_WRITER
+  #define CYTHON_USE_UNICODE_WRITER 0
+  #undef CYTHON_USE_PYLONG_INTERNALS
+  #define CYTHON_USE_PYLONG_INTERNALS 0
+  #ifndef CYTHON_AVOID_BORROWED_REFS
+    #define CYTHON_AVOID_BORROWED_REFS 0
+  #endif
+  #ifndef CYTHON_ASSUME_SAFE_MACROS
+    #define CYTHON_ASSUME_SAFE_MACROS 1
+  #endif
+  #ifndef CYTHON_UNPACK_METHODS
+    #define CYTHON_UNPACK_METHODS 1
+  #endif
+  #undef CYTHON_FAST_THREAD_STATE
+  #define CYTHON_FAST_THREAD_STATE 0
+  #undef CYTHON_FAST_PYCALL
+  #define CYTHON_FAST_PYCALL 0
+  #ifndef CYTHON_PEP489_MULTI_PHASE_INIT
+    #define CYTHON_PEP489_MULTI_PHASE_INIT 1
+  #endif
+  #ifndef CYTHON_USE_TP_FINALIZE
+    #define CYTHON_USE_TP_FINALIZE 1
+  #endif
+  #undef CYTHON_USE_DICT_VERSIONS
+  #define CYTHON_USE_DICT_VERSIONS 0
+  #undef CYTHON_USE_EXC_INFO_STACK
+  #define CYTHON_USE_EXC_INFO_STACK 0
+#else
+  #define CYTHON_COMPILING_IN_PYPY 0
+  #define CYTHON_COMPILING_IN_PYSTON 0
+  #define CYTHON_COMPILING_IN_CPYTHON 1
+  #define CYTHON_COMPILING_IN_NOGIL 0
+  #ifndef CYTHON_USE_TYPE_SLOTS
+    #define CYTHON_USE_TYPE_SLOTS 1
+  #endif
+  #if PY_VERSION_HEX < 0x02070000
+    #undef CYTHON_USE_PYTYPE_LOOKUP
+    #define CYTHON_USE_PYTYPE_LOOKUP 0
+  #elif !defined(CYTHON_USE_PYTYPE_LOOKUP)
+    #define CYTHON_USE_PYTYPE_LOOKUP 1
+  #endif
+  #if PY_MAJOR_VERSION < 3
+    #undef CYTHON_USE_ASYNC_SLOTS
+    #define CYTHON_USE_ASYNC_SLOTS 0
+  #elif !defined(CYTHON_USE_ASYNC_SLOTS)
+    #define CYTHON_USE_ASYNC_SLOTS 1
+  #endif
+  #if PY_VERSION_HEX < 0x02070000
+    #undef CYTHON_USE_PYLONG_INTERNALS
+    #define CYTHON_USE_PYLONG_INTERNALS 0
+  #elif !defined(CYTHON_USE_PYLONG_INTERNALS)
+    #define CYTHON_USE_PYLONG_INTERNALS 1
+  #endif
+  #ifndef CYTHON_USE_PYLIST_INTERNALS
+    #define CYTHON_USE_PYLIST_INTERNALS 1
+  #endif
+  #ifndef CYTHON_USE_UNICODE_INTERNALS
+    #define CYTHON_USE_UNICODE_INTERNALS 1
+  #endif
+  #if PY_VERSION_HEX < 0x030300F0 || PY_VERSION_HEX >= 0x030B00A2
+    #undef CYTHON_USE_UNICODE_WRITER
+    #define CYTHON_USE_UNICODE_WRITER 0
+  #elif !defined(CYTHON_USE_UNICODE_WRITER)
+    #define CYTHON_USE_UNICODE_WRITER 1
+  #endif
+  #ifndef CYTHON_AVOID_BORROWED_REFS
+    #define CYTHON_AVOID_BORROWED_REFS 0
+  #endif
+  #ifndef CYTHON_ASSUME_SAFE_MACROS
+    #define CYTHON_ASSUME_SAFE_MACROS 1
+  #endif
+  #ifndef CYTHON_UNPACK_METHODS
+    #define CYTHON_UNPACK_METHODS 1
+  #endif
+  #if PY_VERSION_HEX >= 0x030B00A4
+    #undef CYTHON_FAST_THREAD_STATE
+    #define CYTHON_FAST_THREAD_STATE 0
+  #elif !defined(CYTHON_FAST_THREAD_STATE)
+    #define CYTHON_FAST_THREAD_STATE 1
+  #endif
+  #ifndef CYTHON_FAST_PYCALL
+    #define CYTHON_FAST_PYCALL (PY_VERSION_HEX < 0x030A0000)
+  #endif
+  #ifndef CYTHON_PEP489_MULTI_PHASE_INIT
+    #define CYTHON_PEP489_MULTI_PHASE_INIT (PY_VERSION_HEX >= 0x03050000)
+  #endif
+  #ifndef CYTHON_USE_TP_FINALIZE
+    #define CYTHON_USE_TP_FINALIZE (PY_VERSION_HEX >= 0x030400a1)
+  #endif
+  #ifndef CYTHON_USE_DICT_VERSIONS
+    #define CYTHON_USE_DICT_VERSIONS (PY_VERSION_HEX >= 0x030600B1)
+  #endif
+  #if PY_VERSION_HEX >= 0x030B00A4
+    #undef CYTHON_USE_EXC_INFO_STACK
+    #define CYTHON_USE_EXC_INFO_STACK 0
+  #elif !defined(CYTHON_USE_EXC_INFO_STACK)
+    #define CYTHON_USE_EXC_INFO_STACK (PY_VERSION_HEX >= 0x030700A3)
+  #endif
+  #ifndef CYTHON_UPDATE_DESCRIPTOR_DOC
+    #define CYTHON_UPDATE_DESCRIPTOR_DOC 1
+  #endif
+#endif
+#if !defined(CYTHON_FAST_PYCCALL)
+#define CYTHON_FAST_PYCCALL  (CYTHON_FAST_PYCALL && PY_VERSION_HEX >= 0x030600B1)
+#endif
+#if CYTHON_USE_PYLONG_INTERNALS
+  #if PY_MAJOR_VERSION < 3
+    #include "longintrepr.h"
+  #endif
+  #undef SHIFT
+  #undef BASE
+  #undef MASK
+  #ifdef SIZEOF_VOID_P
+    enum { __pyx_check_sizeof_voidp = 1 / (int)(SIZEOF_VOID_P == sizeof(void*)) };
+  #endif
+#endif
+#ifndef __has_attribute
+  #define __has_attribute(x) 0
+#endif
+#ifndef __has_cpp_attribute
+  #define __has_cpp_attribute(x) 0
+#endif
+#ifndef CYTHON_RESTRICT
+  #if defined(__GNUC__)
+    #define CYTHON_RESTRICT __restrict__
+  #elif defined(_MSC_VER) && _MSC_VER >= 1400
+    #define CYTHON_RESTRICT __restrict
+  #elif defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
+    #define CYTHON_RESTRICT restrict
+  #else
+    #define CYTHON_RESTRICT
+  #endif
+#endif
+#ifndef CYTHON_UNUSED
+# if defined(__GNUC__)
+#   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
+#     define CYTHON_UNUSED __attribute__ ((__unused__))
+#   else
+#     define CYTHON_UNUSED
+#   endif
+# elif defined(__ICC) || (defined(__INTEL_COMPILER) && !defined(_MSC_VER))
+#   define CYTHON_UNUSED __attribute__ ((__unused__))
+# else
+#   define CYTHON_UNUSED
+# endif
+#endif
+#ifndef CYTHON_MAYBE_UNUSED_VAR
+#  if defined(__cplusplus)
+     template<class T> void CYTHON_MAYBE_UNUSED_VAR( const T& ) { }
+#  else
+#    define CYTHON_MAYBE_UNUSED_VAR(x) (void)(x)
+#  endif
+#endif
+#ifndef CYTHON_NCP_UNUSED
+# if CYTHON_COMPILING_IN_CPYTHON
+#  define CYTHON_NCP_UNUSED
+# else
+#  define CYTHON_NCP_UNUSED CYTHON_UNUSED
+# endif
+#endif
+#define __Pyx_void_to_None(void_result) ((void)(void_result), Py_INCREF(Py_None), Py_None)
+#ifdef _MSC_VER
+    #ifndef _MSC_STDINT_H_
+        #if _MSC_VER < 1300
+           typedef unsigned char     uint8_t;
+           typedef unsigned int      uint32_t;
+        #else
+           typedef unsigned __int8   uint8_t;
+           typedef unsigned __int32  uint32_t;
+        #endif
+    #endif
+#else
+   #include <stdint.h>
+#endif
+#ifndef CYTHON_FALLTHROUGH
+  #if defined(__cplusplus) && __cplusplus >= 201103L
+    #if __has_cpp_attribute(fallthrough)
+      #define CYTHON_FALLTHROUGH [[fallthrough]]
+    #elif __has_cpp_attribute(clang::fallthrough)
+      #define CYTHON_FALLTHROUGH [[clang::fallthrough]]
+    #elif __has_cpp_attribute(gnu::fallthrough)
+      #define CYTHON_FALLTHROUGH [[gnu::fallthrough]]
+    #endif
+  #endif
+  #ifndef CYTHON_FALLTHROUGH
+    #if __has_attribute(fallthrough)
+      #define CYTHON_FALLTHROUGH __attribute__((fallthrough))
+    #else
+      #define CYTHON_FALLTHROUGH
+    #endif
+  #endif
+  #if defined(__clang__ ) && defined(__apple_build_version__)
+    #if __apple_build_version__ < 7000000
+      #undef  CYTHON_FALLTHROUGH
+      #define CYTHON_FALLTHROUGH
+    #endif
+  #endif
+#endif
+
+#ifndef __cplusplus
+  #error "Cython files generated with the C++ option must be compiled with a C++ compiler."
+#endif
+#ifndef CYTHON_INLINE
+  #if defined(__clang__)
+    #define CYTHON_INLINE __inline__ __attribute__ ((__unused__))
+  #else
+    #define CYTHON_INLINE inline
+  #endif
+#endif
+template<typename T>
+void __Pyx_call_destructor(T& x) {
+    x.~T();
+}
+template<typename T>
+class __Pyx_FakeReference {
+  public:
+    __Pyx_FakeReference() : ptr(NULL) { }
+    __Pyx_FakeReference(const T& ref) : ptr(const_cast<T*>(&ref)) { }
+    T *operator->() { return ptr; }
+    T *operator&() { return ptr; }
+    operator T&() { return *ptr; }
+    template<typename U> bool operator ==(U other) { return *ptr == other; }
+    template<typename U> bool operator !=(U other) { return *ptr != other; }
+  private:
+    T *ptr;
+};
+
+#if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX < 0x02070600 && !defined(Py_OptimizeFlag)
+  #define Py_OptimizeFlag 0
+#endif
+#define __PYX_BUILD_PY_SSIZE_T "n"
+#define CYTHON_FORMAT_SSIZE_T "z"
+#if PY_MAJOR_VERSION < 3
+  #define __Pyx_BUILTIN_MODULE_NAME "__builtin__"
+  #define __Pyx_PyCode_New(a, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)\
+          PyCode_New(a+k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)
+  #define __Pyx_DefaultClassType PyClass_Type
+#else
+  #define __Pyx_BUILTIN_MODULE_NAME "builtins"
+  #define __Pyx_DefaultClassType PyType_Type
+#if PY_VERSION_HEX >= 0x030B00A1
+    static CYTHON_INLINE PyCodeObject* __Pyx_PyCode_New(int a, int k, int l, int s, int f,
+                                                    PyObject *code, PyObject *c, PyObject* n, PyObject *v,
+                                                    PyObject *fv, PyObject *cell, PyObject* fn,
+                                                    PyObject *name, int fline, PyObject *lnos) {
+        PyObject *kwds=NULL, *argcount=NULL, *posonlyargcount=NULL, *kwonlyargcount=NULL;
+        PyObject *nlocals=NULL, *stacksize=NULL, *flags=NULL, *replace=NULL, *call_result=NULL, *empty=NULL;
+        const char *fn_cstr=NULL;
+        const char *name_cstr=NULL;
+        PyCodeObject* co=NULL;
+        PyObject *type, *value, *traceback;
+        PyErr_Fetch(&type, &value, &traceback);
+        if (!(kwds=PyDict_New())) goto end;
+        if (!(argcount=PyLong_FromLong(a))) goto end;
+        if (PyDict_SetItemString(kwds, "co_argcount", argcount) != 0) goto end;
+        if (!(posonlyargcount=PyLong_FromLong(0))) goto end;
+        if (PyDict_SetItemString(kwds, "co_posonlyargcount", posonlyargcount) != 0) goto end;
+        if (!(kwonlyargcount=PyLong_FromLong(k))) goto end;
+        if (PyDict_SetItemString(kwds, "co_kwonlyargcount", kwonlyargcount) != 0) goto end;
+        if (!(nlocals=PyLong_FromLong(l))) goto end;
+        if (PyDict_SetItemString(kwds, "co_nlocals", nlocals) != 0) goto end;
+        if (!(stacksize=PyLong_FromLong(s))) goto end;
+        if (PyDict_SetItemString(kwds, "co_stacksize", stacksize) != 0) goto end;
+        if (!(flags=PyLong_FromLong(f))) goto end;
+        if (PyDict_SetItemString(kwds, "co_flags", flags) != 0) goto end;
+        if (PyDict_SetItemString(kwds, "co_code", code) != 0) goto end;
+        if (PyDict_SetItemString(kwds, "co_consts", c) != 0) goto end;
+        if (PyDict_SetItemString(kwds, "co_names", n) != 0) goto end;
+        if (PyDict_SetItemString(kwds, "co_varnames", v) != 0) goto end;
+        if (PyDict_SetItemString(kwds, "co_freevars", fv) != 0) goto end;
+        if (PyDict_SetItemString(kwds, "co_cellvars", cell) != 0) goto end;
+        if (PyDict_SetItemString(kwds, "co_linetable", lnos) != 0) goto end;
+        if (!(fn_cstr=PyUnicode_AsUTF8AndSize(fn, NULL))) goto end;
+        if (!(name_cstr=PyUnicode_AsUTF8AndSize(name, NULL))) goto end;
+        if (!(co = PyCode_NewEmpty(fn_cstr, name_cstr, fline))) goto end;
+        if (!(replace = PyObject_GetAttrString((PyObject*)co, "replace"))) goto cleanup_code_too;
+        if (!(empty = PyTuple_New(0))) goto cleanup_code_too; // unfortunately __pyx_empty_tuple isn't available here
+        if (!(call_result = PyObject_Call(replace, empty, kwds))) goto cleanup_code_too;
+        Py_XDECREF((PyObject*)co);
+        co = (PyCodeObject*)call_result;
+        call_result = NULL;
+        if (0) {
+            cleanup_code_too:
+            Py_XDECREF((PyObject*)co);
+            co = NULL;
+        }
+        end:
+        Py_XDECREF(kwds);
+        Py_XDECREF(argcount);
+        Py_XDECREF(posonlyargcount);
+        Py_XDECREF(kwonlyargcount);
+        Py_XDECREF(nlocals);
+        Py_XDECREF(stacksize);
+        Py_XDECREF(replace);
+        Py_XDECREF(call_result);
+        Py_XDECREF(empty);
+        if (type) {
+            PyErr_Restore(type, value, traceback);
+        }
+        return co;
+    }
+#else
+  #define __Pyx_PyCode_New(a, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)\
+          PyCode_New(a, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)
+#endif
+  #define __Pyx_DefaultClassType PyType_Type
+#endif
+#ifndef Py_TPFLAGS_CHECKTYPES
+  #define Py_TPFLAGS_CHECKTYPES 0
+#endif
+#ifndef Py_TPFLAGS_HAVE_INDEX
+  #define Py_TPFLAGS_HAVE_INDEX 0
+#endif
+#ifndef Py_TPFLAGS_HAVE_NEWBUFFER
+  #define Py_TPFLAGS_HAVE_NEWBUFFER 0
+#endif
+#ifndef Py_TPFLAGS_HAVE_FINALIZE
+  #define Py_TPFLAGS_HAVE_FINALIZE 0
+#endif
+#ifndef METH_STACKLESS
+  #define METH_STACKLESS 0
+#endif
+#if PY_VERSION_HEX <= 0x030700A3 || !defined(METH_FASTCALL)
+  #ifndef METH_FASTCALL
+     #define METH_FASTCALL 0x80
+  #endif
+  typedef PyObject *(*__Pyx_PyCFunctionFast) (PyObject *self, PyObject *const *args, Py_ssize_t nargs);
+  typedef PyObject *(*__Pyx_PyCFunctionFastWithKeywords) (PyObject *self, PyObject *const *args,
+                                                          Py_ssize_t nargs, PyObject *kwnames);
+#else
+  #define __Pyx_PyCFunctionFast _PyCFunctionFast
+  #define __Pyx_PyCFunctionFastWithKeywords _PyCFunctionFastWithKeywords
+#endif
+#if CYTHON_FAST_PYCCALL
+#define __Pyx_PyFastCFunction_Check(func)\
+    ((PyCFunction_Check(func) && (METH_FASTCALL == (PyCFunction_GET_FLAGS(func) & ~(METH_CLASS | METH_STATIC | METH_COEXIST | METH_KEYWORDS | METH_STACKLESS)))))
+#else
+#define __Pyx_PyFastCFunction_Check(func) 0
+#endif
+#if CYTHON_COMPILING_IN_PYPY && !defined(PyObject_Malloc)
+  #define PyObject_Malloc(s)   PyMem_Malloc(s)
+  #define PyObject_Free(p)     PyMem_Free(p)
+  #define PyObject_Realloc(p)  PyMem_Realloc(p)
+#endif
+#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX < 0x030400A1
+  #define PyMem_RawMalloc(n)           PyMem_Malloc(n)
+  #define PyMem_RawRealloc(p, n)       PyMem_Realloc(p, n)
+  #define PyMem_RawFree(p)             PyMem_Free(p)
+#endif
+#if CYTHON_COMPILING_IN_PYSTON
+  #define __Pyx_PyCode_HasFreeVars(co)  PyCode_HasFreeVars(co)
+  #define __Pyx_PyFrame_SetLineNumber(frame, lineno) PyFrame_SetLineNumber(frame, lineno)
+#else
+  #define __Pyx_PyCode_HasFreeVars(co)  (PyCode_GetNumFree(co) > 0)
+  #define __Pyx_PyFrame_SetLineNumber(frame, lineno)  (frame)->f_lineno = (lineno)
+#endif
+#if !CYTHON_FAST_THREAD_STATE || PY_VERSION_HEX < 0x02070000
+  #define __Pyx_PyThreadState_Current PyThreadState_GET()
+#elif PY_VERSION_HEX >= 0x03060000
+  #define __Pyx_PyThreadState_Current _PyThreadState_UncheckedGet()
+#elif PY_VERSION_HEX >= 0x03000000
+  #define __Pyx_PyThreadState_Current PyThreadState_GET()
+#else
+  #define __Pyx_PyThreadState_Current _PyThreadState_Current
+#endif
+#if PY_VERSION_HEX < 0x030700A2 && !defined(PyThread_tss_create) && !defined(Py_tss_NEEDS_INIT)
+#include "pythread.h"
+#define Py_tss_NEEDS_INIT 0
+typedef int Py_tss_t;
+static CYTHON_INLINE int PyThread_tss_create(Py_tss_t *key) {
+  *key = PyThread_create_key();
+  return 0;
+}
+static CYTHON_INLINE Py_tss_t * PyThread_tss_alloc(void) {
+  Py_tss_t *key = (Py_tss_t *)PyObject_Malloc(sizeof(Py_tss_t));
+  *key = Py_tss_NEEDS_INIT;
+  return key;
+}
+static CYTHON_INLINE void PyThread_tss_free(Py_tss_t *key) {
+  PyObject_Free(key);
+}
+static CYTHON_INLINE int PyThread_tss_is_created(Py_tss_t *key) {
+  return *key != Py_tss_NEEDS_INIT;
+}
+static CYTHON_INLINE void PyThread_tss_delete(Py_tss_t *key) {
+  PyThread_delete_key(*key);
+  *key = Py_tss_NEEDS_INIT;
+}
+static CYTHON_INLINE int PyThread_tss_set(Py_tss_t *key, void *value) {
+  return PyThread_set_key_value(*key, value);
+}
+static CYTHON_INLINE void * PyThread_tss_get(Py_tss_t *key) {
+  return PyThread_get_key_value(*key);
+}
+#endif
+#if CYTHON_COMPILING_IN_CPYTHON || defined(_PyDict_NewPresized)
+#define __Pyx_PyDict_NewPresized(n)  ((n <= 8) ? PyDict_New() : _PyDict_NewPresized(n))
+#else
+#define __Pyx_PyDict_NewPresized(n)  PyDict_New()
+#endif
+#if PY_MAJOR_VERSION >= 3 || CYTHON_FUTURE_DIVISION
+  #define __Pyx_PyNumber_Divide(x,y)         PyNumber_TrueDivide(x,y)
+  #define __Pyx_PyNumber_InPlaceDivide(x,y)  PyNumber_InPlaceTrueDivide(x,y)
+#else
+  #define __Pyx_PyNumber_Divide(x,y)         PyNumber_Divide(x,y)
+  #define __Pyx_PyNumber_InPlaceDivide(x,y)  PyNumber_InPlaceDivide(x,y)
+#endif
+#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX >= 0x030500A1 && CYTHON_USE_UNICODE_INTERNALS
+#define __Pyx_PyDict_GetItemStr(dict, name)  _PyDict_GetItem_KnownHash(dict, name, ((PyASCIIObject *) name)->hash)
+#else
+#define __Pyx_PyDict_GetItemStr(dict, name)  PyDict_GetItem(dict, name)
+#endif
+#if PY_VERSION_HEX > 0x03030000 && defined(PyUnicode_KIND)
+  #define CYTHON_PEP393_ENABLED 1
+  #if defined(PyUnicode_IS_READY)
+  #define __Pyx_PyUnicode_READY(op)       (likely(PyUnicode_IS_READY(op)) ?\
+                                              0 : _PyUnicode_Ready((PyObject *)(op)))
+  #else
+  #define __Pyx_PyUnicode_READY(op)       (0)
+  #endif
+  #define __Pyx_PyUnicode_GET_LENGTH(u)   PyUnicode_GET_LENGTH(u)
+  #define __Pyx_PyUnicode_READ_CHAR(u, i) PyUnicode_READ_CHAR(u, i)
+  #define __Pyx_PyUnicode_MAX_CHAR_VALUE(u)   PyUnicode_MAX_CHAR_VALUE(u)
+  #define __Pyx_PyUnicode_KIND(u)         PyUnicode_KIND(u)
+  #define __Pyx_PyUnicode_DATA(u)         PyUnicode_DATA(u)
+  #define __Pyx_PyUnicode_READ(k, d, i)   PyUnicode_READ(k, d, i)
+  #define __Pyx_PyUnicode_WRITE(k, d, i, ch)  PyUnicode_WRITE(k, d, i, ch)
+  #if defined(PyUnicode_IS_READY) && defined(PyUnicode_GET_SIZE)
+  #if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX >= 0x03090000
+  #define __Pyx_PyUnicode_IS_TRUE(u)      (0 != (likely(PyUnicode_IS_READY(u)) ? PyUnicode_GET_LENGTH(u) : ((PyCompactUnicodeObject *)(u))->wstr_length))
+  #else
+  #define __Pyx_PyUnicode_IS_TRUE(u)      (0 != (likely(PyUnicode_IS_READY(u)) ? PyUnicode_GET_LENGTH(u) : PyUnicode_GET_SIZE(u)))
+  #endif
+  #else
+  #define __Pyx_PyUnicode_IS_TRUE(u)      (0 != PyUnicode_GET_LENGTH(u))
+  #endif
+#else
+  #define CYTHON_PEP393_ENABLED 0
+  #define PyUnicode_1BYTE_KIND  1
+  #define PyUnicode_2BYTE_KIND  2
+  #define PyUnicode_4BYTE_KIND  4
+  #define __Pyx_PyUnicode_READY(op)       (0)
+  #define __Pyx_PyUnicode_GET_LENGTH(u)   PyUnicode_GET_SIZE(u)
+  #define __Pyx_PyUnicode_READ_CHAR(u, i) ((Py_UCS4)(PyUnicode_AS_UNICODE(u)[i]))
+  #define __Pyx_PyUnicode_MAX_CHAR_VALUE(u)   ((sizeof(Py_UNICODE) == 2) ? 65535 : 1114111)
+  #define __Pyx_PyUnicode_KIND(u)         (sizeof(Py_UNICODE))
+  #define __Pyx_PyUnicode_DATA(u)         ((void*)PyUnicode_AS_UNICODE(u))
+  #define __Pyx_PyUnicode_READ(k, d, i)   ((void)(k), (Py_UCS4)(((Py_UNICODE*)d)[i]))
+  #define __Pyx_PyUnicode_WRITE(k, d, i, ch)  (((void)(k)), ((Py_UNICODE*)d)[i] = ch)
+  #define __Pyx_PyUnicode_IS_TRUE(u)      (0 != PyUnicode_GET_SIZE(u))
+#endif
+#if CYTHON_COMPILING_IN_PYPY
+  #define __Pyx_PyUnicode_Concat(a, b)      PyNumber_Add(a, b)
+  #define __Pyx_PyUnicode_ConcatSafe(a, b)  PyNumber_Add(a, b)
+#else
+  #define __Pyx_PyUnicode_Concat(a, b)      PyUnicode_Concat(a, b)
+  #define __Pyx_PyUnicode_ConcatSafe(a, b)  ((unlikely((a) == Py_None) || unlikely((b) == Py_None)) ?\
+      PyNumber_Add(a, b) : __Pyx_PyUnicode_Concat(a, b))
+#endif
+#if CYTHON_COMPILING_IN_PYPY && !defined(PyUnicode_Contains)
+  #define PyUnicode_Contains(u, s)  PySequence_Contains(u, s)
+#endif
+#if CYTHON_COMPILING_IN_PYPY && !defined(PyByteArray_Check)
+  #define PyByteArray_Check(obj)  PyObject_TypeCheck(obj, &PyByteArray_Type)
+#endif
+#if CYTHON_COMPILING_IN_PYPY && !defined(PyObject_Format)
+  #define PyObject_Format(obj, fmt)  PyObject_CallMethod(obj, "__format__", "O", fmt)
+#endif
+#define __Pyx_PyString_FormatSafe(a, b)   ((unlikely((a) == Py_None || (PyString_Check(b) && !PyString_CheckExact(b)))) ? PyNumber_Remainder(a, b) : __Pyx_PyString_Format(a, b))
+#define __Pyx_PyUnicode_FormatSafe(a, b)  ((unlikely((a) == Py_None || (PyUnicode_Check(b) && !PyUnicode_CheckExact(b)))) ? PyNumber_Remainder(a, b) : PyUnicode_Format(a, b))
+#if PY_MAJOR_VERSION >= 3
+  #define __Pyx_PyString_Format(a, b)  PyUnicode_Format(a, b)
+#else
+  #define __Pyx_PyString_Format(a, b)  PyString_Format(a, b)
+#endif
+#if PY_MAJOR_VERSION < 3 && !defined(PyObject_ASCII)
+  #define PyObject_ASCII(o)            PyObject_Repr(o)
+#endif
+#if PY_MAJOR_VERSION >= 3
+  #define PyBaseString_Type            PyUnicode_Type
+  #define PyStringObject               PyUnicodeObject
+  #define PyString_Type                PyUnicode_Type
+  #define PyString_Check               PyUnicode_Check
+  #define PyString_CheckExact          PyUnicode_CheckExact
+#ifndef PyObject_Unicode
+  #define PyObject_Unicode             PyObject_Str
+#endif
+#endif
+#if PY_MAJOR_VERSION >= 3
+  #define __Pyx_PyBaseString_Check(obj) PyUnicode_Check(obj)
+  #define __Pyx_PyBaseString_CheckExact(obj) PyUnicode_CheckExact(obj)
+#else
+  #define __Pyx_PyBaseString_Check(obj) (PyString_Check(obj) || PyUnicode_Check(obj))
+  #define __Pyx_PyBaseString_CheckExact(obj) (PyString_CheckExact(obj) || PyUnicode_CheckExact(obj))
+#endif
+#ifndef PySet_CheckExact
+  #define PySet_CheckExact(obj)        (Py_TYPE(obj) == &PySet_Type)
+#endif
+#if PY_VERSION_HEX >= 0x030900A4
+  #define __Pyx_SET_REFCNT(obj, refcnt) Py_SET_REFCNT(obj, refcnt)
+  #define __Pyx_SET_SIZE(obj, size) Py_SET_SIZE(obj, size)
+#else
+  #define __Pyx_SET_REFCNT(obj, refcnt) Py_REFCNT(obj) = (refcnt)
+  #define __Pyx_SET_SIZE(obj, size) Py_SIZE(obj) = (size)
+#endif
+#if CYTHON_ASSUME_SAFE_MACROS
+  #define __Pyx_PySequence_SIZE(seq)  Py_SIZE(seq)
+#else
+  #define __Pyx_PySequence_SIZE(seq)  PySequence_Size(seq)
+#endif
+#if PY_MAJOR_VERSION >= 3
+  #define PyIntObject                  PyLongObject
+  #define PyInt_Type                   PyLong_Type
+  #define PyInt_Check(op)              PyLong_Check(op)
+  #define PyInt_CheckExact(op)         PyLong_CheckExact(op)
+  #define PyInt_FromString             PyLong_FromString
+  #define PyInt_FromUnicode            PyLong_FromUnicode
+  #define PyInt_FromLong               PyLong_FromLong
+  #define PyInt_FromSize_t             PyLong_FromSize_t
+  #define PyInt_FromSsize_t            PyLong_FromSsize_t
+  #define PyInt_AsLong                 PyLong_AsLong
+  #define PyInt_AS_LONG                PyLong_AS_LONG
+  #define PyInt_AsSsize_t              PyLong_AsSsize_t
+  #define PyInt_AsUnsignedLongMask     PyLong_AsUnsignedLongMask
+  #define PyInt_AsUnsignedLongLongMask PyLong_AsUnsignedLongLongMask
+  #define PyNumber_Int                 PyNumber_Long
+#endif
+#if PY_MAJOR_VERSION >= 3
+  #define PyBoolObject                 PyLongObject
+#endif
+#if PY_MAJOR_VERSION >= 3 && CYTHON_COMPILING_IN_PYPY
+  #ifndef PyUnicode_InternFromString
+    #define PyUnicode_InternFromString(s) PyUnicode_FromString(s)
+  #endif
+#endif
+#if PY_VERSION_HEX < 0x030200A4
+  typedef long Py_hash_t;
+  #define __Pyx_PyInt_FromHash_t PyInt_FromLong
+  #define __Pyx_PyInt_AsHash_t   __Pyx_PyIndex_AsHash_t
+#else
+  #define __Pyx_PyInt_FromHash_t PyInt_FromSsize_t
+  #define __Pyx_PyInt_AsHash_t   __Pyx_PyIndex_AsSsize_t
+#endif
+#if PY_MAJOR_VERSION >= 3
+  #define __Pyx_PyMethod_New(func, self, klass) ((self) ? ((void)(klass), PyMethod_New(func, self)) : __Pyx_NewRef(func))
+#else
+  #define __Pyx_PyMethod_New(func, self, klass) PyMethod_New(func, self, klass)
+#endif
+#if CYTHON_USE_ASYNC_SLOTS
+  #if PY_VERSION_HEX >= 0x030500B1
+    #define __Pyx_PyAsyncMethodsStruct PyAsyncMethods
+    #define __Pyx_PyType_AsAsync(obj) (Py_TYPE(obj)->tp_as_async)
+  #else
+    #define __Pyx_PyType_AsAsync(obj) ((__Pyx_PyAsyncMethodsStruct*) (Py_TYPE(obj)->tp_reserved))
+  #endif
+#else
+  #define __Pyx_PyType_AsAsync(obj) NULL
+#endif
+#ifndef __Pyx_PyAsyncMethodsStruct
+    typedef struct {
+        unaryfunc am_await;
+        unaryfunc am_aiter;
+        unaryfunc am_anext;
+    } __Pyx_PyAsyncMethodsStruct;
+#endif
+
+#if defined(_WIN32) || defined(WIN32) || defined(MS_WINDOWS)
+  #if !defined(_USE_MATH_DEFINES)
+    #define _USE_MATH_DEFINES
+  #endif
+#endif
+#include <math.h>
+#ifdef NAN
+#define __PYX_NAN() ((float) NAN)
+#else
+static CYTHON_INLINE float __PYX_NAN() {
+  float value;
+  memset(&value, 0xFF, sizeof(value));
+  return value;
+}
+#endif
+#if defined(__CYGWIN__) && defined(_LDBL_EQ_DBL)
+#define __Pyx_truncl trunc
+#else
+#define __Pyx_truncl truncl
+#endif
+
+#define __PYX_MARK_ERR_POS(f_index, lineno) \
+    { __pyx_filename = __pyx_f[f_index]; (void)__pyx_filename; __pyx_lineno = lineno; (void)__pyx_lineno; __pyx_clineno = __LINE__; (void)__pyx_clineno; }
+#define __PYX_ERR(f_index, lineno, Ln_error) \
+    { __PYX_MARK_ERR_POS(f_index, lineno) goto Ln_error; }
+
+#ifndef __PYX_EXTERN_C
+  #ifdef __cplusplus
+    #define __PYX_EXTERN_C extern "C"
+  #else
+    #define __PYX_EXTERN_C extern
+  #endif
+#endif
+
+#define __PYX_HAVE__crf
+#define __PYX_HAVE_API__crf
+/* Early includes */
+#include <string.h>
+#include <string>
+#include "ios"
+#include "new"
+#include "stdexcept"
+#include "typeinfo"
+#include <vector>
+#include "crfsuite/include/crfsuite.h"
+#include "crfsuite/include/crfsuite_api.hpp"
+#include "trainer_wrapper.hpp"
+#include "tagger_wrapper.hpp"
+#ifdef _OPENMP
+#include <omp.h>
+#endif /* _OPENMP */
+
+#if defined(PYREX_WITHOUT_ASSERTIONS) && !defined(CYTHON_WITHOUT_ASSERTIONS)
+#define CYTHON_WITHOUT_ASSERTIONS
+#endif
+
+typedef struct {PyObject **p; const char *s; const Py_ssize_t n; const char* encoding;
+                const char is_unicode; const char is_str; const char intern; } __Pyx_StringTabEntry;
+
+#define __PYX_DEFAULT_STRING_ENCODING_IS_ASCII 0
+#define __PYX_DEFAULT_STRING_ENCODING_IS_UTF8 1
+#define __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT (PY_MAJOR_VERSION >= 3 && __PYX_DEFAULT_STRING_ENCODING_IS_UTF8)
+#define __PYX_DEFAULT_STRING_ENCODING "utf8"
+#define __Pyx_PyObject_FromString __Pyx_PyStr_FromString
+#define __Pyx_PyObject_FromStringAndSize __Pyx_PyStr_FromStringAndSize
+#define __Pyx_uchar_cast(c) ((unsigned char)c)
+#define __Pyx_long_cast(x) ((long)x)
+#define __Pyx_fits_Py_ssize_t(v, type, is_signed)  (\
+    (sizeof(type) < sizeof(Py_ssize_t))  ||\
+    (sizeof(type) > sizeof(Py_ssize_t) &&\
+          likely(v < (type)PY_SSIZE_T_MAX ||\
+                 v == (type)PY_SSIZE_T_MAX)  &&\
+          (!is_signed || likely(v > (type)PY_SSIZE_T_MIN ||\
+                                v == (type)PY_SSIZE_T_MIN)))  ||\
+    (sizeof(type) == sizeof(Py_ssize_t) &&\
+          (is_signed || likely(v < (type)PY_SSIZE_T_MAX ||\
+                               v == (type)PY_SSIZE_T_MAX)))  )
+static CYTHON_INLINE int __Pyx_is_valid_index(Py_ssize_t i, Py_ssize_t limit) {
+    return (size_t) i < (size_t) limit;
+}
+#if defined (__cplusplus) && __cplusplus >= 201103L
+    #include <cstdlib>
+    #define __Pyx_sst_abs(value) std::abs(value)
+#elif SIZEOF_INT >= SIZEOF_SIZE_T
+    #define __Pyx_sst_abs(value) abs(value)
+#elif SIZEOF_LONG >= SIZEOF_SIZE_T
+    #define __Pyx_sst_abs(value) labs(value)
+#elif defined (_MSC_VER)
+    #define __Pyx_sst_abs(value) ((Py_ssize_t)_abs64(value))
+#elif defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
+    #define __Pyx_sst_abs(value) llabs(value)
+#elif defined (__GNUC__)
+    #define __Pyx_sst_abs(value) __builtin_llabs(value)
+#else
+    #define __Pyx_sst_abs(value) ((value<0) ? -value : value)
+#endif
+static CYTHON_INLINE const char* __Pyx_PyObject_AsString(PyObject*);
+static CYTHON_INLINE const char* __Pyx_PyObject_AsStringAndSize(PyObject*, Py_ssize_t* length);
+#define __Pyx_PyByteArray_FromString(s) PyByteArray_FromStringAndSize((const char*)s, strlen((const char*)s))
+#define __Pyx_PyByteArray_FromStringAndSize(s, l) PyByteArray_FromStringAndSize((const char*)s, l)
+#define __Pyx_PyBytes_FromString        PyBytes_FromString
+#define __Pyx_PyBytes_FromStringAndSize PyBytes_FromStringAndSize
+static CYTHON_INLINE PyObject* __Pyx_PyUnicode_FromString(const char*);
+#if PY_MAJOR_VERSION < 3
+    #define __Pyx_PyStr_FromString        __Pyx_PyBytes_FromString
+    #define __Pyx_PyStr_FromStringAndSize __Pyx_PyBytes_FromStringAndSize
+#else
+    #define __Pyx_PyStr_FromString        __Pyx_PyUnicode_FromString
+    #define __Pyx_PyStr_FromStringAndSize __Pyx_PyUnicode_FromStringAndSize
+#endif
+#define __Pyx_PyBytes_AsWritableString(s)     ((char*) PyBytes_AS_STRING(s))
+#define __Pyx_PyBytes_AsWritableSString(s)    ((signed char*) PyBytes_AS_STRING(s))
+#define __Pyx_PyBytes_AsWritableUString(s)    ((unsigned char*) PyBytes_AS_STRING(s))
+#define __Pyx_PyBytes_AsString(s)     ((const char*) PyBytes_AS_STRING(s))
+#define __Pyx_PyBytes_AsSString(s)    ((const signed char*) PyBytes_AS_STRING(s))
+#define __Pyx_PyBytes_AsUString(s)    ((const unsigned char*) PyBytes_AS_STRING(s))
+#define __Pyx_PyObject_AsWritableString(s)    ((char*) __Pyx_PyObject_AsString(s))
+#define __Pyx_PyObject_AsWritableSString(s)    ((signed char*) __Pyx_PyObject_AsString(s))
+#define __Pyx_PyObject_AsWritableUString(s)    ((unsigned char*) __Pyx_PyObject_AsString(s))
+#define __Pyx_PyObject_AsSString(s)    ((const signed char*) __Pyx_PyObject_AsString(s))
+#define __Pyx_PyObject_AsUString(s)    ((const unsigned char*) __Pyx_PyObject_AsString(s))
+#define __Pyx_PyObject_FromCString(s)  __Pyx_PyObject_FromString((const char*)s)
+#define __Pyx_PyBytes_FromCString(s)   __Pyx_PyBytes_FromString((const char*)s)
+#define __Pyx_PyByteArray_FromCString(s)   __Pyx_PyByteArray_FromString((const char*)s)
+#define __Pyx_PyStr_FromCString(s)     __Pyx_PyStr_FromString((const char*)s)
+#define __Pyx_PyUnicode_FromCString(s) __Pyx_PyUnicode_FromString((const char*)s)
+static CYTHON_INLINE size_t __Pyx_Py_UNICODE_strlen(const Py_UNICODE *u) {
+    const Py_UNICODE *u_end = u;
+    while (*u_end++) ;
+    return (size_t)(u_end - u - 1);
+}
+#define __Pyx_PyUnicode_FromUnicode(u)       PyUnicode_FromUnicode(u, __Pyx_Py_UNICODE_strlen(u))
+#define __Pyx_PyUnicode_FromUnicodeAndLength PyUnicode_FromUnicode
+#define __Pyx_PyUnicode_AsUnicode            PyUnicode_AsUnicode
+#define __Pyx_NewRef(obj) (Py_INCREF(obj), obj)
+#define __Pyx_Owned_Py_None(b) __Pyx_NewRef(Py_None)
+static CYTHON_INLINE PyObject * __Pyx_PyBool_FromLong(long b);
+static CYTHON_INLINE int __Pyx_PyObject_IsTrue(PyObject*);
+static CYTHON_INLINE int __Pyx_PyObject_IsTrueAndDecref(PyObject*);
+static CYTHON_INLINE PyObject* __Pyx_PyNumber_IntOrLong(PyObject* x);
+#define __Pyx_PySequence_Tuple(obj)\
+    (likely(PyTuple_CheckExact(obj)) ? __Pyx_NewRef(obj) : PySequence_Tuple(obj))
+static CYTHON_INLINE Py_ssize_t __Pyx_PyIndex_AsSsize_t(PyObject*);
+static CYTHON_INLINE PyObject * __Pyx_PyInt_FromSize_t(size_t);
+static CYTHON_INLINE Py_hash_t __Pyx_PyIndex_AsHash_t(PyObject*);
+#if CYTHON_ASSUME_SAFE_MACROS
+#define __pyx_PyFloat_AsDouble(x) (PyFloat_CheckExact(x) ? PyFloat_AS_DOUBLE(x) : PyFloat_AsDouble(x))
+#else
+#define __pyx_PyFloat_AsDouble(x) PyFloat_AsDouble(x)
+#endif
+#define __pyx_PyFloat_AsFloat(x) ((float) __pyx_PyFloat_AsDouble(x))
+#if PY_MAJOR_VERSION >= 3
+#define __Pyx_PyNumber_Int(x) (PyLong_CheckExact(x) ? __Pyx_NewRef(x) : PyNumber_Long(x))
+#else
+#define __Pyx_PyNumber_Int(x) (PyInt_CheckExact(x) ? __Pyx_NewRef(x) : PyNumber_Int(x))
+#endif
+#define __Pyx_PyNumber_Float(x) (PyFloat_CheckExact(x) ? __Pyx_NewRef(x) : PyNumber_Float(x))
+#if PY_MAJOR_VERSION < 3 && __PYX_DEFAULT_STRING_ENCODING_IS_ASCII
+static int __Pyx_sys_getdefaultencoding_not_ascii;
+static int __Pyx_init_sys_getdefaultencoding_params(void) {
+    PyObject* sys;
+    PyObject* default_encoding = NULL;
+    PyObject* ascii_chars_u = NULL;
+    PyObject* ascii_chars_b = NULL;
+    const char* default_encoding_c;
+    sys = PyImport_ImportModule("sys");
+    if (!sys) goto bad;
+    default_encoding = PyObject_CallMethod(sys, (char*) "getdefaultencoding", NULL);
+    Py_DECREF(sys);
+    if (!default_encoding) goto bad;
+    default_encoding_c = PyBytes_AsString(default_encoding);
+    if (!default_encoding_c) goto bad;
+    if (strcmp(default_encoding_c, "ascii") == 0) {
+        __Pyx_sys_getdefaultencoding_not_ascii = 0;
+    } else {
+        char ascii_chars[128];
+        int c;
+        for (c = 0; c < 128; c++) {
+            ascii_chars[c] = c;
+        }
+        __Pyx_sys_getdefaultencoding_not_ascii = 1;
+        ascii_chars_u = PyUnicode_DecodeASCII(ascii_chars, 128, NULL);
+        if (!ascii_chars_u) goto bad;
+        ascii_chars_b = PyUnicode_AsEncodedString(ascii_chars_u, default_encoding_c, NULL);
+        if (!ascii_chars_b || !PyBytes_Check(ascii_chars_b) || memcmp(ascii_chars, PyBytes_AS_STRING(ascii_chars_b), 128) != 0) {
+            PyErr_Format(
+                PyExc_ValueError,
+                "This module compiled with c_string_encoding=ascii, but default encoding '%.200s' is not a superset of ascii.",
+                default_encoding_c);
+            goto bad;
+        }
+        Py_DECREF(ascii_chars_u);
+        Py_DECREF(ascii_chars_b);
+    }
+    Py_DECREF(default_encoding);
+    return 0;
+bad:
+    Py_XDECREF(default_encoding);
+    Py_XDECREF(ascii_chars_u);
+    Py_XDECREF(ascii_chars_b);
+    return -1;
+}
+#endif
+#if __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT && PY_MAJOR_VERSION >= 3
+#define __Pyx_PyUnicode_FromStringAndSize(c_str, size) PyUnicode_DecodeUTF8(c_str, size, NULL)
+#else
+#define __Pyx_PyUnicode_FromStringAndSize(c_str, size) PyUnicode_Decode(c_str, size, __PYX_DEFAULT_STRING_ENCODING, NULL)
+#if __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT
+static char* __PYX_DEFAULT_STRING_ENCODING;
+static int __Pyx_init_sys_getdefaultencoding_params(void) {
+    PyObject* sys;
+    PyObject* default_encoding = NULL;
+    char* default_encoding_c;
+    sys = PyImport_ImportModule("sys");
+    if (!sys) goto bad;
+    default_encoding = PyObject_CallMethod(sys, (char*) (const char*) "getdefaultencoding", NULL);
+    Py_DECREF(sys);
+    if (!default_encoding) goto bad;
+    default_encoding_c = PyBytes_AsString(default_encoding);
+    if (!default_encoding_c) goto bad;
+    __PYX_DEFAULT_STRING_ENCODING = (char*) malloc(strlen(default_encoding_c) + 1);
+    if (!__PYX_DEFAULT_STRING_ENCODING) goto bad;
+    strcpy(__PYX_DEFAULT_STRING_ENCODING, default_encoding_c);
+    Py_DECREF(default_encoding);
+    return 0;
+bad:
+    Py_XDECREF(default_encoding);
+    return -1;
+}
+#endif
+#endif
+
+
+/* Test for GCC > 2.95 */
+#if defined(__GNUC__)     && (__GNUC__ > 2 || (__GNUC__ == 2 && (__GNUC_MINOR__ > 95)))
+  #define likely(x)   __builtin_expect(!!(x), 1)
+  #define unlikely(x) __builtin_expect(!!(x), 0)
+#else /* !__GNUC__ or GCC < 2.95 */
+  #define likely(x)   (x)
+  #define unlikely(x) (x)
+#endif /* __GNUC__ */
+static CYTHON_INLINE void __Pyx_pretend_to_initialize(void* ptr) { (void)ptr; }
+
+static PyObject *__pyx_m = NULL;
+static PyObject *__pyx_d;
+static PyObject *__pyx_b;
+static PyObject *__pyx_cython_runtime = NULL;
+static PyObject *__pyx_empty_tuple;
+static PyObject *__pyx_empty_bytes;
+static PyObject *__pyx_empty_unicode;
+static int __pyx_lineno;
+static int __pyx_clineno = 0;
+static const char * __pyx_cfilenm= __FILE__;
+static const char *__pyx_filename;
+
+
+static const char *__pyx_f[] = {
+  "chaine/_core/crf.pyx",
+  "stringsource",
+};
+
+/*--- Type declarations ---*/
+struct __pyx_obj_3crf_Trainer;
+struct __pyx_obj_3crf_Model;
+struct __pyx_obj_3crf_ItemSequence;
+
+/* "crf.pyx":18
+ * 
+ * 
+ * cdef class Trainer:             # <<<<<<<<<<<<<<
+ *     cdef crfsuite_api.Trainer _trainer
+ * 
+ */
+struct __pyx_obj_3crf_Trainer {
+  PyObject_HEAD
+  struct __pyx_vtabstruct_3crf_Trainer *__pyx_vtab;
+  CRFSuiteWrapper::Trainer _trainer;
+};
+
+
+/* "crf.pyx":145
+ * 
+ * 
+ * cdef class Model:             # <<<<<<<<<<<<<<
+ *     cdef crfsuite_api.Tagger _tagger
+ * 
+ */
+struct __pyx_obj_3crf_Model {
+  PyObject_HEAD
+  struct __pyx_vtabstruct_3crf_Model *__pyx_vtab;
+  CRFSuiteWrapper::Tagger _tagger;
+};
+
+
+/* "crf.pyx":247
+ * 
+ * 
+ * cdef class ItemSequence:             # <<<<<<<<<<<<<<
+ *     cdef crfsuite_api.ItemSequence c_sequence
+ * 
+ */
+struct __pyx_obj_3crf_ItemSequence {
+  PyObject_HEAD
+  CRFSuite::ItemSequence c_sequence;
+};
+
+
+
+/* "crf.pyx":18
+ * 
+ * 
+ * cdef class Trainer:             # <<<<<<<<<<<<<<
+ *     cdef crfsuite_api.Trainer _trainer
+ * 
+ */
+
+struct __pyx_vtabstruct_3crf_Trainer {
+  PyObject *(*_on_message)(struct __pyx_obj_3crf_Trainer *, std::string);
+};
+static struct __pyx_vtabstruct_3crf_Trainer *__pyx_vtabptr_3crf_Trainer;
+
+
+/* "crf.pyx":145
+ * 
+ * 
+ * cdef class Model:             # <<<<<<<<<<<<<<
+ *     cdef crfsuite_api.Tagger _tagger
+ * 
+ */
+
+struct __pyx_vtabstruct_3crf_Model {
+  PyObject *(*set_sequence)(struct __pyx_obj_3crf_Model *, PyObject *, int __pyx_skip_dispatch);
+};
+static struct __pyx_vtabstruct_3crf_Model *__pyx_vtabptr_3crf_Model;
+
+/* --- Runtime support code (head) --- */
+/* Refnanny.proto */
+#ifndef CYTHON_REFNANNY
+  #define CYTHON_REFNANNY 0
+#endif
+#if CYTHON_REFNANNY
+  typedef struct {
+    void (*INCREF)(void*, PyObject*, int);
+    void (*DECREF)(void*, PyObject*, int);
+    void (*GOTREF)(void*, PyObject*, int);
+    void (*GIVEREF)(void*, PyObject*, int);
+    void* (*SetupContext)(const char*, int, const char*);
+    void (*FinishContext)(void**);
+  } __Pyx_RefNannyAPIStruct;
+  static __Pyx_RefNannyAPIStruct *__Pyx_RefNanny = NULL;
+  static __Pyx_RefNannyAPIStruct *__Pyx_RefNannyImportAPI(const char *modname);
+  #define __Pyx_RefNannyDeclarations void *__pyx_refnanny = NULL;
+#ifdef WITH_THREAD
+  #define __Pyx_RefNannySetupContext(name, acquire_gil)\
+          if (acquire_gil) {\
+              PyGILState_STATE __pyx_gilstate_save = PyGILState_Ensure();\
+              __pyx_refnanny = __Pyx_RefNanny->SetupContext((name), __LINE__, __FILE__);\
+              PyGILState_Release(__pyx_gilstate_save);\
+          } else {\
+              __pyx_refnanny = __Pyx_RefNanny->SetupContext((name), __LINE__, __FILE__);\
+          }
+#else
+  #define __Pyx_RefNannySetupContext(name, acquire_gil)\
+          __pyx_refnanny = __Pyx_RefNanny->SetupContext((name), __LINE__, __FILE__)
+#endif
+  #define __Pyx_RefNannyFinishContext()\
+          __Pyx_RefNanny->FinishContext(&__pyx_refnanny)
+  #define __Pyx_INCREF(r)  __Pyx_RefNanny->INCREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
+  #define __Pyx_DECREF(r)  __Pyx_RefNanny->DECREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
+  #define __Pyx_GOTREF(r)  __Pyx_RefNanny->GOTREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
+  #define __Pyx_GIVEREF(r) __Pyx_RefNanny->GIVEREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
+  #define __Pyx_XINCREF(r)  do { if((r) != NULL) {__Pyx_INCREF(r); }} while(0)
+  #define __Pyx_XDECREF(r)  do { if((r) != NULL) {__Pyx_DECREF(r); }} while(0)
+  #define __Pyx_XGOTREF(r)  do { if((r) != NULL) {__Pyx_GOTREF(r); }} while(0)
+  #define __Pyx_XGIVEREF(r) do { if((r) != NULL) {__Pyx_GIVEREF(r);}} while(0)
+#else
+  #define __Pyx_RefNannyDeclarations
+  #define __Pyx_RefNannySetupContext(name, acquire_gil)
+  #define __Pyx_RefNannyFinishContext()
+  #define __Pyx_INCREF(r) Py_INCREF(r)
+  #define __Pyx_DECREF(r) Py_DECREF(r)
+  #define __Pyx_GOTREF(r)
+  #define __Pyx_GIVEREF(r)
+  #define __Pyx_XINCREF(r) Py_XINCREF(r)
+  #define __Pyx_XDECREF(r) Py_XDECREF(r)
+  #define __Pyx_XGOTREF(r)
+  #define __Pyx_XGIVEREF(r)
+#endif
+#define __Pyx_XDECREF_SET(r, v) do {\
+        PyObject *tmp = (PyObject *) r;\
+        r = v; __Pyx_XDECREF(tmp);\
+    } while (0)
+#define __Pyx_DECREF_SET(r, v) do {\
+        PyObject *tmp = (PyObject *) r;\
+        r = v; __Pyx_DECREF(tmp);\
+    } while (0)
+#define __Pyx_CLEAR(r)    do { PyObject* tmp = ((PyObject*)(r)); r = NULL; __Pyx_DECREF(tmp);} while(0)
+#define __Pyx_XCLEAR(r)   do { if((r) != NULL) {PyObject* tmp = ((PyObject*)(r)); r = NULL; __Pyx_DECREF(tmp);}} while(0)
+
+/* PyObjectGetAttrStr.proto */
+#if CYTHON_USE_TYPE_SLOTS
+static CYTHON_INLINE PyObject* __Pyx_PyObject_GetAttrStr(PyObject* obj, PyObject* attr_name);
+#else
+#define __Pyx_PyObject_GetAttrStr(o,n) PyObject_GetAttr(o,n)
+#endif
+
+/* GetBuiltinName.proto */
+static PyObject *__Pyx_GetBuiltinName(PyObject *name);
+
+/* RaiseDoubleKeywords.proto */
+static void __Pyx_RaiseDoubleKeywordsError(const char* func_name, PyObject* kw_name);
+
+/* ParseKeywords.proto */
+static int __Pyx_ParseOptionalKeywords(PyObject *kwds, PyObject **argnames[],\
+    PyObject *kwds2, PyObject *values[], Py_ssize_t num_pos_args,\
+    const char* function_name);
+
+/* RaiseArgTupleInvalid.proto */
+static void __Pyx_RaiseArgtupleInvalid(const char* func_name, int exact,
+    Py_ssize_t num_min, Py_ssize_t num_max, Py_ssize_t num_found);
+
+/* ArgTypeTest.proto */
+#define __Pyx_ArgTypeTest(obj, type, none_allowed, name, exact)\
+    ((likely((Py_TYPE(obj) == type) | (none_allowed && (obj == Py_None)))) ? 1 :\
+        __Pyx__ArgTypeTest(obj, type, name, exact))
+static int __Pyx__ArgTypeTest(PyObject *obj, PyTypeObject *type, const char *name, int exact);
+
+/* PyCFunctionFastCall.proto */
+#if CYTHON_FAST_PYCCALL
+static CYTHON_INLINE PyObject *__Pyx_PyCFunction_FastCall(PyObject *func, PyObject **args, Py_ssize_t nargs);
+#else
+#define __Pyx_PyCFunction_FastCall(func, args, nargs)  (assert(0), NULL)
+#endif
+
+/* PyFunctionFastCall.proto */
+#if CYTHON_FAST_PYCALL
+#define __Pyx_PyFunction_FastCall(func, args, nargs)\
+    __Pyx_PyFunction_FastCallDict((func), (args), (nargs), NULL)
+#if 1 || PY_VERSION_HEX < 0x030600B1
+static PyObject *__Pyx_PyFunction_FastCallDict(PyObject *func, PyObject **args, Py_ssize_t nargs, PyObject *kwargs);
+#else
+#define __Pyx_PyFunction_FastCallDict(func, args, nargs, kwargs) _PyFunction_FastCallDict(func, args, nargs, kwargs)
+#endif
+#define __Pyx_BUILD_ASSERT_EXPR(cond)\
+    (sizeof(char [1 - 2*!(cond)]) - 1)
+#ifndef Py_MEMBER_SIZE
+#define Py_MEMBER_SIZE(type, member) sizeof(((type *)0)->member)
+#endif
+#if CYTHON_FAST_PYCALL
+  static size_t __pyx_pyframe_localsplus_offset = 0;
+  #include "frameobject.h"
+#if PY_VERSION_HEX >= 0x030b00a6
+  #ifndef Py_BUILD_CORE
+    #define Py_BUILD_CORE 1
+  #endif
+  #include "internal/pycore_frame.h"
+#endif
+  #define __Pxy_PyFrame_Initialize_Offsets()\
+    ((void)__Pyx_BUILD_ASSERT_EXPR(sizeof(PyFrameObject) == offsetof(PyFrameObject, f_localsplus) + Py_MEMBER_SIZE(PyFrameObject, f_localsplus)),\
+     (void)(__pyx_pyframe_localsplus_offset = ((size_t)PyFrame_Type.tp_basicsize) - Py_MEMBER_SIZE(PyFrameObject, f_localsplus)))
+  #define __Pyx_PyFrame_GetLocalsplus(frame)\
+    (assert(__pyx_pyframe_localsplus_offset), (PyObject **)(((char *)(frame)) + __pyx_pyframe_localsplus_offset))
+#endif // CYTHON_FAST_PYCALL
+#endif
+
+/* PyObjectCall.proto */
+#if CYTHON_COMPILING_IN_CPYTHON
+static CYTHON_INLINE PyObject* __Pyx_PyObject_Call(PyObject *func, PyObject *arg, PyObject *kw);
+#else
+#define __Pyx_PyObject_Call(func, arg, kw) PyObject_Call(func, arg, kw)
+#endif
+
+/* PyObjectCall2Args.proto */
+static CYTHON_UNUSED PyObject* __Pyx_PyObject_Call2Args(PyObject* function, PyObject* arg1, PyObject* arg2);
+
+/* PyObjectCallMethO.proto */
+#if CYTHON_COMPILING_IN_CPYTHON
+static CYTHON_INLINE PyObject* __Pyx_PyObject_CallMethO(PyObject *func, PyObject *arg);
+#endif
+
+/* PyObjectCallOneArg.proto */
+static CYTHON_INLINE PyObject* __Pyx_PyObject_CallOneArg(PyObject *func, PyObject *arg);
+
+/* KeywordStringCheck.proto */
+static int __Pyx_CheckKeywordStrings(PyObject *kwdict, const char* function_name, int kw_allowed);
+
+/* PyDictVersioning.proto */
+#if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_TYPE_SLOTS
+#define __PYX_DICT_VERSION_INIT  ((PY_UINT64_T) -1)
+#define __PYX_GET_DICT_VERSION(dict)  (((PyDictObject*)(dict))->ma_version_tag)
+#define __PYX_UPDATE_DICT_CACHE(dict, value, cache_var, version_var)\
+    (version_var) = __PYX_GET_DICT_VERSION(dict);\
+    (cache_var) = (value);
+#define __PYX_PY_DICT_LOOKUP_IF_MODIFIED(VAR, DICT, LOOKUP) {\
+    static PY_UINT64_T __pyx_dict_version = 0;\
+    static PyObject *__pyx_dict_cached_value = NULL;\
+    if (likely(__PYX_GET_DICT_VERSION(DICT) == __pyx_dict_version)) {\
+        (VAR) = __pyx_dict_cached_value;\
+    } else {\
+        (VAR) = __pyx_dict_cached_value = (LOOKUP);\
+        __pyx_dict_version = __PYX_GET_DICT_VERSION(DICT);\
+    }\
+}
+static CYTHON_INLINE PY_UINT64_T __Pyx_get_tp_dict_version(PyObject *obj);
+static CYTHON_INLINE PY_UINT64_T __Pyx_get_object_dict_version(PyObject *obj);
+static CYTHON_INLINE int __Pyx_object_dict_version_matches(PyObject* obj, PY_UINT64_T tp_dict_version, PY_UINT64_T obj_dict_version);
+#else
+#define __PYX_GET_DICT_VERSION(dict)  (0)
+#define __PYX_UPDATE_DICT_CACHE(dict, value, cache_var, version_var)
+#define __PYX_PY_DICT_LOOKUP_IF_MODIFIED(VAR, DICT, LOOKUP)  (VAR) = (LOOKUP);
+#endif
+
+/* GetModuleGlobalName.proto */
+#if CYTHON_USE_DICT_VERSIONS
+#define __Pyx_GetModuleGlobalName(var, name)  {\
+    static PY_UINT64_T __pyx_dict_version = 0;\
+    static PyObject *__pyx_dict_cached_value = NULL;\
+    (var) = (likely(__pyx_dict_version == __PYX_GET_DICT_VERSION(__pyx_d))) ?\
+        (likely(__pyx_dict_cached_value) ? __Pyx_NewRef(__pyx_dict_cached_value) : __Pyx_GetBuiltinName(name)) :\
+        __Pyx__GetModuleGlobalName(name, &__pyx_dict_version, &__pyx_dict_cached_value);\
+}
+#define __Pyx_GetModuleGlobalNameUncached(var, name)  {\
+    PY_UINT64_T __pyx_dict_version;\
+    PyObject *__pyx_dict_cached_value;\
+    (var) = __Pyx__GetModuleGlobalName(name, &__pyx_dict_version, &__pyx_dict_cached_value);\
+}
+static PyObject *__Pyx__GetModuleGlobalName(PyObject *name, PY_UINT64_T *dict_version, PyObject **dict_cached_value);
+#else
+#define __Pyx_GetModuleGlobalName(var, name)  (var) = __Pyx__GetModuleGlobalName(name)
+#define __Pyx_GetModuleGlobalNameUncached(var, name)  (var) = __Pyx__GetModuleGlobalName(name)
+static CYTHON_INLINE PyObject *__Pyx__GetModuleGlobalName(PyObject *name);
+#endif
+
+/* ListCompAppend.proto */
+#if CYTHON_USE_PYLIST_INTERNALS && CYTHON_ASSUME_SAFE_MACROS
+static CYTHON_INLINE int __Pyx_ListComp_Append(PyObject* list, PyObject* x) {
+    PyListObject* L = (PyListObject*) list;
+    Py_ssize_t len = Py_SIZE(list);
+    if (likely(L->allocated > len)) {
+        Py_INCREF(x);
+        PyList_SET_ITEM(list, len, x);
+        __Pyx_SET_SIZE(list, len + 1);
+        return 0;
+    }
+    return PyList_Append(list, x);
+}
+#else
+#define __Pyx_ListComp_Append(L,x) PyList_Append(L,x)
+#endif
+
+/* PyObjectCallNoArg.proto */
+#if CYTHON_COMPILING_IN_CPYTHON
+static CYTHON_INLINE PyObject* __Pyx_PyObject_CallNoArg(PyObject *func);
+#else
+#define __Pyx_PyObject_CallNoArg(func) __Pyx_PyObject_Call(func, __pyx_empty_tuple, NULL)
+#endif
+
+/* RaiseTooManyValuesToUnpack.proto */
+static CYTHON_INLINE void __Pyx_RaiseTooManyValuesError(Py_ssize_t expected);
+
+/* RaiseNeedMoreValuesToUnpack.proto */
+static CYTHON_INLINE void __Pyx_RaiseNeedMoreValuesError(Py_ssize_t index);
+
+/* IterFinish.proto */
+static CYTHON_INLINE int __Pyx_IterFinish(void);
+
+/* UnpackItemEndCheck.proto */
+static int __Pyx_IternextUnpackEndCheck(PyObject *retval, Py_ssize_t expected);
+
+/* UnpackUnboundCMethod.proto */
+typedef struct {
+    PyObject *type;
+    PyObject **method_name;
+    PyCFunction func;
+    PyObject *method;
+    int flag;
+} __Pyx_CachedCFunction;
+
+/* CallUnboundCMethod0.proto */
+static PyObject* __Pyx__CallUnboundCMethod0(__Pyx_CachedCFunction* cfunc, PyObject* self);
+#if CYTHON_COMPILING_IN_CPYTHON
+#define __Pyx_CallUnboundCMethod0(cfunc, self)\
+    (likely((cfunc)->func) ?\
+        (likely((cfunc)->flag == METH_NOARGS) ?  (*((cfunc)->func))(self, NULL) :\
+         (PY_VERSION_HEX >= 0x030600B1 && likely((cfunc)->flag == METH_FASTCALL) ?\
+            (PY_VERSION_HEX >= 0x030700A0 ?\
+                (*(__Pyx_PyCFunctionFast)(void*)(PyCFunction)(cfunc)->func)(self, &__pyx_empty_tuple, 0) :\
+                (*(__Pyx_PyCFunctionFastWithKeywords)(void*)(PyCFunction)(cfunc)->func)(self, &__pyx_empty_tuple, 0, NULL)) :\
+          (PY_VERSION_HEX >= 0x030700A0 && (cfunc)->flag == (METH_FASTCALL | METH_KEYWORDS) ?\
+            (*(__Pyx_PyCFunctionFastWithKeywords)(void*)(PyCFunction)(cfunc)->func)(self, &__pyx_empty_tuple, 0, NULL) :\
+            (likely((cfunc)->flag == (METH_VARARGS | METH_KEYWORDS)) ?  ((*(PyCFunctionWithKeywords)(void*)(PyCFunction)(cfunc)->func)(self, __pyx_empty_tuple, NULL)) :\
+               ((cfunc)->flag == METH_VARARGS ?  (*((cfunc)->func))(self, __pyx_empty_tuple) :\
+               __Pyx__CallUnboundCMethod0(cfunc, self)))))) :\
+        __Pyx__CallUnboundCMethod0(cfunc, self))
+#else
+#define __Pyx_CallUnboundCMethod0(cfunc, self)  __Pyx__CallUnboundCMethod0(cfunc, self)
+#endif
+
+/* GetItemInt.proto */
+#define __Pyx_GetItemInt(o, i, type, is_signed, to_py_func, is_list, wraparound, boundscheck)\
+    (__Pyx_fits_Py_ssize_t(i, type, is_signed) ?\
+    __Pyx_GetItemInt_Fast(o, (Py_ssize_t)i, is_list, wraparound, boundscheck) :\
+    (is_list ? (PyErr_SetString(PyExc_IndexError, "list index out of range"), (PyObject*)NULL) :\
+               __Pyx_GetItemInt_Generic(o, to_py_func(i))))
+#define __Pyx_GetItemInt_List(o, i, type, is_signed, to_py_func, is_list, wraparound, boundscheck)\
+    (__Pyx_fits_Py_ssize_t(i, type, is_signed) ?\
+    __Pyx_GetItemInt_List_Fast(o, (Py_ssize_t)i, wraparound, boundscheck) :\
+    (PyErr_SetString(PyExc_IndexError, "list index out of range"), (PyObject*)NULL))
+static CYTHON_INLINE PyObject *__Pyx_GetItemInt_List_Fast(PyObject *o, Py_ssize_t i,
+                                                              int wraparound, int boundscheck);
+#define __Pyx_GetItemInt_Tuple(o, i, type, is_signed, to_py_func, is_list, wraparound, boundscheck)\
+    (__Pyx_fits_Py_ssize_t(i, type, is_signed) ?\
+    __Pyx_GetItemInt_Tuple_Fast(o, (Py_ssize_t)i, wraparound, boundscheck) :\
+    (PyErr_SetString(PyExc_IndexError, "tuple index out of range"), (PyObject*)NULL))
+static CYTHON_INLINE PyObject *__Pyx_GetItemInt_Tuple_Fast(PyObject *o, Py_ssize_t i,
+                                                              int wraparound, int boundscheck);
+static PyObject *__Pyx_GetItemInt_Generic(PyObject *o, PyObject* j);
+static CYTHON_INLINE PyObject *__Pyx_GetItemInt_Fast(PyObject *o, Py_ssize_t i,
+                                                     int is_list, int wraparound, int boundscheck);
+
+/* ObjectGetItem.proto */
+#if CYTHON_USE_TYPE_SLOTS
+static CYTHON_INLINE PyObject *__Pyx_PyObject_GetItem(PyObject *obj, PyObject* key);
+#else
+#define __Pyx_PyObject_GetItem(obj, key)  PyObject_GetItem(obj, key)
+#endif
+
+/* GetTopmostException.proto */
+#if CYTHON_USE_EXC_INFO_STACK
+static _PyErr_StackItem * __Pyx_PyErr_GetTopmostException(PyThreadState *tstate);
+#endif
+
+/* PyThreadStateGet.proto */
+#if CYTHON_FAST_THREAD_STATE
+#define __Pyx_PyThreadState_declare  PyThreadState *__pyx_tstate;
+#define __Pyx_PyThreadState_assign  __pyx_tstate = __Pyx_PyThreadState_Current;
+#define __Pyx_PyErr_Occurred()  __pyx_tstate->curexc_type
+#else
+#define __Pyx_PyThreadState_declare
+#define __Pyx_PyThreadState_assign
+#define __Pyx_PyErr_Occurred()  PyErr_Occurred()
+#endif
+
+/* SaveResetException.proto */
+#if CYTHON_FAST_THREAD_STATE
+#define __Pyx_ExceptionSave(type, value, tb)  __Pyx__ExceptionSave(__pyx_tstate, type, value, tb)
+static CYTHON_INLINE void __Pyx__ExceptionSave(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb);
+#define __Pyx_ExceptionReset(type, value, tb)  __Pyx__ExceptionReset(__pyx_tstate, type, value, tb)
+static CYTHON_INLINE void __Pyx__ExceptionReset(PyThreadState *tstate, PyObject *type, PyObject *value, PyObject *tb);
+#else
+#define __Pyx_ExceptionSave(type, value, tb)   PyErr_GetExcInfo(type, value, tb)
+#define __Pyx_ExceptionReset(type, value, tb)  PyErr_SetExcInfo(type, value, tb)
+#endif
+
+/* GetException.proto */
+#if CYTHON_FAST_THREAD_STATE
+#define __Pyx_GetException(type, value, tb)  __Pyx__GetException(__pyx_tstate, type, value, tb)
+static int __Pyx__GetException(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb);
+#else
+static int __Pyx_GetException(PyObject **type, PyObject **value, PyObject **tb);
+#endif
+
+/* PyObjectFormatSimple.proto */
+#if CYTHON_COMPILING_IN_PYPY
+    #define __Pyx_PyObject_FormatSimple(s, f) (\
+        likely(PyUnicode_CheckExact(s)) ? (Py_INCREF(s), s) :\
+        PyObject_Format(s, f))
+#elif PY_MAJOR_VERSION < 3
+    #define __Pyx_PyObject_FormatSimple(s, f) (\
+        likely(PyUnicode_CheckExact(s)) ? (Py_INCREF(s), s) :\
+        likely(PyString_CheckExact(s)) ? PyUnicode_FromEncodedObject(s, NULL, "strict") :\
+        PyObject_Format(s, f))
+#elif CYTHON_USE_TYPE_SLOTS
+    #define __Pyx_PyObject_FormatSimple(s, f) (\
+        likely(PyUnicode_CheckExact(s)) ? (Py_INCREF(s), s) :\
+        likely(PyLong_CheckExact(s)) ? PyLong_Type.tp_str(s) :\
+        likely(PyFloat_CheckExact(s)) ? PyFloat_Type.tp_str(s) :\
+        PyObject_Format(s, f))
+#else
+    #define __Pyx_PyObject_FormatSimple(s, f) (\
+        likely(PyUnicode_CheckExact(s)) ? (Py_INCREF(s), s) :\
+        PyObject_Format(s, f))
+#endif
+
+/* PyErrFetchRestore.proto */
+#if CYTHON_FAST_THREAD_STATE
+#define __Pyx_PyErr_Clear() __Pyx_ErrRestore(NULL, NULL, NULL)
+#define __Pyx_ErrRestoreWithState(type, value, tb)  __Pyx_ErrRestoreInState(PyThreadState_GET(), type, value, tb)
+#define __Pyx_ErrFetchWithState(type, value, tb)    __Pyx_ErrFetchInState(PyThreadState_GET(), type, value, tb)
+#define __Pyx_ErrRestore(type, value, tb)  __Pyx_ErrRestoreInState(__pyx_tstate, type, value, tb)
+#define __Pyx_ErrFetch(type, value, tb)    __Pyx_ErrFetchInState(__pyx_tstate, type, value, tb)
+static CYTHON_INLINE void __Pyx_ErrRestoreInState(PyThreadState *tstate, PyObject *type, PyObject *value, PyObject *tb);
+static CYTHON_INLINE void __Pyx_ErrFetchInState(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb);
+#if CYTHON_COMPILING_IN_CPYTHON
+#define __Pyx_PyErr_SetNone(exc) (Py_INCREF(exc), __Pyx_ErrRestore((exc), NULL, NULL))
+#else
+#define __Pyx_PyErr_SetNone(exc) PyErr_SetNone(exc)
+#endif
+#else
+#define __Pyx_PyErr_Clear() PyErr_Clear()
+#define __Pyx_PyErr_SetNone(exc) PyErr_SetNone(exc)
+#define __Pyx_ErrRestoreWithState(type, value, tb)  PyErr_Restore(type, value, tb)
+#define __Pyx_ErrFetchWithState(type, value, tb)  PyErr_Fetch(type, value, tb)
+#define __Pyx_ErrRestoreInState(tstate, type, value, tb)  PyErr_Restore(type, value, tb)
+#define __Pyx_ErrFetchInState(tstate, type, value, tb)  PyErr_Fetch(type, value, tb)
+#define __Pyx_ErrRestore(type, value, tb)  PyErr_Restore(type, value, tb)
+#define __Pyx_ErrFetch(type, value, tb)  PyErr_Fetch(type, value, tb)
+#endif
+
+/* RaiseException.proto */
+static void __Pyx_Raise(PyObject *type, PyObject *value, PyObject *tb, PyObject *cause);
+
+/* PySequenceContains.proto */
+static CYTHON_INLINE int __Pyx_PySequence_ContainsTF(PyObject* item, PyObject* seq, int eq) {
+    int result = PySequence_Contains(seq, item);
+    return unlikely(result < 0) ? result : (result == (eq == Py_EQ));
+}
+
+/* DictGetItem.proto */
+#if PY_MAJOR_VERSION >= 3 && !CYTHON_COMPILING_IN_PYPY
+static PyObject *__Pyx_PyDict_GetItem(PyObject *d, PyObject* key);
+#define __Pyx_PyObject_Dict_GetItem(obj, name)\
+    (likely(PyDict_CheckExact(obj)) ?\
+     __Pyx_PyDict_GetItem(obj, name) : PyObject_GetItem(obj, name))
+#else
+#define __Pyx_PyDict_GetItem(d, key) PyObject_GetItem(d, key)
+#define __Pyx_PyObject_Dict_GetItem(obj, name)  PyObject_GetItem(obj, name)
+#endif
+
+/* PyObjectLookupSpecial.proto */
+#if CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
+static CYTHON_INLINE PyObject* __Pyx_PyObject_LookupSpecial(PyObject* obj, PyObject* attr_name) {
+    PyObject *res;
+    PyTypeObject *tp = Py_TYPE(obj);
+#if PY_MAJOR_VERSION < 3
+    if (unlikely(PyInstance_Check(obj)))
+        return __Pyx_PyObject_GetAttrStr(obj, attr_name);
+#endif
+    res = _PyType_Lookup(tp, attr_name);
+    if (likely(res)) {
+        descrgetfunc f = Py_TYPE(res)->tp_descr_get;
+        if (!f) {
+            Py_INCREF(res);
+        } else {
+            res = f(res, obj, (PyObject *)tp);
+        }
+    } else {
+        PyErr_SetObject(PyExc_AttributeError, attr_name);
+    }
+    return res;
+}
+#else
+#define __Pyx_PyObject_LookupSpecial(o,n) __Pyx_PyObject_GetAttrStr(o,n)
+#endif
+
+/* IncludeStringH.proto */
+#include <string.h>
+
+/* BytesEquals.proto */
+static CYTHON_INLINE int __Pyx_PyBytes_Equals(PyObject* s1, PyObject* s2, int equals);
+
+/* JoinPyUnicode.proto */
+static PyObject* __Pyx_PyUnicode_Join(PyObject* value_tuple, Py_ssize_t value_count, Py_ssize_t result_ulength,
+                                      Py_UCS4 max_char);
+
+/* decode_c_string_utf16.proto */
+static CYTHON_INLINE PyObject *__Pyx_PyUnicode_DecodeUTF16(const char *s, Py_ssize_t size, const char *errors) {
+    int byteorder = 0;
+    return PyUnicode_DecodeUTF16(s, size, errors, &byteorder);
+}
+static CYTHON_INLINE PyObject *__Pyx_PyUnicode_DecodeUTF16LE(const char *s, Py_ssize_t size, const char *errors) {
+    int byteorder = -1;
+    return PyUnicode_DecodeUTF16(s, size, errors, &byteorder);
+}
+static CYTHON_INLINE PyObject *__Pyx_PyUnicode_DecodeUTF16BE(const char *s, Py_ssize_t size, const char *errors) {
+    int byteorder = 1;
+    return PyUnicode_DecodeUTF16(s, size, errors, &byteorder);
+}
+
+/* decode_c_bytes.proto */
+static CYTHON_INLINE PyObject* __Pyx_decode_c_bytes(
+         const char* cstring, Py_ssize_t length, Py_ssize_t start, Py_ssize_t stop,
+         const char* encoding, const char* errors,
+         PyObject* (*decode_func)(const char *s, Py_ssize_t size, const char *errors));
+
+/* decode_bytes.proto */
+static CYTHON_INLINE PyObject* __Pyx_decode_bytes(
+         PyObject* string, Py_ssize_t start, Py_ssize_t stop,
+         const char* encoding, const char* errors,
+         PyObject* (*decode_func)(const char *s, Py_ssize_t size, const char *errors)) {
+    return __Pyx_decode_c_bytes(
+        PyBytes_AS_STRING(string), PyBytes_GET_SIZE(string),
+        start, stop, encoding, errors, decode_func);
+}
+
+/* ListAppend.proto */
+#if CYTHON_USE_PYLIST_INTERNALS && CYTHON_ASSUME_SAFE_MACROS
+static CYTHON_INLINE int __Pyx_PyList_Append(PyObject* list, PyObject* x) {
+    PyListObject* L = (PyListObject*) list;
+    Py_ssize_t len = Py_SIZE(list);
+    if (likely(L->allocated > len) & likely(len > (L->allocated >> 1))) {
+        Py_INCREF(x);
+        PyList_SET_ITEM(list, len, x);
+        __Pyx_SET_SIZE(list, len + 1);
+        return 0;
+    }
+    return PyList_Append(list, x);
+}
+#else
+#define __Pyx_PyList_Append(L,x) PyList_Append(L,x)
+#endif
+
+/* GCCDiagnostics.proto */
+#if defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 6))
+#define __Pyx_HAS_GCC_DIAGNOSTIC
+#endif
+
+/* BuildPyUnicode.proto */
+static PyObject* __Pyx_PyUnicode_BuildFromAscii(Py_ssize_t ulength, char* chars, int clength,
+                                                int prepend_sign, char padding_char);
+
+/* CIntToPyUnicode.proto */
+static CYTHON_INLINE PyObject* __Pyx_PyUnicode_From_Py_ssize_t(Py_ssize_t value, Py_ssize_t width, char padding_char, char format_char);
+
+/* PyObject_GenericGetAttrNoDict.proto */
+#if CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP && PY_VERSION_HEX < 0x03070000
+static CYTHON_INLINE PyObject* __Pyx_PyObject_GenericGetAttrNoDict(PyObject* obj, PyObject* attr_name);
+#else
+#define __Pyx_PyObject_GenericGetAttrNoDict PyObject_GenericGetAttr
+#endif
+
+/* PyObject_GenericGetAttr.proto */
+#if CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP && PY_VERSION_HEX < 0x03070000
+static PyObject* __Pyx_PyObject_GenericGetAttr(PyObject* obj, PyObject* attr_name);
+#else
+#define __Pyx_PyObject_GenericGetAttr PyObject_GenericGetAttr
+#endif
+
+/* SetVTable.proto */
+static int __Pyx_SetVtable(PyObject *dict, void *vtable);
+
+/* PyErrExceptionMatches.proto */
+#if CYTHON_FAST_THREAD_STATE
+#define __Pyx_PyErr_ExceptionMatches(err) __Pyx_PyErr_ExceptionMatchesInState(__pyx_tstate, err)
+static CYTHON_INLINE int __Pyx_PyErr_ExceptionMatchesInState(PyThreadState* tstate, PyObject* err);
+#else
+#define __Pyx_PyErr_ExceptionMatches(err)  PyErr_ExceptionMatches(err)
+#endif
+
+/* PyObjectGetAttrStrNoError.proto */
+static CYTHON_INLINE PyObject* __Pyx_PyObject_GetAttrStrNoError(PyObject* obj, PyObject* attr_name);
+
+/* SetupReduce.proto */
+static int __Pyx_setup_reduce(PyObject* type_obj);
+
+/* Import.proto */
+static PyObject *__Pyx_Import(PyObject *name, PyObject *from_list, int level);
+
+/* ImportFrom.proto */
+static PyObject* __Pyx_ImportFrom(PyObject* module, PyObject* name);
+
+/* FetchCommonType.proto */
+static PyTypeObject* __Pyx_FetchCommonType(PyTypeObject* type);
+
+/* CythonFunctionShared.proto */
+#define __Pyx_CyFunction_USED 1
+#define __Pyx_CYFUNCTION_STATICMETHOD  0x01
+#define __Pyx_CYFUNCTION_CLASSMETHOD   0x02
+#define __Pyx_CYFUNCTION_CCLASS        0x04
+#define __Pyx_CyFunction_GetClosure(f)\
+    (((__pyx_CyFunctionObject *) (f))->func_closure)
+#define __Pyx_CyFunction_GetClassObj(f)\
+    (((__pyx_CyFunctionObject *) (f))->func_classobj)
+#define __Pyx_CyFunction_Defaults(type, f)\
+    ((type *)(((__pyx_CyFunctionObject *) (f))->defaults))
+#define __Pyx_CyFunction_SetDefaultsGetter(f, g)\
+    ((__pyx_CyFunctionObject *) (f))->defaults_getter = (g)
+typedef struct {
+    PyCFunctionObject func;
+#if PY_VERSION_HEX < 0x030500A0
+    PyObject *func_weakreflist;
+#endif
+    PyObject *func_dict;
+    PyObject *func_name;
+    PyObject *func_qualname;
+    PyObject *func_doc;
+    PyObject *func_globals;
+    PyObject *func_code;
+    PyObject *func_closure;
+    PyObject *func_classobj;
+    void *defaults;
+    int defaults_pyobjects;
+    size_t defaults_size;  // used by FusedFunction for copying defaults
+    int flags;
+    PyObject *defaults_tuple;
+    PyObject *defaults_kwdict;
+    PyObject *(*defaults_getter)(PyObject *);
+    PyObject *func_annotations;
+} __pyx_CyFunctionObject;
+static PyTypeObject *__pyx_CyFunctionType = 0;
+#define __Pyx_CyFunction_Check(obj)  (__Pyx_TypeCheck(obj, __pyx_CyFunctionType))
+static PyObject *__Pyx_CyFunction_Init(__pyx_CyFunctionObject* op, PyMethodDef *ml,
+                                      int flags, PyObject* qualname,
+                                      PyObject *self,
+                                      PyObject *module, PyObject *globals,
+                                      PyObject* code);
+static CYTHON_INLINE void *__Pyx_CyFunction_InitDefaults(PyObject *m,
+                                                         size_t size,
+                                                         int pyobjects);
+static CYTHON_INLINE void __Pyx_CyFunction_SetDefaultsTuple(PyObject *m,
+                                                            PyObject *tuple);
+static CYTHON_INLINE void __Pyx_CyFunction_SetDefaultsKwDict(PyObject *m,
+                                                             PyObject *dict);
+static CYTHON_INLINE void __Pyx_CyFunction_SetAnnotationsDict(PyObject *m,
+                                                              PyObject *dict);
+static int __pyx_CyFunction_init(void);
+
+/* CythonFunction.proto */
+static PyObject *__Pyx_CyFunction_New(PyMethodDef *ml,
+                                      int flags, PyObject* qualname,
+                                      PyObject *closure,
+                                      PyObject *module, PyObject *globals,
+                                      PyObject* code);
+
+/* GetNameInClass.proto */
+#define __Pyx_GetNameInClass(var, nmspace, name)  (var) = __Pyx__GetNameInClass(nmspace, name)
+static PyObject *__Pyx__GetNameInClass(PyObject *nmspace, PyObject *name);
+
+/* CLineInTraceback.proto */
+#ifdef CYTHON_CLINE_IN_TRACEBACK
+#define __Pyx_CLineForTraceback(tstate, c_line)  (((CYTHON_CLINE_IN_TRACEBACK)) ? c_line : 0)
+#else
+static int __Pyx_CLineForTraceback(PyThreadState *tstate, int c_line);
+#endif
+
+/* CodeObjectCache.proto */
+typedef struct {
+    PyCodeObject* code_object;
+    int code_line;
+} __Pyx_CodeObjectCacheEntry;
+struct __Pyx_CodeObjectCache {
+    int count;
+    int max_count;
+    __Pyx_CodeObjectCacheEntry* entries;
+};
+static struct __Pyx_CodeObjectCache __pyx_code_cache = {0,0,NULL};
+static int __pyx_bisect_code_objects(__Pyx_CodeObjectCacheEntry* entries, int count, int code_line);
+static PyCodeObject *__pyx_find_code_object(int code_line);
+static void __pyx_insert_code_object(int code_line, PyCodeObject* code_object);
+
+/* AddTraceback.proto */
+static void __Pyx_AddTraceback(const char *funcname, int c_line,
+                               int py_line, const char *filename);
+
+/* None.proto */
+#include <new>
+
+/* CppExceptionConversion.proto */
+#ifndef __Pyx_CppExn2PyErr
+#include <new>
+#include <typeinfo>
+#include <stdexcept>
+#include <ios>
+static void __Pyx_CppExn2PyErr() {
+  try {
+    if (PyErr_Occurred())
+      ; // let the latest Python exn pass through and ignore the current one
+    else
+      throw;
+  } catch (const std::bad_alloc& exn) {
+    PyErr_SetString(PyExc_MemoryError, exn.what());
+  } catch (const std::bad_cast& exn) {
+    PyErr_SetString(PyExc_TypeError, exn.what());
+  } catch (const std::bad_typeid& exn) {
+    PyErr_SetString(PyExc_TypeError, exn.what());
+  } catch (const std::domain_error& exn) {
+    PyErr_SetString(PyExc_ValueError, exn.what());
+  } catch (const std::invalid_argument& exn) {
+    PyErr_SetString(PyExc_ValueError, exn.what());
+  } catch (const std::ios_base::failure& exn) {
+    PyErr_SetString(PyExc_IOError, exn.what());
+  } catch (const std::out_of_range& exn) {
+    PyErr_SetString(PyExc_IndexError, exn.what());
+  } catch (const std::overflow_error& exn) {
+    PyErr_SetString(PyExc_OverflowError, exn.what());
+  } catch (const std::range_error& exn) {
+    PyErr_SetString(PyExc_ArithmeticError, exn.what());
+  } catch (const std::underflow_error& exn) {
+    PyErr_SetString(PyExc_ArithmeticError, exn.what());
+  } catch (const std::exception& exn) {
+    PyErr_SetString(PyExc_RuntimeError, exn.what());
+  }
+  catch (...)
+  {
+    PyErr_SetString(PyExc_RuntimeError, "Unknown exception");
+  }
+}
+#endif
+
+/* CIntFromPy.proto */
+static CYTHON_INLINE int __Pyx_PyInt_As_int(PyObject *);
+
+/* CIntFromPy.proto */
+static CYTHON_INLINE size_t __Pyx_PyInt_As_size_t(PyObject *);
+
+/* CIntToPy.proto */
+static CYTHON_INLINE PyObject* __Pyx_PyInt_From_long(long value);
+
+/* CIntFromPy.proto */
+static CYTHON_INLINE long __Pyx_PyInt_As_long(PyObject *);
+
+/* FastTypeChecks.proto */
+#if CYTHON_COMPILING_IN_CPYTHON
+#define __Pyx_TypeCheck(obj, type) __Pyx_IsSubtype(Py_TYPE(obj), (PyTypeObject *)type)
+static CYTHON_INLINE int __Pyx_IsSubtype(PyTypeObject *a, PyTypeObject *b);
+static CYTHON_INLINE int __Pyx_PyErr_GivenExceptionMatches(PyObject *err, PyObject *type);
+static CYTHON_INLINE int __Pyx_PyErr_GivenExceptionMatches2(PyObject *err, PyObject *type1, PyObject *type2);
+#else
+#define __Pyx_TypeCheck(obj, type) PyObject_TypeCheck(obj, (PyTypeObject *)type)
+#define __Pyx_PyErr_GivenExceptionMatches(err, type) PyErr_GivenExceptionMatches(err, type)
+#define __Pyx_PyErr_GivenExceptionMatches2(err, type1, type2) (PyErr_GivenExceptionMatches(err, type1) || PyErr_GivenExceptionMatches(err, type2))
+#endif
+#define __Pyx_PyException_Check(obj) __Pyx_TypeCheck(obj, PyExc_Exception)
+
+/* CheckBinaryVersion.proto */
+static int __Pyx_check_binary_version(void);
+
+/* InitStrings.proto */
+static int __Pyx_InitStrings(__Pyx_StringTabEntry *t);
+
+static PyObject *__pyx_f_3crf_7Trainer__on_message(struct __pyx_obj_3crf_Trainer *__pyx_v_self, std::string __pyx_v_message); /* proto*/
+static PyObject *__pyx_f_3crf_5Model_set_sequence(struct __pyx_obj_3crf_Model *__pyx_v_self, PyObject *__pyx_v_sequence, int __pyx_skip_dispatch); /* proto*/
+
+/* Module declarations from 'libc.string' */
+
+/* Module declarations from 'libcpp.string' */
+
+/* Module declarations from 'libcpp.vector' */
+
+/* Module declarations from 'crfsuite_api' */
+
+/* Module declarations from 'crf' */
+static PyTypeObject *__pyx_ptype_3crf_Trainer = 0;
+static PyTypeObject *__pyx_ptype_3crf_Model = 0;
+static PyTypeObject *__pyx_ptype_3crf_ItemSequence = 0;
+static CRFSuite::Item __pyx_f_3crf_to_item(PyObject *); /*proto*/
+static CRFSuite::ItemSequence __pyx_f_3crf_to_seq(PyObject *); /*proto*/
+static std::string __pyx_convert_string_from_py_std__in_string(PyObject *); /*proto*/
+static CYTHON_INLINE PyObject *__pyx_convert_PyObject_string_to_py_std__in_string(std::string const &); /*proto*/
+static CYTHON_INLINE PyObject *__pyx_convert_PyUnicode_string_to_py_std__in_string(std::string const &); /*proto*/
+static CYTHON_INLINE PyObject *__pyx_convert_PyStr_string_to_py_std__in_string(std::string const &); /*proto*/
+static CYTHON_INLINE PyObject *__pyx_convert_PyBytes_string_to_py_std__in_string(std::string const &); /*proto*/
+static CYTHON_INLINE PyObject *__pyx_convert_PyByteArray_string_to_py_std__in_string(std::string const &); /*proto*/
+static PyObject *__pyx_convert_vector_to_py_std_3a__3a_string(const std::vector<std::string>  &); /*proto*/
+static std::vector<std::string>  __pyx_convert_vector_from_py_std_3a__3a_string(PyObject *); /*proto*/
+#define __Pyx_MODULE_NAME "crf"
+extern int __pyx_module_is_main_crf;
+int __pyx_module_is_main_crf = 0;
+
+/* Implementation of 'crf' */
+static PyObject *__pyx_builtin_staticmethod;
+static PyObject *__pyx_builtin_ValueError;
+static PyObject *__pyx_builtin_TypeError;
+static PyObject *__pyx_builtin_range;
+static PyObject *__pyx_builtin_open;
+static const char __pyx_k_c[] = "c";
+static const char __pyx_k__6[] = ":";
+static const char __pyx_k__7[] = ")>";
+static const char __pyx_k_ap[] = "ap";
+static const char __pyx_k_c1[] = "c1";
+static const char __pyx_k_c2[] = "c2";
+static const char __pyx_k_os[] = "os";
+static const char __pyx_k_pa[] = "pa";
+static const char __pyx_k_rb[] = "rb";
+static const char __pyx_k_crf[] = "crf";
+static const char __pyx_k_get[] = "get";
+static const char __pyx_k_log[] = "_log";
+static const char __pyx_k_sgd[] = "sgd";
+static const char __pyx_k_arow[] = "arow";
+static const char __pyx_k_exit[] = "__exit__";
+static const char __pyx_k_info[] = "info";
+static const char __pyx_k_lCRF[] = "lCRF";
+static const char __pyx_k_load[] = "load";
+static const char __pyx_k_main[] = "__main__";
+static const char __pyx_k_name[] = "__name__";
+static const char __pyx_k_open[] = "open";
+static const char __pyx_k_read[] = "read";
+static const char __pyx_k_seek[] = "seek";
+static const char __pyx_k_tell[] = "tell";
+static const char __pyx_k_test[] = "__test__";
+static const char __pyx_k_type[] = "type";
+static const char __pyx_k_Model[] = "Model";
+static const char __pyx_k_crf1d[] = "crf1d";
+static const char __pyx_k_delta[] = "delta";
+static const char __pyx_k_enter[] = "__enter__";
+static const char __pyx_k_gamma[] = "gamma";
+static const char __pyx_k_group[] = "group";
+static const char __pyx_k_index[] = "index";
+static const char __pyx_k_items[] = "items";
+static const char __pyx_k_l2sgd[] = "l2sgd";
+static const char __pyx_k_label[] = "label";
+static const char __pyx_k_lbfgs[] = "lbfgs";
+static const char __pyx_k_lower[] = "lower";
+static const char __pyx_k_magic[] = "magic";
+static const char __pyx_k_model[] = "model";
+static const char __pyx_k_param[] = "param";
+static const char __pyx_k_range[] = "range";
+static const char __pyx_k_value[] = "value";
+static const char __pyx_k_LOGGER[] = "LOGGER";
+static const char __pyx_k_Labels[] = "Labels";
+static const char __pyx_k_Logger[] = "Logger";
+static const char __pyx_k_import[] = "__import__";
+static const char __pyx_k_labels[] = "labels";
+static const char __pyx_k_period[] = "period";
+static const char __pyx_k_reduce[] = "__reduce__";
+static const char __pyx_k_O_CREAT[] = "O_CREAT";
+static const char __pyx_k_Trainer[] = "Trainer";
+static const char __pyx_k_epsilon[] = "epsilon";
+static const char __pyx_k_pa_type[] = "pa_type";
+static const char __pyx_k_Filepath[] = "Filepath";
+static const char __pyx_k_O_WRONLY[] = "O_WRONLY";
+static const char __pyx_k_SEEK_END[] = "SEEK_END";
+static const char __pyx_k_Sequence[] = "Sequence";
+static const char __pyx_k_filepath[] = "filepath";
+static const char __pyx_k_getstate[] = "__getstate__";
+static const char __pyx_k_marginal[] = "marginal";
+static const char __pyx_k_min_freq[] = "min_freq";
+static const char __pyx_k_sequence[] = "sequence";
+static const char __pyx_k_setstate[] = "__setstate__";
+static const char __pyx_k_variance[] = "variance";
+static const char __pyx_k_TypeError[] = "TypeError";
+static const char __pyx_k_algorithm[] = "algorithm";
+static const char __pyx_k_averaging[] = "averaging";
+static const char __pyx_k_reduce_ex[] = "__reduce_ex__";
+static const char __pyx_k_set_param[] = "set_param";
+static const char __pyx_k_Model_file[] = "Model file ";
+static const char __pyx_k_ValueError[] = "ValueError";
+static const char __pyx_k_linesearch[] = "linesearch";
+static const char __pyx_k_pyx_vtable[] = "__pyx_vtable__";
+static const char __pyx_k_set_params[] = "set_params";
+static const char __pyx_k_check_model[] = "check_model";
+static const char __pyx_k_kwarg2param[] = "kwarg2param";
+static const char __pyx_k_param2kwarg[] = "param2kwarg";
+static const char __pyx_k_ItemSequence[] = "<ItemSequence (";
+static const char __pyx_k_num_memories[] = "num_memories";
+static const char __pyx_k_set_sequence[] = "set_sequence";
+static const char __pyx_k_staticmethod[] = "staticmethod";
+static const char __pyx_k_chaine_typing[] = "chaine.typing";
+static const char __pyx_k_reduce_cython[] = "__reduce_cython__";
+static const char __pyx_k_ItemSequence_2[] = "ItemSequence";
+static const char __pyx_k_Trainer_lambda[] = "Trainer.<lambda>";
+static const char __pyx_k_cast_parameter[] = "cast_parameter";
+static const char __pyx_k_chaine_logging[] = "chaine.logging";
+static const char __pyx_k_max_iterations[] = "max_iterations";
+static const char __pyx_k_max_linesearch[] = "max_linesearch";
+static const char __pyx_k_model_filepath[] = "model_filepath";
+static const char __pyx_k_calibration_eta[] = "calibration.eta";
+static const char __pyx_k_error_sensitive[] = "error_sensitive";
+static const char __pyx_k_feature_minfreq[] = "feature.minfreq";
+static const char __pyx_k_parameter_types[] = "_parameter_types";
+static const char __pyx_k_setstate_cython[] = "__setstate_cython__";
+static const char __pyx_k_calibration_rate[] = "calibration.rate";
+static const char __pyx_k_select_algorithm[] = "select_algorithm";
+static const char __pyx_k_translate_params[] = "translate_params";
+static const char __pyx_k_algorithm_aliases[] = "_algorithm_aliases";
+static const char __pyx_k_calibration_eta_2[] = "calibration_eta";
+static const char __pyx_k_Invalid_model_file[] = "Invalid model file ";
+static const char __pyx_k_calibration_rate_2[] = "calibration_rate";
+static const char __pyx_k_cline_in_traceback[] = "cline_in_traceback";
+static const char __pyx_k_passive_aggressive[] = "passive-aggressive";
+static const char __pyx_k_all_possible_states[] = "all_possible_states";
+static const char __pyx_k_averaged_perceptron[] = "averaged-perceptron";
+static const char __pyx_k_calibration_samples[] = "calibration.samples";
+static const char __pyx_k_limited_memory_bfgs[] = "limited-memory-bfgs";
+static const char __pyx_k_chaine__core_crf_pyx[] = "chaine/_core/crf.pyx";
+static const char __pyx_k_calibration_samples_2[] = "calibration_samples";
+static const char __pyx_k_Cannot_load_model_file[] = "Cannot load model file ";
+static const char __pyx_k_calibration_candidates[] = "calibration.candidates";
+static const char __pyx_k_calibration_max_trials[] = "calibration.max_trials";
+static const char __pyx_k_feature_possible_states[] = "feature.possible_states";
+static const char __pyx_k_all_possible_transitions[] = "all_possible_transitions";
+static const char __pyx_k_calibration_candidates_2[] = "calibration_candidates";
+static const char __pyx_k_calibration_max_trials_2[] = "calibration_max_trials";
+static const char __pyx_k_is_no_available_algorithm[] = " is no available algorithm";
+static const char __pyx_k_stochastic_gradient_descent[] = "stochastic-gradient-descent";
+static const char __pyx_k_feature_possible_transitions[] = "feature.possible_transitions";
+static const char __pyx_k_does_not_have_a_complete_header[] = " does not have a complete header";
+static const char __pyx_k_no_default___reduce___due_to_non[] = "no default __reduce__ due to non-trivial __cinit__";
+static const char __pyx_k_self__tagger_cannot_be_converted[] = "self._tagger cannot be converted to a Python object for pickling";
+static const char __pyx_k_self_c_sequence_cannot_be_conver[] = "self.c_sequence cannot be converted to a Python object for pickling";
+static PyObject *__pyx_kp_u_Cannot_load_model_file;
+static PyObject *__pyx_n_s_Filepath;
+static PyObject *__pyx_kp_u_Invalid_model_file;
+static PyObject *__pyx_kp_u_ItemSequence;
+static PyObject *__pyx_n_s_ItemSequence_2;
+static PyObject *__pyx_n_s_LOGGER;
+static PyObject *__pyx_n_s_Labels;
+static PyObject *__pyx_n_s_Logger;
+static PyObject *__pyx_n_s_Model;
+static PyObject *__pyx_kp_u_Model_file;
+static PyObject *__pyx_n_s_O_CREAT;
+static PyObject *__pyx_n_s_O_WRONLY;
+static PyObject *__pyx_n_s_SEEK_END;
+static PyObject *__pyx_n_s_Sequence;
+static PyObject *__pyx_n_s_Trainer;
+static PyObject *__pyx_n_s_Trainer_lambda;
+static PyObject *__pyx_n_s_TypeError;
+static PyObject *__pyx_n_s_ValueError;
+static PyObject *__pyx_kp_b__6;
+static PyObject *__pyx_kp_u__7;
+static PyObject *__pyx_n_s_algorithm;
+static PyObject *__pyx_n_s_algorithm_aliases;
+static PyObject *__pyx_n_s_all_possible_states;
+static PyObject *__pyx_n_s_all_possible_transitions;
+static PyObject *__pyx_n_s_ap;
+static PyObject *__pyx_n_s_arow;
+static PyObject *__pyx_kp_s_averaged_perceptron;
+static PyObject *__pyx_n_s_averaging;
+static PyObject *__pyx_n_s_c;
+static PyObject *__pyx_n_s_c1;
+static PyObject *__pyx_n_s_c2;
+static PyObject *__pyx_kp_s_calibration_candidates;
+static PyObject *__pyx_n_s_calibration_candidates_2;
+static PyObject *__pyx_kp_s_calibration_eta;
+static PyObject *__pyx_n_s_calibration_eta_2;
+static PyObject *__pyx_kp_s_calibration_max_trials;
+static PyObject *__pyx_n_s_calibration_max_trials_2;
+static PyObject *__pyx_kp_s_calibration_rate;
+static PyObject *__pyx_n_s_calibration_rate_2;
+static PyObject *__pyx_kp_s_calibration_samples;
+static PyObject *__pyx_n_s_calibration_samples_2;
+static PyObject *__pyx_n_s_cast_parameter;
+static PyObject *__pyx_kp_s_chaine__core_crf_pyx;
+static PyObject *__pyx_n_s_chaine_logging;
+static PyObject *__pyx_n_s_chaine_typing;
+static PyObject *__pyx_n_s_check_model;
+static PyObject *__pyx_n_s_cline_in_traceback;
+static PyObject *__pyx_n_s_crf;
+static PyObject *__pyx_n_b_crf1d;
+static PyObject *__pyx_n_s_delta;
+static PyObject *__pyx_kp_u_does_not_have_a_complete_header;
+static PyObject *__pyx_n_s_enter;
+static PyObject *__pyx_n_s_epsilon;
+static PyObject *__pyx_n_s_error_sensitive;
+static PyObject *__pyx_n_s_exit;
+static PyObject *__pyx_kp_s_feature_minfreq;
+static PyObject *__pyx_kp_s_feature_possible_states;
+static PyObject *__pyx_kp_s_feature_possible_transitions;
+static PyObject *__pyx_n_s_filepath;
+static PyObject *__pyx_n_s_gamma;
+static PyObject *__pyx_n_s_get;
+static PyObject *__pyx_n_s_getstate;
+static PyObject *__pyx_n_s_group;
+static PyObject *__pyx_n_s_import;
+static PyObject *__pyx_n_s_index;
+static PyObject *__pyx_n_s_info;
+static PyObject *__pyx_kp_u_is_no_available_algorithm;
+static PyObject *__pyx_n_s_items;
+static PyObject *__pyx_n_s_kwarg2param;
+static PyObject *__pyx_n_b_l2sgd;
+static PyObject *__pyx_n_s_l2sgd;
+static PyObject *__pyx_n_b_lCRF;
+static PyObject *__pyx_n_s_label;
+static PyObject *__pyx_n_s_labels;
+static PyObject *__pyx_n_s_lbfgs;
+static PyObject *__pyx_kp_s_limited_memory_bfgs;
+static PyObject *__pyx_n_s_linesearch;
+static PyObject *__pyx_n_s_load;
+static PyObject *__pyx_n_s_log;
+static PyObject *__pyx_n_s_lower;
+static PyObject *__pyx_n_s_magic;
+static PyObject *__pyx_n_s_main;
+static PyObject *__pyx_n_s_marginal;
+static PyObject *__pyx_n_s_max_iterations;
+static PyObject *__pyx_n_s_max_linesearch;
+static PyObject *__pyx_n_s_min_freq;
+static PyObject *__pyx_n_s_model;
+static PyObject *__pyx_n_s_model_filepath;
+static PyObject *__pyx_n_s_name;
+static PyObject *__pyx_kp_s_no_default___reduce___due_to_non;
+static PyObject *__pyx_n_s_num_memories;
+static PyObject *__pyx_n_s_open;
+static PyObject *__pyx_n_s_os;
+static PyObject *__pyx_n_s_pa;
+static PyObject *__pyx_n_s_pa_type;
+static PyObject *__pyx_n_s_param;
+static PyObject *__pyx_n_s_param2kwarg;
+static PyObject *__pyx_n_s_parameter_types;
+static PyObject *__pyx_kp_s_passive_aggressive;
+static PyObject *__pyx_n_s_period;
+static PyObject *__pyx_n_s_pyx_vtable;
+static PyObject *__pyx_n_s_range;
+static PyObject *__pyx_n_s_rb;
+static PyObject *__pyx_n_s_read;
+static PyObject *__pyx_n_s_reduce;
+static PyObject *__pyx_n_s_reduce_cython;
+static PyObject *__pyx_n_s_reduce_ex;
+static PyObject *__pyx_n_s_seek;
+static PyObject *__pyx_n_s_select_algorithm;
+static PyObject *__pyx_kp_s_self__tagger_cannot_be_converted;
+static PyObject *__pyx_kp_s_self_c_sequence_cannot_be_conver;
+static PyObject *__pyx_n_s_sequence;
+static PyObject *__pyx_n_s_set_param;
+static PyObject *__pyx_n_s_set_params;
+static PyObject *__pyx_n_s_set_sequence;
+static PyObject *__pyx_n_s_setstate;
+static PyObject *__pyx_n_s_setstate_cython;
+static PyObject *__pyx_n_s_sgd;
+static PyObject *__pyx_n_s_staticmethod;
+static PyObject *__pyx_kp_s_stochastic_gradient_descent;
+static PyObject *__pyx_n_s_tell;
+static PyObject *__pyx_n_s_test;
+static PyObject *__pyx_n_s_translate_params;
+static PyObject *__pyx_n_s_type;
+static PyObject *__pyx_n_s_value;
+static PyObject *__pyx_n_s_variance;
+static PyObject *__pyx_lambda_funcdef_3crf_7Trainer_lambda(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_value); /* proto */
+static PyObject *__pyx_lambda_funcdef_3crf_7Trainer_lambda1(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_value); /* proto */
+static PyObject *__pyx_lambda_funcdef_3crf_7Trainer_lambda2(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_value); /* proto */
+static PyObject *__pyx_lambda_funcdef_3crf_7Trainer_lambda3(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_value); /* proto */
+static int __pyx_pf_3crf_7Trainer___init__(struct __pyx_obj_3crf_Trainer *__pyx_v_self, PyObject *__pyx_v_algorithm, PyObject *__pyx_v_kwargs); /* proto */
+static int __pyx_pf_3crf_7Trainer_2__cinit__(struct __pyx_obj_3crf_Trainer *__pyx_v_self); /* proto */
+static PyObject *__pyx_pf_3crf_7Trainer_6params___get__(struct __pyx_obj_3crf_Trainer *__pyx_v_self); /* proto */
+static PyObject *__pyx_pf_3crf_7Trainer_4train(struct __pyx_obj_3crf_Trainer *__pyx_v_self, PyObject *__pyx_v_model_filepath); /* proto */
+static PyObject *__pyx_pf_3crf_7Trainer_6_log(CYTHON_UNUSED struct __pyx_obj_3crf_Trainer *__pyx_v_self, PyObject *__pyx_v_message); /* proto */
+static PyObject *__pyx_pf_3crf_7Trainer_8append(struct __pyx_obj_3crf_Trainer *__pyx_v_self, PyObject *__pyx_v_sequence, PyObject *__pyx_v_labels, int __pyx_v_group); /* proto */
+static PyObject *__pyx_pf_3crf_7Trainer_10translate_params(struct __pyx_obj_3crf_Trainer *__pyx_v_self, PyObject *__pyx_v_kwargs); /* proto */
+static PyObject *__pyx_pf_3crf_7Trainer_12select_algorithm(struct __pyx_obj_3crf_Trainer *__pyx_v_self, PyObject *__pyx_v_algorithm); /* proto */
+static PyObject *__pyx_pf_3crf_7Trainer_14set_params(struct __pyx_obj_3crf_Trainer *__pyx_v_self, PyObject *__pyx_v_params); /* proto */
+static PyObject *__pyx_pf_3crf_7Trainer_16set_param(struct __pyx_obj_3crf_Trainer *__pyx_v_self, PyObject *__pyx_v_param, PyObject *__pyx_v_value); /* proto */
+static PyObject *__pyx_pf_3crf_7Trainer_18get_param(struct __pyx_obj_3crf_Trainer *__pyx_v_self, PyObject *__pyx_v_param); /* proto */
+static PyObject *__pyx_pf_3crf_7Trainer_20cast_parameter(struct __pyx_obj_3crf_Trainer *__pyx_v_self, PyObject *__pyx_v_param, PyObject *__pyx_v_value); /* proto */
+static PyObject *__pyx_pf_3crf_7Trainer_26__reduce_cython__(CYTHON_UNUSED struct __pyx_obj_3crf_Trainer *__pyx_v_self); /* proto */
+static PyObject *__pyx_pf_3crf_7Trainer_28__setstate_cython__(CYTHON_UNUSED struct __pyx_obj_3crf_Trainer *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v___pyx_state); /* proto */
+static int __pyx_pf_3crf_5Model___init__(struct __pyx_obj_3crf_Model *__pyx_v_self, PyObject *__pyx_v_model_filepath); /* proto */
+static PyObject *__pyx_pf_3crf_5Model_6labels___get__(struct __pyx_obj_3crf_Model *__pyx_v_self); /* proto */
+static PyObject *__pyx_pf_3crf_5Model_2predict_single(struct __pyx_obj_3crf_Model *__pyx_v_self, PyObject *__pyx_v_sequence); /* proto */
+static PyObject *__pyx_pf_3crf_5Model_4predict_proba_single(struct __pyx_obj_3crf_Model *__pyx_v_self, PyObject *__pyx_v_sequence); /* proto */
+static PyObject *__pyx_pf_3crf_5Model_6load(struct __pyx_obj_3crf_Model *__pyx_v_self, PyObject *__pyx_v_filepath); /* proto */
+static PyObject *__pyx_pf_3crf_5Model_8marginal(struct __pyx_obj_3crf_Model *__pyx_v_self, PyObject *__pyx_v_label, PyObject *__pyx_v_index); /* proto */
+static PyObject *__pyx_pf_3crf_5Model_10set_sequence(struct __pyx_obj_3crf_Model *__pyx_v_self, PyObject *__pyx_v_sequence); /* proto */
+static PyObject *__pyx_pf_3crf_5Model_12check_model(PyObject *__pyx_v_filepath); /* proto */
+static PyObject *__pyx_pf_3crf_5Model_14dump_transitions(struct __pyx_obj_3crf_Model *__pyx_v_self, PyObject *__pyx_v_filepath); /* proto */
+static PyObject *__pyx_pf_3crf_5Model_16dump_states(struct __pyx_obj_3crf_Model *__pyx_v_self, PyObject *__pyx_v_filepath); /* proto */
+static PyObject *__pyx_pf_3crf_5Model_18__reduce_cython__(CYTHON_UNUSED struct __pyx_obj_3crf_Model *__pyx_v_self); /* proto */
+static PyObject *__pyx_pf_3crf_5Model_20__setstate_cython__(CYTHON_UNUSED struct __pyx_obj_3crf_Model *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v___pyx_state); /* proto */
+static int __pyx_pf_3crf_12ItemSequence___init__(struct __pyx_obj_3crf_ItemSequence *__pyx_v_self, PyObject *__pyx_v_sequence); /* proto */
+static PyObject *__pyx_pf_3crf_12ItemSequence_2items(struct __pyx_obj_3crf_ItemSequence *__pyx_v_self); /* proto */
+static Py_ssize_t __pyx_pf_3crf_12ItemSequence_4__len__(struct __pyx_obj_3crf_ItemSequence *__pyx_v_self); /* proto */
+static PyObject *__pyx_pf_3crf_12ItemSequence_6__repr__(struct __pyx_obj_3crf_ItemSequence *__pyx_v_self); /* proto */
+static PyObject *__pyx_pf_3crf_12ItemSequence_8__reduce_cython__(CYTHON_UNUSED struct __pyx_obj_3crf_ItemSequence *__pyx_v_self); /* proto */
+static PyObject *__pyx_pf_3crf_12ItemSequence_10__setstate_cython__(CYTHON_UNUSED struct __pyx_obj_3crf_ItemSequence *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v___pyx_state); /* proto */
+static PyObject *__pyx_tp_new_3crf_Trainer(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
+static PyObject *__pyx_tp_new_3crf_Model(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
+static PyObject *__pyx_tp_new_3crf_ItemSequence(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
+static __Pyx_CachedCFunction __pyx_umethod_PyString_Type_lower = {0, &__pyx_n_s_lower, 0, 0, 0};
+static PyObject *__pyx_int_0;
+static PyObject *__pyx_int_4;
+static PyObject *__pyx_int_48;
+static PyObject *__pyx_tuple_;
+static PyObject *__pyx_tuple__2;
+static PyObject *__pyx_tuple__3;
+static PyObject *__pyx_tuple__4;
+static PyObject *__pyx_tuple__5;
+static PyObject *__pyx_tuple__8;
+static PyObject *__pyx_tuple__9;
+static PyObject *__pyx_tuple__10;
+static PyObject *__pyx_codeobj__11;
+/* Late includes */
+
+/* "crf.pyx":57
+ *     _parameter_types = {
+ *             "feature.minfreq": float,
+ *             "feature.possible_states": lambda value: bool(int(value)),             # <<<<<<<<<<<<<<
+ *             "feature.possible_transitions": lambda value: bool(int(value)),
+ *             "c1": float,
+ */
+
+/* Python wrapper */
+static PyObject *__pyx_pw_3crf_7Trainer_22lambda(PyObject *__pyx_self, PyObject *__pyx_v_value); /*proto*/
+static PyMethodDef __pyx_mdef_3crf_7Trainer_22lambda = {"lambda", (PyCFunction)__pyx_pw_3crf_7Trainer_22lambda, METH_O, 0};
+static PyObject *__pyx_pw_3crf_7Trainer_22lambda(PyObject *__pyx_self, PyObject *__pyx_v_value) {
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("lambda (wrapper)", 0);
+  __pyx_r = __pyx_lambda_funcdef_3crf_7Trainer_lambda(__pyx_self, ((PyObject *)__pyx_v_value));
+
+  /* function exit code */
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+static PyObject *__pyx_lambda_funcdef_3crf_7Trainer_lambda(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_value) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  int __pyx_t_2;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("lambda", 0);
+  __Pyx_XDECREF(__pyx_r);
+  __pyx_t_1 = __Pyx_PyNumber_Int(__pyx_v_value); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 57, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 57, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __pyx_t_1 = __Pyx_PyBool_FromLong((!(!__pyx_t_2))); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 57, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_r = __pyx_t_1;
+  __pyx_t_1 = 0;
+  goto __pyx_L0;
+
+  /* function exit code */
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_AddTraceback("crf.Trainer.lambda", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "crf.pyx":58
+ *             "feature.minfreq": float,
+ *             "feature.possible_states": lambda value: bool(int(value)),
+ *             "feature.possible_transitions": lambda value: bool(int(value)),             # <<<<<<<<<<<<<<
+ *             "c1": float,
+ *             "c2": float,
+ */
+
+/* Python wrapper */
+static PyObject *__pyx_pw_3crf_7Trainer_23lambda1(PyObject *__pyx_self, PyObject *__pyx_v_value); /*proto*/
+static PyMethodDef __pyx_mdef_3crf_7Trainer_23lambda1 = {"lambda1", (PyCFunction)__pyx_pw_3crf_7Trainer_23lambda1, METH_O, 0};
+static PyObject *__pyx_pw_3crf_7Trainer_23lambda1(PyObject *__pyx_self, PyObject *__pyx_v_value) {
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("lambda1 (wrapper)", 0);
+  __pyx_r = __pyx_lambda_funcdef_3crf_7Trainer_lambda1(__pyx_self, ((PyObject *)__pyx_v_value));
+
+  /* function exit code */
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+static PyObject *__pyx_lambda_funcdef_3crf_7Trainer_lambda1(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_value) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  int __pyx_t_2;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("lambda1", 0);
+  __Pyx_XDECREF(__pyx_r);
+  __pyx_t_1 = __Pyx_PyNumber_Int(__pyx_v_value); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 58, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 58, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __pyx_t_1 = __Pyx_PyBool_FromLong((!(!__pyx_t_2))); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 58, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_r = __pyx_t_1;
+  __pyx_t_1 = 0;
+  goto __pyx_L0;
+
+  /* function exit code */
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_AddTraceback("crf.Trainer.lambda1", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "crf.pyx":75
+ *             "type": int,
+ *             "c": float,
+ *             "error_sensitive": lambda value: bool(int(value)),             # <<<<<<<<<<<<<<
+ *             "averaging": lambda value: bool(int(value)),
+ *             "variance": float,
+ */
+
+/* Python wrapper */
+static PyObject *__pyx_pw_3crf_7Trainer_24lambda2(PyObject *__pyx_self, PyObject *__pyx_v_value); /*proto*/
+static PyMethodDef __pyx_mdef_3crf_7Trainer_24lambda2 = {"lambda2", (PyCFunction)__pyx_pw_3crf_7Trainer_24lambda2, METH_O, 0};
+static PyObject *__pyx_pw_3crf_7Trainer_24lambda2(PyObject *__pyx_self, PyObject *__pyx_v_value) {
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("lambda2 (wrapper)", 0);
+  __pyx_r = __pyx_lambda_funcdef_3crf_7Trainer_lambda2(__pyx_self, ((PyObject *)__pyx_v_value));
+
+  /* function exit code */
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+static PyObject *__pyx_lambda_funcdef_3crf_7Trainer_lambda2(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_value) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  int __pyx_t_2;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("lambda2", 0);
+  __Pyx_XDECREF(__pyx_r);
+  __pyx_t_1 = __Pyx_PyNumber_Int(__pyx_v_value); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 75, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 75, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __pyx_t_1 = __Pyx_PyBool_FromLong((!(!__pyx_t_2))); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 75, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_r = __pyx_t_1;
+  __pyx_t_1 = 0;
+  goto __pyx_L0;
+
+  /* function exit code */
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_AddTraceback("crf.Trainer.lambda2", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "crf.pyx":76
+ *             "c": float,
+ *             "error_sensitive": lambda value: bool(int(value)),
+ *             "averaging": lambda value: bool(int(value)),             # <<<<<<<<<<<<<<
+ *             "variance": float,
+ *             "gamma": float,
+ */
+
+/* Python wrapper */
+static PyObject *__pyx_pw_3crf_7Trainer_25lambda3(PyObject *__pyx_self, PyObject *__pyx_v_value); /*proto*/
+static PyMethodDef __pyx_mdef_3crf_7Trainer_25lambda3 = {"lambda3", (PyCFunction)__pyx_pw_3crf_7Trainer_25lambda3, METH_O, 0};
+static PyObject *__pyx_pw_3crf_7Trainer_25lambda3(PyObject *__pyx_self, PyObject *__pyx_v_value) {
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("lambda3 (wrapper)", 0);
+  __pyx_r = __pyx_lambda_funcdef_3crf_7Trainer_lambda3(__pyx_self, ((PyObject *)__pyx_v_value));
+
+  /* function exit code */
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+static PyObject *__pyx_lambda_funcdef_3crf_7Trainer_lambda3(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_value) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  int __pyx_t_2;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("lambda3", 0);
+  __Pyx_XDECREF(__pyx_r);
+  __pyx_t_1 = __Pyx_PyNumber_Int(__pyx_v_value); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 76, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 76, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __pyx_t_1 = __Pyx_PyBool_FromLong((!(!__pyx_t_2))); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 76, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_r = __pyx_t_1;
+  __pyx_t_1 = 0;
+  goto __pyx_L0;
+
+  /* function exit code */
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_AddTraceback("crf.Trainer.lambda3", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "crf.pyx":81
+ *         }
+ * 
+ *     def __init__(self, algorithm: str, **kwargs):             # <<<<<<<<<<<<<<
+ *         self.select_algorithm(algorithm)
+ *         self.set_params(self.translate_params(kwargs))
+ */
+
+/* Python wrapper */
+static int __pyx_pw_3crf_7Trainer_1__init__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
+static int __pyx_pw_3crf_7Trainer_1__init__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
+  PyObject *__pyx_v_algorithm = 0;
+  PyObject *__pyx_v_kwargs = 0;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("__init__ (wrapper)", 0);
+  __pyx_v_kwargs = PyDict_New(); if (unlikely(!__pyx_v_kwargs)) return -1;
+  __Pyx_GOTREF(__pyx_v_kwargs);
+  {
+    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_algorithm,0};
+    PyObject* values[1] = {0};
+    if (unlikely(__pyx_kwds)) {
+      Py_ssize_t kw_args;
+      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
+      switch (pos_args) {
+        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
+        CYTHON_FALLTHROUGH;
+        case  0: break;
+        default: goto __pyx_L5_argtuple_error;
+      }
+      kw_args = PyDict_Size(__pyx_kwds);
+      switch (pos_args) {
+        case  0:
+        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_algorithm)) != 0)) kw_args--;
+        else goto __pyx_L5_argtuple_error;
+      }
+      if (unlikely(kw_args > 0)) {
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, __pyx_v_kwargs, values, pos_args, "__init__") < 0)) __PYX_ERR(0, 81, __pyx_L3_error)
+      }
+    } else if (PyTuple_GET_SIZE(__pyx_args) != 1) {
+      goto __pyx_L5_argtuple_error;
+    } else {
+      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
+    }
+    __pyx_v_algorithm = ((PyObject*)values[0]);
+  }
+  goto __pyx_L4_argument_unpacking_done;
+  __pyx_L5_argtuple_error:;
+  __Pyx_RaiseArgtupleInvalid("__init__", 1, 1, 1, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 81, __pyx_L3_error)
+  __pyx_L3_error:;
+  __Pyx_DECREF(__pyx_v_kwargs); __pyx_v_kwargs = 0;
+  __Pyx_AddTraceback("crf.Trainer.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_RefNannyFinishContext();
+  return -1;
+  __pyx_L4_argument_unpacking_done:;
+  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_algorithm), (&PyString_Type), 1, "algorithm", 1))) __PYX_ERR(0, 81, __pyx_L1_error)
+  __pyx_r = __pyx_pf_3crf_7Trainer___init__(((struct __pyx_obj_3crf_Trainer *)__pyx_v_self), __pyx_v_algorithm, __pyx_v_kwargs);
+
+  /* function exit code */
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __pyx_r = -1;
+  __pyx_L0:;
+  __Pyx_XDECREF(__pyx_v_kwargs);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+static int __pyx_pf_3crf_7Trainer___init__(struct __pyx_obj_3crf_Trainer *__pyx_v_self, PyObject *__pyx_v_algorithm, PyObject *__pyx_v_kwargs) {
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  PyObject *__pyx_t_2 = NULL;
+  PyObject *__pyx_t_3 = NULL;
+  PyObject *__pyx_t_4 = NULL;
+  PyObject *__pyx_t_5 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("__init__", 0);
+
+  /* "crf.pyx":82
+ * 
+ *     def __init__(self, algorithm: str, **kwargs):
+ *         self.select_algorithm(algorithm)             # <<<<<<<<<<<<<<
+ *         self.set_params(self.translate_params(kwargs))
+ * 
+ */
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_select_algorithm); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 82, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  __pyx_t_3 = NULL;
+  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
+    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
+    if (likely(__pyx_t_3)) {
+      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
+      __Pyx_INCREF(__pyx_t_3);
+      __Pyx_INCREF(function);
+      __Pyx_DECREF_SET(__pyx_t_2, function);
+    }
+  }
+  __pyx_t_1 = (__pyx_t_3) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_3, __pyx_v_algorithm) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_v_algorithm);
+  __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
+  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 82, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "crf.pyx":83
+ *     def __init__(self, algorithm: str, **kwargs):
+ *         self.select_algorithm(algorithm)
+ *         self.set_params(self.translate_params(kwargs))             # <<<<<<<<<<<<<<
+ * 
+ *     def __cinit__(self):
+ */
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_set_params); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 83, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_translate_params); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 83, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_4);
+  __pyx_t_5 = NULL;
+  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_4))) {
+    __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_4);
+    if (likely(__pyx_t_5)) {
+      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
+      __Pyx_INCREF(__pyx_t_5);
+      __Pyx_INCREF(function);
+      __Pyx_DECREF_SET(__pyx_t_4, function);
+    }
+  }
+  __pyx_t_3 = (__pyx_t_5) ? __Pyx_PyObject_Call2Args(__pyx_t_4, __pyx_t_5, __pyx_v_kwargs) : __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_v_kwargs);
+  __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
+  if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 83, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_3);
+  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+  __pyx_t_4 = NULL;
+  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
+    __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_2);
+    if (likely(__pyx_t_4)) {
+      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
+      __Pyx_INCREF(__pyx_t_4);
+      __Pyx_INCREF(function);
+      __Pyx_DECREF_SET(__pyx_t_2, function);
+    }
+  }
+  __pyx_t_1 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_4, __pyx_t_3) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_3);
+  __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 83, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "crf.pyx":81
+ *         }
+ * 
+ *     def __init__(self, algorithm: str, **kwargs):             # <<<<<<<<<<<<<<
+ *         self.select_algorithm(algorithm)
+ *         self.set_params(self.translate_params(kwargs))
+ */
+
+  /* function exit code */
+  __pyx_r = 0;
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_XDECREF(__pyx_t_2);
+  __Pyx_XDECREF(__pyx_t_3);
+  __Pyx_XDECREF(__pyx_t_4);
+  __Pyx_XDECREF(__pyx_t_5);
+  __Pyx_AddTraceback("crf.Trainer.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = -1;
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "crf.pyx":85
+ *         self.set_params(self.translate_params(kwargs))
+ * 
+ *     def __cinit__(self):             # <<<<<<<<<<<<<<
+ *         self._trainer.set_handler(self, <crfsuite_api.messagefunc>self._on_message)
+ *         self._trainer.select("l2sgd", "crf1d")
+ */
+
+/* Python wrapper */
+static int __pyx_pw_3crf_7Trainer_3__cinit__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
+static int __pyx_pw_3crf_7Trainer_3__cinit__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("__cinit__ (wrapper)", 0);
+  if (unlikely(PyTuple_GET_SIZE(__pyx_args) > 0)) {
+    __Pyx_RaiseArgtupleInvalid("__cinit__", 1, 0, 0, PyTuple_GET_SIZE(__pyx_args)); return -1;}
+  if (unlikely(__pyx_kwds) && unlikely(PyDict_Size(__pyx_kwds) > 0) && unlikely(!__Pyx_CheckKeywordStrings(__pyx_kwds, "__cinit__", 0))) return -1;
+  __pyx_r = __pyx_pf_3crf_7Trainer_2__cinit__(((struct __pyx_obj_3crf_Trainer *)__pyx_v_self));
+
+  /* function exit code */
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+static int __pyx_pf_3crf_7Trainer_2__cinit__(struct __pyx_obj_3crf_Trainer *__pyx_v_self) {
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  std::string __pyx_t_1;
+  std::string __pyx_t_2;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("__cinit__", 0);
+
+  /* "crf.pyx":86
+ * 
+ *     def __cinit__(self):
+ *         self._trainer.set_handler(self, <crfsuite_api.messagefunc>self._on_message)             # <<<<<<<<<<<<<<
+ *         self._trainer.select("l2sgd", "crf1d")
+ *         self._trainer._init_trainer()
+ */
+  try {
+    __pyx_v_self->_trainer.set_handler(((PyObject *)__pyx_v_self), ((CRFSuiteWrapper::messagefunc)((struct __pyx_vtabstruct_3crf_Trainer *)__pyx_v_self->__pyx_vtab)->_on_message));
+  } catch(...) {
+    __Pyx_CppExn2PyErr();
+    __PYX_ERR(0, 86, __pyx_L1_error)
+  }
+
+  /* "crf.pyx":87
+ *     def __cinit__(self):
+ *         self._trainer.set_handler(self, <crfsuite_api.messagefunc>self._on_message)
+ *         self._trainer.select("l2sgd", "crf1d")             # <<<<<<<<<<<<<<
+ *         self._trainer._init_trainer()
+ * 
+ */
+  __pyx_t_1 = __pyx_convert_string_from_py_std__in_string(__pyx_n_b_l2sgd); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 87, __pyx_L1_error)
+  __pyx_t_2 = __pyx_convert_string_from_py_std__in_string(__pyx_n_b_crf1d); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 87, __pyx_L1_error)
+  try {
+    __pyx_v_self->_trainer.select(__pyx_t_1, __pyx_t_2);
+  } catch(...) {
+    __Pyx_CppExn2PyErr();
+    __PYX_ERR(0, 87, __pyx_L1_error)
+  }
+
+  /* "crf.pyx":88
+ *         self._trainer.set_handler(self, <crfsuite_api.messagefunc>self._on_message)
+ *         self._trainer.select("l2sgd", "crf1d")
+ *         self._trainer._init_trainer()             # <<<<<<<<<<<<<<
+ * 
+ *     @property
+ */
+  try {
+    __pyx_v_self->_trainer._init_trainer();
+  } catch(...) {
+    __Pyx_CppExn2PyErr();
+    __PYX_ERR(0, 88, __pyx_L1_error)
+  }
+
+  /* "crf.pyx":85
+ *         self.set_params(self.translate_params(kwargs))
+ * 
+ *     def __cinit__(self):             # <<<<<<<<<<<<<<
+ *         self._trainer.set_handler(self, <crfsuite_api.messagefunc>self._on_message)
+ *         self._trainer.select("l2sgd", "crf1d")
+ */
+
+  /* function exit code */
+  __pyx_r = 0;
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_AddTraceback("crf.Trainer.__cinit__", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = -1;
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "crf.pyx":91
+ * 
+ *     @property
+ *     def params(self):             # <<<<<<<<<<<<<<
+ *         return self._trainer.params()
+ * 
+ */
+
+/* Python wrapper */
+static PyObject *__pyx_pw_3crf_7Trainer_6params_1__get__(PyObject *__pyx_v_self); /*proto*/
+static PyObject *__pyx_pw_3crf_7Trainer_6params_1__get__(PyObject *__pyx_v_self) {
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("__get__ (wrapper)", 0);
+  __pyx_r = __pyx_pf_3crf_7Trainer_6params___get__(((struct __pyx_obj_3crf_Trainer *)__pyx_v_self));
+
+  /* function exit code */
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+static PyObject *__pyx_pf_3crf_7Trainer_6params___get__(struct __pyx_obj_3crf_Trainer *__pyx_v_self) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  CRFSuite::StringList __pyx_t_1;
+  PyObject *__pyx_t_2 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("__get__", 0);
+
+  /* "crf.pyx":92
+ *     @property
+ *     def params(self):
+ *         return self._trainer.params()             # <<<<<<<<<<<<<<
+ * 
+ *     def train(self, model_filepath: Filepath):
+ */
+  __Pyx_XDECREF(__pyx_r);
+  try {
+    __pyx_t_1 = __pyx_v_self->_trainer.params();
+  } catch(...) {
+    __Pyx_CppExn2PyErr();
+    __PYX_ERR(0, 92, __pyx_L1_error)
+  }
+  __pyx_t_2 = __pyx_convert_vector_to_py_std_3a__3a_string(__pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 92, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  __pyx_r = __pyx_t_2;
+  __pyx_t_2 = 0;
+  goto __pyx_L0;
+
+  /* "crf.pyx":91
+ * 
+ *     @property
+ *     def params(self):             # <<<<<<<<<<<<<<
+ *         return self._trainer.params()
+ * 
+ */
+
+  /* function exit code */
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_2);
+  __Pyx_AddTraceback("crf.Trainer.params.__get__", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "crf.pyx":94
+ *         return self._trainer.params()
+ * 
+ *     def train(self, model_filepath: Filepath):             # <<<<<<<<<<<<<<
+ *         self._trainer.train(str(model_filepath), -1)
+ * 
+ */
+
+/* Python wrapper */
+static PyObject *__pyx_pw_3crf_7Trainer_5train(PyObject *__pyx_v_self, PyObject *__pyx_v_model_filepath); /*proto*/
+static char __pyx_doc_3crf_7Trainer_4train[] = "Trainer.train(self, model_filepath: Filepath)";
+static PyObject *__pyx_pw_3crf_7Trainer_5train(PyObject *__pyx_v_self, PyObject *__pyx_v_model_filepath) {
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("train (wrapper)", 0);
+  __pyx_r = __pyx_pf_3crf_7Trainer_4train(((struct __pyx_obj_3crf_Trainer *)__pyx_v_self), ((PyObject *)__pyx_v_model_filepath));
+
+  /* function exit code */
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+static PyObject *__pyx_pf_3crf_7Trainer_4train(struct __pyx_obj_3crf_Trainer *__pyx_v_self, PyObject *__pyx_v_model_filepath) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  std::string __pyx_t_2;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("train", 0);
+
+  /* "crf.pyx":95
+ * 
+ *     def train(self, model_filepath: Filepath):
+ *         self._trainer.train(str(model_filepath), -1)             # <<<<<<<<<<<<<<
+ * 
+ *     def _log(self, message: str):
+ */
+  __pyx_t_1 = __Pyx_PyObject_CallOneArg(((PyObject *)(&PyString_Type)), __pyx_v_model_filepath); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 95, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_t_2 = __pyx_convert_string_from_py_std__in_string(__pyx_t_1); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 95, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  try {
+    __pyx_v_self->_trainer.train(__pyx_t_2, -1);
+  } catch(...) {
+    __Pyx_CppExn2PyErr();
+    __PYX_ERR(0, 95, __pyx_L1_error)
+  }
+
+  /* "crf.pyx":94
+ *         return self._trainer.params()
+ * 
+ *     def train(self, model_filepath: Filepath):             # <<<<<<<<<<<<<<
+ *         self._trainer.train(str(model_filepath), -1)
+ * 
+ */
+
+  /* function exit code */
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_AddTraceback("crf.Trainer.train", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "crf.pyx":97
+ *         self._trainer.train(str(model_filepath), -1)
+ * 
+ *     def _log(self, message: str):             # <<<<<<<<<<<<<<
+ *         LOGGER.info(message)
+ * 
+ */
+
+/* Python wrapper */
+static PyObject *__pyx_pw_3crf_7Trainer_7_log(PyObject *__pyx_v_self, PyObject *__pyx_v_message); /*proto*/
+static char __pyx_doc_3crf_7Trainer_6_log[] = "Trainer._log(self, str message: str)";
+static PyObject *__pyx_pw_3crf_7Trainer_7_log(PyObject *__pyx_v_self, PyObject *__pyx_v_message) {
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("_log (wrapper)", 0);
+  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_message), (&PyString_Type), 1, "message", 1))) __PYX_ERR(0, 97, __pyx_L1_error)
+  __pyx_r = __pyx_pf_3crf_7Trainer_6_log(((struct __pyx_obj_3crf_Trainer *)__pyx_v_self), ((PyObject*)__pyx_v_message));
+
+  /* function exit code */
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+static PyObject *__pyx_pf_3crf_7Trainer_6_log(CYTHON_UNUSED struct __pyx_obj_3crf_Trainer *__pyx_v_self, PyObject *__pyx_v_message) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  PyObject *__pyx_t_2 = NULL;
+  PyObject *__pyx_t_3 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("_log", 0);
+
+  /* "crf.pyx":98
+ * 
+ *     def _log(self, message: str):
+ *         LOGGER.info(message)             # <<<<<<<<<<<<<<
+ * 
+ *     cdef _on_message(self, string message):
+ */
+  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_LOGGER); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 98, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_info); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 98, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_3);
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __pyx_t_2 = NULL;
+  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
+    __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_3);
+    if (likely(__pyx_t_2)) {
+      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
+      __Pyx_INCREF(__pyx_t_2);
+      __Pyx_INCREF(function);
+      __Pyx_DECREF_SET(__pyx_t_3, function);
+    }
+  }
+  __pyx_t_1 = (__pyx_t_2) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_2, __pyx_v_message) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_v_message);
+  __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
+  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 98, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "crf.pyx":97
+ *         self._trainer.train(str(model_filepath), -1)
+ * 
+ *     def _log(self, message: str):             # <<<<<<<<<<<<<<
+ *         LOGGER.info(message)
+ * 
+ */
+
+  /* function exit code */
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_XDECREF(__pyx_t_2);
+  __Pyx_XDECREF(__pyx_t_3);
+  __Pyx_AddTraceback("crf.Trainer._log", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "crf.pyx":100
+ *         LOGGER.info(message)
+ * 
+ *     cdef _on_message(self, string message):             # <<<<<<<<<<<<<<
+ *         self._log(message)
+ * 
+ */
+
+static PyObject *__pyx_f_3crf_7Trainer__on_message(struct __pyx_obj_3crf_Trainer *__pyx_v_self, std::string __pyx_v_message) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  PyObject *__pyx_t_2 = NULL;
+  PyObject *__pyx_t_3 = NULL;
+  PyObject *__pyx_t_4 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("_on_message", 0);
+
+  /* "crf.pyx":101
+ * 
+ *     cdef _on_message(self, string message):
+ *         self._log(message)             # <<<<<<<<<<<<<<
+ * 
+ *     def append(self, sequence: Sequence, labels: Labels, int group=0):
+ */
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_log); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 101, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  __pyx_t_3 = __pyx_convert_PyStr_string_to_py_std__in_string(__pyx_v_message); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 101, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_3);
+  __pyx_t_4 = NULL;
+  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
+    __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_2);
+    if (likely(__pyx_t_4)) {
+      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
+      __Pyx_INCREF(__pyx_t_4);
+      __Pyx_INCREF(function);
+      __Pyx_DECREF_SET(__pyx_t_2, function);
+    }
+  }
+  __pyx_t_1 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_4, __pyx_t_3) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_3);
+  __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 101, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "crf.pyx":100
+ *         LOGGER.info(message)
+ * 
+ *     cdef _on_message(self, string message):             # <<<<<<<<<<<<<<
+ *         self._log(message)
+ * 
+ */
+
+  /* function exit code */
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_XDECREF(__pyx_t_2);
+  __Pyx_XDECREF(__pyx_t_3);
+  __Pyx_XDECREF(__pyx_t_4);
+  __Pyx_AddTraceback("crf.Trainer._on_message", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "crf.pyx":103
+ *         self._log(message)
+ * 
+ *     def append(self, sequence: Sequence, labels: Labels, int group=0):             # <<<<<<<<<<<<<<
+ *         # no generators allowed
+ *         if not isinstance(sequence, list):
+ */
+
+/* Python wrapper */
+static PyObject *__pyx_pw_3crf_7Trainer_9append(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
+static char __pyx_doc_3crf_7Trainer_8append[] = "Trainer.append(self, sequence: Sequence, labels: Labels, int group=0)";
+static PyObject *__pyx_pw_3crf_7Trainer_9append(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
+  PyObject *__pyx_v_sequence = 0;
+  PyObject *__pyx_v_labels = 0;
+  int __pyx_v_group;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("append (wrapper)", 0);
+  {
+    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_sequence,&__pyx_n_s_labels,&__pyx_n_s_group,0};
+    PyObject* values[3] = {0,0,0};
+    if (unlikely(__pyx_kwds)) {
+      Py_ssize_t kw_args;
+      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
+      switch (pos_args) {
+        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
+        CYTHON_FALLTHROUGH;
+        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
+        CYTHON_FALLTHROUGH;
+        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
+        CYTHON_FALLTHROUGH;
+        case  0: break;
+        default: goto __pyx_L5_argtuple_error;
+      }
+      kw_args = PyDict_Size(__pyx_kwds);
+      switch (pos_args) {
+        case  0:
+        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_sequence)) != 0)) kw_args--;
+        else goto __pyx_L5_argtuple_error;
+        CYTHON_FALLTHROUGH;
+        case  1:
+        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_labels)) != 0)) kw_args--;
+        else {
+          __Pyx_RaiseArgtupleInvalid("append", 0, 2, 3, 1); __PYX_ERR(0, 103, __pyx_L3_error)
+        }
+        CYTHON_FALLTHROUGH;
+        case  2:
+        if (kw_args > 0) {
+          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_group);
+          if (value) { values[2] = value; kw_args--; }
+        }
+      }
+      if (unlikely(kw_args > 0)) {
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "append") < 0)) __PYX_ERR(0, 103, __pyx_L3_error)
+      }
+    } else {
+      switch (PyTuple_GET_SIZE(__pyx_args)) {
+        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
+        CYTHON_FALLTHROUGH;
+        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
+        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
+        break;
+        default: goto __pyx_L5_argtuple_error;
+      }
+    }
+    __pyx_v_sequence = values[0];
+    __pyx_v_labels = values[1];
+    if (values[2]) {
+      __pyx_v_group = __Pyx_PyInt_As_int(values[2]); if (unlikely((__pyx_v_group == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 103, __pyx_L3_error)
+    } else {
+      __pyx_v_group = ((int)0);
+    }
+  }
+  goto __pyx_L4_argument_unpacking_done;
+  __pyx_L5_argtuple_error:;
+  __Pyx_RaiseArgtupleInvalid("append", 0, 2, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 103, __pyx_L3_error)
+  __pyx_L3_error:;
+  __Pyx_AddTraceback("crf.Trainer.append", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_RefNannyFinishContext();
+  return NULL;
+  __pyx_L4_argument_unpacking_done:;
+  __pyx_r = __pyx_pf_3crf_7Trainer_8append(((struct __pyx_obj_3crf_Trainer *)__pyx_v_self), __pyx_v_sequence, __pyx_v_labels, __pyx_v_group);
+
+  /* function exit code */
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+static PyObject *__pyx_pf_3crf_7Trainer_8append(struct __pyx_obj_3crf_Trainer *__pyx_v_self, PyObject *__pyx_v_sequence, PyObject *__pyx_v_labels, int __pyx_v_group) {
+  PyObject *__pyx_v_item = NULL;
+  PyObject *__pyx_v_label = NULL;
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  int __pyx_t_1;
+  int __pyx_t_2;
+  PyObject *__pyx_t_3 = NULL;
+  PyObject *__pyx_t_4 = NULL;
+  Py_ssize_t __pyx_t_5;
+  PyObject *(*__pyx_t_6)(PyObject *);
+  PyObject *__pyx_t_7 = NULL;
+  CRFSuite::ItemSequence __pyx_t_8;
+  CRFSuite::StringList __pyx_t_9;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("append", 0);
+  __Pyx_INCREF(__pyx_v_sequence);
+  __Pyx_INCREF(__pyx_v_labels);
+
+  /* "crf.pyx":105
+ *     def append(self, sequence: Sequence, labels: Labels, int group=0):
+ *         # no generators allowed
+ *         if not isinstance(sequence, list):             # <<<<<<<<<<<<<<
+ *             sequence = [item for item in sequence]
+ *         if not isinstance(labels, list):
+ */
+  __pyx_t_1 = PyList_Check(__pyx_v_sequence); 
+  __pyx_t_2 = ((!(__pyx_t_1 != 0)) != 0);
+  if (__pyx_t_2) {
+
+    /* "crf.pyx":106
+ *         # no generators allowed
+ *         if not isinstance(sequence, list):
+ *             sequence = [item for item in sequence]             # <<<<<<<<<<<<<<
+ *         if not isinstance(labels, list):
+ *             # labels must be strings
+ */
+    __pyx_t_3 = PyList_New(0); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 106, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_3);
+    if (likely(PyList_CheckExact(__pyx_v_sequence)) || PyTuple_CheckExact(__pyx_v_sequence)) {
+      __pyx_t_4 = __pyx_v_sequence; __Pyx_INCREF(__pyx_t_4); __pyx_t_5 = 0;
+      __pyx_t_6 = NULL;
+    } else {
+      __pyx_t_5 = -1; __pyx_t_4 = PyObject_GetIter(__pyx_v_sequence); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 106, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_4);
+      __pyx_t_6 = Py_TYPE(__pyx_t_4)->tp_iternext; if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 106, __pyx_L1_error)
+    }
+    for (;;) {
+      if (likely(!__pyx_t_6)) {
+        if (likely(PyList_CheckExact(__pyx_t_4))) {
+          if (__pyx_t_5 >= PyList_GET_SIZE(__pyx_t_4)) break;
+          #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
+          __pyx_t_7 = PyList_GET_ITEM(__pyx_t_4, __pyx_t_5); __Pyx_INCREF(__pyx_t_7); __pyx_t_5++; if (unlikely(0 < 0)) __PYX_ERR(0, 106, __pyx_L1_error)
+          #else
+          __pyx_t_7 = PySequence_ITEM(__pyx_t_4, __pyx_t_5); __pyx_t_5++; if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 106, __pyx_L1_error)
+          __Pyx_GOTREF(__pyx_t_7);
+          #endif
+        } else {
+          if (__pyx_t_5 >= PyTuple_GET_SIZE(__pyx_t_4)) break;
+          #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
+          __pyx_t_7 = PyTuple_GET_ITEM(__pyx_t_4, __pyx_t_5); __Pyx_INCREF(__pyx_t_7); __pyx_t_5++; if (unlikely(0 < 0)) __PYX_ERR(0, 106, __pyx_L1_error)
+          #else
+          __pyx_t_7 = PySequence_ITEM(__pyx_t_4, __pyx_t_5); __pyx_t_5++; if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 106, __pyx_L1_error)
+          __Pyx_GOTREF(__pyx_t_7);
+          #endif
+        }
+      } else {
+        __pyx_t_7 = __pyx_t_6(__pyx_t_4);
+        if (unlikely(!__pyx_t_7)) {
+          PyObject* exc_type = PyErr_Occurred();
+          if (exc_type) {
+            if (likely(__Pyx_PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
+            else __PYX_ERR(0, 106, __pyx_L1_error)
+          }
+          break;
+        }
+        __Pyx_GOTREF(__pyx_t_7);
+      }
+      __Pyx_XDECREF_SET(__pyx_v_item, __pyx_t_7);
+      __pyx_t_7 = 0;
+      if (unlikely(__Pyx_ListComp_Append(__pyx_t_3, (PyObject*)__pyx_v_item))) __PYX_ERR(0, 106, __pyx_L1_error)
+    }
+    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+    __Pyx_DECREF_SET(__pyx_v_sequence, __pyx_t_3);
+    __pyx_t_3 = 0;
+
+    /* "crf.pyx":105
+ *     def append(self, sequence: Sequence, labels: Labels, int group=0):
+ *         # no generators allowed
+ *         if not isinstance(sequence, list):             # <<<<<<<<<<<<<<
+ *             sequence = [item for item in sequence]
+ *         if not isinstance(labels, list):
+ */
+  }
+
+  /* "crf.pyx":107
+ *         if not isinstance(sequence, list):
+ *             sequence = [item for item in sequence]
+ *         if not isinstance(labels, list):             # <<<<<<<<<<<<<<
+ *             # labels must be strings
+ *             labels = [str(label) for label in labels]
+ */
+  __pyx_t_2 = PyList_Check(__pyx_v_labels); 
+  __pyx_t_1 = ((!(__pyx_t_2 != 0)) != 0);
+  if (__pyx_t_1) {
+
+    /* "crf.pyx":109
+ *         if not isinstance(labels, list):
+ *             # labels must be strings
+ *             labels = [str(label) for label in labels]             # <<<<<<<<<<<<<<
+ * 
+ *         self._trainer.append(to_seq(sequence), labels, group)
+ */
+    __pyx_t_3 = PyList_New(0); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 109, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_3);
+    if (likely(PyList_CheckExact(__pyx_v_labels)) || PyTuple_CheckExact(__pyx_v_labels)) {
+      __pyx_t_4 = __pyx_v_labels; __Pyx_INCREF(__pyx_t_4); __pyx_t_5 = 0;
+      __pyx_t_6 = NULL;
+    } else {
+      __pyx_t_5 = -1; __pyx_t_4 = PyObject_GetIter(__pyx_v_labels); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 109, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_4);
+      __pyx_t_6 = Py_TYPE(__pyx_t_4)->tp_iternext; if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 109, __pyx_L1_error)
+    }
+    for (;;) {
+      if (likely(!__pyx_t_6)) {
+        if (likely(PyList_CheckExact(__pyx_t_4))) {
+          if (__pyx_t_5 >= PyList_GET_SIZE(__pyx_t_4)) break;
+          #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
+          __pyx_t_7 = PyList_GET_ITEM(__pyx_t_4, __pyx_t_5); __Pyx_INCREF(__pyx_t_7); __pyx_t_5++; if (unlikely(0 < 0)) __PYX_ERR(0, 109, __pyx_L1_error)
+          #else
+          __pyx_t_7 = PySequence_ITEM(__pyx_t_4, __pyx_t_5); __pyx_t_5++; if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 109, __pyx_L1_error)
+          __Pyx_GOTREF(__pyx_t_7);
+          #endif
+        } else {
+          if (__pyx_t_5 >= PyTuple_GET_SIZE(__pyx_t_4)) break;
+          #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
+          __pyx_t_7 = PyTuple_GET_ITEM(__pyx_t_4, __pyx_t_5); __Pyx_INCREF(__pyx_t_7); __pyx_t_5++; if (unlikely(0 < 0)) __PYX_ERR(0, 109, __pyx_L1_error)
+          #else
+          __pyx_t_7 = PySequence_ITEM(__pyx_t_4, __pyx_t_5); __pyx_t_5++; if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 109, __pyx_L1_error)
+          __Pyx_GOTREF(__pyx_t_7);
+          #endif
+        }
+      } else {
+        __pyx_t_7 = __pyx_t_6(__pyx_t_4);
+        if (unlikely(!__pyx_t_7)) {
+          PyObject* exc_type = PyErr_Occurred();
+          if (exc_type) {
+            if (likely(__Pyx_PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
+            else __PYX_ERR(0, 109, __pyx_L1_error)
+          }
+          break;
+        }
+        __Pyx_GOTREF(__pyx_t_7);
+      }
+      __Pyx_XDECREF_SET(__pyx_v_label, __pyx_t_7);
+      __pyx_t_7 = 0;
+      __pyx_t_7 = __Pyx_PyObject_CallOneArg(((PyObject *)(&PyString_Type)), __pyx_v_label); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 109, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_7);
+      if (unlikely(__Pyx_ListComp_Append(__pyx_t_3, (PyObject*)__pyx_t_7))) __PYX_ERR(0, 109, __pyx_L1_error)
+      __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
+    }
+    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+    __Pyx_DECREF_SET(__pyx_v_labels, __pyx_t_3);
+    __pyx_t_3 = 0;
+
+    /* "crf.pyx":107
+ *         if not isinstance(sequence, list):
+ *             sequence = [item for item in sequence]
+ *         if not isinstance(labels, list):             # <<<<<<<<<<<<<<
+ *             # labels must be strings
+ *             labels = [str(label) for label in labels]
+ */
+  }
+
+  /* "crf.pyx":111
+ *             labels = [str(label) for label in labels]
+ * 
+ *         self._trainer.append(to_seq(sequence), labels, group)             # <<<<<<<<<<<<<<
+ * 
+ *     def translate_params(self, kwargs: dict[str, str | int | float | bool]):
+ */
+  try {
+    __pyx_t_8 = __pyx_f_3crf_to_seq(__pyx_v_sequence);
+  } catch(...) {
+    __Pyx_CppExn2PyErr();
+    __PYX_ERR(0, 111, __pyx_L1_error)
+  }
+  __pyx_t_9 = __pyx_convert_vector_from_py_std_3a__3a_string(__pyx_v_labels); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 111, __pyx_L1_error)
+  try {
+    __pyx_v_self->_trainer.append(__pyx_t_8, __pyx_t_9, __pyx_v_group);
+  } catch(...) {
+    __Pyx_CppExn2PyErr();
+    __PYX_ERR(0, 111, __pyx_L1_error)
+  }
+
+  /* "crf.pyx":103
+ *         self._log(message)
+ * 
+ *     def append(self, sequence: Sequence, labels: Labels, int group=0):             # <<<<<<<<<<<<<<
+ *         # no generators allowed
+ *         if not isinstance(sequence, list):
+ */
+
+  /* function exit code */
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_3);
+  __Pyx_XDECREF(__pyx_t_4);
+  __Pyx_XDECREF(__pyx_t_7);
+  __Pyx_AddTraceback("crf.Trainer.append", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_XDECREF(__pyx_v_item);
+  __Pyx_XDECREF(__pyx_v_label);
+  __Pyx_XDECREF(__pyx_v_sequence);
+  __Pyx_XDECREF(__pyx_v_labels);
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "crf.pyx":113
+ *         self._trainer.append(to_seq(sequence), labels, group)
+ * 
+ *     def translate_params(self, kwargs: dict[str, str | int | float | bool]):             # <<<<<<<<<<<<<<
+ *         return {
+ *             self.kwarg2param.get(kwarg, kwarg): value
+ */
+
+/* Python wrapper */
+static PyObject *__pyx_pw_3crf_7Trainer_11translate_params(PyObject *__pyx_v_self, PyObject *__pyx_v_kwargs); /*proto*/
+static char __pyx_doc_3crf_7Trainer_10translate_params[] = "Trainer.translate_params(self, kwargs: dict[str, str | int | float | bool])";
+static PyObject *__pyx_pw_3crf_7Trainer_11translate_params(PyObject *__pyx_v_self, PyObject *__pyx_v_kwargs) {
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("translate_params (wrapper)", 0);
+  __pyx_r = __pyx_pf_3crf_7Trainer_10translate_params(((struct __pyx_obj_3crf_Trainer *)__pyx_v_self), ((PyObject *)__pyx_v_kwargs));
+
+  /* function exit code */
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+static PyObject *__pyx_pf_3crf_7Trainer_10translate_params(struct __pyx_obj_3crf_Trainer *__pyx_v_self, PyObject *__pyx_v_kwargs) {
+  PyObject *__pyx_7genexpr__pyx_v_kwarg = NULL;
+  PyObject *__pyx_7genexpr__pyx_v_value = NULL;
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  PyObject *__pyx_t_2 = NULL;
+  PyObject *__pyx_t_3 = NULL;
+  PyObject *__pyx_t_4 = NULL;
+  Py_ssize_t __pyx_t_5;
+  PyObject *(*__pyx_t_6)(PyObject *);
+  PyObject *__pyx_t_7 = NULL;
+  PyObject *__pyx_t_8 = NULL;
+  PyObject *(*__pyx_t_9)(PyObject *);
+  int __pyx_t_10;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("translate_params", 0);
+
+  /* "crf.pyx":114
+ * 
+ *     def translate_params(self, kwargs: dict[str, str | int | float | bool]):
+ *         return {             # <<<<<<<<<<<<<<
+ *             self.kwarg2param.get(kwarg, kwarg): value
+ *             for kwarg, value in kwargs.items()
+ */
+  __Pyx_XDECREF(__pyx_r);
+  { /* enter inner scope */
+    __pyx_t_1 = PyDict_New(); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 114, __pyx_L5_error)
+    __Pyx_GOTREF(__pyx_t_1);
+
+    /* "crf.pyx":116
+ *         return {
+ *             self.kwarg2param.get(kwarg, kwarg): value
+ *             for kwarg, value in kwargs.items()             # <<<<<<<<<<<<<<
+ *         }
+ * 
+ */
+    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_kwargs, __pyx_n_s_items); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 116, __pyx_L5_error)
+    __Pyx_GOTREF(__pyx_t_3);
+    __pyx_t_4 = NULL;
+    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
+      __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
+      if (likely(__pyx_t_4)) {
+        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
+        __Pyx_INCREF(__pyx_t_4);
+        __Pyx_INCREF(function);
+        __Pyx_DECREF_SET(__pyx_t_3, function);
+      }
+    }
+    __pyx_t_2 = (__pyx_t_4) ? __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_4) : __Pyx_PyObject_CallNoArg(__pyx_t_3);
+    __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
+    if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 116, __pyx_L5_error)
+    __Pyx_GOTREF(__pyx_t_2);
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+    if (likely(PyList_CheckExact(__pyx_t_2)) || PyTuple_CheckExact(__pyx_t_2)) {
+      __pyx_t_3 = __pyx_t_2; __Pyx_INCREF(__pyx_t_3); __pyx_t_5 = 0;
+      __pyx_t_6 = NULL;
+    } else {
+      __pyx_t_5 = -1; __pyx_t_3 = PyObject_GetIter(__pyx_t_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 116, __pyx_L5_error)
+      __Pyx_GOTREF(__pyx_t_3);
+      __pyx_t_6 = Py_TYPE(__pyx_t_3)->tp_iternext; if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 116, __pyx_L5_error)
+    }
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    for (;;) {
+      if (likely(!__pyx_t_6)) {
+        if (likely(PyList_CheckExact(__pyx_t_3))) {
+          if (__pyx_t_5 >= PyList_GET_SIZE(__pyx_t_3)) break;
+          #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
+          __pyx_t_2 = PyList_GET_ITEM(__pyx_t_3, __pyx_t_5); __Pyx_INCREF(__pyx_t_2); __pyx_t_5++; if (unlikely(0 < 0)) __PYX_ERR(0, 116, __pyx_L5_error)
+          #else
+          __pyx_t_2 = PySequence_ITEM(__pyx_t_3, __pyx_t_5); __pyx_t_5++; if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 116, __pyx_L5_error)
+          __Pyx_GOTREF(__pyx_t_2);
+          #endif
+        } else {
+          if (__pyx_t_5 >= PyTuple_GET_SIZE(__pyx_t_3)) break;
+          #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
+          __pyx_t_2 = PyTuple_GET_ITEM(__pyx_t_3, __pyx_t_5); __Pyx_INCREF(__pyx_t_2); __pyx_t_5++; if (unlikely(0 < 0)) __PYX_ERR(0, 116, __pyx_L5_error)
+          #else
+          __pyx_t_2 = PySequence_ITEM(__pyx_t_3, __pyx_t_5); __pyx_t_5++; if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 116, __pyx_L5_error)
+          __Pyx_GOTREF(__pyx_t_2);
+          #endif
+        }
+      } else {
+        __pyx_t_2 = __pyx_t_6(__pyx_t_3);
+        if (unlikely(!__pyx_t_2)) {
+          PyObject* exc_type = PyErr_Occurred();
+          if (exc_type) {
+            if (likely(__Pyx_PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
+            else __PYX_ERR(0, 116, __pyx_L5_error)
+          }
+          break;
+        }
+        __Pyx_GOTREF(__pyx_t_2);
+      }
+      if ((likely(PyTuple_CheckExact(__pyx_t_2))) || (PyList_CheckExact(__pyx_t_2))) {
+        PyObject* sequence = __pyx_t_2;
+        Py_ssize_t size = __Pyx_PySequence_SIZE(sequence);
+        if (unlikely(size != 2)) {
+          if (size > 2) __Pyx_RaiseTooManyValuesError(2);
+          else if (size >= 0) __Pyx_RaiseNeedMoreValuesError(size);
+          __PYX_ERR(0, 116, __pyx_L5_error)
+        }
+        #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
+        if (likely(PyTuple_CheckExact(sequence))) {
+          __pyx_t_4 = PyTuple_GET_ITEM(sequence, 0); 
+          __pyx_t_7 = PyTuple_GET_ITEM(sequence, 1); 
+        } else {
+          __pyx_t_4 = PyList_GET_ITEM(sequence, 0); 
+          __pyx_t_7 = PyList_GET_ITEM(sequence, 1); 
+        }
+        __Pyx_INCREF(__pyx_t_4);
+        __Pyx_INCREF(__pyx_t_7);
+        #else
+        __pyx_t_4 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 116, __pyx_L5_error)
+        __Pyx_GOTREF(__pyx_t_4);
+        __pyx_t_7 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 116, __pyx_L5_error)
+        __Pyx_GOTREF(__pyx_t_7);
+        #endif
+        __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+      } else {
+        Py_ssize_t index = -1;
+        __pyx_t_8 = PyObject_GetIter(__pyx_t_2); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 116, __pyx_L5_error)
+        __Pyx_GOTREF(__pyx_t_8);
+        __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+        __pyx_t_9 = Py_TYPE(__pyx_t_8)->tp_iternext;
+        index = 0; __pyx_t_4 = __pyx_t_9(__pyx_t_8); if (unlikely(!__pyx_t_4)) goto __pyx_L8_unpacking_failed;
+        __Pyx_GOTREF(__pyx_t_4);
+        index = 1; __pyx_t_7 = __pyx_t_9(__pyx_t_8); if (unlikely(!__pyx_t_7)) goto __pyx_L8_unpacking_failed;
+        __Pyx_GOTREF(__pyx_t_7);
+        if (__Pyx_IternextUnpackEndCheck(__pyx_t_9(__pyx_t_8), 2) < 0) __PYX_ERR(0, 116, __pyx_L5_error)
+        __pyx_t_9 = NULL;
+        __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
+        goto __pyx_L9_unpacking_done;
+        __pyx_L8_unpacking_failed:;
+        __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
+        __pyx_t_9 = NULL;
+        if (__Pyx_IterFinish() == 0) __Pyx_RaiseNeedMoreValuesError(index);
+        __PYX_ERR(0, 116, __pyx_L5_error)
+        __pyx_L9_unpacking_done:;
+      }
+      __Pyx_XDECREF_SET(__pyx_7genexpr__pyx_v_kwarg, __pyx_t_4);
+      __pyx_t_4 = 0;
+      __Pyx_XDECREF_SET(__pyx_7genexpr__pyx_v_value, __pyx_t_7);
+      __pyx_t_7 = 0;
+
+      /* "crf.pyx":115
+ *     def translate_params(self, kwargs: dict[str, str | int | float | bool]):
+ *         return {
+ *             self.kwarg2param.get(kwarg, kwarg): value             # <<<<<<<<<<<<<<
+ *             for kwarg, value in kwargs.items()
+ *         }
+ */
+      __pyx_t_7 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_kwarg2param); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 115, __pyx_L5_error)
+      __Pyx_GOTREF(__pyx_t_7);
+      __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_get); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 115, __pyx_L5_error)
+      __Pyx_GOTREF(__pyx_t_4);
+      __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
+      __pyx_t_7 = NULL;
+      __pyx_t_10 = 0;
+      if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_4))) {
+        __pyx_t_7 = PyMethod_GET_SELF(__pyx_t_4);
+        if (likely(__pyx_t_7)) {
+          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
+          __Pyx_INCREF(__pyx_t_7);
+          __Pyx_INCREF(function);
+          __Pyx_DECREF_SET(__pyx_t_4, function);
+          __pyx_t_10 = 1;
+        }
+      }
+      #if CYTHON_FAST_PYCALL
+      if (PyFunction_Check(__pyx_t_4)) {
+        PyObject *__pyx_temp[3] = {__pyx_t_7, __pyx_7genexpr__pyx_v_kwarg, __pyx_7genexpr__pyx_v_kwarg};
+        __pyx_t_2 = __Pyx_PyFunction_FastCall(__pyx_t_4, __pyx_temp+1-__pyx_t_10, 2+__pyx_t_10); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 115, __pyx_L5_error)
+        __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
+        __Pyx_GOTREF(__pyx_t_2);
+      } else
+      #endif
+      #if CYTHON_FAST_PYCCALL
+      if (__Pyx_PyFastCFunction_Check(__pyx_t_4)) {
+        PyObject *__pyx_temp[3] = {__pyx_t_7, __pyx_7genexpr__pyx_v_kwarg, __pyx_7genexpr__pyx_v_kwarg};
+        __pyx_t_2 = __Pyx_PyCFunction_FastCall(__pyx_t_4, __pyx_temp+1-__pyx_t_10, 2+__pyx_t_10); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 115, __pyx_L5_error)
+        __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
+        __Pyx_GOTREF(__pyx_t_2);
+      } else
+      #endif
+      {
+        __pyx_t_8 = PyTuple_New(2+__pyx_t_10); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 115, __pyx_L5_error)
+        __Pyx_GOTREF(__pyx_t_8);
+        if (__pyx_t_7) {
+          __Pyx_GIVEREF(__pyx_t_7); PyTuple_SET_ITEM(__pyx_t_8, 0, __pyx_t_7); __pyx_t_7 = NULL;
+        }
+        __Pyx_INCREF(__pyx_7genexpr__pyx_v_kwarg);
+        __Pyx_GIVEREF(__pyx_7genexpr__pyx_v_kwarg);
+        PyTuple_SET_ITEM(__pyx_t_8, 0+__pyx_t_10, __pyx_7genexpr__pyx_v_kwarg);
+        __Pyx_INCREF(__pyx_7genexpr__pyx_v_kwarg);
+        __Pyx_GIVEREF(__pyx_7genexpr__pyx_v_kwarg);
+        PyTuple_SET_ITEM(__pyx_t_8, 1+__pyx_t_10, __pyx_7genexpr__pyx_v_kwarg);
+        __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_t_8, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 115, __pyx_L5_error)
+        __Pyx_GOTREF(__pyx_t_2);
+        __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
+      }
+      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+      if (unlikely(PyDict_SetItem(__pyx_t_1, (PyObject*)__pyx_t_2, (PyObject*)__pyx_7genexpr__pyx_v_value))) __PYX_ERR(0, 115, __pyx_L5_error)
+      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+
+      /* "crf.pyx":116
+ *         return {
+ *             self.kwarg2param.get(kwarg, kwarg): value
+ *             for kwarg, value in kwargs.items()             # <<<<<<<<<<<<<<
+ *         }
+ * 
+ */
+    }
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+    __Pyx_XDECREF(__pyx_7genexpr__pyx_v_kwarg); __pyx_7genexpr__pyx_v_kwarg = 0;
+    __Pyx_XDECREF(__pyx_7genexpr__pyx_v_value); __pyx_7genexpr__pyx_v_value = 0;
+    goto __pyx_L10_exit_scope;
+    __pyx_L5_error:;
+    __Pyx_XDECREF(__pyx_7genexpr__pyx_v_kwarg); __pyx_7genexpr__pyx_v_kwarg = 0;
+    __Pyx_XDECREF(__pyx_7genexpr__pyx_v_value); __pyx_7genexpr__pyx_v_value = 0;
+    goto __pyx_L1_error;
+    __pyx_L10_exit_scope:;
+  } /* exit inner scope */
+  __pyx_r = __pyx_t_1;
+  __pyx_t_1 = 0;
+  goto __pyx_L0;
+
+  /* "crf.pyx":113
+ *         self._trainer.append(to_seq(sequence), labels, group)
+ * 
+ *     def translate_params(self, kwargs: dict[str, str | int | float | bool]):             # <<<<<<<<<<<<<<
+ *         return {
+ *             self.kwarg2param.get(kwarg, kwarg): value
+ */
+
+  /* function exit code */
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_XDECREF(__pyx_t_2);
+  __Pyx_XDECREF(__pyx_t_3);
+  __Pyx_XDECREF(__pyx_t_4);
+  __Pyx_XDECREF(__pyx_t_7);
+  __Pyx_XDECREF(__pyx_t_8);
+  __Pyx_AddTraceback("crf.Trainer.translate_params", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_XDECREF(__pyx_7genexpr__pyx_v_kwarg);
+  __Pyx_XDECREF(__pyx_7genexpr__pyx_v_value);
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "crf.pyx":119
+ *         }
+ * 
+ *     def select_algorithm(self, algorithm: str):             # <<<<<<<<<<<<<<
+ *         try:
+ *             algorithm = self._algorithm_aliases[algorithm.lower()]
+ */
+
+/* Python wrapper */
+static PyObject *__pyx_pw_3crf_7Trainer_13select_algorithm(PyObject *__pyx_v_self, PyObject *__pyx_v_algorithm); /*proto*/
+static char __pyx_doc_3crf_7Trainer_12select_algorithm[] = "Trainer.select_algorithm(self, str algorithm: str)";
+static PyObject *__pyx_pw_3crf_7Trainer_13select_algorithm(PyObject *__pyx_v_self, PyObject *__pyx_v_algorithm) {
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("select_algorithm (wrapper)", 0);
+  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_algorithm), (&PyString_Type), 1, "algorithm", 1))) __PYX_ERR(0, 119, __pyx_L1_error)
+  __pyx_r = __pyx_pf_3crf_7Trainer_12select_algorithm(((struct __pyx_obj_3crf_Trainer *)__pyx_v_self), ((PyObject*)__pyx_v_algorithm));
+
+  /* function exit code */
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+static PyObject *__pyx_pf_3crf_7Trainer_12select_algorithm(struct __pyx_obj_3crf_Trainer *__pyx_v_self, PyObject *__pyx_v_algorithm) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  PyObject *__pyx_t_2 = NULL;
+  PyObject *__pyx_t_3 = NULL;
+  PyObject *__pyx_t_4 = NULL;
+  PyObject *__pyx_t_5 = NULL;
+  PyObject *__pyx_t_6 = NULL;
+  PyObject *__pyx_t_7 = NULL;
+  PyObject *__pyx_t_8 = NULL;
+  std::string __pyx_t_9;
+  std::string __pyx_t_10;
+  int __pyx_t_11;
+  int __pyx_t_12;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("select_algorithm", 0);
+  __Pyx_INCREF(__pyx_v_algorithm);
+
+  /* "crf.pyx":120
+ * 
+ *     def select_algorithm(self, algorithm: str):
+ *         try:             # <<<<<<<<<<<<<<
+ *             algorithm = self._algorithm_aliases[algorithm.lower()]
+ *         except:
+ */
+  {
+    __Pyx_PyThreadState_declare
+    __Pyx_PyThreadState_assign
+    __Pyx_ExceptionSave(&__pyx_t_1, &__pyx_t_2, &__pyx_t_3);
+    __Pyx_XGOTREF(__pyx_t_1);
+    __Pyx_XGOTREF(__pyx_t_2);
+    __Pyx_XGOTREF(__pyx_t_3);
+    /*try:*/ {
+
+      /* "crf.pyx":121
+ *     def select_algorithm(self, algorithm: str):
+ *         try:
+ *             algorithm = self._algorithm_aliases[algorithm.lower()]             # <<<<<<<<<<<<<<
+ *         except:
+ *             raise ValueError(f"{algorithm} is no available algorithm")
+ */
+      __pyx_t_4 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_algorithm_aliases); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 121, __pyx_L3_error)
+      __Pyx_GOTREF(__pyx_t_4);
+      __pyx_t_5 = __Pyx_CallUnboundCMethod0(&__pyx_umethod_PyString_Type_lower, __pyx_v_algorithm); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 121, __pyx_L3_error)
+      __Pyx_GOTREF(__pyx_t_5);
+      __pyx_t_6 = __Pyx_PyObject_GetItem(__pyx_t_4, __pyx_t_5); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 121, __pyx_L3_error)
+      __Pyx_GOTREF(__pyx_t_6);
+      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+      if (!(likely(PyString_CheckExact(__pyx_t_6))||((__pyx_t_6) == Py_None)||(PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "str", Py_TYPE(__pyx_t_6)->tp_name), 0))) __PYX_ERR(0, 121, __pyx_L3_error)
+      __Pyx_DECREF_SET(__pyx_v_algorithm, ((PyObject*)__pyx_t_6));
+      __pyx_t_6 = 0;
+
+      /* "crf.pyx":120
+ * 
+ *     def select_algorithm(self, algorithm: str):
+ *         try:             # <<<<<<<<<<<<<<
+ *             algorithm = self._algorithm_aliases[algorithm.lower()]
+ *         except:
+ */
+    }
+    __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
+    __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
+    __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
+    goto __pyx_L8_try_end;
+    __pyx_L3_error:;
+    __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
+    __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
+    __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
+
+    /* "crf.pyx":122
+ *         try:
+ *             algorithm = self._algorithm_aliases[algorithm.lower()]
+ *         except:             # <<<<<<<<<<<<<<
+ *             raise ValueError(f"{algorithm} is no available algorithm")
+ *         if not self._trainer.select(algorithm, "crf1d"):
+ */
+    /*except:*/ {
+      __Pyx_AddTraceback("crf.Trainer.select_algorithm", __pyx_clineno, __pyx_lineno, __pyx_filename);
+      if (__Pyx_GetException(&__pyx_t_6, &__pyx_t_5, &__pyx_t_4) < 0) __PYX_ERR(0, 122, __pyx_L5_except_error)
+      __Pyx_GOTREF(__pyx_t_6);
+      __Pyx_GOTREF(__pyx_t_5);
+      __Pyx_GOTREF(__pyx_t_4);
+
+      /* "crf.pyx":123
+ *             algorithm = self._algorithm_aliases[algorithm.lower()]
+ *         except:
+ *             raise ValueError(f"{algorithm} is no available algorithm")             # <<<<<<<<<<<<<<
+ *         if not self._trainer.select(algorithm, "crf1d"):
+ *             raise ValueError(f"{algorithm} is no available algorithm")
+ */
+      __pyx_t_7 = __Pyx_PyObject_FormatSimple(__pyx_v_algorithm, __pyx_empty_unicode); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 123, __pyx_L5_except_error)
+      __Pyx_GOTREF(__pyx_t_7);
+      __pyx_t_8 = __Pyx_PyUnicode_Concat(__pyx_t_7, __pyx_kp_u_is_no_available_algorithm); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 123, __pyx_L5_except_error)
+      __Pyx_GOTREF(__pyx_t_8);
+      __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
+      __pyx_t_7 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_8); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 123, __pyx_L5_except_error)
+      __Pyx_GOTREF(__pyx_t_7);
+      __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
+      __Pyx_Raise(__pyx_t_7, 0, 0, 0);
+      __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
+      __PYX_ERR(0, 123, __pyx_L5_except_error)
+    }
+    __pyx_L5_except_error:;
+
+    /* "crf.pyx":120
+ * 
+ *     def select_algorithm(self, algorithm: str):
+ *         try:             # <<<<<<<<<<<<<<
+ *             algorithm = self._algorithm_aliases[algorithm.lower()]
+ *         except:
+ */
+    __Pyx_XGIVEREF(__pyx_t_1);
+    __Pyx_XGIVEREF(__pyx_t_2);
+    __Pyx_XGIVEREF(__pyx_t_3);
+    __Pyx_ExceptionReset(__pyx_t_1, __pyx_t_2, __pyx_t_3);
+    goto __pyx_L1_error;
+    __pyx_L8_try_end:;
+  }
+
+  /* "crf.pyx":124
+ *         except:
+ *             raise ValueError(f"{algorithm} is no available algorithm")
+ *         if not self._trainer.select(algorithm, "crf1d"):             # <<<<<<<<<<<<<<
+ *             raise ValueError(f"{algorithm} is no available algorithm")
+ * 
+ */
+  __pyx_t_9 = __pyx_convert_string_from_py_std__in_string(__pyx_v_algorithm); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 124, __pyx_L1_error)
+  __pyx_t_10 = __pyx_convert_string_from_py_std__in_string(__pyx_n_b_crf1d); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 124, __pyx_L1_error)
+  try {
+    __pyx_t_11 = __pyx_v_self->_trainer.select(__pyx_t_9, __pyx_t_10);
+  } catch(...) {
+    __Pyx_CppExn2PyErr();
+    __PYX_ERR(0, 124, __pyx_L1_error)
+  }
+  __pyx_t_12 = ((!(__pyx_t_11 != 0)) != 0);
+  if (unlikely(__pyx_t_12)) {
+
+    /* "crf.pyx":125
+ *             raise ValueError(f"{algorithm} is no available algorithm")
+ *         if not self._trainer.select(algorithm, "crf1d"):
+ *             raise ValueError(f"{algorithm} is no available algorithm")             # <<<<<<<<<<<<<<
+ * 
+ *     def set_params(self, params: dict[str, str | int | float | bool]):
+ */
+    __pyx_t_4 = __Pyx_PyObject_FormatSimple(__pyx_v_algorithm, __pyx_empty_unicode); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 125, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_4);
+    __pyx_t_5 = __Pyx_PyUnicode_Concat(__pyx_t_4, __pyx_kp_u_is_no_available_algorithm); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 125, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_5);
+    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+    __pyx_t_4 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_5); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 125, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_4);
+    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+    __Pyx_Raise(__pyx_t_4, 0, 0, 0);
+    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+    __PYX_ERR(0, 125, __pyx_L1_error)
+
+    /* "crf.pyx":124
+ *         except:
+ *             raise ValueError(f"{algorithm} is no available algorithm")
+ *         if not self._trainer.select(algorithm, "crf1d"):             # <<<<<<<<<<<<<<
+ *             raise ValueError(f"{algorithm} is no available algorithm")
+ * 
+ */
+  }
+
+  /* "crf.pyx":119
+ *         }
+ * 
+ *     def select_algorithm(self, algorithm: str):             # <<<<<<<<<<<<<<
+ *         try:
+ *             algorithm = self._algorithm_aliases[algorithm.lower()]
+ */
+
+  /* function exit code */
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_4);
+  __Pyx_XDECREF(__pyx_t_5);
+  __Pyx_XDECREF(__pyx_t_6);
+  __Pyx_XDECREF(__pyx_t_7);
+  __Pyx_XDECREF(__pyx_t_8);
+  __Pyx_AddTraceback("crf.Trainer.select_algorithm", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_XDECREF(__pyx_v_algorithm);
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "crf.pyx":127
+ *             raise ValueError(f"{algorithm} is no available algorithm")
+ * 
+ *     def set_params(self, params: dict[str, str | int | float | bool]):             # <<<<<<<<<<<<<<
+ *         for param, value in params.items():
+ *             self.set_param(param, value)
+ */
+
+/* Python wrapper */
+static PyObject *__pyx_pw_3crf_7Trainer_15set_params(PyObject *__pyx_v_self, PyObject *__pyx_v_params); /*proto*/
+static char __pyx_doc_3crf_7Trainer_14set_params[] = "Trainer.set_params(self, params: dict[str, str | int | float | bool])";
+static PyObject *__pyx_pw_3crf_7Trainer_15set_params(PyObject *__pyx_v_self, PyObject *__pyx_v_params) {
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("set_params (wrapper)", 0);
+  __pyx_r = __pyx_pf_3crf_7Trainer_14set_params(((struct __pyx_obj_3crf_Trainer *)__pyx_v_self), ((PyObject *)__pyx_v_params));
+
+  /* function exit code */
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+static PyObject *__pyx_pf_3crf_7Trainer_14set_params(struct __pyx_obj_3crf_Trainer *__pyx_v_self, PyObject *__pyx_v_params) {
+  PyObject *__pyx_v_param = NULL;
+  PyObject *__pyx_v_value = NULL;
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  PyObject *__pyx_t_2 = NULL;
+  PyObject *__pyx_t_3 = NULL;
+  Py_ssize_t __pyx_t_4;
+  PyObject *(*__pyx_t_5)(PyObject *);
+  PyObject *__pyx_t_6 = NULL;
+  PyObject *__pyx_t_7 = NULL;
+  PyObject *(*__pyx_t_8)(PyObject *);
+  int __pyx_t_9;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("set_params", 0);
+
+  /* "crf.pyx":128
+ * 
+ *     def set_params(self, params: dict[str, str | int | float | bool]):
+ *         for param, value in params.items():             # <<<<<<<<<<<<<<
+ *             self.set_param(param, value)
+ * 
+ */
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_params, __pyx_n_s_items); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 128, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  __pyx_t_3 = NULL;
+  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
+    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
+    if (likely(__pyx_t_3)) {
+      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
+      __Pyx_INCREF(__pyx_t_3);
+      __Pyx_INCREF(function);
+      __Pyx_DECREF_SET(__pyx_t_2, function);
+    }
+  }
+  __pyx_t_1 = (__pyx_t_3) ? __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_3) : __Pyx_PyObject_CallNoArg(__pyx_t_2);
+  __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
+  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 128, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  if (likely(PyList_CheckExact(__pyx_t_1)) || PyTuple_CheckExact(__pyx_t_1)) {
+    __pyx_t_2 = __pyx_t_1; __Pyx_INCREF(__pyx_t_2); __pyx_t_4 = 0;
+    __pyx_t_5 = NULL;
+  } else {
+    __pyx_t_4 = -1; __pyx_t_2 = PyObject_GetIter(__pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 128, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_2);
+    __pyx_t_5 = Py_TYPE(__pyx_t_2)->tp_iternext; if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 128, __pyx_L1_error)
+  }
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  for (;;) {
+    if (likely(!__pyx_t_5)) {
+      if (likely(PyList_CheckExact(__pyx_t_2))) {
+        if (__pyx_t_4 >= PyList_GET_SIZE(__pyx_t_2)) break;
+        #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
+        __pyx_t_1 = PyList_GET_ITEM(__pyx_t_2, __pyx_t_4); __Pyx_INCREF(__pyx_t_1); __pyx_t_4++; if (unlikely(0 < 0)) __PYX_ERR(0, 128, __pyx_L1_error)
+        #else
+        __pyx_t_1 = PySequence_ITEM(__pyx_t_2, __pyx_t_4); __pyx_t_4++; if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 128, __pyx_L1_error)
+        __Pyx_GOTREF(__pyx_t_1);
+        #endif
+      } else {
+        if (__pyx_t_4 >= PyTuple_GET_SIZE(__pyx_t_2)) break;
+        #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
+        __pyx_t_1 = PyTuple_GET_ITEM(__pyx_t_2, __pyx_t_4); __Pyx_INCREF(__pyx_t_1); __pyx_t_4++; if (unlikely(0 < 0)) __PYX_ERR(0, 128, __pyx_L1_error)
+        #else
+        __pyx_t_1 = PySequence_ITEM(__pyx_t_2, __pyx_t_4); __pyx_t_4++; if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 128, __pyx_L1_error)
+        __Pyx_GOTREF(__pyx_t_1);
+        #endif
+      }
+    } else {
+      __pyx_t_1 = __pyx_t_5(__pyx_t_2);
+      if (unlikely(!__pyx_t_1)) {
+        PyObject* exc_type = PyErr_Occurred();
+        if (exc_type) {
+          if (likely(__Pyx_PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
+          else __PYX_ERR(0, 128, __pyx_L1_error)
+        }
+        break;
+      }
+      __Pyx_GOTREF(__pyx_t_1);
+    }
+    if ((likely(PyTuple_CheckExact(__pyx_t_1))) || (PyList_CheckExact(__pyx_t_1))) {
+      PyObject* sequence = __pyx_t_1;
+      Py_ssize_t size = __Pyx_PySequence_SIZE(sequence);
+      if (unlikely(size != 2)) {
+        if (size > 2) __Pyx_RaiseTooManyValuesError(2);
+        else if (size >= 0) __Pyx_RaiseNeedMoreValuesError(size);
+        __PYX_ERR(0, 128, __pyx_L1_error)
+      }
+      #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
+      if (likely(PyTuple_CheckExact(sequence))) {
+        __pyx_t_3 = PyTuple_GET_ITEM(sequence, 0); 
+        __pyx_t_6 = PyTuple_GET_ITEM(sequence, 1); 
+      } else {
+        __pyx_t_3 = PyList_GET_ITEM(sequence, 0); 
+        __pyx_t_6 = PyList_GET_ITEM(sequence, 1); 
+      }
+      __Pyx_INCREF(__pyx_t_3);
+      __Pyx_INCREF(__pyx_t_6);
+      #else
+      __pyx_t_3 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 128, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_3);
+      __pyx_t_6 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 128, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_6);
+      #endif
+      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+    } else {
+      Py_ssize_t index = -1;
+      __pyx_t_7 = PyObject_GetIter(__pyx_t_1); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 128, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_7);
+      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+      __pyx_t_8 = Py_TYPE(__pyx_t_7)->tp_iternext;
+      index = 0; __pyx_t_3 = __pyx_t_8(__pyx_t_7); if (unlikely(!__pyx_t_3)) goto __pyx_L5_unpacking_failed;
+      __Pyx_GOTREF(__pyx_t_3);
+      index = 1; __pyx_t_6 = __pyx_t_8(__pyx_t_7); if (unlikely(!__pyx_t_6)) goto __pyx_L5_unpacking_failed;
+      __Pyx_GOTREF(__pyx_t_6);
+      if (__Pyx_IternextUnpackEndCheck(__pyx_t_8(__pyx_t_7), 2) < 0) __PYX_ERR(0, 128, __pyx_L1_error)
+      __pyx_t_8 = NULL;
+      __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
+      goto __pyx_L6_unpacking_done;
+      __pyx_L5_unpacking_failed:;
+      __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
+      __pyx_t_8 = NULL;
+      if (__Pyx_IterFinish() == 0) __Pyx_RaiseNeedMoreValuesError(index);
+      __PYX_ERR(0, 128, __pyx_L1_error)
+      __pyx_L6_unpacking_done:;
+    }
+    __Pyx_XDECREF_SET(__pyx_v_param, __pyx_t_3);
+    __pyx_t_3 = 0;
+    __Pyx_XDECREF_SET(__pyx_v_value, __pyx_t_6);
+    __pyx_t_6 = 0;
+
+    /* "crf.pyx":129
+ *     def set_params(self, params: dict[str, str | int | float | bool]):
+ *         for param, value in params.items():
+ *             self.set_param(param, value)             # <<<<<<<<<<<<<<
+ * 
+ *     def set_param(self, param: str, value: str | int | float | bool):
+ */
+    __pyx_t_6 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_set_param); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 129, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_6);
+    __pyx_t_3 = NULL;
+    __pyx_t_9 = 0;
+    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_6))) {
+      __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_6);
+      if (likely(__pyx_t_3)) {
+        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_6);
+        __Pyx_INCREF(__pyx_t_3);
+        __Pyx_INCREF(function);
+        __Pyx_DECREF_SET(__pyx_t_6, function);
+        __pyx_t_9 = 1;
+      }
+    }
+    #if CYTHON_FAST_PYCALL
+    if (PyFunction_Check(__pyx_t_6)) {
+      PyObject *__pyx_temp[3] = {__pyx_t_3, __pyx_v_param, __pyx_v_value};
+      __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_6, __pyx_temp+1-__pyx_t_9, 2+__pyx_t_9); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 129, __pyx_L1_error)
+      __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
+      __Pyx_GOTREF(__pyx_t_1);
+    } else
+    #endif
+    #if CYTHON_FAST_PYCCALL
+    if (__Pyx_PyFastCFunction_Check(__pyx_t_6)) {
+      PyObject *__pyx_temp[3] = {__pyx_t_3, __pyx_v_param, __pyx_v_value};
+      __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_6, __pyx_temp+1-__pyx_t_9, 2+__pyx_t_9); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 129, __pyx_L1_error)
+      __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
+      __Pyx_GOTREF(__pyx_t_1);
+    } else
+    #endif
+    {
+      __pyx_t_7 = PyTuple_New(2+__pyx_t_9); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 129, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_7);
+      if (__pyx_t_3) {
+        __Pyx_GIVEREF(__pyx_t_3); PyTuple_SET_ITEM(__pyx_t_7, 0, __pyx_t_3); __pyx_t_3 = NULL;
+      }
+      __Pyx_INCREF(__pyx_v_param);
+      __Pyx_GIVEREF(__pyx_v_param);
+      PyTuple_SET_ITEM(__pyx_t_7, 0+__pyx_t_9, __pyx_v_param);
+      __Pyx_INCREF(__pyx_v_value);
+      __Pyx_GIVEREF(__pyx_v_value);
+      PyTuple_SET_ITEM(__pyx_t_7, 1+__pyx_t_9, __pyx_v_value);
+      __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_6, __pyx_t_7, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 129, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_1);
+      __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
+    }
+    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
+    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+    /* "crf.pyx":128
+ * 
+ *     def set_params(self, params: dict[str, str | int | float | bool]):
+ *         for param, value in params.items():             # <<<<<<<<<<<<<<
+ *             self.set_param(param, value)
+ * 
+ */
+  }
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+
+  /* "crf.pyx":127
+ *             raise ValueError(f"{algorithm} is no available algorithm")
+ * 
+ *     def set_params(self, params: dict[str, str | int | float | bool]):             # <<<<<<<<<<<<<<
+ *         for param, value in params.items():
+ *             self.set_param(param, value)
+ */
+
+  /* function exit code */
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_XDECREF(__pyx_t_2);
+  __Pyx_XDECREF(__pyx_t_3);
+  __Pyx_XDECREF(__pyx_t_6);
+  __Pyx_XDECREF(__pyx_t_7);
+  __Pyx_AddTraceback("crf.Trainer.set_params", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_XDECREF(__pyx_v_param);
+  __Pyx_XDECREF(__pyx_v_value);
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "crf.pyx":131
+ *             self.set_param(param, value)
+ * 
+ *     def set_param(self, param: str, value: str | int | float | bool):             # <<<<<<<<<<<<<<
+ *         if isinstance(value, bool):
+ *             value = int(value)
+ */
+
+/* Python wrapper */
+static PyObject *__pyx_pw_3crf_7Trainer_17set_param(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
+static char __pyx_doc_3crf_7Trainer_16set_param[] = "Trainer.set_param(self, str param: str, value: str | int | float | bool)";
+static PyObject *__pyx_pw_3crf_7Trainer_17set_param(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
+  PyObject *__pyx_v_param = 0;
+  PyObject *__pyx_v_value = 0;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("set_param (wrapper)", 0);
+  {
+    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_param,&__pyx_n_s_value,0};
+    PyObject* values[2] = {0,0};
+    if (unlikely(__pyx_kwds)) {
+      Py_ssize_t kw_args;
+      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
+      switch (pos_args) {
+        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
+        CYTHON_FALLTHROUGH;
+        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
+        CYTHON_FALLTHROUGH;
+        case  0: break;
+        default: goto __pyx_L5_argtuple_error;
+      }
+      kw_args = PyDict_Size(__pyx_kwds);
+      switch (pos_args) {
+        case  0:
+        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_param)) != 0)) kw_args--;
+        else goto __pyx_L5_argtuple_error;
+        CYTHON_FALLTHROUGH;
+        case  1:
+        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_value)) != 0)) kw_args--;
+        else {
+          __Pyx_RaiseArgtupleInvalid("set_param", 1, 2, 2, 1); __PYX_ERR(0, 131, __pyx_L3_error)
+        }
+      }
+      if (unlikely(kw_args > 0)) {
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "set_param") < 0)) __PYX_ERR(0, 131, __pyx_L3_error)
+      }
+    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
+      goto __pyx_L5_argtuple_error;
+    } else {
+      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
+      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
+    }
+    __pyx_v_param = ((PyObject*)values[0]);
+    __pyx_v_value = values[1];
+  }
+  goto __pyx_L4_argument_unpacking_done;
+  __pyx_L5_argtuple_error:;
+  __Pyx_RaiseArgtupleInvalid("set_param", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 131, __pyx_L3_error)
+  __pyx_L3_error:;
+  __Pyx_AddTraceback("crf.Trainer.set_param", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_RefNannyFinishContext();
+  return NULL;
+  __pyx_L4_argument_unpacking_done:;
+  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_param), (&PyString_Type), 1, "param", 1))) __PYX_ERR(0, 131, __pyx_L1_error)
+  __pyx_r = __pyx_pf_3crf_7Trainer_16set_param(((struct __pyx_obj_3crf_Trainer *)__pyx_v_self), __pyx_v_param, __pyx_v_value);
+
+  /* function exit code */
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+static PyObject *__pyx_pf_3crf_7Trainer_16set_param(struct __pyx_obj_3crf_Trainer *__pyx_v_self, PyObject *__pyx_v_param, PyObject *__pyx_v_value) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  int __pyx_t_2;
+  int __pyx_t_3;
+  std::string __pyx_t_4;
+  std::string __pyx_t_5;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("set_param", 0);
+  __Pyx_INCREF(__pyx_v_value);
+
+  /* "crf.pyx":132
+ * 
+ *     def set_param(self, param: str, value: str | int | float | bool):
+ *         if isinstance(value, bool):             # <<<<<<<<<<<<<<
+ *             value = int(value)
+ *         self._trainer.set(param, str(value))
+ */
+  __pyx_t_1 = ((PyObject*)&PyBool_Type);
+  __Pyx_INCREF(__pyx_t_1);
+  __pyx_t_2 = PyObject_IsInstance(__pyx_v_value, __pyx_t_1); if (unlikely(__pyx_t_2 == ((int)-1))) __PYX_ERR(0, 132, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __pyx_t_3 = (__pyx_t_2 != 0);
+  if (__pyx_t_3) {
+
+    /* "crf.pyx":133
+ *     def set_param(self, param: str, value: str | int | float | bool):
+ *         if isinstance(value, bool):
+ *             value = int(value)             # <<<<<<<<<<<<<<
+ *         self._trainer.set(param, str(value))
+ * 
+ */
+    __pyx_t_1 = __Pyx_PyNumber_Int(__pyx_v_value); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 133, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_1);
+    __Pyx_DECREF_SET(__pyx_v_value, __pyx_t_1);
+    __pyx_t_1 = 0;
+
+    /* "crf.pyx":132
+ * 
+ *     def set_param(self, param: str, value: str | int | float | bool):
+ *         if isinstance(value, bool):             # <<<<<<<<<<<<<<
+ *             value = int(value)
+ *         self._trainer.set(param, str(value))
+ */
+  }
+
+  /* "crf.pyx":134
+ *         if isinstance(value, bool):
+ *             value = int(value)
+ *         self._trainer.set(param, str(value))             # <<<<<<<<<<<<<<
+ * 
+ *     def get_param(self, param: str):
+ */
+  __pyx_t_4 = __pyx_convert_string_from_py_std__in_string(__pyx_v_param); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 134, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_CallOneArg(((PyObject *)(&PyString_Type)), __pyx_v_value); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 134, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_t_5 = __pyx_convert_string_from_py_std__in_string(__pyx_t_1); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 134, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  try {
+    __pyx_v_self->_trainer.set(__pyx_t_4, __pyx_t_5);
+  } catch(...) {
+    __Pyx_CppExn2PyErr();
+    __PYX_ERR(0, 134, __pyx_L1_error)
+  }
+
+  /* "crf.pyx":131
+ *             self.set_param(param, value)
+ * 
+ *     def set_param(self, param: str, value: str | int | float | bool):             # <<<<<<<<<<<<<<
+ *         if isinstance(value, bool):
+ *             value = int(value)
+ */
+
+  /* function exit code */
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_AddTraceback("crf.Trainer.set_param", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_XDECREF(__pyx_v_value);
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "crf.pyx":136
+ *         self._trainer.set(param, str(value))
+ * 
+ *     def get_param(self, param: str):             # <<<<<<<<<<<<<<
+ *         return self.cast_parameter(param, self._trainer.get(param))
+ * 
+ */
+
+/* Python wrapper */
+static PyObject *__pyx_pw_3crf_7Trainer_19get_param(PyObject *__pyx_v_self, PyObject *__pyx_v_param); /*proto*/
+static char __pyx_doc_3crf_7Trainer_18get_param[] = "Trainer.get_param(self, str param: str)";
+static PyObject *__pyx_pw_3crf_7Trainer_19get_param(PyObject *__pyx_v_self, PyObject *__pyx_v_param) {
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("get_param (wrapper)", 0);
+  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_param), (&PyString_Type), 1, "param", 1))) __PYX_ERR(0, 136, __pyx_L1_error)
+  __pyx_r = __pyx_pf_3crf_7Trainer_18get_param(((struct __pyx_obj_3crf_Trainer *)__pyx_v_self), ((PyObject*)__pyx_v_param));
+
+  /* function exit code */
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+static PyObject *__pyx_pf_3crf_7Trainer_18get_param(struct __pyx_obj_3crf_Trainer *__pyx_v_self, PyObject *__pyx_v_param) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  PyObject *__pyx_t_2 = NULL;
+  std::string __pyx_t_3;
+  std::string __pyx_t_4;
+  PyObject *__pyx_t_5 = NULL;
+  PyObject *__pyx_t_6 = NULL;
+  int __pyx_t_7;
+  PyObject *__pyx_t_8 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("get_param", 0);
+
+  /* "crf.pyx":137
+ * 
+ *     def get_param(self, param: str):
+ *         return self.cast_parameter(param, self._trainer.get(param))             # <<<<<<<<<<<<<<
+ * 
+ *     def cast_parameter(self, param: str, value: str | int | float | bool):
+ */
+  __Pyx_XDECREF(__pyx_r);
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_cast_parameter); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 137, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  __pyx_t_3 = __pyx_convert_string_from_py_std__in_string(__pyx_v_param); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 137, __pyx_L1_error)
+  try {
+    __pyx_t_4 = __pyx_v_self->_trainer.get(__pyx_t_3);
+  } catch(...) {
+    __Pyx_CppExn2PyErr();
+    __PYX_ERR(0, 137, __pyx_L1_error)
+  }
+  __pyx_t_5 = __pyx_convert_PyStr_string_to_py_std__in_string(__pyx_t_4); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 137, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_5);
+  __pyx_t_6 = NULL;
+  __pyx_t_7 = 0;
+  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
+    __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_2);
+    if (likely(__pyx_t_6)) {
+      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
+      __Pyx_INCREF(__pyx_t_6);
+      __Pyx_INCREF(function);
+      __Pyx_DECREF_SET(__pyx_t_2, function);
+      __pyx_t_7 = 1;
+    }
+  }
+  #if CYTHON_FAST_PYCALL
+  if (PyFunction_Check(__pyx_t_2)) {
+    PyObject *__pyx_temp[3] = {__pyx_t_6, __pyx_v_param, __pyx_t_5};
+    __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_7, 2+__pyx_t_7); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 137, __pyx_L1_error)
+    __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
+    __Pyx_GOTREF(__pyx_t_1);
+    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+  } else
+  #endif
+  #if CYTHON_FAST_PYCCALL
+  if (__Pyx_PyFastCFunction_Check(__pyx_t_2)) {
+    PyObject *__pyx_temp[3] = {__pyx_t_6, __pyx_v_param, __pyx_t_5};
+    __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_7, 2+__pyx_t_7); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 137, __pyx_L1_error)
+    __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
+    __Pyx_GOTREF(__pyx_t_1);
+    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+  } else
+  #endif
+  {
+    __pyx_t_8 = PyTuple_New(2+__pyx_t_7); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 137, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_8);
+    if (__pyx_t_6) {
+      __Pyx_GIVEREF(__pyx_t_6); PyTuple_SET_ITEM(__pyx_t_8, 0, __pyx_t_6); __pyx_t_6 = NULL;
+    }
+    __Pyx_INCREF(__pyx_v_param);
+    __Pyx_GIVEREF(__pyx_v_param);
+    PyTuple_SET_ITEM(__pyx_t_8, 0+__pyx_t_7, __pyx_v_param);
+    __Pyx_GIVEREF(__pyx_t_5);
+    PyTuple_SET_ITEM(__pyx_t_8, 1+__pyx_t_7, __pyx_t_5);
+    __pyx_t_5 = 0;
+    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_8, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 137, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_1);
+    __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
+  }
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __pyx_r = __pyx_t_1;
+  __pyx_t_1 = 0;
+  goto __pyx_L0;
+
+  /* "crf.pyx":136
+ *         self._trainer.set(param, str(value))
+ * 
+ *     def get_param(self, param: str):             # <<<<<<<<<<<<<<
+ *         return self.cast_parameter(param, self._trainer.get(param))
+ * 
+ */
+
+  /* function exit code */
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_XDECREF(__pyx_t_2);
+  __Pyx_XDECREF(__pyx_t_5);
+  __Pyx_XDECREF(__pyx_t_6);
+  __Pyx_XDECREF(__pyx_t_8);
+  __Pyx_AddTraceback("crf.Trainer.get_param", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "crf.pyx":139
+ *         return self.cast_parameter(param, self._trainer.get(param))
+ * 
+ *     def cast_parameter(self, param: str, value: str | int | float | bool):             # <<<<<<<<<<<<<<
+ *         if param in self._parameter_types:
+ *             return self._parameter_types[param](value)
+ */
+
+/* Python wrapper */
+static PyObject *__pyx_pw_3crf_7Trainer_21cast_parameter(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
+static char __pyx_doc_3crf_7Trainer_20cast_parameter[] = "Trainer.cast_parameter(self, str param: str, value: str | int | float | bool)";
+static PyObject *__pyx_pw_3crf_7Trainer_21cast_parameter(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
+  PyObject *__pyx_v_param = 0;
+  PyObject *__pyx_v_value = 0;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("cast_parameter (wrapper)", 0);
+  {
+    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_param,&__pyx_n_s_value,0};
+    PyObject* values[2] = {0,0};
+    if (unlikely(__pyx_kwds)) {
+      Py_ssize_t kw_args;
+      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
+      switch (pos_args) {
+        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
+        CYTHON_FALLTHROUGH;
+        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
+        CYTHON_FALLTHROUGH;
+        case  0: break;
+        default: goto __pyx_L5_argtuple_error;
+      }
+      kw_args = PyDict_Size(__pyx_kwds);
+      switch (pos_args) {
+        case  0:
+        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_param)) != 0)) kw_args--;
+        else goto __pyx_L5_argtuple_error;
+        CYTHON_FALLTHROUGH;
+        case  1:
+        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_value)) != 0)) kw_args--;
+        else {
+          __Pyx_RaiseArgtupleInvalid("cast_parameter", 1, 2, 2, 1); __PYX_ERR(0, 139, __pyx_L3_error)
+        }
+      }
+      if (unlikely(kw_args > 0)) {
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "cast_parameter") < 0)) __PYX_ERR(0, 139, __pyx_L3_error)
+      }
+    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
+      goto __pyx_L5_argtuple_error;
+    } else {
+      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
+      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
+    }
+    __pyx_v_param = ((PyObject*)values[0]);
+    __pyx_v_value = values[1];
+  }
+  goto __pyx_L4_argument_unpacking_done;
+  __pyx_L5_argtuple_error:;
+  __Pyx_RaiseArgtupleInvalid("cast_parameter", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 139, __pyx_L3_error)
+  __pyx_L3_error:;
+  __Pyx_AddTraceback("crf.Trainer.cast_parameter", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_RefNannyFinishContext();
+  return NULL;
+  __pyx_L4_argument_unpacking_done:;
+  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_param), (&PyString_Type), 1, "param", 1))) __PYX_ERR(0, 139, __pyx_L1_error)
+  __pyx_r = __pyx_pf_3crf_7Trainer_20cast_parameter(((struct __pyx_obj_3crf_Trainer *)__pyx_v_self), __pyx_v_param, __pyx_v_value);
+
+  /* function exit code */
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+static PyObject *__pyx_pf_3crf_7Trainer_20cast_parameter(struct __pyx_obj_3crf_Trainer *__pyx_v_self, PyObject *__pyx_v_param, PyObject *__pyx_v_value) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  int __pyx_t_2;
+  int __pyx_t_3;
+  PyObject *__pyx_t_4 = NULL;
+  PyObject *__pyx_t_5 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("cast_parameter", 0);
+
+  /* "crf.pyx":140
+ * 
+ *     def cast_parameter(self, param: str, value: str | int | float | bool):
+ *         if param in self._parameter_types:             # <<<<<<<<<<<<<<
+ *             return self._parameter_types[param](value)
+ *         return value
+ */
+  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_parameter_types); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 140, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_t_2 = (__Pyx_PySequence_ContainsTF(__pyx_v_param, __pyx_t_1, Py_EQ)); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 140, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __pyx_t_3 = (__pyx_t_2 != 0);
+  if (__pyx_t_3) {
+
+    /* "crf.pyx":141
+ *     def cast_parameter(self, param: str, value: str | int | float | bool):
+ *         if param in self._parameter_types:
+ *             return self._parameter_types[param](value)             # <<<<<<<<<<<<<<
+ *         return value
+ * 
+ */
+    __Pyx_XDECREF(__pyx_r);
+    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_parameter_types); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 141, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_4);
+    __pyx_t_5 = __Pyx_PyObject_Dict_GetItem(__pyx_t_4, __pyx_v_param); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 141, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_5);
+    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+    __pyx_t_4 = NULL;
+    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_5))) {
+      __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_5);
+      if (likely(__pyx_t_4)) {
+        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
+        __Pyx_INCREF(__pyx_t_4);
+        __Pyx_INCREF(function);
+        __Pyx_DECREF_SET(__pyx_t_5, function);
+      }
+    }
+    __pyx_t_1 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_5, __pyx_t_4, __pyx_v_value) : __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_v_value);
+    __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
+    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 141, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_1);
+    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+    __pyx_r = __pyx_t_1;
+    __pyx_t_1 = 0;
+    goto __pyx_L0;
+
+    /* "crf.pyx":140
+ * 
+ *     def cast_parameter(self, param: str, value: str | int | float | bool):
+ *         if param in self._parameter_types:             # <<<<<<<<<<<<<<
+ *             return self._parameter_types[param](value)
+ *         return value
+ */
+  }
+
+  /* "crf.pyx":142
+ *         if param in self._parameter_types:
+ *             return self._parameter_types[param](value)
+ *         return value             # <<<<<<<<<<<<<<
+ * 
+ * 
+ */
+  __Pyx_XDECREF(__pyx_r);
+  __Pyx_INCREF(__pyx_v_value);
+  __pyx_r = __pyx_v_value;
+  goto __pyx_L0;
+
+  /* "crf.pyx":139
+ *         return self.cast_parameter(param, self._trainer.get(param))
+ * 
+ *     def cast_parameter(self, param: str, value: str | int | float | bool):             # <<<<<<<<<<<<<<
+ *         if param in self._parameter_types:
+ *             return self._parameter_types[param](value)
+ */
+
+  /* function exit code */
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_XDECREF(__pyx_t_4);
+  __Pyx_XDECREF(__pyx_t_5);
+  __Pyx_AddTraceback("crf.Trainer.cast_parameter", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "(tree fragment)":1
+ * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
+ *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
+ * def __setstate_cython__(self, __pyx_state):
+ */
+
+/* Python wrapper */
+static PyObject *__pyx_pw_3crf_7Trainer_27__reduce_cython__(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
+static char __pyx_doc_3crf_7Trainer_26__reduce_cython__[] = "Trainer.__reduce_cython__(self)";
+static PyObject *__pyx_pw_3crf_7Trainer_27__reduce_cython__(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("__reduce_cython__ (wrapper)", 0);
+  __pyx_r = __pyx_pf_3crf_7Trainer_26__reduce_cython__(((struct __pyx_obj_3crf_Trainer *)__pyx_v_self));
+
+  /* function exit code */
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+static PyObject *__pyx_pf_3crf_7Trainer_26__reduce_cython__(CYTHON_UNUSED struct __pyx_obj_3crf_Trainer *__pyx_v_self) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("__reduce_cython__", 0);
+
+  /* "(tree fragment)":2
+ * def __reduce_cython__(self):
+ *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
+ * def __setstate_cython__(self, __pyx_state):
+ *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
+ */
+  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple_, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 2, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_Raise(__pyx_t_1, 0, 0, 0);
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __PYX_ERR(1, 2, __pyx_L1_error)
+
+  /* "(tree fragment)":1
+ * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
+ *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
+ * def __setstate_cython__(self, __pyx_state):
+ */
+
+  /* function exit code */
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_AddTraceback("crf.Trainer.__reduce_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = NULL;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "(tree fragment)":3
+ * def __reduce_cython__(self):
+ *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
+ * def __setstate_cython__(self, __pyx_state):             # <<<<<<<<<<<<<<
+ *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
+ */
+
+/* Python wrapper */
+static PyObject *__pyx_pw_3crf_7Trainer_29__setstate_cython__(PyObject *__pyx_v_self, PyObject *__pyx_v___pyx_state); /*proto*/
+static char __pyx_doc_3crf_7Trainer_28__setstate_cython__[] = "Trainer.__setstate_cython__(self, __pyx_state)";
+static PyObject *__pyx_pw_3crf_7Trainer_29__setstate_cython__(PyObject *__pyx_v_self, PyObject *__pyx_v___pyx_state) {
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("__setstate_cython__ (wrapper)", 0);
+  __pyx_r = __pyx_pf_3crf_7Trainer_28__setstate_cython__(((struct __pyx_obj_3crf_Trainer *)__pyx_v_self), ((PyObject *)__pyx_v___pyx_state));
+
+  /* function exit code */
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+static PyObject *__pyx_pf_3crf_7Trainer_28__setstate_cython__(CYTHON_UNUSED struct __pyx_obj_3crf_Trainer *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v___pyx_state) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("__setstate_cython__", 0);
+
+  /* "(tree fragment)":4
+ *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
+ * def __setstate_cython__(self, __pyx_state):
+ *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
+ */
+  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__2, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 4, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_Raise(__pyx_t_1, 0, 0, 0);
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __PYX_ERR(1, 4, __pyx_L1_error)
+
+  /* "(tree fragment)":3
+ * def __reduce_cython__(self):
+ *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
+ * def __setstate_cython__(self, __pyx_state):             # <<<<<<<<<<<<<<
+ *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
+ */
+
+  /* function exit code */
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_AddTraceback("crf.Trainer.__setstate_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = NULL;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "crf.pyx":148
+ *     cdef crfsuite_api.Tagger _tagger
+ * 
+ *     def __init__(self, model_filepath: Filepath):             # <<<<<<<<<<<<<<
+ *         self.load(model_filepath)
+ * 
+ */
+
+/* Python wrapper */
+static int __pyx_pw_3crf_5Model_1__init__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
+static int __pyx_pw_3crf_5Model_1__init__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
+  PyObject *__pyx_v_model_filepath = 0;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("__init__ (wrapper)", 0);
+  {
+    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_model_filepath,0};
+    PyObject* values[1] = {0};
+    if (unlikely(__pyx_kwds)) {
+      Py_ssize_t kw_args;
+      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
+      switch (pos_args) {
+        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
+        CYTHON_FALLTHROUGH;
+        case  0: break;
+        default: goto __pyx_L5_argtuple_error;
+      }
+      kw_args = PyDict_Size(__pyx_kwds);
+      switch (pos_args) {
+        case  0:
+        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_model_filepath)) != 0)) kw_args--;
+        else goto __pyx_L5_argtuple_error;
+      }
+      if (unlikely(kw_args > 0)) {
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__init__") < 0)) __PYX_ERR(0, 148, __pyx_L3_error)
+      }
+    } else if (PyTuple_GET_SIZE(__pyx_args) != 1) {
+      goto __pyx_L5_argtuple_error;
+    } else {
+      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
+    }
+    __pyx_v_model_filepath = values[0];
+  }
+  goto __pyx_L4_argument_unpacking_done;
+  __pyx_L5_argtuple_error:;
+  __Pyx_RaiseArgtupleInvalid("__init__", 1, 1, 1, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 148, __pyx_L3_error)
+  __pyx_L3_error:;
+  __Pyx_AddTraceback("crf.Model.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_RefNannyFinishContext();
+  return -1;
+  __pyx_L4_argument_unpacking_done:;
+  __pyx_r = __pyx_pf_3crf_5Model___init__(((struct __pyx_obj_3crf_Model *)__pyx_v_self), __pyx_v_model_filepath);
+
+  /* function exit code */
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+static int __pyx_pf_3crf_5Model___init__(struct __pyx_obj_3crf_Model *__pyx_v_self, PyObject *__pyx_v_model_filepath) {
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  PyObject *__pyx_t_2 = NULL;
+  PyObject *__pyx_t_3 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("__init__", 0);
+
+  /* "crf.pyx":149
+ * 
+ *     def __init__(self, model_filepath: Filepath):
+ *         self.load(model_filepath)             # <<<<<<<<<<<<<<
+ * 
+ *     @property
+ */
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_load); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 149, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  __pyx_t_3 = NULL;
+  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
+    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
+    if (likely(__pyx_t_3)) {
+      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
+      __Pyx_INCREF(__pyx_t_3);
+      __Pyx_INCREF(function);
+      __Pyx_DECREF_SET(__pyx_t_2, function);
+    }
+  }
+  __pyx_t_1 = (__pyx_t_3) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_3, __pyx_v_model_filepath) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_v_model_filepath);
+  __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
+  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 149, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "crf.pyx":148
+ *     cdef crfsuite_api.Tagger _tagger
+ * 
+ *     def __init__(self, model_filepath: Filepath):             # <<<<<<<<<<<<<<
+ *         self.load(model_filepath)
+ * 
+ */
+
+  /* function exit code */
+  __pyx_r = 0;
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_XDECREF(__pyx_t_2);
+  __Pyx_XDECREF(__pyx_t_3);
+  __Pyx_AddTraceback("crf.Model.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = -1;
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "crf.pyx":152
+ * 
+ *     @property
+ *     def labels(self):             # <<<<<<<<<<<<<<
+ *         return self._tagger.labels()
+ * 
+ */
+
+/* Python wrapper */
+static PyObject *__pyx_pw_3crf_5Model_6labels_1__get__(PyObject *__pyx_v_self); /*proto*/
+static PyObject *__pyx_pw_3crf_5Model_6labels_1__get__(PyObject *__pyx_v_self) {
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("__get__ (wrapper)", 0);
+  __pyx_r = __pyx_pf_3crf_5Model_6labels___get__(((struct __pyx_obj_3crf_Model *)__pyx_v_self));
+
+  /* function exit code */
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+static PyObject *__pyx_pf_3crf_5Model_6labels___get__(struct __pyx_obj_3crf_Model *__pyx_v_self) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  CRFSuite::StringList __pyx_t_1;
+  PyObject *__pyx_t_2 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("__get__", 0);
+
+  /* "crf.pyx":153
+ *     @property
+ *     def labels(self):
+ *         return self._tagger.labels()             # <<<<<<<<<<<<<<
+ * 
+ *     def predict_single(self, sequence: Sequence) -> list[str]:
+ */
+  __Pyx_XDECREF(__pyx_r);
+  try {
+    __pyx_t_1 = __pyx_v_self->_tagger.labels();
+  } catch(...) {
+    __Pyx_CppExn2PyErr();
+    __PYX_ERR(0, 153, __pyx_L1_error)
+  }
+  __pyx_t_2 = __pyx_convert_vector_to_py_std_3a__3a_string(__pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 153, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  __pyx_r = __pyx_t_2;
+  __pyx_t_2 = 0;
+  goto __pyx_L0;
+
+  /* "crf.pyx":152
+ * 
+ *     @property
+ *     def labels(self):             # <<<<<<<<<<<<<<
+ *         return self._tagger.labels()
+ * 
+ */
+
+  /* function exit code */
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_2);
+  __Pyx_AddTraceback("crf.Model.labels.__get__", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "crf.pyx":155
+ *         return self._tagger.labels()
+ * 
+ *     def predict_single(self, sequence: Sequence) -> list[str]:             # <<<<<<<<<<<<<<
+ *         self.set_sequence(sequence)
+ *         return self._tagger.viterbi()
+ */
+
+/* Python wrapper */
+static PyObject *__pyx_pw_3crf_5Model_3predict_single(PyObject *__pyx_v_self, PyObject *__pyx_v_sequence); /*proto*/
+static char __pyx_doc_3crf_5Model_2predict_single[] = "Model.predict_single(self, sequence: Sequence) -> list[str]";
+static PyObject *__pyx_pw_3crf_5Model_3predict_single(PyObject *__pyx_v_self, PyObject *__pyx_v_sequence) {
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("predict_single (wrapper)", 0);
+  __pyx_r = __pyx_pf_3crf_5Model_2predict_single(((struct __pyx_obj_3crf_Model *)__pyx_v_self), ((PyObject *)__pyx_v_sequence));
+
+  /* function exit code */
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+static PyObject *__pyx_pf_3crf_5Model_2predict_single(struct __pyx_obj_3crf_Model *__pyx_v_self, PyObject *__pyx_v_sequence) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  CRFSuite::StringList __pyx_t_2;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("predict_single", 0);
+
+  /* "crf.pyx":156
+ * 
+ *     def predict_single(self, sequence: Sequence) -> list[str]:
+ *         self.set_sequence(sequence)             # <<<<<<<<<<<<<<
+ *         return self._tagger.viterbi()
+ * 
+ */
+  try {
+    __pyx_t_1 = ((struct __pyx_vtabstruct_3crf_Model *)__pyx_v_self->__pyx_vtab)->set_sequence(__pyx_v_self, __pyx_v_sequence, 0);
+    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 156, __pyx_L1_error)
+  } catch(...) {
+    __Pyx_CppExn2PyErr();
+    __PYX_ERR(0, 156, __pyx_L1_error)
+  }
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "crf.pyx":157
+ *     def predict_single(self, sequence: Sequence) -> list[str]:
+ *         self.set_sequence(sequence)
+ *         return self._tagger.viterbi()             # <<<<<<<<<<<<<<
+ * 
+ *     def predict_proba_single(self, sequence: Sequence) -> list[dict[str, float]]:
+ */
+  __Pyx_XDECREF(__pyx_r);
+  try {
+    __pyx_t_2 = __pyx_v_self->_tagger.viterbi();
+  } catch(...) {
+    __Pyx_CppExn2PyErr();
+    __PYX_ERR(0, 157, __pyx_L1_error)
+  }
+  __pyx_t_1 = __pyx_convert_vector_to_py_std_3a__3a_string(__pyx_t_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 157, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_r = __pyx_t_1;
+  __pyx_t_1 = 0;
+  goto __pyx_L0;
+
+  /* "crf.pyx":155
+ *         return self._tagger.labels()
+ * 
+ *     def predict_single(self, sequence: Sequence) -> list[str]:             # <<<<<<<<<<<<<<
+ *         self.set_sequence(sequence)
+ *         return self._tagger.viterbi()
+ */
+
+  /* function exit code */
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_AddTraceback("crf.Model.predict_single", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "crf.pyx":159
+ *         return self._tagger.viterbi()
+ * 
+ *     def predict_proba_single(self, sequence: Sequence) -> list[dict[str, float]]:             # <<<<<<<<<<<<<<
+ *         self.set_sequence(sequence)
+ *         return [
+ */
+
+/* Python wrapper */
+static PyObject *__pyx_pw_3crf_5Model_5predict_proba_single(PyObject *__pyx_v_self, PyObject *__pyx_v_sequence); /*proto*/
+static char __pyx_doc_3crf_5Model_4predict_proba_single[] = "Model.predict_proba_single(self, sequence: Sequence) -> list[dict[str, float]]";
+static PyObject *__pyx_pw_3crf_5Model_5predict_proba_single(PyObject *__pyx_v_self, PyObject *__pyx_v_sequence) {
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("predict_proba_single (wrapper)", 0);
+  __pyx_r = __pyx_pf_3crf_5Model_4predict_proba_single(((struct __pyx_obj_3crf_Model *)__pyx_v_self), ((PyObject *)__pyx_v_sequence));
+
+  /* function exit code */
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+static PyObject *__pyx_pf_3crf_5Model_4predict_proba_single(struct __pyx_obj_3crf_Model *__pyx_v_self, PyObject *__pyx_v_sequence) {
+  Py_ssize_t __pyx_v_index;
+  PyObject *__pyx_8genexpr1__pyx_v_label = NULL;
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  Py_ssize_t __pyx_t_2;
+  Py_ssize_t __pyx_t_3;
+  Py_ssize_t __pyx_t_4;
+  PyObject *__pyx_t_5 = NULL;
+  PyObject *__pyx_t_6 = NULL;
+  PyObject *__pyx_t_7 = NULL;
+  Py_ssize_t __pyx_t_8;
+  PyObject *(*__pyx_t_9)(PyObject *);
+  PyObject *__pyx_t_10 = NULL;
+  PyObject *__pyx_t_11 = NULL;
+  PyObject *__pyx_t_12 = NULL;
+  int __pyx_t_13;
+  PyObject *__pyx_t_14 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("predict_proba_single", 0);
+
+  /* "crf.pyx":160
+ * 
+ *     def predict_proba_single(self, sequence: Sequence) -> list[dict[str, float]]:
+ *         self.set_sequence(sequence)             # <<<<<<<<<<<<<<
+ *         return [
+ *             {label: self.marginal(label, index) for label in self.labels}
+ */
+  try {
+    __pyx_t_1 = ((struct __pyx_vtabstruct_3crf_Model *)__pyx_v_self->__pyx_vtab)->set_sequence(__pyx_v_self, __pyx_v_sequence, 0);
+    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 160, __pyx_L1_error)
+  } catch(...) {
+    __Pyx_CppExn2PyErr();
+    __PYX_ERR(0, 160, __pyx_L1_error)
+  }
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "crf.pyx":161
+ *     def predict_proba_single(self, sequence: Sequence) -> list[dict[str, float]]:
+ *         self.set_sequence(sequence)
+ *         return [             # <<<<<<<<<<<<<<
+ *             {label: self.marginal(label, index) for label in self.labels}
+ *             for index in range(len(sequence))
+ */
+  __Pyx_XDECREF(__pyx_r);
+  __pyx_t_1 = PyList_New(0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 161, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+
+  /* "crf.pyx":163
+ *         return [
+ *             {label: self.marginal(label, index) for label in self.labels}
+ *             for index in range(len(sequence))             # <<<<<<<<<<<<<<
+ *         ]
+ * 
+ */
+  __pyx_t_2 = PyObject_Length(__pyx_v_sequence); if (unlikely(__pyx_t_2 == ((Py_ssize_t)-1))) __PYX_ERR(0, 163, __pyx_L1_error)
+  __pyx_t_3 = __pyx_t_2;
+  for (__pyx_t_4 = 0; __pyx_t_4 < __pyx_t_3; __pyx_t_4+=1) {
+    __pyx_v_index = __pyx_t_4;
+    { /* enter inner scope */
+
+      /* "crf.pyx":162
+ *         self.set_sequence(sequence)
+ *         return [
+ *             {label: self.marginal(label, index) for label in self.labels}             # <<<<<<<<<<<<<<
+ *             for index in range(len(sequence))
+ *         ]
+ */
+      __pyx_t_5 = PyDict_New(); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 162, __pyx_L7_error)
+      __Pyx_GOTREF(__pyx_t_5);
+      __pyx_t_6 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_labels); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 162, __pyx_L7_error)
+      __Pyx_GOTREF(__pyx_t_6);
+      if (likely(PyList_CheckExact(__pyx_t_6)) || PyTuple_CheckExact(__pyx_t_6)) {
+        __pyx_t_7 = __pyx_t_6; __Pyx_INCREF(__pyx_t_7); __pyx_t_8 = 0;
+        __pyx_t_9 = NULL;
+      } else {
+        __pyx_t_8 = -1; __pyx_t_7 = PyObject_GetIter(__pyx_t_6); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 162, __pyx_L7_error)
+        __Pyx_GOTREF(__pyx_t_7);
+        __pyx_t_9 = Py_TYPE(__pyx_t_7)->tp_iternext; if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 162, __pyx_L7_error)
+      }
+      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
+      for (;;) {
+        if (likely(!__pyx_t_9)) {
+          if (likely(PyList_CheckExact(__pyx_t_7))) {
+            if (__pyx_t_8 >= PyList_GET_SIZE(__pyx_t_7)) break;
+            #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
+            __pyx_t_6 = PyList_GET_ITEM(__pyx_t_7, __pyx_t_8); __Pyx_INCREF(__pyx_t_6); __pyx_t_8++; if (unlikely(0 < 0)) __PYX_ERR(0, 162, __pyx_L7_error)
+            #else
+            __pyx_t_6 = PySequence_ITEM(__pyx_t_7, __pyx_t_8); __pyx_t_8++; if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 162, __pyx_L7_error)
+            __Pyx_GOTREF(__pyx_t_6);
+            #endif
+          } else {
+            if (__pyx_t_8 >= PyTuple_GET_SIZE(__pyx_t_7)) break;
+            #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
+            __pyx_t_6 = PyTuple_GET_ITEM(__pyx_t_7, __pyx_t_8); __Pyx_INCREF(__pyx_t_6); __pyx_t_8++; if (unlikely(0 < 0)) __PYX_ERR(0, 162, __pyx_L7_error)
+            #else
+            __pyx_t_6 = PySequence_ITEM(__pyx_t_7, __pyx_t_8); __pyx_t_8++; if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 162, __pyx_L7_error)
+            __Pyx_GOTREF(__pyx_t_6);
+            #endif
+          }
+        } else {
+          __pyx_t_6 = __pyx_t_9(__pyx_t_7);
+          if (unlikely(!__pyx_t_6)) {
+            PyObject* exc_type = PyErr_Occurred();
+            if (exc_type) {
+              if (likely(__Pyx_PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
+              else __PYX_ERR(0, 162, __pyx_L7_error)
+            }
+            break;
+          }
+          __Pyx_GOTREF(__pyx_t_6);
+        }
+        __Pyx_XDECREF_SET(__pyx_8genexpr1__pyx_v_label, __pyx_t_6);
+        __pyx_t_6 = 0;
+        __pyx_t_10 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_marginal); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 162, __pyx_L7_error)
+        __Pyx_GOTREF(__pyx_t_10);
+        __pyx_t_11 = PyInt_FromSsize_t(__pyx_v_index); if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 162, __pyx_L7_error)
+        __Pyx_GOTREF(__pyx_t_11);
+        __pyx_t_12 = NULL;
+        __pyx_t_13 = 0;
+        if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_10))) {
+          __pyx_t_12 = PyMethod_GET_SELF(__pyx_t_10);
+          if (likely(__pyx_t_12)) {
+            PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_10);
+            __Pyx_INCREF(__pyx_t_12);
+            __Pyx_INCREF(function);
+            __Pyx_DECREF_SET(__pyx_t_10, function);
+            __pyx_t_13 = 1;
+          }
+        }
+        #if CYTHON_FAST_PYCALL
+        if (PyFunction_Check(__pyx_t_10)) {
+          PyObject *__pyx_temp[3] = {__pyx_t_12, __pyx_8genexpr1__pyx_v_label, __pyx_t_11};
+          __pyx_t_6 = __Pyx_PyFunction_FastCall(__pyx_t_10, __pyx_temp+1-__pyx_t_13, 2+__pyx_t_13); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 162, __pyx_L7_error)
+          __Pyx_XDECREF(__pyx_t_12); __pyx_t_12 = 0;
+          __Pyx_GOTREF(__pyx_t_6);
+          __Pyx_DECREF(__pyx_t_11); __pyx_t_11 = 0;
+        } else
+        #endif
+        #if CYTHON_FAST_PYCCALL
+        if (__Pyx_PyFastCFunction_Check(__pyx_t_10)) {
+          PyObject *__pyx_temp[3] = {__pyx_t_12, __pyx_8genexpr1__pyx_v_label, __pyx_t_11};
+          __pyx_t_6 = __Pyx_PyCFunction_FastCall(__pyx_t_10, __pyx_temp+1-__pyx_t_13, 2+__pyx_t_13); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 162, __pyx_L7_error)
+          __Pyx_XDECREF(__pyx_t_12); __pyx_t_12 = 0;
+          __Pyx_GOTREF(__pyx_t_6);
+          __Pyx_DECREF(__pyx_t_11); __pyx_t_11 = 0;
+        } else
+        #endif
+        {
+          __pyx_t_14 = PyTuple_New(2+__pyx_t_13); if (unlikely(!__pyx_t_14)) __PYX_ERR(0, 162, __pyx_L7_error)
+          __Pyx_GOTREF(__pyx_t_14);
+          if (__pyx_t_12) {
+            __Pyx_GIVEREF(__pyx_t_12); PyTuple_SET_ITEM(__pyx_t_14, 0, __pyx_t_12); __pyx_t_12 = NULL;
+          }
+          __Pyx_INCREF(__pyx_8genexpr1__pyx_v_label);
+          __Pyx_GIVEREF(__pyx_8genexpr1__pyx_v_label);
+          PyTuple_SET_ITEM(__pyx_t_14, 0+__pyx_t_13, __pyx_8genexpr1__pyx_v_label);
+          __Pyx_GIVEREF(__pyx_t_11);
+          PyTuple_SET_ITEM(__pyx_t_14, 1+__pyx_t_13, __pyx_t_11);
+          __pyx_t_11 = 0;
+          __pyx_t_6 = __Pyx_PyObject_Call(__pyx_t_10, __pyx_t_14, NULL); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 162, __pyx_L7_error)
+          __Pyx_GOTREF(__pyx_t_6);
+          __Pyx_DECREF(__pyx_t_14); __pyx_t_14 = 0;
+        }
+        __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
+        if (unlikely(PyDict_SetItem(__pyx_t_5, (PyObject*)__pyx_8genexpr1__pyx_v_label, (PyObject*)__pyx_t_6))) __PYX_ERR(0, 162, __pyx_L7_error)
+        __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
+      }
+      __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
+      __Pyx_XDECREF(__pyx_8genexpr1__pyx_v_label); __pyx_8genexpr1__pyx_v_label = 0;
+      goto __pyx_L10_exit_scope;
+      __pyx_L7_error:;
+      __Pyx_XDECREF(__pyx_8genexpr1__pyx_v_label); __pyx_8genexpr1__pyx_v_label = 0;
+      goto __pyx_L1_error;
+      __pyx_L10_exit_scope:;
+    } /* exit inner scope */
+    if (unlikely(__Pyx_ListComp_Append(__pyx_t_1, (PyObject*)__pyx_t_5))) __PYX_ERR(0, 161, __pyx_L1_error)
+    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+  }
+  __pyx_r = __pyx_t_1;
+  __pyx_t_1 = 0;
+  goto __pyx_L0;
+
+  /* "crf.pyx":159
+ *         return self._tagger.viterbi()
+ * 
+ *     def predict_proba_single(self, sequence: Sequence) -> list[dict[str, float]]:             # <<<<<<<<<<<<<<
+ *         self.set_sequence(sequence)
+ *         return [
+ */
+
+  /* function exit code */
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_XDECREF(__pyx_t_5);
+  __Pyx_XDECREF(__pyx_t_6);
+  __Pyx_XDECREF(__pyx_t_7);
+  __Pyx_XDECREF(__pyx_t_10);
+  __Pyx_XDECREF(__pyx_t_11);
+  __Pyx_XDECREF(__pyx_t_12);
+  __Pyx_XDECREF(__pyx_t_14);
+  __Pyx_AddTraceback("crf.Model.predict_proba_single", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_XDECREF(__pyx_8genexpr1__pyx_v_label);
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "crf.pyx":166
+ *         ]
+ * 
+ *     def load(self, filepath: Filepath):             # <<<<<<<<<<<<<<
+ *         filepath = str(filepath)
+ *         self.check_model(filepath)
+ */
+
+/* Python wrapper */
+static PyObject *__pyx_pw_3crf_5Model_7load(PyObject *__pyx_v_self, PyObject *__pyx_v_filepath); /*proto*/
+static char __pyx_doc_3crf_5Model_6load[] = "Model.load(self, filepath: Filepath)";
+static PyObject *__pyx_pw_3crf_5Model_7load(PyObject *__pyx_v_self, PyObject *__pyx_v_filepath) {
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("load (wrapper)", 0);
+  __pyx_r = __pyx_pf_3crf_5Model_6load(((struct __pyx_obj_3crf_Model *)__pyx_v_self), ((PyObject *)__pyx_v_filepath));
+
+  /* function exit code */
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+static PyObject *__pyx_pf_3crf_5Model_6load(struct __pyx_obj_3crf_Model *__pyx_v_self, PyObject *__pyx_v_filepath) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  PyObject *__pyx_t_2 = NULL;
+  PyObject *__pyx_t_3 = NULL;
+  std::string __pyx_t_4;
+  int __pyx_t_5;
+  int __pyx_t_6;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("load", 0);
+  __Pyx_INCREF(__pyx_v_filepath);
+
+  /* "crf.pyx":167
+ * 
+ *     def load(self, filepath: Filepath):
+ *         filepath = str(filepath)             # <<<<<<<<<<<<<<
+ *         self.check_model(filepath)
+ *         if not self._tagger.open(filepath):
+ */
+  __pyx_t_1 = __Pyx_PyObject_CallOneArg(((PyObject *)(&PyString_Type)), __pyx_v_filepath); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 167, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_DECREF_SET(__pyx_v_filepath, __pyx_t_1);
+  __pyx_t_1 = 0;
+
+  /* "crf.pyx":168
+ *     def load(self, filepath: Filepath):
+ *         filepath = str(filepath)
+ *         self.check_model(filepath)             # <<<<<<<<<<<<<<
+ *         if not self._tagger.open(filepath):
+ *             raise ValueError(f"Cannot load model file {filepath}")
+ */
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_check_model); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 168, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  __pyx_t_3 = NULL;
+  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
+    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
+    if (likely(__pyx_t_3)) {
+      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
+      __Pyx_INCREF(__pyx_t_3);
+      __Pyx_INCREF(function);
+      __Pyx_DECREF_SET(__pyx_t_2, function);
+    }
+  }
+  __pyx_t_1 = (__pyx_t_3) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_3, __pyx_v_filepath) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_v_filepath);
+  __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
+  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 168, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "crf.pyx":169
+ *         filepath = str(filepath)
+ *         self.check_model(filepath)
+ *         if not self._tagger.open(filepath):             # <<<<<<<<<<<<<<
+ *             raise ValueError(f"Cannot load model file {filepath}")
+ * 
+ */
+  __pyx_t_4 = __pyx_convert_string_from_py_std__in_string(__pyx_v_filepath); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 169, __pyx_L1_error)
+  try {
+    __pyx_t_5 = __pyx_v_self->_tagger.open(__pyx_t_4);
+  } catch(...) {
+    __Pyx_CppExn2PyErr();
+    __PYX_ERR(0, 169, __pyx_L1_error)
+  }
+  __pyx_t_6 = ((!(__pyx_t_5 != 0)) != 0);
+  if (unlikely(__pyx_t_6)) {
+
+    /* "crf.pyx":170
+ *         self.check_model(filepath)
+ *         if not self._tagger.open(filepath):
+ *             raise ValueError(f"Cannot load model file {filepath}")             # <<<<<<<<<<<<<<
+ * 
+ *     def marginal(self, label: str, index: int):
+ */
+    __pyx_t_1 = __Pyx_PyObject_FormatSimple(__pyx_v_filepath, __pyx_empty_unicode); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 170, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_1);
+    __pyx_t_2 = __Pyx_PyUnicode_Concat(__pyx_kp_u_Cannot_load_model_file, __pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 170, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_2);
+    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+    __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 170, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_1);
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    __Pyx_Raise(__pyx_t_1, 0, 0, 0);
+    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+    __PYX_ERR(0, 170, __pyx_L1_error)
+
+    /* "crf.pyx":169
+ *         filepath = str(filepath)
+ *         self.check_model(filepath)
+ *         if not self._tagger.open(filepath):             # <<<<<<<<<<<<<<
+ *             raise ValueError(f"Cannot load model file {filepath}")
+ * 
+ */
+  }
+
+  /* "crf.pyx":166
+ *         ]
+ * 
+ *     def load(self, filepath: Filepath):             # <<<<<<<<<<<<<<
+ *         filepath = str(filepath)
+ *         self.check_model(filepath)
+ */
+
+  /* function exit code */
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_XDECREF(__pyx_t_2);
+  __Pyx_XDECREF(__pyx_t_3);
+  __Pyx_AddTraceback("crf.Model.load", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_XDECREF(__pyx_v_filepath);
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "crf.pyx":172
+ *             raise ValueError(f"Cannot load model file {filepath}")
+ * 
+ *     def marginal(self, label: str, index: int):             # <<<<<<<<<<<<<<
+ *         return self._tagger.marginal(label, index)
+ * 
+ */
+
+/* Python wrapper */
+static PyObject *__pyx_pw_3crf_5Model_9marginal(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
+static char __pyx_doc_3crf_5Model_8marginal[] = "Model.marginal(self, str label: str, index: int)";
+static PyObject *__pyx_pw_3crf_5Model_9marginal(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
+  PyObject *__pyx_v_label = 0;
+  PyObject *__pyx_v_index = 0;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("marginal (wrapper)", 0);
+  {
+    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_label,&__pyx_n_s_index,0};
+    PyObject* values[2] = {0,0};
+    if (unlikely(__pyx_kwds)) {
+      Py_ssize_t kw_args;
+      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
+      switch (pos_args) {
+        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
+        CYTHON_FALLTHROUGH;
+        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
+        CYTHON_FALLTHROUGH;
+        case  0: break;
+        default: goto __pyx_L5_argtuple_error;
+      }
+      kw_args = PyDict_Size(__pyx_kwds);
+      switch (pos_args) {
+        case  0:
+        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_label)) != 0)) kw_args--;
+        else goto __pyx_L5_argtuple_error;
+        CYTHON_FALLTHROUGH;
+        case  1:
+        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_index)) != 0)) kw_args--;
+        else {
+          __Pyx_RaiseArgtupleInvalid("marginal", 1, 2, 2, 1); __PYX_ERR(0, 172, __pyx_L3_error)
+        }
+      }
+      if (unlikely(kw_args > 0)) {
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "marginal") < 0)) __PYX_ERR(0, 172, __pyx_L3_error)
+      }
+    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
+      goto __pyx_L5_argtuple_error;
+    } else {
+      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
+      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
+    }
+    __pyx_v_label = ((PyObject*)values[0]);
+    __pyx_v_index = values[1];
+  }
+  goto __pyx_L4_argument_unpacking_done;
+  __pyx_L5_argtuple_error:;
+  __Pyx_RaiseArgtupleInvalid("marginal", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 172, __pyx_L3_error)
+  __pyx_L3_error:;
+  __Pyx_AddTraceback("crf.Model.marginal", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_RefNannyFinishContext();
+  return NULL;
+  __pyx_L4_argument_unpacking_done:;
+  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_label), (&PyString_Type), 1, "label", 1))) __PYX_ERR(0, 172, __pyx_L1_error)
+  __pyx_r = __pyx_pf_3crf_5Model_8marginal(((struct __pyx_obj_3crf_Model *)__pyx_v_self), __pyx_v_label, __pyx_v_index);
+
+  /* function exit code */
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+static PyObject *__pyx_pf_3crf_5Model_8marginal(struct __pyx_obj_3crf_Model *__pyx_v_self, PyObject *__pyx_v_label, PyObject *__pyx_v_index) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  std::string __pyx_t_1;
+  int __pyx_t_2;
+  double __pyx_t_3;
+  PyObject *__pyx_t_4 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("marginal", 0);
+
+  /* "crf.pyx":173
+ * 
+ *     def marginal(self, label: str, index: int):
+ *         return self._tagger.marginal(label, index)             # <<<<<<<<<<<<<<
+ * 
+ *     cpdef set_sequence(self, sequence) except +:
+ */
+  __Pyx_XDECREF(__pyx_r);
+  __pyx_t_1 = __pyx_convert_string_from_py_std__in_string(__pyx_v_label); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 173, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyInt_As_int(__pyx_v_index); if (unlikely((__pyx_t_2 == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 173, __pyx_L1_error)
+  try {
+    __pyx_t_3 = __pyx_v_self->_tagger.marginal(__pyx_t_1, __pyx_t_2);
+  } catch(...) {
+    __Pyx_CppExn2PyErr();
+    __PYX_ERR(0, 173, __pyx_L1_error)
+  }
+  __pyx_t_4 = PyFloat_FromDouble(__pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 173, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_4);
+  __pyx_r = __pyx_t_4;
+  __pyx_t_4 = 0;
+  goto __pyx_L0;
+
+  /* "crf.pyx":172
+ *             raise ValueError(f"Cannot load model file {filepath}")
+ * 
+ *     def marginal(self, label: str, index: int):             # <<<<<<<<<<<<<<
+ *         return self._tagger.marginal(label, index)
+ * 
+ */
+
+  /* function exit code */
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_4);
+  __Pyx_AddTraceback("crf.Model.marginal", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "crf.pyx":175
+ *         return self._tagger.marginal(label, index)
+ * 
+ *     cpdef set_sequence(self, sequence) except +:             # <<<<<<<<<<<<<<
+ *         self._tagger.set(to_seq(sequence))
+ * 
+ */
+
+static PyObject *__pyx_pw_3crf_5Model_11set_sequence(PyObject *__pyx_v_self, PyObject *__pyx_v_sequence); /*proto*/
+static PyObject *__pyx_f_3crf_5Model_set_sequence(struct __pyx_obj_3crf_Model *__pyx_v_self, PyObject *__pyx_v_sequence, int __pyx_skip_dispatch) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  PyObject *__pyx_t_2 = NULL;
+  PyObject *__pyx_t_3 = NULL;
+  PyObject *__pyx_t_4 = NULL;
+  CRFSuite::ItemSequence __pyx_t_5;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("set_sequence", 0);
+  /* Check if called by wrapper */
+  if (unlikely(__pyx_skip_dispatch)) ;
+  /* Check if overridden in Python */
+  else if (unlikely((Py_TYPE(((PyObject *)__pyx_v_self))->tp_dictoffset != 0) || (Py_TYPE(((PyObject *)__pyx_v_self))->tp_flags & (Py_TPFLAGS_IS_ABSTRACT | Py_TPFLAGS_HEAPTYPE)))) {
+    #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
+    static PY_UINT64_T __pyx_tp_dict_version = __PYX_DICT_VERSION_INIT, __pyx_obj_dict_version = __PYX_DICT_VERSION_INIT;
+    if (unlikely(!__Pyx_object_dict_version_matches(((PyObject *)__pyx_v_self), __pyx_tp_dict_version, __pyx_obj_dict_version))) {
+      PY_UINT64_T __pyx_type_dict_guard = __Pyx_get_tp_dict_version(((PyObject *)__pyx_v_self));
+      #endif
+      __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_set_sequence); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 175, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_1);
+      if (!PyCFunction_Check(__pyx_t_1) || (PyCFunction_GET_FUNCTION(__pyx_t_1) != (PyCFunction)(void*)__pyx_pw_3crf_5Model_11set_sequence)) {
+        __Pyx_XDECREF(__pyx_r);
+        __Pyx_INCREF(__pyx_t_1);
+        __pyx_t_3 = __pyx_t_1; __pyx_t_4 = NULL;
+        if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
+          __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
+          if (likely(__pyx_t_4)) {
+            PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
+            __Pyx_INCREF(__pyx_t_4);
+            __Pyx_INCREF(function);
+            __Pyx_DECREF_SET(__pyx_t_3, function);
+          }
+        }
+        __pyx_t_2 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_4, __pyx_v_sequence) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_v_sequence);
+        __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
+        if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 175, __pyx_L1_error)
+        __Pyx_GOTREF(__pyx_t_2);
+        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+        __pyx_r = __pyx_t_2;
+        __pyx_t_2 = 0;
+        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+        goto __pyx_L0;
+      }
+      #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
+      __pyx_tp_dict_version = __Pyx_get_tp_dict_version(((PyObject *)__pyx_v_self));
+      __pyx_obj_dict_version = __Pyx_get_object_dict_version(((PyObject *)__pyx_v_self));
+      if (unlikely(__pyx_type_dict_guard != __pyx_tp_dict_version)) {
+        __pyx_tp_dict_version = __pyx_obj_dict_version = __PYX_DICT_VERSION_INIT;
+      }
+      #endif
+      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+      #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
+    }
+    #endif
+  }
+
+  /* "crf.pyx":176
+ * 
+ *     cpdef set_sequence(self, sequence) except +:
+ *         self._tagger.set(to_seq(sequence))             # <<<<<<<<<<<<<<
+ * 
+ *     @staticmethod
+ */
+  try {
+    __pyx_t_5 = __pyx_f_3crf_to_seq(__pyx_v_sequence);
+  } catch(...) {
+    __Pyx_CppExn2PyErr();
+    __PYX_ERR(0, 176, __pyx_L1_error)
+  }
+  try {
+    __pyx_v_self->_tagger.set(__pyx_t_5);
+  } catch(...) {
+    __Pyx_CppExn2PyErr();
+    __PYX_ERR(0, 176, __pyx_L1_error)
+  }
+
+  /* "crf.pyx":175
+ *         return self._tagger.marginal(label, index)
+ * 
+ *     cpdef set_sequence(self, sequence) except +:             # <<<<<<<<<<<<<<
+ *         self._tagger.set(to_seq(sequence))
+ * 
+ */
+
+  /* function exit code */
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_XDECREF(__pyx_t_2);
+  __Pyx_XDECREF(__pyx_t_3);
+  __Pyx_XDECREF(__pyx_t_4);
+  __Pyx_AddTraceback("crf.Model.set_sequence", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* Python wrapper */
+static PyObject *__pyx_pw_3crf_5Model_11set_sequence(PyObject *__pyx_v_self, PyObject *__pyx_v_sequence); /*proto*/
+static char __pyx_doc_3crf_5Model_10set_sequence[] = "Model.set_sequence(self, sequence)";
+static PyObject *__pyx_pw_3crf_5Model_11set_sequence(PyObject *__pyx_v_self, PyObject *__pyx_v_sequence) {
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("set_sequence (wrapper)", 0);
+  __pyx_r = __pyx_pf_3crf_5Model_10set_sequence(((struct __pyx_obj_3crf_Model *)__pyx_v_self), ((PyObject *)__pyx_v_sequence));
+
+  /* function exit code */
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+static PyObject *__pyx_pf_3crf_5Model_10set_sequence(struct __pyx_obj_3crf_Model *__pyx_v_self, PyObject *__pyx_v_sequence) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("set_sequence", 0);
+  __Pyx_XDECREF(__pyx_r);
+  try {
+    __pyx_t_1 = __pyx_f_3crf_5Model_set_sequence(__pyx_v_self, __pyx_v_sequence, 1);
+    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 175, __pyx_L1_error)
+  } catch(...) {
+    __Pyx_CppExn2PyErr();
+    __PYX_ERR(0, 175, __pyx_L1_error)
+  }
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_r = __pyx_t_1;
+  __pyx_t_1 = 0;
+  goto __pyx_L0;
+
+  /* function exit code */
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_AddTraceback("crf.Model.set_sequence", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "crf.pyx":179
+ * 
+ *     @staticmethod
+ *     def check_model(filepath: str):             # <<<<<<<<<<<<<<
+ *         with open(filepath, "rb") as model:
+ *             magic = model.read(4)
+ */
+
+/* Python wrapper */
+static PyObject *__pyx_pw_3crf_5Model_13check_model(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
+static char __pyx_doc_3crf_5Model_12check_model[] = "Model.check_model(str filepath: str)";
+static PyMethodDef __pyx_mdef_3crf_5Model_13check_model = {"check_model", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_3crf_5Model_13check_model, METH_VARARGS|METH_KEYWORDS, __pyx_doc_3crf_5Model_12check_model};
+static PyObject *__pyx_pw_3crf_5Model_13check_model(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
+  PyObject *__pyx_v_filepath = 0;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("check_model (wrapper)", 0);
+  {
+    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_filepath,0};
+    PyObject* values[1] = {0};
+    if (unlikely(__pyx_kwds)) {
+      Py_ssize_t kw_args;
+      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
+      switch (pos_args) {
+        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
+        CYTHON_FALLTHROUGH;
+        case  0: break;
+        default: goto __pyx_L5_argtuple_error;
+      }
+      kw_args = PyDict_Size(__pyx_kwds);
+      switch (pos_args) {
+        case  0:
+        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_filepath)) != 0)) kw_args--;
+        else goto __pyx_L5_argtuple_error;
+      }
+      if (unlikely(kw_args > 0)) {
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "check_model") < 0)) __PYX_ERR(0, 179, __pyx_L3_error)
+      }
+    } else if (PyTuple_GET_SIZE(__pyx_args) != 1) {
+      goto __pyx_L5_argtuple_error;
+    } else {
+      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
+    }
+    __pyx_v_filepath = ((PyObject*)values[0]);
+  }
+  goto __pyx_L4_argument_unpacking_done;
+  __pyx_L5_argtuple_error:;
+  __Pyx_RaiseArgtupleInvalid("check_model", 1, 1, 1, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 179, __pyx_L3_error)
+  __pyx_L3_error:;
+  __Pyx_AddTraceback("crf.Model.check_model", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_RefNannyFinishContext();
+  return NULL;
+  __pyx_L4_argument_unpacking_done:;
+  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_filepath), (&PyString_Type), 1, "filepath", 1))) __PYX_ERR(0, 179, __pyx_L1_error)
+  __pyx_r = __pyx_pf_3crf_5Model_12check_model(__pyx_v_filepath);
+
+  /* function exit code */
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+static PyObject *__pyx_pf_3crf_5Model_12check_model(PyObject *__pyx_v_filepath) {
+  PyObject *__pyx_v_model = NULL;
+  PyObject *__pyx_v_magic = NULL;
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  PyObject *__pyx_t_2 = NULL;
+  PyObject *__pyx_t_3 = NULL;
+  PyObject *__pyx_t_4 = NULL;
+  PyObject *__pyx_t_5 = NULL;
+  PyObject *__pyx_t_6 = NULL;
+  PyObject *__pyx_t_7 = NULL;
+  PyObject *__pyx_t_8 = NULL;
+  int __pyx_t_9;
+  int __pyx_t_10;
+  PyObject *__pyx_t_11 = NULL;
+  Py_ssize_t __pyx_t_12;
+  Py_UCS4 __pyx_t_13;
+  PyObject *__pyx_t_14 = NULL;
+  int __pyx_t_15;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("check_model", 0);
+
+  /* "crf.pyx":180
+ *     @staticmethod
+ *     def check_model(filepath: str):
+ *         with open(filepath, "rb") as model:             # <<<<<<<<<<<<<<
+ *             magic = model.read(4)
+ *             if magic != b"lCRF":
+ */
+  /*with:*/ {
+    __pyx_t_1 = PyTuple_New(2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 180, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_1);
+    __Pyx_INCREF(__pyx_v_filepath);
+    __Pyx_GIVEREF(__pyx_v_filepath);
+    PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_v_filepath);
+    __Pyx_INCREF(__pyx_n_s_rb);
+    __Pyx_GIVEREF(__pyx_n_s_rb);
+    PyTuple_SET_ITEM(__pyx_t_1, 1, __pyx_n_s_rb);
+    __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_open, __pyx_t_1, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 180, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_2);
+    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+    __pyx_t_3 = __Pyx_PyObject_LookupSpecial(__pyx_t_2, __pyx_n_s_exit); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 180, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_3);
+    __pyx_t_4 = __Pyx_PyObject_LookupSpecial(__pyx_t_2, __pyx_n_s_enter); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 180, __pyx_L3_error)
+    __Pyx_GOTREF(__pyx_t_4);
+    __pyx_t_5 = NULL;
+    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_4))) {
+      __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_4);
+      if (likely(__pyx_t_5)) {
+        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
+        __Pyx_INCREF(__pyx_t_5);
+        __Pyx_INCREF(function);
+        __Pyx_DECREF_SET(__pyx_t_4, function);
+      }
+    }
+    __pyx_t_1 = (__pyx_t_5) ? __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_t_5) : __Pyx_PyObject_CallNoArg(__pyx_t_4);
+    __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
+    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 180, __pyx_L3_error)
+    __Pyx_GOTREF(__pyx_t_1);
+    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+    __pyx_t_4 = __pyx_t_1;
+    __pyx_t_1 = 0;
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    /*try:*/ {
+      {
+        __Pyx_PyThreadState_declare
+        __Pyx_PyThreadState_assign
+        __Pyx_ExceptionSave(&__pyx_t_6, &__pyx_t_7, &__pyx_t_8);
+        __Pyx_XGOTREF(__pyx_t_6);
+        __Pyx_XGOTREF(__pyx_t_7);
+        __Pyx_XGOTREF(__pyx_t_8);
+        /*try:*/ {
+          __pyx_v_model = __pyx_t_4;
+          __pyx_t_4 = 0;
+
+          /* "crf.pyx":181
+ *     def check_model(filepath: str):
+ *         with open(filepath, "rb") as model:
+ *             magic = model.read(4)             # <<<<<<<<<<<<<<
+ *             if magic != b"lCRF":
+ *                 raise ValueError(f"Invalid model file {filepath}")
+ */
+          __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_model, __pyx_n_s_read); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 181, __pyx_L7_error)
+          __Pyx_GOTREF(__pyx_t_2);
+          __pyx_t_1 = NULL;
+          if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
+            __pyx_t_1 = PyMethod_GET_SELF(__pyx_t_2);
+            if (likely(__pyx_t_1)) {
+              PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
+              __Pyx_INCREF(__pyx_t_1);
+              __Pyx_INCREF(function);
+              __Pyx_DECREF_SET(__pyx_t_2, function);
+            }
+          }
+          __pyx_t_4 = (__pyx_t_1) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_1, __pyx_int_4) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_int_4);
+          __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
+          if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 181, __pyx_L7_error)
+          __Pyx_GOTREF(__pyx_t_4);
+          __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+          __pyx_v_magic = __pyx_t_4;
+          __pyx_t_4 = 0;
+
+          /* "crf.pyx":182
+ *         with open(filepath, "rb") as model:
+ *             magic = model.read(4)
+ *             if magic != b"lCRF":             # <<<<<<<<<<<<<<
+ *                 raise ValueError(f"Invalid model file {filepath}")
+ *             model.seek(0, os.SEEK_END)
+ */
+          __pyx_t_9 = (__Pyx_PyBytes_Equals(__pyx_v_magic, __pyx_n_b_lCRF, Py_NE)); if (unlikely(__pyx_t_9 < 0)) __PYX_ERR(0, 182, __pyx_L7_error)
+          if (unlikely(__pyx_t_9)) {
+
+            /* "crf.pyx":183
+ *             magic = model.read(4)
+ *             if magic != b"lCRF":
+ *                 raise ValueError(f"Invalid model file {filepath}")             # <<<<<<<<<<<<<<
+ *             model.seek(0, os.SEEK_END)
+ *             if model.tell() <= 48:
+ */
+            __pyx_t_4 = __Pyx_PyObject_FormatSimple(__pyx_v_filepath, __pyx_empty_unicode); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 183, __pyx_L7_error)
+            __Pyx_GOTREF(__pyx_t_4);
+            __pyx_t_2 = __Pyx_PyUnicode_Concat(__pyx_kp_u_Invalid_model_file, __pyx_t_4); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 183, __pyx_L7_error)
+            __Pyx_GOTREF(__pyx_t_2);
+            __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+            __pyx_t_4 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_2); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 183, __pyx_L7_error)
+            __Pyx_GOTREF(__pyx_t_4);
+            __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+            __Pyx_Raise(__pyx_t_4, 0, 0, 0);
+            __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+            __PYX_ERR(0, 183, __pyx_L7_error)
+
+            /* "crf.pyx":182
+ *         with open(filepath, "rb") as model:
+ *             magic = model.read(4)
+ *             if magic != b"lCRF":             # <<<<<<<<<<<<<<
+ *                 raise ValueError(f"Invalid model file {filepath}")
+ *             model.seek(0, os.SEEK_END)
+ */
+          }
+
+          /* "crf.pyx":184
+ *             if magic != b"lCRF":
+ *                 raise ValueError(f"Invalid model file {filepath}")
+ *             model.seek(0, os.SEEK_END)             # <<<<<<<<<<<<<<
+ *             if model.tell() <= 48:
+ *                 raise ValueError(f"Model file {filepath} does not have a complete header")
+ */
+          __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_model, __pyx_n_s_seek); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 184, __pyx_L7_error)
+          __Pyx_GOTREF(__pyx_t_2);
+          __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_os); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 184, __pyx_L7_error)
+          __Pyx_GOTREF(__pyx_t_1);
+          __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_SEEK_END); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 184, __pyx_L7_error)
+          __Pyx_GOTREF(__pyx_t_5);
+          __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+          __pyx_t_1 = NULL;
+          __pyx_t_10 = 0;
+          if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
+            __pyx_t_1 = PyMethod_GET_SELF(__pyx_t_2);
+            if (likely(__pyx_t_1)) {
+              PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
+              __Pyx_INCREF(__pyx_t_1);
+              __Pyx_INCREF(function);
+              __Pyx_DECREF_SET(__pyx_t_2, function);
+              __pyx_t_10 = 1;
+            }
+          }
+          #if CYTHON_FAST_PYCALL
+          if (PyFunction_Check(__pyx_t_2)) {
+            PyObject *__pyx_temp[3] = {__pyx_t_1, __pyx_int_0, __pyx_t_5};
+            __pyx_t_4 = __Pyx_PyFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_10, 2+__pyx_t_10); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 184, __pyx_L7_error)
+            __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
+            __Pyx_GOTREF(__pyx_t_4);
+            __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+          } else
+          #endif
+          #if CYTHON_FAST_PYCCALL
+          if (__Pyx_PyFastCFunction_Check(__pyx_t_2)) {
+            PyObject *__pyx_temp[3] = {__pyx_t_1, __pyx_int_0, __pyx_t_5};
+            __pyx_t_4 = __Pyx_PyCFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_10, 2+__pyx_t_10); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 184, __pyx_L7_error)
+            __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
+            __Pyx_GOTREF(__pyx_t_4);
+            __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+          } else
+          #endif
+          {
+            __pyx_t_11 = PyTuple_New(2+__pyx_t_10); if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 184, __pyx_L7_error)
+            __Pyx_GOTREF(__pyx_t_11);
+            if (__pyx_t_1) {
+              __Pyx_GIVEREF(__pyx_t_1); PyTuple_SET_ITEM(__pyx_t_11, 0, __pyx_t_1); __pyx_t_1 = NULL;
+            }
+            __Pyx_INCREF(__pyx_int_0);
+            __Pyx_GIVEREF(__pyx_int_0);
+            PyTuple_SET_ITEM(__pyx_t_11, 0+__pyx_t_10, __pyx_int_0);
+            __Pyx_GIVEREF(__pyx_t_5);
+            PyTuple_SET_ITEM(__pyx_t_11, 1+__pyx_t_10, __pyx_t_5);
+            __pyx_t_5 = 0;
+            __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_11, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 184, __pyx_L7_error)
+            __Pyx_GOTREF(__pyx_t_4);
+            __Pyx_DECREF(__pyx_t_11); __pyx_t_11 = 0;
+          }
+          __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+          __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+
+          /* "crf.pyx":185
+ *                 raise ValueError(f"Invalid model file {filepath}")
+ *             model.seek(0, os.SEEK_END)
+ *             if model.tell() <= 48:             # <<<<<<<<<<<<<<
+ *                 raise ValueError(f"Model file {filepath} does not have a complete header")
+ * 
+ */
+          __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_model, __pyx_n_s_tell); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 185, __pyx_L7_error)
+          __Pyx_GOTREF(__pyx_t_2);
+          __pyx_t_11 = NULL;
+          if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
+            __pyx_t_11 = PyMethod_GET_SELF(__pyx_t_2);
+            if (likely(__pyx_t_11)) {
+              PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
+              __Pyx_INCREF(__pyx_t_11);
+              __Pyx_INCREF(function);
+              __Pyx_DECREF_SET(__pyx_t_2, function);
+            }
+          }
+          __pyx_t_4 = (__pyx_t_11) ? __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_11) : __Pyx_PyObject_CallNoArg(__pyx_t_2);
+          __Pyx_XDECREF(__pyx_t_11); __pyx_t_11 = 0;
+          if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 185, __pyx_L7_error)
+          __Pyx_GOTREF(__pyx_t_4);
+          __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+          __pyx_t_2 = PyObject_RichCompare(__pyx_t_4, __pyx_int_48, Py_LE); __Pyx_XGOTREF(__pyx_t_2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 185, __pyx_L7_error)
+          __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+          __pyx_t_9 = __Pyx_PyObject_IsTrue(__pyx_t_2); if (unlikely(__pyx_t_9 < 0)) __PYX_ERR(0, 185, __pyx_L7_error)
+          __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+          if (unlikely(__pyx_t_9)) {
+
+            /* "crf.pyx":186
+ *             model.seek(0, os.SEEK_END)
+ *             if model.tell() <= 48:
+ *                 raise ValueError(f"Model file {filepath} does not have a complete header")             # <<<<<<<<<<<<<<
+ * 
+ *     def dump_transitions(self, filepath: Filepath):
+ */
+            __pyx_t_2 = PyTuple_New(3); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 186, __pyx_L7_error)
+            __Pyx_GOTREF(__pyx_t_2);
+            __pyx_t_12 = 0;
+            __pyx_t_13 = 127;
+            __Pyx_INCREF(__pyx_kp_u_Model_file);
+            __pyx_t_12 += 11;
+            __Pyx_GIVEREF(__pyx_kp_u_Model_file);
+            PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_kp_u_Model_file);
+            __pyx_t_4 = __Pyx_PyObject_FormatSimple(__pyx_v_filepath, __pyx_empty_unicode); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 186, __pyx_L7_error)
+            __Pyx_GOTREF(__pyx_t_4);
+            __pyx_t_13 = (__Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_4) > __pyx_t_13) ? __Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_4) : __pyx_t_13;
+            __pyx_t_12 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_4);
+            __Pyx_GIVEREF(__pyx_t_4);
+            PyTuple_SET_ITEM(__pyx_t_2, 1, __pyx_t_4);
+            __pyx_t_4 = 0;
+            __Pyx_INCREF(__pyx_kp_u_does_not_have_a_complete_header);
+            __pyx_t_12 += 32;
+            __Pyx_GIVEREF(__pyx_kp_u_does_not_have_a_complete_header);
+            PyTuple_SET_ITEM(__pyx_t_2, 2, __pyx_kp_u_does_not_have_a_complete_header);
+            __pyx_t_4 = __Pyx_PyUnicode_Join(__pyx_t_2, 3, __pyx_t_12, __pyx_t_13); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 186, __pyx_L7_error)
+            __Pyx_GOTREF(__pyx_t_4);
+            __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+            __pyx_t_2 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_4); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 186, __pyx_L7_error)
+            __Pyx_GOTREF(__pyx_t_2);
+            __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+            __Pyx_Raise(__pyx_t_2, 0, 0, 0);
+            __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+            __PYX_ERR(0, 186, __pyx_L7_error)
+
+            /* "crf.pyx":185
+ *                 raise ValueError(f"Invalid model file {filepath}")
+ *             model.seek(0, os.SEEK_END)
+ *             if model.tell() <= 48:             # <<<<<<<<<<<<<<
+ *                 raise ValueError(f"Model file {filepath} does not have a complete header")
+ * 
+ */
+          }
+
+          /* "crf.pyx":180
+ *     @staticmethod
+ *     def check_model(filepath: str):
+ *         with open(filepath, "rb") as model:             # <<<<<<<<<<<<<<
+ *             magic = model.read(4)
+ *             if magic != b"lCRF":
+ */
+        }
+        __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
+        __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
+        __Pyx_XDECREF(__pyx_t_8); __pyx_t_8 = 0;
+        goto __pyx_L12_try_end;
+        __pyx_L7_error:;
+        __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
+        __Pyx_XDECREF(__pyx_t_11); __pyx_t_11 = 0;
+        __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
+        __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
+        __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
+        /*except:*/ {
+          __Pyx_AddTraceback("crf.Model.check_model", __pyx_clineno, __pyx_lineno, __pyx_filename);
+          if (__Pyx_GetException(&__pyx_t_2, &__pyx_t_4, &__pyx_t_11) < 0) __PYX_ERR(0, 180, __pyx_L9_except_error)
+          __Pyx_GOTREF(__pyx_t_2);
+          __Pyx_GOTREF(__pyx_t_4);
+          __Pyx_GOTREF(__pyx_t_11);
+          __pyx_t_5 = PyTuple_Pack(3, __pyx_t_2, __pyx_t_4, __pyx_t_11); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 180, __pyx_L9_except_error)
+          __Pyx_GOTREF(__pyx_t_5);
+          __pyx_t_14 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_5, NULL);
+          __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+          __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+          if (unlikely(!__pyx_t_14)) __PYX_ERR(0, 180, __pyx_L9_except_error)
+          __Pyx_GOTREF(__pyx_t_14);
+          __pyx_t_9 = __Pyx_PyObject_IsTrue(__pyx_t_14);
+          __Pyx_DECREF(__pyx_t_14); __pyx_t_14 = 0;
+          if (__pyx_t_9 < 0) __PYX_ERR(0, 180, __pyx_L9_except_error)
+          __pyx_t_15 = ((!(__pyx_t_9 != 0)) != 0);
+          if (__pyx_t_15) {
+            __Pyx_GIVEREF(__pyx_t_2);
+            __Pyx_GIVEREF(__pyx_t_4);
+            __Pyx_XGIVEREF(__pyx_t_11);
+            __Pyx_ErrRestoreWithState(__pyx_t_2, __pyx_t_4, __pyx_t_11);
+            __pyx_t_2 = 0; __pyx_t_4 = 0; __pyx_t_11 = 0; 
+            __PYX_ERR(0, 180, __pyx_L9_except_error)
+          }
+          __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
+          __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
+          __Pyx_XDECREF(__pyx_t_11); __pyx_t_11 = 0;
+          goto __pyx_L8_exception_handled;
+        }
+        __pyx_L9_except_error:;
+        __Pyx_XGIVEREF(__pyx_t_6);
+        __Pyx_XGIVEREF(__pyx_t_7);
+        __Pyx_XGIVEREF(__pyx_t_8);
+        __Pyx_ExceptionReset(__pyx_t_6, __pyx_t_7, __pyx_t_8);
+        goto __pyx_L1_error;
+        __pyx_L8_exception_handled:;
+        __Pyx_XGIVEREF(__pyx_t_6);
+        __Pyx_XGIVEREF(__pyx_t_7);
+        __Pyx_XGIVEREF(__pyx_t_8);
+        __Pyx_ExceptionReset(__pyx_t_6, __pyx_t_7, __pyx_t_8);
+        __pyx_L12_try_end:;
+      }
+    }
+    /*finally:*/ {
+      /*normal exit:*/{
+        if (__pyx_t_3) {
+          __pyx_t_8 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_tuple__3, NULL);
+          __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+          if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 180, __pyx_L1_error)
+          __Pyx_GOTREF(__pyx_t_8);
+          __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
+        }
+        goto __pyx_L6;
+      }
+      __pyx_L6:;
+    }
+    goto __pyx_L18;
+    __pyx_L3_error:;
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+    goto __pyx_L1_error;
+    __pyx_L18:;
+  }
+
+  /* "crf.pyx":179
+ * 
+ *     @staticmethod
+ *     def check_model(filepath: str):             # <<<<<<<<<<<<<<
+ *         with open(filepath, "rb") as model:
+ *             magic = model.read(4)
+ */
+
+  /* function exit code */
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_XDECREF(__pyx_t_2);
+  __Pyx_XDECREF(__pyx_t_4);
+  __Pyx_XDECREF(__pyx_t_5);
+  __Pyx_XDECREF(__pyx_t_11);
+  __Pyx_AddTraceback("crf.Model.check_model", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_XDECREF(__pyx_v_model);
+  __Pyx_XDECREF(__pyx_v_magic);
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "crf.pyx":188
+ *                 raise ValueError(f"Model file {filepath} does not have a complete header")
+ * 
+ *     def dump_transitions(self, filepath: Filepath):             # <<<<<<<<<<<<<<
+ *         self._tagger.dump_transitions(os.open(str(filepath), os.O_WRONLY | os.O_CREAT))
+ * 
+ */
+
+/* Python wrapper */
+static PyObject *__pyx_pw_3crf_5Model_15dump_transitions(PyObject *__pyx_v_self, PyObject *__pyx_v_filepath); /*proto*/
+static char __pyx_doc_3crf_5Model_14dump_transitions[] = "Model.dump_transitions(self, filepath: Filepath)";
+static PyObject *__pyx_pw_3crf_5Model_15dump_transitions(PyObject *__pyx_v_self, PyObject *__pyx_v_filepath) {
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("dump_transitions (wrapper)", 0);
+  __pyx_r = __pyx_pf_3crf_5Model_14dump_transitions(((struct __pyx_obj_3crf_Model *)__pyx_v_self), ((PyObject *)__pyx_v_filepath));
+
+  /* function exit code */
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+static PyObject *__pyx_pf_3crf_5Model_14dump_transitions(struct __pyx_obj_3crf_Model *__pyx_v_self, PyObject *__pyx_v_filepath) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  PyObject *__pyx_t_2 = NULL;
+  PyObject *__pyx_t_3 = NULL;
+  PyObject *__pyx_t_4 = NULL;
+  PyObject *__pyx_t_5 = NULL;
+  PyObject *__pyx_t_6 = NULL;
+  int __pyx_t_7;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("dump_transitions", 0);
+
+  /* "crf.pyx":189
+ * 
+ *     def dump_transitions(self, filepath: Filepath):
+ *         self._tagger.dump_transitions(os.open(str(filepath), os.O_WRONLY | os.O_CREAT))             # <<<<<<<<<<<<<<
+ * 
+ *     def dump_states(self, filepath: Filepath):
+ */
+  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_os); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 189, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_open); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 189, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_3);
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __pyx_t_2 = __Pyx_PyObject_CallOneArg(((PyObject *)(&PyString_Type)), __pyx_v_filepath); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 189, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_os); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 189, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_4);
+  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_O_WRONLY); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 189, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_5);
+  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+  __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_os); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 189, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_4);
+  __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_O_CREAT); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 189, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_6);
+  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+  __pyx_t_4 = PyNumber_Or(__pyx_t_5, __pyx_t_6); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 189, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_4);
+  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+  __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
+  __pyx_t_6 = NULL;
+  __pyx_t_7 = 0;
+  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
+    __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_3);
+    if (likely(__pyx_t_6)) {
+      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
+      __Pyx_INCREF(__pyx_t_6);
+      __Pyx_INCREF(function);
+      __Pyx_DECREF_SET(__pyx_t_3, function);
+      __pyx_t_7 = 1;
+    }
+  }
+  #if CYTHON_FAST_PYCALL
+  if (PyFunction_Check(__pyx_t_3)) {
+    PyObject *__pyx_temp[3] = {__pyx_t_6, __pyx_t_2, __pyx_t_4};
+    __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_7, 2+__pyx_t_7); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 189, __pyx_L1_error)
+    __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
+    __Pyx_GOTREF(__pyx_t_1);
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+  } else
+  #endif
+  #if CYTHON_FAST_PYCCALL
+  if (__Pyx_PyFastCFunction_Check(__pyx_t_3)) {
+    PyObject *__pyx_temp[3] = {__pyx_t_6, __pyx_t_2, __pyx_t_4};
+    __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_7, 2+__pyx_t_7); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 189, __pyx_L1_error)
+    __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
+    __Pyx_GOTREF(__pyx_t_1);
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+  } else
+  #endif
+  {
+    __pyx_t_5 = PyTuple_New(2+__pyx_t_7); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 189, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_5);
+    if (__pyx_t_6) {
+      __Pyx_GIVEREF(__pyx_t_6); PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_6); __pyx_t_6 = NULL;
+    }
+    __Pyx_GIVEREF(__pyx_t_2);
+    PyTuple_SET_ITEM(__pyx_t_5, 0+__pyx_t_7, __pyx_t_2);
+    __Pyx_GIVEREF(__pyx_t_4);
+    PyTuple_SET_ITEM(__pyx_t_5, 1+__pyx_t_7, __pyx_t_4);
+    __pyx_t_2 = 0;
+    __pyx_t_4 = 0;
+    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_5, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 189, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_1);
+    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+  }
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __pyx_t_7 = __Pyx_PyInt_As_int(__pyx_t_1); if (unlikely((__pyx_t_7 == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 189, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  try {
+    __pyx_v_self->_tagger.dump_transitions(__pyx_t_7);
+  } catch(...) {
+    __Pyx_CppExn2PyErr();
+    __PYX_ERR(0, 189, __pyx_L1_error)
+  }
+
+  /* "crf.pyx":188
+ *                 raise ValueError(f"Model file {filepath} does not have a complete header")
+ * 
+ *     def dump_transitions(self, filepath: Filepath):             # <<<<<<<<<<<<<<
+ *         self._tagger.dump_transitions(os.open(str(filepath), os.O_WRONLY | os.O_CREAT))
+ * 
+ */
+
+  /* function exit code */
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_XDECREF(__pyx_t_2);
+  __Pyx_XDECREF(__pyx_t_3);
+  __Pyx_XDECREF(__pyx_t_4);
+  __Pyx_XDECREF(__pyx_t_5);
+  __Pyx_XDECREF(__pyx_t_6);
+  __Pyx_AddTraceback("crf.Model.dump_transitions", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "crf.pyx":191
+ *         self._tagger.dump_transitions(os.open(str(filepath), os.O_WRONLY | os.O_CREAT))
+ * 
+ *     def dump_states(self, filepath: Filepath):             # <<<<<<<<<<<<<<
+ *         self._tagger.dump_states(os.open(str(filepath), os.O_WRONLY | os.O_CREAT))
+ * 
+ */
+
+/* Python wrapper */
+static PyObject *__pyx_pw_3crf_5Model_17dump_states(PyObject *__pyx_v_self, PyObject *__pyx_v_filepath); /*proto*/
+static char __pyx_doc_3crf_5Model_16dump_states[] = "Model.dump_states(self, filepath: Filepath)";
+static PyObject *__pyx_pw_3crf_5Model_17dump_states(PyObject *__pyx_v_self, PyObject *__pyx_v_filepath) {
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("dump_states (wrapper)", 0);
+  __pyx_r = __pyx_pf_3crf_5Model_16dump_states(((struct __pyx_obj_3crf_Model *)__pyx_v_self), ((PyObject *)__pyx_v_filepath));
+
+  /* function exit code */
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+static PyObject *__pyx_pf_3crf_5Model_16dump_states(struct __pyx_obj_3crf_Model *__pyx_v_self, PyObject *__pyx_v_filepath) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  PyObject *__pyx_t_2 = NULL;
+  PyObject *__pyx_t_3 = NULL;
+  PyObject *__pyx_t_4 = NULL;
+  PyObject *__pyx_t_5 = NULL;
+  PyObject *__pyx_t_6 = NULL;
+  int __pyx_t_7;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("dump_states", 0);
+
+  /* "crf.pyx":192
+ * 
+ *     def dump_states(self, filepath: Filepath):
+ *         self._tagger.dump_states(os.open(str(filepath), os.O_WRONLY | os.O_CREAT))             # <<<<<<<<<<<<<<
+ * 
+ * cdef crfsuite_api.Item to_item(sequence) except+:
+ */
+  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_os); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 192, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_open); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 192, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_3);
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __pyx_t_2 = __Pyx_PyObject_CallOneArg(((PyObject *)(&PyString_Type)), __pyx_v_filepath); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 192, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_os); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 192, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_4);
+  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_O_WRONLY); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 192, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_5);
+  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+  __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_os); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 192, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_4);
+  __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_O_CREAT); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 192, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_6);
+  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+  __pyx_t_4 = PyNumber_Or(__pyx_t_5, __pyx_t_6); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 192, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_4);
+  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+  __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
+  __pyx_t_6 = NULL;
+  __pyx_t_7 = 0;
+  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
+    __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_3);
+    if (likely(__pyx_t_6)) {
+      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
+      __Pyx_INCREF(__pyx_t_6);
+      __Pyx_INCREF(function);
+      __Pyx_DECREF_SET(__pyx_t_3, function);
+      __pyx_t_7 = 1;
+    }
+  }
+  #if CYTHON_FAST_PYCALL
+  if (PyFunction_Check(__pyx_t_3)) {
+    PyObject *__pyx_temp[3] = {__pyx_t_6, __pyx_t_2, __pyx_t_4};
+    __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_7, 2+__pyx_t_7); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 192, __pyx_L1_error)
+    __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
+    __Pyx_GOTREF(__pyx_t_1);
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+  } else
+  #endif
+  #if CYTHON_FAST_PYCCALL
+  if (__Pyx_PyFastCFunction_Check(__pyx_t_3)) {
+    PyObject *__pyx_temp[3] = {__pyx_t_6, __pyx_t_2, __pyx_t_4};
+    __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_7, 2+__pyx_t_7); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 192, __pyx_L1_error)
+    __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
+    __Pyx_GOTREF(__pyx_t_1);
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+  } else
+  #endif
+  {
+    __pyx_t_5 = PyTuple_New(2+__pyx_t_7); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 192, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_5);
+    if (__pyx_t_6) {
+      __Pyx_GIVEREF(__pyx_t_6); PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_6); __pyx_t_6 = NULL;
+    }
+    __Pyx_GIVEREF(__pyx_t_2);
+    PyTuple_SET_ITEM(__pyx_t_5, 0+__pyx_t_7, __pyx_t_2);
+    __Pyx_GIVEREF(__pyx_t_4);
+    PyTuple_SET_ITEM(__pyx_t_5, 1+__pyx_t_7, __pyx_t_4);
+    __pyx_t_2 = 0;
+    __pyx_t_4 = 0;
+    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_5, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 192, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_1);
+    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+  }
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __pyx_t_7 = __Pyx_PyInt_As_int(__pyx_t_1); if (unlikely((__pyx_t_7 == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 192, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  try {
+    __pyx_v_self->_tagger.dump_states(__pyx_t_7);
+  } catch(...) {
+    __Pyx_CppExn2PyErr();
+    __PYX_ERR(0, 192, __pyx_L1_error)
+  }
+
+  /* "crf.pyx":191
+ *         self._tagger.dump_transitions(os.open(str(filepath), os.O_WRONLY | os.O_CREAT))
+ * 
+ *     def dump_states(self, filepath: Filepath):             # <<<<<<<<<<<<<<
+ *         self._tagger.dump_states(os.open(str(filepath), os.O_WRONLY | os.O_CREAT))
+ * 
+ */
+
+  /* function exit code */
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_XDECREF(__pyx_t_2);
+  __Pyx_XDECREF(__pyx_t_3);
+  __Pyx_XDECREF(__pyx_t_4);
+  __Pyx_XDECREF(__pyx_t_5);
+  __Pyx_XDECREF(__pyx_t_6);
+  __Pyx_AddTraceback("crf.Model.dump_states", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "(tree fragment)":1
+ * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
+ *     raise TypeError("self._tagger cannot be converted to a Python object for pickling")
+ * def __setstate_cython__(self, __pyx_state):
+ */
+
+/* Python wrapper */
+static PyObject *__pyx_pw_3crf_5Model_19__reduce_cython__(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
+static char __pyx_doc_3crf_5Model_18__reduce_cython__[] = "Model.__reduce_cython__(self)";
+static PyObject *__pyx_pw_3crf_5Model_19__reduce_cython__(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("__reduce_cython__ (wrapper)", 0);
+  __pyx_r = __pyx_pf_3crf_5Model_18__reduce_cython__(((struct __pyx_obj_3crf_Model *)__pyx_v_self));
+
+  /* function exit code */
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+static PyObject *__pyx_pf_3crf_5Model_18__reduce_cython__(CYTHON_UNUSED struct __pyx_obj_3crf_Model *__pyx_v_self) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("__reduce_cython__", 0);
+
+  /* "(tree fragment)":2
+ * def __reduce_cython__(self):
+ *     raise TypeError("self._tagger cannot be converted to a Python object for pickling")             # <<<<<<<<<<<<<<
+ * def __setstate_cython__(self, __pyx_state):
+ *     raise TypeError("self._tagger cannot be converted to a Python object for pickling")
+ */
+  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__4, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 2, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_Raise(__pyx_t_1, 0, 0, 0);
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __PYX_ERR(1, 2, __pyx_L1_error)
+
+  /* "(tree fragment)":1
+ * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
+ *     raise TypeError("self._tagger cannot be converted to a Python object for pickling")
+ * def __setstate_cython__(self, __pyx_state):
+ */
+
+  /* function exit code */
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_AddTraceback("crf.Model.__reduce_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = NULL;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "(tree fragment)":3
+ * def __reduce_cython__(self):
+ *     raise TypeError("self._tagger cannot be converted to a Python object for pickling")
+ * def __setstate_cython__(self, __pyx_state):             # <<<<<<<<<<<<<<
+ *     raise TypeError("self._tagger cannot be converted to a Python object for pickling")
+ */
+
+/* Python wrapper */
+static PyObject *__pyx_pw_3crf_5Model_21__setstate_cython__(PyObject *__pyx_v_self, PyObject *__pyx_v___pyx_state); /*proto*/
+static char __pyx_doc_3crf_5Model_20__setstate_cython__[] = "Model.__setstate_cython__(self, __pyx_state)";
+static PyObject *__pyx_pw_3crf_5Model_21__setstate_cython__(PyObject *__pyx_v_self, PyObject *__pyx_v___pyx_state) {
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("__setstate_cython__ (wrapper)", 0);
+  __pyx_r = __pyx_pf_3crf_5Model_20__setstate_cython__(((struct __pyx_obj_3crf_Model *)__pyx_v_self), ((PyObject *)__pyx_v___pyx_state));
+
+  /* function exit code */
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+static PyObject *__pyx_pf_3crf_5Model_20__setstate_cython__(CYTHON_UNUSED struct __pyx_obj_3crf_Model *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v___pyx_state) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("__setstate_cython__", 0);
+
+  /* "(tree fragment)":4
+ *     raise TypeError("self._tagger cannot be converted to a Python object for pickling")
+ * def __setstate_cython__(self, __pyx_state):
+ *     raise TypeError("self._tagger cannot be converted to a Python object for pickling")             # <<<<<<<<<<<<<<
+ */
+  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__5, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 4, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_Raise(__pyx_t_1, 0, 0, 0);
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __PYX_ERR(1, 4, __pyx_L1_error)
+
+  /* "(tree fragment)":3
+ * def __reduce_cython__(self):
+ *     raise TypeError("self._tagger cannot be converted to a Python object for pickling")
+ * def __setstate_cython__(self, __pyx_state):             # <<<<<<<<<<<<<<
+ *     raise TypeError("self._tagger cannot be converted to a Python object for pickling")
+ */
+
+  /* function exit code */
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_AddTraceback("crf.Model.__setstate_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = NULL;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "crf.pyx":194
+ *         self._tagger.dump_states(os.open(str(filepath), os.O_WRONLY | os.O_CREAT))
+ * 
+ * cdef crfsuite_api.Item to_item(sequence) except+:             # <<<<<<<<<<<<<<
+ *     cdef crfsuite_api.Item c_item
+ *     cdef double c_value
+ */
+
+static CRFSuite::Item __pyx_f_3crf_to_item(PyObject *__pyx_v_sequence) {
+  CRFSuite::Item __pyx_v_c_item;
+  double __pyx_v_c_value;
+  std::string __pyx_v_c_token;
+  std::string __pyx_v_separator;
+  int __pyx_v_is_dict;
+  PyObject *__pyx_v_token = NULL;
+  PyObject *__pyx_v_value = NULL;
+  CRFSuite::Attribute __pyx_v_attr;
+  CRFSuite::Item __pyx_r;
+  __Pyx_RefNannyDeclarations
+  std::string __pyx_t_1;
+  int __pyx_t_2;
+  CRFSuite::Item __pyx_t_3;
+  Py_ssize_t __pyx_t_4;
+  PyObject *__pyx_t_5 = NULL;
+  PyObject *(*__pyx_t_6)(PyObject *);
+  PyObject *__pyx_t_7 = NULL;
+  int __pyx_t_8;
+  int __pyx_t_9;
+  std::vector<CRFSuite::Attribute> ::iterator __pyx_t_10;
+  CRFSuite::Item *__pyx_t_11;
+  CRFSuite::Attribute __pyx_t_12;
+  std::string __pyx_t_13;
+  double __pyx_t_14;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("to_item", 0);
+
+  /* "crf.pyx":201
+ *     cdef bint is_dict, is_nested_value
+ * 
+ *     separator = b":"             # <<<<<<<<<<<<<<
+ *     is_dict = isinstance(sequence, dict)
+ *     c_item = crfsuite_api.Item()
+ */
+  __pyx_t_1 = __pyx_convert_string_from_py_std__in_string(__pyx_kp_b__6); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 201, __pyx_L1_error)
+  __pyx_v_separator = __pyx_t_1;
+
+  /* "crf.pyx":202
+ * 
+ *     separator = b":"
+ *     is_dict = isinstance(sequence, dict)             # <<<<<<<<<<<<<<
+ *     c_item = crfsuite_api.Item()
+ *     c_item.reserve(len(sequence))
+ */
+  __pyx_t_2 = PyDict_Check(__pyx_v_sequence); 
+  __pyx_v_is_dict = __pyx_t_2;
+
+  /* "crf.pyx":203
+ *     separator = b":"
+ *     is_dict = isinstance(sequence, dict)
+ *     c_item = crfsuite_api.Item()             # <<<<<<<<<<<<<<
+ *     c_item.reserve(len(sequence))
+ * 
+ */
+  try {
+    __pyx_t_3 = CRFSuite::Item();
+  } catch(...) {
+    __Pyx_CppExn2PyErr();
+    __PYX_ERR(0, 203, __pyx_L1_error)
+  }
+  __pyx_v_c_item = __pyx_t_3;
+
+  /* "crf.pyx":204
+ *     is_dict = isinstance(sequence, dict)
+ *     c_item = crfsuite_api.Item()
+ *     c_item.reserve(len(sequence))             # <<<<<<<<<<<<<<
+ * 
+ *     for token in sequence:
+ */
+  __pyx_t_4 = PyObject_Length(__pyx_v_sequence); if (unlikely(__pyx_t_4 == ((Py_ssize_t)-1))) __PYX_ERR(0, 204, __pyx_L1_error)
+  __pyx_v_c_item.reserve(__pyx_t_4);
+
+  /* "crf.pyx":206
+ *     c_item.reserve(len(sequence))
+ * 
+ *     for token in sequence:             # <<<<<<<<<<<<<<
+ *         if isinstance(token, unicode):
+ *             c_token = (<unicode>token).encode("utf8")
+ */
+  if (likely(PyList_CheckExact(__pyx_v_sequence)) || PyTuple_CheckExact(__pyx_v_sequence)) {
+    __pyx_t_5 = __pyx_v_sequence; __Pyx_INCREF(__pyx_t_5); __pyx_t_4 = 0;
+    __pyx_t_6 = NULL;
+  } else {
+    __pyx_t_4 = -1; __pyx_t_5 = PyObject_GetIter(__pyx_v_sequence); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 206, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_5);
+    __pyx_t_6 = Py_TYPE(__pyx_t_5)->tp_iternext; if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 206, __pyx_L1_error)
+  }
+  for (;;) {
+    if (likely(!__pyx_t_6)) {
+      if (likely(PyList_CheckExact(__pyx_t_5))) {
+        if (__pyx_t_4 >= PyList_GET_SIZE(__pyx_t_5)) break;
+        #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
+        __pyx_t_7 = PyList_GET_ITEM(__pyx_t_5, __pyx_t_4); __Pyx_INCREF(__pyx_t_7); __pyx_t_4++; if (unlikely(0 < 0)) __PYX_ERR(0, 206, __pyx_L1_error)
+        #else
+        __pyx_t_7 = PySequence_ITEM(__pyx_t_5, __pyx_t_4); __pyx_t_4++; if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 206, __pyx_L1_error)
+        __Pyx_GOTREF(__pyx_t_7);
+        #endif
+      } else {
+        if (__pyx_t_4 >= PyTuple_GET_SIZE(__pyx_t_5)) break;
+        #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
+        __pyx_t_7 = PyTuple_GET_ITEM(__pyx_t_5, __pyx_t_4); __Pyx_INCREF(__pyx_t_7); __pyx_t_4++; if (unlikely(0 < 0)) __PYX_ERR(0, 206, __pyx_L1_error)
+        #else
+        __pyx_t_7 = PySequence_ITEM(__pyx_t_5, __pyx_t_4); __pyx_t_4++; if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 206, __pyx_L1_error)
+        __Pyx_GOTREF(__pyx_t_7);
+        #endif
+      }
+    } else {
+      __pyx_t_7 = __pyx_t_6(__pyx_t_5);
+      if (unlikely(!__pyx_t_7)) {
+        PyObject* exc_type = PyErr_Occurred();
+        if (exc_type) {
+          if (likely(__Pyx_PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
+          else __PYX_ERR(0, 206, __pyx_L1_error)
+        }
+        break;
+      }
+      __Pyx_GOTREF(__pyx_t_7);
+    }
+    __Pyx_XDECREF_SET(__pyx_v_token, __pyx_t_7);
+    __pyx_t_7 = 0;
+
+    /* "crf.pyx":207
+ * 
+ *     for token in sequence:
+ *         if isinstance(token, unicode):             # <<<<<<<<<<<<<<
+ *             c_token = (<unicode>token).encode("utf8")
+ *         else:
+ */
+    __pyx_t_2 = PyUnicode_Check(__pyx_v_token); 
+    __pyx_t_8 = (__pyx_t_2 != 0);
+    if (__pyx_t_8) {
+
+      /* "crf.pyx":208
+ *     for token in sequence:
+ *         if isinstance(token, unicode):
+ *             c_token = (<unicode>token).encode("utf8")             # <<<<<<<<<<<<<<
+ *         else:
+ *             c_token = token
+ */
+      if (unlikely(__pyx_v_token == Py_None)) {
+        PyErr_Format(PyExc_AttributeError, "'NoneType' object has no attribute '%.30s'", "encode");
+        __PYX_ERR(0, 208, __pyx_L1_error)
+      }
+      __pyx_t_7 = PyUnicode_AsUTF8String(((PyObject*)__pyx_v_token)); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 208, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_7);
+      __pyx_t_1 = __pyx_convert_string_from_py_std__in_string(__pyx_t_7); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 208, __pyx_L1_error)
+      __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
+      __pyx_v_c_token = __pyx_t_1;
+
+      /* "crf.pyx":207
+ * 
+ *     for token in sequence:
+ *         if isinstance(token, unicode):             # <<<<<<<<<<<<<<
+ *             c_token = (<unicode>token).encode("utf8")
+ *         else:
+ */
+      goto __pyx_L5;
+    }
+
+    /* "crf.pyx":210
+ *             c_token = (<unicode>token).encode("utf8")
+ *         else:
+ *             c_token = token             # <<<<<<<<<<<<<<
+ *         if not is_dict:
+ *             c_value = 1.0
+ */
+    /*else*/ {
+      __pyx_t_1 = __pyx_convert_string_from_py_std__in_string(__pyx_v_token); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 210, __pyx_L1_error)
+      __pyx_v_c_token = __pyx_t_1;
+    }
+    __pyx_L5:;
+
+    /* "crf.pyx":211
+ *         else:
+ *             c_token = token
+ *         if not is_dict:             # <<<<<<<<<<<<<<
+ *             c_value = 1.0
+ *             c_item.push_back(crfsuite_api.Attribute(c_token, c_value))
+ */
+    __pyx_t_8 = ((!(__pyx_v_is_dict != 0)) != 0);
+    if (__pyx_t_8) {
+
+      /* "crf.pyx":212
+ *             c_token = token
+ *         if not is_dict:
+ *             c_value = 1.0             # <<<<<<<<<<<<<<
+ *             c_item.push_back(crfsuite_api.Attribute(c_token, c_value))
+ *         else:
+ */
+      __pyx_v_c_value = 1.0;
+
+      /* "crf.pyx":213
+ *         if not is_dict:
+ *             c_value = 1.0
+ *             c_item.push_back(crfsuite_api.Attribute(c_token, c_value))             # <<<<<<<<<<<<<<
+ *         else:
+ *             value = (<dict>sequence)[token]
+ */
+      try {
+        __pyx_v_c_item.push_back(CRFSuite::Attribute(__pyx_v_c_token, __pyx_v_c_value));
+      } catch(...) {
+        __Pyx_CppExn2PyErr();
+        __PYX_ERR(0, 213, __pyx_L1_error)
+      }
+
+      /* "crf.pyx":211
+ *         else:
+ *             c_token = token
+ *         if not is_dict:             # <<<<<<<<<<<<<<
+ *             c_value = 1.0
+ *             c_item.push_back(crfsuite_api.Attribute(c_token, c_value))
+ */
+      goto __pyx_L6;
+    }
+
+    /* "crf.pyx":215
+ *             c_item.push_back(crfsuite_api.Attribute(c_token, c_value))
+ *         else:
+ *             value = (<dict>sequence)[token]             # <<<<<<<<<<<<<<
+ *             if isinstance(value, (dict, list, set)):
+ *                 for attr in to_item(value):
+ */
+    /*else*/ {
+      if (unlikely(__pyx_v_sequence == Py_None)) {
+        PyErr_SetString(PyExc_TypeError, "'NoneType' object is not subscriptable");
+        __PYX_ERR(0, 215, __pyx_L1_error)
+      }
+      __pyx_t_7 = __Pyx_PyDict_GetItem(((PyObject*)__pyx_v_sequence), __pyx_v_token); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 215, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_7);
+      __Pyx_XDECREF_SET(__pyx_v_value, __pyx_t_7);
+      __pyx_t_7 = 0;
+
+      /* "crf.pyx":216
+ *         else:
+ *             value = (<dict>sequence)[token]
+ *             if isinstance(value, (dict, list, set)):             # <<<<<<<<<<<<<<
+ *                 for attr in to_item(value):
+ *                     c_item.push_back(
+ */
+      __pyx_t_2 = PyDict_Check(__pyx_v_value); 
+      __pyx_t_9 = (__pyx_t_2 != 0);
+      if (!__pyx_t_9) {
+      } else {
+        __pyx_t_8 = __pyx_t_9;
+        goto __pyx_L8_bool_binop_done;
+      }
+      __pyx_t_9 = PyList_Check(__pyx_v_value); 
+      __pyx_t_2 = (__pyx_t_9 != 0);
+      if (!__pyx_t_2) {
+      } else {
+        __pyx_t_8 = __pyx_t_2;
+        goto __pyx_L8_bool_binop_done;
+      }
+      __pyx_t_2 = PySet_Check(__pyx_v_value); 
+      __pyx_t_9 = (__pyx_t_2 != 0);
+      __pyx_t_8 = __pyx_t_9;
+      __pyx_L8_bool_binop_done:;
+      __pyx_t_9 = (__pyx_t_8 != 0);
+      if (__pyx_t_9) {
+
+        /* "crf.pyx":217
+ *             value = (<dict>sequence)[token]
+ *             if isinstance(value, (dict, list, set)):
+ *                 for attr in to_item(value):             # <<<<<<<<<<<<<<
+ *                     c_item.push_back(
+ *                         crfsuite_api.Attribute(c_token + separator + attr.attr, attr.value)
+ */
+        try {
+          __pyx_t_3 = __pyx_f_3crf_to_item(__pyx_v_value);
+        } catch(...) {
+          __Pyx_CppExn2PyErr();
+          __PYX_ERR(0, 217, __pyx_L1_error)
+        }
+        __pyx_t_11 = &__pyx_t_3;
+        __pyx_t_10 = __pyx_t_11->begin();
+        for (;;) {
+          if (!(__pyx_t_10 != __pyx_t_11->end())) break;
+          __pyx_t_12 = *__pyx_t_10;
+          ++__pyx_t_10;
+          __pyx_v_attr = __pyx_t_12;
+
+          /* "crf.pyx":219
+ *                 for attr in to_item(value):
+ *                     c_item.push_back(
+ *                         crfsuite_api.Attribute(c_token + separator + attr.attr, attr.value)             # <<<<<<<<<<<<<<
+ *                     )
+ *             else:
+ */
+          try {
+            __pyx_t_1 = (__pyx_v_c_token + __pyx_v_separator);
+          } catch(...) {
+            __Pyx_CppExn2PyErr();
+            __PYX_ERR(0, 219, __pyx_L1_error)
+          }
+          try {
+            __pyx_t_13 = (__pyx_t_1 + __pyx_v_attr.attr);
+          } catch(...) {
+            __Pyx_CppExn2PyErr();
+            __PYX_ERR(0, 219, __pyx_L1_error)
+          }
+
+          /* "crf.pyx":218
+ *             if isinstance(value, (dict, list, set)):
+ *                 for attr in to_item(value):
+ *                     c_item.push_back(             # <<<<<<<<<<<<<<
+ *                         crfsuite_api.Attribute(c_token + separator + attr.attr, attr.value)
+ *                     )
+ */
+          try {
+            __pyx_v_c_item.push_back(CRFSuite::Attribute(__pyx_t_13, __pyx_v_attr.value));
+          } catch(...) {
+            __Pyx_CppExn2PyErr();
+            __PYX_ERR(0, 218, __pyx_L1_error)
+          }
+
+          /* "crf.pyx":217
+ *             value = (<dict>sequence)[token]
+ *             if isinstance(value, (dict, list, set)):
+ *                 for attr in to_item(value):             # <<<<<<<<<<<<<<
+ *                     c_item.push_back(
+ *                         crfsuite_api.Attribute(c_token + separator + attr.attr, attr.value)
+ */
+        }
+
+        /* "crf.pyx":216
+ *         else:
+ *             value = (<dict>sequence)[token]
+ *             if isinstance(value, (dict, list, set)):             # <<<<<<<<<<<<<<
+ *                 for attr in to_item(value):
+ *                     c_item.push_back(
+ */
+        goto __pyx_L7;
+      }
+
+      /* "crf.pyx":222
+ *                     )
+ *             else:
+ *                 if isinstance(value, unicode):             # <<<<<<<<<<<<<<
+ *                     c_token += separator
+ *                     c_token += <string>(<unicode>value).encode("utf8")
+ */
+      /*else*/ {
+        __pyx_t_9 = PyUnicode_Check(__pyx_v_value); 
+        __pyx_t_8 = (__pyx_t_9 != 0);
+        if (__pyx_t_8) {
+
+          /* "crf.pyx":223
+ *             else:
+ *                 if isinstance(value, unicode):
+ *                     c_token += separator             # <<<<<<<<<<<<<<
+ *                     c_token += <string>(<unicode>value).encode("utf8")
+ *                     c_value = 1.0
+ */
+          __pyx_v_c_token += __pyx_v_separator;
+
+          /* "crf.pyx":224
+ *                 if isinstance(value, unicode):
+ *                     c_token += separator
+ *                     c_token += <string>(<unicode>value).encode("utf8")             # <<<<<<<<<<<<<<
+ *                     c_value = 1.0
+ *                 elif isinstance(value, bytes):
+ */
+          if (unlikely(__pyx_v_value == Py_None)) {
+            PyErr_Format(PyExc_AttributeError, "'NoneType' object has no attribute '%.30s'", "encode");
+            __PYX_ERR(0, 224, __pyx_L1_error)
+          }
+          __pyx_t_7 = PyUnicode_AsUTF8String(((PyObject*)__pyx_v_value)); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 224, __pyx_L1_error)
+          __Pyx_GOTREF(__pyx_t_7);
+          __pyx_t_13 = __pyx_convert_string_from_py_std__in_string(__pyx_t_7); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 224, __pyx_L1_error)
+          __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
+          __pyx_v_c_token += ((std::string)__pyx_t_13);
+
+          /* "crf.pyx":225
+ *                     c_token += separator
+ *                     c_token += <string>(<unicode>value).encode("utf8")
+ *                     c_value = 1.0             # <<<<<<<<<<<<<<
+ *                 elif isinstance(value, bytes):
+ *                     c_token += separator
+ */
+          __pyx_v_c_value = 1.0;
+
+          /* "crf.pyx":222
+ *                     )
+ *             else:
+ *                 if isinstance(value, unicode):             # <<<<<<<<<<<<<<
+ *                     c_token += separator
+ *                     c_token += <string>(<unicode>value).encode("utf8")
+ */
+          goto __pyx_L13;
+        }
+
+        /* "crf.pyx":226
+ *                     c_token += <string>(<unicode>value).encode("utf8")
+ *                     c_value = 1.0
+ *                 elif isinstance(value, bytes):             # <<<<<<<<<<<<<<
+ *                     c_token += separator
+ *                     c_token += <string>value
+ */
+        __pyx_t_8 = PyBytes_Check(__pyx_v_value); 
+        __pyx_t_9 = (__pyx_t_8 != 0);
+        if (__pyx_t_9) {
+
+          /* "crf.pyx":227
+ *                     c_value = 1.0
+ *                 elif isinstance(value, bytes):
+ *                     c_token += separator             # <<<<<<<<<<<<<<
+ *                     c_token += <string>value
+ *                     c_value = 1.0
+ */
+          __pyx_v_c_token += __pyx_v_separator;
+
+          /* "crf.pyx":228
+ *                 elif isinstance(value, bytes):
+ *                     c_token += separator
+ *                     c_token += <string>value             # <<<<<<<<<<<<<<
+ *                     c_value = 1.0
+ *                 else:
+ */
+          __pyx_t_13 = __pyx_convert_string_from_py_std__in_string(__pyx_v_value); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 228, __pyx_L1_error)
+          __pyx_v_c_token += ((std::string)__pyx_t_13);
+
+          /* "crf.pyx":229
+ *                     c_token += separator
+ *                     c_token += <string>value
+ *                     c_value = 1.0             # <<<<<<<<<<<<<<
+ *                 else:
+ *                     c_value = value
+ */
+          __pyx_v_c_value = 1.0;
+
+          /* "crf.pyx":226
+ *                     c_token += <string>(<unicode>value).encode("utf8")
+ *                     c_value = 1.0
+ *                 elif isinstance(value, bytes):             # <<<<<<<<<<<<<<
+ *                     c_token += separator
+ *                     c_token += <string>value
+ */
+          goto __pyx_L13;
+        }
+
+        /* "crf.pyx":231
+ *                     c_value = 1.0
+ *                 else:
+ *                     c_value = value             # <<<<<<<<<<<<<<
+ *                 c_item.push_back(crfsuite_api.Attribute(c_token, c_value))
+ *     return c_item
+ */
+        /*else*/ {
+          __pyx_t_14 = __pyx_PyFloat_AsDouble(__pyx_v_value); if (unlikely((__pyx_t_14 == (double)-1) && PyErr_Occurred())) __PYX_ERR(0, 231, __pyx_L1_error)
+          __pyx_v_c_value = __pyx_t_14;
+        }
+        __pyx_L13:;
+
+        /* "crf.pyx":232
+ *                 else:
+ *                     c_value = value
+ *                 c_item.push_back(crfsuite_api.Attribute(c_token, c_value))             # <<<<<<<<<<<<<<
+ *     return c_item
+ * 
+ */
+        try {
+          __pyx_v_c_item.push_back(CRFSuite::Attribute(__pyx_v_c_token, __pyx_v_c_value));
+        } catch(...) {
+          __Pyx_CppExn2PyErr();
+          __PYX_ERR(0, 232, __pyx_L1_error)
+        }
+      }
+      __pyx_L7:;
+    }
+    __pyx_L6:;
+
+    /* "crf.pyx":206
+ *     c_item.reserve(len(sequence))
+ * 
+ *     for token in sequence:             # <<<<<<<<<<<<<<
+ *         if isinstance(token, unicode):
+ *             c_token = (<unicode>token).encode("utf8")
+ */
+  }
+  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+
+  /* "crf.pyx":233
+ *                     c_value = value
+ *                 c_item.push_back(crfsuite_api.Attribute(c_token, c_value))
+ *     return c_item             # <<<<<<<<<<<<<<
+ * 
+ * 
+ */
+  __pyx_r = __pyx_v_c_item;
+  goto __pyx_L0;
+
+  /* "crf.pyx":194
+ *         self._tagger.dump_states(os.open(str(filepath), os.O_WRONLY | os.O_CREAT))
+ * 
+ * cdef crfsuite_api.Item to_item(sequence) except+:             # <<<<<<<<<<<<<<
+ *     cdef crfsuite_api.Item c_item
+ *     cdef double c_value
+ */
+
+  /* function exit code */
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_5);
+  __Pyx_XDECREF(__pyx_t_7);
+  __Pyx_AddTraceback("crf.to_item", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_pretend_to_initialize(&__pyx_r);
+  __pyx_L0:;
+  __Pyx_XDECREF(__pyx_v_token);
+  __Pyx_XDECREF(__pyx_v_value);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "crf.pyx":236
+ * 
+ * 
+ * cdef crfsuite_api.ItemSequence to_seq(sequence) except+:             # <<<<<<<<<<<<<<
+ *     cdef crfsuite_api.ItemSequence c_sequence
+ * 
+ */
+
+static CRFSuite::ItemSequence __pyx_f_3crf_to_seq(PyObject *__pyx_v_sequence) {
+  CRFSuite::ItemSequence __pyx_v_c_sequence;
+  PyObject *__pyx_v_s = NULL;
+  CRFSuite::ItemSequence __pyx_r;
+  __Pyx_RefNannyDeclarations
+  int __pyx_t_1;
+  int __pyx_t_2;
+  CRFSuite::ItemSequence __pyx_t_3;
+  PyObject *__pyx_t_4 = NULL;
+  Py_ssize_t __pyx_t_5;
+  PyObject *(*__pyx_t_6)(PyObject *);
+  PyObject *__pyx_t_7 = NULL;
+  CRFSuite::Item __pyx_t_8;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("to_seq", 0);
+
+  /* "crf.pyx":239
+ *     cdef crfsuite_api.ItemSequence c_sequence
+ * 
+ *     if isinstance(sequence, ItemSequence):             # <<<<<<<<<<<<<<
+ *         c_sequence = (<ItemSequence>sequence).c_sequence
+ *     else:
+ */
+  __pyx_t_1 = __Pyx_TypeCheck(__pyx_v_sequence, __pyx_ptype_3crf_ItemSequence); 
+  __pyx_t_2 = (__pyx_t_1 != 0);
+  if (__pyx_t_2) {
+
+    /* "crf.pyx":240
+ * 
+ *     if isinstance(sequence, ItemSequence):
+ *         c_sequence = (<ItemSequence>sequence).c_sequence             # <<<<<<<<<<<<<<
+ *     else:
+ *         for s in sequence:
+ */
+    __pyx_t_3 = ((struct __pyx_obj_3crf_ItemSequence *)__pyx_v_sequence)->c_sequence;
+    __pyx_v_c_sequence = __pyx_t_3;
+
+    /* "crf.pyx":239
+ *     cdef crfsuite_api.ItemSequence c_sequence
+ * 
+ *     if isinstance(sequence, ItemSequence):             # <<<<<<<<<<<<<<
+ *         c_sequence = (<ItemSequence>sequence).c_sequence
+ *     else:
+ */
+    goto __pyx_L3;
+  }
+
+  /* "crf.pyx":242
+ *         c_sequence = (<ItemSequence>sequence).c_sequence
+ *     else:
+ *         for s in sequence:             # <<<<<<<<<<<<<<
+ *             c_sequence.push_back(to_item(s))
+ *     return c_sequence
+ */
+  /*else*/ {
+    if (likely(PyList_CheckExact(__pyx_v_sequence)) || PyTuple_CheckExact(__pyx_v_sequence)) {
+      __pyx_t_4 = __pyx_v_sequence; __Pyx_INCREF(__pyx_t_4); __pyx_t_5 = 0;
+      __pyx_t_6 = NULL;
+    } else {
+      __pyx_t_5 = -1; __pyx_t_4 = PyObject_GetIter(__pyx_v_sequence); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 242, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_4);
+      __pyx_t_6 = Py_TYPE(__pyx_t_4)->tp_iternext; if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 242, __pyx_L1_error)
+    }
+    for (;;) {
+      if (likely(!__pyx_t_6)) {
+        if (likely(PyList_CheckExact(__pyx_t_4))) {
+          if (__pyx_t_5 >= PyList_GET_SIZE(__pyx_t_4)) break;
+          #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
+          __pyx_t_7 = PyList_GET_ITEM(__pyx_t_4, __pyx_t_5); __Pyx_INCREF(__pyx_t_7); __pyx_t_5++; if (unlikely(0 < 0)) __PYX_ERR(0, 242, __pyx_L1_error)
+          #else
+          __pyx_t_7 = PySequence_ITEM(__pyx_t_4, __pyx_t_5); __pyx_t_5++; if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 242, __pyx_L1_error)
+          __Pyx_GOTREF(__pyx_t_7);
+          #endif
+        } else {
+          if (__pyx_t_5 >= PyTuple_GET_SIZE(__pyx_t_4)) break;
+          #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
+          __pyx_t_7 = PyTuple_GET_ITEM(__pyx_t_4, __pyx_t_5); __Pyx_INCREF(__pyx_t_7); __pyx_t_5++; if (unlikely(0 < 0)) __PYX_ERR(0, 242, __pyx_L1_error)
+          #else
+          __pyx_t_7 = PySequence_ITEM(__pyx_t_4, __pyx_t_5); __pyx_t_5++; if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 242, __pyx_L1_error)
+          __Pyx_GOTREF(__pyx_t_7);
+          #endif
+        }
+      } else {
+        __pyx_t_7 = __pyx_t_6(__pyx_t_4);
+        if (unlikely(!__pyx_t_7)) {
+          PyObject* exc_type = PyErr_Occurred();
+          if (exc_type) {
+            if (likely(__Pyx_PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
+            else __PYX_ERR(0, 242, __pyx_L1_error)
+          }
+          break;
+        }
+        __Pyx_GOTREF(__pyx_t_7);
+      }
+      __Pyx_XDECREF_SET(__pyx_v_s, __pyx_t_7);
+      __pyx_t_7 = 0;
+
+      /* "crf.pyx":243
+ *     else:
+ *         for s in sequence:
+ *             c_sequence.push_back(to_item(s))             # <<<<<<<<<<<<<<
+ *     return c_sequence
+ * 
+ */
+      try {
+        __pyx_t_8 = __pyx_f_3crf_to_item(__pyx_v_s);
+      } catch(...) {
+        __Pyx_CppExn2PyErr();
+        __PYX_ERR(0, 243, __pyx_L1_error)
+      }
+      try {
+        __pyx_v_c_sequence.push_back(__pyx_t_8);
+      } catch(...) {
+        __Pyx_CppExn2PyErr();
+        __PYX_ERR(0, 243, __pyx_L1_error)
+      }
+
+      /* "crf.pyx":242
+ *         c_sequence = (<ItemSequence>sequence).c_sequence
+ *     else:
+ *         for s in sequence:             # <<<<<<<<<<<<<<
+ *             c_sequence.push_back(to_item(s))
+ *     return c_sequence
+ */
+    }
+    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+  }
+  __pyx_L3:;
+
+  /* "crf.pyx":244
+ *         for s in sequence:
+ *             c_sequence.push_back(to_item(s))
+ *     return c_sequence             # <<<<<<<<<<<<<<
+ * 
+ * 
+ */
+  __pyx_r = __pyx_v_c_sequence;
+  goto __pyx_L0;
+
+  /* "crf.pyx":236
+ * 
+ * 
+ * cdef crfsuite_api.ItemSequence to_seq(sequence) except+:             # <<<<<<<<<<<<<<
+ *     cdef crfsuite_api.ItemSequence c_sequence
+ * 
+ */
+
+  /* function exit code */
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_4);
+  __Pyx_XDECREF(__pyx_t_7);
+  __Pyx_AddTraceback("crf.to_seq", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_pretend_to_initialize(&__pyx_r);
+  __pyx_L0:;
+  __Pyx_XDECREF(__pyx_v_s);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "crf.pyx":250
+ *     cdef crfsuite_api.ItemSequence c_sequence
+ * 
+ *     def __init__(self, sequence):             # <<<<<<<<<<<<<<
+ *         self.c_sequence = to_seq(sequence)
+ * 
+ */
+
+/* Python wrapper */
+static int __pyx_pw_3crf_12ItemSequence_1__init__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
+static int __pyx_pw_3crf_12ItemSequence_1__init__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
+  PyObject *__pyx_v_sequence = 0;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("__init__ (wrapper)", 0);
+  {
+    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_sequence,0};
+    PyObject* values[1] = {0};
+    if (unlikely(__pyx_kwds)) {
+      Py_ssize_t kw_args;
+      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
+      switch (pos_args) {
+        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
+        CYTHON_FALLTHROUGH;
+        case  0: break;
+        default: goto __pyx_L5_argtuple_error;
+      }
+      kw_args = PyDict_Size(__pyx_kwds);
+      switch (pos_args) {
+        case  0:
+        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_sequence)) != 0)) kw_args--;
+        else goto __pyx_L5_argtuple_error;
+      }
+      if (unlikely(kw_args > 0)) {
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__init__") < 0)) __PYX_ERR(0, 250, __pyx_L3_error)
+      }
+    } else if (PyTuple_GET_SIZE(__pyx_args) != 1) {
+      goto __pyx_L5_argtuple_error;
+    } else {
+      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
+    }
+    __pyx_v_sequence = values[0];
+  }
+  goto __pyx_L4_argument_unpacking_done;
+  __pyx_L5_argtuple_error:;
+  __Pyx_RaiseArgtupleInvalid("__init__", 1, 1, 1, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 250, __pyx_L3_error)
+  __pyx_L3_error:;
+  __Pyx_AddTraceback("crf.ItemSequence.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_RefNannyFinishContext();
+  return -1;
+  __pyx_L4_argument_unpacking_done:;
+  __pyx_r = __pyx_pf_3crf_12ItemSequence___init__(((struct __pyx_obj_3crf_ItemSequence *)__pyx_v_self), __pyx_v_sequence);
+
+  /* function exit code */
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+static int __pyx_pf_3crf_12ItemSequence___init__(struct __pyx_obj_3crf_ItemSequence *__pyx_v_self, PyObject *__pyx_v_sequence) {
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  CRFSuite::ItemSequence __pyx_t_1;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("__init__", 0);
+
+  /* "crf.pyx":251
+ * 
+ *     def __init__(self, sequence):
+ *         self.c_sequence = to_seq(sequence)             # <<<<<<<<<<<<<<
+ * 
+ *     def items(self):
+ */
+  try {
+    __pyx_t_1 = __pyx_f_3crf_to_seq(__pyx_v_sequence);
+  } catch(...) {
+    __Pyx_CppExn2PyErr();
+    __PYX_ERR(0, 251, __pyx_L1_error)
+  }
+  __pyx_v_self->c_sequence = __pyx_t_1;
+
+  /* "crf.pyx":250
+ *     cdef crfsuite_api.ItemSequence c_sequence
+ * 
+ *     def __init__(self, sequence):             # <<<<<<<<<<<<<<
+ *         self.c_sequence = to_seq(sequence)
+ * 
+ */
+
+  /* function exit code */
+  __pyx_r = 0;
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_AddTraceback("crf.ItemSequence.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = -1;
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "crf.pyx":253
+ *         self.c_sequence = to_seq(sequence)
+ * 
+ *     def items(self):             # <<<<<<<<<<<<<<
+ *         cdef crfsuite_api.Item c_item
+ *         cdef crfsuite_api.Attribute c_attr
+ */
+
+/* Python wrapper */
+static PyObject *__pyx_pw_3crf_12ItemSequence_3items(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
+static char __pyx_doc_3crf_12ItemSequence_2items[] = "ItemSequence.items(self)";
+static PyObject *__pyx_pw_3crf_12ItemSequence_3items(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("items (wrapper)", 0);
+  __pyx_r = __pyx_pf_3crf_12ItemSequence_2items(((struct __pyx_obj_3crf_ItemSequence *)__pyx_v_self));
+
+  /* function exit code */
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+static PyObject *__pyx_pf_3crf_12ItemSequence_2items(struct __pyx_obj_3crf_ItemSequence *__pyx_v_self) {
+  CRFSuite::Item __pyx_v_c_item;
+  CRFSuite::Attribute __pyx_v_c_attr;
+  PyObject *__pyx_v_token = 0;
+  PyObject *__pyx_v_sequence = NULL;
+  PyObject *__pyx_v_x = NULL;
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  std::vector<CRFSuite::Item> ::iterator __pyx_t_2;
+  CRFSuite::ItemSequence *__pyx_t_3;
+  CRFSuite::Item __pyx_t_4;
+  std::vector<CRFSuite::Attribute> ::iterator __pyx_t_5;
+  CRFSuite::Attribute __pyx_t_6;
+  PyObject *__pyx_t_7 = NULL;
+  int __pyx_t_8;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("items", 0);
+
+  /* "crf.pyx":258
+ *         cdef bytes token
+ * 
+ *         sequence = []             # <<<<<<<<<<<<<<
+ *         for c_item in self.c_sequence:
+ *             x = {}
+ */
+  __pyx_t_1 = PyList_New(0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 258, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_v_sequence = ((PyObject*)__pyx_t_1);
+  __pyx_t_1 = 0;
+
+  /* "crf.pyx":259
+ * 
+ *         sequence = []
+ *         for c_item in self.c_sequence:             # <<<<<<<<<<<<<<
+ *             x = {}
+ *             for c_attr in c_item:
+ */
+  __pyx_t_3 = &__pyx_v_self->c_sequence;
+  __pyx_t_2 = __pyx_t_3->begin();
+  for (;;) {
+    if (!(__pyx_t_2 != __pyx_t_3->end())) break;
+    __pyx_t_4 = *__pyx_t_2;
+    ++__pyx_t_2;
+    __pyx_v_c_item = __pyx_t_4;
+
+    /* "crf.pyx":260
+ *         sequence = []
+ *         for c_item in self.c_sequence:
+ *             x = {}             # <<<<<<<<<<<<<<
+ *             for c_attr in c_item:
+ *                 token = <bytes>c_attr.attr.c_str()
+ */
+    __pyx_t_1 = __Pyx_PyDict_NewPresized(0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 260, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_1);
+    __Pyx_XDECREF_SET(__pyx_v_x, ((PyObject*)__pyx_t_1));
+    __pyx_t_1 = 0;
+
+    /* "crf.pyx":261
+ *         for c_item in self.c_sequence:
+ *             x = {}
+ *             for c_attr in c_item:             # <<<<<<<<<<<<<<
+ *                 token = <bytes>c_attr.attr.c_str()
+ *                 x[token.decode("utf8")] = c_attr.value
+ */
+    __pyx_t_5 = __pyx_v_c_item.begin();
+    for (;;) {
+      if (!(__pyx_t_5 != __pyx_v_c_item.end())) break;
+      __pyx_t_6 = *__pyx_t_5;
+      ++__pyx_t_5;
+      __pyx_v_c_attr = __pyx_t_6;
+
+      /* "crf.pyx":262
+ *             x = {}
+ *             for c_attr in c_item:
+ *                 token = <bytes>c_attr.attr.c_str()             # <<<<<<<<<<<<<<
+ *                 x[token.decode("utf8")] = c_attr.value
+ *             sequence.append(x)
+ */
+      __pyx_t_1 = __Pyx_PyBytes_FromString(__pyx_v_c_attr.attr.c_str()); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 262, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_1);
+      __pyx_t_7 = __pyx_t_1;
+      __Pyx_INCREF(__pyx_t_7);
+      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+      __Pyx_XDECREF_SET(__pyx_v_token, ((PyObject*)__pyx_t_7));
+      __pyx_t_7 = 0;
+
+      /* "crf.pyx":263
+ *             for c_attr in c_item:
+ *                 token = <bytes>c_attr.attr.c_str()
+ *                 x[token.decode("utf8")] = c_attr.value             # <<<<<<<<<<<<<<
+ *             sequence.append(x)
+ *         return sequence
+ */
+      __pyx_t_7 = PyFloat_FromDouble(__pyx_v_c_attr.value); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 263, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_7);
+      if (unlikely(__pyx_v_token == Py_None)) {
+        PyErr_Format(PyExc_AttributeError, "'NoneType' object has no attribute '%.30s'", "decode");
+        __PYX_ERR(0, 263, __pyx_L1_error)
+      }
+      __pyx_t_1 = __Pyx_decode_bytes(__pyx_v_token, 0, PY_SSIZE_T_MAX, NULL, NULL, PyUnicode_DecodeUTF8); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 263, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_1);
+      if (unlikely(PyDict_SetItem(__pyx_v_x, __pyx_t_1, __pyx_t_7) < 0)) __PYX_ERR(0, 263, __pyx_L1_error)
+      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+      __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
+
+      /* "crf.pyx":261
+ *         for c_item in self.c_sequence:
+ *             x = {}
+ *             for c_attr in c_item:             # <<<<<<<<<<<<<<
+ *                 token = <bytes>c_attr.attr.c_str()
+ *                 x[token.decode("utf8")] = c_attr.value
+ */
+    }
+
+    /* "crf.pyx":264
+ *                 token = <bytes>c_attr.attr.c_str()
+ *                 x[token.decode("utf8")] = c_attr.value
+ *             sequence.append(x)             # <<<<<<<<<<<<<<
+ *         return sequence
+ * 
+ */
+    __pyx_t_8 = __Pyx_PyList_Append(__pyx_v_sequence, __pyx_v_x); if (unlikely(__pyx_t_8 == ((int)-1))) __PYX_ERR(0, 264, __pyx_L1_error)
+
+    /* "crf.pyx":259
+ * 
+ *         sequence = []
+ *         for c_item in self.c_sequence:             # <<<<<<<<<<<<<<
+ *             x = {}
+ *             for c_attr in c_item:
+ */
+  }
+
+  /* "crf.pyx":265
+ *                 x[token.decode("utf8")] = c_attr.value
+ *             sequence.append(x)
+ *         return sequence             # <<<<<<<<<<<<<<
+ * 
+ *     def __len__(self):
+ */
+  __Pyx_XDECREF(__pyx_r);
+  __Pyx_INCREF(__pyx_v_sequence);
+  __pyx_r = __pyx_v_sequence;
+  goto __pyx_L0;
+
+  /* "crf.pyx":253
+ *         self.c_sequence = to_seq(sequence)
+ * 
+ *     def items(self):             # <<<<<<<<<<<<<<
+ *         cdef crfsuite_api.Item c_item
+ *         cdef crfsuite_api.Attribute c_attr
+ */
+
+  /* function exit code */
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_XDECREF(__pyx_t_7);
+  __Pyx_AddTraceback("crf.ItemSequence.items", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_XDECREF(__pyx_v_token);
+  __Pyx_XDECREF(__pyx_v_sequence);
+  __Pyx_XDECREF(__pyx_v_x);
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "crf.pyx":267
+ *         return sequence
+ * 
+ *     def __len__(self):             # <<<<<<<<<<<<<<
+ *         return self.c_sequence.size()
+ * 
+ */
+
+/* Python wrapper */
+static Py_ssize_t __pyx_pw_3crf_12ItemSequence_5__len__(PyObject *__pyx_v_self); /*proto*/
+static Py_ssize_t __pyx_pw_3crf_12ItemSequence_5__len__(PyObject *__pyx_v_self) {
+  Py_ssize_t __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("__len__ (wrapper)", 0);
+  __pyx_r = __pyx_pf_3crf_12ItemSequence_4__len__(((struct __pyx_obj_3crf_ItemSequence *)__pyx_v_self));
+
+  /* function exit code */
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+static Py_ssize_t __pyx_pf_3crf_12ItemSequence_4__len__(struct __pyx_obj_3crf_ItemSequence *__pyx_v_self) {
+  Py_ssize_t __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("__len__", 0);
+
+  /* "crf.pyx":268
+ * 
+ *     def __len__(self):
+ *         return self.c_sequence.size()             # <<<<<<<<<<<<<<
+ * 
+ *     def __repr__(self):
+ */
+  __pyx_r = __pyx_v_self->c_sequence.size();
+  goto __pyx_L0;
+
+  /* "crf.pyx":267
+ *         return sequence
+ * 
+ *     def __len__(self):             # <<<<<<<<<<<<<<
+ *         return self.c_sequence.size()
+ * 
+ */
+
+  /* function exit code */
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "crf.pyx":270
+ *         return self.c_sequence.size()
+ * 
+ *     def __repr__(self):             # <<<<<<<<<<<<<<
+ *         return f"<ItemSequence ({len(self)})>"
+ */
+
+/* Python wrapper */
+static PyObject *__pyx_pw_3crf_12ItemSequence_7__repr__(PyObject *__pyx_v_self); /*proto*/
+static PyObject *__pyx_pw_3crf_12ItemSequence_7__repr__(PyObject *__pyx_v_self) {
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("__repr__ (wrapper)", 0);
+  __pyx_r = __pyx_pf_3crf_12ItemSequence_6__repr__(((struct __pyx_obj_3crf_ItemSequence *)__pyx_v_self));
+
+  /* function exit code */
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+static PyObject *__pyx_pf_3crf_12ItemSequence_6__repr__(struct __pyx_obj_3crf_ItemSequence *__pyx_v_self) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  Py_ssize_t __pyx_t_2;
+  Py_UCS4 __pyx_t_3;
+  Py_ssize_t __pyx_t_4;
+  PyObject *__pyx_t_5 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("__repr__", 0);
+
+  /* "crf.pyx":271
+ * 
+ *     def __repr__(self):
+ *         return f"<ItemSequence ({len(self)})>"             # <<<<<<<<<<<<<<
+ */
+  __Pyx_XDECREF(__pyx_r);
+  __pyx_t_1 = PyTuple_New(3); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 271, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_t_2 = 0;
+  __pyx_t_3 = 127;
+  __Pyx_INCREF(__pyx_kp_u_ItemSequence);
+  __pyx_t_2 += 15;
+  __Pyx_GIVEREF(__pyx_kp_u_ItemSequence);
+  PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_kp_u_ItemSequence);
+  __pyx_t_4 = PyObject_Length(((PyObject *)__pyx_v_self)); if (unlikely(__pyx_t_4 == ((Py_ssize_t)-1))) __PYX_ERR(0, 271, __pyx_L1_error)
+  __pyx_t_5 = __Pyx_PyUnicode_From_Py_ssize_t(__pyx_t_4, 0, ' ', 'd'); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 271, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_5);
+  __pyx_t_2 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_5);
+  __Pyx_GIVEREF(__pyx_t_5);
+  PyTuple_SET_ITEM(__pyx_t_1, 1, __pyx_t_5);
+  __pyx_t_5 = 0;
+  __Pyx_INCREF(__pyx_kp_u__7);
+  __pyx_t_2 += 2;
+  __Pyx_GIVEREF(__pyx_kp_u__7);
+  PyTuple_SET_ITEM(__pyx_t_1, 2, __pyx_kp_u__7);
+  __pyx_t_5 = __Pyx_PyUnicode_Join(__pyx_t_1, 3, __pyx_t_2, __pyx_t_3); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 271, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_5);
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __pyx_r = __pyx_t_5;
+  __pyx_t_5 = 0;
+  goto __pyx_L0;
+
+  /* "crf.pyx":270
+ *         return self.c_sequence.size()
+ * 
+ *     def __repr__(self):             # <<<<<<<<<<<<<<
+ *         return f"<ItemSequence ({len(self)})>"
+ */
+
+  /* function exit code */
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_XDECREF(__pyx_t_5);
+  __Pyx_AddTraceback("crf.ItemSequence.__repr__", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "(tree fragment)":1
+ * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
+ *     raise TypeError("self.c_sequence cannot be converted to a Python object for pickling")
+ * def __setstate_cython__(self, __pyx_state):
+ */
+
+/* Python wrapper */
+static PyObject *__pyx_pw_3crf_12ItemSequence_9__reduce_cython__(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
+static char __pyx_doc_3crf_12ItemSequence_8__reduce_cython__[] = "ItemSequence.__reduce_cython__(self)";
+static PyObject *__pyx_pw_3crf_12ItemSequence_9__reduce_cython__(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("__reduce_cython__ (wrapper)", 0);
+  __pyx_r = __pyx_pf_3crf_12ItemSequence_8__reduce_cython__(((struct __pyx_obj_3crf_ItemSequence *)__pyx_v_self));
+
+  /* function exit code */
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+static PyObject *__pyx_pf_3crf_12ItemSequence_8__reduce_cython__(CYTHON_UNUSED struct __pyx_obj_3crf_ItemSequence *__pyx_v_self) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("__reduce_cython__", 0);
+
+  /* "(tree fragment)":2
+ * def __reduce_cython__(self):
+ *     raise TypeError("self.c_sequence cannot be converted to a Python object for pickling")             # <<<<<<<<<<<<<<
+ * def __setstate_cython__(self, __pyx_state):
+ *     raise TypeError("self.c_sequence cannot be converted to a Python object for pickling")
+ */
+  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__8, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 2, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_Raise(__pyx_t_1, 0, 0, 0);
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __PYX_ERR(1, 2, __pyx_L1_error)
+
+  /* "(tree fragment)":1
+ * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
+ *     raise TypeError("self.c_sequence cannot be converted to a Python object for pickling")
+ * def __setstate_cython__(self, __pyx_state):
+ */
+
+  /* function exit code */
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_AddTraceback("crf.ItemSequence.__reduce_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = NULL;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "(tree fragment)":3
+ * def __reduce_cython__(self):
+ *     raise TypeError("self.c_sequence cannot be converted to a Python object for pickling")
+ * def __setstate_cython__(self, __pyx_state):             # <<<<<<<<<<<<<<
+ *     raise TypeError("self.c_sequence cannot be converted to a Python object for pickling")
+ */
+
+/* Python wrapper */
+static PyObject *__pyx_pw_3crf_12ItemSequence_11__setstate_cython__(PyObject *__pyx_v_self, PyObject *__pyx_v___pyx_state); /*proto*/
+static char __pyx_doc_3crf_12ItemSequence_10__setstate_cython__[] = "ItemSequence.__setstate_cython__(self, __pyx_state)";
+static PyObject *__pyx_pw_3crf_12ItemSequence_11__setstate_cython__(PyObject *__pyx_v_self, PyObject *__pyx_v___pyx_state) {
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("__setstate_cython__ (wrapper)", 0);
+  __pyx_r = __pyx_pf_3crf_12ItemSequence_10__setstate_cython__(((struct __pyx_obj_3crf_ItemSequence *)__pyx_v_self), ((PyObject *)__pyx_v___pyx_state));
+
+  /* function exit code */
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+static PyObject *__pyx_pf_3crf_12ItemSequence_10__setstate_cython__(CYTHON_UNUSED struct __pyx_obj_3crf_ItemSequence *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v___pyx_state) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("__setstate_cython__", 0);
+
+  /* "(tree fragment)":4
+ *     raise TypeError("self.c_sequence cannot be converted to a Python object for pickling")
+ * def __setstate_cython__(self, __pyx_state):
+ *     raise TypeError("self.c_sequence cannot be converted to a Python object for pickling")             # <<<<<<<<<<<<<<
+ */
+  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__9, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 4, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_Raise(__pyx_t_1, 0, 0, 0);
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __PYX_ERR(1, 4, __pyx_L1_error)
+
+  /* "(tree fragment)":3
+ * def __reduce_cython__(self):
+ *     raise TypeError("self.c_sequence cannot be converted to a Python object for pickling")
+ * def __setstate_cython__(self, __pyx_state):             # <<<<<<<<<<<<<<
+ *     raise TypeError("self.c_sequence cannot be converted to a Python object for pickling")
+ */
+
+  /* function exit code */
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_AddTraceback("crf.ItemSequence.__setstate_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = NULL;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "string.from_py":13
+ * 
+ * @cname("__pyx_convert_string_from_py_std__in_string")
+ * cdef string __pyx_convert_string_from_py_std__in_string(object o) except *:             # <<<<<<<<<<<<<<
+ *     cdef Py_ssize_t length = 0
+ *     cdef const char* data = __Pyx_PyObject_AsStringAndSize(o, &length)
+ */
+
+static std::string __pyx_convert_string_from_py_std__in_string(PyObject *__pyx_v_o) {
+  Py_ssize_t __pyx_v_length;
+  char const *__pyx_v_data;
+  std::string __pyx_r;
+  __Pyx_RefNannyDeclarations
+  char const *__pyx_t_1;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("__pyx_convert_string_from_py_std__in_string", 0);
+
+  /* "string.from_py":14
+ * @cname("__pyx_convert_string_from_py_std__in_string")
+ * cdef string __pyx_convert_string_from_py_std__in_string(object o) except *:
+ *     cdef Py_ssize_t length = 0             # <<<<<<<<<<<<<<
+ *     cdef const char* data = __Pyx_PyObject_AsStringAndSize(o, &length)
+ *     return string(data, length)
+ */
+  __pyx_v_length = 0;
+
+  /* "string.from_py":15
+ * cdef string __pyx_convert_string_from_py_std__in_string(object o) except *:
+ *     cdef Py_ssize_t length = 0
+ *     cdef const char* data = __Pyx_PyObject_AsStringAndSize(o, &length)             # <<<<<<<<<<<<<<
+ *     return string(data, length)
+ * 
+ */
+  __pyx_t_1 = __Pyx_PyObject_AsStringAndSize(__pyx_v_o, (&__pyx_v_length)); if (unlikely(__pyx_t_1 == ((char const *)NULL))) __PYX_ERR(1, 15, __pyx_L1_error)
+  __pyx_v_data = __pyx_t_1;
+
+  /* "string.from_py":16
+ *     cdef Py_ssize_t length = 0
+ *     cdef const char* data = __Pyx_PyObject_AsStringAndSize(o, &length)
+ *     return string(data, length)             # <<<<<<<<<<<<<<
+ * 
+ * 
+ */
+  __pyx_r = std::string(__pyx_v_data, __pyx_v_length);
+  goto __pyx_L0;
+
+  /* "string.from_py":13
+ * 
+ * @cname("__pyx_convert_string_from_py_std__in_string")
+ * cdef string __pyx_convert_string_from_py_std__in_string(object o) except *:             # <<<<<<<<<<<<<<
+ *     cdef Py_ssize_t length = 0
+ *     cdef const char* data = __Pyx_PyObject_AsStringAndSize(o, &length)
+ */
+
+  /* function exit code */
+  __pyx_L1_error:;
+  __Pyx_AddTraceback("string.from_py.__pyx_convert_string_from_py_std__in_string", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_pretend_to_initialize(&__pyx_r);
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "string.to_py":31
+ * 
+ * @cname("__pyx_convert_PyObject_string_to_py_std__in_string")
+ * cdef inline object __pyx_convert_PyObject_string_to_py_std__in_string(const string& s):             # <<<<<<<<<<<<<<
+ *     return __Pyx_PyObject_FromStringAndSize(s.data(), s.size())
+ * cdef extern from *:
+ */
+
+static CYTHON_INLINE PyObject *__pyx_convert_PyObject_string_to_py_std__in_string(std::string const &__pyx_v_s) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("__pyx_convert_PyObject_string_to_py_std__in_string", 0);
+
+  /* "string.to_py":32
+ * @cname("__pyx_convert_PyObject_string_to_py_std__in_string")
+ * cdef inline object __pyx_convert_PyObject_string_to_py_std__in_string(const string& s):
+ *     return __Pyx_PyObject_FromStringAndSize(s.data(), s.size())             # <<<<<<<<<<<<<<
+ * cdef extern from *:
+ *     cdef object __Pyx_PyUnicode_FromStringAndSize(const char*, size_t)
+ */
+  __Pyx_XDECREF(__pyx_r);
+  __pyx_t_1 = __Pyx_PyObject_FromStringAndSize(__pyx_v_s.data(), __pyx_v_s.size()); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 32, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_r = __pyx_t_1;
+  __pyx_t_1 = 0;
+  goto __pyx_L0;
+
+  /* "string.to_py":31
+ * 
+ * @cname("__pyx_convert_PyObject_string_to_py_std__in_string")
+ * cdef inline object __pyx_convert_PyObject_string_to_py_std__in_string(const string& s):             # <<<<<<<<<<<<<<
+ *     return __Pyx_PyObject_FromStringAndSize(s.data(), s.size())
+ * cdef extern from *:
+ */
+
+  /* function exit code */
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_AddTraceback("string.to_py.__pyx_convert_PyObject_string_to_py_std__in_string", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "string.to_py":37
+ * 
+ * @cname("__pyx_convert_PyUnicode_string_to_py_std__in_string")
+ * cdef inline object __pyx_convert_PyUnicode_string_to_py_std__in_string(const string& s):             # <<<<<<<<<<<<<<
+ *     return __Pyx_PyUnicode_FromStringAndSize(s.data(), s.size())
+ * cdef extern from *:
+ */
+
+static CYTHON_INLINE PyObject *__pyx_convert_PyUnicode_string_to_py_std__in_string(std::string const &__pyx_v_s) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("__pyx_convert_PyUnicode_string_to_py_std__in_string", 0);
+
+  /* "string.to_py":38
+ * @cname("__pyx_convert_PyUnicode_string_to_py_std__in_string")
+ * cdef inline object __pyx_convert_PyUnicode_string_to_py_std__in_string(const string& s):
+ *     return __Pyx_PyUnicode_FromStringAndSize(s.data(), s.size())             # <<<<<<<<<<<<<<
+ * cdef extern from *:
+ *     cdef object __Pyx_PyStr_FromStringAndSize(const char*, size_t)
+ */
+  __Pyx_XDECREF(__pyx_r);
+  __pyx_t_1 = __Pyx_PyUnicode_FromStringAndSize(__pyx_v_s.data(), __pyx_v_s.size()); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 38, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_r = __pyx_t_1;
+  __pyx_t_1 = 0;
+  goto __pyx_L0;
+
+  /* "string.to_py":37
+ * 
+ * @cname("__pyx_convert_PyUnicode_string_to_py_std__in_string")
+ * cdef inline object __pyx_convert_PyUnicode_string_to_py_std__in_string(const string& s):             # <<<<<<<<<<<<<<
+ *     return __Pyx_PyUnicode_FromStringAndSize(s.data(), s.size())
+ * cdef extern from *:
+ */
+
+  /* function exit code */
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_AddTraceback("string.to_py.__pyx_convert_PyUnicode_string_to_py_std__in_string", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "string.to_py":43
+ * 
+ * @cname("__pyx_convert_PyStr_string_to_py_std__in_string")
+ * cdef inline object __pyx_convert_PyStr_string_to_py_std__in_string(const string& s):             # <<<<<<<<<<<<<<
+ *     return __Pyx_PyStr_FromStringAndSize(s.data(), s.size())
+ * cdef extern from *:
+ */
+
+static CYTHON_INLINE PyObject *__pyx_convert_PyStr_string_to_py_std__in_string(std::string const &__pyx_v_s) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("__pyx_convert_PyStr_string_to_py_std__in_string", 0);
+
+  /* "string.to_py":44
+ * @cname("__pyx_convert_PyStr_string_to_py_std__in_string")
+ * cdef inline object __pyx_convert_PyStr_string_to_py_std__in_string(const string& s):
+ *     return __Pyx_PyStr_FromStringAndSize(s.data(), s.size())             # <<<<<<<<<<<<<<
+ * cdef extern from *:
+ *     cdef object __Pyx_PyBytes_FromStringAndSize(const char*, size_t)
+ */
+  __Pyx_XDECREF(__pyx_r);
+  __pyx_t_1 = __Pyx_PyStr_FromStringAndSize(__pyx_v_s.data(), __pyx_v_s.size()); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 44, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_r = __pyx_t_1;
+  __pyx_t_1 = 0;
+  goto __pyx_L0;
+
+  /* "string.to_py":43
+ * 
+ * @cname("__pyx_convert_PyStr_string_to_py_std__in_string")
+ * cdef inline object __pyx_convert_PyStr_string_to_py_std__in_string(const string& s):             # <<<<<<<<<<<<<<
+ *     return __Pyx_PyStr_FromStringAndSize(s.data(), s.size())
+ * cdef extern from *:
+ */
+
+  /* function exit code */
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_AddTraceback("string.to_py.__pyx_convert_PyStr_string_to_py_std__in_string", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "string.to_py":49
+ * 
+ * @cname("__pyx_convert_PyBytes_string_to_py_std__in_string")
+ * cdef inline object __pyx_convert_PyBytes_string_to_py_std__in_string(const string& s):             # <<<<<<<<<<<<<<
+ *     return __Pyx_PyBytes_FromStringAndSize(s.data(), s.size())
+ * cdef extern from *:
+ */
+
+static CYTHON_INLINE PyObject *__pyx_convert_PyBytes_string_to_py_std__in_string(std::string const &__pyx_v_s) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("__pyx_convert_PyBytes_string_to_py_std__in_string", 0);
+
+  /* "string.to_py":50
+ * @cname("__pyx_convert_PyBytes_string_to_py_std__in_string")
+ * cdef inline object __pyx_convert_PyBytes_string_to_py_std__in_string(const string& s):
+ *     return __Pyx_PyBytes_FromStringAndSize(s.data(), s.size())             # <<<<<<<<<<<<<<
+ * cdef extern from *:
+ *     cdef object __Pyx_PyByteArray_FromStringAndSize(const char*, size_t)
+ */
+  __Pyx_XDECREF(__pyx_r);
+  __pyx_t_1 = __Pyx_PyBytes_FromStringAndSize(__pyx_v_s.data(), __pyx_v_s.size()); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 50, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_r = __pyx_t_1;
+  __pyx_t_1 = 0;
+  goto __pyx_L0;
+
+  /* "string.to_py":49
+ * 
+ * @cname("__pyx_convert_PyBytes_string_to_py_std__in_string")
+ * cdef inline object __pyx_convert_PyBytes_string_to_py_std__in_string(const string& s):             # <<<<<<<<<<<<<<
+ *     return __Pyx_PyBytes_FromStringAndSize(s.data(), s.size())
+ * cdef extern from *:
+ */
+
+  /* function exit code */
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_AddTraceback("string.to_py.__pyx_convert_PyBytes_string_to_py_std__in_string", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "string.to_py":55
+ * 
+ * @cname("__pyx_convert_PyByteArray_string_to_py_std__in_string")
+ * cdef inline object __pyx_convert_PyByteArray_string_to_py_std__in_string(const string& s):             # <<<<<<<<<<<<<<
+ *     return __Pyx_PyByteArray_FromStringAndSize(s.data(), s.size())
+ * 
+ */
+
+static CYTHON_INLINE PyObject *__pyx_convert_PyByteArray_string_to_py_std__in_string(std::string const &__pyx_v_s) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("__pyx_convert_PyByteArray_string_to_py_std__in_string", 0);
+
+  /* "string.to_py":56
+ * @cname("__pyx_convert_PyByteArray_string_to_py_std__in_string")
+ * cdef inline object __pyx_convert_PyByteArray_string_to_py_std__in_string(const string& s):
+ *     return __Pyx_PyByteArray_FromStringAndSize(s.data(), s.size())             # <<<<<<<<<<<<<<
+ * 
+ */
+  __Pyx_XDECREF(__pyx_r);
+  __pyx_t_1 = __Pyx_PyByteArray_FromStringAndSize(__pyx_v_s.data(), __pyx_v_s.size()); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 56, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_r = __pyx_t_1;
+  __pyx_t_1 = 0;
+  goto __pyx_L0;
+
+  /* "string.to_py":55
+ * 
+ * @cname("__pyx_convert_PyByteArray_string_to_py_std__in_string")
+ * cdef inline object __pyx_convert_PyByteArray_string_to_py_std__in_string(const string& s):             # <<<<<<<<<<<<<<
+ *     return __Pyx_PyByteArray_FromStringAndSize(s.data(), s.size())
+ * 
+ */
+
+  /* function exit code */
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_AddTraceback("string.to_py.__pyx_convert_PyByteArray_string_to_py_std__in_string", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "vector.to_py":60
+ * 
+ * @cname("__pyx_convert_vector_to_py_std_3a__3a_string")
+ * cdef object __pyx_convert_vector_to_py_std_3a__3a_string(vector[X]& v):             # <<<<<<<<<<<<<<
+ *     return [v[i] for i in range(v.size())]
+ * 
+ */
+
+static PyObject *__pyx_convert_vector_to_py_std_3a__3a_string(const std::vector<std::string>  &__pyx_v_v) {
+  size_t __pyx_v_i;
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  size_t __pyx_t_2;
+  size_t __pyx_t_3;
+  size_t __pyx_t_4;
+  PyObject *__pyx_t_5 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("__pyx_convert_vector_to_py_std_3a__3a_string", 0);
+
+  /* "vector.to_py":61
+ * @cname("__pyx_convert_vector_to_py_std_3a__3a_string")
+ * cdef object __pyx_convert_vector_to_py_std_3a__3a_string(vector[X]& v):
+ *     return [v[i] for i in range(v.size())]             # <<<<<<<<<<<<<<
+ * 
+ * 
+ */
+  __Pyx_XDECREF(__pyx_r);
+  __pyx_t_1 = PyList_New(0); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 61, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_t_2 = __pyx_v_v.size();
+  __pyx_t_3 = __pyx_t_2;
+  for (__pyx_t_4 = 0; __pyx_t_4 < __pyx_t_3; __pyx_t_4+=1) {
+    __pyx_v_i = __pyx_t_4;
+    __pyx_t_5 = __pyx_convert_PyStr_string_to_py_std__in_string((__pyx_v_v[__pyx_v_i])); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 61, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_5);
+    if (unlikely(__Pyx_ListComp_Append(__pyx_t_1, (PyObject*)__pyx_t_5))) __PYX_ERR(1, 61, __pyx_L1_error)
+    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+  }
+  __pyx_r = __pyx_t_1;
+  __pyx_t_1 = 0;
+  goto __pyx_L0;
+
+  /* "vector.to_py":60
+ * 
+ * @cname("__pyx_convert_vector_to_py_std_3a__3a_string")
+ * cdef object __pyx_convert_vector_to_py_std_3a__3a_string(vector[X]& v):             # <<<<<<<<<<<<<<
+ *     return [v[i] for i in range(v.size())]
+ * 
+ */
+
+  /* function exit code */
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_XDECREF(__pyx_t_5);
+  __Pyx_AddTraceback("vector.to_py.__pyx_convert_vector_to_py_std_3a__3a_string", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "vector.from_py":45
+ * 
+ * @cname("__pyx_convert_vector_from_py_std_3a__3a_string")
+ * cdef vector[X] __pyx_convert_vector_from_py_std_3a__3a_string(object o) except *:             # <<<<<<<<<<<<<<
+ *     cdef vector[X] v
+ *     for item in o:
+ */
+
+static std::vector<std::string>  __pyx_convert_vector_from_py_std_3a__3a_string(PyObject *__pyx_v_o) {
+  std::vector<std::string>  __pyx_v_v;
+  PyObject *__pyx_v_item = NULL;
+  std::vector<std::string>  __pyx_r;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  Py_ssize_t __pyx_t_2;
+  PyObject *(*__pyx_t_3)(PyObject *);
+  PyObject *__pyx_t_4 = NULL;
+  std::string __pyx_t_5;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("__pyx_convert_vector_from_py_std_3a__3a_string", 0);
+
+  /* "vector.from_py":47
+ * cdef vector[X] __pyx_convert_vector_from_py_std_3a__3a_string(object o) except *:
+ *     cdef vector[X] v
+ *     for item in o:             # <<<<<<<<<<<<<<
+ *         v.push_back(<X>item)
+ *     return v
+ */
+  if (likely(PyList_CheckExact(__pyx_v_o)) || PyTuple_CheckExact(__pyx_v_o)) {
+    __pyx_t_1 = __pyx_v_o; __Pyx_INCREF(__pyx_t_1); __pyx_t_2 = 0;
+    __pyx_t_3 = NULL;
+  } else {
+    __pyx_t_2 = -1; __pyx_t_1 = PyObject_GetIter(__pyx_v_o); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 47, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_1);
+    __pyx_t_3 = Py_TYPE(__pyx_t_1)->tp_iternext; if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 47, __pyx_L1_error)
+  }
+  for (;;) {
+    if (likely(!__pyx_t_3)) {
+      if (likely(PyList_CheckExact(__pyx_t_1))) {
+        if (__pyx_t_2 >= PyList_GET_SIZE(__pyx_t_1)) break;
+        #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
+        __pyx_t_4 = PyList_GET_ITEM(__pyx_t_1, __pyx_t_2); __Pyx_INCREF(__pyx_t_4); __pyx_t_2++; if (unlikely(0 < 0)) __PYX_ERR(1, 47, __pyx_L1_error)
+        #else
+        __pyx_t_4 = PySequence_ITEM(__pyx_t_1, __pyx_t_2); __pyx_t_2++; if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 47, __pyx_L1_error)
+        __Pyx_GOTREF(__pyx_t_4);
+        #endif
+      } else {
+        if (__pyx_t_2 >= PyTuple_GET_SIZE(__pyx_t_1)) break;
+        #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
+        __pyx_t_4 = PyTuple_GET_ITEM(__pyx_t_1, __pyx_t_2); __Pyx_INCREF(__pyx_t_4); __pyx_t_2++; if (unlikely(0 < 0)) __PYX_ERR(1, 47, __pyx_L1_error)
+        #else
+        __pyx_t_4 = PySequence_ITEM(__pyx_t_1, __pyx_t_2); __pyx_t_2++; if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 47, __pyx_L1_error)
+        __Pyx_GOTREF(__pyx_t_4);
+        #endif
+      }
+    } else {
+      __pyx_t_4 = __pyx_t_3(__pyx_t_1);
+      if (unlikely(!__pyx_t_4)) {
+        PyObject* exc_type = PyErr_Occurred();
+        if (exc_type) {
+          if (likely(__Pyx_PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
+          else __PYX_ERR(1, 47, __pyx_L1_error)
+        }
+        break;
+      }
+      __Pyx_GOTREF(__pyx_t_4);
+    }
+    __Pyx_XDECREF_SET(__pyx_v_item, __pyx_t_4);
+    __pyx_t_4 = 0;
+
+    /* "vector.from_py":48
+ *     cdef vector[X] v
+ *     for item in o:
+ *         v.push_back(<X>item)             # <<<<<<<<<<<<<<
+ *     return v
+ * 
+ */
+    __pyx_t_5 = __pyx_convert_string_from_py_std__in_string(__pyx_v_item); if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 48, __pyx_L1_error)
+    __pyx_v_v.push_back(((std::string)__pyx_t_5));
+
+    /* "vector.from_py":47
+ * cdef vector[X] __pyx_convert_vector_from_py_std_3a__3a_string(object o) except *:
+ *     cdef vector[X] v
+ *     for item in o:             # <<<<<<<<<<<<<<
+ *         v.push_back(<X>item)
+ *     return v
+ */
+  }
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "vector.from_py":49
+ *     for item in o:
+ *         v.push_back(<X>item)
+ *     return v             # <<<<<<<<<<<<<<
+ * 
+ * 
+ */
+  __pyx_r = __pyx_v_v;
+  goto __pyx_L0;
+
+  /* "vector.from_py":45
+ * 
+ * @cname("__pyx_convert_vector_from_py_std_3a__3a_string")
+ * cdef vector[X] __pyx_convert_vector_from_py_std_3a__3a_string(object o) except *:             # <<<<<<<<<<<<<<
+ *     cdef vector[X] v
+ *     for item in o:
+ */
+
+  /* function exit code */
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_XDECREF(__pyx_t_4);
+  __Pyx_AddTraceback("vector.from_py.__pyx_convert_vector_from_py_std_3a__3a_string", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_pretend_to_initialize(&__pyx_r);
+  __pyx_L0:;
+  __Pyx_XDECREF(__pyx_v_item);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+static struct __pyx_vtabstruct_3crf_Trainer __pyx_vtable_3crf_Trainer;
+
+static PyObject *__pyx_tp_new_3crf_Trainer(PyTypeObject *t, CYTHON_UNUSED PyObject *a, CYTHON_UNUSED PyObject *k) {
+  struct __pyx_obj_3crf_Trainer *p;
+  PyObject *o;
+  if (likely((t->tp_flags & Py_TPFLAGS_IS_ABSTRACT) == 0)) {
+    o = (*t->tp_alloc)(t, 0);
+  } else {
+    o = (PyObject *) PyBaseObject_Type.tp_new(t, __pyx_empty_tuple, 0);
+  }
+  if (unlikely(!o)) return 0;
+  p = ((struct __pyx_obj_3crf_Trainer *)o);
+  p->__pyx_vtab = __pyx_vtabptr_3crf_Trainer;
+  new((void*)&(p->_trainer)) CRFSuiteWrapper::Trainer();
+  if (unlikely(__pyx_pw_3crf_7Trainer_3__cinit__(o, __pyx_empty_tuple, NULL) < 0)) goto bad;
+  return o;
+  bad:
+  Py_DECREF(o); o = 0;
+  return NULL;
+}
+
+static void __pyx_tp_dealloc_3crf_Trainer(PyObject *o) {
+  struct __pyx_obj_3crf_Trainer *p = (struct __pyx_obj_3crf_Trainer *)o;
+  #if CYTHON_USE_TP_FINALIZE
+  if (unlikely(PyType_HasFeature(Py_TYPE(o), Py_TPFLAGS_HAVE_FINALIZE) && Py_TYPE(o)->tp_finalize) && (!PyType_IS_GC(Py_TYPE(o)) || !_PyGC_FINALIZED(o))) {
+    if (PyObject_CallFinalizerFromDealloc(o)) return;
+  }
+  #endif
+  __Pyx_call_destructor(p->_trainer);
+  (*Py_TYPE(o)->tp_free)(o);
+}
+
+static PyObject *__pyx_getprop_3crf_7Trainer_params(PyObject *o, CYTHON_UNUSED void *x) {
+  return __pyx_pw_3crf_7Trainer_6params_1__get__(o);
+}
+
+static PyMethodDef __pyx_methods_3crf_Trainer[] = {
+  {"train", (PyCFunction)__pyx_pw_3crf_7Trainer_5train, METH_O, __pyx_doc_3crf_7Trainer_4train},
+  {"_log", (PyCFunction)__pyx_pw_3crf_7Trainer_7_log, METH_O, __pyx_doc_3crf_7Trainer_6_log},
+  {"append", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_3crf_7Trainer_9append, METH_VARARGS|METH_KEYWORDS, __pyx_doc_3crf_7Trainer_8append},
+  {"translate_params", (PyCFunction)__pyx_pw_3crf_7Trainer_11translate_params, METH_O, __pyx_doc_3crf_7Trainer_10translate_params},
+  {"select_algorithm", (PyCFunction)__pyx_pw_3crf_7Trainer_13select_algorithm, METH_O, __pyx_doc_3crf_7Trainer_12select_algorithm},
+  {"set_params", (PyCFunction)__pyx_pw_3crf_7Trainer_15set_params, METH_O, __pyx_doc_3crf_7Trainer_14set_params},
+  {"set_param", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_3crf_7Trainer_17set_param, METH_VARARGS|METH_KEYWORDS, __pyx_doc_3crf_7Trainer_16set_param},
+  {"get_param", (PyCFunction)__pyx_pw_3crf_7Trainer_19get_param, METH_O, __pyx_doc_3crf_7Trainer_18get_param},
+  {"cast_parameter", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_3crf_7Trainer_21cast_parameter, METH_VARARGS|METH_KEYWORDS, __pyx_doc_3crf_7Trainer_20cast_parameter},
+  {"__reduce_cython__", (PyCFunction)__pyx_pw_3crf_7Trainer_27__reduce_cython__, METH_NOARGS, __pyx_doc_3crf_7Trainer_26__reduce_cython__},
+  {"__setstate_cython__", (PyCFunction)__pyx_pw_3crf_7Trainer_29__setstate_cython__, METH_O, __pyx_doc_3crf_7Trainer_28__setstate_cython__},
+  {0, 0, 0, 0}
+};
+
+static struct PyGetSetDef __pyx_getsets_3crf_Trainer[] = {
+  {(char *)"params", __pyx_getprop_3crf_7Trainer_params, 0, (char *)0, 0},
+  {0, 0, 0, 0, 0}
+};
+
+static PyTypeObject __pyx_type_3crf_Trainer = {
+  PyVarObject_HEAD_INIT(0, 0)
+  "crf.Trainer", /*tp_name*/
+  sizeof(struct __pyx_obj_3crf_Trainer), /*tp_basicsize*/
+  0, /*tp_itemsize*/
+  __pyx_tp_dealloc_3crf_Trainer, /*tp_dealloc*/
+  #if PY_VERSION_HEX < 0x030800b4
+  0, /*tp_print*/
+  #endif
+  #if PY_VERSION_HEX >= 0x030800b4
+  0, /*tp_vectorcall_offset*/
+  #endif
+  0, /*tp_getattr*/
+  0, /*tp_setattr*/
+  #if PY_MAJOR_VERSION < 3
+  0, /*tp_compare*/
+  #endif
+  #if PY_MAJOR_VERSION >= 3
+  0, /*tp_as_async*/
+  #endif
+  0, /*tp_repr*/
+  0, /*tp_as_number*/
+  0, /*tp_as_sequence*/
+  0, /*tp_as_mapping*/
+  0, /*tp_hash*/
+  0, /*tp_call*/
+  0, /*tp_str*/
+  0, /*tp_getattro*/
+  0, /*tp_setattro*/
+  0, /*tp_as_buffer*/
+  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE, /*tp_flags*/
+  "Trainer(str algorithm: str, **kwargs)", /*tp_doc*/
+  0, /*tp_traverse*/
+  0, /*tp_clear*/
+  0, /*tp_richcompare*/
+  0, /*tp_weaklistoffset*/
+  0, /*tp_iter*/
+  0, /*tp_iternext*/
+  __pyx_methods_3crf_Trainer, /*tp_methods*/
+  0, /*tp_members*/
+  __pyx_getsets_3crf_Trainer, /*tp_getset*/
+  0, /*tp_base*/
+  0, /*tp_dict*/
+  0, /*tp_descr_get*/
+  0, /*tp_descr_set*/
+  0, /*tp_dictoffset*/
+  __pyx_pw_3crf_7Trainer_1__init__, /*tp_init*/
+  0, /*tp_alloc*/
+  __pyx_tp_new_3crf_Trainer, /*tp_new*/
+  0, /*tp_free*/
+  0, /*tp_is_gc*/
+  0, /*tp_bases*/
+  0, /*tp_mro*/
+  0, /*tp_cache*/
+  0, /*tp_subclasses*/
+  0, /*tp_weaklist*/
+  0, /*tp_del*/
+  0, /*tp_version_tag*/
+  #if PY_VERSION_HEX >= 0x030400a1
+  0, /*tp_finalize*/
+  #endif
+  #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
+  0, /*tp_vectorcall*/
+  #endif
+  #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
+  0, /*tp_print*/
+  #endif
+  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
+  0, /*tp_pypy_flags*/
+  #endif
+};
+static struct __pyx_vtabstruct_3crf_Model __pyx_vtable_3crf_Model;
+
+static PyObject *__pyx_tp_new_3crf_Model(PyTypeObject *t, CYTHON_UNUSED PyObject *a, CYTHON_UNUSED PyObject *k) {
+  struct __pyx_obj_3crf_Model *p;
+  PyObject *o;
+  if (likely((t->tp_flags & Py_TPFLAGS_IS_ABSTRACT) == 0)) {
+    o = (*t->tp_alloc)(t, 0);
+  } else {
+    o = (PyObject *) PyBaseObject_Type.tp_new(t, __pyx_empty_tuple, 0);
+  }
+  if (unlikely(!o)) return 0;
+  p = ((struct __pyx_obj_3crf_Model *)o);
+  p->__pyx_vtab = __pyx_vtabptr_3crf_Model;
+  new((void*)&(p->_tagger)) CRFSuiteWrapper::Tagger();
+  return o;
+}
+
+static void __pyx_tp_dealloc_3crf_Model(PyObject *o) {
+  struct __pyx_obj_3crf_Model *p = (struct __pyx_obj_3crf_Model *)o;
+  #if CYTHON_USE_TP_FINALIZE
+  if (unlikely(PyType_HasFeature(Py_TYPE(o), Py_TPFLAGS_HAVE_FINALIZE) && Py_TYPE(o)->tp_finalize) && (!PyType_IS_GC(Py_TYPE(o)) || !_PyGC_FINALIZED(o))) {
+    if (PyObject_CallFinalizerFromDealloc(o)) return;
+  }
+  #endif
+  __Pyx_call_destructor(p->_tagger);
+  (*Py_TYPE(o)->tp_free)(o);
+}
+
+static PyObject *__pyx_getprop_3crf_5Model_labels(PyObject *o, CYTHON_UNUSED void *x) {
+  return __pyx_pw_3crf_5Model_6labels_1__get__(o);
+}
+
+static PyMethodDef __pyx_methods_3crf_Model[] = {
+  {"predict_single", (PyCFunction)__pyx_pw_3crf_5Model_3predict_single, METH_O, __pyx_doc_3crf_5Model_2predict_single},
+  {"predict_proba_single", (PyCFunction)__pyx_pw_3crf_5Model_5predict_proba_single, METH_O, __pyx_doc_3crf_5Model_4predict_proba_single},
+  {"load", (PyCFunction)__pyx_pw_3crf_5Model_7load, METH_O, __pyx_doc_3crf_5Model_6load},
+  {"marginal", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_3crf_5Model_9marginal, METH_VARARGS|METH_KEYWORDS, __pyx_doc_3crf_5Model_8marginal},
+  {"set_sequence", (PyCFunction)__pyx_pw_3crf_5Model_11set_sequence, METH_O, __pyx_doc_3crf_5Model_10set_sequence},
+  {"check_model", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_3crf_5Model_13check_model, METH_VARARGS|METH_KEYWORDS, __pyx_doc_3crf_5Model_12check_model},
+  {"dump_transitions", (PyCFunction)__pyx_pw_3crf_5Model_15dump_transitions, METH_O, __pyx_doc_3crf_5Model_14dump_transitions},
+  {"dump_states", (PyCFunction)__pyx_pw_3crf_5Model_17dump_states, METH_O, __pyx_doc_3crf_5Model_16dump_states},
+  {"__reduce_cython__", (PyCFunction)__pyx_pw_3crf_5Model_19__reduce_cython__, METH_NOARGS, __pyx_doc_3crf_5Model_18__reduce_cython__},
+  {"__setstate_cython__", (PyCFunction)__pyx_pw_3crf_5Model_21__setstate_cython__, METH_O, __pyx_doc_3crf_5Model_20__setstate_cython__},
+  {0, 0, 0, 0}
+};
+
+static struct PyGetSetDef __pyx_getsets_3crf_Model[] = {
+  {(char *)"labels", __pyx_getprop_3crf_5Model_labels, 0, (char *)0, 0},
+  {0, 0, 0, 0, 0}
+};
+
+static PyTypeObject __pyx_type_3crf_Model = {
+  PyVarObject_HEAD_INIT(0, 0)
+  "crf.Model", /*tp_name*/
+  sizeof(struct __pyx_obj_3crf_Model), /*tp_basicsize*/
+  0, /*tp_itemsize*/
+  __pyx_tp_dealloc_3crf_Model, /*tp_dealloc*/
+  #if PY_VERSION_HEX < 0x030800b4
+  0, /*tp_print*/
+  #endif
+  #if PY_VERSION_HEX >= 0x030800b4
+  0, /*tp_vectorcall_offset*/
+  #endif
+  0, /*tp_getattr*/
+  0, /*tp_setattr*/
+  #if PY_MAJOR_VERSION < 3
+  0, /*tp_compare*/
+  #endif
+  #if PY_MAJOR_VERSION >= 3
+  0, /*tp_as_async*/
+  #endif
+  0, /*tp_repr*/
+  0, /*tp_as_number*/
+  0, /*tp_as_sequence*/
+  0, /*tp_as_mapping*/
+  0, /*tp_hash*/
+  0, /*tp_call*/
+  0, /*tp_str*/
+  0, /*tp_getattro*/
+  0, /*tp_setattro*/
+  0, /*tp_as_buffer*/
+  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE, /*tp_flags*/
+  "Model(model_filepath: Filepath)", /*tp_doc*/
+  0, /*tp_traverse*/
+  0, /*tp_clear*/
+  0, /*tp_richcompare*/
+  0, /*tp_weaklistoffset*/
+  0, /*tp_iter*/
+  0, /*tp_iternext*/
+  __pyx_methods_3crf_Model, /*tp_methods*/
+  0, /*tp_members*/
+  __pyx_getsets_3crf_Model, /*tp_getset*/
+  0, /*tp_base*/
+  0, /*tp_dict*/
+  0, /*tp_descr_get*/
+  0, /*tp_descr_set*/
+  0, /*tp_dictoffset*/
+  __pyx_pw_3crf_5Model_1__init__, /*tp_init*/
+  0, /*tp_alloc*/
+  __pyx_tp_new_3crf_Model, /*tp_new*/
+  0, /*tp_free*/
+  0, /*tp_is_gc*/
+  0, /*tp_bases*/
+  0, /*tp_mro*/
+  0, /*tp_cache*/
+  0, /*tp_subclasses*/
+  0, /*tp_weaklist*/
+  0, /*tp_del*/
+  0, /*tp_version_tag*/
+  #if PY_VERSION_HEX >= 0x030400a1
+  0, /*tp_finalize*/
+  #endif
+  #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
+  0, /*tp_vectorcall*/
+  #endif
+  #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
+  0, /*tp_print*/
+  #endif
+  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
+  0, /*tp_pypy_flags*/
+  #endif
+};
+
+static PyObject *__pyx_tp_new_3crf_ItemSequence(PyTypeObject *t, CYTHON_UNUSED PyObject *a, CYTHON_UNUSED PyObject *k) {
+  struct __pyx_obj_3crf_ItemSequence *p;
+  PyObject *o;
+  if (likely((t->tp_flags & Py_TPFLAGS_IS_ABSTRACT) == 0)) {
+    o = (*t->tp_alloc)(t, 0);
+  } else {
+    o = (PyObject *) PyBaseObject_Type.tp_new(t, __pyx_empty_tuple, 0);
+  }
+  if (unlikely(!o)) return 0;
+  p = ((struct __pyx_obj_3crf_ItemSequence *)o);
+  new((void*)&(p->c_sequence)) CRFSuite::ItemSequence();
+  return o;
+}
+
+static void __pyx_tp_dealloc_3crf_ItemSequence(PyObject *o) {
+  struct __pyx_obj_3crf_ItemSequence *p = (struct __pyx_obj_3crf_ItemSequence *)o;
+  #if CYTHON_USE_TP_FINALIZE
+  if (unlikely(PyType_HasFeature(Py_TYPE(o), Py_TPFLAGS_HAVE_FINALIZE) && Py_TYPE(o)->tp_finalize) && (!PyType_IS_GC(Py_TYPE(o)) || !_PyGC_FINALIZED(o))) {
+    if (PyObject_CallFinalizerFromDealloc(o)) return;
+  }
+  #endif
+  __Pyx_call_destructor(p->c_sequence);
+  (*Py_TYPE(o)->tp_free)(o);
+}
+
+static PyMethodDef __pyx_methods_3crf_ItemSequence[] = {
+  {"items", (PyCFunction)__pyx_pw_3crf_12ItemSequence_3items, METH_NOARGS, __pyx_doc_3crf_12ItemSequence_2items},
+  {"__reduce_cython__", (PyCFunction)__pyx_pw_3crf_12ItemSequence_9__reduce_cython__, METH_NOARGS, __pyx_doc_3crf_12ItemSequence_8__reduce_cython__},
+  {"__setstate_cython__", (PyCFunction)__pyx_pw_3crf_12ItemSequence_11__setstate_cython__, METH_O, __pyx_doc_3crf_12ItemSequence_10__setstate_cython__},
+  {0, 0, 0, 0}
+};
+
+static PySequenceMethods __pyx_tp_as_sequence_ItemSequence = {
+  __pyx_pw_3crf_12ItemSequence_5__len__, /*sq_length*/
+  0, /*sq_concat*/
+  0, /*sq_repeat*/
+  0, /*sq_item*/
+  0, /*sq_slice*/
+  0, /*sq_ass_item*/
+  0, /*sq_ass_slice*/
+  0, /*sq_contains*/
+  0, /*sq_inplace_concat*/
+  0, /*sq_inplace_repeat*/
+};
+
+static PyMappingMethods __pyx_tp_as_mapping_ItemSequence = {
+  __pyx_pw_3crf_12ItemSequence_5__len__, /*mp_length*/
+  0, /*mp_subscript*/
+  0, /*mp_ass_subscript*/
+};
+
+static PyTypeObject __pyx_type_3crf_ItemSequence = {
+  PyVarObject_HEAD_INIT(0, 0)
+  "crf.ItemSequence", /*tp_name*/
+  sizeof(struct __pyx_obj_3crf_ItemSequence), /*tp_basicsize*/
+  0, /*tp_itemsize*/
+  __pyx_tp_dealloc_3crf_ItemSequence, /*tp_dealloc*/
+  #if PY_VERSION_HEX < 0x030800b4
+  0, /*tp_print*/
+  #endif
+  #if PY_VERSION_HEX >= 0x030800b4
+  0, /*tp_vectorcall_offset*/
+  #endif
+  0, /*tp_getattr*/
+  0, /*tp_setattr*/
+  #if PY_MAJOR_VERSION < 3
+  0, /*tp_compare*/
+  #endif
+  #if PY_MAJOR_VERSION >= 3
+  0, /*tp_as_async*/
+  #endif
+  __pyx_pw_3crf_12ItemSequence_7__repr__, /*tp_repr*/
+  0, /*tp_as_number*/
+  &__pyx_tp_as_sequence_ItemSequence, /*tp_as_sequence*/
+  &__pyx_tp_as_mapping_ItemSequence, /*tp_as_mapping*/
+  0, /*tp_hash*/
+  0, /*tp_call*/
+  0, /*tp_str*/
+  0, /*tp_getattro*/
+  0, /*tp_setattro*/
+  0, /*tp_as_buffer*/
+  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE, /*tp_flags*/
+  "ItemSequence(sequence)", /*tp_doc*/
+  0, /*tp_traverse*/
+  0, /*tp_clear*/
+  0, /*tp_richcompare*/
+  0, /*tp_weaklistoffset*/
+  0, /*tp_iter*/
+  0, /*tp_iternext*/
+  __pyx_methods_3crf_ItemSequence, /*tp_methods*/
+  0, /*tp_members*/
+  0, /*tp_getset*/
+  0, /*tp_base*/
+  0, /*tp_dict*/
+  0, /*tp_descr_get*/
+  0, /*tp_descr_set*/
+  0, /*tp_dictoffset*/
+  __pyx_pw_3crf_12ItemSequence_1__init__, /*tp_init*/
+  0, /*tp_alloc*/
+  __pyx_tp_new_3crf_ItemSequence, /*tp_new*/
+  0, /*tp_free*/
+  0, /*tp_is_gc*/
+  0, /*tp_bases*/
+  0, /*tp_mro*/
+  0, /*tp_cache*/
+  0, /*tp_subclasses*/
+  0, /*tp_weaklist*/
+  0, /*tp_del*/
+  0, /*tp_version_tag*/
+  #if PY_VERSION_HEX >= 0x030400a1
+  0, /*tp_finalize*/
+  #endif
+  #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
+  0, /*tp_vectorcall*/
+  #endif
+  #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
+  0, /*tp_print*/
+  #endif
+  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
+  0, /*tp_pypy_flags*/
+  #endif
+};
+
+static PyMethodDef __pyx_methods[] = {
+  {0, 0, 0, 0}
+};
+
+#if PY_MAJOR_VERSION >= 3
+#if CYTHON_PEP489_MULTI_PHASE_INIT
+static PyObject* __pyx_pymod_create(PyObject *spec, PyModuleDef *def); /*proto*/
+static int __pyx_pymod_exec_crf(PyObject* module); /*proto*/
+static PyModuleDef_Slot __pyx_moduledef_slots[] = {
+  {Py_mod_create, (void*)__pyx_pymod_create},
+  {Py_mod_exec, (void*)__pyx_pymod_exec_crf},
+  {0, NULL}
+};
+#endif
+
+static struct PyModuleDef __pyx_moduledef = {
+    PyModuleDef_HEAD_INIT,
+    "crf",
+    0, /* m_doc */
+  #if CYTHON_PEP489_MULTI_PHASE_INIT
+    0, /* m_size */
+  #else
+    -1, /* m_size */
+  #endif
+    __pyx_methods /* m_methods */,
+  #if CYTHON_PEP489_MULTI_PHASE_INIT
+    __pyx_moduledef_slots, /* m_slots */
+  #else
+    NULL, /* m_reload */
+  #endif
+    NULL, /* m_traverse */
+    NULL, /* m_clear */
+    NULL /* m_free */
+};
+#endif
+#ifndef CYTHON_SMALL_CODE
+#if defined(__clang__)
+    #define CYTHON_SMALL_CODE
+#elif defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3))
+    #define CYTHON_SMALL_CODE __attribute__((cold))
+#else
+    #define CYTHON_SMALL_CODE
+#endif
+#endif
+
+static __Pyx_StringTabEntry __pyx_string_tab[] = {
+  {&__pyx_kp_u_Cannot_load_model_file, __pyx_k_Cannot_load_model_file, sizeof(__pyx_k_Cannot_load_model_file), 0, 1, 0, 0},
+  {&__pyx_n_s_Filepath, __pyx_k_Filepath, sizeof(__pyx_k_Filepath), 0, 0, 1, 1},
+  {&__pyx_kp_u_Invalid_model_file, __pyx_k_Invalid_model_file, sizeof(__pyx_k_Invalid_model_file), 0, 1, 0, 0},
+  {&__pyx_kp_u_ItemSequence, __pyx_k_ItemSequence, sizeof(__pyx_k_ItemSequence), 0, 1, 0, 0},
+  {&__pyx_n_s_ItemSequence_2, __pyx_k_ItemSequence_2, sizeof(__pyx_k_ItemSequence_2), 0, 0, 1, 1},
+  {&__pyx_n_s_LOGGER, __pyx_k_LOGGER, sizeof(__pyx_k_LOGGER), 0, 0, 1, 1},
+  {&__pyx_n_s_Labels, __pyx_k_Labels, sizeof(__pyx_k_Labels), 0, 0, 1, 1},
+  {&__pyx_n_s_Logger, __pyx_k_Logger, sizeof(__pyx_k_Logger), 0, 0, 1, 1},
+  {&__pyx_n_s_Model, __pyx_k_Model, sizeof(__pyx_k_Model), 0, 0, 1, 1},
+  {&__pyx_kp_u_Model_file, __pyx_k_Model_file, sizeof(__pyx_k_Model_file), 0, 1, 0, 0},
+  {&__pyx_n_s_O_CREAT, __pyx_k_O_CREAT, sizeof(__pyx_k_O_CREAT), 0, 0, 1, 1},
+  {&__pyx_n_s_O_WRONLY, __pyx_k_O_WRONLY, sizeof(__pyx_k_O_WRONLY), 0, 0, 1, 1},
+  {&__pyx_n_s_SEEK_END, __pyx_k_SEEK_END, sizeof(__pyx_k_SEEK_END), 0, 0, 1, 1},
+  {&__pyx_n_s_Sequence, __pyx_k_Sequence, sizeof(__pyx_k_Sequence), 0, 0, 1, 1},
+  {&__pyx_n_s_Trainer, __pyx_k_Trainer, sizeof(__pyx_k_Trainer), 0, 0, 1, 1},
+  {&__pyx_n_s_Trainer_lambda, __pyx_k_Trainer_lambda, sizeof(__pyx_k_Trainer_lambda), 0, 0, 1, 1},
+  {&__pyx_n_s_TypeError, __pyx_k_TypeError, sizeof(__pyx_k_TypeError), 0, 0, 1, 1},
+  {&__pyx_n_s_ValueError, __pyx_k_ValueError, sizeof(__pyx_k_ValueError), 0, 0, 1, 1},
+  {&__pyx_kp_b__6, __pyx_k__6, sizeof(__pyx_k__6), 0, 0, 0, 0},
+  {&__pyx_kp_u__7, __pyx_k__7, sizeof(__pyx_k__7), 0, 1, 0, 0},
+  {&__pyx_n_s_algorithm, __pyx_k_algorithm, sizeof(__pyx_k_algorithm), 0, 0, 1, 1},
+  {&__pyx_n_s_algorithm_aliases, __pyx_k_algorithm_aliases, sizeof(__pyx_k_algorithm_aliases), 0, 0, 1, 1},
+  {&__pyx_n_s_all_possible_states, __pyx_k_all_possible_states, sizeof(__pyx_k_all_possible_states), 0, 0, 1, 1},
+  {&__pyx_n_s_all_possible_transitions, __pyx_k_all_possible_transitions, sizeof(__pyx_k_all_possible_transitions), 0, 0, 1, 1},
+  {&__pyx_n_s_ap, __pyx_k_ap, sizeof(__pyx_k_ap), 0, 0, 1, 1},
+  {&__pyx_n_s_arow, __pyx_k_arow, sizeof(__pyx_k_arow), 0, 0, 1, 1},
+  {&__pyx_kp_s_averaged_perceptron, __pyx_k_averaged_perceptron, sizeof(__pyx_k_averaged_perceptron), 0, 0, 1, 0},
+  {&__pyx_n_s_averaging, __pyx_k_averaging, sizeof(__pyx_k_averaging), 0, 0, 1, 1},
+  {&__pyx_n_s_c, __pyx_k_c, sizeof(__pyx_k_c), 0, 0, 1, 1},
+  {&__pyx_n_s_c1, __pyx_k_c1, sizeof(__pyx_k_c1), 0, 0, 1, 1},
+  {&__pyx_n_s_c2, __pyx_k_c2, sizeof(__pyx_k_c2), 0, 0, 1, 1},
+  {&__pyx_kp_s_calibration_candidates, __pyx_k_calibration_candidates, sizeof(__pyx_k_calibration_candidates), 0, 0, 1, 0},
+  {&__pyx_n_s_calibration_candidates_2, __pyx_k_calibration_candidates_2, sizeof(__pyx_k_calibration_candidates_2), 0, 0, 1, 1},
+  {&__pyx_kp_s_calibration_eta, __pyx_k_calibration_eta, sizeof(__pyx_k_calibration_eta), 0, 0, 1, 0},
+  {&__pyx_n_s_calibration_eta_2, __pyx_k_calibration_eta_2, sizeof(__pyx_k_calibration_eta_2), 0, 0, 1, 1},
+  {&__pyx_kp_s_calibration_max_trials, __pyx_k_calibration_max_trials, sizeof(__pyx_k_calibration_max_trials), 0, 0, 1, 0},
+  {&__pyx_n_s_calibration_max_trials_2, __pyx_k_calibration_max_trials_2, sizeof(__pyx_k_calibration_max_trials_2), 0, 0, 1, 1},
+  {&__pyx_kp_s_calibration_rate, __pyx_k_calibration_rate, sizeof(__pyx_k_calibration_rate), 0, 0, 1, 0},
+  {&__pyx_n_s_calibration_rate_2, __pyx_k_calibration_rate_2, sizeof(__pyx_k_calibration_rate_2), 0, 0, 1, 1},
+  {&__pyx_kp_s_calibration_samples, __pyx_k_calibration_samples, sizeof(__pyx_k_calibration_samples), 0, 0, 1, 0},
+  {&__pyx_n_s_calibration_samples_2, __pyx_k_calibration_samples_2, sizeof(__pyx_k_calibration_samples_2), 0, 0, 1, 1},
+  {&__pyx_n_s_cast_parameter, __pyx_k_cast_parameter, sizeof(__pyx_k_cast_parameter), 0, 0, 1, 1},
+  {&__pyx_kp_s_chaine__core_crf_pyx, __pyx_k_chaine__core_crf_pyx, sizeof(__pyx_k_chaine__core_crf_pyx), 0, 0, 1, 0},
+  {&__pyx_n_s_chaine_logging, __pyx_k_chaine_logging, sizeof(__pyx_k_chaine_logging), 0, 0, 1, 1},
+  {&__pyx_n_s_chaine_typing, __pyx_k_chaine_typing, sizeof(__pyx_k_chaine_typing), 0, 0, 1, 1},
+  {&__pyx_n_s_check_model, __pyx_k_check_model, sizeof(__pyx_k_check_model), 0, 0, 1, 1},
+  {&__pyx_n_s_cline_in_traceback, __pyx_k_cline_in_traceback, sizeof(__pyx_k_cline_in_traceback), 0, 0, 1, 1},
+  {&__pyx_n_s_crf, __pyx_k_crf, sizeof(__pyx_k_crf), 0, 0, 1, 1},
+  {&__pyx_n_b_crf1d, __pyx_k_crf1d, sizeof(__pyx_k_crf1d), 0, 0, 0, 1},
+  {&__pyx_n_s_delta, __pyx_k_delta, sizeof(__pyx_k_delta), 0, 0, 1, 1},
+  {&__pyx_kp_u_does_not_have_a_complete_header, __pyx_k_does_not_have_a_complete_header, sizeof(__pyx_k_does_not_have_a_complete_header), 0, 1, 0, 0},
+  {&__pyx_n_s_enter, __pyx_k_enter, sizeof(__pyx_k_enter), 0, 0, 1, 1},
+  {&__pyx_n_s_epsilon, __pyx_k_epsilon, sizeof(__pyx_k_epsilon), 0, 0, 1, 1},
+  {&__pyx_n_s_error_sensitive, __pyx_k_error_sensitive, sizeof(__pyx_k_error_sensitive), 0, 0, 1, 1},
+  {&__pyx_n_s_exit, __pyx_k_exit, sizeof(__pyx_k_exit), 0, 0, 1, 1},
+  {&__pyx_kp_s_feature_minfreq, __pyx_k_feature_minfreq, sizeof(__pyx_k_feature_minfreq), 0, 0, 1, 0},
+  {&__pyx_kp_s_feature_possible_states, __pyx_k_feature_possible_states, sizeof(__pyx_k_feature_possible_states), 0, 0, 1, 0},
+  {&__pyx_kp_s_feature_possible_transitions, __pyx_k_feature_possible_transitions, sizeof(__pyx_k_feature_possible_transitions), 0, 0, 1, 0},
+  {&__pyx_n_s_filepath, __pyx_k_filepath, sizeof(__pyx_k_filepath), 0, 0, 1, 1},
+  {&__pyx_n_s_gamma, __pyx_k_gamma, sizeof(__pyx_k_gamma), 0, 0, 1, 1},
+  {&__pyx_n_s_get, __pyx_k_get, sizeof(__pyx_k_get), 0, 0, 1, 1},
+  {&__pyx_n_s_getstate, __pyx_k_getstate, sizeof(__pyx_k_getstate), 0, 0, 1, 1},
+  {&__pyx_n_s_group, __pyx_k_group, sizeof(__pyx_k_group), 0, 0, 1, 1},
+  {&__pyx_n_s_import, __pyx_k_import, sizeof(__pyx_k_import), 0, 0, 1, 1},
+  {&__pyx_n_s_index, __pyx_k_index, sizeof(__pyx_k_index), 0, 0, 1, 1},
+  {&__pyx_n_s_info, __pyx_k_info, sizeof(__pyx_k_info), 0, 0, 1, 1},
+  {&__pyx_kp_u_is_no_available_algorithm, __pyx_k_is_no_available_algorithm, sizeof(__pyx_k_is_no_available_algorithm), 0, 1, 0, 0},
+  {&__pyx_n_s_items, __pyx_k_items, sizeof(__pyx_k_items), 0, 0, 1, 1},
+  {&__pyx_n_s_kwarg2param, __pyx_k_kwarg2param, sizeof(__pyx_k_kwarg2param), 0, 0, 1, 1},
+  {&__pyx_n_b_l2sgd, __pyx_k_l2sgd, sizeof(__pyx_k_l2sgd), 0, 0, 0, 1},
+  {&__pyx_n_s_l2sgd, __pyx_k_l2sgd, sizeof(__pyx_k_l2sgd), 0, 0, 1, 1},
+  {&__pyx_n_b_lCRF, __pyx_k_lCRF, sizeof(__pyx_k_lCRF), 0, 0, 0, 1},
+  {&__pyx_n_s_label, __pyx_k_label, sizeof(__pyx_k_label), 0, 0, 1, 1},
+  {&__pyx_n_s_labels, __pyx_k_labels, sizeof(__pyx_k_labels), 0, 0, 1, 1},
+  {&__pyx_n_s_lbfgs, __pyx_k_lbfgs, sizeof(__pyx_k_lbfgs), 0, 0, 1, 1},
+  {&__pyx_kp_s_limited_memory_bfgs, __pyx_k_limited_memory_bfgs, sizeof(__pyx_k_limited_memory_bfgs), 0, 0, 1, 0},
+  {&__pyx_n_s_linesearch, __pyx_k_linesearch, sizeof(__pyx_k_linesearch), 0, 0, 1, 1},
+  {&__pyx_n_s_load, __pyx_k_load, sizeof(__pyx_k_load), 0, 0, 1, 1},
+  {&__pyx_n_s_log, __pyx_k_log, sizeof(__pyx_k_log), 0, 0, 1, 1},
+  {&__pyx_n_s_lower, __pyx_k_lower, sizeof(__pyx_k_lower), 0, 0, 1, 1},
+  {&__pyx_n_s_magic, __pyx_k_magic, sizeof(__pyx_k_magic), 0, 0, 1, 1},
+  {&__pyx_n_s_main, __pyx_k_main, sizeof(__pyx_k_main), 0, 0, 1, 1},
+  {&__pyx_n_s_marginal, __pyx_k_marginal, sizeof(__pyx_k_marginal), 0, 0, 1, 1},
+  {&__pyx_n_s_max_iterations, __pyx_k_max_iterations, sizeof(__pyx_k_max_iterations), 0, 0, 1, 1},
+  {&__pyx_n_s_max_linesearch, __pyx_k_max_linesearch, sizeof(__pyx_k_max_linesearch), 0, 0, 1, 1},
+  {&__pyx_n_s_min_freq, __pyx_k_min_freq, sizeof(__pyx_k_min_freq), 0, 0, 1, 1},
+  {&__pyx_n_s_model, __pyx_k_model, sizeof(__pyx_k_model), 0, 0, 1, 1},
+  {&__pyx_n_s_model_filepath, __pyx_k_model_filepath, sizeof(__pyx_k_model_filepath), 0, 0, 1, 1},
+  {&__pyx_n_s_name, __pyx_k_name, sizeof(__pyx_k_name), 0, 0, 1, 1},
+  {&__pyx_kp_s_no_default___reduce___due_to_non, __pyx_k_no_default___reduce___due_to_non, sizeof(__pyx_k_no_default___reduce___due_to_non), 0, 0, 1, 0},
+  {&__pyx_n_s_num_memories, __pyx_k_num_memories, sizeof(__pyx_k_num_memories), 0, 0, 1, 1},
+  {&__pyx_n_s_open, __pyx_k_open, sizeof(__pyx_k_open), 0, 0, 1, 1},
+  {&__pyx_n_s_os, __pyx_k_os, sizeof(__pyx_k_os), 0, 0, 1, 1},
+  {&__pyx_n_s_pa, __pyx_k_pa, sizeof(__pyx_k_pa), 0, 0, 1, 1},
+  {&__pyx_n_s_pa_type, __pyx_k_pa_type, sizeof(__pyx_k_pa_type), 0, 0, 1, 1},
+  {&__pyx_n_s_param, __pyx_k_param, sizeof(__pyx_k_param), 0, 0, 1, 1},
+  {&__pyx_n_s_param2kwarg, __pyx_k_param2kwarg, sizeof(__pyx_k_param2kwarg), 0, 0, 1, 1},
+  {&__pyx_n_s_parameter_types, __pyx_k_parameter_types, sizeof(__pyx_k_parameter_types), 0, 0, 1, 1},
+  {&__pyx_kp_s_passive_aggressive, __pyx_k_passive_aggressive, sizeof(__pyx_k_passive_aggressive), 0, 0, 1, 0},
+  {&__pyx_n_s_period, __pyx_k_period, sizeof(__pyx_k_period), 0, 0, 1, 1},
+  {&__pyx_n_s_pyx_vtable, __pyx_k_pyx_vtable, sizeof(__pyx_k_pyx_vtable), 0, 0, 1, 1},
+  {&__pyx_n_s_range, __pyx_k_range, sizeof(__pyx_k_range), 0, 0, 1, 1},
+  {&__pyx_n_s_rb, __pyx_k_rb, sizeof(__pyx_k_rb), 0, 0, 1, 1},
+  {&__pyx_n_s_read, __pyx_k_read, sizeof(__pyx_k_read), 0, 0, 1, 1},
+  {&__pyx_n_s_reduce, __pyx_k_reduce, sizeof(__pyx_k_reduce), 0, 0, 1, 1},
+  {&__pyx_n_s_reduce_cython, __pyx_k_reduce_cython, sizeof(__pyx_k_reduce_cython), 0, 0, 1, 1},
+  {&__pyx_n_s_reduce_ex, __pyx_k_reduce_ex, sizeof(__pyx_k_reduce_ex), 0, 0, 1, 1},
+  {&__pyx_n_s_seek, __pyx_k_seek, sizeof(__pyx_k_seek), 0, 0, 1, 1},
+  {&__pyx_n_s_select_algorithm, __pyx_k_select_algorithm, sizeof(__pyx_k_select_algorithm), 0, 0, 1, 1},
+  {&__pyx_kp_s_self__tagger_cannot_be_converted, __pyx_k_self__tagger_cannot_be_converted, sizeof(__pyx_k_self__tagger_cannot_be_converted), 0, 0, 1, 0},
+  {&__pyx_kp_s_self_c_sequence_cannot_be_conver, __pyx_k_self_c_sequence_cannot_be_conver, sizeof(__pyx_k_self_c_sequence_cannot_be_conver), 0, 0, 1, 0},
+  {&__pyx_n_s_sequence, __pyx_k_sequence, sizeof(__pyx_k_sequence), 0, 0, 1, 1},
+  {&__pyx_n_s_set_param, __pyx_k_set_param, sizeof(__pyx_k_set_param), 0, 0, 1, 1},
+  {&__pyx_n_s_set_params, __pyx_k_set_params, sizeof(__pyx_k_set_params), 0, 0, 1, 1},
+  {&__pyx_n_s_set_sequence, __pyx_k_set_sequence, sizeof(__pyx_k_set_sequence), 0, 0, 1, 1},
+  {&__pyx_n_s_setstate, __pyx_k_setstate, sizeof(__pyx_k_setstate), 0, 0, 1, 1},
+  {&__pyx_n_s_setstate_cython, __pyx_k_setstate_cython, sizeof(__pyx_k_setstate_cython), 0, 0, 1, 1},
+  {&__pyx_n_s_sgd, __pyx_k_sgd, sizeof(__pyx_k_sgd), 0, 0, 1, 1},
+  {&__pyx_n_s_staticmethod, __pyx_k_staticmethod, sizeof(__pyx_k_staticmethod), 0, 0, 1, 1},
+  {&__pyx_kp_s_stochastic_gradient_descent, __pyx_k_stochastic_gradient_descent, sizeof(__pyx_k_stochastic_gradient_descent), 0, 0, 1, 0},
+  {&__pyx_n_s_tell, __pyx_k_tell, sizeof(__pyx_k_tell), 0, 0, 1, 1},
+  {&__pyx_n_s_test, __pyx_k_test, sizeof(__pyx_k_test), 0, 0, 1, 1},
+  {&__pyx_n_s_translate_params, __pyx_k_translate_params, sizeof(__pyx_k_translate_params), 0, 0, 1, 1},
+  {&__pyx_n_s_type, __pyx_k_type, sizeof(__pyx_k_type), 0, 0, 1, 1},
+  {&__pyx_n_s_value, __pyx_k_value, sizeof(__pyx_k_value), 0, 0, 1, 1},
+  {&__pyx_n_s_variance, __pyx_k_variance, sizeof(__pyx_k_variance), 0, 0, 1, 1},
+  {0, 0, 0, 0, 0, 0, 0}
+};
+static CYTHON_SMALL_CODE int __Pyx_InitCachedBuiltins(void) {
+  __pyx_builtin_staticmethod = __Pyx_GetBuiltinName(__pyx_n_s_staticmethod); if (!__pyx_builtin_staticmethod) __PYX_ERR(0, 178, __pyx_L1_error)
+  __pyx_builtin_ValueError = __Pyx_GetBuiltinName(__pyx_n_s_ValueError); if (!__pyx_builtin_ValueError) __PYX_ERR(0, 123, __pyx_L1_error)
+  __pyx_builtin_TypeError = __Pyx_GetBuiltinName(__pyx_n_s_TypeError); if (!__pyx_builtin_TypeError) __PYX_ERR(1, 2, __pyx_L1_error)
+  __pyx_builtin_range = __Pyx_GetBuiltinName(__pyx_n_s_range); if (!__pyx_builtin_range) __PYX_ERR(0, 163, __pyx_L1_error)
+  __pyx_builtin_open = __Pyx_GetBuiltinName(__pyx_n_s_open); if (!__pyx_builtin_open) __PYX_ERR(0, 180, __pyx_L1_error)
+  return 0;
+  __pyx_L1_error:;
+  return -1;
+}
+
+static CYTHON_SMALL_CODE int __Pyx_InitCachedConstants(void) {
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("__Pyx_InitCachedConstants", 0);
+
+  /* "(tree fragment)":2
+ * def __reduce_cython__(self):
+ *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
+ * def __setstate_cython__(self, __pyx_state):
+ *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
+ */
+  __pyx_tuple_ = PyTuple_Pack(1, __pyx_kp_s_no_default___reduce___due_to_non); if (unlikely(!__pyx_tuple_)) __PYX_ERR(1, 2, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple_);
+  __Pyx_GIVEREF(__pyx_tuple_);
+
+  /* "(tree fragment)":4
+ *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
+ * def __setstate_cython__(self, __pyx_state):
+ *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
+ */
+  __pyx_tuple__2 = PyTuple_Pack(1, __pyx_kp_s_no_default___reduce___due_to_non); if (unlikely(!__pyx_tuple__2)) __PYX_ERR(1, 4, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__2);
+  __Pyx_GIVEREF(__pyx_tuple__2);
+
+  /* "crf.pyx":180
+ *     @staticmethod
+ *     def check_model(filepath: str):
+ *         with open(filepath, "rb") as model:             # <<<<<<<<<<<<<<
+ *             magic = model.read(4)
+ *             if magic != b"lCRF":
+ */
+  __pyx_tuple__3 = PyTuple_Pack(3, Py_None, Py_None, Py_None); if (unlikely(!__pyx_tuple__3)) __PYX_ERR(0, 180, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__3);
+  __Pyx_GIVEREF(__pyx_tuple__3);
+
+  /* "(tree fragment)":2
+ * def __reduce_cython__(self):
+ *     raise TypeError("self._tagger cannot be converted to a Python object for pickling")             # <<<<<<<<<<<<<<
+ * def __setstate_cython__(self, __pyx_state):
+ *     raise TypeError("self._tagger cannot be converted to a Python object for pickling")
+ */
+  __pyx_tuple__4 = PyTuple_Pack(1, __pyx_kp_s_self__tagger_cannot_be_converted); if (unlikely(!__pyx_tuple__4)) __PYX_ERR(1, 2, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__4);
+  __Pyx_GIVEREF(__pyx_tuple__4);
+
+  /* "(tree fragment)":4
+ *     raise TypeError("self._tagger cannot be converted to a Python object for pickling")
+ * def __setstate_cython__(self, __pyx_state):
+ *     raise TypeError("self._tagger cannot be converted to a Python object for pickling")             # <<<<<<<<<<<<<<
+ */
+  __pyx_tuple__5 = PyTuple_Pack(1, __pyx_kp_s_self__tagger_cannot_be_converted); if (unlikely(!__pyx_tuple__5)) __PYX_ERR(1, 4, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__5);
+  __Pyx_GIVEREF(__pyx_tuple__5);
+
+  /* "(tree fragment)":2
+ * def __reduce_cython__(self):
+ *     raise TypeError("self.c_sequence cannot be converted to a Python object for pickling")             # <<<<<<<<<<<<<<
+ * def __setstate_cython__(self, __pyx_state):
+ *     raise TypeError("self.c_sequence cannot be converted to a Python object for pickling")
+ */
+  __pyx_tuple__8 = PyTuple_Pack(1, __pyx_kp_s_self_c_sequence_cannot_be_conver); if (unlikely(!__pyx_tuple__8)) __PYX_ERR(1, 2, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__8);
+  __Pyx_GIVEREF(__pyx_tuple__8);
+
+  /* "(tree fragment)":4
+ *     raise TypeError("self.c_sequence cannot be converted to a Python object for pickling")
+ * def __setstate_cython__(self, __pyx_state):
+ *     raise TypeError("self.c_sequence cannot be converted to a Python object for pickling")             # <<<<<<<<<<<<<<
+ */
+  __pyx_tuple__9 = PyTuple_Pack(1, __pyx_kp_s_self_c_sequence_cannot_be_conver); if (unlikely(!__pyx_tuple__9)) __PYX_ERR(1, 4, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__9);
+  __Pyx_GIVEREF(__pyx_tuple__9);
+
+  /* "crf.pyx":179
+ * 
+ *     @staticmethod
+ *     def check_model(filepath: str):             # <<<<<<<<<<<<<<
+ *         with open(filepath, "rb") as model:
+ *             magic = model.read(4)
+ */
+  __pyx_tuple__10 = PyTuple_Pack(3, __pyx_n_s_filepath, __pyx_n_s_model, __pyx_n_s_magic); if (unlikely(!__pyx_tuple__10)) __PYX_ERR(0, 179, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__10);
+  __Pyx_GIVEREF(__pyx_tuple__10);
+  __pyx_codeobj__11 = (PyObject*)__Pyx_PyCode_New(1, 0, 3, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__10, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_chaine__core_crf_pyx, __pyx_n_s_check_model, 179, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__11)) __PYX_ERR(0, 179, __pyx_L1_error)
+  __Pyx_RefNannyFinishContext();
+  return 0;
+  __pyx_L1_error:;
+  __Pyx_RefNannyFinishContext();
+  return -1;
+}
+
+static CYTHON_SMALL_CODE int __Pyx_InitGlobals(void) {
+  __pyx_umethod_PyString_Type_lower.type = (PyObject*)&PyString_Type;
+  if (__Pyx_InitStrings(__pyx_string_tab) < 0) __PYX_ERR(0, 1, __pyx_L1_error);
+  __pyx_int_0 = PyInt_FromLong(0); if (unlikely(!__pyx_int_0)) __PYX_ERR(0, 1, __pyx_L1_error)
+  __pyx_int_4 = PyInt_FromLong(4); if (unlikely(!__pyx_int_4)) __PYX_ERR(0, 1, __pyx_L1_error)
+  __pyx_int_48 = PyInt_FromLong(48); if (unlikely(!__pyx_int_48)) __PYX_ERR(0, 1, __pyx_L1_error)
+  return 0;
+  __pyx_L1_error:;
+  return -1;
+}
+
+static CYTHON_SMALL_CODE int __Pyx_modinit_global_init_code(void); /*proto*/
+static CYTHON_SMALL_CODE int __Pyx_modinit_variable_export_code(void); /*proto*/
+static CYTHON_SMALL_CODE int __Pyx_modinit_function_export_code(void); /*proto*/
+static CYTHON_SMALL_CODE int __Pyx_modinit_type_init_code(void); /*proto*/
+static CYTHON_SMALL_CODE int __Pyx_modinit_type_import_code(void); /*proto*/
+static CYTHON_SMALL_CODE int __Pyx_modinit_variable_import_code(void); /*proto*/
+static CYTHON_SMALL_CODE int __Pyx_modinit_function_import_code(void); /*proto*/
+
+static int __Pyx_modinit_global_init_code(void) {
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("__Pyx_modinit_global_init_code", 0);
+  /*--- Global init code ---*/
+  __Pyx_RefNannyFinishContext();
+  return 0;
+}
+
+static int __Pyx_modinit_variable_export_code(void) {
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("__Pyx_modinit_variable_export_code", 0);
+  /*--- Variable export code ---*/
+  __Pyx_RefNannyFinishContext();
+  return 0;
+}
+
+static int __Pyx_modinit_function_export_code(void) {
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("__Pyx_modinit_function_export_code", 0);
+  /*--- Function export code ---*/
+  __Pyx_RefNannyFinishContext();
+  return 0;
+}
+
+static int __Pyx_modinit_type_init_code(void) {
+  __Pyx_RefNannyDeclarations
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("__Pyx_modinit_type_init_code", 0);
+  /*--- Type init code ---*/
+  __pyx_vtabptr_3crf_Trainer = &__pyx_vtable_3crf_Trainer;
+  __pyx_vtable_3crf_Trainer._on_message = (PyObject *(*)(struct __pyx_obj_3crf_Trainer *, std::string))__pyx_f_3crf_7Trainer__on_message;
+  if (PyType_Ready(&__pyx_type_3crf_Trainer) < 0) __PYX_ERR(0, 18, __pyx_L1_error)
+  #if PY_VERSION_HEX < 0x030800B1
+  __pyx_type_3crf_Trainer.tp_print = 0;
+  #endif
+  if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_type_3crf_Trainer.tp_dictoffset && __pyx_type_3crf_Trainer.tp_getattro == PyObject_GenericGetAttr)) {
+    __pyx_type_3crf_Trainer.tp_getattro = __Pyx_PyObject_GenericGetAttr;
+  }
+  if (__Pyx_SetVtable(__pyx_type_3crf_Trainer.tp_dict, __pyx_vtabptr_3crf_Trainer) < 0) __PYX_ERR(0, 18, __pyx_L1_error)
+  if (PyObject_SetAttr(__pyx_m, __pyx_n_s_Trainer, (PyObject *)&__pyx_type_3crf_Trainer) < 0) __PYX_ERR(0, 18, __pyx_L1_error)
+  if (__Pyx_setup_reduce((PyObject*)&__pyx_type_3crf_Trainer) < 0) __PYX_ERR(0, 18, __pyx_L1_error)
+  __pyx_ptype_3crf_Trainer = &__pyx_type_3crf_Trainer;
+  __pyx_vtabptr_3crf_Model = &__pyx_vtable_3crf_Model;
+  __pyx_vtable_3crf_Model.set_sequence = (PyObject *(*)(struct __pyx_obj_3crf_Model *, PyObject *, int __pyx_skip_dispatch))__pyx_f_3crf_5Model_set_sequence;
+  if (PyType_Ready(&__pyx_type_3crf_Model) < 0) __PYX_ERR(0, 145, __pyx_L1_error)
+  #if PY_VERSION_HEX < 0x030800B1
+  __pyx_type_3crf_Model.tp_print = 0;
+  #endif
+  if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_type_3crf_Model.tp_dictoffset && __pyx_type_3crf_Model.tp_getattro == PyObject_GenericGetAttr)) {
+    __pyx_type_3crf_Model.tp_getattro = __Pyx_PyObject_GenericGetAttr;
+  }
+  if (__Pyx_SetVtable(__pyx_type_3crf_Model.tp_dict, __pyx_vtabptr_3crf_Model) < 0) __PYX_ERR(0, 145, __pyx_L1_error)
+  if (PyObject_SetAttr(__pyx_m, __pyx_n_s_Model, (PyObject *)&__pyx_type_3crf_Model) < 0) __PYX_ERR(0, 145, __pyx_L1_error)
+  if (__Pyx_setup_reduce((PyObject*)&__pyx_type_3crf_Model) < 0) __PYX_ERR(0, 145, __pyx_L1_error)
+  __pyx_ptype_3crf_Model = &__pyx_type_3crf_Model;
+  if (PyType_Ready(&__pyx_type_3crf_ItemSequence) < 0) __PYX_ERR(0, 247, __pyx_L1_error)
+  #if PY_VERSION_HEX < 0x030800B1
+  __pyx_type_3crf_ItemSequence.tp_print = 0;
+  #endif
+  if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_type_3crf_ItemSequence.tp_dictoffset && __pyx_type_3crf_ItemSequence.tp_getattro == PyObject_GenericGetAttr)) {
+    __pyx_type_3crf_ItemSequence.tp_getattro = __Pyx_PyObject_GenericGetAttr;
+  }
+  if (PyObject_SetAttr(__pyx_m, __pyx_n_s_ItemSequence_2, (PyObject *)&__pyx_type_3crf_ItemSequence) < 0) __PYX_ERR(0, 247, __pyx_L1_error)
+  if (__Pyx_setup_reduce((PyObject*)&__pyx_type_3crf_ItemSequence) < 0) __PYX_ERR(0, 247, __pyx_L1_error)
+  __pyx_ptype_3crf_ItemSequence = &__pyx_type_3crf_ItemSequence;
+  __Pyx_RefNannyFinishContext();
+  return 0;
+  __pyx_L1_error:;
+  __Pyx_RefNannyFinishContext();
+  return -1;
+}
+
+static int __Pyx_modinit_type_import_code(void) {
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("__Pyx_modinit_type_import_code", 0);
+  /*--- Type import code ---*/
+  __Pyx_RefNannyFinishContext();
+  return 0;
+}
+
+static int __Pyx_modinit_variable_import_code(void) {
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("__Pyx_modinit_variable_import_code", 0);
+  /*--- Variable import code ---*/
+  __Pyx_RefNannyFinishContext();
+  return 0;
+}
+
+static int __Pyx_modinit_function_import_code(void) {
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("__Pyx_modinit_function_import_code", 0);
+  /*--- Function import code ---*/
+  __Pyx_RefNannyFinishContext();
+  return 0;
+}
+
+
+#ifndef CYTHON_NO_PYINIT_EXPORT
+#define __Pyx_PyMODINIT_FUNC PyMODINIT_FUNC
+#elif PY_MAJOR_VERSION < 3
+#ifdef __cplusplus
+#define __Pyx_PyMODINIT_FUNC extern "C" void
+#else
+#define __Pyx_PyMODINIT_FUNC void
+#endif
+#else
+#ifdef __cplusplus
+#define __Pyx_PyMODINIT_FUNC extern "C" PyObject *
+#else
+#define __Pyx_PyMODINIT_FUNC PyObject *
+#endif
+#endif
+
+
+#if PY_MAJOR_VERSION < 3
+__Pyx_PyMODINIT_FUNC initcrf(void) CYTHON_SMALL_CODE; /*proto*/
+__Pyx_PyMODINIT_FUNC initcrf(void)
+#else
+__Pyx_PyMODINIT_FUNC PyInit_crf(void) CYTHON_SMALL_CODE; /*proto*/
+__Pyx_PyMODINIT_FUNC PyInit_crf(void)
+#if CYTHON_PEP489_MULTI_PHASE_INIT
+{
+  return PyModuleDef_Init(&__pyx_moduledef);
+}
+static CYTHON_SMALL_CODE int __Pyx_check_single_interpreter(void) {
+    #if PY_VERSION_HEX >= 0x030700A1
+    static PY_INT64_T main_interpreter_id = -1;
+    PY_INT64_T current_id = PyInterpreterState_GetID(PyThreadState_Get()->interp);
+    if (main_interpreter_id == -1) {
+        main_interpreter_id = current_id;
+        return (unlikely(current_id == -1)) ? -1 : 0;
+    } else if (unlikely(main_interpreter_id != current_id))
+    #else
+    static PyInterpreterState *main_interpreter = NULL;
+    PyInterpreterState *current_interpreter = PyThreadState_Get()->interp;
+    if (!main_interpreter) {
+        main_interpreter = current_interpreter;
+    } else if (unlikely(main_interpreter != current_interpreter))
+    #endif
+    {
+        PyErr_SetString(
+            PyExc_ImportError,
+            "Interpreter change detected - this module can only be loaded into one interpreter per process.");
+        return -1;
+    }
+    return 0;
+}
+static CYTHON_SMALL_CODE int __Pyx_copy_spec_to_module(PyObject *spec, PyObject *moddict, const char* from_name, const char* to_name, int allow_none) {
+    PyObject *value = PyObject_GetAttrString(spec, from_name);
+    int result = 0;
+    if (likely(value)) {
+        if (allow_none || value != Py_None) {
+            result = PyDict_SetItemString(moddict, to_name, value);
+        }
+        Py_DECREF(value);
+    } else if (PyErr_ExceptionMatches(PyExc_AttributeError)) {
+        PyErr_Clear();
+    } else {
+        result = -1;
+    }
+    return result;
+}
+static CYTHON_SMALL_CODE PyObject* __pyx_pymod_create(PyObject *spec, CYTHON_UNUSED PyModuleDef *def) {
+    PyObject *module = NULL, *moddict, *modname;
+    if (__Pyx_check_single_interpreter())
+        return NULL;
+    if (__pyx_m)
+        return __Pyx_NewRef(__pyx_m);
+    modname = PyObject_GetAttrString(spec, "name");
+    if (unlikely(!modname)) goto bad;
+    module = PyModule_NewObject(modname);
+    Py_DECREF(modname);
+    if (unlikely(!module)) goto bad;
+    moddict = PyModule_GetDict(module);
+    if (unlikely(!moddict)) goto bad;
+    if (unlikely(__Pyx_copy_spec_to_module(spec, moddict, "loader", "__loader__", 1) < 0)) goto bad;
+    if (unlikely(__Pyx_copy_spec_to_module(spec, moddict, "origin", "__file__", 1) < 0)) goto bad;
+    if (unlikely(__Pyx_copy_spec_to_module(spec, moddict, "parent", "__package__", 1) < 0)) goto bad;
+    if (unlikely(__Pyx_copy_spec_to_module(spec, moddict, "submodule_search_locations", "__path__", 0) < 0)) goto bad;
+    return module;
+bad:
+    Py_XDECREF(module);
+    return NULL;
+}
+
+
+static CYTHON_SMALL_CODE int __pyx_pymod_exec_crf(PyObject *__pyx_pyinit_module)
+#endif
+#endif
+{
+  PyObject *__pyx_t_1 = NULL;
+  PyObject *__pyx_t_2 = NULL;
+  PyObject *__pyx_t_3 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannyDeclarations
+  #if CYTHON_PEP489_MULTI_PHASE_INIT
+  if (__pyx_m) {
+    if (__pyx_m == __pyx_pyinit_module) return 0;
+    PyErr_SetString(PyExc_RuntimeError, "Module 'crf' has already been imported. Re-initialisation is not supported.");
+    return -1;
+  }
+  #elif PY_MAJOR_VERSION >= 3
+  if (__pyx_m) return __Pyx_NewRef(__pyx_m);
+  #endif
+  #if CYTHON_REFNANNY
+__Pyx_RefNanny = __Pyx_RefNannyImportAPI("refnanny");
+if (!__Pyx_RefNanny) {
+  PyErr_Clear();
+  __Pyx_RefNanny = __Pyx_RefNannyImportAPI("Cython.Runtime.refnanny");
+  if (!__Pyx_RefNanny)
+      Py_FatalError("failed to import 'refnanny' module");
+}
+#endif
+  __Pyx_RefNannySetupContext("__Pyx_PyMODINIT_FUNC PyInit_crf(void)", 0);
+  if (__Pyx_check_binary_version() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
+  #ifdef __Pxy_PyFrame_Initialize_Offsets
+  __Pxy_PyFrame_Initialize_Offsets();
+  #endif
+  __pyx_empty_tuple = PyTuple_New(0); if (unlikely(!__pyx_empty_tuple)) __PYX_ERR(0, 1, __pyx_L1_error)
+  __pyx_empty_bytes = PyBytes_FromStringAndSize("", 0); if (unlikely(!__pyx_empty_bytes)) __PYX_ERR(0, 1, __pyx_L1_error)
+  __pyx_empty_unicode = PyUnicode_FromStringAndSize("", 0); if (unlikely(!__pyx_empty_unicode)) __PYX_ERR(0, 1, __pyx_L1_error)
+  #ifdef __Pyx_CyFunction_USED
+  if (__pyx_CyFunction_init() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
+  #endif
+  #ifdef __Pyx_FusedFunction_USED
+  if (__pyx_FusedFunction_init() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
+  #endif
+  #ifdef __Pyx_Coroutine_USED
+  if (__pyx_Coroutine_init() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
+  #endif
+  #ifdef __Pyx_Generator_USED
+  if (__pyx_Generator_init() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
+  #endif
+  #ifdef __Pyx_AsyncGen_USED
+  if (__pyx_AsyncGen_init() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
+  #endif
+  #ifdef __Pyx_StopAsyncIteration_USED
+  if (__pyx_StopAsyncIteration_init() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
+  #endif
+  /*--- Library function declarations ---*/
+  /*--- Threads initialization code ---*/
+  #if defined(WITH_THREAD) && PY_VERSION_HEX < 0x030700F0 && defined(__PYX_FORCE_INIT_THREADS) && __PYX_FORCE_INIT_THREADS
+  PyEval_InitThreads();
+  #endif
+  /*--- Module creation code ---*/
+  #if CYTHON_PEP489_MULTI_PHASE_INIT
+  __pyx_m = __pyx_pyinit_module;
+  Py_INCREF(__pyx_m);
+  #else
+  #if PY_MAJOR_VERSION < 3
+  __pyx_m = Py_InitModule4("crf", __pyx_methods, 0, 0, PYTHON_API_VERSION); Py_XINCREF(__pyx_m);
+  #else
+  __pyx_m = PyModule_Create(&__pyx_moduledef);
+  #endif
+  if (unlikely(!__pyx_m)) __PYX_ERR(0, 1, __pyx_L1_error)
+  #endif
+  __pyx_d = PyModule_GetDict(__pyx_m); if (unlikely(!__pyx_d)) __PYX_ERR(0, 1, __pyx_L1_error)
+  Py_INCREF(__pyx_d);
+  __pyx_b = PyImport_AddModule(__Pyx_BUILTIN_MODULE_NAME); if (unlikely(!__pyx_b)) __PYX_ERR(0, 1, __pyx_L1_error)
+  Py_INCREF(__pyx_b);
+  __pyx_cython_runtime = PyImport_AddModule((char *) "cython_runtime"); if (unlikely(!__pyx_cython_runtime)) __PYX_ERR(0, 1, __pyx_L1_error)
+  Py_INCREF(__pyx_cython_runtime);
+  if (PyObject_SetAttrString(__pyx_m, "__builtins__", __pyx_b) < 0) __PYX_ERR(0, 1, __pyx_L1_error);
+  /*--- Initialize various global constants etc. ---*/
+  if (__Pyx_InitGlobals() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
+  #if PY_MAJOR_VERSION < 3 && (__PYX_DEFAULT_STRING_ENCODING_IS_ASCII || __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT)
+  if (__Pyx_init_sys_getdefaultencoding_params() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
+  #endif
+  if (__pyx_module_is_main_crf) {
+    if (PyObject_SetAttr(__pyx_m, __pyx_n_s_name, __pyx_n_s_main) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
+  }
+  #if PY_MAJOR_VERSION >= 3
+  {
+    PyObject *modules = PyImport_GetModuleDict(); if (unlikely(!modules)) __PYX_ERR(0, 1, __pyx_L1_error)
+    if (!PyDict_GetItemString(modules, "crf")) {
+      if (unlikely(PyDict_SetItemString(modules, "crf", __pyx_m) < 0)) __PYX_ERR(0, 1, __pyx_L1_error)
+    }
+  }
+  #endif
+  /*--- Builtin init code ---*/
+  if (__Pyx_InitCachedBuiltins() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
+  /*--- Constants init code ---*/
+  if (__Pyx_InitCachedConstants() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
+  /*--- Global type/function init code ---*/
+  (void)__Pyx_modinit_global_init_code();
+  (void)__Pyx_modinit_variable_export_code();
+  (void)__Pyx_modinit_function_export_code();
+  if (unlikely(__Pyx_modinit_type_init_code() < 0)) __PYX_ERR(0, 1, __pyx_L1_error)
+  (void)__Pyx_modinit_type_import_code();
+  (void)__Pyx_modinit_variable_import_code();
+  (void)__Pyx_modinit_function_import_code();
+  /*--- Execution code ---*/
+  #if defined(__Pyx_Generator_USED) || defined(__Pyx_Coroutine_USED)
+  if (__Pyx_patch_abc() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
+  #endif
+
+  /* "crf.pyx":10
+ * cimport crfsuite_api
+ * from libcpp.string cimport string
+ * import os             # <<<<<<<<<<<<<<
+ * 
+ * from chaine.logging import Logger
+ */
+  __pyx_t_1 = __Pyx_Import(__pyx_n_s_os, 0, -1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 10, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_os, __pyx_t_1) < 0) __PYX_ERR(0, 10, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "crf.pyx":12
+ * import os
+ * 
+ * from chaine.logging import Logger             # <<<<<<<<<<<<<<
+ * from chaine.typing import Filepath, Labels, Sequence
+ * 
+ */
+  __pyx_t_1 = PyList_New(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 12, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_INCREF(__pyx_n_s_Logger);
+  __Pyx_GIVEREF(__pyx_n_s_Logger);
+  PyList_SET_ITEM(__pyx_t_1, 0, __pyx_n_s_Logger);
+  __pyx_t_2 = __Pyx_Import(__pyx_n_s_chaine_logging, __pyx_t_1, -1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 12, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __pyx_t_1 = __Pyx_ImportFrom(__pyx_t_2, __pyx_n_s_Logger); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 12, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_Logger, __pyx_t_1) < 0) __PYX_ERR(0, 12, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+
+  /* "crf.pyx":13
+ * 
+ * from chaine.logging import Logger
+ * from chaine.typing import Filepath, Labels, Sequence             # <<<<<<<<<<<<<<
+ * 
+ * LOGGER = Logger(__name__)
+ */
+  __pyx_t_2 = PyList_New(3); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 13, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  __Pyx_INCREF(__pyx_n_s_Filepath);
+  __Pyx_GIVEREF(__pyx_n_s_Filepath);
+  PyList_SET_ITEM(__pyx_t_2, 0, __pyx_n_s_Filepath);
+  __Pyx_INCREF(__pyx_n_s_Labels);
+  __Pyx_GIVEREF(__pyx_n_s_Labels);
+  PyList_SET_ITEM(__pyx_t_2, 1, __pyx_n_s_Labels);
+  __Pyx_INCREF(__pyx_n_s_Sequence);
+  __Pyx_GIVEREF(__pyx_n_s_Sequence);
+  PyList_SET_ITEM(__pyx_t_2, 2, __pyx_n_s_Sequence);
+  __pyx_t_1 = __Pyx_Import(__pyx_n_s_chaine_typing, __pyx_t_2, -1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 13, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __pyx_t_2 = __Pyx_ImportFrom(__pyx_t_1, __pyx_n_s_Filepath); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 13, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_Filepath, __pyx_t_2) < 0) __PYX_ERR(0, 13, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __pyx_t_2 = __Pyx_ImportFrom(__pyx_t_1, __pyx_n_s_Labels); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 13, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_Labels, __pyx_t_2) < 0) __PYX_ERR(0, 13, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __pyx_t_2 = __Pyx_ImportFrom(__pyx_t_1, __pyx_n_s_Sequence); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 13, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_Sequence, __pyx_t_2) < 0) __PYX_ERR(0, 13, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "crf.pyx":15
+ * from chaine.typing import Filepath, Labels, Sequence
+ * 
+ * LOGGER = Logger(__name__)             # <<<<<<<<<<<<<<
+ * 
+ * 
+ */
+  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_Logger); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 15, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_name); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 15, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  __pyx_t_3 = __Pyx_PyObject_CallOneArg(__pyx_t_1, __pyx_t_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 15, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_3);
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_LOGGER, __pyx_t_3) < 0) __PYX_ERR(0, 15, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+
+  /* "crf.pyx":22
+ * 
+ *     param2kwarg = {
+ *         "feature.minfreq": "min_freq",             # <<<<<<<<<<<<<<
+ *         "feature.possible_states": "all_possible_states",
+ *         "feature.possible_transitions": "all_possible_transitions",
+ */
+  __pyx_t_3 = __Pyx_PyDict_NewPresized(9); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 22, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_3);
+  if (PyDict_SetItem(__pyx_t_3, __pyx_kp_s_feature_minfreq, __pyx_n_s_min_freq) < 0) __PYX_ERR(0, 22, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_3, __pyx_kp_s_feature_possible_states, __pyx_n_s_all_possible_states) < 0) __PYX_ERR(0, 22, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_3, __pyx_kp_s_feature_possible_transitions, __pyx_n_s_all_possible_transitions) < 0) __PYX_ERR(0, 22, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_3, __pyx_kp_s_calibration_eta, __pyx_n_s_calibration_eta_2) < 0) __PYX_ERR(0, 22, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_3, __pyx_kp_s_calibration_rate, __pyx_n_s_calibration_rate_2) < 0) __PYX_ERR(0, 22, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_3, __pyx_kp_s_calibration_samples, __pyx_n_s_calibration_samples_2) < 0) __PYX_ERR(0, 22, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_3, __pyx_kp_s_calibration_candidates, __pyx_n_s_calibration_candidates_2) < 0) __PYX_ERR(0, 22, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_3, __pyx_kp_s_calibration_max_trials, __pyx_n_s_calibration_max_trials_2) < 0) __PYX_ERR(0, 22, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_type, __pyx_n_s_pa_type) < 0) __PYX_ERR(0, 22, __pyx_L1_error)
+  if (PyDict_SetItem((PyObject *)__pyx_ptype_3crf_Trainer->tp_dict, __pyx_n_s_param2kwarg, __pyx_t_3) < 0) __PYX_ERR(0, 21, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  PyType_Modified(__pyx_ptype_3crf_Trainer);
+
+  /* "crf.pyx":33
+ *     }
+ *     kwarg2param = {
+ *         "min_freq": "feature.minfreq",             # <<<<<<<<<<<<<<
+ *         "all_possible_states": "feature.possible_states",
+ *         "all_possible_transitions": "feature.possible_transitions",
+ */
+  __pyx_t_3 = __Pyx_PyDict_NewPresized(9); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 33, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_3);
+  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_min_freq, __pyx_kp_s_feature_minfreq) < 0) __PYX_ERR(0, 33, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_all_possible_states, __pyx_kp_s_feature_possible_states) < 0) __PYX_ERR(0, 33, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_all_possible_transitions, __pyx_kp_s_feature_possible_transitions) < 0) __PYX_ERR(0, 33, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_calibration_eta_2, __pyx_kp_s_calibration_eta) < 0) __PYX_ERR(0, 33, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_calibration_rate_2, __pyx_kp_s_calibration_rate) < 0) __PYX_ERR(0, 33, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_calibration_samples_2, __pyx_kp_s_calibration_samples) < 0) __PYX_ERR(0, 33, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_calibration_candidates_2, __pyx_kp_s_calibration_candidates) < 0) __PYX_ERR(0, 33, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_calibration_max_trials_2, __pyx_kp_s_calibration_max_trials) < 0) __PYX_ERR(0, 33, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_pa_type, __pyx_n_s_type) < 0) __PYX_ERR(0, 33, __pyx_L1_error)
+  if (PyDict_SetItem((PyObject *)__pyx_ptype_3crf_Trainer->tp_dict, __pyx_n_s_kwarg2param, __pyx_t_3) < 0) __PYX_ERR(0, 32, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  PyType_Modified(__pyx_ptype_3crf_Trainer);
+
+  /* "crf.pyx":44
+ *     }
+ *     _algorithm_aliases = {
+ *         "lbfgs": "lbfgs",             # <<<<<<<<<<<<<<
+ *         "limited-memory-bfgs": "lbfgs",
+ *         "l2sgd": "l2sgd",
+ */
+  __pyx_t_3 = __Pyx_PyDict_NewPresized(10); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 44, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_3);
+  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_lbfgs, __pyx_n_s_lbfgs) < 0) __PYX_ERR(0, 44, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_3, __pyx_kp_s_limited_memory_bfgs, __pyx_n_s_lbfgs) < 0) __PYX_ERR(0, 44, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_l2sgd, __pyx_n_s_l2sgd) < 0) __PYX_ERR(0, 44, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_sgd, __pyx_n_s_l2sgd) < 0) __PYX_ERR(0, 44, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_3, __pyx_kp_s_stochastic_gradient_descent, __pyx_n_s_l2sgd) < 0) __PYX_ERR(0, 44, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_ap, __pyx_kp_s_averaged_perceptron) < 0) __PYX_ERR(0, 44, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_3, __pyx_kp_s_averaged_perceptron, __pyx_kp_s_averaged_perceptron) < 0) __PYX_ERR(0, 44, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_pa, __pyx_kp_s_passive_aggressive) < 0) __PYX_ERR(0, 44, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_3, __pyx_kp_s_passive_aggressive, __pyx_kp_s_passive_aggressive) < 0) __PYX_ERR(0, 44, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_arow, __pyx_n_s_arow) < 0) __PYX_ERR(0, 44, __pyx_L1_error)
+  if (PyDict_SetItem((PyObject *)__pyx_ptype_3crf_Trainer->tp_dict, __pyx_n_s_algorithm_aliases, __pyx_t_3) < 0) __PYX_ERR(0, 43, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  PyType_Modified(__pyx_ptype_3crf_Trainer);
+
+  /* "crf.pyx":56
+ *     }
+ *     _parameter_types = {
+ *             "feature.minfreq": float,             # <<<<<<<<<<<<<<
+ *             "feature.possible_states": lambda value: bool(int(value)),
+ *             "feature.possible_transitions": lambda value: bool(int(value)),
+ */
+  __pyx_t_3 = __Pyx_PyDict_NewPresized(23); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 56, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_3);
+  if (PyDict_SetItem(__pyx_t_3, __pyx_kp_s_feature_minfreq, ((PyObject *)(&PyFloat_Type))) < 0) __PYX_ERR(0, 56, __pyx_L1_error)
+
+  /* "crf.pyx":57
+ *     _parameter_types = {
+ *             "feature.minfreq": float,
+ *             "feature.possible_states": lambda value: bool(int(value)),             # <<<<<<<<<<<<<<
+ *             "feature.possible_transitions": lambda value: bool(int(value)),
+ *             "c1": float,
+ */
+  __pyx_t_2 = __Pyx_CyFunction_New(&__pyx_mdef_3crf_7Trainer_22lambda, 0, __pyx_n_s_Trainer_lambda, NULL, __pyx_n_s_crf, __pyx_d, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 57, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  if (PyDict_SetItem(__pyx_t_3, __pyx_kp_s_feature_possible_states, __pyx_t_2) < 0) __PYX_ERR(0, 56, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+
+  /* "crf.pyx":58
+ *             "feature.minfreq": float,
+ *             "feature.possible_states": lambda value: bool(int(value)),
+ *             "feature.possible_transitions": lambda value: bool(int(value)),             # <<<<<<<<<<<<<<
+ *             "c1": float,
+ *             "c2": float,
+ */
+  __pyx_t_2 = __Pyx_CyFunction_New(&__pyx_mdef_3crf_7Trainer_23lambda1, 0, __pyx_n_s_Trainer_lambda, NULL, __pyx_n_s_crf, __pyx_d, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 58, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  if (PyDict_SetItem(__pyx_t_3, __pyx_kp_s_feature_possible_transitions, __pyx_t_2) < 0) __PYX_ERR(0, 56, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+
+  /* "crf.pyx":59
+ *             "feature.possible_states": lambda value: bool(int(value)),
+ *             "feature.possible_transitions": lambda value: bool(int(value)),
+ *             "c1": float,             # <<<<<<<<<<<<<<
+ *             "c2": float,
+ *             "max_iterations": int,
+ */
+  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_c1, ((PyObject *)(&PyFloat_Type))) < 0) __PYX_ERR(0, 56, __pyx_L1_error)
+
+  /* "crf.pyx":60
+ *             "feature.possible_transitions": lambda value: bool(int(value)),
+ *             "c1": float,
+ *             "c2": float,             # <<<<<<<<<<<<<<
+ *             "max_iterations": int,
+ *             "num_memories": int,
+ */
+  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_c2, ((PyObject *)(&PyFloat_Type))) < 0) __PYX_ERR(0, 56, __pyx_L1_error)
+
+  /* "crf.pyx":61
+ *             "c1": float,
+ *             "c2": float,
+ *             "max_iterations": int,             # <<<<<<<<<<<<<<
+ *             "num_memories": int,
+ *             "epsilon": float,
+ */
+  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_max_iterations, ((PyObject *)(&PyInt_Type))) < 0) __PYX_ERR(0, 56, __pyx_L1_error)
+
+  /* "crf.pyx":62
+ *             "c2": float,
+ *             "max_iterations": int,
+ *             "num_memories": int,             # <<<<<<<<<<<<<<
+ *             "epsilon": float,
+ *             "period": int,
+ */
+  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_num_memories, ((PyObject *)(&PyInt_Type))) < 0) __PYX_ERR(0, 56, __pyx_L1_error)
+
+  /* "crf.pyx":63
+ *             "max_iterations": int,
+ *             "num_memories": int,
+ *             "epsilon": float,             # <<<<<<<<<<<<<<
+ *             "period": int,
+ *             "delta": float,
+ */
+  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_epsilon, ((PyObject *)(&PyFloat_Type))) < 0) __PYX_ERR(0, 56, __pyx_L1_error)
+
+  /* "crf.pyx":64
+ *             "num_memories": int,
+ *             "epsilon": float,
+ *             "period": int,             # <<<<<<<<<<<<<<
+ *             "delta": float,
+ *             "linesearch": str,
+ */
+  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_period, ((PyObject *)(&PyInt_Type))) < 0) __PYX_ERR(0, 56, __pyx_L1_error)
+
+  /* "crf.pyx":65
+ *             "epsilon": float,
+ *             "period": int,
+ *             "delta": float,             # <<<<<<<<<<<<<<
+ *             "linesearch": str,
+ *             "max_linesearch": int,
+ */
+  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_delta, ((PyObject *)(&PyFloat_Type))) < 0) __PYX_ERR(0, 56, __pyx_L1_error)
+
+  /* "crf.pyx":66
+ *             "period": int,
+ *             "delta": float,
+ *             "linesearch": str,             # <<<<<<<<<<<<<<
+ *             "max_linesearch": int,
+ *             "calibration.eta": float,
+ */
+  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_linesearch, ((PyObject *)(&PyString_Type))) < 0) __PYX_ERR(0, 56, __pyx_L1_error)
+
+  /* "crf.pyx":67
+ *             "delta": float,
+ *             "linesearch": str,
+ *             "max_linesearch": int,             # <<<<<<<<<<<<<<
+ *             "calibration.eta": float,
+ *             "calibration.rate": float,
+ */
+  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_max_linesearch, ((PyObject *)(&PyInt_Type))) < 0) __PYX_ERR(0, 56, __pyx_L1_error)
+
+  /* "crf.pyx":68
+ *             "linesearch": str,
+ *             "max_linesearch": int,
+ *             "calibration.eta": float,             # <<<<<<<<<<<<<<
+ *             "calibration.rate": float,
+ *             "calibration.samples": float,
+ */
+  if (PyDict_SetItem(__pyx_t_3, __pyx_kp_s_calibration_eta, ((PyObject *)(&PyFloat_Type))) < 0) __PYX_ERR(0, 56, __pyx_L1_error)
+
+  /* "crf.pyx":69
+ *             "max_linesearch": int,
+ *             "calibration.eta": float,
+ *             "calibration.rate": float,             # <<<<<<<<<<<<<<
+ *             "calibration.samples": float,
+ *             "calibration.candidates": int,
+ */
+  if (PyDict_SetItem(__pyx_t_3, __pyx_kp_s_calibration_rate, ((PyObject *)(&PyFloat_Type))) < 0) __PYX_ERR(0, 56, __pyx_L1_error)
+
+  /* "crf.pyx":70
+ *             "calibration.eta": float,
+ *             "calibration.rate": float,
+ *             "calibration.samples": float,             # <<<<<<<<<<<<<<
+ *             "calibration.candidates": int,
+ *             "calibration.max_trials": int,
+ */
+  if (PyDict_SetItem(__pyx_t_3, __pyx_kp_s_calibration_samples, ((PyObject *)(&PyFloat_Type))) < 0) __PYX_ERR(0, 56, __pyx_L1_error)
+
+  /* "crf.pyx":71
+ *             "calibration.rate": float,
+ *             "calibration.samples": float,
+ *             "calibration.candidates": int,             # <<<<<<<<<<<<<<
+ *             "calibration.max_trials": int,
+ *             "type": int,
+ */
+  if (PyDict_SetItem(__pyx_t_3, __pyx_kp_s_calibration_candidates, ((PyObject *)(&PyInt_Type))) < 0) __PYX_ERR(0, 56, __pyx_L1_error)
+
+  /* "crf.pyx":72
+ *             "calibration.samples": float,
+ *             "calibration.candidates": int,
+ *             "calibration.max_trials": int,             # <<<<<<<<<<<<<<
+ *             "type": int,
+ *             "c": float,
+ */
+  if (PyDict_SetItem(__pyx_t_3, __pyx_kp_s_calibration_max_trials, ((PyObject *)(&PyInt_Type))) < 0) __PYX_ERR(0, 56, __pyx_L1_error)
+
+  /* "crf.pyx":73
+ *             "calibration.candidates": int,
+ *             "calibration.max_trials": int,
+ *             "type": int,             # <<<<<<<<<<<<<<
+ *             "c": float,
+ *             "error_sensitive": lambda value: bool(int(value)),
+ */
+  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_type, ((PyObject *)(&PyInt_Type))) < 0) __PYX_ERR(0, 56, __pyx_L1_error)
+
+  /* "crf.pyx":74
+ *             "calibration.max_trials": int,
+ *             "type": int,
+ *             "c": float,             # <<<<<<<<<<<<<<
+ *             "error_sensitive": lambda value: bool(int(value)),
+ *             "averaging": lambda value: bool(int(value)),
+ */
+  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_c, ((PyObject *)(&PyFloat_Type))) < 0) __PYX_ERR(0, 56, __pyx_L1_error)
+
+  /* "crf.pyx":75
+ *             "type": int,
+ *             "c": float,
+ *             "error_sensitive": lambda value: bool(int(value)),             # <<<<<<<<<<<<<<
+ *             "averaging": lambda value: bool(int(value)),
+ *             "variance": float,
+ */
+  __pyx_t_2 = __Pyx_CyFunction_New(&__pyx_mdef_3crf_7Trainer_24lambda2, 0, __pyx_n_s_Trainer_lambda, NULL, __pyx_n_s_crf, __pyx_d, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 75, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_error_sensitive, __pyx_t_2) < 0) __PYX_ERR(0, 56, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+
+  /* "crf.pyx":76
+ *             "c": float,
+ *             "error_sensitive": lambda value: bool(int(value)),
+ *             "averaging": lambda value: bool(int(value)),             # <<<<<<<<<<<<<<
+ *             "variance": float,
+ *             "gamma": float,
+ */
+  __pyx_t_2 = __Pyx_CyFunction_New(&__pyx_mdef_3crf_7Trainer_25lambda3, 0, __pyx_n_s_Trainer_lambda, NULL, __pyx_n_s_crf, __pyx_d, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 76, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_averaging, __pyx_t_2) < 0) __PYX_ERR(0, 56, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+
+  /* "crf.pyx":77
+ *             "error_sensitive": lambda value: bool(int(value)),
+ *             "averaging": lambda value: bool(int(value)),
+ *             "variance": float,             # <<<<<<<<<<<<<<
+ *             "gamma": float,
+ *         }
+ */
+  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_variance, ((PyObject *)(&PyFloat_Type))) < 0) __PYX_ERR(0, 56, __pyx_L1_error)
+
+  /* "crf.pyx":78
+ *             "averaging": lambda value: bool(int(value)),
+ *             "variance": float,
+ *             "gamma": float,             # <<<<<<<<<<<<<<
+ *         }
+ * 
+ */
+  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_gamma, ((PyObject *)(&PyFloat_Type))) < 0) __PYX_ERR(0, 56, __pyx_L1_error)
+  if (PyDict_SetItem((PyObject *)__pyx_ptype_3crf_Trainer->tp_dict, __pyx_n_s_parameter_types, __pyx_t_3) < 0) __PYX_ERR(0, 55, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  PyType_Modified(__pyx_ptype_3crf_Trainer);
+
+  /* "crf.pyx":179
+ * 
+ *     @staticmethod
+ *     def check_model(filepath: str):             # <<<<<<<<<<<<<<
+ *         with open(filepath, "rb") as model:
+ *             magic = model.read(4)
+ */
+  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_3crf_5Model_13check_model, NULL, __pyx_n_s_crf); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 179, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_3);
+  if (PyDict_SetItem((PyObject *)__pyx_ptype_3crf_Model->tp_dict, __pyx_n_s_check_model, __pyx_t_3) < 0) __PYX_ERR(0, 179, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  PyType_Modified(__pyx_ptype_3crf_Model);
+
+  /* "crf.pyx":178
+ *         self._tagger.set(to_seq(sequence))
+ * 
+ *     @staticmethod             # <<<<<<<<<<<<<<
+ *     def check_model(filepath: str):
+ *         with open(filepath, "rb") as model:
+ */
+  __Pyx_GetNameInClass(__pyx_t_3, (PyObject *)__pyx_ptype_3crf_Model, __pyx_n_s_check_model); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 179, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_3);
+  __pyx_t_2 = __Pyx_PyObject_CallOneArg(__pyx_builtin_staticmethod, __pyx_t_3); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 178, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  if (PyDict_SetItem((PyObject *)__pyx_ptype_3crf_Model->tp_dict, __pyx_n_s_check_model, __pyx_t_2) < 0) __PYX_ERR(0, 179, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  PyType_Modified(__pyx_ptype_3crf_Model);
+
+  /* "crf.pyx":1
+ * # cython: embedsignature=True             # <<<<<<<<<<<<<<
+ * # cython: c_string_type=str
+ * # cython: c_string_encoding=utf-8
+ */
+  __pyx_t_2 = __Pyx_PyDict_NewPresized(0); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_test, __pyx_t_2) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+
+  /* "vector.from_py":45
+ * 
+ * @cname("__pyx_convert_vector_from_py_std_3a__3a_string")
+ * cdef vector[X] __pyx_convert_vector_from_py_std_3a__3a_string(object o) except *:             # <<<<<<<<<<<<<<
+ *     cdef vector[X] v
+ *     for item in o:
+ */
+
+  /*--- Wrapped vars code ---*/
+
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_XDECREF(__pyx_t_2);
+  __Pyx_XDECREF(__pyx_t_3);
+  if (__pyx_m) {
+    if (__pyx_d) {
+      __Pyx_AddTraceback("init crf", __pyx_clineno, __pyx_lineno, __pyx_filename);
+    }
+    Py_CLEAR(__pyx_m);
+  } else if (!PyErr_Occurred()) {
+    PyErr_SetString(PyExc_ImportError, "init crf");
+  }
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  #if CYTHON_PEP489_MULTI_PHASE_INIT
+  return (__pyx_m != NULL) ? 0 : -1;
+  #elif PY_MAJOR_VERSION >= 3
+  return __pyx_m;
+  #else
+  return;
+  #endif
+}
+
+/* --- Runtime support code --- */
+/* Refnanny */
+#if CYTHON_REFNANNY
+static __Pyx_RefNannyAPIStruct *__Pyx_RefNannyImportAPI(const char *modname) {
+    PyObject *m = NULL, *p = NULL;
+    void *r = NULL;
+    m = PyImport_ImportModule(modname);
+    if (!m) goto end;
+    p = PyObject_GetAttrString(m, "RefNannyAPI");
+    if (!p) goto end;
+    r = PyLong_AsVoidPtr(p);
+end:
+    Py_XDECREF(p);
+    Py_XDECREF(m);
+    return (__Pyx_RefNannyAPIStruct *)r;
+}
+#endif
+
+/* PyObjectGetAttrStr */
+#if CYTHON_USE_TYPE_SLOTS
+static CYTHON_INLINE PyObject* __Pyx_PyObject_GetAttrStr(PyObject* obj, PyObject* attr_name) {
+    PyTypeObject* tp = Py_TYPE(obj);
+    if (likely(tp->tp_getattro))
+        return tp->tp_getattro(obj, attr_name);
+#if PY_MAJOR_VERSION < 3
+    if (likely(tp->tp_getattr))
+        return tp->tp_getattr(obj, PyString_AS_STRING(attr_name));
+#endif
+    return PyObject_GetAttr(obj, attr_name);
+}
+#endif
+
+/* GetBuiltinName */
+static PyObject *__Pyx_GetBuiltinName(PyObject *name) {
+    PyObject* result = __Pyx_PyObject_GetAttrStr(__pyx_b, name);
+    if (unlikely(!result)) {
+        PyErr_Format(PyExc_NameError,
+#if PY_MAJOR_VERSION >= 3
+            "name '%U' is not defined", name);
+#else
+            "name '%.200s' is not defined", PyString_AS_STRING(name));
+#endif
+    }
+    return result;
+}
+
+/* RaiseDoubleKeywords */
+static void __Pyx_RaiseDoubleKeywordsError(
+    const char* func_name,
+    PyObject* kw_name)
+{
+    PyErr_Format(PyExc_TypeError,
+        #if PY_MAJOR_VERSION >= 3
+        "%s() got multiple values for keyword argument '%U'", func_name, kw_name);
+        #else
+        "%s() got multiple values for keyword argument '%s'", func_name,
+        PyString_AsString(kw_name));
+        #endif
+}
+
+/* ParseKeywords */
+static int __Pyx_ParseOptionalKeywords(
+    PyObject *kwds,
+    PyObject **argnames[],
+    PyObject *kwds2,
+    PyObject *values[],
+    Py_ssize_t num_pos_args,
+    const char* function_name)
+{
+    PyObject *key = 0, *value = 0;
+    Py_ssize_t pos = 0;
+    PyObject*** name;
+    PyObject*** first_kw_arg = argnames + num_pos_args;
+    while (PyDict_Next(kwds, &pos, &key, &value)) {
+        name = first_kw_arg;
+        while (*name && (**name != key)) name++;
+        if (*name) {
+            values[name-argnames] = value;
+            continue;
+        }
+        name = first_kw_arg;
+        #if PY_MAJOR_VERSION < 3
+        if (likely(PyString_Check(key))) {
+            while (*name) {
+                if ((CYTHON_COMPILING_IN_PYPY || PyString_GET_SIZE(**name) == PyString_GET_SIZE(key))
+                        && _PyString_Eq(**name, key)) {
+                    values[name-argnames] = value;
+                    break;
+                }
+                name++;
+            }
+            if (*name) continue;
+            else {
+                PyObject*** argname = argnames;
+                while (argname != first_kw_arg) {
+                    if ((**argname == key) || (
+                            (CYTHON_COMPILING_IN_PYPY || PyString_GET_SIZE(**argname) == PyString_GET_SIZE(key))
+                             && _PyString_Eq(**argname, key))) {
+                        goto arg_passed_twice;
+                    }
+                    argname++;
+                }
+            }
+        } else
+        #endif
+        if (likely(PyUnicode_Check(key))) {
+            while (*name) {
+                int cmp = (**name == key) ? 0 :
+                #if !CYTHON_COMPILING_IN_PYPY && PY_MAJOR_VERSION >= 3
+                    (__Pyx_PyUnicode_GET_LENGTH(**name) != __Pyx_PyUnicode_GET_LENGTH(key)) ? 1 :
+                #endif
+                    PyUnicode_Compare(**name, key);
+                if (cmp < 0 && unlikely(PyErr_Occurred())) goto bad;
+                if (cmp == 0) {
+                    values[name-argnames] = value;
+                    break;
+                }
+                name++;
+            }
+            if (*name) continue;
+            else {
+                PyObject*** argname = argnames;
+                while (argname != first_kw_arg) {
+                    int cmp = (**argname == key) ? 0 :
+                    #if !CYTHON_COMPILING_IN_PYPY && PY_MAJOR_VERSION >= 3
+                        (__Pyx_PyUnicode_GET_LENGTH(**argname) != __Pyx_PyUnicode_GET_LENGTH(key)) ? 1 :
+                    #endif
+                        PyUnicode_Compare(**argname, key);
+                    if (cmp < 0 && unlikely(PyErr_Occurred())) goto bad;
+                    if (cmp == 0) goto arg_passed_twice;
+                    argname++;
+                }
+            }
+        } else
+            goto invalid_keyword_type;
+        if (kwds2) {
+            if (unlikely(PyDict_SetItem(kwds2, key, value))) goto bad;
+        } else {
+            goto invalid_keyword;
+        }
+    }
+    return 0;
+arg_passed_twice:
+    __Pyx_RaiseDoubleKeywordsError(function_name, key);
+    goto bad;
+invalid_keyword_type:
+    PyErr_Format(PyExc_TypeError,
+        "%.200s() keywords must be strings", function_name);
+    goto bad;
+invalid_keyword:
+    PyErr_Format(PyExc_TypeError,
+    #if PY_MAJOR_VERSION < 3
+        "%.200s() got an unexpected keyword argument '%.200s'",
+        function_name, PyString_AsString(key));
+    #else
+        "%s() got an unexpected keyword argument '%U'",
+        function_name, key);
+    #endif
+bad:
+    return -1;
+}
+
+/* RaiseArgTupleInvalid */
+static void __Pyx_RaiseArgtupleInvalid(
+    const char* func_name,
+    int exact,
+    Py_ssize_t num_min,
+    Py_ssize_t num_max,
+    Py_ssize_t num_found)
+{
+    Py_ssize_t num_expected;
+    const char *more_or_less;
+    if (num_found < num_min) {
+        num_expected = num_min;
+        more_or_less = "at least";
+    } else {
+        num_expected = num_max;
+        more_or_less = "at most";
+    }
+    if (exact) {
+        more_or_less = "exactly";
+    }
+    PyErr_Format(PyExc_TypeError,
+                 "%.200s() takes %.8s %" CYTHON_FORMAT_SSIZE_T "d positional argument%.1s (%" CYTHON_FORMAT_SSIZE_T "d given)",
+                 func_name, more_or_less, num_expected,
+                 (num_expected == 1) ? "" : "s", num_found);
+}
+
+/* ArgTypeTest */
+static int __Pyx__ArgTypeTest(PyObject *obj, PyTypeObject *type, const char *name, int exact)
+{
+    if (unlikely(!type)) {
+        PyErr_SetString(PyExc_SystemError, "Missing type object");
+        return 0;
+    }
+    else if (exact) {
+        #if PY_MAJOR_VERSION == 2
+        if ((type == &PyBaseString_Type) && likely(__Pyx_PyBaseString_CheckExact(obj))) return 1;
+        #endif
+    }
+    else {
+        if (likely(__Pyx_TypeCheck(obj, type))) return 1;
+    }
+    PyErr_Format(PyExc_TypeError,
+        "Argument '%.200s' has incorrect type (expected %.200s, got %.200s)",
+        name, type->tp_name, Py_TYPE(obj)->tp_name);
+    return 0;
+}
+
+/* PyCFunctionFastCall */
+#if CYTHON_FAST_PYCCALL
+static CYTHON_INLINE PyObject * __Pyx_PyCFunction_FastCall(PyObject *func_obj, PyObject **args, Py_ssize_t nargs) {
+    PyCFunctionObject *func = (PyCFunctionObject*)func_obj;
+    PyCFunction meth = PyCFunction_GET_FUNCTION(func);
+    PyObject *self = PyCFunction_GET_SELF(func);
+    int flags = PyCFunction_GET_FLAGS(func);
+    assert(PyCFunction_Check(func));
+    assert(METH_FASTCALL == (flags & ~(METH_CLASS | METH_STATIC | METH_COEXIST | METH_KEYWORDS | METH_STACKLESS)));
+    assert(nargs >= 0);
+    assert(nargs == 0 || args != NULL);
+    /* _PyCFunction_FastCallDict() must not be called with an exception set,
+       because it may clear it (directly or indirectly) and so the
+       caller loses its exception */
+    assert(!PyErr_Occurred());
+    if ((PY_VERSION_HEX < 0x030700A0) || unlikely(flags & METH_KEYWORDS)) {
+        return (*((__Pyx_PyCFunctionFastWithKeywords)(void*)meth)) (self, args, nargs, NULL);
+    } else {
+        return (*((__Pyx_PyCFunctionFast)(void*)meth)) (self, args, nargs);
+    }
+}
+#endif
+
+/* PyFunctionFastCall */
+#if CYTHON_FAST_PYCALL
+static PyObject* __Pyx_PyFunction_FastCallNoKw(PyCodeObject *co, PyObject **args, Py_ssize_t na,
+                                               PyObject *globals) {
+    PyFrameObject *f;
+    PyThreadState *tstate = __Pyx_PyThreadState_Current;
+    PyObject **fastlocals;
+    Py_ssize_t i;
+    PyObject *result;
+    assert(globals != NULL);
+    /* XXX Perhaps we should create a specialized
+       PyFrame_New() that doesn't take locals, but does
+       take builtins without sanity checking them.
+       */
+    assert(tstate != NULL);
+    f = PyFrame_New(tstate, co, globals, NULL);
+    if (f == NULL) {
+        return NULL;
+    }
+    fastlocals = __Pyx_PyFrame_GetLocalsplus(f);
+    for (i = 0; i < na; i++) {
+        Py_INCREF(*args);
+        fastlocals[i] = *args++;
+    }
+    result = PyEval_EvalFrameEx(f,0);
+    ++tstate->recursion_depth;
+    Py_DECREF(f);
+    --tstate->recursion_depth;
+    return result;
+}
+#if 1 || PY_VERSION_HEX < 0x030600B1
+static PyObject *__Pyx_PyFunction_FastCallDict(PyObject *func, PyObject **args, Py_ssize_t nargs, PyObject *kwargs) {
+    PyCodeObject *co = (PyCodeObject *)PyFunction_GET_CODE(func);
+    PyObject *globals = PyFunction_GET_GLOBALS(func);
+    PyObject *argdefs = PyFunction_GET_DEFAULTS(func);
+    PyObject *closure;
+#if PY_MAJOR_VERSION >= 3
+    PyObject *kwdefs;
+#endif
+    PyObject *kwtuple, **k;
+    PyObject **d;
+    Py_ssize_t nd;
+    Py_ssize_t nk;
+    PyObject *result;
+    assert(kwargs == NULL || PyDict_Check(kwargs));
+    nk = kwargs ? PyDict_Size(kwargs) : 0;
+    if (Py_EnterRecursiveCall((char*)" while calling a Python object")) {
+        return NULL;
+    }
+    if (
+#if PY_MAJOR_VERSION >= 3
+            co->co_kwonlyargcount == 0 &&
+#endif
+            likely(kwargs == NULL || nk == 0) &&
+            co->co_flags == (CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE)) {
+        if (argdefs == NULL && co->co_argcount == nargs) {
+            result = __Pyx_PyFunction_FastCallNoKw(co, args, nargs, globals);
+            goto done;
+        }
+        else if (nargs == 0 && argdefs != NULL
+                 && co->co_argcount == Py_SIZE(argdefs)) {
+            /* function called with no arguments, but all parameters have
+               a default value: use default values as arguments .*/
+            args = &PyTuple_GET_ITEM(argdefs, 0);
+            result =__Pyx_PyFunction_FastCallNoKw(co, args, Py_SIZE(argdefs), globals);
+            goto done;
+        }
+    }
+    if (kwargs != NULL) {
+        Py_ssize_t pos, i;
+        kwtuple = PyTuple_New(2 * nk);
+        if (kwtuple == NULL) {
+            result = NULL;
+            goto done;
+        }
+        k = &PyTuple_GET_ITEM(kwtuple, 0);
+        pos = i = 0;
+        while (PyDict_Next(kwargs, &pos, &k[i], &k[i+1])) {
+            Py_INCREF(k[i]);
+            Py_INCREF(k[i+1]);
+            i += 2;
+        }
+        nk = i / 2;
+    }
+    else {
+        kwtuple = NULL;
+        k = NULL;
+    }
+    closure = PyFunction_GET_CLOSURE(func);
+#if PY_MAJOR_VERSION >= 3
+    kwdefs = PyFunction_GET_KW_DEFAULTS(func);
+#endif
+    if (argdefs != NULL) {
+        d = &PyTuple_GET_ITEM(argdefs, 0);
+        nd = Py_SIZE(argdefs);
+    }
+    else {
+        d = NULL;
+        nd = 0;
+    }
+#if PY_MAJOR_VERSION >= 3
+    result = PyEval_EvalCodeEx((PyObject*)co, globals, (PyObject *)NULL,
+                               args, (int)nargs,
+                               k, (int)nk,
+                               d, (int)nd, kwdefs, closure);
+#else
+    result = PyEval_EvalCodeEx(co, globals, (PyObject *)NULL,
+                               args, (int)nargs,
+                               k, (int)nk,
+                               d, (int)nd, closure);
+#endif
+    Py_XDECREF(kwtuple);
+done:
+    Py_LeaveRecursiveCall();
+    return result;
+}
+#endif
+#endif
+
+/* PyObjectCall */
+#if CYTHON_COMPILING_IN_CPYTHON
+static CYTHON_INLINE PyObject* __Pyx_PyObject_Call(PyObject *func, PyObject *arg, PyObject *kw) {
+    PyObject *result;
+    ternaryfunc call = Py_TYPE(func)->tp_call;
+    if (unlikely(!call))
+        return PyObject_Call(func, arg, kw);
+    if (unlikely(Py_EnterRecursiveCall((char*)" while calling a Python object")))
+        return NULL;
+    result = (*call)(func, arg, kw);
+    Py_LeaveRecursiveCall();
+    if (unlikely(!result) && unlikely(!PyErr_Occurred())) {
+        PyErr_SetString(
+            PyExc_SystemError,
+            "NULL result without error in PyObject_Call");
+    }
+    return result;
+}
+#endif
+
+/* PyObjectCall2Args */
+static CYTHON_UNUSED PyObject* __Pyx_PyObject_Call2Args(PyObject* function, PyObject* arg1, PyObject* arg2) {
+    PyObject *args, *result = NULL;
+    #if CYTHON_FAST_PYCALL
+    if (PyFunction_Check(function)) {
+        PyObject *args[2] = {arg1, arg2};
+        return __Pyx_PyFunction_FastCall(function, args, 2);
+    }
+    #endif
+    #if CYTHON_FAST_PYCCALL
+    if (__Pyx_PyFastCFunction_Check(function)) {
+        PyObject *args[2] = {arg1, arg2};
+        return __Pyx_PyCFunction_FastCall(function, args, 2);
+    }
+    #endif
+    args = PyTuple_New(2);
+    if (unlikely(!args)) goto done;
+    Py_INCREF(arg1);
+    PyTuple_SET_ITEM(args, 0, arg1);
+    Py_INCREF(arg2);
+    PyTuple_SET_ITEM(args, 1, arg2);
+    Py_INCREF(function);
+    result = __Pyx_PyObject_Call(function, args, NULL);
+    Py_DECREF(args);
+    Py_DECREF(function);
+done:
+    return result;
+}
+
+/* PyObjectCallMethO */
+#if CYTHON_COMPILING_IN_CPYTHON
+static CYTHON_INLINE PyObject* __Pyx_PyObject_CallMethO(PyObject *func, PyObject *arg) {
+    PyObject *self, *result;
+    PyCFunction cfunc;
+    cfunc = PyCFunction_GET_FUNCTION(func);
+    self = PyCFunction_GET_SELF(func);
+    if (unlikely(Py_EnterRecursiveCall((char*)" while calling a Python object")))
+        return NULL;
+    result = cfunc(self, arg);
+    Py_LeaveRecursiveCall();
+    if (unlikely(!result) && unlikely(!PyErr_Occurred())) {
+        PyErr_SetString(
+            PyExc_SystemError,
+            "NULL result without error in PyObject_Call");
+    }
+    return result;
+}
+#endif
+
+/* PyObjectCallOneArg */
+#if CYTHON_COMPILING_IN_CPYTHON
+static PyObject* __Pyx__PyObject_CallOneArg(PyObject *func, PyObject *arg) {
+    PyObject *result;
+    PyObject *args = PyTuple_New(1);
+    if (unlikely(!args)) return NULL;
+    Py_INCREF(arg);
+    PyTuple_SET_ITEM(args, 0, arg);
+    result = __Pyx_PyObject_Call(func, args, NULL);
+    Py_DECREF(args);
+    return result;
+}
+static CYTHON_INLINE PyObject* __Pyx_PyObject_CallOneArg(PyObject *func, PyObject *arg) {
+#if CYTHON_FAST_PYCALL
+    if (PyFunction_Check(func)) {
+        return __Pyx_PyFunction_FastCall(func, &arg, 1);
+    }
+#endif
+    if (likely(PyCFunction_Check(func))) {
+        if (likely(PyCFunction_GET_FLAGS(func) & METH_O)) {
+            return __Pyx_PyObject_CallMethO(func, arg);
+#if CYTHON_FAST_PYCCALL
+        } else if (__Pyx_PyFastCFunction_Check(func)) {
+            return __Pyx_PyCFunction_FastCall(func, &arg, 1);
+#endif
+        }
+    }
+    return __Pyx__PyObject_CallOneArg(func, arg);
+}
+#else
+static CYTHON_INLINE PyObject* __Pyx_PyObject_CallOneArg(PyObject *func, PyObject *arg) {
+    PyObject *result;
+    PyObject *args = PyTuple_Pack(1, arg);
+    if (unlikely(!args)) return NULL;
+    result = __Pyx_PyObject_Call(func, args, NULL);
+    Py_DECREF(args);
+    return result;
+}
+#endif
+
+/* KeywordStringCheck */
+static int __Pyx_CheckKeywordStrings(
+    PyObject *kwdict,
+    const char* function_name,
+    int kw_allowed)
+{
+    PyObject* key = 0;
+    Py_ssize_t pos = 0;
+#if CYTHON_COMPILING_IN_PYPY
+    if (!kw_allowed && PyDict_Next(kwdict, &pos, &key, 0))
+        goto invalid_keyword;
+    return 1;
+#else
+    while (PyDict_Next(kwdict, &pos, &key, 0)) {
+        #if PY_MAJOR_VERSION < 3
+        if (unlikely(!PyString_Check(key)))
+        #endif
+            if (unlikely(!PyUnicode_Check(key)))
+                goto invalid_keyword_type;
+    }
+    if ((!kw_allowed) && unlikely(key))
+        goto invalid_keyword;
+    return 1;
+invalid_keyword_type:
+    PyErr_Format(PyExc_TypeError,
+        "%.200s() keywords must be strings", function_name);
+    return 0;
+#endif
+invalid_keyword:
+    PyErr_Format(PyExc_TypeError,
+    #if PY_MAJOR_VERSION < 3
+        "%.200s() got an unexpected keyword argument '%.200s'",
+        function_name, PyString_AsString(key));
+    #else
+        "%s() got an unexpected keyword argument '%U'",
+        function_name, key);
+    #endif
+    return 0;
+}
+
+/* PyDictVersioning */
+#if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_TYPE_SLOTS
+static CYTHON_INLINE PY_UINT64_T __Pyx_get_tp_dict_version(PyObject *obj) {
+    PyObject *dict = Py_TYPE(obj)->tp_dict;
+    return likely(dict) ? __PYX_GET_DICT_VERSION(dict) : 0;
+}
+static CYTHON_INLINE PY_UINT64_T __Pyx_get_object_dict_version(PyObject *obj) {
+    PyObject **dictptr = NULL;
+    Py_ssize_t offset = Py_TYPE(obj)->tp_dictoffset;
+    if (offset) {
+#if CYTHON_COMPILING_IN_CPYTHON
+        dictptr = (likely(offset > 0)) ? (PyObject **) ((char *)obj + offset) : _PyObject_GetDictPtr(obj);
+#else
+        dictptr = _PyObject_GetDictPtr(obj);
+#endif
+    }
+    return (dictptr && *dictptr) ? __PYX_GET_DICT_VERSION(*dictptr) : 0;
+}
+static CYTHON_INLINE int __Pyx_object_dict_version_matches(PyObject* obj, PY_UINT64_T tp_dict_version, PY_UINT64_T obj_dict_version) {
+    PyObject *dict = Py_TYPE(obj)->tp_dict;
+    if (unlikely(!dict) || unlikely(tp_dict_version != __PYX_GET_DICT_VERSION(dict)))
+        return 0;
+    return obj_dict_version == __Pyx_get_object_dict_version(obj);
+}
+#endif
+
+/* GetModuleGlobalName */
+#if CYTHON_USE_DICT_VERSIONS
+static PyObject *__Pyx__GetModuleGlobalName(PyObject *name, PY_UINT64_T *dict_version, PyObject **dict_cached_value)
+#else
+static CYTHON_INLINE PyObject *__Pyx__GetModuleGlobalName(PyObject *name)
+#endif
+{
+    PyObject *result;
+#if !CYTHON_AVOID_BORROWED_REFS
+#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX >= 0x030500A1
+    result = _PyDict_GetItem_KnownHash(__pyx_d, name, ((PyASCIIObject *) name)->hash);
+    __PYX_UPDATE_DICT_CACHE(__pyx_d, result, *dict_cached_value, *dict_version)
+    if (likely(result)) {
+        return __Pyx_NewRef(result);
+    } else if (unlikely(PyErr_Occurred())) {
+        return NULL;
+    }
+#else
+    result = PyDict_GetItem(__pyx_d, name);
+    __PYX_UPDATE_DICT_CACHE(__pyx_d, result, *dict_cached_value, *dict_version)
+    if (likely(result)) {
+        return __Pyx_NewRef(result);
+    }
+#endif
+#else
+    result = PyObject_GetItem(__pyx_d, name);
+    __PYX_UPDATE_DICT_CACHE(__pyx_d, result, *dict_cached_value, *dict_version)
+    if (likely(result)) {
+        return __Pyx_NewRef(result);
+    }
+    PyErr_Clear();
+#endif
+    return __Pyx_GetBuiltinName(name);
+}
+
+/* PyObjectCallNoArg */
+#if CYTHON_COMPILING_IN_CPYTHON
+static CYTHON_INLINE PyObject* __Pyx_PyObject_CallNoArg(PyObject *func) {
+#if CYTHON_FAST_PYCALL
+    if (PyFunction_Check(func)) {
+        return __Pyx_PyFunction_FastCall(func, NULL, 0);
+    }
+#endif
+#ifdef __Pyx_CyFunction_USED
+    if (likely(PyCFunction_Check(func) || __Pyx_CyFunction_Check(func)))
+#else
+    if (likely(PyCFunction_Check(func)))
+#endif
+    {
+        if (likely(PyCFunction_GET_FLAGS(func) & METH_NOARGS)) {
+            return __Pyx_PyObject_CallMethO(func, NULL);
+        }
+    }
+    return __Pyx_PyObject_Call(func, __pyx_empty_tuple, NULL);
+}
+#endif
+
+/* RaiseTooManyValuesToUnpack */
+static CYTHON_INLINE void __Pyx_RaiseTooManyValuesError(Py_ssize_t expected) {
+    PyErr_Format(PyExc_ValueError,
+                 "too many values to unpack (expected %" CYTHON_FORMAT_SSIZE_T "d)", expected);
+}
+
+/* RaiseNeedMoreValuesToUnpack */
+static CYTHON_INLINE void __Pyx_RaiseNeedMoreValuesError(Py_ssize_t index) {
+    PyErr_Format(PyExc_ValueError,
+                 "need more than %" CYTHON_FORMAT_SSIZE_T "d value%.1s to unpack",
+                 index, (index == 1) ? "" : "s");
+}
+
+/* IterFinish */
+static CYTHON_INLINE int __Pyx_IterFinish(void) {
+#if CYTHON_FAST_THREAD_STATE
+    PyThreadState *tstate = __Pyx_PyThreadState_Current;
+    PyObject* exc_type = tstate->curexc_type;
+    if (unlikely(exc_type)) {
+        if (likely(__Pyx_PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) {
+            PyObject *exc_value, *exc_tb;
+            exc_value = tstate->curexc_value;
+            exc_tb = tstate->curexc_traceback;
+            tstate->curexc_type = 0;
+            tstate->curexc_value = 0;
+            tstate->curexc_traceback = 0;
+            Py_DECREF(exc_type);
+            Py_XDECREF(exc_value);
+            Py_XDECREF(exc_tb);
+            return 0;
+        } else {
+            return -1;
+        }
+    }
+    return 0;
+#else
+    if (unlikely(PyErr_Occurred())) {
+        if (likely(PyErr_ExceptionMatches(PyExc_StopIteration))) {
+            PyErr_Clear();
+            return 0;
+        } else {
+            return -1;
+        }
+    }
+    return 0;
+#endif
+}
+
+/* UnpackItemEndCheck */
+static int __Pyx_IternextUnpackEndCheck(PyObject *retval, Py_ssize_t expected) {
+    if (unlikely(retval)) {
+        Py_DECREF(retval);
+        __Pyx_RaiseTooManyValuesError(expected);
+        return -1;
+    } else {
+        return __Pyx_IterFinish();
+    }
+    return 0;
+}
+
+/* UnpackUnboundCMethod */
+static int __Pyx_TryUnpackUnboundCMethod(__Pyx_CachedCFunction* target) {
+    PyObject *method;
+    method = __Pyx_PyObject_GetAttrStr(target->type, *target->method_name);
+    if (unlikely(!method))
+        return -1;
+    target->method = method;
+#if CYTHON_COMPILING_IN_CPYTHON
+    #if PY_MAJOR_VERSION >= 3
+    if (likely(__Pyx_TypeCheck(method, &PyMethodDescr_Type)))
+    #endif
+    {
+        PyMethodDescrObject *descr = (PyMethodDescrObject*) method;
+        target->func = descr->d_method->ml_meth;
+        target->flag = descr->d_method->ml_flags & ~(METH_CLASS | METH_STATIC | METH_COEXIST | METH_STACKLESS);
+    }
+#endif
+    return 0;
+}
+
+/* CallUnboundCMethod0 */
+static PyObject* __Pyx__CallUnboundCMethod0(__Pyx_CachedCFunction* cfunc, PyObject* self) {
+    PyObject *args, *result = NULL;
+    if (unlikely(!cfunc->method) && unlikely(__Pyx_TryUnpackUnboundCMethod(cfunc) < 0)) return NULL;
+#if CYTHON_ASSUME_SAFE_MACROS
+    args = PyTuple_New(1);
+    if (unlikely(!args)) goto bad;
+    Py_INCREF(self);
+    PyTuple_SET_ITEM(args, 0, self);
+#else
+    args = PyTuple_Pack(1, self);
+    if (unlikely(!args)) goto bad;
+#endif
+    result = __Pyx_PyObject_Call(cfunc->method, args, NULL);
+    Py_DECREF(args);
+bad:
+    return result;
+}
+
+/* GetItemInt */
+static PyObject *__Pyx_GetItemInt_Generic(PyObject *o, PyObject* j) {
+    PyObject *r;
+    if (!j) return NULL;
+    r = PyObject_GetItem(o, j);
+    Py_DECREF(j);
+    return r;
+}
+static CYTHON_INLINE PyObject *__Pyx_GetItemInt_List_Fast(PyObject *o, Py_ssize_t i,
+                                                              CYTHON_NCP_UNUSED int wraparound,
+                                                              CYTHON_NCP_UNUSED int boundscheck) {
+#if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
+    Py_ssize_t wrapped_i = i;
+    if (wraparound & unlikely(i < 0)) {
+        wrapped_i += PyList_GET_SIZE(o);
+    }
+    if ((!boundscheck) || likely(__Pyx_is_valid_index(wrapped_i, PyList_GET_SIZE(o)))) {
+        PyObject *r = PyList_GET_ITEM(o, wrapped_i);
+        Py_INCREF(r);
+        return r;
+    }
+    return __Pyx_GetItemInt_Generic(o, PyInt_FromSsize_t(i));
+#else
+    return PySequence_GetItem(o, i);
+#endif
+}
+static CYTHON_INLINE PyObject *__Pyx_GetItemInt_Tuple_Fast(PyObject *o, Py_ssize_t i,
+                                                              CYTHON_NCP_UNUSED int wraparound,
+                                                              CYTHON_NCP_UNUSED int boundscheck) {
+#if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
+    Py_ssize_t wrapped_i = i;
+    if (wraparound & unlikely(i < 0)) {
+        wrapped_i += PyTuple_GET_SIZE(o);
+    }
+    if ((!boundscheck) || likely(__Pyx_is_valid_index(wrapped_i, PyTuple_GET_SIZE(o)))) {
+        PyObject *r = PyTuple_GET_ITEM(o, wrapped_i);
+        Py_INCREF(r);
+        return r;
+    }
+    return __Pyx_GetItemInt_Generic(o, PyInt_FromSsize_t(i));
+#else
+    return PySequence_GetItem(o, i);
+#endif
+}
+static CYTHON_INLINE PyObject *__Pyx_GetItemInt_Fast(PyObject *o, Py_ssize_t i, int is_list,
+                                                     CYTHON_NCP_UNUSED int wraparound,
+                                                     CYTHON_NCP_UNUSED int boundscheck) {
+#if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS && CYTHON_USE_TYPE_SLOTS
+    if (is_list || PyList_CheckExact(o)) {
+        Py_ssize_t n = ((!wraparound) | likely(i >= 0)) ? i : i + PyList_GET_SIZE(o);
+        if ((!boundscheck) || (likely(__Pyx_is_valid_index(n, PyList_GET_SIZE(o))))) {
+            PyObject *r = PyList_GET_ITEM(o, n);
+            Py_INCREF(r);
+            return r;
+        }
+    }
+    else if (PyTuple_CheckExact(o)) {
+        Py_ssize_t n = ((!wraparound) | likely(i >= 0)) ? i : i + PyTuple_GET_SIZE(o);
+        if ((!boundscheck) || likely(__Pyx_is_valid_index(n, PyTuple_GET_SIZE(o)))) {
+            PyObject *r = PyTuple_GET_ITEM(o, n);
+            Py_INCREF(r);
+            return r;
+        }
+    } else {
+        PySequenceMethods *m = Py_TYPE(o)->tp_as_sequence;
+        if (likely(m && m->sq_item)) {
+            if (wraparound && unlikely(i < 0) && likely(m->sq_length)) {
+                Py_ssize_t l = m->sq_length(o);
+                if (likely(l >= 0)) {
+                    i += l;
+                } else {
+                    if (!PyErr_ExceptionMatches(PyExc_OverflowError))
+                        return NULL;
+                    PyErr_Clear();
+                }
+            }
+            return m->sq_item(o, i);
+        }
+    }
+#else
+    if (is_list || PySequence_Check(o)) {
+        return PySequence_GetItem(o, i);
+    }
+#endif
+    return __Pyx_GetItemInt_Generic(o, PyInt_FromSsize_t(i));
+}
+
+/* ObjectGetItem */
+#if CYTHON_USE_TYPE_SLOTS
+static PyObject *__Pyx_PyObject_GetIndex(PyObject *obj, PyObject* index) {
+    PyObject *runerr;
+    Py_ssize_t key_value;
+    PySequenceMethods *m = Py_TYPE(obj)->tp_as_sequence;
+    if (unlikely(!(m && m->sq_item))) {
+        PyErr_Format(PyExc_TypeError, "'%.200s' object is not subscriptable", Py_TYPE(obj)->tp_name);
+        return NULL;
+    }
+    key_value = __Pyx_PyIndex_AsSsize_t(index);
+    if (likely(key_value != -1 || !(runerr = PyErr_Occurred()))) {
+        return __Pyx_GetItemInt_Fast(obj, key_value, 0, 1, 1);
+    }
+    if (PyErr_GivenExceptionMatches(runerr, PyExc_OverflowError)) {
+        PyErr_Clear();
+        PyErr_Format(PyExc_IndexError, "cannot fit '%.200s' into an index-sized integer", Py_TYPE(index)->tp_name);
+    }
+    return NULL;
+}
+static PyObject *__Pyx_PyObject_GetItem(PyObject *obj, PyObject* key) {
+    PyMappingMethods *m = Py_TYPE(obj)->tp_as_mapping;
+    if (likely(m && m->mp_subscript)) {
+        return m->mp_subscript(obj, key);
+    }
+    return __Pyx_PyObject_GetIndex(obj, key);
+}
+#endif
+
+/* GetTopmostException */
+#if CYTHON_USE_EXC_INFO_STACK
+static _PyErr_StackItem *
+__Pyx_PyErr_GetTopmostException(PyThreadState *tstate)
+{
+    _PyErr_StackItem *exc_info = tstate->exc_info;
+    while ((exc_info->exc_type == NULL || exc_info->exc_type == Py_None) &&
+           exc_info->previous_item != NULL)
+    {
+        exc_info = exc_info->previous_item;
+    }
+    return exc_info;
+}
+#endif
+
+/* SaveResetException */
+#if CYTHON_FAST_THREAD_STATE
+static CYTHON_INLINE void __Pyx__ExceptionSave(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb) {
+    #if CYTHON_USE_EXC_INFO_STACK
+    _PyErr_StackItem *exc_info = __Pyx_PyErr_GetTopmostException(tstate);
+    *type = exc_info->exc_type;
+    *value = exc_info->exc_value;
+    *tb = exc_info->exc_traceback;
+    #else
+    *type = tstate->exc_type;
+    *value = tstate->exc_value;
+    *tb = tstate->exc_traceback;
+    #endif
+    Py_XINCREF(*type);
+    Py_XINCREF(*value);
+    Py_XINCREF(*tb);
+}
+static CYTHON_INLINE void __Pyx__ExceptionReset(PyThreadState *tstate, PyObject *type, PyObject *value, PyObject *tb) {
+    PyObject *tmp_type, *tmp_value, *tmp_tb;
+    #if CYTHON_USE_EXC_INFO_STACK
+    _PyErr_StackItem *exc_info = tstate->exc_info;
+    tmp_type = exc_info->exc_type;
+    tmp_value = exc_info->exc_value;
+    tmp_tb = exc_info->exc_traceback;
+    exc_info->exc_type = type;
+    exc_info->exc_value = value;
+    exc_info->exc_traceback = tb;
+    #else
+    tmp_type = tstate->exc_type;
+    tmp_value = tstate->exc_value;
+    tmp_tb = tstate->exc_traceback;
+    tstate->exc_type = type;
+    tstate->exc_value = value;
+    tstate->exc_traceback = tb;
+    #endif
+    Py_XDECREF(tmp_type);
+    Py_XDECREF(tmp_value);
+    Py_XDECREF(tmp_tb);
+}
+#endif
+
+/* GetException */
+#if CYTHON_FAST_THREAD_STATE
+static int __Pyx__GetException(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb)
+#else
+static int __Pyx_GetException(PyObject **type, PyObject **value, PyObject **tb)
+#endif
+{
+    PyObject *local_type, *local_value, *local_tb;
+#if CYTHON_FAST_THREAD_STATE
+    PyObject *tmp_type, *tmp_value, *tmp_tb;
+    local_type = tstate->curexc_type;
+    local_value = tstate->curexc_value;
+    local_tb = tstate->curexc_traceback;
+    tstate->curexc_type = 0;
+    tstate->curexc_value = 0;
+    tstate->curexc_traceback = 0;
+#else
+    PyErr_Fetch(&local_type, &local_value, &local_tb);
+#endif
+    PyErr_NormalizeException(&local_type, &local_value, &local_tb);
+#if CYTHON_FAST_THREAD_STATE
+    if (unlikely(tstate->curexc_type))
+#else
+    if (unlikely(PyErr_Occurred()))
+#endif
+        goto bad;
+    #if PY_MAJOR_VERSION >= 3
+    if (local_tb) {
+        if (unlikely(PyException_SetTraceback(local_value, local_tb) < 0))
+            goto bad;
+    }
+    #endif
+    Py_XINCREF(local_tb);
+    Py_XINCREF(local_type);
+    Py_XINCREF(local_value);
+    *type = local_type;
+    *value = local_value;
+    *tb = local_tb;
+#if CYTHON_FAST_THREAD_STATE
+    #if CYTHON_USE_EXC_INFO_STACK
+    {
+        _PyErr_StackItem *exc_info = tstate->exc_info;
+        tmp_type = exc_info->exc_type;
+        tmp_value = exc_info->exc_value;
+        tmp_tb = exc_info->exc_traceback;
+        exc_info->exc_type = local_type;
+        exc_info->exc_value = local_value;
+        exc_info->exc_traceback = local_tb;
+    }
+    #else
+    tmp_type = tstate->exc_type;
+    tmp_value = tstate->exc_value;
+    tmp_tb = tstate->exc_traceback;
+    tstate->exc_type = local_type;
+    tstate->exc_value = local_value;
+    tstate->exc_traceback = local_tb;
+    #endif
+    Py_XDECREF(tmp_type);
+    Py_XDECREF(tmp_value);
+    Py_XDECREF(tmp_tb);
+#else
+    PyErr_SetExcInfo(local_type, local_value, local_tb);
+#endif
+    return 0;
+bad:
+    *type = 0;
+    *value = 0;
+    *tb = 0;
+    Py_XDECREF(local_type);
+    Py_XDECREF(local_value);
+    Py_XDECREF(local_tb);
+    return -1;
+}
+
+/* PyErrFetchRestore */
+#if CYTHON_FAST_THREAD_STATE
+static CYTHON_INLINE void __Pyx_ErrRestoreInState(PyThreadState *tstate, PyObject *type, PyObject *value, PyObject *tb) {
+    PyObject *tmp_type, *tmp_value, *tmp_tb;
+    tmp_type = tstate->curexc_type;
+    tmp_value = tstate->curexc_value;
+    tmp_tb = tstate->curexc_traceback;
+    tstate->curexc_type = type;
+    tstate->curexc_value = value;
+    tstate->curexc_traceback = tb;
+    Py_XDECREF(tmp_type);
+    Py_XDECREF(tmp_value);
+    Py_XDECREF(tmp_tb);
+}
+static CYTHON_INLINE void __Pyx_ErrFetchInState(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb) {
+    *type = tstate->curexc_type;
+    *value = tstate->curexc_value;
+    *tb = tstate->curexc_traceback;
+    tstate->curexc_type = 0;
+    tstate->curexc_value = 0;
+    tstate->curexc_traceback = 0;
+}
+#endif
+
+/* RaiseException */
+#if PY_MAJOR_VERSION < 3
+static void __Pyx_Raise(PyObject *type, PyObject *value, PyObject *tb,
+                        CYTHON_UNUSED PyObject *cause) {
+    __Pyx_PyThreadState_declare
+    Py_XINCREF(type);
+    if (!value || value == Py_None)
+        value = NULL;
+    else
+        Py_INCREF(value);
+    if (!tb || tb == Py_None)
+        tb = NULL;
+    else {
+        Py_INCREF(tb);
+        if (!PyTraceBack_Check(tb)) {
+            PyErr_SetString(PyExc_TypeError,
+                "raise: arg 3 must be a traceback or None");
+            goto raise_error;
+        }
+    }
+    if (PyType_Check(type)) {
+#if CYTHON_COMPILING_IN_PYPY
+        if (!value) {
+            Py_INCREF(Py_None);
+            value = Py_None;
+        }
+#endif
+        PyErr_NormalizeException(&type, &value, &tb);
+    } else {
+        if (value) {
+            PyErr_SetString(PyExc_TypeError,
+                "instance exception may not have a separate value");
+            goto raise_error;
+        }
+        value = type;
+        type = (PyObject*) Py_TYPE(type);
+        Py_INCREF(type);
+        if (!PyType_IsSubtype((PyTypeObject *)type, (PyTypeObject *)PyExc_BaseException)) {
+            PyErr_SetString(PyExc_TypeError,
+                "raise: exception class must be a subclass of BaseException");
+            goto raise_error;
+        }
+    }
+    __Pyx_PyThreadState_assign
+    __Pyx_ErrRestore(type, value, tb);
+    return;
+raise_error:
+    Py_XDECREF(value);
+    Py_XDECREF(type);
+    Py_XDECREF(tb);
+    return;
+}
+#else
+static void __Pyx_Raise(PyObject *type, PyObject *value, PyObject *tb, PyObject *cause) {
+    PyObject* owned_instance = NULL;
+    if (tb == Py_None) {
+        tb = 0;
+    } else if (tb && !PyTraceBack_Check(tb)) {
+        PyErr_SetString(PyExc_TypeError,
+            "raise: arg 3 must be a traceback or None");
+        goto bad;
+    }
+    if (value == Py_None)
+        value = 0;
+    if (PyExceptionInstance_Check(type)) {
+        if (value) {
+            PyErr_SetString(PyExc_TypeError,
+                "instance exception may not have a separate value");
+            goto bad;
+        }
+        value = type;
+        type = (PyObject*) Py_TYPE(value);
+    } else if (PyExceptionClass_Check(type)) {
+        PyObject *instance_class = NULL;
+        if (value && PyExceptionInstance_Check(value)) {
+            instance_class = (PyObject*) Py_TYPE(value);
+            if (instance_class != type) {
+                int is_subclass = PyObject_IsSubclass(instance_class, type);
+                if (!is_subclass) {
+                    instance_class = NULL;
+                } else if (unlikely(is_subclass == -1)) {
+                    goto bad;
+                } else {
+                    type = instance_class;
+                }
+            }
+        }
+        if (!instance_class) {
+            PyObject *args;
+            if (!value)
+                args = PyTuple_New(0);
+            else if (PyTuple_Check(value)) {
+                Py_INCREF(value);
+                args = value;
+            } else
+                args = PyTuple_Pack(1, value);
+            if (!args)
+                goto bad;
+            owned_instance = PyObject_Call(type, args, NULL);
+            Py_DECREF(args);
+            if (!owned_instance)
+                goto bad;
+            value = owned_instance;
+            if (!PyExceptionInstance_Check(value)) {
+                PyErr_Format(PyExc_TypeError,
+                             "calling %R should have returned an instance of "
+                             "BaseException, not %R",
+                             type, Py_TYPE(value));
+                goto bad;
+            }
+        }
+    } else {
+        PyErr_SetString(PyExc_TypeError,
+            "raise: exception class must be a subclass of BaseException");
+        goto bad;
+    }
+    if (cause) {
+        PyObject *fixed_cause;
+        if (cause == Py_None) {
+            fixed_cause = NULL;
+        } else if (PyExceptionClass_Check(cause)) {
+            fixed_cause = PyObject_CallObject(cause, NULL);
+            if (fixed_cause == NULL)
+                goto bad;
+        } else if (PyExceptionInstance_Check(cause)) {
+            fixed_cause = cause;
+            Py_INCREF(fixed_cause);
+        } else {
+            PyErr_SetString(PyExc_TypeError,
+                            "exception causes must derive from "
+                            "BaseException");
+            goto bad;
+        }
+        PyException_SetCause(value, fixed_cause);
+    }
+    PyErr_SetObject(type, value);
+    if (tb) {
+#if CYTHON_COMPILING_IN_PYPY
+        PyObject *tmp_type, *tmp_value, *tmp_tb;
+        PyErr_Fetch(&tmp_type, &tmp_value, &tmp_tb);
+        Py_INCREF(tb);
+        PyErr_Restore(tmp_type, tmp_value, tb);
+        Py_XDECREF(tmp_tb);
+#else
+        PyThreadState *tstate = __Pyx_PyThreadState_Current;
+        PyObject* tmp_tb = tstate->curexc_traceback;
+        if (tb != tmp_tb) {
+            Py_INCREF(tb);
+            tstate->curexc_traceback = tb;
+            Py_XDECREF(tmp_tb);
+        }
+#endif
+    }
+bad:
+    Py_XDECREF(owned_instance);
+    return;
+}
+#endif
+
+/* DictGetItem */
+#if PY_MAJOR_VERSION >= 3 && !CYTHON_COMPILING_IN_PYPY
+static PyObject *__Pyx_PyDict_GetItem(PyObject *d, PyObject* key) {
+    PyObject *value;
+    value = PyDict_GetItemWithError(d, key);
+    if (unlikely(!value)) {
+        if (!PyErr_Occurred()) {
+            if (unlikely(PyTuple_Check(key))) {
+                PyObject* args = PyTuple_Pack(1, key);
+                if (likely(args)) {
+                    PyErr_SetObject(PyExc_KeyError, args);
+                    Py_DECREF(args);
+                }
+            } else {
+                PyErr_SetObject(PyExc_KeyError, key);
+            }
+        }
+        return NULL;
+    }
+    Py_INCREF(value);
+    return value;
+}
+#endif
+
+/* BytesEquals */
+static CYTHON_INLINE int __Pyx_PyBytes_Equals(PyObject* s1, PyObject* s2, int equals) {
+#if CYTHON_COMPILING_IN_PYPY
+    return PyObject_RichCompareBool(s1, s2, equals);
+#else
+    if (s1 == s2) {
+        return (equals == Py_EQ);
+    } else if (PyBytes_CheckExact(s1) & PyBytes_CheckExact(s2)) {
+        const char *ps1, *ps2;
+        Py_ssize_t length = PyBytes_GET_SIZE(s1);
+        if (length != PyBytes_GET_SIZE(s2))
+            return (equals == Py_NE);
+        ps1 = PyBytes_AS_STRING(s1);
+        ps2 = PyBytes_AS_STRING(s2);
+        if (ps1[0] != ps2[0]) {
+            return (equals == Py_NE);
+        } else if (length == 1) {
+            return (equals == Py_EQ);
+        } else {
+            int result;
+#if CYTHON_USE_UNICODE_INTERNALS && (PY_VERSION_HEX < 0x030B0000)
+            Py_hash_t hash1, hash2;
+            hash1 = ((PyBytesObject*)s1)->ob_shash;
+            hash2 = ((PyBytesObject*)s2)->ob_shash;
+            if (hash1 != hash2 && hash1 != -1 && hash2 != -1) {
+                return (equals == Py_NE);
+            }
+#endif
+            result = memcmp(ps1, ps2, (size_t)length);
+            return (equals == Py_EQ) ? (result == 0) : (result != 0);
+        }
+    } else if ((s1 == Py_None) & PyBytes_CheckExact(s2)) {
+        return (equals == Py_NE);
+    } else if ((s2 == Py_None) & PyBytes_CheckExact(s1)) {
+        return (equals == Py_NE);
+    } else {
+        int result;
+        PyObject* py_result = PyObject_RichCompare(s1, s2, equals);
+        if (!py_result)
+            return -1;
+        result = __Pyx_PyObject_IsTrue(py_result);
+        Py_DECREF(py_result);
+        return result;
+    }
+#endif
+}
+
+/* JoinPyUnicode */
+static PyObject* __Pyx_PyUnicode_Join(PyObject* value_tuple, Py_ssize_t value_count, Py_ssize_t result_ulength,
+                                      CYTHON_UNUSED Py_UCS4 max_char) {
+#if CYTHON_USE_UNICODE_INTERNALS && CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
+    PyObject *result_uval;
+    int result_ukind;
+    Py_ssize_t i, char_pos;
+    void *result_udata;
+#if CYTHON_PEP393_ENABLED
+    result_uval = PyUnicode_New(result_ulength, max_char);
+    if (unlikely(!result_uval)) return NULL;
+    result_ukind = (max_char <= 255) ? PyUnicode_1BYTE_KIND : (max_char <= 65535) ? PyUnicode_2BYTE_KIND : PyUnicode_4BYTE_KIND;
+    result_udata = PyUnicode_DATA(result_uval);
+#else
+    result_uval = PyUnicode_FromUnicode(NULL, result_ulength);
+    if (unlikely(!result_uval)) return NULL;
+    result_ukind = sizeof(Py_UNICODE);
+    result_udata = PyUnicode_AS_UNICODE(result_uval);
+#endif
+    char_pos = 0;
+    for (i=0; i < value_count; i++) {
+        int ukind;
+        Py_ssize_t ulength;
+        void *udata;
+        PyObject *uval = PyTuple_GET_ITEM(value_tuple, i);
+        if (unlikely(__Pyx_PyUnicode_READY(uval)))
+            goto bad;
+        ulength = __Pyx_PyUnicode_GET_LENGTH(uval);
+        if (unlikely(!ulength))
+            continue;
+        if (unlikely(char_pos + ulength < 0))
+            goto overflow;
+        ukind = __Pyx_PyUnicode_KIND(uval);
+        udata = __Pyx_PyUnicode_DATA(uval);
+        if (!CYTHON_PEP393_ENABLED || ukind == result_ukind) {
+            memcpy((char *)result_udata + char_pos * result_ukind, udata, (size_t) (ulength * result_ukind));
+        } else {
+            #if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX >= 0x030300F0 || defined(_PyUnicode_FastCopyCharacters)
+            _PyUnicode_FastCopyCharacters(result_uval, char_pos, uval, 0, ulength);
+            #else
+            Py_ssize_t j;
+            for (j=0; j < ulength; j++) {
+                Py_UCS4 uchar = __Pyx_PyUnicode_READ(ukind, udata, j);
+                __Pyx_PyUnicode_WRITE(result_ukind, result_udata, char_pos+j, uchar);
+            }
+            #endif
+        }
+        char_pos += ulength;
+    }
+    return result_uval;
+overflow:
+    PyErr_SetString(PyExc_OverflowError, "join() result is too long for a Python string");
+bad:
+    Py_DECREF(result_uval);
+    return NULL;
+#else
+    result_ulength++;
+    value_count++;
+    return PyUnicode_Join(__pyx_empty_unicode, value_tuple);
+#endif
+}
+
+/* decode_c_bytes */
+static CYTHON_INLINE PyObject* __Pyx_decode_c_bytes(
+         const char* cstring, Py_ssize_t length, Py_ssize_t start, Py_ssize_t stop,
+         const char* encoding, const char* errors,
+         PyObject* (*decode_func)(const char *s, Py_ssize_t size, const char *errors)) {
+    if (unlikely((start < 0) | (stop < 0))) {
+        if (start < 0) {
+            start += length;
+            if (start < 0)
+                start = 0;
+        }
+        if (stop < 0)
+            stop += length;
+    }
+    if (stop > length)
+        stop = length;
+    if (unlikely(stop <= start))
+        return __Pyx_NewRef(__pyx_empty_unicode);
+    length = stop - start;
+    cstring += start;
+    if (decode_func) {
+        return decode_func(cstring, length, errors);
+    } else {
+        return PyUnicode_Decode(cstring, length, encoding, errors);
+    }
+}
+
+/* CIntToDigits */
+static const char DIGIT_PAIRS_10[2*10*10+1] = {
+    "00010203040506070809"
+    "10111213141516171819"
+    "20212223242526272829"
+    "30313233343536373839"
+    "40414243444546474849"
+    "50515253545556575859"
+    "60616263646566676869"
+    "70717273747576777879"
+    "80818283848586878889"
+    "90919293949596979899"
+};
+static const char DIGIT_PAIRS_8[2*8*8+1] = {
+    "0001020304050607"
+    "1011121314151617"
+    "2021222324252627"
+    "3031323334353637"
+    "4041424344454647"
+    "5051525354555657"
+    "6061626364656667"
+    "7071727374757677"
+};
+static const char DIGITS_HEX[2*16+1] = {
+    "0123456789abcdef"
+    "0123456789ABCDEF"
+};
+
+/* BuildPyUnicode */
+static PyObject* __Pyx_PyUnicode_BuildFromAscii(Py_ssize_t ulength, char* chars, int clength,
+                                                int prepend_sign, char padding_char) {
+    PyObject *uval;
+    Py_ssize_t uoffset = ulength - clength;
+#if CYTHON_USE_UNICODE_INTERNALS
+    Py_ssize_t i;
+#if CYTHON_PEP393_ENABLED
+    void *udata;
+    uval = PyUnicode_New(ulength, 127);
+    if (unlikely(!uval)) return NULL;
+    udata = PyUnicode_DATA(uval);
+#else
+    Py_UNICODE *udata;
+    uval = PyUnicode_FromUnicode(NULL, ulength);
+    if (unlikely(!uval)) return NULL;
+    udata = PyUnicode_AS_UNICODE(uval);
+#endif
+    if (uoffset > 0) {
+        i = 0;
+        if (prepend_sign) {
+            __Pyx_PyUnicode_WRITE(PyUnicode_1BYTE_KIND, udata, 0, '-');
+            i++;
+        }
+        for (; i < uoffset; i++) {
+            __Pyx_PyUnicode_WRITE(PyUnicode_1BYTE_KIND, udata, i, padding_char);
+        }
+    }
+    for (i=0; i < clength; i++) {
+        __Pyx_PyUnicode_WRITE(PyUnicode_1BYTE_KIND, udata, uoffset+i, chars[i]);
+    }
+#else
+    {
+        PyObject *sign = NULL, *padding = NULL;
+        uval = NULL;
+        if (uoffset > 0) {
+            prepend_sign = !!prepend_sign;
+            if (uoffset > prepend_sign) {
+                padding = PyUnicode_FromOrdinal(padding_char);
+                if (likely(padding) && uoffset > prepend_sign + 1) {
+                    PyObject *tmp;
+                    PyObject *repeat = PyInt_FromSsize_t(uoffset - prepend_sign);
+                    if (unlikely(!repeat)) goto done_or_error;
+                    tmp = PyNumber_Multiply(padding, repeat);
+                    Py_DECREF(repeat);
+                    Py_DECREF(padding);
+                    padding = tmp;
+                }
+                if (unlikely(!padding)) goto done_or_error;
+            }
+            if (prepend_sign) {
+                sign = PyUnicode_FromOrdinal('-');
+                if (unlikely(!sign)) goto done_or_error;
+            }
+        }
+        uval = PyUnicode_DecodeASCII(chars, clength, NULL);
+        if (likely(uval) && padding) {
+            PyObject *tmp = PyNumber_Add(padding, uval);
+            Py_DECREF(uval);
+            uval = tmp;
+        }
+        if (likely(uval) && sign) {
+            PyObject *tmp = PyNumber_Add(sign, uval);
+            Py_DECREF(uval);
+            uval = tmp;
+        }
+done_or_error:
+        Py_XDECREF(padding);
+        Py_XDECREF(sign);
+    }
+#endif
+    return uval;
+}
+
+/* CIntToPyUnicode */
+static CYTHON_INLINE PyObject* __Pyx_PyUnicode_From_Py_ssize_t(Py_ssize_t value, Py_ssize_t width, char padding_char, char format_char) {
+    char digits[sizeof(Py_ssize_t)*3+2];
+    char *dpos, *end = digits + sizeof(Py_ssize_t)*3+2;
+    const char *hex_digits = DIGITS_HEX;
+    Py_ssize_t length, ulength;
+    int prepend_sign, last_one_off;
+    Py_ssize_t remaining;
+#ifdef __Pyx_HAS_GCC_DIAGNOSTIC
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wconversion"
+#endif
+    const Py_ssize_t neg_one = (Py_ssize_t) -1, const_zero = (Py_ssize_t) 0;
+#ifdef __Pyx_HAS_GCC_DIAGNOSTIC
+#pragma GCC diagnostic pop
+#endif
+    const int is_unsigned = neg_one > const_zero;
+    if (format_char == 'X') {
+        hex_digits += 16;
+        format_char = 'x';
+    }
+    remaining = value;
+    last_one_off = 0;
+    dpos = end;
+    do {
+        int digit_pos;
+        switch (format_char) {
+        case 'o':
+            digit_pos = abs((int)(remaining % (8*8)));
+            remaining = (Py_ssize_t) (remaining / (8*8));
+            dpos -= 2;
+            memcpy(dpos, DIGIT_PAIRS_8 + digit_pos * 2, 2);
+            last_one_off = (digit_pos < 8);
+            break;
+        case 'd':
+            digit_pos = abs((int)(remaining % (10*10)));
+            remaining = (Py_ssize_t) (remaining / (10*10));
+            dpos -= 2;
+            memcpy(dpos, DIGIT_PAIRS_10 + digit_pos * 2, 2);
+            last_one_off = (digit_pos < 10);
+            break;
+        case 'x':
+            *(--dpos) = hex_digits[abs((int)(remaining % 16))];
+            remaining = (Py_ssize_t) (remaining / 16);
+            break;
+        default:
+            assert(0);
+            break;
+        }
+    } while (unlikely(remaining != 0));
+    if (last_one_off) {
+        assert(*dpos == '0');
+        dpos++;
+    }
+    length = end - dpos;
+    ulength = length;
+    prepend_sign = 0;
+    if (!is_unsigned && value <= neg_one) {
+        if (padding_char == ' ' || width <= length + 1) {
+            *(--dpos) = '-';
+            ++length;
+        } else {
+            prepend_sign = 1;
+        }
+        ++ulength;
+    }
+    if (width > ulength) {
+        ulength = width;
+    }
+    if (ulength == 1) {
+        return PyUnicode_FromOrdinal(*dpos);
+    }
+    return __Pyx_PyUnicode_BuildFromAscii(ulength, dpos, (int) length, prepend_sign, padding_char);
+}
+
+/* PyObject_GenericGetAttrNoDict */
+#if CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP && PY_VERSION_HEX < 0x03070000
+static PyObject *__Pyx_RaiseGenericGetAttributeError(PyTypeObject *tp, PyObject *attr_name) {
+    PyErr_Format(PyExc_AttributeError,
+#if PY_MAJOR_VERSION >= 3
+                 "'%.50s' object has no attribute '%U'",
+                 tp->tp_name, attr_name);
+#else
+                 "'%.50s' object has no attribute '%.400s'",
+                 tp->tp_name, PyString_AS_STRING(attr_name));
+#endif
+    return NULL;
+}
+static CYTHON_INLINE PyObject* __Pyx_PyObject_GenericGetAttrNoDict(PyObject* obj, PyObject* attr_name) {
+    PyObject *descr;
+    PyTypeObject *tp = Py_TYPE(obj);
+    if (unlikely(!PyString_Check(attr_name))) {
+        return PyObject_GenericGetAttr(obj, attr_name);
+    }
+    assert(!tp->tp_dictoffset);
+    descr = _PyType_Lookup(tp, attr_name);
+    if (unlikely(!descr)) {
+        return __Pyx_RaiseGenericGetAttributeError(tp, attr_name);
+    }
+    Py_INCREF(descr);
+    #if PY_MAJOR_VERSION < 3
+    if (likely(PyType_HasFeature(Py_TYPE(descr), Py_TPFLAGS_HAVE_CLASS)))
+    #endif
+    {
+        descrgetfunc f = Py_TYPE(descr)->tp_descr_get;
+        if (unlikely(f)) {
+            PyObject *res = f(descr, obj, (PyObject *)tp);
+            Py_DECREF(descr);
+            return res;
+        }
+    }
+    return descr;
+}
+#endif
+
+/* PyObject_GenericGetAttr */
+#if CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP && PY_VERSION_HEX < 0x03070000
+static PyObject* __Pyx_PyObject_GenericGetAttr(PyObject* obj, PyObject* attr_name) {
+    if (unlikely(Py_TYPE(obj)->tp_dictoffset)) {
+        return PyObject_GenericGetAttr(obj, attr_name);
+    }
+    return __Pyx_PyObject_GenericGetAttrNoDict(obj, attr_name);
+}
+#endif
+
+/* SetVTable */
+static int __Pyx_SetVtable(PyObject *dict, void *vtable) {
+#if PY_VERSION_HEX >= 0x02070000
+    PyObject *ob = PyCapsule_New(vtable, 0, 0);
+#else
+    PyObject *ob = PyCObject_FromVoidPtr(vtable, 0);
+#endif
+    if (!ob)
+        goto bad;
+    if (PyDict_SetItem(dict, __pyx_n_s_pyx_vtable, ob) < 0)
+        goto bad;
+    Py_DECREF(ob);
+    return 0;
+bad:
+    Py_XDECREF(ob);
+    return -1;
+}
+
+/* PyErrExceptionMatches */
+#if CYTHON_FAST_THREAD_STATE
+static int __Pyx_PyErr_ExceptionMatchesTuple(PyObject *exc_type, PyObject *tuple) {
+    Py_ssize_t i, n;
+    n = PyTuple_GET_SIZE(tuple);
+#if PY_MAJOR_VERSION >= 3
+    for (i=0; i<n; i++) {
+        if (exc_type == PyTuple_GET_ITEM(tuple, i)) return 1;
+    }
+#endif
+    for (i=0; i<n; i++) {
+        if (__Pyx_PyErr_GivenExceptionMatches(exc_type, PyTuple_GET_ITEM(tuple, i))) return 1;
+    }
+    return 0;
+}
+static CYTHON_INLINE int __Pyx_PyErr_ExceptionMatchesInState(PyThreadState* tstate, PyObject* err) {
+    PyObject *exc_type = tstate->curexc_type;
+    if (exc_type == err) return 1;
+    if (unlikely(!exc_type)) return 0;
+    if (unlikely(PyTuple_Check(err)))
+        return __Pyx_PyErr_ExceptionMatchesTuple(exc_type, err);
+    return __Pyx_PyErr_GivenExceptionMatches(exc_type, err);
+}
+#endif
+
+/* PyObjectGetAttrStrNoError */
+static void __Pyx_PyObject_GetAttrStr_ClearAttributeError(void) {
+    __Pyx_PyThreadState_declare
+    __Pyx_PyThreadState_assign
+    if (likely(__Pyx_PyErr_ExceptionMatches(PyExc_AttributeError)))
+        __Pyx_PyErr_Clear();
+}
+static CYTHON_INLINE PyObject* __Pyx_PyObject_GetAttrStrNoError(PyObject* obj, PyObject* attr_name) {
+    PyObject *result;
+#if CYTHON_COMPILING_IN_CPYTHON && CYTHON_USE_TYPE_SLOTS && PY_VERSION_HEX >= 0x030700B1
+    PyTypeObject* tp = Py_TYPE(obj);
+    if (likely(tp->tp_getattro == PyObject_GenericGetAttr)) {
+        return _PyObject_GenericGetAttrWithDict(obj, attr_name, NULL, 1);
+    }
+#endif
+    result = __Pyx_PyObject_GetAttrStr(obj, attr_name);
+    if (unlikely(!result)) {
+        __Pyx_PyObject_GetAttrStr_ClearAttributeError();
+    }
+    return result;
+}
+
+/* SetupReduce */
+static int __Pyx_setup_reduce_is_named(PyObject* meth, PyObject* name) {
+  int ret;
+  PyObject *name_attr;
+  name_attr = __Pyx_PyObject_GetAttrStr(meth, __pyx_n_s_name);
+  if (likely(name_attr)) {
+      ret = PyObject_RichCompareBool(name_attr, name, Py_EQ);
+  } else {
+      ret = -1;
+  }
+  if (unlikely(ret < 0)) {
+      PyErr_Clear();
+      ret = 0;
+  }
+  Py_XDECREF(name_attr);
+  return ret;
+}
+static int __Pyx_setup_reduce(PyObject* type_obj) {
+    int ret = 0;
+    PyObject *object_reduce = NULL;
+    PyObject *object_getstate = NULL;
+    PyObject *object_reduce_ex = NULL;
+    PyObject *reduce = NULL;
+    PyObject *reduce_ex = NULL;
+    PyObject *reduce_cython = NULL;
+    PyObject *setstate = NULL;
+    PyObject *setstate_cython = NULL;
+    PyObject *getstate = NULL;
+#if CYTHON_USE_PYTYPE_LOOKUP
+    getstate = _PyType_Lookup((PyTypeObject*)type_obj, __pyx_n_s_getstate);
+#else
+    getstate = __Pyx_PyObject_GetAttrStrNoError(type_obj, __pyx_n_s_getstate);
+    if (!getstate && PyErr_Occurred()) {
+        goto __PYX_BAD;
+    }
+#endif
+    if (getstate) {
+#if CYTHON_USE_PYTYPE_LOOKUP
+        object_getstate = _PyType_Lookup(&PyBaseObject_Type, __pyx_n_s_getstate);
+#else
+        object_getstate = __Pyx_PyObject_GetAttrStrNoError((PyObject*)&PyBaseObject_Type, __pyx_n_s_getstate);
+        if (!object_getstate && PyErr_Occurred()) {
+            goto __PYX_BAD;
+        }
+#endif
+        if (object_getstate != getstate) {
+            goto __PYX_GOOD;
+        }
+    }
+#if CYTHON_USE_PYTYPE_LOOKUP
+    object_reduce_ex = _PyType_Lookup(&PyBaseObject_Type, __pyx_n_s_reduce_ex); if (!object_reduce_ex) goto __PYX_BAD;
+#else
+    object_reduce_ex = __Pyx_PyObject_GetAttrStr((PyObject*)&PyBaseObject_Type, __pyx_n_s_reduce_ex); if (!object_reduce_ex) goto __PYX_BAD;
+#endif
+    reduce_ex = __Pyx_PyObject_GetAttrStr(type_obj, __pyx_n_s_reduce_ex); if (unlikely(!reduce_ex)) goto __PYX_BAD;
+    if (reduce_ex == object_reduce_ex) {
+#if CYTHON_USE_PYTYPE_LOOKUP
+        object_reduce = _PyType_Lookup(&PyBaseObject_Type, __pyx_n_s_reduce); if (!object_reduce) goto __PYX_BAD;
+#else
+        object_reduce = __Pyx_PyObject_GetAttrStr((PyObject*)&PyBaseObject_Type, __pyx_n_s_reduce); if (!object_reduce) goto __PYX_BAD;
+#endif
+        reduce = __Pyx_PyObject_GetAttrStr(type_obj, __pyx_n_s_reduce); if (unlikely(!reduce)) goto __PYX_BAD;
+        if (reduce == object_reduce || __Pyx_setup_reduce_is_named(reduce, __pyx_n_s_reduce_cython)) {
+            reduce_cython = __Pyx_PyObject_GetAttrStrNoError(type_obj, __pyx_n_s_reduce_cython);
+            if (likely(reduce_cython)) {
+                ret = PyDict_SetItem(((PyTypeObject*)type_obj)->tp_dict, __pyx_n_s_reduce, reduce_cython); if (unlikely(ret < 0)) goto __PYX_BAD;
+                ret = PyDict_DelItem(((PyTypeObject*)type_obj)->tp_dict, __pyx_n_s_reduce_cython); if (unlikely(ret < 0)) goto __PYX_BAD;
+            } else if (reduce == object_reduce || PyErr_Occurred()) {
+                goto __PYX_BAD;
+            }
+            setstate = __Pyx_PyObject_GetAttrStr(type_obj, __pyx_n_s_setstate);
+            if (!setstate) PyErr_Clear();
+            if (!setstate || __Pyx_setup_reduce_is_named(setstate, __pyx_n_s_setstate_cython)) {
+                setstate_cython = __Pyx_PyObject_GetAttrStrNoError(type_obj, __pyx_n_s_setstate_cython);
+                if (likely(setstate_cython)) {
+                    ret = PyDict_SetItem(((PyTypeObject*)type_obj)->tp_dict, __pyx_n_s_setstate, setstate_cython); if (unlikely(ret < 0)) goto __PYX_BAD;
+                    ret = PyDict_DelItem(((PyTypeObject*)type_obj)->tp_dict, __pyx_n_s_setstate_cython); if (unlikely(ret < 0)) goto __PYX_BAD;
+                } else if (!setstate || PyErr_Occurred()) {
+                    goto __PYX_BAD;
+                }
+            }
+            PyType_Modified((PyTypeObject*)type_obj);
+        }
+    }
+    goto __PYX_GOOD;
+__PYX_BAD:
+    if (!PyErr_Occurred())
+        PyErr_Format(PyExc_RuntimeError, "Unable to initialize pickling for %s", ((PyTypeObject*)type_obj)->tp_name);
+    ret = -1;
+__PYX_GOOD:
+#if !CYTHON_USE_PYTYPE_LOOKUP
+    Py_XDECREF(object_reduce);
+    Py_XDECREF(object_reduce_ex);
+    Py_XDECREF(object_getstate);
+    Py_XDECREF(getstate);
+#endif
+    Py_XDECREF(reduce);
+    Py_XDECREF(reduce_ex);
+    Py_XDECREF(reduce_cython);
+    Py_XDECREF(setstate);
+    Py_XDECREF(setstate_cython);
+    return ret;
+}
+
+/* Import */
+static PyObject *__Pyx_Import(PyObject *name, PyObject *from_list, int level) {
+    PyObject *empty_list = 0;
+    PyObject *module = 0;
+    PyObject *global_dict = 0;
+    PyObject *empty_dict = 0;
+    PyObject *list;
+    #if PY_MAJOR_VERSION < 3
+    PyObject *py_import;
+    py_import = __Pyx_PyObject_GetAttrStr(__pyx_b, __pyx_n_s_import);
+    if (!py_import)
+        goto bad;
+    #endif
+    if (from_list)
+        list = from_list;
+    else {
+        empty_list = PyList_New(0);
+        if (!empty_list)
+            goto bad;
+        list = empty_list;
+    }
+    global_dict = PyModule_GetDict(__pyx_m);
+    if (!global_dict)
+        goto bad;
+    empty_dict = PyDict_New();
+    if (!empty_dict)
+        goto bad;
+    {
+        #if PY_MAJOR_VERSION >= 3
+        if (level == -1) {
+            if ((1) && (strchr(__Pyx_MODULE_NAME, '.'))) {
+                module = PyImport_ImportModuleLevelObject(
+                    name, global_dict, empty_dict, list, 1);
+                if (!module) {
+                    if (!PyErr_ExceptionMatches(PyExc_ImportError))
+                        goto bad;
+                    PyErr_Clear();
+                }
+            }
+            level = 0;
+        }
+        #endif
+        if (!module) {
+            #if PY_MAJOR_VERSION < 3
+            PyObject *py_level = PyInt_FromLong(level);
+            if (!py_level)
+                goto bad;
+            module = PyObject_CallFunctionObjArgs(py_import,
+                name, global_dict, empty_dict, list, py_level, (PyObject *)NULL);
+            Py_DECREF(py_level);
+            #else
+            module = PyImport_ImportModuleLevelObject(
+                name, global_dict, empty_dict, list, level);
+            #endif
+        }
+    }
+bad:
+    #if PY_MAJOR_VERSION < 3
+    Py_XDECREF(py_import);
+    #endif
+    Py_XDECREF(empty_list);
+    Py_XDECREF(empty_dict);
+    return module;
+}
+
+/* ImportFrom */
+static PyObject* __Pyx_ImportFrom(PyObject* module, PyObject* name) {
+    PyObject* value = __Pyx_PyObject_GetAttrStr(module, name);
+    if (unlikely(!value) && PyErr_ExceptionMatches(PyExc_AttributeError)) {
+        PyErr_Format(PyExc_ImportError,
+        #if PY_MAJOR_VERSION < 3
+            "cannot import name %.230s", PyString_AS_STRING(name));
+        #else
+            "cannot import name %S", name);
+        #endif
+    }
+    return value;
+}
+
+/* FetchCommonType */
+static PyTypeObject* __Pyx_FetchCommonType(PyTypeObject* type) {
+    PyObject* fake_module;
+    PyTypeObject* cached_type = NULL;
+    fake_module = PyImport_AddModule((char*) "_cython_" CYTHON_ABI);
+    if (!fake_module) return NULL;
+    Py_INCREF(fake_module);
+    cached_type = (PyTypeObject*) PyObject_GetAttrString(fake_module, type->tp_name);
+    if (cached_type) {
+        if (!PyType_Check((PyObject*)cached_type)) {
+            PyErr_Format(PyExc_TypeError,
+                "Shared Cython type %.200s is not a type object",
+                type->tp_name);
+            goto bad;
+        }
+        if (cached_type->tp_basicsize != type->tp_basicsize) {
+            PyErr_Format(PyExc_TypeError,
+                "Shared Cython type %.200s has the wrong size, try recompiling",
+                type->tp_name);
+            goto bad;
+        }
+    } else {
+        if (!PyErr_ExceptionMatches(PyExc_AttributeError)) goto bad;
+        PyErr_Clear();
+        if (PyType_Ready(type) < 0) goto bad;
+        if (PyObject_SetAttrString(fake_module, type->tp_name, (PyObject*) type) < 0)
+            goto bad;
+        Py_INCREF(type);
+        cached_type = type;
+    }
+done:
+    Py_DECREF(fake_module);
+    return cached_type;
+bad:
+    Py_XDECREF(cached_type);
+    cached_type = NULL;
+    goto done;
+}
+
+/* CythonFunctionShared */
+#include <structmember.h>
+static PyObject *
+__Pyx_CyFunction_get_doc(__pyx_CyFunctionObject *op, CYTHON_UNUSED void *closure)
+{
+    if (unlikely(op->func_doc == NULL)) {
+        if (op->func.m_ml->ml_doc) {
+#if PY_MAJOR_VERSION >= 3
+            op->func_doc = PyUnicode_FromString(op->func.m_ml->ml_doc);
+#else
+            op->func_doc = PyString_FromString(op->func.m_ml->ml_doc);
+#endif
+            if (unlikely(op->func_doc == NULL))
+                return NULL;
+        } else {
+            Py_INCREF(Py_None);
+            return Py_None;
+        }
+    }
+    Py_INCREF(op->func_doc);
+    return op->func_doc;
+}
+static int
+__Pyx_CyFunction_set_doc(__pyx_CyFunctionObject *op, PyObject *value, CYTHON_UNUSED void *context)
+{
+    PyObject *tmp = op->func_doc;
+    if (value == NULL) {
+        value = Py_None;
+    }
+    Py_INCREF(value);
+    op->func_doc = value;
+    Py_XDECREF(tmp);
+    return 0;
+}
+static PyObject *
+__Pyx_CyFunction_get_name(__pyx_CyFunctionObject *op, CYTHON_UNUSED void *context)
+{
+    if (unlikely(op->func_name == NULL)) {
+#if PY_MAJOR_VERSION >= 3
+        op->func_name = PyUnicode_InternFromString(op->func.m_ml->ml_name);
+#else
+        op->func_name = PyString_InternFromString(op->func.m_ml->ml_name);
+#endif
+        if (unlikely(op->func_name == NULL))
+            return NULL;
+    }
+    Py_INCREF(op->func_name);
+    return op->func_name;
+}
+static int
+__Pyx_CyFunction_set_name(__pyx_CyFunctionObject *op, PyObject *value, CYTHON_UNUSED void *context)
+{
+    PyObject *tmp;
+#if PY_MAJOR_VERSION >= 3
+    if (unlikely(value == NULL || !PyUnicode_Check(value)))
+#else
+    if (unlikely(value == NULL || !PyString_Check(value)))
+#endif
+    {
+        PyErr_SetString(PyExc_TypeError,
+                        "__name__ must be set to a string object");
+        return -1;
+    }
+    tmp = op->func_name;
+    Py_INCREF(value);
+    op->func_name = value;
+    Py_XDECREF(tmp);
+    return 0;
+}
+static PyObject *
+__Pyx_CyFunction_get_qualname(__pyx_CyFunctionObject *op, CYTHON_UNUSED void *context)
+{
+    Py_INCREF(op->func_qualname);
+    return op->func_qualname;
+}
+static int
+__Pyx_CyFunction_set_qualname(__pyx_CyFunctionObject *op, PyObject *value, CYTHON_UNUSED void *context)
+{
+    PyObject *tmp;
+#if PY_MAJOR_VERSION >= 3
+    if (unlikely(value == NULL || !PyUnicode_Check(value)))
+#else
+    if (unlikely(value == NULL || !PyString_Check(value)))
+#endif
+    {
+        PyErr_SetString(PyExc_TypeError,
+                        "__qualname__ must be set to a string object");
+        return -1;
+    }
+    tmp = op->func_qualname;
+    Py_INCREF(value);
+    op->func_qualname = value;
+    Py_XDECREF(tmp);
+    return 0;
+}
+static PyObject *
+__Pyx_CyFunction_get_self(__pyx_CyFunctionObject *m, CYTHON_UNUSED void *closure)
+{
+    PyObject *self;
+    self = m->func_closure;
+    if (self == NULL)
+        self = Py_None;
+    Py_INCREF(self);
+    return self;
+}
+static PyObject *
+__Pyx_CyFunction_get_dict(__pyx_CyFunctionObject *op, CYTHON_UNUSED void *context)
+{
+    if (unlikely(op->func_dict == NULL)) {
+        op->func_dict = PyDict_New();
+        if (unlikely(op->func_dict == NULL))
+            return NULL;
+    }
+    Py_INCREF(op->func_dict);
+    return op->func_dict;
+}
+static int
+__Pyx_CyFunction_set_dict(__pyx_CyFunctionObject *op, PyObject *value, CYTHON_UNUSED void *context)
+{
+    PyObject *tmp;
+    if (unlikely(value == NULL)) {
+        PyErr_SetString(PyExc_TypeError,
+               "function's dictionary may not be deleted");
+        return -1;
+    }
+    if (unlikely(!PyDict_Check(value))) {
+        PyErr_SetString(PyExc_TypeError,
+               "setting function's dictionary to a non-dict");
+        return -1;
+    }
+    tmp = op->func_dict;
+    Py_INCREF(value);
+    op->func_dict = value;
+    Py_XDECREF(tmp);
+    return 0;
+}
+static PyObject *
+__Pyx_CyFunction_get_globals(__pyx_CyFunctionObject *op, CYTHON_UNUSED void *context)
+{
+    Py_INCREF(op->func_globals);
+    return op->func_globals;
+}
+static PyObject *
+__Pyx_CyFunction_get_closure(CYTHON_UNUSED __pyx_CyFunctionObject *op, CYTHON_UNUSED void *context)
+{
+    Py_INCREF(Py_None);
+    return Py_None;
+}
+static PyObject *
+__Pyx_CyFunction_get_code(__pyx_CyFunctionObject *op, CYTHON_UNUSED void *context)
+{
+    PyObject* result = (op->func_code) ? op->func_code : Py_None;
+    Py_INCREF(result);
+    return result;
+}
+static int
+__Pyx_CyFunction_init_defaults(__pyx_CyFunctionObject *op) {
+    int result = 0;
+    PyObject *res = op->defaults_getter((PyObject *) op);
+    if (unlikely(!res))
+        return -1;
+    #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
+    op->defaults_tuple = PyTuple_GET_ITEM(res, 0);
+    Py_INCREF(op->defaults_tuple);
+    op->defaults_kwdict = PyTuple_GET_ITEM(res, 1);
+    Py_INCREF(op->defaults_kwdict);
+    #else
+    op->defaults_tuple = PySequence_ITEM(res, 0);
+    if (unlikely(!op->defaults_tuple)) result = -1;
+    else {
+        op->defaults_kwdict = PySequence_ITEM(res, 1);
+        if (unlikely(!op->defaults_kwdict)) result = -1;
+    }
+    #endif
+    Py_DECREF(res);
+    return result;
+}
+static int
+__Pyx_CyFunction_set_defaults(__pyx_CyFunctionObject *op, PyObject* value, CYTHON_UNUSED void *context) {
+    PyObject* tmp;
+    if (!value) {
+        value = Py_None;
+    } else if (value != Py_None && !PyTuple_Check(value)) {
+        PyErr_SetString(PyExc_TypeError,
+                        "__defaults__ must be set to a tuple object");
+        return -1;
+    }
+    Py_INCREF(value);
+    tmp = op->defaults_tuple;
+    op->defaults_tuple = value;
+    Py_XDECREF(tmp);
+    return 0;
+}
+static PyObject *
+__Pyx_CyFunction_get_defaults(__pyx_CyFunctionObject *op, CYTHON_UNUSED void *context) {
+    PyObject* result = op->defaults_tuple;
+    if (unlikely(!result)) {
+        if (op->defaults_getter) {
+            if (__Pyx_CyFunction_init_defaults(op) < 0) return NULL;
+            result = op->defaults_tuple;
+        } else {
+            result = Py_None;
+        }
+    }
+    Py_INCREF(result);
+    return result;
+}
+static int
+__Pyx_CyFunction_set_kwdefaults(__pyx_CyFunctionObject *op, PyObject* value, CYTHON_UNUSED void *context) {
+    PyObject* tmp;
+    if (!value) {
+        value = Py_None;
+    } else if (value != Py_None && !PyDict_Check(value)) {
+        PyErr_SetString(PyExc_TypeError,
+                        "__kwdefaults__ must be set to a dict object");
+        return -1;
+    }
+    Py_INCREF(value);
+    tmp = op->defaults_kwdict;
+    op->defaults_kwdict = value;
+    Py_XDECREF(tmp);
+    return 0;
+}
+static PyObject *
+__Pyx_CyFunction_get_kwdefaults(__pyx_CyFunctionObject *op, CYTHON_UNUSED void *context) {
+    PyObject* result = op->defaults_kwdict;
+    if (unlikely(!result)) {
+        if (op->defaults_getter) {
+            if (__Pyx_CyFunction_init_defaults(op) < 0) return NULL;
+            result = op->defaults_kwdict;
+        } else {
+            result = Py_None;
+        }
+    }
+    Py_INCREF(result);
+    return result;
+}
+static int
+__Pyx_CyFunction_set_annotations(__pyx_CyFunctionObject *op, PyObject* value, CYTHON_UNUSED void *context) {
+    PyObject* tmp;
+    if (!value || value == Py_None) {
+        value = NULL;
+    } else if (!PyDict_Check(value)) {
+        PyErr_SetString(PyExc_TypeError,
+                        "__annotations__ must be set to a dict object");
+        return -1;
+    }
+    Py_XINCREF(value);
+    tmp = op->func_annotations;
+    op->func_annotations = value;
+    Py_XDECREF(tmp);
+    return 0;
+}
+static PyObject *
+__Pyx_CyFunction_get_annotations(__pyx_CyFunctionObject *op, CYTHON_UNUSED void *context) {
+    PyObject* result = op->func_annotations;
+    if (unlikely(!result)) {
+        result = PyDict_New();
+        if (unlikely(!result)) return NULL;
+        op->func_annotations = result;
+    }
+    Py_INCREF(result);
+    return result;
+}
+static PyGetSetDef __pyx_CyFunction_getsets[] = {
+    {(char *) "func_doc", (getter)__Pyx_CyFunction_get_doc, (setter)__Pyx_CyFunction_set_doc, 0, 0},
+    {(char *) "__doc__",  (getter)__Pyx_CyFunction_get_doc, (setter)__Pyx_CyFunction_set_doc, 0, 0},
+    {(char *) "func_name", (getter)__Pyx_CyFunction_get_name, (setter)__Pyx_CyFunction_set_name, 0, 0},
+    {(char *) "__name__", (getter)__Pyx_CyFunction_get_name, (setter)__Pyx_CyFunction_set_name, 0, 0},
+    {(char *) "__qualname__", (getter)__Pyx_CyFunction_get_qualname, (setter)__Pyx_CyFunction_set_qualname, 0, 0},
+    {(char *) "__self__", (getter)__Pyx_CyFunction_get_self, 0, 0, 0},
+    {(char *) "func_dict", (getter)__Pyx_CyFunction_get_dict, (setter)__Pyx_CyFunction_set_dict, 0, 0},
+    {(char *) "__dict__", (getter)__Pyx_CyFunction_get_dict, (setter)__Pyx_CyFunction_set_dict, 0, 0},
+    {(char *) "func_globals", (getter)__Pyx_CyFunction_get_globals, 0, 0, 0},
+    {(char *) "__globals__", (getter)__Pyx_CyFunction_get_globals, 0, 0, 0},
+    {(char *) "func_closure", (getter)__Pyx_CyFunction_get_closure, 0, 0, 0},
+    {(char *) "__closure__", (getter)__Pyx_CyFunction_get_closure, 0, 0, 0},
+    {(char *) "func_code", (getter)__Pyx_CyFunction_get_code, 0, 0, 0},
+    {(char *) "__code__", (getter)__Pyx_CyFunction_get_code, 0, 0, 0},
+    {(char *) "func_defaults", (getter)__Pyx_CyFunction_get_defaults, (setter)__Pyx_CyFunction_set_defaults, 0, 0},
+    {(char *) "__defaults__", (getter)__Pyx_CyFunction_get_defaults, (setter)__Pyx_CyFunction_set_defaults, 0, 0},
+    {(char *) "__kwdefaults__", (getter)__Pyx_CyFunction_get_kwdefaults, (setter)__Pyx_CyFunction_set_kwdefaults, 0, 0},
+    {(char *) "__annotations__", (getter)__Pyx_CyFunction_get_annotations, (setter)__Pyx_CyFunction_set_annotations, 0, 0},
+    {0, 0, 0, 0, 0}
+};
+static PyMemberDef __pyx_CyFunction_members[] = {
+    {(char *) "__module__", T_OBJECT, offsetof(PyCFunctionObject, m_module), PY_WRITE_RESTRICTED, 0},
+    {0, 0, 0,  0, 0}
+};
+static PyObject *
+__Pyx_CyFunction_reduce(__pyx_CyFunctionObject *m, CYTHON_UNUSED PyObject *args)
+{
+#if PY_MAJOR_VERSION >= 3
+    Py_INCREF(m->func_qualname);
+    return m->func_qualname;
+#else
+    return PyString_FromString(m->func.m_ml->ml_name);
+#endif
+}
+static PyMethodDef __pyx_CyFunction_methods[] = {
+    {"__reduce__", (PyCFunction)__Pyx_CyFunction_reduce, METH_VARARGS, 0},
+    {0, 0, 0, 0}
+};
+#if PY_VERSION_HEX < 0x030500A0
+#define __Pyx_CyFunction_weakreflist(cyfunc) ((cyfunc)->func_weakreflist)
+#else
+#define __Pyx_CyFunction_weakreflist(cyfunc) ((cyfunc)->func.m_weakreflist)
+#endif
+static PyObject *__Pyx_CyFunction_Init(__pyx_CyFunctionObject *op, PyMethodDef *ml, int flags, PyObject* qualname,
+                                       PyObject *closure, PyObject *module, PyObject* globals, PyObject* code) {
+    if (unlikely(op == NULL))
+        return NULL;
+    op->flags = flags;
+    __Pyx_CyFunction_weakreflist(op) = NULL;
+    op->func.m_ml = ml;
+    op->func.m_self = (PyObject *) op;
+    Py_XINCREF(closure);
+    op->func_closure = closure;
+    Py_XINCREF(module);
+    op->func.m_module = module;
+    op->func_dict = NULL;
+    op->func_name = NULL;
+    Py_INCREF(qualname);
+    op->func_qualname = qualname;
+    op->func_doc = NULL;
+    op->func_classobj = NULL;
+    op->func_globals = globals;
+    Py_INCREF(op->func_globals);
+    Py_XINCREF(code);
+    op->func_code = code;
+    op->defaults_pyobjects = 0;
+    op->defaults_size = 0;
+    op->defaults = NULL;
+    op->defaults_tuple = NULL;
+    op->defaults_kwdict = NULL;
+    op->defaults_getter = NULL;
+    op->func_annotations = NULL;
+    return (PyObject *) op;
+}
+static int
+__Pyx_CyFunction_clear(__pyx_CyFunctionObject *m)
+{
+    Py_CLEAR(m->func_closure);
+    Py_CLEAR(m->func.m_module);
+    Py_CLEAR(m->func_dict);
+    Py_CLEAR(m->func_name);
+    Py_CLEAR(m->func_qualname);
+    Py_CLEAR(m->func_doc);
+    Py_CLEAR(m->func_globals);
+    Py_CLEAR(m->func_code);
+    Py_CLEAR(m->func_classobj);
+    Py_CLEAR(m->defaults_tuple);
+    Py_CLEAR(m->defaults_kwdict);
+    Py_CLEAR(m->func_annotations);
+    if (m->defaults) {
+        PyObject **pydefaults = __Pyx_CyFunction_Defaults(PyObject *, m);
+        int i;
+        for (i = 0; i < m->defaults_pyobjects; i++)
+            Py_XDECREF(pydefaults[i]);
+        PyObject_Free(m->defaults);
+        m->defaults = NULL;
+    }
+    return 0;
+}
+static void __Pyx__CyFunction_dealloc(__pyx_CyFunctionObject *m)
+{
+    if (__Pyx_CyFunction_weakreflist(m) != NULL)
+        PyObject_ClearWeakRefs((PyObject *) m);
+    __Pyx_CyFunction_clear(m);
+    PyObject_GC_Del(m);
+}
+static void __Pyx_CyFunction_dealloc(__pyx_CyFunctionObject *m)
+{
+    PyObject_GC_UnTrack(m);
+    __Pyx__CyFunction_dealloc(m);
+}
+static int __Pyx_CyFunction_traverse(__pyx_CyFunctionObject *m, visitproc visit, void *arg)
+{
+    Py_VISIT(m->func_closure);
+    Py_VISIT(m->func.m_module);
+    Py_VISIT(m->func_dict);
+    Py_VISIT(m->func_name);
+    Py_VISIT(m->func_qualname);
+    Py_VISIT(m->func_doc);
+    Py_VISIT(m->func_globals);
+    Py_VISIT(m->func_code);
+    Py_VISIT(m->func_classobj);
+    Py_VISIT(m->defaults_tuple);
+    Py_VISIT(m->defaults_kwdict);
+    if (m->defaults) {
+        PyObject **pydefaults = __Pyx_CyFunction_Defaults(PyObject *, m);
+        int i;
+        for (i = 0; i < m->defaults_pyobjects; i++)
+            Py_VISIT(pydefaults[i]);
+    }
+    return 0;
+}
+static PyObject *__Pyx_CyFunction_descr_get(PyObject *func, PyObject *obj, PyObject *type)
+{
+#if PY_MAJOR_VERSION < 3
+    __pyx_CyFunctionObject *m = (__pyx_CyFunctionObject *) func;
+    if (m->flags & __Pyx_CYFUNCTION_STATICMETHOD) {
+        Py_INCREF(func);
+        return func;
+    }
+    if (m->flags & __Pyx_CYFUNCTION_CLASSMETHOD) {
+        if (type == NULL)
+            type = (PyObject *)(Py_TYPE(obj));
+        return __Pyx_PyMethod_New(func, type, (PyObject *)(Py_TYPE(type)));
+    }
+    if (obj == Py_None)
+        obj = NULL;
+#endif
+    return __Pyx_PyMethod_New(func, obj, type);
+}
+static PyObject*
+__Pyx_CyFunction_repr(__pyx_CyFunctionObject *op)
+{
+#if PY_MAJOR_VERSION >= 3
+    return PyUnicode_FromFormat("<cyfunction %U at %p>",
+                                op->func_qualname, (void *)op);
+#else
+    return PyString_FromFormat("<cyfunction %s at %p>",
+                               PyString_AsString(op->func_qualname), (void *)op);
+#endif
+}
+static PyObject * __Pyx_CyFunction_CallMethod(PyObject *func, PyObject *self, PyObject *arg, PyObject *kw) {
+    PyCFunctionObject* f = (PyCFunctionObject*)func;
+    PyCFunction meth = f->m_ml->ml_meth;
+    Py_ssize_t size;
+    switch (f->m_ml->ml_flags & (METH_VARARGS | METH_KEYWORDS | METH_NOARGS | METH_O)) {
+    case METH_VARARGS:
+        if (likely(kw == NULL || PyDict_Size(kw) == 0))
+            return (*meth)(self, arg);
+        break;
+    case METH_VARARGS | METH_KEYWORDS:
+        return (*(PyCFunctionWithKeywords)(void*)meth)(self, arg, kw);
+    case METH_NOARGS:
+        if (likely(kw == NULL || PyDict_Size(kw) == 0)) {
+            size = PyTuple_GET_SIZE(arg);
+            if (likely(size == 0))
+                return (*meth)(self, NULL);
+            PyErr_Format(PyExc_TypeError,
+                "%.200s() takes no arguments (%" CYTHON_FORMAT_SSIZE_T "d given)",
+                f->m_ml->ml_name, size);
+            return NULL;
+        }
+        break;
+    case METH_O:
+        if (likely(kw == NULL || PyDict_Size(kw) == 0)) {
+            size = PyTuple_GET_SIZE(arg);
+            if (likely(size == 1)) {
+                PyObject *result, *arg0;
+                #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
+                arg0 = PyTuple_GET_ITEM(arg, 0);
+                #else
+                arg0 = PySequence_ITEM(arg, 0); if (unlikely(!arg0)) return NULL;
+                #endif
+                result = (*meth)(self, arg0);
+                #if !(CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS)
+                Py_DECREF(arg0);
+                #endif
+                return result;
+            }
+            PyErr_Format(PyExc_TypeError,
+                "%.200s() takes exactly one argument (%" CYTHON_FORMAT_SSIZE_T "d given)",
+                f->m_ml->ml_name, size);
+            return NULL;
+        }
+        break;
+    default:
+        PyErr_SetString(PyExc_SystemError, "Bad call flags in "
+                        "__Pyx_CyFunction_Call. METH_OLDARGS is no "
+                        "longer supported!");
+        return NULL;
+    }
+    PyErr_Format(PyExc_TypeError, "%.200s() takes no keyword arguments",
+                 f->m_ml->ml_name);
+    return NULL;
+}
+static CYTHON_INLINE PyObject *__Pyx_CyFunction_Call(PyObject *func, PyObject *arg, PyObject *kw) {
+    return __Pyx_CyFunction_CallMethod(func, ((PyCFunctionObject*)func)->m_self, arg, kw);
+}
+static PyObject *__Pyx_CyFunction_CallAsMethod(PyObject *func, PyObject *args, PyObject *kw) {
+    PyObject *result;
+    __pyx_CyFunctionObject *cyfunc = (__pyx_CyFunctionObject *) func;
+    if ((cyfunc->flags & __Pyx_CYFUNCTION_CCLASS) && !(cyfunc->flags & __Pyx_CYFUNCTION_STATICMETHOD)) {
+        Py_ssize_t argc;
+        PyObject *new_args;
+        PyObject *self;
+        argc = PyTuple_GET_SIZE(args);
+        new_args = PyTuple_GetSlice(args, 1, argc);
+        if (unlikely(!new_args))
+            return NULL;
+        self = PyTuple_GetItem(args, 0);
+        if (unlikely(!self)) {
+            Py_DECREF(new_args);
+            PyErr_Format(PyExc_TypeError,
+                         "unbound method %.200S() needs an argument",
+                         cyfunc->func_qualname);
+            return NULL;
+        }
+        result = __Pyx_CyFunction_CallMethod(func, self, new_args, kw);
+        Py_DECREF(new_args);
+    } else {
+        result = __Pyx_CyFunction_Call(func, args, kw);
+    }
+    return result;
+}
+static PyTypeObject __pyx_CyFunctionType_type = {
+    PyVarObject_HEAD_INIT(0, 0)
+    "cython_function_or_method",
+    sizeof(__pyx_CyFunctionObject),
+    0,
+    (destructor) __Pyx_CyFunction_dealloc,
+    0,
+    0,
+    0,
+#if PY_MAJOR_VERSION < 3
+    0,
+#else
+    0,
+#endif
+    (reprfunc) __Pyx_CyFunction_repr,
+    0,
+    0,
+    0,
+    0,
+    __Pyx_CyFunction_CallAsMethod,
+    0,
+    0,
+    0,
+    0,
+    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC,
+    0,
+    (traverseproc) __Pyx_CyFunction_traverse,
+    (inquiry) __Pyx_CyFunction_clear,
+    0,
+#if PY_VERSION_HEX < 0x030500A0
+    offsetof(__pyx_CyFunctionObject, func_weakreflist),
+#else
+    offsetof(PyCFunctionObject, m_weakreflist),
+#endif
+    0,
+    0,
+    __pyx_CyFunction_methods,
+    __pyx_CyFunction_members,
+    __pyx_CyFunction_getsets,
+    0,
+    0,
+    __Pyx_CyFunction_descr_get,
+    0,
+    offsetof(__pyx_CyFunctionObject, func_dict),
+    0,
+    0,
+    0,
+    0,
+    0,
+    0,
+    0,
+    0,
+    0,
+    0,
+    0,
+    0,
+#if PY_VERSION_HEX >= 0x030400a1
+    0,
+#endif
+#if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
+    0,
+#endif
+#if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
+    0,
+#endif
+#if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
+    0,
+#endif
+};
+static int __pyx_CyFunction_init(void) {
+    __pyx_CyFunctionType = __Pyx_FetchCommonType(&__pyx_CyFunctionType_type);
+    if (unlikely(__pyx_CyFunctionType == NULL)) {
+        return -1;
+    }
+    return 0;
+}
+static CYTHON_INLINE void *__Pyx_CyFunction_InitDefaults(PyObject *func, size_t size, int pyobjects) {
+    __pyx_CyFunctionObject *m = (__pyx_CyFunctionObject *) func;
+    m->defaults = PyObject_Malloc(size);
+    if (unlikely(!m->defaults))
+        return PyErr_NoMemory();
+    memset(m->defaults, 0, size);
+    m->defaults_pyobjects = pyobjects;
+    m->defaults_size = size;
+    return m->defaults;
+}
+static CYTHON_INLINE void __Pyx_CyFunction_SetDefaultsTuple(PyObject *func, PyObject *tuple) {
+    __pyx_CyFunctionObject *m = (__pyx_CyFunctionObject *) func;
+    m->defaults_tuple = tuple;
+    Py_INCREF(tuple);
+}
+static CYTHON_INLINE void __Pyx_CyFunction_SetDefaultsKwDict(PyObject *func, PyObject *dict) {
+    __pyx_CyFunctionObject *m = (__pyx_CyFunctionObject *) func;
+    m->defaults_kwdict = dict;
+    Py_INCREF(dict);
+}
+static CYTHON_INLINE void __Pyx_CyFunction_SetAnnotationsDict(PyObject *func, PyObject *dict) {
+    __pyx_CyFunctionObject *m = (__pyx_CyFunctionObject *) func;
+    m->func_annotations = dict;
+    Py_INCREF(dict);
+}
+
+/* CythonFunction */
+static PyObject *__Pyx_CyFunction_New(PyMethodDef *ml, int flags, PyObject* qualname,
+                                      PyObject *closure, PyObject *module, PyObject* globals, PyObject* code) {
+    PyObject *op = __Pyx_CyFunction_Init(
+        PyObject_GC_New(__pyx_CyFunctionObject, __pyx_CyFunctionType),
+        ml, flags, qualname, closure, module, globals, code
+    );
+    if (likely(op)) {
+        PyObject_GC_Track(op);
+    }
+    return op;
+}
+
+/* GetNameInClass */
+static PyObject *__Pyx_GetGlobalNameAfterAttributeLookup(PyObject *name) {
+    PyObject *result;
+    __Pyx_PyThreadState_declare
+    __Pyx_PyThreadState_assign
+    if (unlikely(!__Pyx_PyErr_ExceptionMatches(PyExc_AttributeError)))
+        return NULL;
+    __Pyx_PyErr_Clear();
+    __Pyx_GetModuleGlobalNameUncached(result, name);
+    return result;
+}
+static PyObject *__Pyx__GetNameInClass(PyObject *nmspace, PyObject *name) {
+    PyObject *result;
+    result = __Pyx_PyObject_GetAttrStr(nmspace, name);
+    if (!result) {
+        result = __Pyx_GetGlobalNameAfterAttributeLookup(name);
+    }
+    return result;
+}
+
+/* CLineInTraceback */
+#ifndef CYTHON_CLINE_IN_TRACEBACK
+static int __Pyx_CLineForTraceback(CYTHON_NCP_UNUSED PyThreadState *tstate, int c_line) {
+    PyObject *use_cline;
+    PyObject *ptype, *pvalue, *ptraceback;
+#if CYTHON_COMPILING_IN_CPYTHON
+    PyObject **cython_runtime_dict;
+#endif
+    if (unlikely(!__pyx_cython_runtime)) {
+        return c_line;
+    }
+    __Pyx_ErrFetchInState(tstate, &ptype, &pvalue, &ptraceback);
+#if CYTHON_COMPILING_IN_CPYTHON
+    cython_runtime_dict = _PyObject_GetDictPtr(__pyx_cython_runtime);
+    if (likely(cython_runtime_dict)) {
+        __PYX_PY_DICT_LOOKUP_IF_MODIFIED(
+            use_cline, *cython_runtime_dict,
+            __Pyx_PyDict_GetItemStr(*cython_runtime_dict, __pyx_n_s_cline_in_traceback))
+    } else
+#endif
+    {
+      PyObject *use_cline_obj = __Pyx_PyObject_GetAttrStr(__pyx_cython_runtime, __pyx_n_s_cline_in_traceback);
+      if (use_cline_obj) {
+        use_cline = PyObject_Not(use_cline_obj) ? Py_False : Py_True;
+        Py_DECREF(use_cline_obj);
+      } else {
+        PyErr_Clear();
+        use_cline = NULL;
+      }
+    }
+    if (!use_cline) {
+        c_line = 0;
+        (void) PyObject_SetAttr(__pyx_cython_runtime, __pyx_n_s_cline_in_traceback, Py_False);
+    }
+    else if (use_cline == Py_False || (use_cline != Py_True && PyObject_Not(use_cline) != 0)) {
+        c_line = 0;
+    }
+    __Pyx_ErrRestoreInState(tstate, ptype, pvalue, ptraceback);
+    return c_line;
+}
+#endif
+
+/* CodeObjectCache */
+static int __pyx_bisect_code_objects(__Pyx_CodeObjectCacheEntry* entries, int count, int code_line) {
+    int start = 0, mid = 0, end = count - 1;
+    if (end >= 0 && code_line > entries[end].code_line) {
+        return count;
+    }
+    while (start < end) {
+        mid = start + (end - start) / 2;
+        if (code_line < entries[mid].code_line) {
+            end = mid;
+        } else if (code_line > entries[mid].code_line) {
+             start = mid + 1;
+        } else {
+            return mid;
+        }
+    }
+    if (code_line <= entries[mid].code_line) {
+        return mid;
+    } else {
+        return mid + 1;
+    }
+}
+static PyCodeObject *__pyx_find_code_object(int code_line) {
+    PyCodeObject* code_object;
+    int pos;
+    if (unlikely(!code_line) || unlikely(!__pyx_code_cache.entries)) {
+        return NULL;
+    }
+    pos = __pyx_bisect_code_objects(__pyx_code_cache.entries, __pyx_code_cache.count, code_line);
+    if (unlikely(pos >= __pyx_code_cache.count) || unlikely(__pyx_code_cache.entries[pos].code_line != code_line)) {
+        return NULL;
+    }
+    code_object = __pyx_code_cache.entries[pos].code_object;
+    Py_INCREF(code_object);
+    return code_object;
+}
+static void __pyx_insert_code_object(int code_line, PyCodeObject* code_object) {
+    int pos, i;
+    __Pyx_CodeObjectCacheEntry* entries = __pyx_code_cache.entries;
+    if (unlikely(!code_line)) {
+        return;
+    }
+    if (unlikely(!entries)) {
+        entries = (__Pyx_CodeObjectCacheEntry*)PyMem_Malloc(64*sizeof(__Pyx_CodeObjectCacheEntry));
+        if (likely(entries)) {
+            __pyx_code_cache.entries = entries;
+            __pyx_code_cache.max_count = 64;
+            __pyx_code_cache.count = 1;
+            entries[0].code_line = code_line;
+            entries[0].code_object = code_object;
+            Py_INCREF(code_object);
+        }
+        return;
+    }
+    pos = __pyx_bisect_code_objects(__pyx_code_cache.entries, __pyx_code_cache.count, code_line);
+    if ((pos < __pyx_code_cache.count) && unlikely(__pyx_code_cache.entries[pos].code_line == code_line)) {
+        PyCodeObject* tmp = entries[pos].code_object;
+        entries[pos].code_object = code_object;
+        Py_DECREF(tmp);
+        return;
+    }
+    if (__pyx_code_cache.count == __pyx_code_cache.max_count) {
+        int new_max = __pyx_code_cache.max_count + 64;
+        entries = (__Pyx_CodeObjectCacheEntry*)PyMem_Realloc(
+            __pyx_code_cache.entries, ((size_t)new_max) * sizeof(__Pyx_CodeObjectCacheEntry));
+        if (unlikely(!entries)) {
+            return;
+        }
+        __pyx_code_cache.entries = entries;
+        __pyx_code_cache.max_count = new_max;
+    }
+    for (i=__pyx_code_cache.count; i>pos; i--) {
+        entries[i] = entries[i-1];
+    }
+    entries[pos].code_line = code_line;
+    entries[pos].code_object = code_object;
+    __pyx_code_cache.count++;
+    Py_INCREF(code_object);
+}
+
+/* AddTraceback */
+#include "compile.h"
+#include "frameobject.h"
+#include "traceback.h"
+#if PY_VERSION_HEX >= 0x030b00a6
+  #ifndef Py_BUILD_CORE
+    #define Py_BUILD_CORE 1
+  #endif
+  #include "internal/pycore_frame.h"
+#endif
+static PyCodeObject* __Pyx_CreateCodeObjectForTraceback(
+            const char *funcname, int c_line,
+            int py_line, const char *filename) {
+    PyCodeObject *py_code = NULL;
+    PyObject *py_funcname = NULL;
+    #if PY_MAJOR_VERSION < 3
+    PyObject *py_srcfile = NULL;
+    py_srcfile = PyString_FromString(filename);
+    if (!py_srcfile) goto bad;
+    #endif
+    if (c_line) {
+        #if PY_MAJOR_VERSION < 3
+        py_funcname = PyString_FromFormat( "%s (%s:%d)", funcname, __pyx_cfilenm, c_line);
+        if (!py_funcname) goto bad;
+        #else
+        py_funcname = PyUnicode_FromFormat( "%s (%s:%d)", funcname, __pyx_cfilenm, c_line);
+        if (!py_funcname) goto bad;
+        funcname = PyUnicode_AsUTF8(py_funcname);
+        if (!funcname) goto bad;
+        #endif
+    }
+    else {
+        #if PY_MAJOR_VERSION < 3
+        py_funcname = PyString_FromString(funcname);
+        if (!py_funcname) goto bad;
+        #endif
+    }
+    #if PY_MAJOR_VERSION < 3
+    py_code = __Pyx_PyCode_New(
+        0,
+        0,
+        0,
+        0,
+        0,
+        __pyx_empty_bytes, /*PyObject *code,*/
+        __pyx_empty_tuple, /*PyObject *consts,*/
+        __pyx_empty_tuple, /*PyObject *names,*/
+        __pyx_empty_tuple, /*PyObject *varnames,*/
+        __pyx_empty_tuple, /*PyObject *freevars,*/
+        __pyx_empty_tuple, /*PyObject *cellvars,*/
+        py_srcfile,   /*PyObject *filename,*/
+        py_funcname,  /*PyObject *name,*/
+        py_line,
+        __pyx_empty_bytes  /*PyObject *lnotab*/
+    );
+    Py_DECREF(py_srcfile);
+    #else
+    py_code = PyCode_NewEmpty(filename, funcname, py_line);
+    #endif
+    Py_XDECREF(py_funcname);  // XDECREF since it's only set on Py3 if cline
+    return py_code;
+bad:
+    Py_XDECREF(py_funcname);
+    #if PY_MAJOR_VERSION < 3
+    Py_XDECREF(py_srcfile);
+    #endif
+    return NULL;
+}
+static void __Pyx_AddTraceback(const char *funcname, int c_line,
+                               int py_line, const char *filename) {
+    PyCodeObject *py_code = 0;
+    PyFrameObject *py_frame = 0;
+    PyThreadState *tstate = __Pyx_PyThreadState_Current;
+    PyObject *ptype, *pvalue, *ptraceback;
+    if (c_line) {
+        c_line = __Pyx_CLineForTraceback(tstate, c_line);
+    }
+    py_code = __pyx_find_code_object(c_line ? -c_line : py_line);
+    if (!py_code) {
+        __Pyx_ErrFetchInState(tstate, &ptype, &pvalue, &ptraceback);
+        py_code = __Pyx_CreateCodeObjectForTraceback(
+            funcname, c_line, py_line, filename);
+        if (!py_code) {
+            /* If the code object creation fails, then we should clear the
+               fetched exception references and propagate the new exception */
+            Py_XDECREF(ptype);
+            Py_XDECREF(pvalue);
+            Py_XDECREF(ptraceback);
+            goto bad;
+        }
+        __Pyx_ErrRestoreInState(tstate, ptype, pvalue, ptraceback);
+        __pyx_insert_code_object(c_line ? -c_line : py_line, py_code);
+    }
+    py_frame = PyFrame_New(
+        tstate,            /*PyThreadState *tstate,*/
+        py_code,           /*PyCodeObject *code,*/
+        __pyx_d,    /*PyObject *globals,*/
+        0                  /*PyObject *locals*/
+    );
+    if (!py_frame) goto bad;
+    __Pyx_PyFrame_SetLineNumber(py_frame, py_line);
+    PyTraceBack_Here(py_frame);
+bad:
+    Py_XDECREF(py_code);
+    Py_XDECREF(py_frame);
+}
+
+/* CIntFromPyVerify */
+#define __PYX_VERIFY_RETURN_INT(target_type, func_type, func_value)\
+    __PYX__VERIFY_RETURN_INT(target_type, func_type, func_value, 0)
+#define __PYX_VERIFY_RETURN_INT_EXC(target_type, func_type, func_value)\
+    __PYX__VERIFY_RETURN_INT(target_type, func_type, func_value, 1)
+#define __PYX__VERIFY_RETURN_INT(target_type, func_type, func_value, exc)\
+    {\
+        func_type value = func_value;\
+        if (sizeof(target_type) < sizeof(func_type)) {\
+            if (unlikely(value != (func_type) (target_type) value)) {\
+                func_type zero = 0;\
+                if (exc && unlikely(value == (func_type)-1 && PyErr_Occurred()))\
+                    return (target_type) -1;\
+                if (is_unsigned && unlikely(value < zero))\
+                    goto raise_neg_overflow;\
+                else\
+                    goto raise_overflow;\
+            }\
+        }\
+        return (target_type) value;\
+    }
+
+/* CIntFromPy */
+static CYTHON_INLINE int __Pyx_PyInt_As_int(PyObject *x) {
+#ifdef __Pyx_HAS_GCC_DIAGNOSTIC
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wconversion"
+#endif
+    const int neg_one = (int) -1, const_zero = (int) 0;
+#ifdef __Pyx_HAS_GCC_DIAGNOSTIC
+#pragma GCC diagnostic pop
+#endif
+    const int is_unsigned = neg_one > const_zero;
+#if PY_MAJOR_VERSION < 3
+    if (likely(PyInt_Check(x))) {
+        if (sizeof(int) < sizeof(long)) {
+            __PYX_VERIFY_RETURN_INT(int, long, PyInt_AS_LONG(x))
+        } else {
+            long val = PyInt_AS_LONG(x);
+            if (is_unsigned && unlikely(val < 0)) {
+                goto raise_neg_overflow;
+            }
+            return (int) val;
+        }
+    } else
+#endif
+    if (likely(PyLong_Check(x))) {
+        if (is_unsigned) {
+#if CYTHON_USE_PYLONG_INTERNALS
+            const digit* digits = ((PyLongObject*)x)->ob_digit;
+            switch (Py_SIZE(x)) {
+                case  0: return (int) 0;
+                case  1: __PYX_VERIFY_RETURN_INT(int, digit, digits[0])
+                case 2:
+                    if (8 * sizeof(int) > 1 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(int) >= 2 * PyLong_SHIFT) {
+                            return (int) (((((int)digits[1]) << PyLong_SHIFT) | (int)digits[0]));
+                        }
+                    }
+                    break;
+                case 3:
+                    if (8 * sizeof(int) > 2 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(int) >= 3 * PyLong_SHIFT) {
+                            return (int) (((((((int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0]));
+                        }
+                    }
+                    break;
+                case 4:
+                    if (8 * sizeof(int) > 3 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(int) >= 4 * PyLong_SHIFT) {
+                            return (int) (((((((((int)digits[3]) << PyLong_SHIFT) | (int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0]));
+                        }
+                    }
+                    break;
+            }
+#endif
+#if CYTHON_COMPILING_IN_CPYTHON
+            if (unlikely(Py_SIZE(x) < 0)) {
+                goto raise_neg_overflow;
+            }
+#else
+            {
+                int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
+                if (unlikely(result < 0))
+                    return (int) -1;
+                if (unlikely(result == 1))
+                    goto raise_neg_overflow;
+            }
+#endif
+            if (sizeof(int) <= sizeof(unsigned long)) {
+                __PYX_VERIFY_RETURN_INT_EXC(int, unsigned long, PyLong_AsUnsignedLong(x))
+#ifdef HAVE_LONG_LONG
+            } else if (sizeof(int) <= sizeof(unsigned PY_LONG_LONG)) {
+                __PYX_VERIFY_RETURN_INT_EXC(int, unsigned PY_LONG_LONG, PyLong_AsUnsignedLongLong(x))
+#endif
+            }
+        } else {
+#if CYTHON_USE_PYLONG_INTERNALS
+            const digit* digits = ((PyLongObject*)x)->ob_digit;
+            switch (Py_SIZE(x)) {
+                case  0: return (int) 0;
+                case -1: __PYX_VERIFY_RETURN_INT(int, sdigit, (sdigit) (-(sdigit)digits[0]))
+                case  1: __PYX_VERIFY_RETURN_INT(int,  digit, +digits[0])
+                case -2:
+                    if (8 * sizeof(int) - 1 > 1 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(int, long, -(long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(int) - 1 > 2 * PyLong_SHIFT) {
+                            return (int) (((int)-1)*(((((int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
+                        }
+                    }
+                    break;
+                case 2:
+                    if (8 * sizeof(int) > 1 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(int) - 1 > 2 * PyLong_SHIFT) {
+                            return (int) ((((((int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
+                        }
+                    }
+                    break;
+                case -3:
+                    if (8 * sizeof(int) - 1 > 2 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(int, long, -(long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(int) - 1 > 3 * PyLong_SHIFT) {
+                            return (int) (((int)-1)*(((((((int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
+                        }
+                    }
+                    break;
+                case 3:
+                    if (8 * sizeof(int) > 2 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(int) - 1 > 3 * PyLong_SHIFT) {
+                            return (int) ((((((((int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
+                        }
+                    }
+                    break;
+                case -4:
+                    if (8 * sizeof(int) - 1 > 3 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(int, long, -(long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(int) - 1 > 4 * PyLong_SHIFT) {
+                            return (int) (((int)-1)*(((((((((int)digits[3]) << PyLong_SHIFT) | (int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
+                        }
+                    }
+                    break;
+                case 4:
+                    if (8 * sizeof(int) > 3 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(int) - 1 > 4 * PyLong_SHIFT) {
+                            return (int) ((((((((((int)digits[3]) << PyLong_SHIFT) | (int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
+                        }
+                    }
+                    break;
+            }
+#endif
+            if (sizeof(int) <= sizeof(long)) {
+                __PYX_VERIFY_RETURN_INT_EXC(int, long, PyLong_AsLong(x))
+#ifdef HAVE_LONG_LONG
+            } else if (sizeof(int) <= sizeof(PY_LONG_LONG)) {
+                __PYX_VERIFY_RETURN_INT_EXC(int, PY_LONG_LONG, PyLong_AsLongLong(x))
+#endif
+            }
+        }
+        {
+#if CYTHON_COMPILING_IN_PYPY && !defined(_PyLong_AsByteArray)
+            PyErr_SetString(PyExc_RuntimeError,
+                            "_PyLong_AsByteArray() not available in PyPy, cannot convert large numbers");
+#else
+            int val;
+            PyObject *v = __Pyx_PyNumber_IntOrLong(x);
+ #if PY_MAJOR_VERSION < 3
+            if (likely(v) && !PyLong_Check(v)) {
+                PyObject *tmp = v;
+                v = PyNumber_Long(tmp);
+                Py_DECREF(tmp);
+            }
+ #endif
+            if (likely(v)) {
+                int one = 1; int is_little = (int)*(unsigned char *)&one;
+                unsigned char *bytes = (unsigned char *)&val;
+                int ret = _PyLong_AsByteArray((PyLongObject *)v,
+                                              bytes, sizeof(val),
+                                              is_little, !is_unsigned);
+                Py_DECREF(v);
+                if (likely(!ret))
+                    return val;
+            }
+#endif
+            return (int) -1;
+        }
+    } else {
+        int val;
+        PyObject *tmp = __Pyx_PyNumber_IntOrLong(x);
+        if (!tmp) return (int) -1;
+        val = __Pyx_PyInt_As_int(tmp);
+        Py_DECREF(tmp);
+        return val;
+    }
+raise_overflow:
+    PyErr_SetString(PyExc_OverflowError,
+        "value too large to convert to int");
+    return (int) -1;
+raise_neg_overflow:
+    PyErr_SetString(PyExc_OverflowError,
+        "can't convert negative value to int");
+    return (int) -1;
+}
+
+/* CIntFromPy */
+static CYTHON_INLINE size_t __Pyx_PyInt_As_size_t(PyObject *x) {
+#ifdef __Pyx_HAS_GCC_DIAGNOSTIC
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wconversion"
+#endif
+    const size_t neg_one = (size_t) -1, const_zero = (size_t) 0;
+#ifdef __Pyx_HAS_GCC_DIAGNOSTIC
+#pragma GCC diagnostic pop
+#endif
+    const int is_unsigned = neg_one > const_zero;
+#if PY_MAJOR_VERSION < 3
+    if (likely(PyInt_Check(x))) {
+        if (sizeof(size_t) < sizeof(long)) {
+            __PYX_VERIFY_RETURN_INT(size_t, long, PyInt_AS_LONG(x))
+        } else {
+            long val = PyInt_AS_LONG(x);
+            if (is_unsigned && unlikely(val < 0)) {
+                goto raise_neg_overflow;
+            }
+            return (size_t) val;
+        }
+    } else
+#endif
+    if (likely(PyLong_Check(x))) {
+        if (is_unsigned) {
+#if CYTHON_USE_PYLONG_INTERNALS
+            const digit* digits = ((PyLongObject*)x)->ob_digit;
+            switch (Py_SIZE(x)) {
+                case  0: return (size_t) 0;
+                case  1: __PYX_VERIFY_RETURN_INT(size_t, digit, digits[0])
+                case 2:
+                    if (8 * sizeof(size_t) > 1 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(size_t, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(size_t) >= 2 * PyLong_SHIFT) {
+                            return (size_t) (((((size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0]));
+                        }
+                    }
+                    break;
+                case 3:
+                    if (8 * sizeof(size_t) > 2 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(size_t, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(size_t) >= 3 * PyLong_SHIFT) {
+                            return (size_t) (((((((size_t)digits[2]) << PyLong_SHIFT) | (size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0]));
+                        }
+                    }
+                    break;
+                case 4:
+                    if (8 * sizeof(size_t) > 3 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(size_t, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(size_t) >= 4 * PyLong_SHIFT) {
+                            return (size_t) (((((((((size_t)digits[3]) << PyLong_SHIFT) | (size_t)digits[2]) << PyLong_SHIFT) | (size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0]));
+                        }
+                    }
+                    break;
+            }
+#endif
+#if CYTHON_COMPILING_IN_CPYTHON
+            if (unlikely(Py_SIZE(x) < 0)) {
+                goto raise_neg_overflow;
+            }
+#else
+            {
+                int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
+                if (unlikely(result < 0))
+                    return (size_t) -1;
+                if (unlikely(result == 1))
+                    goto raise_neg_overflow;
+            }
+#endif
+            if (sizeof(size_t) <= sizeof(unsigned long)) {
+                __PYX_VERIFY_RETURN_INT_EXC(size_t, unsigned long, PyLong_AsUnsignedLong(x))
+#ifdef HAVE_LONG_LONG
+            } else if (sizeof(size_t) <= sizeof(unsigned PY_LONG_LONG)) {
+                __PYX_VERIFY_RETURN_INT_EXC(size_t, unsigned PY_LONG_LONG, PyLong_AsUnsignedLongLong(x))
+#endif
+            }
+        } else {
+#if CYTHON_USE_PYLONG_INTERNALS
+            const digit* digits = ((PyLongObject*)x)->ob_digit;
+            switch (Py_SIZE(x)) {
+                case  0: return (size_t) 0;
+                case -1: __PYX_VERIFY_RETURN_INT(size_t, sdigit, (sdigit) (-(sdigit)digits[0]))
+                case  1: __PYX_VERIFY_RETURN_INT(size_t,  digit, +digits[0])
+                case -2:
+                    if (8 * sizeof(size_t) - 1 > 1 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(size_t, long, -(long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(size_t) - 1 > 2 * PyLong_SHIFT) {
+                            return (size_t) (((size_t)-1)*(((((size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0])));
+                        }
+                    }
+                    break;
+                case 2:
+                    if (8 * sizeof(size_t) > 1 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(size_t, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(size_t) - 1 > 2 * PyLong_SHIFT) {
+                            return (size_t) ((((((size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0])));
+                        }
+                    }
+                    break;
+                case -3:
+                    if (8 * sizeof(size_t) - 1 > 2 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(size_t, long, -(long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(size_t) - 1 > 3 * PyLong_SHIFT) {
+                            return (size_t) (((size_t)-1)*(((((((size_t)digits[2]) << PyLong_SHIFT) | (size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0])));
+                        }
+                    }
+                    break;
+                case 3:
+                    if (8 * sizeof(size_t) > 2 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(size_t, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(size_t) - 1 > 3 * PyLong_SHIFT) {
+                            return (size_t) ((((((((size_t)digits[2]) << PyLong_SHIFT) | (size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0])));
+                        }
+                    }
+                    break;
+                case -4:
+                    if (8 * sizeof(size_t) - 1 > 3 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(size_t, long, -(long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(size_t) - 1 > 4 * PyLong_SHIFT) {
+                            return (size_t) (((size_t)-1)*(((((((((size_t)digits[3]) << PyLong_SHIFT) | (size_t)digits[2]) << PyLong_SHIFT) | (size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0])));
+                        }
+                    }
+                    break;
+                case 4:
+                    if (8 * sizeof(size_t) > 3 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(size_t, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(size_t) - 1 > 4 * PyLong_SHIFT) {
+                            return (size_t) ((((((((((size_t)digits[3]) << PyLong_SHIFT) | (size_t)digits[2]) << PyLong_SHIFT) | (size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0])));
+                        }
+                    }
+                    break;
+            }
+#endif
+            if (sizeof(size_t) <= sizeof(long)) {
+                __PYX_VERIFY_RETURN_INT_EXC(size_t, long, PyLong_AsLong(x))
+#ifdef HAVE_LONG_LONG
+            } else if (sizeof(size_t) <= sizeof(PY_LONG_LONG)) {
+                __PYX_VERIFY_RETURN_INT_EXC(size_t, PY_LONG_LONG, PyLong_AsLongLong(x))
+#endif
+            }
+        }
+        {
+#if CYTHON_COMPILING_IN_PYPY && !defined(_PyLong_AsByteArray)
+            PyErr_SetString(PyExc_RuntimeError,
+                            "_PyLong_AsByteArray() not available in PyPy, cannot convert large numbers");
+#else
+            size_t val;
+            PyObject *v = __Pyx_PyNumber_IntOrLong(x);
+ #if PY_MAJOR_VERSION < 3
+            if (likely(v) && !PyLong_Check(v)) {
+                PyObject *tmp = v;
+                v = PyNumber_Long(tmp);
+                Py_DECREF(tmp);
+            }
+ #endif
+            if (likely(v)) {
+                int one = 1; int is_little = (int)*(unsigned char *)&one;
+                unsigned char *bytes = (unsigned char *)&val;
+                int ret = _PyLong_AsByteArray((PyLongObject *)v,
+                                              bytes, sizeof(val),
+                                              is_little, !is_unsigned);
+                Py_DECREF(v);
+                if (likely(!ret))
+                    return val;
+            }
+#endif
+            return (size_t) -1;
+        }
+    } else {
+        size_t val;
+        PyObject *tmp = __Pyx_PyNumber_IntOrLong(x);
+        if (!tmp) return (size_t) -1;
+        val = __Pyx_PyInt_As_size_t(tmp);
+        Py_DECREF(tmp);
+        return val;
+    }
+raise_overflow:
+    PyErr_SetString(PyExc_OverflowError,
+        "value too large to convert to size_t");
+    return (size_t) -1;
+raise_neg_overflow:
+    PyErr_SetString(PyExc_OverflowError,
+        "can't convert negative value to size_t");
+    return (size_t) -1;
+}
+
+/* CIntToPy */
+static CYTHON_INLINE PyObject* __Pyx_PyInt_From_long(long value) {
+#ifdef __Pyx_HAS_GCC_DIAGNOSTIC
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wconversion"
+#endif
+    const long neg_one = (long) -1, const_zero = (long) 0;
+#ifdef __Pyx_HAS_GCC_DIAGNOSTIC
+#pragma GCC diagnostic pop
+#endif
+    const int is_unsigned = neg_one > const_zero;
+    if (is_unsigned) {
+        if (sizeof(long) < sizeof(long)) {
+            return PyInt_FromLong((long) value);
+        } else if (sizeof(long) <= sizeof(unsigned long)) {
+            return PyLong_FromUnsignedLong((unsigned long) value);
+#ifdef HAVE_LONG_LONG
+        } else if (sizeof(long) <= sizeof(unsigned PY_LONG_LONG)) {
+            return PyLong_FromUnsignedLongLong((unsigned PY_LONG_LONG) value);
+#endif
+        }
+    } else {
+        if (sizeof(long) <= sizeof(long)) {
+            return PyInt_FromLong((long) value);
+#ifdef HAVE_LONG_LONG
+        } else if (sizeof(long) <= sizeof(PY_LONG_LONG)) {
+            return PyLong_FromLongLong((PY_LONG_LONG) value);
+#endif
+        }
+    }
+    {
+        int one = 1; int little = (int)*(unsigned char *)&one;
+        unsigned char *bytes = (unsigned char *)&value;
+        return _PyLong_FromByteArray(bytes, sizeof(long),
+                                     little, !is_unsigned);
+    }
+}
+
+/* CIntFromPy */
+static CYTHON_INLINE long __Pyx_PyInt_As_long(PyObject *x) {
+#ifdef __Pyx_HAS_GCC_DIAGNOSTIC
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wconversion"
+#endif
+    const long neg_one = (long) -1, const_zero = (long) 0;
+#ifdef __Pyx_HAS_GCC_DIAGNOSTIC
+#pragma GCC diagnostic pop
+#endif
+    const int is_unsigned = neg_one > const_zero;
+#if PY_MAJOR_VERSION < 3
+    if (likely(PyInt_Check(x))) {
+        if (sizeof(long) < sizeof(long)) {
+            __PYX_VERIFY_RETURN_INT(long, long, PyInt_AS_LONG(x))
+        } else {
+            long val = PyInt_AS_LONG(x);
+            if (is_unsigned && unlikely(val < 0)) {
+                goto raise_neg_overflow;
+            }
+            return (long) val;
+        }
+    } else
+#endif
+    if (likely(PyLong_Check(x))) {
+        if (is_unsigned) {
+#if CYTHON_USE_PYLONG_INTERNALS
+            const digit* digits = ((PyLongObject*)x)->ob_digit;
+            switch (Py_SIZE(x)) {
+                case  0: return (long) 0;
+                case  1: __PYX_VERIFY_RETURN_INT(long, digit, digits[0])
+                case 2:
+                    if (8 * sizeof(long) > 1 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(long) >= 2 * PyLong_SHIFT) {
+                            return (long) (((((long)digits[1]) << PyLong_SHIFT) | (long)digits[0]));
+                        }
+                    }
+                    break;
+                case 3:
+                    if (8 * sizeof(long) > 2 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(long) >= 3 * PyLong_SHIFT) {
+                            return (long) (((((((long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0]));
+                        }
+                    }
+                    break;
+                case 4:
+                    if (8 * sizeof(long) > 3 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(long) >= 4 * PyLong_SHIFT) {
+                            return (long) (((((((((long)digits[3]) << PyLong_SHIFT) | (long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0]));
+                        }
+                    }
+                    break;
+            }
+#endif
+#if CYTHON_COMPILING_IN_CPYTHON
+            if (unlikely(Py_SIZE(x) < 0)) {
+                goto raise_neg_overflow;
+            }
+#else
+            {
+                int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
+                if (unlikely(result < 0))
+                    return (long) -1;
+                if (unlikely(result == 1))
+                    goto raise_neg_overflow;
+            }
+#endif
+            if (sizeof(long) <= sizeof(unsigned long)) {
+                __PYX_VERIFY_RETURN_INT_EXC(long, unsigned long, PyLong_AsUnsignedLong(x))
+#ifdef HAVE_LONG_LONG
+            } else if (sizeof(long) <= sizeof(unsigned PY_LONG_LONG)) {
+                __PYX_VERIFY_RETURN_INT_EXC(long, unsigned PY_LONG_LONG, PyLong_AsUnsignedLongLong(x))
+#endif
+            }
+        } else {
+#if CYTHON_USE_PYLONG_INTERNALS
+            const digit* digits = ((PyLongObject*)x)->ob_digit;
+            switch (Py_SIZE(x)) {
+                case  0: return (long) 0;
+                case -1: __PYX_VERIFY_RETURN_INT(long, sdigit, (sdigit) (-(sdigit)digits[0]))
+                case  1: __PYX_VERIFY_RETURN_INT(long,  digit, +digits[0])
+                case -2:
+                    if (8 * sizeof(long) - 1 > 1 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(long, long, -(long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(long) - 1 > 2 * PyLong_SHIFT) {
+                            return (long) (((long)-1)*(((((long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
+                        }
+                    }
+                    break;
+                case 2:
+                    if (8 * sizeof(long) > 1 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(long) - 1 > 2 * PyLong_SHIFT) {
+                            return (long) ((((((long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
+                        }
+                    }
+                    break;
+                case -3:
+                    if (8 * sizeof(long) - 1 > 2 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(long, long, -(long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(long) - 1 > 3 * PyLong_SHIFT) {
+                            return (long) (((long)-1)*(((((((long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
+                        }
+                    }
+                    break;
+                case 3:
+                    if (8 * sizeof(long) > 2 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(long) - 1 > 3 * PyLong_SHIFT) {
+                            return (long) ((((((((long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
+                        }
+                    }
+                    break;
+                case -4:
+                    if (8 * sizeof(long) - 1 > 3 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(long, long, -(long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(long) - 1 > 4 * PyLong_SHIFT) {
+                            return (long) (((long)-1)*(((((((((long)digits[3]) << PyLong_SHIFT) | (long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
+                        }
+                    }
+                    break;
+                case 4:
+                    if (8 * sizeof(long) > 3 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(long) - 1 > 4 * PyLong_SHIFT) {
+                            return (long) ((((((((((long)digits[3]) << PyLong_SHIFT) | (long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
+                        }
+                    }
+                    break;
+            }
+#endif
+            if (sizeof(long) <= sizeof(long)) {
+                __PYX_VERIFY_RETURN_INT_EXC(long, long, PyLong_AsLong(x))
+#ifdef HAVE_LONG_LONG
+            } else if (sizeof(long) <= sizeof(PY_LONG_LONG)) {
+                __PYX_VERIFY_RETURN_INT_EXC(long, PY_LONG_LONG, PyLong_AsLongLong(x))
+#endif
+            }
+        }
+        {
+#if CYTHON_COMPILING_IN_PYPY && !defined(_PyLong_AsByteArray)
+            PyErr_SetString(PyExc_RuntimeError,
+                            "_PyLong_AsByteArray() not available in PyPy, cannot convert large numbers");
+#else
+            long val;
+            PyObject *v = __Pyx_PyNumber_IntOrLong(x);
+ #if PY_MAJOR_VERSION < 3
+            if (likely(v) && !PyLong_Check(v)) {
+                PyObject *tmp = v;
+                v = PyNumber_Long(tmp);
+                Py_DECREF(tmp);
+            }
+ #endif
+            if (likely(v)) {
+                int one = 1; int is_little = (int)*(unsigned char *)&one;
+                unsigned char *bytes = (unsigned char *)&val;
+                int ret = _PyLong_AsByteArray((PyLongObject *)v,
+                                              bytes, sizeof(val),
+                                              is_little, !is_unsigned);
+                Py_DECREF(v);
+                if (likely(!ret))
+                    return val;
+            }
+#endif
+            return (long) -1;
+        }
+    } else {
+        long val;
+        PyObject *tmp = __Pyx_PyNumber_IntOrLong(x);
+        if (!tmp) return (long) -1;
+        val = __Pyx_PyInt_As_long(tmp);
+        Py_DECREF(tmp);
+        return val;
+    }
+raise_overflow:
+    PyErr_SetString(PyExc_OverflowError,
+        "value too large to convert to long");
+    return (long) -1;
+raise_neg_overflow:
+    PyErr_SetString(PyExc_OverflowError,
+        "can't convert negative value to long");
+    return (long) -1;
+}
+
+/* FastTypeChecks */
+#if CYTHON_COMPILING_IN_CPYTHON
+static int __Pyx_InBases(PyTypeObject *a, PyTypeObject *b) {
+    while (a) {
+        a = a->tp_base;
+        if (a == b)
+            return 1;
+    }
+    return b == &PyBaseObject_Type;
+}
+static CYTHON_INLINE int __Pyx_IsSubtype(PyTypeObject *a, PyTypeObject *b) {
+    PyObject *mro;
+    if (a == b) return 1;
+    mro = a->tp_mro;
+    if (likely(mro)) {
+        Py_ssize_t i, n;
+        n = PyTuple_GET_SIZE(mro);
+        for (i = 0; i < n; i++) {
+            if (PyTuple_GET_ITEM(mro, i) == (PyObject *)b)
+                return 1;
+        }
+        return 0;
+    }
+    return __Pyx_InBases(a, b);
+}
+#if PY_MAJOR_VERSION == 2
+static int __Pyx_inner_PyErr_GivenExceptionMatches2(PyObject *err, PyObject* exc_type1, PyObject* exc_type2) {
+    PyObject *exception, *value, *tb;
+    int res;
+    __Pyx_PyThreadState_declare
+    __Pyx_PyThreadState_assign
+    __Pyx_ErrFetch(&exception, &value, &tb);
+    res = exc_type1 ? PyObject_IsSubclass(err, exc_type1) : 0;
+    if (unlikely(res == -1)) {
+        PyErr_WriteUnraisable(err);
+        res = 0;
+    }
+    if (!res) {
+        res = PyObject_IsSubclass(err, exc_type2);
+        if (unlikely(res == -1)) {
+            PyErr_WriteUnraisable(err);
+            res = 0;
+        }
+    }
+    __Pyx_ErrRestore(exception, value, tb);
+    return res;
+}
+#else
+static CYTHON_INLINE int __Pyx_inner_PyErr_GivenExceptionMatches2(PyObject *err, PyObject* exc_type1, PyObject *exc_type2) {
+    int res = exc_type1 ? __Pyx_IsSubtype((PyTypeObject*)err, (PyTypeObject*)exc_type1) : 0;
+    if (!res) {
+        res = __Pyx_IsSubtype((PyTypeObject*)err, (PyTypeObject*)exc_type2);
+    }
+    return res;
+}
+#endif
+static int __Pyx_PyErr_GivenExceptionMatchesTuple(PyObject *exc_type, PyObject *tuple) {
+    Py_ssize_t i, n;
+    assert(PyExceptionClass_Check(exc_type));
+    n = PyTuple_GET_SIZE(tuple);
+#if PY_MAJOR_VERSION >= 3
+    for (i=0; i<n; i++) {
+        if (exc_type == PyTuple_GET_ITEM(tuple, i)) return 1;
+    }
+#endif
+    for (i=0; i<n; i++) {
+        PyObject *t = PyTuple_GET_ITEM(tuple, i);
+        #if PY_MAJOR_VERSION < 3
+        if (likely(exc_type == t)) return 1;
+        #endif
+        if (likely(PyExceptionClass_Check(t))) {
+            if (__Pyx_inner_PyErr_GivenExceptionMatches2(exc_type, NULL, t)) return 1;
+        } else {
+        }
+    }
+    return 0;
+}
+static CYTHON_INLINE int __Pyx_PyErr_GivenExceptionMatches(PyObject *err, PyObject* exc_type) {
+    if (likely(err == exc_type)) return 1;
+    if (likely(PyExceptionClass_Check(err))) {
+        if (likely(PyExceptionClass_Check(exc_type))) {
+            return __Pyx_inner_PyErr_GivenExceptionMatches2(err, NULL, exc_type);
+        } else if (likely(PyTuple_Check(exc_type))) {
+            return __Pyx_PyErr_GivenExceptionMatchesTuple(err, exc_type);
+        } else {
+        }
+    }
+    return PyErr_GivenExceptionMatches(err, exc_type);
+}
+static CYTHON_INLINE int __Pyx_PyErr_GivenExceptionMatches2(PyObject *err, PyObject *exc_type1, PyObject *exc_type2) {
+    assert(PyExceptionClass_Check(exc_type1));
+    assert(PyExceptionClass_Check(exc_type2));
+    if (likely(err == exc_type1 || err == exc_type2)) return 1;
+    if (likely(PyExceptionClass_Check(err))) {
+        return __Pyx_inner_PyErr_GivenExceptionMatches2(err, exc_type1, exc_type2);
+    }
+    return (PyErr_GivenExceptionMatches(err, exc_type1) || PyErr_GivenExceptionMatches(err, exc_type2));
+}
+#endif
+
+/* CheckBinaryVersion */
+static int __Pyx_check_binary_version(void) {
+    char ctversion[5];
+    int same=1, i, found_dot;
+    const char* rt_from_call = Py_GetVersion();
+    PyOS_snprintf(ctversion, 5, "%d.%d", PY_MAJOR_VERSION, PY_MINOR_VERSION);
+    found_dot = 0;
+    for (i = 0; i < 4; i++) {
+        if (!ctversion[i]) {
+            same = (rt_from_call[i] < '0' || rt_from_call[i] > '9');
+            break;
+        }
+        if (rt_from_call[i] != ctversion[i]) {
+            same = 0;
+            break;
+        }
+    }
+    if (!same) {
+        char rtversion[5] = {'\0'};
+        char message[200];
+        for (i=0; i<4; ++i) {
+            if (rt_from_call[i] == '.') {
+                if (found_dot) break;
+                found_dot = 1;
+            } else if (rt_from_call[i] < '0' || rt_from_call[i] > '9') {
+                break;
+            }
+            rtversion[i] = rt_from_call[i];
+        }
+        PyOS_snprintf(message, sizeof(message),
+                      "compiletime version %s of module '%.100s' "
+                      "does not match runtime version %s",
+                      ctversion, __Pyx_MODULE_NAME, rtversion);
+        return PyErr_WarnEx(NULL, message, 1);
+    }
+    return 0;
+}
+
+/* InitStrings */
+static int __Pyx_InitStrings(__Pyx_StringTabEntry *t) {
+    while (t->p) {
+        #if PY_MAJOR_VERSION < 3
+        if (t->is_unicode) {
+            *t->p = PyUnicode_DecodeUTF8(t->s, t->n - 1, NULL);
+        } else if (t->intern) {
+            *t->p = PyString_InternFromString(t->s);
+        } else {
+            *t->p = PyString_FromStringAndSize(t->s, t->n - 1);
+        }
+        #else
+        if (t->is_unicode | t->is_str) {
+            if (t->intern) {
+                *t->p = PyUnicode_InternFromString(t->s);
+            } else if (t->encoding) {
+                *t->p = PyUnicode_Decode(t->s, t->n - 1, t->encoding, NULL);
+            } else {
+                *t->p = PyUnicode_FromStringAndSize(t->s, t->n - 1);
+            }
+        } else {
+            *t->p = PyBytes_FromStringAndSize(t->s, t->n - 1);
+        }
+        #endif
+        if (!*t->p)
+            return -1;
+        if (PyObject_Hash(*t->p) == -1)
+            return -1;
+        ++t;
+    }
+    return 0;
+}
+
+static CYTHON_INLINE PyObject* __Pyx_PyUnicode_FromString(const char* c_str) {
+    return __Pyx_PyUnicode_FromStringAndSize(c_str, (Py_ssize_t)strlen(c_str));
+}
+static CYTHON_INLINE const char* __Pyx_PyObject_AsString(PyObject* o) {
+    Py_ssize_t ignore;
+    return __Pyx_PyObject_AsStringAndSize(o, &ignore);
+}
+#if __PYX_DEFAULT_STRING_ENCODING_IS_ASCII || __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT
+#if !CYTHON_PEP393_ENABLED
+static const char* __Pyx_PyUnicode_AsStringAndSize(PyObject* o, Py_ssize_t *length) {
+    char* defenc_c;
+    PyObject* defenc = _PyUnicode_AsDefaultEncodedString(o, NULL);
+    if (!defenc) return NULL;
+    defenc_c = PyBytes_AS_STRING(defenc);
+#if __PYX_DEFAULT_STRING_ENCODING_IS_ASCII
+    {
+        char* end = defenc_c + PyBytes_GET_SIZE(defenc);
+        char* c;
+        for (c = defenc_c; c < end; c++) {
+            if ((unsigned char) (*c) >= 128) {
+                PyUnicode_AsASCIIString(o);
+                return NULL;
+            }
+        }
+    }
+#endif
+    *length = PyBytes_GET_SIZE(defenc);
+    return defenc_c;
+}
+#else
+static CYTHON_INLINE const char* __Pyx_PyUnicode_AsStringAndSize(PyObject* o, Py_ssize_t *length) {
+    if (unlikely(__Pyx_PyUnicode_READY(o) == -1)) return NULL;
+#if __PYX_DEFAULT_STRING_ENCODING_IS_ASCII
+    if (likely(PyUnicode_IS_ASCII(o))) {
+        *length = PyUnicode_GET_LENGTH(o);
+        return PyUnicode_AsUTF8(o);
+    } else {
+        PyUnicode_AsASCIIString(o);
+        return NULL;
+    }
+#else
+    return PyUnicode_AsUTF8AndSize(o, length);
+#endif
+}
+#endif
+#endif
+static CYTHON_INLINE const char* __Pyx_PyObject_AsStringAndSize(PyObject* o, Py_ssize_t *length) {
+#if __PYX_DEFAULT_STRING_ENCODING_IS_ASCII || __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT
+    if (
+#if PY_MAJOR_VERSION < 3 && __PYX_DEFAULT_STRING_ENCODING_IS_ASCII
+            __Pyx_sys_getdefaultencoding_not_ascii &&
+#endif
+            PyUnicode_Check(o)) {
+        return __Pyx_PyUnicode_AsStringAndSize(o, length);
+    } else
+#endif
+#if (!CYTHON_COMPILING_IN_PYPY) || (defined(PyByteArray_AS_STRING) && defined(PyByteArray_GET_SIZE))
+    if (PyByteArray_Check(o)) {
+        *length = PyByteArray_GET_SIZE(o);
+        return PyByteArray_AS_STRING(o);
+    } else
+#endif
+    {
+        char* result;
+        int r = PyBytes_AsStringAndSize(o, &result, length);
+        if (unlikely(r < 0)) {
+            return NULL;
+        } else {
+            return result;
+        }
+    }
+}
+static CYTHON_INLINE int __Pyx_PyObject_IsTrue(PyObject* x) {
+   int is_true = x == Py_True;
+   if (is_true | (x == Py_False) | (x == Py_None)) return is_true;
+   else return PyObject_IsTrue(x);
+}
+static CYTHON_INLINE int __Pyx_PyObject_IsTrueAndDecref(PyObject* x) {
+    int retval;
+    if (unlikely(!x)) return -1;
+    retval = __Pyx_PyObject_IsTrue(x);
+    Py_DECREF(x);
+    return retval;
+}
+static PyObject* __Pyx_PyNumber_IntOrLongWrongResultType(PyObject* result, const char* type_name) {
+#if PY_MAJOR_VERSION >= 3
+    if (PyLong_Check(result)) {
+        if (PyErr_WarnFormat(PyExc_DeprecationWarning, 1,
+                "__int__ returned non-int (type %.200s).  "
+                "The ability to return an instance of a strict subclass of int "
+                "is deprecated, and may be removed in a future version of Python.",
+                Py_TYPE(result)->tp_name)) {
+            Py_DECREF(result);
+            return NULL;
+        }
+        return result;
+    }
+#endif
+    PyErr_Format(PyExc_TypeError,
+                 "__%.4s__ returned non-%.4s (type %.200s)",
+                 type_name, type_name, Py_TYPE(result)->tp_name);
+    Py_DECREF(result);
+    return NULL;
+}
+static CYTHON_INLINE PyObject* __Pyx_PyNumber_IntOrLong(PyObject* x) {
+#if CYTHON_USE_TYPE_SLOTS
+  PyNumberMethods *m;
+#endif
+  const char *name = NULL;
+  PyObject *res = NULL;
+#if PY_MAJOR_VERSION < 3
+  if (likely(PyInt_Check(x) || PyLong_Check(x)))
+#else
+  if (likely(PyLong_Check(x)))
+#endif
+    return __Pyx_NewRef(x);
+#if CYTHON_USE_TYPE_SLOTS
+  m = Py_TYPE(x)->tp_as_number;
+  #if PY_MAJOR_VERSION < 3
+  if (m && m->nb_int) {
+    name = "int";
+    res = m->nb_int(x);
+  }
+  else if (m && m->nb_long) {
+    name = "long";
+    res = m->nb_long(x);
+  }
+  #else
+  if (likely(m && m->nb_int)) {
+    name = "int";
+    res = m->nb_int(x);
+  }
+  #endif
+#else
+  if (!PyBytes_CheckExact(x) && !PyUnicode_CheckExact(x)) {
+    res = PyNumber_Int(x);
+  }
+#endif
+  if (likely(res)) {
+#if PY_MAJOR_VERSION < 3
+    if (unlikely(!PyInt_Check(res) && !PyLong_Check(res))) {
+#else
+    if (unlikely(!PyLong_CheckExact(res))) {
+#endif
+        return __Pyx_PyNumber_IntOrLongWrongResultType(res, name);
+    }
+  }
+  else if (!PyErr_Occurred()) {
+    PyErr_SetString(PyExc_TypeError,
+                    "an integer is required");
+  }
+  return res;
+}
+static CYTHON_INLINE Py_ssize_t __Pyx_PyIndex_AsSsize_t(PyObject* b) {
+  Py_ssize_t ival;
+  PyObject *x;
+#if PY_MAJOR_VERSION < 3
+  if (likely(PyInt_CheckExact(b))) {
+    if (sizeof(Py_ssize_t) >= sizeof(long))
+        return PyInt_AS_LONG(b);
+    else
+        return PyInt_AsSsize_t(b);
+  }
+#endif
+  if (likely(PyLong_CheckExact(b))) {
+    #if CYTHON_USE_PYLONG_INTERNALS
+    const digit* digits = ((PyLongObject*)b)->ob_digit;
+    const Py_ssize_t size = Py_SIZE(b);
+    if (likely(__Pyx_sst_abs(size) <= 1)) {
+        ival = likely(size) ? digits[0] : 0;
+        if (size == -1) ival = -ival;
+        return ival;
+    } else {
+      switch (size) {
+         case 2:
+           if (8 * sizeof(Py_ssize_t) > 2 * PyLong_SHIFT) {
+             return (Py_ssize_t) (((((size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0]));
+           }
+           break;
+         case -2:
+           if (8 * sizeof(Py_ssize_t) > 2 * PyLong_SHIFT) {
+             return -(Py_ssize_t) (((((size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0]));
+           }
+           break;
+         case 3:
+           if (8 * sizeof(Py_ssize_t) > 3 * PyLong_SHIFT) {
+             return (Py_ssize_t) (((((((size_t)digits[2]) << PyLong_SHIFT) | (size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0]));
+           }
+           break;
+         case -3:
+           if (8 * sizeof(Py_ssize_t) > 3 * PyLong_SHIFT) {
+             return -(Py_ssize_t) (((((((size_t)digits[2]) << PyLong_SHIFT) | (size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0]));
+           }
+           break;
+         case 4:
+           if (8 * sizeof(Py_ssize_t) > 4 * PyLong_SHIFT) {
+             return (Py_ssize_t) (((((((((size_t)digits[3]) << PyLong_SHIFT) | (size_t)digits[2]) << PyLong_SHIFT) | (size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0]));
+           }
+           break;
+         case -4:
+           if (8 * sizeof(Py_ssize_t) > 4 * PyLong_SHIFT) {
+             return -(Py_ssize_t) (((((((((size_t)digits[3]) << PyLong_SHIFT) | (size_t)digits[2]) << PyLong_SHIFT) | (size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0]));
+           }
+           break;
+      }
+    }
+    #endif
+    return PyLong_AsSsize_t(b);
+  }
+  x = PyNumber_Index(b);
+  if (!x) return -1;
+  ival = PyInt_AsSsize_t(x);
+  Py_DECREF(x);
+  return ival;
+}
+static CYTHON_INLINE Py_hash_t __Pyx_PyIndex_AsHash_t(PyObject* o) {
+  if (sizeof(Py_hash_t) == sizeof(Py_ssize_t)) {
+    return (Py_hash_t) __Pyx_PyIndex_AsSsize_t(o);
+#if PY_MAJOR_VERSION < 3
+  } else if (likely(PyInt_CheckExact(o))) {
+    return PyInt_AS_LONG(o);
+#endif
+  } else {
+    Py_ssize_t ival;
+    PyObject *x;
+    x = PyNumber_Index(o);
+    if (!x) return -1;
+    ival = PyInt_AsLong(x);
+    Py_DECREF(x);
+    return ival;
+  }
+}
+static CYTHON_INLINE PyObject * __Pyx_PyBool_FromLong(long b) {
+  return b ? __Pyx_NewRef(Py_True) : __Pyx_NewRef(Py_False);
+}
+static CYTHON_INLINE PyObject * __Pyx_PyInt_FromSize_t(size_t ival) {
+    return PyInt_FromSize_t(ival);
+}
+
+
+#endif /* Py_PYTHON_H */
```

## chaine/_core/crf.pyx

 * *Ordering differences only*

```diff
@@ -1,271 +1,271 @@
-# cython: embedsignature=True
-# cython: c_string_type=str
-# cython: c_string_encoding=utf-8
-# cython: profile=False
-# cython: language_level=2
-# distutils: language=c++
-
-cimport crfsuite_api
-from libcpp.string cimport string
-import os
-
-from chaine.logging import Logger
-from chaine.typing import Filepath, Labels, Sequence
-
-LOGGER = Logger(__name__)
-
-
-cdef class Trainer:
-    cdef crfsuite_api.Trainer _trainer
-
-    param2kwarg = {
-        "feature.minfreq": "min_freq",
-        "feature.possible_states": "all_possible_states",
-        "feature.possible_transitions": "all_possible_transitions",
-        "calibration.eta": "calibration_eta",
-        "calibration.rate": "calibration_rate",
-        "calibration.samples": "calibration_samples",
-        "calibration.candidates": "calibration_candidates",
-        "calibration.max_trials": "calibration_max_trials",
-        "type": "pa_type",
-    }
-    kwarg2param = {
-        "min_freq": "feature.minfreq",
-        "all_possible_states": "feature.possible_states",
-        "all_possible_transitions": "feature.possible_transitions",
-        "calibration_eta": "calibration.eta",
-        "calibration_rate": "calibration.rate",
-        "calibration_samples": "calibration.samples",
-        "calibration_candidates": "calibration.candidates",
-        "calibration_max_trials": "calibration.max_trials",
-        "pa_type": "type",
-    }
-    _algorithm_aliases = {
-        "lbfgs": "lbfgs",
-        "limited-memory-bfgs": "lbfgs",
-        "l2sgd": "l2sgd",
-        "sgd": "l2sgd",
-        "stochastic-gradient-descent": "l2sgd",
-        "ap": "averaged-perceptron",
-        "averaged-perceptron": "averaged-perceptron",
-        "pa": "passive-aggressive",
-        "passive-aggressive": "passive-aggressive",
-        "arow": "arow"
-    }
-    _parameter_types = {
-            "feature.minfreq": float,
-            "feature.possible_states": lambda value: bool(int(value)),
-            "feature.possible_transitions": lambda value: bool(int(value)),
-            "c1": float,
-            "c2": float,
-            "max_iterations": int,
-            "num_memories": int,
-            "epsilon": float,
-            "period": int,
-            "delta": float,
-            "linesearch": str,
-            "max_linesearch": int,
-            "calibration.eta": float,
-            "calibration.rate": float,
-            "calibration.samples": float,
-            "calibration.candidates": int,
-            "calibration.max_trials": int,
-            "type": int,
-            "c": float,
-            "error_sensitive": lambda value: bool(int(value)),
-            "averaging": lambda value: bool(int(value)),
-            "variance": float,
-            "gamma": float,
-        }
-
-    def __init__(self, algorithm: str, **kwargs):
-        self.select_algorithm(algorithm)
-        self.set_params(self.translate_params(kwargs))
-
-    def __cinit__(self):
-        self._trainer.set_handler(self, <crfsuite_api.messagefunc>self._on_message)
-        self._trainer.select("l2sgd", "crf1d")
-        self._trainer._init_trainer()
-
-    @property
-    def params(self):
-        return self._trainer.params()
-
-    def train(self, model_filepath: Filepath):
-        self._trainer.train(str(model_filepath), -1)
-
-    def _log(self, message: str):
-        LOGGER.info(message)
-
-    cdef _on_message(self, string message):
-        self._log(message)
-
-    def append(self, sequence: Sequence, labels: Labels, int group=0):
-        # no generators allowed
-        if not isinstance(sequence, list):
-            sequence = [item for item in sequence]
-        if not isinstance(labels, list):
-            # labels must be strings
-            labels = [str(label) for label in labels]
-
-        self._trainer.append(to_seq(sequence), labels, group)
-
-    def translate_params(self, kwargs: dict[str, str | int | float | bool]):
-        return {
-            self.kwarg2param.get(kwarg, kwarg): value
-            for kwarg, value in kwargs.items()
-        }
-
-    def select_algorithm(self, algorithm: str):
-        try:
-            algorithm = self._algorithm_aliases[algorithm.lower()]
-        except:
-            raise ValueError(f"{algorithm} is no available algorithm")
-        if not self._trainer.select(algorithm, "crf1d"):
-            raise ValueError(f"{algorithm} is no available algorithm")
-
-    def set_params(self, params: dict[str, str | int | float | bool]):
-        for param, value in params.items():
-            self.set_param(param, value)
-
-    def set_param(self, param: str, value: str | int | float | bool):
-        if isinstance(value, bool):
-            value = int(value)
-        self._trainer.set(param, str(value))
-
-    def get_param(self, param: str):
-        return self.cast_parameter(param, self._trainer.get(param))
-
-    def cast_parameter(self, param: str, value: str | int | float | bool):
-        if param in self._parameter_types:
-            return self._parameter_types[param](value)
-        return value
-
-
-cdef class Model:
-    cdef crfsuite_api.Tagger _tagger
-
-    def __init__(self, model_filepath: Filepath):
-        self.load(model_filepath)
-
-    @property
-    def labels(self):
-        return self._tagger.labels()
-
-    def predict_single(self, sequence: Sequence) -> list[str]:
-        self.set_sequence(sequence)
-        return self._tagger.viterbi()
-
-    def predict_proba_single(self, sequence: Sequence) -> list[dict[str, float]]:
-        self.set_sequence(sequence)
-        return [
-            {label: self.marginal(label, index) for label in self.labels}
-            for index in range(len(sequence))
-        ]
-
-    def load(self, filepath: Filepath):
-        filepath = str(filepath)
-        self.check_model(filepath)
-        if not self._tagger.open(filepath):
-            raise ValueError(f"Cannot load model file {filepath}")
-
-    def marginal(self, label: str, index: int):
-        return self._tagger.marginal(label, index)
-
-    cpdef set_sequence(self, sequence) except +:
-        self._tagger.set(to_seq(sequence))
-
-    @staticmethod
-    def check_model(filepath: str):
-        with open(filepath, "rb") as model:
-            magic = model.read(4)
-            if magic != b"lCRF":
-                raise ValueError(f"Invalid model file {filepath}")
-            model.seek(0, os.SEEK_END)
-            if model.tell() <= 48:
-                raise ValueError(f"Model file {filepath} does not have a complete header")
-
-    def dump_transitions(self, filepath: Filepath):
-        self._tagger.dump_transitions(os.open(str(filepath), os.O_WRONLY | os.O_CREAT))
-
-    def dump_states(self, filepath: Filepath):
-        self._tagger.dump_states(os.open(str(filepath), os.O_WRONLY | os.O_CREAT))
-
-cdef crfsuite_api.Item to_item(sequence) except+:
-    cdef crfsuite_api.Item c_item
-    cdef double c_value
-    cdef string c_token
-    cdef string separator
-    cdef bint is_dict, is_nested_value
-
-    separator = b":"
-    is_dict = isinstance(sequence, dict)
-    c_item = crfsuite_api.Item()
-    c_item.reserve(len(sequence))
-
-    for token in sequence:
-        if isinstance(token, unicode):
-            c_token = (<unicode>token).encode("utf8")
-        else:
-            c_token = token
-        if not is_dict:
-            c_value = 1.0
-            c_item.push_back(crfsuite_api.Attribute(c_token, c_value))
-        else:
-            value = (<dict>sequence)[token]
-            if isinstance(value, (dict, list, set)):
-                for attr in to_item(value):
-                    c_item.push_back(
-                        crfsuite_api.Attribute(c_token + separator + attr.attr, attr.value)
-                    )
-            else:
-                if isinstance(value, unicode):
-                    c_token += separator
-                    c_token += <string>(<unicode>value).encode("utf8")
-                    c_value = 1.0
-                elif isinstance(value, bytes):
-                    c_token += separator
-                    c_token += <string>value
-                    c_value = 1.0
-                else:
-                    c_value = value
-                c_item.push_back(crfsuite_api.Attribute(c_token, c_value))
-    return c_item
-
-
-cdef crfsuite_api.ItemSequence to_seq(sequence) except+:
-    cdef crfsuite_api.ItemSequence c_sequence
-
-    if isinstance(sequence, ItemSequence):
-        c_sequence = (<ItemSequence>sequence).c_sequence
-    else:
-        for s in sequence:
-            c_sequence.push_back(to_item(s))
-    return c_sequence
-
-
-cdef class ItemSequence:
-    cdef crfsuite_api.ItemSequence c_sequence
-
-    def __init__(self, sequence):
-        self.c_sequence = to_seq(sequence)
-
-    def items(self):
-        cdef crfsuite_api.Item c_item
-        cdef crfsuite_api.Attribute c_attr
-        cdef bytes token
-
-        sequence = []
-        for c_item in self.c_sequence:
-            x = {}
-            for c_attr in c_item:
-                token = <bytes>c_attr.attr.c_str()
-                x[token.decode("utf8")] = c_attr.value
-            sequence.append(x)
-        return sequence
-
-    def __len__(self):
-        return self.c_sequence.size()
-
-    def __repr__(self):
-        return f"<ItemSequence ({len(self)})>"
+# cython: embedsignature=True
+# cython: c_string_type=str
+# cython: c_string_encoding=utf-8
+# cython: profile=False
+# cython: language_level=2
+# distutils: language=c++
+
+cimport crfsuite_api
+from libcpp.string cimport string
+import os
+
+from chaine.logging import Logger
+from chaine.typing import Filepath, Labels, Sequence
+
+LOGGER = Logger(__name__)
+
+
+cdef class Trainer:
+    cdef crfsuite_api.Trainer _trainer
+
+    param2kwarg = {
+        "feature.minfreq": "min_freq",
+        "feature.possible_states": "all_possible_states",
+        "feature.possible_transitions": "all_possible_transitions",
+        "calibration.eta": "calibration_eta",
+        "calibration.rate": "calibration_rate",
+        "calibration.samples": "calibration_samples",
+        "calibration.candidates": "calibration_candidates",
+        "calibration.max_trials": "calibration_max_trials",
+        "type": "pa_type",
+    }
+    kwarg2param = {
+        "min_freq": "feature.minfreq",
+        "all_possible_states": "feature.possible_states",
+        "all_possible_transitions": "feature.possible_transitions",
+        "calibration_eta": "calibration.eta",
+        "calibration_rate": "calibration.rate",
+        "calibration_samples": "calibration.samples",
+        "calibration_candidates": "calibration.candidates",
+        "calibration_max_trials": "calibration.max_trials",
+        "pa_type": "type",
+    }
+    _algorithm_aliases = {
+        "lbfgs": "lbfgs",
+        "limited-memory-bfgs": "lbfgs",
+        "l2sgd": "l2sgd",
+        "sgd": "l2sgd",
+        "stochastic-gradient-descent": "l2sgd",
+        "ap": "averaged-perceptron",
+        "averaged-perceptron": "averaged-perceptron",
+        "pa": "passive-aggressive",
+        "passive-aggressive": "passive-aggressive",
+        "arow": "arow"
+    }
+    _parameter_types = {
+            "feature.minfreq": float,
+            "feature.possible_states": lambda value: bool(int(value)),
+            "feature.possible_transitions": lambda value: bool(int(value)),
+            "c1": float,
+            "c2": float,
+            "max_iterations": int,
+            "num_memories": int,
+            "epsilon": float,
+            "period": int,
+            "delta": float,
+            "linesearch": str,
+            "max_linesearch": int,
+            "calibration.eta": float,
+            "calibration.rate": float,
+            "calibration.samples": float,
+            "calibration.candidates": int,
+            "calibration.max_trials": int,
+            "type": int,
+            "c": float,
+            "error_sensitive": lambda value: bool(int(value)),
+            "averaging": lambda value: bool(int(value)),
+            "variance": float,
+            "gamma": float,
+        }
+
+    def __init__(self, algorithm: str, **kwargs):
+        self.select_algorithm(algorithm)
+        self.set_params(self.translate_params(kwargs))
+
+    def __cinit__(self):
+        self._trainer.set_handler(self, <crfsuite_api.messagefunc>self._on_message)
+        self._trainer.select("l2sgd", "crf1d")
+        self._trainer._init_trainer()
+
+    @property
+    def params(self):
+        return self._trainer.params()
+
+    def train(self, model_filepath: Filepath):
+        self._trainer.train(str(model_filepath), -1)
+
+    def _log(self, message: str):
+        LOGGER.info(message)
+
+    cdef _on_message(self, string message):
+        self._log(message)
+
+    def append(self, sequence: Sequence, labels: Labels, int group=0):
+        # no generators allowed
+        if not isinstance(sequence, list):
+            sequence = [item for item in sequence]
+        if not isinstance(labels, list):
+            # labels must be strings
+            labels = [str(label) for label in labels]
+
+        self._trainer.append(to_seq(sequence), labels, group)
+
+    def translate_params(self, kwargs: dict[str, str | int | float | bool]):
+        return {
+            self.kwarg2param.get(kwarg, kwarg): value
+            for kwarg, value in kwargs.items()
+        }
+
+    def select_algorithm(self, algorithm: str):
+        try:
+            algorithm = self._algorithm_aliases[algorithm.lower()]
+        except:
+            raise ValueError(f"{algorithm} is no available algorithm")
+        if not self._trainer.select(algorithm, "crf1d"):
+            raise ValueError(f"{algorithm} is no available algorithm")
+
+    def set_params(self, params: dict[str, str | int | float | bool]):
+        for param, value in params.items():
+            self.set_param(param, value)
+
+    def set_param(self, param: str, value: str | int | float | bool):
+        if isinstance(value, bool):
+            value = int(value)
+        self._trainer.set(param, str(value))
+
+    def get_param(self, param: str):
+        return self.cast_parameter(param, self._trainer.get(param))
+
+    def cast_parameter(self, param: str, value: str | int | float | bool):
+        if param in self._parameter_types:
+            return self._parameter_types[param](value)
+        return value
+
+
+cdef class Model:
+    cdef crfsuite_api.Tagger _tagger
+
+    def __init__(self, model_filepath: Filepath):
+        self.load(model_filepath)
+
+    @property
+    def labels(self):
+        return self._tagger.labels()
+
+    def predict_single(self, sequence: Sequence) -> list[str]:
+        self.set_sequence(sequence)
+        return self._tagger.viterbi()
+
+    def predict_proba_single(self, sequence: Sequence) -> list[dict[str, float]]:
+        self.set_sequence(sequence)
+        return [
+            {label: self.marginal(label, index) for label in self.labels}
+            for index in range(len(sequence))
+        ]
+
+    def load(self, filepath: Filepath):
+        filepath = str(filepath)
+        self.check_model(filepath)
+        if not self._tagger.open(filepath):
+            raise ValueError(f"Cannot load model file {filepath}")
+
+    def marginal(self, label: str, index: int):
+        return self._tagger.marginal(label, index)
+
+    cpdef set_sequence(self, sequence) except +:
+        self._tagger.set(to_seq(sequence))
+
+    @staticmethod
+    def check_model(filepath: str):
+        with open(filepath, "rb") as model:
+            magic = model.read(4)
+            if magic != b"lCRF":
+                raise ValueError(f"Invalid model file {filepath}")
+            model.seek(0, os.SEEK_END)
+            if model.tell() <= 48:
+                raise ValueError(f"Model file {filepath} does not have a complete header")
+
+    def dump_transitions(self, filepath: Filepath):
+        self._tagger.dump_transitions(os.open(str(filepath), os.O_WRONLY | os.O_CREAT))
+
+    def dump_states(self, filepath: Filepath):
+        self._tagger.dump_states(os.open(str(filepath), os.O_WRONLY | os.O_CREAT))
+
+cdef crfsuite_api.Item to_item(sequence) except+:
+    cdef crfsuite_api.Item c_item
+    cdef double c_value
+    cdef string c_token
+    cdef string separator
+    cdef bint is_dict, is_nested_value
+
+    separator = b":"
+    is_dict = isinstance(sequence, dict)
+    c_item = crfsuite_api.Item()
+    c_item.reserve(len(sequence))
+
+    for token in sequence:
+        if isinstance(token, unicode):
+            c_token = (<unicode>token).encode("utf8")
+        else:
+            c_token = token
+        if not is_dict:
+            c_value = 1.0
+            c_item.push_back(crfsuite_api.Attribute(c_token, c_value))
+        else:
+            value = (<dict>sequence)[token]
+            if isinstance(value, (dict, list, set)):
+                for attr in to_item(value):
+                    c_item.push_back(
+                        crfsuite_api.Attribute(c_token + separator + attr.attr, attr.value)
+                    )
+            else:
+                if isinstance(value, unicode):
+                    c_token += separator
+                    c_token += <string>(<unicode>value).encode("utf8")
+                    c_value = 1.0
+                elif isinstance(value, bytes):
+                    c_token += separator
+                    c_token += <string>value
+                    c_value = 1.0
+                else:
+                    c_value = value
+                c_item.push_back(crfsuite_api.Attribute(c_token, c_value))
+    return c_item
+
+
+cdef crfsuite_api.ItemSequence to_seq(sequence) except+:
+    cdef crfsuite_api.ItemSequence c_sequence
+
+    if isinstance(sequence, ItemSequence):
+        c_sequence = (<ItemSequence>sequence).c_sequence
+    else:
+        for s in sequence:
+            c_sequence.push_back(to_item(s))
+    return c_sequence
+
+
+cdef class ItemSequence:
+    cdef crfsuite_api.ItemSequence c_sequence
+
+    def __init__(self, sequence):
+        self.c_sequence = to_seq(sequence)
+
+    def items(self):
+        cdef crfsuite_api.Item c_item
+        cdef crfsuite_api.Attribute c_attr
+        cdef bytes token
+
+        sequence = []
+        for c_item in self.c_sequence:
+            x = {}
+            for c_attr in c_item:
+                token = <bytes>c_attr.attr.c_str()
+                x[token.decode("utf8")] = c_attr.value
+            sequence.append(x)
+        return sequence
+
+    def __len__(self):
+        return self.c_sequence.size()
+
+    def __repr__(self):
+        return f"<ItemSequence ({len(self)})>"
```

## chaine/_core/crfsuite/COPYING

 * *Ordering differences only*

```diff
@@ -1,27 +1,27 @@
-The BSD license.
-
-Copyright (c) 2007-2010, Naoaki Okazaki
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in the
-      documentation and/or other materials provided with the distribution.
-    * Neither the names of the authors nor the names of its contributors
-      may be used to endorse or promote products derived from this
-      software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
-OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
-EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
-PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+The BSD license.
+
+Copyright (c) 2007-2010, Naoaki Okazaki
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+    * Neither the names of the authors nor the names of its contributors
+      may be used to endorse or promote products derived from this
+      software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
```

## chaine/_core/crfsuite/include/crfsuite.h

 * *Ordering differences only*

```diff
@@ -1,1077 +1,1077 @@
-/*
- *      CRFsuite library.
- *
- * Copyright (c) 2007-2010, Naoaki Okazaki
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the names of the authors nor the names of its contributors
- *       may be used to endorse or promote products derived from this
- *       software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
- * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-/* $Id$ */
-
-#ifndef __CRFSUITE_H__
-#define __CRFSUITE_H__
-
-#ifdef __cplusplus
-extern "C"
-{
-#endif /*__cplusplus*/
-
-#include <limits.h>
-#include <stdio.h>
-#include <stdarg.h>
-
-/**
- * \addtogroup crfsuite_api CRFSuite C API
- * @{
- *
- *  The CRFSuite C API provides a low-level library for manupulating
- *  CRFSuite in C language.
- */
-
-/**
- * \addtogroup crfsuite_misc Miscellaneous definitions and functions
- * @{
- */
-
-/** Version number of CRFSuite library. */
-#define CRFSUITE_VERSION "0.12.2"
-
-/** Copyright string of CRFSuite library. */
-#define CRFSUITE_COPYRIGHT "Copyright (c) 2007-2013 Naoaki Okazaki"
-
-   /** Type of a float value. */
-   typedef double floatval_t;
-
-/** Maximum value of a float value. */
-#define FLOAT_MAX DBL_MAX
-
-   /**
-    * Status codes.
-    */
-   enum
-   {
-      /** Success. */
-      CRFSUITE_SUCCESS = 0,
-      /** Unknown error occurred. */
-      CRFSUITEERR_UNKNOWN = INT_MIN,
-      /** Insufficient memory. */
-      CRFSUITEERR_OUTOFMEMORY,
-      /** Unsupported operation. */
-      CRFSUITEERR_NOTSUPPORTED,
-      /** Incompatible data. */
-      CRFSUITEERR_INCOMPATIBLE,
-      /** Internal error. */
-      CRFSUITEERR_INTERNAL_LOGIC,
-      /** Overflow. */
-      CRFSUITEERR_OVERFLOW,
-      /** Not implemented. */
-      CRFSUITEERR_NOTIMPLEMENTED,
-   };
-
-   /**@}*/
-
-   /**
-    * \addtogroup crfsuite_object Object interfaces and utilities.
-    * @{
-    */
-
-   struct tag_crfsuite_model;
-   /** CRFSuite model interface. */
-   typedef struct tag_crfsuite_model crfsuite_model_t;
-
-   struct tag_crfsuite_trainer;
-   /** CRFSuite trainer interface. */
-   typedef struct tag_crfsuite_trainer crfsuite_trainer_t;
-
-   struct tag_crfsuite_tagger;
-   /** CRFSuite tagger interface. */
-   typedef struct tag_crfsuite_tagger crfsuite_tagger_t;
-
-   struct tag_crfsuite_dictionary;
-   /** CRFSuite dictionary interface. */
-   typedef struct tag_crfsuite_dictionary crfsuite_dictionary_t;
-
-   struct tag_crfsuite_params;
-   /** CRFSuite parameter interface. */
-   typedef struct tag_crfsuite_params crfsuite_params_t;
-
-   /**@}*/
-
-   /**
-    * \addtogroup crfsuite_data Dataset (attribute, item, instance, dataset)
-    * @{
-    */
-
-   /**
-    * An attribute.
-    *  An attribute consists of an attribute id with its value.
-    */
-   typedef struct
-   {
-      int aid;          /**< Attribute id. */
-      floatval_t value; /**< Value of the attribute. */
-   } crfsuite_attribute_t;
-
-   /**
-    * An item.
-    *  An item consists of an array of attributes.
-    */
-   typedef struct
-   {
-      /** Number of contents associated with the item. */
-      int num_contents;
-      /** Maximum number of contents (internal use). */
-      int cap_contents;
-      /** Array of the attributes. */
-      crfsuite_attribute_t *contents;
-   } crfsuite_item_t;
-
-   /**
-    * An instance (sequence of items and labels).
-    *  An instance consists of a sequence of items and labels.
-    */
-   typedef struct
-   {
-      /** Number of items/labels in the sequence. */
-      int num_items;
-      /** Maximum number of items/labels (internal use). */
-      int cap_items;
-      /** Array of the item sequence. */
-      crfsuite_item_t *items;
-      /** Array of the label sequence. */
-      int *labels;
-      /** Instance weight. */
-      floatval_t weight;
-      /** Group ID of the instance. */
-      int group;
-   } crfsuite_instance_t;
-
-   /**
-    * A data set.
-    *  A data set consists of an array of instances and dictionary objects
-    *  for attributes and labels.
-    */
-   typedef struct
-   {
-      /** Number of instances. */
-      int num_instances;
-      /** Maximum number of instances (internal use). */
-      int cap_instances;
-      /** Array of instances. */
-      crfsuite_instance_t *instances;
-
-      /** Dictionary object for attributes. */
-      crfsuite_dictionary_t *attrs;
-      /** Dictionary object for labels. */
-      crfsuite_dictionary_t *labels;
-   } crfsuite_data_t;
-
-   /**@}*/
-
-   /**
-    * \addtogroup crfsuite_evaluation Evaluation utility
-    * @{
-    */
-
-   /**
-    * Label-wise performance values.
-    */
-   typedef struct
-   {
-      /** Number of correct predictions. */
-      int num_correct;
-      /** Number of occurrences of the label in the gold-standard data. */
-      int num_observation;
-      /** Number of predictions. */
-      int num_model;
-      /** Precision. */
-      floatval_t precision;
-      /** Recall. */
-      floatval_t recall;
-      /** F1 score. */
-      floatval_t fmeasure;
-   } crfsuite_label_evaluation_t;
-
-   /**
-    * An overall performance values.
-    */
-   typedef struct
-   {
-      /** Number of labels. */
-      int num_labels;
-      /** Array of label-wise evaluations. */
-      crfsuite_label_evaluation_t *tbl;
-
-      /** Number of correctly predicted items. */
-      int item_total_correct;
-      /** Total number of items. */
-      int item_total_num;
-      /** Total number of occurrences of labels in the gold-standard data. */
-      int item_total_observation;
-      /** Total number of predictions. */
-      int item_total_model;
-      /** Item-level accuracy. */
-      floatval_t item_accuracy;
-
-      /** Number of correctly predicted instances. */
-      int inst_total_correct;
-      /** Total number of instances. */
-      int inst_total_num;
-      /** Instance-level accuracy. */
-      floatval_t inst_accuracy;
-
-      /** Macro-averaged precision. */
-      floatval_t macro_precision;
-      /** Macro-averaged recall. */
-      floatval_t macro_recall;
-      /** Macro-averaged F1 score. */
-      floatval_t macro_fmeasure;
-   } crfsuite_evaluation_t;
-
-   /**@}*/
-
-   /**
-    * \addtogroup crfsuite_object
-    * @{
-    */
-
-   /**
-    * Type of callback function for logging.
-    *  @param  user        Pointer to the user-defined data.
-    *  @param  format      Format string (compatible with prinf()).
-    *  @param  args        Optional arguments for the format string.
-    *  @return int         \c 0 to continue; non-zero to cancel the training.
-    */
-   typedef int (*crfsuite_logging_callback)(void *user, const char *format, va_list args);
-
-   /**
-    * CRFSuite model interface.
-    */
-   struct tag_crfsuite_model
-   {
-      /**
-       * Pointer to the internal data (internal use only).
-       */
-      void *internal;
-
-      /**
-       * Reference counter (internal use only).
-       */
-      int nref;
-
-      /**
-       * Increment the reference counter.
-       *  @param  model       The pointer to this model instance.
-       *  @return int         The reference count after this increment.
-       */
-      int (*addref)(crfsuite_model_t *model);
-
-      /**
-       * Decrement the reference counter.
-       *  @param  model       The pointer to this model instance.
-       *  @return int         The reference count after this operation.
-       */
-      int (*release)(crfsuite_model_t *model);
-
-      /**
-       * Obtain the pointer to crfsuite_tagger_t interface.
-       *  @param  model       The pointer to this model instance.
-       *  @param  ptr_tagger  The pointer that receives a crfsuite_tagger_t
-       *                      pointer.
-       *  @return int         The status code.
-       */
-      int (*get_tagger)(crfsuite_model_t *model, crfsuite_tagger_t **ptr_tagger);
-
-      /**
-       * Obtain the pointer to crfsuite_dictionary_t interface for labels.
-       *  @param  model       The pointer to this model instance.
-       *  @param  ptr_labels  The pointer that receives a crfsuite_dictionary_t
-       *                      pointer.
-       *  @return int         The status code.
-       */
-      int (*get_labels)(crfsuite_model_t *model, crfsuite_dictionary_t **ptr_labels);
-
-      /**
-       * Obtain the pointer to crfsuite_dictionary_t interface for attributes.
-       *  @param  model       The pointer to this model instance.
-       *  @param  ptr_attrs   The pointer that receives a crfsuite_dictionary_t
-       *                      pointer.
-       *  @return int         The status code.
-       */
-      int (*get_attrs)(crfsuite_model_t *model, crfsuite_dictionary_t **ptr_attrs);
-
-      /**
-       * Print the learned transitions as JSON.
-       *  @param  model       The pointer to this model instance.
-       *  @param  fpo         The FILE* pointer.
-       *  @return int         The status code.
-       */
-      int (*dump_transitions)(crfsuite_model_t *model, FILE *fpo);
-
-      /**
-       * Print the learned states as JSON.
-       *  @param  model       The pointer to this model instance.
-       *  @param  fpo         The FILE* pointer.
-       *  @return int         The status code.
-       */
-      int (*dump_states)(crfsuite_model_t *model, FILE *fpo);
-   };
-
-   /**
-    * CRFSuite trainer interface.
-    */
-   struct tag_crfsuite_trainer
-   {
-      /**
-       * Pointer to the internal data (internal use only).
-       */
-      void *internal;
-
-      /**
-       * Reference counter (internal use only).
-       */
-      int nref;
-
-      /**
-       * Increment the reference counter.
-       *  @param  trainer     The pointer to this trainer instance.
-       *  @return int         The reference count after this increment.
-       */
-      int (*addref)(crfsuite_trainer_t *trainer);
-
-      /**
-       * Decrement the reference counter.
-       *  @param  trainer     The pointer to this trainer instance.
-       *  @return int         The reference count after this operation.
-       */
-      int (*release)(crfsuite_trainer_t *trainer);
-
-      /**
-       * Obtain the pointer to crfsuite_params_t interface.
-       *  @param  trainer     The pointer to this trainer instance.
-       *  @return crfsuite_params_t*  The pointer to crfsuite_params_t.
-       */
-      crfsuite_params_t *(*params)(crfsuite_trainer_t *trainer);
-
-      /**
-       * Set the callback function and user-defined data.
-       *  @param  trainer     The pointer to this trainer instance.
-       *  @param  user        The pointer to the user-defined data.
-       *  @param  cbm         The pointer to the callback function.
-       */
-      void (*set_message_callback)(crfsuite_trainer_t *trainer, void *user, crfsuite_logging_callback cbm);
-
-      /**
-       * Start a training process.
-       *  @param  trainer     The pointer to this trainer instance.
-       *  @param  data        The poiinter to the data set.
-       *  @param  filename    The filename to which the trainer stores the model.
-       *                      If an empty string is specified, this function
-       *                      does not sture the model to a file.
-       *  @param  holdout     The holdout group.
-       *  @return int         The status code.
-       */
-      int (*train)(crfsuite_trainer_t *trainer, const crfsuite_data_t *data, const char *filename, int holdout);
-   };
-
-   /**
-    * CRFSuite tagger interface.
-    */
-   struct tag_crfsuite_tagger
-   {
-      /**
-       * Pointer to the internal data (internal use only).
-       */
-      void *internal;
-
-      /**
-       * Reference counter (internal use only).
-       */
-      int nref;
-
-      /**
-       * Increment the reference counter.
-       *  @param  tagger      The pointer to this tagger instance.
-       *  @return int         The reference count after this increment.
-       */
-      int (*addref)(crfsuite_tagger_t *tagger);
-
-      /**
-       * Decrement the reference counter.
-       *  @param  tagger      The pointer to this tagger instance.
-       *  @return int         The reference count after this operation.
-       */
-      int (*release)(crfsuite_tagger_t *tagger);
-
-      /**
-       * Set an instance to the tagger.
-       *  @param  tagger      The pointer to this tagger instance.
-       *  @param  inst        The item sequence to be tagged.
-       *  @return int         The status code.
-       */
-      int (*set)(crfsuite_tagger_t *tagger, crfsuite_instance_t *inst);
-
-      /**
-       * Obtain the number of items in the current instance.
-       *  @param  tagger      The pointer to this tagger instance.
-       *  @return int         The number of items of the instance set by
-       *                      set() function.
-       *  @return int         The status code.
-       */
-      int (*length)(crfsuite_tagger_t *tagger);
-
-      /**
-       * Find the Viterbi label sequence.
-       *  @param  tagger      The pointer to this tagger instance.
-       *  @param  labels      The label array that receives the Viterbi label
-       *                      sequence. The number of elements in the array must
-       *                      be no smaller than the number of item.
-       *  @param  ptr_score   The pointer to a float variable that receives the
-       *                      score of the Viterbi label sequence.
-       *  @return int         The status code.
-       */
-      int (*viterbi)(crfsuite_tagger_t *tagger, int *labels, floatval_t *ptr_score);
-
-      /**
-       * Compute the score of a label sequence.
-       *  @param  tagger      The pointer to this tagger instance.
-       *  @param  path        The label sequence.
-       *  @param  ptr_score   The pointer to a float variable that receives the
-       *                      score of the label sequence.
-       *  @return int         The status code.
-       */
-      int (*score)(crfsuite_tagger_t *tagger, int *path, floatval_t *ptr_score);
-
-      /**
-       * Compute the log of the partition factor (normalization constant).
-       *  @param  tagger      The pointer to this tagger instance.
-       *  @param  ptr_score   The pointer to a float variable that receives the
-       *                      logarithm of the partition factor.
-       *  @return int         The status code.
-       */
-      int (*lognorm)(crfsuite_tagger_t *tagger, floatval_t *ptr_norm);
-
-      /**
-       * Compute the marginal probability of a label at a position.
-       *  This function computes P(y_t = l | x), the probability when
-       *  y_t is the label (l).
-       *  @param  tagger      The pointer to this tagger instance.
-       *  @param  l           The label.
-       *  @param  t           The position.
-       *  @param  ptr_prob    The pointer to a float variable that receives the
-       *                      marginal probability.
-       *  @return int         The status code.
-       */
-      int (*marginal_point)(crfsuite_tagger_t *tagger, int l, int t, floatval_t *ptr_prob);
-
-      /**
-       * Compute the marginal probability of a partial label sequence.
-       *  @param  tagger      The pointer to this tagger instance.
-       *  @param  path        The partial label sequence.
-       *  @param  begin       The start position of the partial label sequence.
-       *  @param  end         The last+1 position of the partial label sequence.
-       *  @param  ptr_prob    The pointer to a float variable that receives the
-       *                      marginal probability.
-       *  @return int         The status code.
-       */
-      int (*marginal_path)(crfsuite_tagger_t *tagger, const int *path, int begin, int end, floatval_t *ptr_prob);
-   };
-
-   /**
-    * CRFSuite dictionary interface.
-    */
-   struct tag_crfsuite_dictionary
-   {
-      /**
-       * Pointer to the internal data (internal use only).
-       */
-      void *internal;
-
-      /**
-       * Reference counter (internal use only).
-       */
-      int nref;
-
-      /**
-       * Increment the reference counter.
-       *  @param  dic         The pointer to this dictionary instance.
-       *  @return int         The reference count after this increment.
-       */
-      int (*addref)(crfsuite_dictionary_t *dic);
-
-      /**
-       * Decrement the reference counter.
-       *  @param  dic         The pointer to this dictionary instance.
-       *  @return int         The reference count after this operation.
-       */
-      int (*release)(crfsuite_dictionary_t *dic);
-
-      /**
-       * Assign and obtain the integer ID for the string.
-       *  @param  dic         The pointer to this dictionary instance.
-       *  @param  str         The string.
-       *  @return int         The ID associated with the string if any,
-       *                      the new ID otherwise.
-       */
-      int (*get)(crfsuite_dictionary_t *dic, const char *str);
-
-      /**
-       * Obtain the integer ID for the string.
-       *  @param  dic         The pointer to this dictionary instance.
-       *  @param  str         The string.
-       *  @return int         The ID associated with the string if any,
-       *                      \c -1 otherwise.
-       */
-      int (*to_id)(crfsuite_dictionary_t *dic, const char *str);
-
-      /**
-       * Obtain the string for the ID.
-       *  @param  dic         The pointer to this dictionary instance.
-       *  @param  id          the string ID.
-       *  @param  pstr        \c *pstr points to the string associated with
-       *                      the ID if any, \c NULL otherwise.
-       *  @return int         \c 0 if the string ID is associated with a string,
-       *                      \c 1 otherwise.
-       */
-      int (*to_string)(crfsuite_dictionary_t *dic, int id, char const **pstr);
-
-      /**
-       * Obtain the number of strings in the dictionary.
-       *  @param  dic         The pointer to this dictionary instance.
-       *  @return int         The number of strings stored in the dictionary.
-       */
-      int (*num)(crfsuite_dictionary_t *dic);
-
-      /**
-       * Free the memory block allocated by to_string() function.
-       *  @param  dic         The pointer to this dictionary instance.
-       *  @param  str         The pointer to the string whose memory block is
-       *                      freed.
-       */
-      void (*free)(crfsuite_dictionary_t *dic, const char *str);
-   };
-
-   /**
-    * CRFSuite parameter interface.
-    */
-   struct tag_crfsuite_params
-   {
-      /**
-       * Pointer to the instance data (internal use only).
-       */
-      void *internal;
-
-      /**
-       * Reference counter (internal use only).
-       */
-      int nref;
-
-      /**
-       * Increment the reference counter.
-       *  @param  params      The pointer to this parameter instance.
-       *  @return int         The reference count after this increment.
-       */
-      int (*addref)(crfsuite_params_t *params);
-
-      /**
-       * Decrement the reference counter.
-       *  @param  params      The pointer to this parameter instance.
-       *  @return int         The reference count after this operation.
-       */
-      int (*release)(crfsuite_params_t *params);
-
-      /**
-       * Obtain the number of available parameters.
-       *  @param  params      The pointer to this parameter instance.
-       *  @return int         The number of parameters maintained by this object.
-       */
-      int (*num)(crfsuite_params_t *params);
-
-      /**
-       * Obtain the name of a parameter.
-       *  @param  params      The pointer to this parameter instance.
-       *  @param  i           The parameter index.
-       *  @param  ptr_name    *ptr_name points to the parameter name.
-       *  @return int         \c 0 always.
-       */
-      int (*name)(crfsuite_params_t *params, int i, char **ptr_name);
-
-      /**
-       * Set a parameter value.
-       *  @param  params      The pointer to this parameter instance.
-       *  @param  name        The parameter name.
-       *  @param  value       The parameter value in string format.
-       *  @return int         \c 0 if the parameter is found, \c -1 otherwise.
-       */
-      int (*set)(crfsuite_params_t *params, const char *name, const char *value);
-
-      /**
-       * Get a parameter value.
-       *  @param  params      The pointer to this parameter instance.
-       *  @param  name        The parameter name.
-       *  @param  ptr_value   *ptr_value presents the parameter value in string
-       *                      format.
-       *  @return int         \c 0 if the parameter is found, \c -1 otherwise.
-       */
-      int (*get)(crfsuite_params_t *params, const char *name, char **ptr_value);
-
-      /**
-       * Set an integer value of a parameter.
-       *  @param  params      The pointer to this parameter instance.
-       *  @param  name        The parameter name.
-       *  @param  value       The parameter value.
-       *  @return int         \c 0 if the parameter value is set successfully,
-       *                      \c -1 otherwise (unknown parameter or incompatible
-       *                      type).
-       */
-      int (*set_int)(crfsuite_params_t *params, const char *name, int value);
-
-      /**
-       * Set a float value of a parameter.
-       *  @param  params      The pointer to this parameter instance.
-       *  @param  name        The parameter name.
-       *  @param  value       The parameter value.
-       *  @return int         \c 0 if the parameter value is set successfully,
-       *                      \c -1 otherwise (unknown parameter or incompatible
-       *                      type).
-       */
-      int (*set_float)(crfsuite_params_t *params, const char *name, floatval_t value);
-
-      /**
-       * Set a string value of a parameter.
-       *  @param  params      The pointer to this parameter instance.
-       *  @param  name        The parameter name.
-       *  @param  value       The parameter value.
-       *  @return int         \c 0 if the parameter value is set successfully,
-       *                      \c -1 otherwise (unknown parameter or incompatible
-       *                      type).
-       */
-      int (*set_string)(crfsuite_params_t *params, const char *name, const char *value);
-
-      /**
-       * Get an integer value of a parameter.
-       *  @param  params      The pointer to this parameter instance.
-       *  @param  name        The parameter name.
-       *  @param  ptr_value   The pointer to a variable that receives the
-       *                      integer value.
-       *  @return int         \c 0 if the parameter value is obtained
-       *                      successfully, \c -1 otherwise (unknown parameter
-       *                      or incompatible type).
-       */
-      int (*get_int)(crfsuite_params_t *params, const char *name, int *ptr_value);
-
-      /**
-       * Get a float value of a parameter.
-       *  @param  params      The pointer to this parameter instance.
-       *  @param  name        The parameter name.
-       *  @param  ptr_value   The pointer to a variable that receives the
-       *                      float value.
-       *  @return int         \c 0 if the parameter value is obtained
-       *                      successfully, \c -1 otherwise (unknown parameter
-       *                      or incompatible type).
-       */
-      int (*get_float)(crfsuite_params_t *params, const char *name, floatval_t *ptr_value);
-
-      /**
-       * Get a string value of a parameter.
-       *  @param  params      The pointer to this parameter instance.
-       *  @param  name        The parameter name.
-       *  @param  ptr_value   *ptr_value presents the parameter value.
-       *  @return int         \c 0 if the parameter value is obtained
-       *                      successfully, \c -1 otherwise (unknown parameter
-       *                      or incompatible type).
-       */
-      int (*get_string)(crfsuite_params_t *params, const char *name, char **ptr_value);
-
-      /**
-       * Get the help message of a parameter.
-       *  @param  params      The pointer to this parameter instance.
-       *  @param  name        The parameter name.
-       *  @param  ptr_type    The pointer to \c char* to which this function
-       *                      store the type of the parameter.
-       *  @param  ptr_help    The pointer to \c char* to which this function
-       *                      store the help message of the parameter.
-       *  @return int         \c 0 if the parameter is found, \c -1 otherwise.
-       */
-      int (*help)(crfsuite_params_t *params, const char *name, char **ptr_type, char **ptr_help);
-
-      /**
-       * Free the memory block of a string allocated by this object.
-       *  @param  params      The pointer to this parameter instance.
-       *  @param  str         The pointer to the string.
-       */
-      void (*free)(crfsuite_params_t *params, const char *str);
-   };
-
-   /**@}*/
-
-   /**
-    * \addtogroup crfsuite_object
-    * @{
-    */
-
-   /**
-    * Create an instance of an object by an interface identifier.
-    *  @param  iid         The interface identifier.
-    *  @param  ptr         The pointer to \c void* that points to the
-    *                      instance of the object if successful,
-    *                      *ptr points to \c NULL otherwise.
-    *  @return int         \c 1 if this function creates an object successfully,
-    *                      \c 0 otherwise. Note that this is inconsistent with the
-    *                      other CRFsuite API calls.
-    */
-   int crfsuite_create_instance(const char *iid, void **ptr);
-
-   /**
-    * Create an instance of a model object from a model file.
-    *  @param  filename    The filename of the model.
-    *  @param  ptr         The pointer to \c void* that points to the
-    *                      instance of the model object if successful,
-    *                      *ptr points to \c NULL otherwise.
-    *  @return int         \c 0 if this function creates an object successfully,
-    *                      \c 1 otherwise.
-    */
-   int crfsuite_create_instance_from_file(const char *filename, void **ptr);
-
-   /**
-    * Create an instance of a model object from a model in memory.
-    *  @param  data        A pointer to the model data.
-    *                      Must be 16-byte aligned.
-    *  @param  size        A size (in bytes) of the model data.
-    *  @param  ptr         The pointer to \c void* that points to the
-    *                      instance of the model object if successful,
-    *                      *ptr points to \c NULL otherwise.
-    *  @return int         \c 0 if this function creates an object successfully,
-    *                      \c 1 otherwise
-    */
-   int crfsuite_create_instance_from_memory(const void *data, size_t size, void **ptr);
-
-   /**
-    * Create instances of tagging object from a model file.
-    *  @param  filename    The filename of the model.
-    *  @param  ptr_tagger  The pointer to \c void* that points to the
-    *                      instance of the tagger object if successful,
-    *                      *ptr points to \c NULL otherwise.
-    *  @param  ptr_attrs   The pointer to \c void* that points to the
-    *                      instance of the dictionary object for attributes
-    *                      if successful, *ptr points to \c NULL otherwise.
-    *  @param  ptr_labels  The pointer to \c void* that points to the
-    *                      instance of the dictionary object for labels
-    *                      if successful, *ptr points to \c NULL otherwise.
-    *  @return int         \c 0 if this function creates an object successfully,
-    *                      \c 1 otherwise.
-    */
-   int crfsuite_create_tagger(
-       const char *filename,
-       crfsuite_tagger_t **ptr_tagger,
-       crfsuite_dictionary_t **ptr_attrs,
-       crfsuite_dictionary_t **ptr_labels);
-
-   /**@}*/
-
-   /**
-    * \addtogroup crfsuite_data
-    * @{
-    */
-
-   /**
-    * Initialize an attribute structure.
-    *  @param  attr        The pointer to crfsuite_attribute_t.
-    */
-   void crfsuite_attribute_init(crfsuite_attribute_t *attr);
-
-   /**
-    * Set an attribute and its value.
-    *  @param  attr        The pointer to crfsuite_attribute_t.
-    *  @param  aid         The attribute identifier.
-    *  @param  value       The attribute value.
-    */
-   void crfsuite_attribute_set(crfsuite_attribute_t *attr, int aid, floatval_t value);
-
-   /**
-    * Copy the content of an attribute structure.
-    *  @param  dst         The pointer to the destination.
-    *  @param  src         The pointer to the source.
-    */
-   void crfsuite_attribute_copy(crfsuite_attribute_t *dst, const crfsuite_attribute_t *src);
-
-   /**
-    * Swap the contents of two attribute structures.
-    *  @param  x           The pointer to an attribute structure.
-    *  @param  y           The pointer to another attribute structure.
-    */
-   void crfsuite_attribute_swap(crfsuite_attribute_t *x, crfsuite_attribute_t *y);
-
-   /**
-    * Initialize an item structure.
-    *  @param  item        The pointer to crfsuite_item_t.
-    */
-   void crfsuite_item_init(crfsuite_item_t *item);
-
-   /**
-    * Initialize an item structure with the number of attributes.
-    *  @param  item        The pointer to crfsuite_item_t.
-    *  @param  num_attributes  The number of attributes.
-    */
-   void crfsuite_item_init_n(crfsuite_item_t *item, int num_attributes);
-
-   /**
-    * Uninitialize an item structure.
-    *  @param  item        The pointer to crfsuite_item_t.
-    */
-   void crfsuite_item_finish(crfsuite_item_t *item);
-
-   /**
-    * Copy the content of an item structure.
-    *  @param  dst         The pointer to the destination.
-    *  @param  src         The pointer to the source.
-    */
-   void crfsuite_item_copy(crfsuite_item_t *dst, const crfsuite_item_t *src);
-
-   /**
-    * Swap the contents of two item structures.
-    *  @param  x           The pointer to an item structure.
-    *  @param  y           The pointer to another item structure.
-    */
-   void crfsuite_item_swap(crfsuite_item_t *x, crfsuite_item_t *y);
-
-   /**
-    * Append an attribute to the item structure.
-    *  @param  item        The pointer to crfsuite_item_t.
-    *  @param  attr        The attribute to be added to the item.
-    *  @return int         \c 0 if successful, \c -1 otherwise.
-    */
-   int crfsuite_item_append_attribute(crfsuite_item_t *item, const crfsuite_attribute_t *attr);
-
-   /**
-    * Check whether the item has no attribute.
-    *  @param  item        The pointer to crfsuite_item_t.
-    *  @return int         \c 1 if the item has no attribute, \c 0 otherwise.
-    */
-   int crfsuite_item_empty(crfsuite_item_t *item);
-
-   /**
-    * Initialize an instance structure.
-    *  @param  seq         The pointer to crfsuite_instance_t.
-    */
-   void crfsuite_instance_init(crfsuite_instance_t *seq);
-
-   /**
-    * Initialize an instance structure with the number of items.
-    *  @param  seq         The pointer to crfsuite_instance_t.
-    *  @param  num_items   The number of items.
-    */
-   void crfsuite_instance_init_n(crfsuite_instance_t *seq, int num_items);
-
-   /**
-    * Uninitialize an instance structure.
-    *  @param  seq         The pointer to crfsuite_instance_t.
-    */
-   void crfsuite_instance_finish(crfsuite_instance_t *seq);
-
-   /**
-    * Copy the content of an instance structure.
-    *  @param  dst         The pointer to the destination.
-    *  @param  src         The pointer to the source.
-    */
-   void crfsuite_instance_copy(crfsuite_instance_t *dst, const crfsuite_instance_t *src);
-
-   /**
-    * Swap the contents of two instance structures.
-    *  @param  x           The pointer to an instance structure.
-    *  @param  y           The pointer to another instance structure.
-    */
-   void crfsuite_instance_swap(crfsuite_instance_t *x, crfsuite_instance_t *y);
-
-   /**
-    * Append a pair of item and label to the instance structure.
-    *  @param  seq         The pointer to crfsuite_instance_t.
-    *  @param  item        The item to be added to the instance.
-    *  @param  label       The label to be added to the instance.
-    *  @return int         \c 0 if successful, \c -1 otherwise.
-    */
-   int crfsuite_instance_append(crfsuite_instance_t *seq, const crfsuite_item_t *item, int label);
-
-   /**
-    * Check whether the instance has no item.
-    *  @param  seq         The pointer to crfsuite_instance_t.
-    *  @return int         \c 1 if the instance has no attribute, \c 0 otherwise.
-    */
-   int crfsuite_instance_empty(crfsuite_instance_t *seq);
-
-   /**
-    * Initialize a dataset structure.
-    *  @param  data        The pointer to crfsuite_data_t.
-    */
-   void crfsuite_data_init(crfsuite_data_t *data);
-
-   /**
-    * Initialize a dataset structure with the number of instances.
-    *  @param  data        The pointer to crfsuite_data_t.
-    *  @param  n           The number of instances.
-    */
-   void crfsuite_data_init_n(crfsuite_data_t *data, int n);
-
-   /**
-    * Uninitialize a dataset structure.
-    *  @param  data        The pointer to crfsuite_data_t.
-    */
-   void crfsuite_data_finish(crfsuite_data_t *data);
-
-   /**
-    * Copy the content of a dataset structure.
-    *  @param  dst         The pointer to the destination.
-    *  @param  src         The pointer to the source.
-    */
-   void crfsuite_data_copy(crfsuite_data_t *dst, const crfsuite_data_t *src);
-
-   /**
-    * Swap the contents of two dataset structures.
-    *  @param  x           The pointer to a dataset structure.
-    *  @param  y           The pointer to another dataset structure.
-    */
-   void crfsuite_data_swap(crfsuite_data_t *x, crfsuite_data_t *y);
-
-   /**
-    * Append an instance to the dataset structure.
-    *  @param  data        The pointer to crfsuite_data_t.
-    *  @param  inst        The instance to be added to the dataset.
-    *  @return int         \c 0 if successful, \c -1 otherwise.
-    */
-   int crfsuite_data_append(crfsuite_data_t *data, const crfsuite_instance_t *inst);
-
-   /**
-    * Obtain the maximum length of the instances in the dataset.
-    *  @param  data        The pointer to crfsuite_data_t.
-    *  @return int         The maximum number of items of the instances in the
-    *                      dataset.
-    */
-   int crfsuite_data_maxlength(crfsuite_data_t *data);
-
-   /**
-    * Obtain the total number of items in the dataset.
-    *  @param  data        The pointer to crfsuite_data_t.
-    *  @return int         The total number of items in the dataset.
-    */
-   int crfsuite_data_totalitems(crfsuite_data_t *data);
-
-   /**@}*/
-
-   /**
-    * \addtogroup crfsuite_evaluation
-    */
-   /**@{*/
-
-   /**
-    * Initialize an evaluation structure.
-    *  @param  eval        The pointer to crfsuite_evaluation_t.
-    *  @param  n           The number of labels in the dataset.
-    */
-   void crfsuite_evaluation_init(crfsuite_evaluation_t *eval, int n);
-
-   /**
-    * Uninitialize an evaluation structure.
-    *  @param  eval        The pointer to crfsuite_evaluation_t.
-    */
-   void crfsuite_evaluation_finish(crfsuite_evaluation_t *eval);
-
-   /**
-    * Reset an evaluation structure.
-    *  @param  eval        The pointer to crfsuite_evaluation_t.
-    */
-   void crfsuite_evaluation_clear(crfsuite_evaluation_t *eval);
-
-   /**
-    * Accmulate the correctness of the predicted label sequence.
-    *  @param  eval        The pointer to crfsuite_evaluation_t.
-    *  @param  reference   The reference label sequence.
-    *  @param  prediction  The predicted label sequence.
-    *  @param  T           The length of the label sequence.
-    *  @return int         \c 0 if succeeded, \c 1 otherwise.
-    */
-   int crfsuite_evaluation_accmulate(crfsuite_evaluation_t *eval, const int *reference, const int *prediction, int T);
-
-   /**
-    * Finalize the evaluation result.
-    *  @param  eval        The pointer to crfsuite_evaluation_t.
-    */
-   void crfsuite_evaluation_finalize(crfsuite_evaluation_t *eval);
-
-   /**
-    * Print the evaluation result.
-    *  @param  eval        The pointer to crfsuite_evaluation_t.
-    *  @param  labels      The pointer to the label dictionary.
-    *  @param  cbm         The callback function to receive the evaluation result.
-    *  @param  user        The pointer to the user data that is forwarded to the
-    *                      callback function.
-    */
-   void crfsuite_evaluation_output(crfsuite_evaluation_t *eval, crfsuite_dictionary_t *labels, crfsuite_logging_callback cbm, void *user);
-
-   /**@}*/
-
-   /**
-    * \addtogroup crfsuite_misc Miscellaneous definitions and functions
-    * @{
-    */
-
-   /**
-    * Increments the value of the integer variable as an atomic operation.
-    *  @param  count       The pointer to the integer variable.
-    *  @return             The value after this increment.
-    */
-   int crfsuite_interlocked_increment(int *count);
-
-   /**
-    * Decrements the value of the integer variable as an atomic operation.
-    *  @param  count       The pointer to the integer variable.
-    *  @return             The value after this decrement.
-    */
-   int crfsuite_interlocked_decrement(int *count);
-
-   /**@}*/
-
-   /**@}*/
-
-   /**
-@mainpage CRFsuite: a fast implementation of Conditional Random Fields (CRFs)
-
-@section intro Introduction
-
-This document describes information for using
-<a href="http://www.chokkan.org/software/crfsuite">CRFsuite</a> from external
-programs. CRFsuite provides two APIs:
-- @link crfsuite_api C API @endlink: low-level and complete interface, which
- is used by the official frontend program.
-- @link crfsuite_hpp_api C++/SWIG API @endlink: high-level and easy-to-use
- interface for a number of programming languages (e.g, C++ and Python),
- which is a wrapper for the C API.
-
-*/
-
-#ifdef __cplusplus
-}
-#endif /*__cplusplus*/
-
-#endif /*__CRFSUITE_H__*/
+/*
+ *      CRFsuite library.
+ *
+ * Copyright (c) 2007-2010, Naoaki Okazaki
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the names of the authors nor the names of its contributors
+ *       may be used to endorse or promote products derived from this
+ *       software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+ * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/* $Id$ */
+
+#ifndef __CRFSUITE_H__
+#define __CRFSUITE_H__
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif /*__cplusplus*/
+
+#include <limits.h>
+#include <stdio.h>
+#include <stdarg.h>
+
+/**
+ * \addtogroup crfsuite_api CRFSuite C API
+ * @{
+ *
+ *  The CRFSuite C API provides a low-level library for manupulating
+ *  CRFSuite in C language.
+ */
+
+/**
+ * \addtogroup crfsuite_misc Miscellaneous definitions and functions
+ * @{
+ */
+
+/** Version number of CRFSuite library. */
+#define CRFSUITE_VERSION "0.12.2"
+
+/** Copyright string of CRFSuite library. */
+#define CRFSUITE_COPYRIGHT "Copyright (c) 2007-2013 Naoaki Okazaki"
+
+   /** Type of a float value. */
+   typedef double floatval_t;
+
+/** Maximum value of a float value. */
+#define FLOAT_MAX DBL_MAX
+
+   /**
+    * Status codes.
+    */
+   enum
+   {
+      /** Success. */
+      CRFSUITE_SUCCESS = 0,
+      /** Unknown error occurred. */
+      CRFSUITEERR_UNKNOWN = INT_MIN,
+      /** Insufficient memory. */
+      CRFSUITEERR_OUTOFMEMORY,
+      /** Unsupported operation. */
+      CRFSUITEERR_NOTSUPPORTED,
+      /** Incompatible data. */
+      CRFSUITEERR_INCOMPATIBLE,
+      /** Internal error. */
+      CRFSUITEERR_INTERNAL_LOGIC,
+      /** Overflow. */
+      CRFSUITEERR_OVERFLOW,
+      /** Not implemented. */
+      CRFSUITEERR_NOTIMPLEMENTED,
+   };
+
+   /**@}*/
+
+   /**
+    * \addtogroup crfsuite_object Object interfaces and utilities.
+    * @{
+    */
+
+   struct tag_crfsuite_model;
+   /** CRFSuite model interface. */
+   typedef struct tag_crfsuite_model crfsuite_model_t;
+
+   struct tag_crfsuite_trainer;
+   /** CRFSuite trainer interface. */
+   typedef struct tag_crfsuite_trainer crfsuite_trainer_t;
+
+   struct tag_crfsuite_tagger;
+   /** CRFSuite tagger interface. */
+   typedef struct tag_crfsuite_tagger crfsuite_tagger_t;
+
+   struct tag_crfsuite_dictionary;
+   /** CRFSuite dictionary interface. */
+   typedef struct tag_crfsuite_dictionary crfsuite_dictionary_t;
+
+   struct tag_crfsuite_params;
+   /** CRFSuite parameter interface. */
+   typedef struct tag_crfsuite_params crfsuite_params_t;
+
+   /**@}*/
+
+   /**
+    * \addtogroup crfsuite_data Dataset (attribute, item, instance, dataset)
+    * @{
+    */
+
+   /**
+    * An attribute.
+    *  An attribute consists of an attribute id with its value.
+    */
+   typedef struct
+   {
+      int aid;          /**< Attribute id. */
+      floatval_t value; /**< Value of the attribute. */
+   } crfsuite_attribute_t;
+
+   /**
+    * An item.
+    *  An item consists of an array of attributes.
+    */
+   typedef struct
+   {
+      /** Number of contents associated with the item. */
+      int num_contents;
+      /** Maximum number of contents (internal use). */
+      int cap_contents;
+      /** Array of the attributes. */
+      crfsuite_attribute_t *contents;
+   } crfsuite_item_t;
+
+   /**
+    * An instance (sequence of items and labels).
+    *  An instance consists of a sequence of items and labels.
+    */
+   typedef struct
+   {
+      /** Number of items/labels in the sequence. */
+      int num_items;
+      /** Maximum number of items/labels (internal use). */
+      int cap_items;
+      /** Array of the item sequence. */
+      crfsuite_item_t *items;
+      /** Array of the label sequence. */
+      int *labels;
+      /** Instance weight. */
+      floatval_t weight;
+      /** Group ID of the instance. */
+      int group;
+   } crfsuite_instance_t;
+
+   /**
+    * A data set.
+    *  A data set consists of an array of instances and dictionary objects
+    *  for attributes and labels.
+    */
+   typedef struct
+   {
+      /** Number of instances. */
+      int num_instances;
+      /** Maximum number of instances (internal use). */
+      int cap_instances;
+      /** Array of instances. */
+      crfsuite_instance_t *instances;
+
+      /** Dictionary object for attributes. */
+      crfsuite_dictionary_t *attrs;
+      /** Dictionary object for labels. */
+      crfsuite_dictionary_t *labels;
+   } crfsuite_data_t;
+
+   /**@}*/
+
+   /**
+    * \addtogroup crfsuite_evaluation Evaluation utility
+    * @{
+    */
+
+   /**
+    * Label-wise performance values.
+    */
+   typedef struct
+   {
+      /** Number of correct predictions. */
+      int num_correct;
+      /** Number of occurrences of the label in the gold-standard data. */
+      int num_observation;
+      /** Number of predictions. */
+      int num_model;
+      /** Precision. */
+      floatval_t precision;
+      /** Recall. */
+      floatval_t recall;
+      /** F1 score. */
+      floatval_t fmeasure;
+   } crfsuite_label_evaluation_t;
+
+   /**
+    * An overall performance values.
+    */
+   typedef struct
+   {
+      /** Number of labels. */
+      int num_labels;
+      /** Array of label-wise evaluations. */
+      crfsuite_label_evaluation_t *tbl;
+
+      /** Number of correctly predicted items. */
+      int item_total_correct;
+      /** Total number of items. */
+      int item_total_num;
+      /** Total number of occurrences of labels in the gold-standard data. */
+      int item_total_observation;
+      /** Total number of predictions. */
+      int item_total_model;
+      /** Item-level accuracy. */
+      floatval_t item_accuracy;
+
+      /** Number of correctly predicted instances. */
+      int inst_total_correct;
+      /** Total number of instances. */
+      int inst_total_num;
+      /** Instance-level accuracy. */
+      floatval_t inst_accuracy;
+
+      /** Macro-averaged precision. */
+      floatval_t macro_precision;
+      /** Macro-averaged recall. */
+      floatval_t macro_recall;
+      /** Macro-averaged F1 score. */
+      floatval_t macro_fmeasure;
+   } crfsuite_evaluation_t;
+
+   /**@}*/
+
+   /**
+    * \addtogroup crfsuite_object
+    * @{
+    */
+
+   /**
+    * Type of callback function for logging.
+    *  @param  user        Pointer to the user-defined data.
+    *  @param  format      Format string (compatible with prinf()).
+    *  @param  args        Optional arguments for the format string.
+    *  @return int         \c 0 to continue; non-zero to cancel the training.
+    */
+   typedef int (*crfsuite_logging_callback)(void *user, const char *format, va_list args);
+
+   /**
+    * CRFSuite model interface.
+    */
+   struct tag_crfsuite_model
+   {
+      /**
+       * Pointer to the internal data (internal use only).
+       */
+      void *internal;
+
+      /**
+       * Reference counter (internal use only).
+       */
+      int nref;
+
+      /**
+       * Increment the reference counter.
+       *  @param  model       The pointer to this model instance.
+       *  @return int         The reference count after this increment.
+       */
+      int (*addref)(crfsuite_model_t *model);
+
+      /**
+       * Decrement the reference counter.
+       *  @param  model       The pointer to this model instance.
+       *  @return int         The reference count after this operation.
+       */
+      int (*release)(crfsuite_model_t *model);
+
+      /**
+       * Obtain the pointer to crfsuite_tagger_t interface.
+       *  @param  model       The pointer to this model instance.
+       *  @param  ptr_tagger  The pointer that receives a crfsuite_tagger_t
+       *                      pointer.
+       *  @return int         The status code.
+       */
+      int (*get_tagger)(crfsuite_model_t *model, crfsuite_tagger_t **ptr_tagger);
+
+      /**
+       * Obtain the pointer to crfsuite_dictionary_t interface for labels.
+       *  @param  model       The pointer to this model instance.
+       *  @param  ptr_labels  The pointer that receives a crfsuite_dictionary_t
+       *                      pointer.
+       *  @return int         The status code.
+       */
+      int (*get_labels)(crfsuite_model_t *model, crfsuite_dictionary_t **ptr_labels);
+
+      /**
+       * Obtain the pointer to crfsuite_dictionary_t interface for attributes.
+       *  @param  model       The pointer to this model instance.
+       *  @param  ptr_attrs   The pointer that receives a crfsuite_dictionary_t
+       *                      pointer.
+       *  @return int         The status code.
+       */
+      int (*get_attrs)(crfsuite_model_t *model, crfsuite_dictionary_t **ptr_attrs);
+
+      /**
+       * Print the learned transitions as JSON.
+       *  @param  model       The pointer to this model instance.
+       *  @param  fpo         The FILE* pointer.
+       *  @return int         The status code.
+       */
+      int (*dump_transitions)(crfsuite_model_t *model, FILE *fpo);
+
+      /**
+       * Print the learned states as JSON.
+       *  @param  model       The pointer to this model instance.
+       *  @param  fpo         The FILE* pointer.
+       *  @return int         The status code.
+       */
+      int (*dump_states)(crfsuite_model_t *model, FILE *fpo);
+   };
+
+   /**
+    * CRFSuite trainer interface.
+    */
+   struct tag_crfsuite_trainer
+   {
+      /**
+       * Pointer to the internal data (internal use only).
+       */
+      void *internal;
+
+      /**
+       * Reference counter (internal use only).
+       */
+      int nref;
+
+      /**
+       * Increment the reference counter.
+       *  @param  trainer     The pointer to this trainer instance.
+       *  @return int         The reference count after this increment.
+       */
+      int (*addref)(crfsuite_trainer_t *trainer);
+
+      /**
+       * Decrement the reference counter.
+       *  @param  trainer     The pointer to this trainer instance.
+       *  @return int         The reference count after this operation.
+       */
+      int (*release)(crfsuite_trainer_t *trainer);
+
+      /**
+       * Obtain the pointer to crfsuite_params_t interface.
+       *  @param  trainer     The pointer to this trainer instance.
+       *  @return crfsuite_params_t*  The pointer to crfsuite_params_t.
+       */
+      crfsuite_params_t *(*params)(crfsuite_trainer_t *trainer);
+
+      /**
+       * Set the callback function and user-defined data.
+       *  @param  trainer     The pointer to this trainer instance.
+       *  @param  user        The pointer to the user-defined data.
+       *  @param  cbm         The pointer to the callback function.
+       */
+      void (*set_message_callback)(crfsuite_trainer_t *trainer, void *user, crfsuite_logging_callback cbm);
+
+      /**
+       * Start a training process.
+       *  @param  trainer     The pointer to this trainer instance.
+       *  @param  data        The poiinter to the data set.
+       *  @param  filename    The filename to which the trainer stores the model.
+       *                      If an empty string is specified, this function
+       *                      does not sture the model to a file.
+       *  @param  holdout     The holdout group.
+       *  @return int         The status code.
+       */
+      int (*train)(crfsuite_trainer_t *trainer, const crfsuite_data_t *data, const char *filename, int holdout);
+   };
+
+   /**
+    * CRFSuite tagger interface.
+    */
+   struct tag_crfsuite_tagger
+   {
+      /**
+       * Pointer to the internal data (internal use only).
+       */
+      void *internal;
+
+      /**
+       * Reference counter (internal use only).
+       */
+      int nref;
+
+      /**
+       * Increment the reference counter.
+       *  @param  tagger      The pointer to this tagger instance.
+       *  @return int         The reference count after this increment.
+       */
+      int (*addref)(crfsuite_tagger_t *tagger);
+
+      /**
+       * Decrement the reference counter.
+       *  @param  tagger      The pointer to this tagger instance.
+       *  @return int         The reference count after this operation.
+       */
+      int (*release)(crfsuite_tagger_t *tagger);
+
+      /**
+       * Set an instance to the tagger.
+       *  @param  tagger      The pointer to this tagger instance.
+       *  @param  inst        The item sequence to be tagged.
+       *  @return int         The status code.
+       */
+      int (*set)(crfsuite_tagger_t *tagger, crfsuite_instance_t *inst);
+
+      /**
+       * Obtain the number of items in the current instance.
+       *  @param  tagger      The pointer to this tagger instance.
+       *  @return int         The number of items of the instance set by
+       *                      set() function.
+       *  @return int         The status code.
+       */
+      int (*length)(crfsuite_tagger_t *tagger);
+
+      /**
+       * Find the Viterbi label sequence.
+       *  @param  tagger      The pointer to this tagger instance.
+       *  @param  labels      The label array that receives the Viterbi label
+       *                      sequence. The number of elements in the array must
+       *                      be no smaller than the number of item.
+       *  @param  ptr_score   The pointer to a float variable that receives the
+       *                      score of the Viterbi label sequence.
+       *  @return int         The status code.
+       */
+      int (*viterbi)(crfsuite_tagger_t *tagger, int *labels, floatval_t *ptr_score);
+
+      /**
+       * Compute the score of a label sequence.
+       *  @param  tagger      The pointer to this tagger instance.
+       *  @param  path        The label sequence.
+       *  @param  ptr_score   The pointer to a float variable that receives the
+       *                      score of the label sequence.
+       *  @return int         The status code.
+       */
+      int (*score)(crfsuite_tagger_t *tagger, int *path, floatval_t *ptr_score);
+
+      /**
+       * Compute the log of the partition factor (normalization constant).
+       *  @param  tagger      The pointer to this tagger instance.
+       *  @param  ptr_score   The pointer to a float variable that receives the
+       *                      logarithm of the partition factor.
+       *  @return int         The status code.
+       */
+      int (*lognorm)(crfsuite_tagger_t *tagger, floatval_t *ptr_norm);
+
+      /**
+       * Compute the marginal probability of a label at a position.
+       *  This function computes P(y_t = l | x), the probability when
+       *  y_t is the label (l).
+       *  @param  tagger      The pointer to this tagger instance.
+       *  @param  l           The label.
+       *  @param  t           The position.
+       *  @param  ptr_prob    The pointer to a float variable that receives the
+       *                      marginal probability.
+       *  @return int         The status code.
+       */
+      int (*marginal_point)(crfsuite_tagger_t *tagger, int l, int t, floatval_t *ptr_prob);
+
+      /**
+       * Compute the marginal probability of a partial label sequence.
+       *  @param  tagger      The pointer to this tagger instance.
+       *  @param  path        The partial label sequence.
+       *  @param  begin       The start position of the partial label sequence.
+       *  @param  end         The last+1 position of the partial label sequence.
+       *  @param  ptr_prob    The pointer to a float variable that receives the
+       *                      marginal probability.
+       *  @return int         The status code.
+       */
+      int (*marginal_path)(crfsuite_tagger_t *tagger, const int *path, int begin, int end, floatval_t *ptr_prob);
+   };
+
+   /**
+    * CRFSuite dictionary interface.
+    */
+   struct tag_crfsuite_dictionary
+   {
+      /**
+       * Pointer to the internal data (internal use only).
+       */
+      void *internal;
+
+      /**
+       * Reference counter (internal use only).
+       */
+      int nref;
+
+      /**
+       * Increment the reference counter.
+       *  @param  dic         The pointer to this dictionary instance.
+       *  @return int         The reference count after this increment.
+       */
+      int (*addref)(crfsuite_dictionary_t *dic);
+
+      /**
+       * Decrement the reference counter.
+       *  @param  dic         The pointer to this dictionary instance.
+       *  @return int         The reference count after this operation.
+       */
+      int (*release)(crfsuite_dictionary_t *dic);
+
+      /**
+       * Assign and obtain the integer ID for the string.
+       *  @param  dic         The pointer to this dictionary instance.
+       *  @param  str         The string.
+       *  @return int         The ID associated with the string if any,
+       *                      the new ID otherwise.
+       */
+      int (*get)(crfsuite_dictionary_t *dic, const char *str);
+
+      /**
+       * Obtain the integer ID for the string.
+       *  @param  dic         The pointer to this dictionary instance.
+       *  @param  str         The string.
+       *  @return int         The ID associated with the string if any,
+       *                      \c -1 otherwise.
+       */
+      int (*to_id)(crfsuite_dictionary_t *dic, const char *str);
+
+      /**
+       * Obtain the string for the ID.
+       *  @param  dic         The pointer to this dictionary instance.
+       *  @param  id          the string ID.
+       *  @param  pstr        \c *pstr points to the string associated with
+       *                      the ID if any, \c NULL otherwise.
+       *  @return int         \c 0 if the string ID is associated with a string,
+       *                      \c 1 otherwise.
+       */
+      int (*to_string)(crfsuite_dictionary_t *dic, int id, char const **pstr);
+
+      /**
+       * Obtain the number of strings in the dictionary.
+       *  @param  dic         The pointer to this dictionary instance.
+       *  @return int         The number of strings stored in the dictionary.
+       */
+      int (*num)(crfsuite_dictionary_t *dic);
+
+      /**
+       * Free the memory block allocated by to_string() function.
+       *  @param  dic         The pointer to this dictionary instance.
+       *  @param  str         The pointer to the string whose memory block is
+       *                      freed.
+       */
+      void (*free)(crfsuite_dictionary_t *dic, const char *str);
+   };
+
+   /**
+    * CRFSuite parameter interface.
+    */
+   struct tag_crfsuite_params
+   {
+      /**
+       * Pointer to the instance data (internal use only).
+       */
+      void *internal;
+
+      /**
+       * Reference counter (internal use only).
+       */
+      int nref;
+
+      /**
+       * Increment the reference counter.
+       *  @param  params      The pointer to this parameter instance.
+       *  @return int         The reference count after this increment.
+       */
+      int (*addref)(crfsuite_params_t *params);
+
+      /**
+       * Decrement the reference counter.
+       *  @param  params      The pointer to this parameter instance.
+       *  @return int         The reference count after this operation.
+       */
+      int (*release)(crfsuite_params_t *params);
+
+      /**
+       * Obtain the number of available parameters.
+       *  @param  params      The pointer to this parameter instance.
+       *  @return int         The number of parameters maintained by this object.
+       */
+      int (*num)(crfsuite_params_t *params);
+
+      /**
+       * Obtain the name of a parameter.
+       *  @param  params      The pointer to this parameter instance.
+       *  @param  i           The parameter index.
+       *  @param  ptr_name    *ptr_name points to the parameter name.
+       *  @return int         \c 0 always.
+       */
+      int (*name)(crfsuite_params_t *params, int i, char **ptr_name);
+
+      /**
+       * Set a parameter value.
+       *  @param  params      The pointer to this parameter instance.
+       *  @param  name        The parameter name.
+       *  @param  value       The parameter value in string format.
+       *  @return int         \c 0 if the parameter is found, \c -1 otherwise.
+       */
+      int (*set)(crfsuite_params_t *params, const char *name, const char *value);
+
+      /**
+       * Get a parameter value.
+       *  @param  params      The pointer to this parameter instance.
+       *  @param  name        The parameter name.
+       *  @param  ptr_value   *ptr_value presents the parameter value in string
+       *                      format.
+       *  @return int         \c 0 if the parameter is found, \c -1 otherwise.
+       */
+      int (*get)(crfsuite_params_t *params, const char *name, char **ptr_value);
+
+      /**
+       * Set an integer value of a parameter.
+       *  @param  params      The pointer to this parameter instance.
+       *  @param  name        The parameter name.
+       *  @param  value       The parameter value.
+       *  @return int         \c 0 if the parameter value is set successfully,
+       *                      \c -1 otherwise (unknown parameter or incompatible
+       *                      type).
+       */
+      int (*set_int)(crfsuite_params_t *params, const char *name, int value);
+
+      /**
+       * Set a float value of a parameter.
+       *  @param  params      The pointer to this parameter instance.
+       *  @param  name        The parameter name.
+       *  @param  value       The parameter value.
+       *  @return int         \c 0 if the parameter value is set successfully,
+       *                      \c -1 otherwise (unknown parameter or incompatible
+       *                      type).
+       */
+      int (*set_float)(crfsuite_params_t *params, const char *name, floatval_t value);
+
+      /**
+       * Set a string value of a parameter.
+       *  @param  params      The pointer to this parameter instance.
+       *  @param  name        The parameter name.
+       *  @param  value       The parameter value.
+       *  @return int         \c 0 if the parameter value is set successfully,
+       *                      \c -1 otherwise (unknown parameter or incompatible
+       *                      type).
+       */
+      int (*set_string)(crfsuite_params_t *params, const char *name, const char *value);
+
+      /**
+       * Get an integer value of a parameter.
+       *  @param  params      The pointer to this parameter instance.
+       *  @param  name        The parameter name.
+       *  @param  ptr_value   The pointer to a variable that receives the
+       *                      integer value.
+       *  @return int         \c 0 if the parameter value is obtained
+       *                      successfully, \c -1 otherwise (unknown parameter
+       *                      or incompatible type).
+       */
+      int (*get_int)(crfsuite_params_t *params, const char *name, int *ptr_value);
+
+      /**
+       * Get a float value of a parameter.
+       *  @param  params      The pointer to this parameter instance.
+       *  @param  name        The parameter name.
+       *  @param  ptr_value   The pointer to a variable that receives the
+       *                      float value.
+       *  @return int         \c 0 if the parameter value is obtained
+       *                      successfully, \c -1 otherwise (unknown parameter
+       *                      or incompatible type).
+       */
+      int (*get_float)(crfsuite_params_t *params, const char *name, floatval_t *ptr_value);
+
+      /**
+       * Get a string value of a parameter.
+       *  @param  params      The pointer to this parameter instance.
+       *  @param  name        The parameter name.
+       *  @param  ptr_value   *ptr_value presents the parameter value.
+       *  @return int         \c 0 if the parameter value is obtained
+       *                      successfully, \c -1 otherwise (unknown parameter
+       *                      or incompatible type).
+       */
+      int (*get_string)(crfsuite_params_t *params, const char *name, char **ptr_value);
+
+      /**
+       * Get the help message of a parameter.
+       *  @param  params      The pointer to this parameter instance.
+       *  @param  name        The parameter name.
+       *  @param  ptr_type    The pointer to \c char* to which this function
+       *                      store the type of the parameter.
+       *  @param  ptr_help    The pointer to \c char* to which this function
+       *                      store the help message of the parameter.
+       *  @return int         \c 0 if the parameter is found, \c -1 otherwise.
+       */
+      int (*help)(crfsuite_params_t *params, const char *name, char **ptr_type, char **ptr_help);
+
+      /**
+       * Free the memory block of a string allocated by this object.
+       *  @param  params      The pointer to this parameter instance.
+       *  @param  str         The pointer to the string.
+       */
+      void (*free)(crfsuite_params_t *params, const char *str);
+   };
+
+   /**@}*/
+
+   /**
+    * \addtogroup crfsuite_object
+    * @{
+    */
+
+   /**
+    * Create an instance of an object by an interface identifier.
+    *  @param  iid         The interface identifier.
+    *  @param  ptr         The pointer to \c void* that points to the
+    *                      instance of the object if successful,
+    *                      *ptr points to \c NULL otherwise.
+    *  @return int         \c 1 if this function creates an object successfully,
+    *                      \c 0 otherwise. Note that this is inconsistent with the
+    *                      other CRFsuite API calls.
+    */
+   int crfsuite_create_instance(const char *iid, void **ptr);
+
+   /**
+    * Create an instance of a model object from a model file.
+    *  @param  filename    The filename of the model.
+    *  @param  ptr         The pointer to \c void* that points to the
+    *                      instance of the model object if successful,
+    *                      *ptr points to \c NULL otherwise.
+    *  @return int         \c 0 if this function creates an object successfully,
+    *                      \c 1 otherwise.
+    */
+   int crfsuite_create_instance_from_file(const char *filename, void **ptr);
+
+   /**
+    * Create an instance of a model object from a model in memory.
+    *  @param  data        A pointer to the model data.
+    *                      Must be 16-byte aligned.
+    *  @param  size        A size (in bytes) of the model data.
+    *  @param  ptr         The pointer to \c void* that points to the
+    *                      instance of the model object if successful,
+    *                      *ptr points to \c NULL otherwise.
+    *  @return int         \c 0 if this function creates an object successfully,
+    *                      \c 1 otherwise
+    */
+   int crfsuite_create_instance_from_memory(const void *data, size_t size, void **ptr);
+
+   /**
+    * Create instances of tagging object from a model file.
+    *  @param  filename    The filename of the model.
+    *  @param  ptr_tagger  The pointer to \c void* that points to the
+    *                      instance of the tagger object if successful,
+    *                      *ptr points to \c NULL otherwise.
+    *  @param  ptr_attrs   The pointer to \c void* that points to the
+    *                      instance of the dictionary object for attributes
+    *                      if successful, *ptr points to \c NULL otherwise.
+    *  @param  ptr_labels  The pointer to \c void* that points to the
+    *                      instance of the dictionary object for labels
+    *                      if successful, *ptr points to \c NULL otherwise.
+    *  @return int         \c 0 if this function creates an object successfully,
+    *                      \c 1 otherwise.
+    */
+   int crfsuite_create_tagger(
+       const char *filename,
+       crfsuite_tagger_t **ptr_tagger,
+       crfsuite_dictionary_t **ptr_attrs,
+       crfsuite_dictionary_t **ptr_labels);
+
+   /**@}*/
+
+   /**
+    * \addtogroup crfsuite_data
+    * @{
+    */
+
+   /**
+    * Initialize an attribute structure.
+    *  @param  attr        The pointer to crfsuite_attribute_t.
+    */
+   void crfsuite_attribute_init(crfsuite_attribute_t *attr);
+
+   /**
+    * Set an attribute and its value.
+    *  @param  attr        The pointer to crfsuite_attribute_t.
+    *  @param  aid         The attribute identifier.
+    *  @param  value       The attribute value.
+    */
+   void crfsuite_attribute_set(crfsuite_attribute_t *attr, int aid, floatval_t value);
+
+   /**
+    * Copy the content of an attribute structure.
+    *  @param  dst         The pointer to the destination.
+    *  @param  src         The pointer to the source.
+    */
+   void crfsuite_attribute_copy(crfsuite_attribute_t *dst, const crfsuite_attribute_t *src);
+
+   /**
+    * Swap the contents of two attribute structures.
+    *  @param  x           The pointer to an attribute structure.
+    *  @param  y           The pointer to another attribute structure.
+    */
+   void crfsuite_attribute_swap(crfsuite_attribute_t *x, crfsuite_attribute_t *y);
+
+   /**
+    * Initialize an item structure.
+    *  @param  item        The pointer to crfsuite_item_t.
+    */
+   void crfsuite_item_init(crfsuite_item_t *item);
+
+   /**
+    * Initialize an item structure with the number of attributes.
+    *  @param  item        The pointer to crfsuite_item_t.
+    *  @param  num_attributes  The number of attributes.
+    */
+   void crfsuite_item_init_n(crfsuite_item_t *item, int num_attributes);
+
+   /**
+    * Uninitialize an item structure.
+    *  @param  item        The pointer to crfsuite_item_t.
+    */
+   void crfsuite_item_finish(crfsuite_item_t *item);
+
+   /**
+    * Copy the content of an item structure.
+    *  @param  dst         The pointer to the destination.
+    *  @param  src         The pointer to the source.
+    */
+   void crfsuite_item_copy(crfsuite_item_t *dst, const crfsuite_item_t *src);
+
+   /**
+    * Swap the contents of two item structures.
+    *  @param  x           The pointer to an item structure.
+    *  @param  y           The pointer to another item structure.
+    */
+   void crfsuite_item_swap(crfsuite_item_t *x, crfsuite_item_t *y);
+
+   /**
+    * Append an attribute to the item structure.
+    *  @param  item        The pointer to crfsuite_item_t.
+    *  @param  attr        The attribute to be added to the item.
+    *  @return int         \c 0 if successful, \c -1 otherwise.
+    */
+   int crfsuite_item_append_attribute(crfsuite_item_t *item, const crfsuite_attribute_t *attr);
+
+   /**
+    * Check whether the item has no attribute.
+    *  @param  item        The pointer to crfsuite_item_t.
+    *  @return int         \c 1 if the item has no attribute, \c 0 otherwise.
+    */
+   int crfsuite_item_empty(crfsuite_item_t *item);
+
+   /**
+    * Initialize an instance structure.
+    *  @param  seq         The pointer to crfsuite_instance_t.
+    */
+   void crfsuite_instance_init(crfsuite_instance_t *seq);
+
+   /**
+    * Initialize an instance structure with the number of items.
+    *  @param  seq         The pointer to crfsuite_instance_t.
+    *  @param  num_items   The number of items.
+    */
+   void crfsuite_instance_init_n(crfsuite_instance_t *seq, int num_items);
+
+   /**
+    * Uninitialize an instance structure.
+    *  @param  seq         The pointer to crfsuite_instance_t.
+    */
+   void crfsuite_instance_finish(crfsuite_instance_t *seq);
+
+   /**
+    * Copy the content of an instance structure.
+    *  @param  dst         The pointer to the destination.
+    *  @param  src         The pointer to the source.
+    */
+   void crfsuite_instance_copy(crfsuite_instance_t *dst, const crfsuite_instance_t *src);
+
+   /**
+    * Swap the contents of two instance structures.
+    *  @param  x           The pointer to an instance structure.
+    *  @param  y           The pointer to another instance structure.
+    */
+   void crfsuite_instance_swap(crfsuite_instance_t *x, crfsuite_instance_t *y);
+
+   /**
+    * Append a pair of item and label to the instance structure.
+    *  @param  seq         The pointer to crfsuite_instance_t.
+    *  @param  item        The item to be added to the instance.
+    *  @param  label       The label to be added to the instance.
+    *  @return int         \c 0 if successful, \c -1 otherwise.
+    */
+   int crfsuite_instance_append(crfsuite_instance_t *seq, const crfsuite_item_t *item, int label);
+
+   /**
+    * Check whether the instance has no item.
+    *  @param  seq         The pointer to crfsuite_instance_t.
+    *  @return int         \c 1 if the instance has no attribute, \c 0 otherwise.
+    */
+   int crfsuite_instance_empty(crfsuite_instance_t *seq);
+
+   /**
+    * Initialize a dataset structure.
+    *  @param  data        The pointer to crfsuite_data_t.
+    */
+   void crfsuite_data_init(crfsuite_data_t *data);
+
+   /**
+    * Initialize a dataset structure with the number of instances.
+    *  @param  data        The pointer to crfsuite_data_t.
+    *  @param  n           The number of instances.
+    */
+   void crfsuite_data_init_n(crfsuite_data_t *data, int n);
+
+   /**
+    * Uninitialize a dataset structure.
+    *  @param  data        The pointer to crfsuite_data_t.
+    */
+   void crfsuite_data_finish(crfsuite_data_t *data);
+
+   /**
+    * Copy the content of a dataset structure.
+    *  @param  dst         The pointer to the destination.
+    *  @param  src         The pointer to the source.
+    */
+   void crfsuite_data_copy(crfsuite_data_t *dst, const crfsuite_data_t *src);
+
+   /**
+    * Swap the contents of two dataset structures.
+    *  @param  x           The pointer to a dataset structure.
+    *  @param  y           The pointer to another dataset structure.
+    */
+   void crfsuite_data_swap(crfsuite_data_t *x, crfsuite_data_t *y);
+
+   /**
+    * Append an instance to the dataset structure.
+    *  @param  data        The pointer to crfsuite_data_t.
+    *  @param  inst        The instance to be added to the dataset.
+    *  @return int         \c 0 if successful, \c -1 otherwise.
+    */
+   int crfsuite_data_append(crfsuite_data_t *data, const crfsuite_instance_t *inst);
+
+   /**
+    * Obtain the maximum length of the instances in the dataset.
+    *  @param  data        The pointer to crfsuite_data_t.
+    *  @return int         The maximum number of items of the instances in the
+    *                      dataset.
+    */
+   int crfsuite_data_maxlength(crfsuite_data_t *data);
+
+   /**
+    * Obtain the total number of items in the dataset.
+    *  @param  data        The pointer to crfsuite_data_t.
+    *  @return int         The total number of items in the dataset.
+    */
+   int crfsuite_data_totalitems(crfsuite_data_t *data);
+
+   /**@}*/
+
+   /**
+    * \addtogroup crfsuite_evaluation
+    */
+   /**@{*/
+
+   /**
+    * Initialize an evaluation structure.
+    *  @param  eval        The pointer to crfsuite_evaluation_t.
+    *  @param  n           The number of labels in the dataset.
+    */
+   void crfsuite_evaluation_init(crfsuite_evaluation_t *eval, int n);
+
+   /**
+    * Uninitialize an evaluation structure.
+    *  @param  eval        The pointer to crfsuite_evaluation_t.
+    */
+   void crfsuite_evaluation_finish(crfsuite_evaluation_t *eval);
+
+   /**
+    * Reset an evaluation structure.
+    *  @param  eval        The pointer to crfsuite_evaluation_t.
+    */
+   void crfsuite_evaluation_clear(crfsuite_evaluation_t *eval);
+
+   /**
+    * Accmulate the correctness of the predicted label sequence.
+    *  @param  eval        The pointer to crfsuite_evaluation_t.
+    *  @param  reference   The reference label sequence.
+    *  @param  prediction  The predicted label sequence.
+    *  @param  T           The length of the label sequence.
+    *  @return int         \c 0 if succeeded, \c 1 otherwise.
+    */
+   int crfsuite_evaluation_accmulate(crfsuite_evaluation_t *eval, const int *reference, const int *prediction, int T);
+
+   /**
+    * Finalize the evaluation result.
+    *  @param  eval        The pointer to crfsuite_evaluation_t.
+    */
+   void crfsuite_evaluation_finalize(crfsuite_evaluation_t *eval);
+
+   /**
+    * Print the evaluation result.
+    *  @param  eval        The pointer to crfsuite_evaluation_t.
+    *  @param  labels      The pointer to the label dictionary.
+    *  @param  cbm         The callback function to receive the evaluation result.
+    *  @param  user        The pointer to the user data that is forwarded to the
+    *                      callback function.
+    */
+   void crfsuite_evaluation_output(crfsuite_evaluation_t *eval, crfsuite_dictionary_t *labels, crfsuite_logging_callback cbm, void *user);
+
+   /**@}*/
+
+   /**
+    * \addtogroup crfsuite_misc Miscellaneous definitions and functions
+    * @{
+    */
+
+   /**
+    * Increments the value of the integer variable as an atomic operation.
+    *  @param  count       The pointer to the integer variable.
+    *  @return             The value after this increment.
+    */
+   int crfsuite_interlocked_increment(int *count);
+
+   /**
+    * Decrements the value of the integer variable as an atomic operation.
+    *  @param  count       The pointer to the integer variable.
+    *  @return             The value after this decrement.
+    */
+   int crfsuite_interlocked_decrement(int *count);
+
+   /**@}*/
+
+   /**@}*/
+
+   /**
+@mainpage CRFsuite: a fast implementation of Conditional Random Fields (CRFs)
+
+@section intro Introduction
+
+This document describes information for using
+<a href="http://www.chokkan.org/software/crfsuite">CRFsuite</a> from external
+programs. CRFsuite provides two APIs:
+- @link crfsuite_api C API @endlink: low-level and complete interface, which
+ is used by the official frontend program.
+- @link crfsuite_hpp_api C++/SWIG API @endlink: high-level and easy-to-use
+ interface for a number of programming languages (e.g, C++ and Python),
+ which is a wrapper for the C API.
+
+*/
+
+#ifdef __cplusplus
+}
+#endif /*__cplusplus*/
+
+#endif /*__CRFSUITE_H__*/
```

## chaine/_core/crfsuite/include/crfsuite.hpp

 * *Ordering differences only*

```diff
@@ -1,649 +1,649 @@
-/*
- *      CRFsuite C++/SWIG API wrapper.
- *
- * Copyright (c) 2007-2010, Naoaki Okazaki
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the names of the authors nor the names of its contributors
- *       may be used to endorse or promote products derived from this
- *       software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
- * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#ifndef __CRFSUITE_HPP__
-#define __CRFSUITE_HPP__
-
-#include <cmath>
-#include <vector>
-#include <string>
-#include <stdexcept>
-#include <iostream>
-#include <sstream>
-
-#include <crfsuite.h>
-#include "crfsuite_api.hpp"
-
-namespace CRFSuite
-{
-
-    Trainer::Trainer()
-    {
-        data = new crfsuite_data_t;
-        if (data != NULL)
-        {
-            crfsuite_data_init(data);
-        }
-        tr = NULL;
-    }
-
-    Trainer::~Trainer()
-    {
-        if (data != NULL)
-        {
-            clear();
-            delete data;
-            data = NULL;
-        }
-        if (tr != NULL)
-        {
-            tr->release(tr);
-            tr = NULL;
-        }
-    }
-
-    void Trainer::init()
-    {
-        // Create an instance of attribute dictionary.
-        if (data->attrs == NULL)
-        {
-            int ret = crfsuite_create_instance("dictionary", (void **)&data->attrs);
-            if (!ret)
-            {
-                throw std::runtime_error("Failed to create a dictionary instance for attributes.");
-            }
-        }
-
-        // Create an instance of label dictionary.
-        if (data->labels == NULL)
-        {
-            int ret = crfsuite_create_instance("dictionary", (void **)&data->labels);
-            if (!ret)
-            {
-                throw std::runtime_error("Failed to create a dictionary instance for labels.");
-            }
-        }
-    }
-
-    void Trainer::clear()
-    {
-        if (data != NULL)
-        {
-            if (data->labels != NULL)
-            {
-                data->labels->release(data->labels);
-                data->labels = NULL;
-            }
-
-            if (data->attrs != NULL)
-            {
-                data->attrs->release(data->attrs);
-                data->attrs = NULL;
-            }
-
-            crfsuite_data_finish(data);
-            crfsuite_data_init(data);
-        }
-    }
-
-    void Trainer::append(const ItemSequence &xseq, const StringList &yseq, int group)
-    {
-        // Create dictionary objects if necessary.
-        if (data->attrs == NULL || data->labels == NULL)
-        {
-            init();
-        }
-
-        // Make sure |y| == |x|.
-        if (xseq.size() != yseq.size())
-        {
-            std::stringstream ss;
-            ss << "The number of items and labels differ: |x| = " << xseq.size() << ", |y| = " << yseq.size();
-            throw std::invalid_argument(ss.str());
-        }
-
-        // Convert instance_type to crfsuite_instance_t.
-        crfsuite_instance_t _inst;
-        crfsuite_instance_init_n(&_inst, xseq.size());
-        for (size_t t = 0; t < xseq.size(); ++t)
-        {
-            const Item &item = xseq[t];
-            crfsuite_item_t *_item = &_inst.items[t];
-
-            // Set the attributes in the item.
-            crfsuite_item_init_n(_item, item.size());
-            for (size_t i = 0; i < item.size(); ++i)
-            {
-                _item->contents[i].aid = data->attrs->get(data->attrs, item[i].attr.c_str());
-                _item->contents[i].value = (floatval_t)item[i].value;
-            }
-
-            // Set the label of the item.
-            _inst.labels[t] = data->labels->get(data->labels, yseq[t].c_str());
-        }
-        _inst.group = group;
-
-        // Append the instance to the training set.
-        crfsuite_data_append(data, &_inst);
-
-        // Finish the instance.
-        crfsuite_instance_finish(&_inst);
-    }
-
-    bool Trainer::select(const std::string &algorithm, const std::string &type)
-    {
-        int ret;
-
-        // Release the trainer if it is already initialized.
-        if (tr != NULL)
-        {
-            tr->release(tr);
-            tr = NULL;
-        }
-
-        // Build the trainer string ID.
-        std::string tid = "train/";
-        tid += type;
-        tid += '/';
-        tid += algorithm;
-
-        // Create an instance of a trainer.
-        ret = crfsuite_create_instance(tid.c_str(), (void **)&tr);
-        if (!ret)
-        {
-            return false;
-        }
-
-        // Set the callback function for receiving messages.
-        tr->set_message_callback(tr, this, __logging_callback);
-
-        return true;
-    }
-
-    int Trainer::train(const std::string &model, int holdout)
-    {
-        int ret;
-
-        if (tr == NULL)
-        {
-            std::stringstream ss;
-            ss << "The trainer is not initialized. Call Trainer::select before Trainer::train.";
-            throw std::invalid_argument(ss.str());
-        }
-
-        if (data->attrs == NULL || data->labels == NULL)
-        {
-            std::stringstream ss;
-            ss << "The data is empty. Call Trainer::append before Trainer::train.";
-            throw std::invalid_argument(ss.str());
-        }
-
-        // Run the training algorithm.
-        ret = tr->train(tr, data, model.c_str(), holdout);
-
-        return ret;
-    }
-
-    StringList Trainer::params()
-    {
-        StringList pars;
-        crfsuite_params_t *params = tr->params(tr);
-        int n = params->num(params);
-        for (int i = 0; i < n; ++i)
-        {
-            char *name = NULL;
-            params->name(params, i, &name);
-            pars.push_back(name);
-            params->free(params, name);
-        }
-        return pars;
-    }
-
-    void Trainer::set(const std::string &name, const std::string &value)
-    {
-        crfsuite_params_t *params = tr->params(tr);
-        if (params->set(params, name.c_str(), value.c_str()) != 0)
-        {
-            std::stringstream ss;
-            ss << "Parameter not found: " << name << " = " << value;
-            params->release(params);
-            throw std::invalid_argument(ss.str());
-        }
-        params->release(params);
-    }
-
-    std::string Trainer::get(const std::string &name)
-    {
-        std::string value;
-        char *_value = NULL;
-        crfsuite_params_t *params = tr->params(tr);
-        if (params->get(params, name.c_str(), &_value) != 0)
-        {
-            std::stringstream ss;
-            ss << "Parameter not found: " << name << " = " << value;
-            params->release(params);
-            throw std::invalid_argument(ss.str());
-        }
-        value = _value;
-        params->free(params, _value);
-        params->release(params);
-        return value;
-    }
-
-    std::string Trainer::help(const std::string &name)
-    {
-        std::string str;
-        crfsuite_params_t *params = tr->params(tr);
-        char *_str = NULL;
-        if (params->help(params, name.c_str(), NULL, &_str) != 0)
-        {
-            std::stringstream ss;
-            ss << "Parameter not found: " << name;
-            params->release(params);
-            throw std::invalid_argument(ss.str());
-        }
-        str = _str;
-        params->free(params, _str);
-        params->release(params);
-        return str;
-    }
-
-    void Trainer::message(const std::string &msg)
-    {
-    }
-
-    int Trainer::__logging_callback(void *instance, const char *format, va_list args)
-    {
-        char buffer[65536];
-        vsnprintf(buffer, sizeof(buffer) - 1, format, args);
-        reinterpret_cast<Trainer *>(instance)->message(buffer);
-        return 0;
-    }
-
-    Tagger::Tagger()
-    {
-        model = NULL;
-        tagger = NULL;
-    }
-
-    Tagger::~Tagger()
-    {
-        this->close();
-    }
-
-    bool Tagger::open(const std::string &name)
-    {
-        int ret;
-
-        // Close the model if it is already opened.
-        this->close();
-
-        // Open the model file.
-        if ((ret = crfsuite_create_instance_from_file(name.c_str(), (void **)&model)))
-        {
-            return false;
-        }
-
-        // Obtain the tagger interface.
-        if ((ret = model->get_tagger(model, &tagger)))
-        {
-            throw std::runtime_error("Failed to obtain the tagger interface");
-        }
-
-        return true;
-    }
-
-    bool Tagger::open(const void *data, std::size_t size)
-    {
-        int ret;
-
-        // Close the model if it is already opened.
-        this->close();
-
-        // Open the model.
-        if ((ret = crfsuite_create_instance_from_memory(data, size, (void **)&model)))
-        {
-            return false;
-        }
-
-        // Obtain the tagger interface.
-        if ((ret = model->get_tagger(model, &tagger)))
-        {
-            throw std::runtime_error("Failed to obtain the tagger interface");
-        }
-
-        return true;
-    }
-
-    void Tagger::close()
-    {
-        if (tagger != NULL)
-        {
-            tagger->release(tagger);
-            tagger = NULL;
-        }
-        if (model != NULL)
-        {
-            model->release(model);
-            model = NULL;
-        }
-    }
-
-    StringList Tagger::labels()
-    {
-        int ret;
-        StringList lseq;
-        crfsuite_dictionary_t *labels = NULL;
-
-        if (model == NULL)
-        {
-            throw std::invalid_argument("The tagger is not opened.");
-        }
-
-        // Obtain the dictionary interface representing the labels in the model.
-        if ((ret = model->get_labels(model, &labels)))
-        {
-            throw std::runtime_error("Failed to obtain the dictionary interface for labels.");
-        }
-
-        // Collect all label strings to lseq.
-        for (int i = 0; i < labels->num(labels); ++i)
-        {
-            const char *label = NULL;
-            if (labels->to_string(labels, i, &label) != 0)
-            {
-                labels->release(labels);
-                throw std::runtime_error("Failed to convert a label identifier to string.");
-            }
-            lseq.push_back(label);
-            labels->free(labels, label);
-        }
-
-        labels->release(labels);
-        return lseq;
-    }
-
-    StringList Tagger::tag(const ItemSequence &xseq)
-    {
-        set(xseq);
-        return viterbi();
-    }
-
-    void Tagger::set(const ItemSequence &xseq)
-    {
-        int ret;
-        StringList yseq;
-        crfsuite_instance_t _inst;
-        crfsuite_dictionary_t *attrs = NULL;
-
-        if (model == NULL || tagger == NULL)
-        {
-            throw std::invalid_argument("The tagger is not opened.");
-        }
-
-        // Obtain the dictionary interface representing the attributes in the model.
-        if ((ret = model->get_attrs(model, &attrs)))
-        {
-            throw std::runtime_error("Failed to obtain the dictionary interface for attributes.");
-        }
-
-        // Build an instance.
-        crfsuite_instance_init_n(&_inst, xseq.size());
-        for (size_t t = 0; t < xseq.size(); ++t)
-        {
-            const Item &item = xseq[t];
-            crfsuite_item_t *_item = &_inst.items[t];
-
-            // Set the attributes in the item.
-            crfsuite_item_init(_item);
-            for (size_t i = 0; i < item.size(); ++i)
-            {
-                int aid = attrs->to_id(attrs, item[i].attr.c_str());
-                if (0 <= aid)
-                {
-                    crfsuite_attribute_t cont;
-                    crfsuite_attribute_set(&cont, aid, item[i].value);
-                    crfsuite_item_append_attribute(_item, &cont);
-                }
-            }
-        }
-
-        // Set the instance to the tagger.
-        if ((ret = tagger->set(tagger, &_inst)))
-        {
-            crfsuite_instance_finish(&_inst);
-            attrs->release(attrs);
-            throw std::runtime_error("Failed to set the instance to the tagger.");
-        }
-
-        crfsuite_instance_finish(&_inst);
-        attrs->release(attrs);
-    }
-
-    StringList Tagger::viterbi()
-    {
-        int ret;
-        StringList yseq;
-        crfsuite_dictionary_t *labels = NULL;
-
-        if (model == NULL || tagger == NULL)
-        {
-            throw std::invalid_argument("The tagger is not opened");
-        }
-
-        // Make sure that the current instance is not empty.
-        const size_t T = (size_t)tagger->length(tagger);
-        if (T <= 0)
-        {
-            return yseq;
-        }
-
-        // Obtain the dictionary interface representing the labels in the model.
-        if ((ret = model->get_labels(model, &labels)))
-        {
-            throw std::runtime_error("Failed to obtain the dictionary interface for labels.");
-        }
-
-        // Run the Viterbi algorithm.
-        floatval_t score;
-        int *path = new int[T];
-        if ((ret = tagger->viterbi(tagger, path, &score)))
-        {
-            delete[] path;
-            labels->release(labels);
-            throw std::runtime_error("Failed to find the Viterbi path.");
-        }
-
-        // Convert the Viterbi path to a label sequence.
-        yseq.resize(T);
-        for (size_t t = 0; t < T; ++t)
-        {
-            const char *label = NULL;
-            if (labels->to_string(labels, path[t], &label) != 0)
-            {
-                delete[] path;
-                labels->release(labels);
-                throw std::runtime_error("Failed to convert a label identifier to string.");
-            }
-            yseq[t] = label;
-            labels->free(labels, label);
-        }
-
-        labels->release(labels);
-        delete[] path;
-        return yseq;
-    }
-
-    double Tagger::probability(const StringList &yseq)
-    {
-        int ret;
-        size_t T;
-        int *path = NULL;
-        std::stringstream msg;
-        floatval_t score, lognorm;
-        crfsuite_dictionary_t *labels = NULL;
-
-        if (model == NULL || tagger == NULL)
-        {
-            msg << "The tagger is not opened";
-            throw std::invalid_argument(msg.str());
-        }
-
-        // Make sure that the current instance is not empty.
-        T = (size_t)tagger->length(tagger);
-        if (T <= 0)
-        {
-            return 0.;
-        }
-
-        // Make sure that |y| == |x|.
-        if (yseq.size() != T)
-        {
-            msg << "The numbers of items and labels differ: |x| = " << T << ", |y| = " << yseq.size();
-            throw std::invalid_argument(msg.str());
-        }
-
-        // Obtain the dictionary interface representing the labels in the model.
-        if ((ret = model->get_labels(model, &labels)))
-        {
-            msg << "Failed to obtain the dictionary interface for labels";
-            goto error_exit;
-        }
-
-        // Convert string labels into label IDs.
-        path = new int[T];
-        for (size_t t = 0; t < T; ++t)
-        {
-            int l = labels->to_id(labels, yseq[t].c_str());
-            if (l < 0)
-            {
-                msg << "Failed to convert into label identifier: " << yseq[t];
-                goto error_exit;
-            }
-            path[t] = l;
-        }
-
-        // Compute the score of the path.
-        if ((ret = tagger->score(tagger, path, &score)))
-        {
-            msg << "Failed to score the label sequence";
-            goto error_exit;
-        }
-
-        // Compute the partition factor.
-        if ((ret = tagger->lognorm(tagger, &lognorm)))
-        {
-            msg << "Failed to compute the partition factor";
-            goto error_exit;
-        }
-
-        labels->release(labels);
-        delete[] path;
-        return std::exp((double)(score - lognorm));
-
-    error_exit:
-        if (labels != NULL)
-        {
-            labels->release(labels);
-            labels = NULL;
-        }
-        delete[] path;
-        throw std::runtime_error(msg.str());
-    }
-
-    double Tagger::marginal(const std::string &y, const int t)
-    {
-        int l, ret, T;
-        floatval_t prob;
-        std::stringstream msg;
-        crfsuite_dictionary_t *labels = NULL;
-
-        if (model == NULL || tagger == NULL)
-        {
-            msg << "The tagger is not opened";
-            throw std::invalid_argument(msg.str());
-        }
-
-        // Make sure that the current instance is not empty.
-        T = tagger->length(tagger);
-        if (T <= 0)
-        {
-            return 0.;
-        }
-
-        // Make sure that 0 <= t < |x|.
-        if (t < 0 || T <= t)
-        {
-            msg << "The position, " << t << "is out of range of " << T;
-            throw std::invalid_argument(msg.str());
-        }
-
-        // Obtain the dictionary interface representing the labels in the model.
-        if ((ret = model->get_labels(model, &labels)))
-        {
-            msg << "Failed to obtain the dictionary interface for labels";
-            goto error_exit;
-        }
-
-        // Convert string labels into label IDs.
-        l = labels->to_id(labels, y.c_str());
-        if (l < 0)
-        {
-            msg << "Failed to convert into label identifier: " << y;
-            goto error_exit;
-        }
-
-        // Compute the score of the path.
-        if ((ret = tagger->marginal_point(tagger, l, t, &prob)))
-        {
-            msg << "Failed to compute the marginal probability of '" << y << "' at " << t;
-            goto error_exit;
-        }
-
-        labels->release(labels);
-        return prob;
-
-    error_exit:
-        if (labels != NULL)
-        {
-            labels->release(labels);
-            labels = NULL;
-        }
-        throw std::runtime_error(msg.str());
-    }
-
-    std::string version()
-    {
-        return CRFSUITE_VERSION;
-    }
-
-} // namespace CRFSuite
-
-#endif /*__CRFSUITE_HPP__*/
+/*
+ *      CRFsuite C++/SWIG API wrapper.
+ *
+ * Copyright (c) 2007-2010, Naoaki Okazaki
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the names of the authors nor the names of its contributors
+ *       may be used to endorse or promote products derived from this
+ *       software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+ * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __CRFSUITE_HPP__
+#define __CRFSUITE_HPP__
+
+#include <cmath>
+#include <vector>
+#include <string>
+#include <stdexcept>
+#include <iostream>
+#include <sstream>
+
+#include <crfsuite.h>
+#include "crfsuite_api.hpp"
+
+namespace CRFSuite
+{
+
+    Trainer::Trainer()
+    {
+        data = new crfsuite_data_t;
+        if (data != NULL)
+        {
+            crfsuite_data_init(data);
+        }
+        tr = NULL;
+    }
+
+    Trainer::~Trainer()
+    {
+        if (data != NULL)
+        {
+            clear();
+            delete data;
+            data = NULL;
+        }
+        if (tr != NULL)
+        {
+            tr->release(tr);
+            tr = NULL;
+        }
+    }
+
+    void Trainer::init()
+    {
+        // Create an instance of attribute dictionary.
+        if (data->attrs == NULL)
+        {
+            int ret = crfsuite_create_instance("dictionary", (void **)&data->attrs);
+            if (!ret)
+            {
+                throw std::runtime_error("Failed to create a dictionary instance for attributes.");
+            }
+        }
+
+        // Create an instance of label dictionary.
+        if (data->labels == NULL)
+        {
+            int ret = crfsuite_create_instance("dictionary", (void **)&data->labels);
+            if (!ret)
+            {
+                throw std::runtime_error("Failed to create a dictionary instance for labels.");
+            }
+        }
+    }
+
+    void Trainer::clear()
+    {
+        if (data != NULL)
+        {
+            if (data->labels != NULL)
+            {
+                data->labels->release(data->labels);
+                data->labels = NULL;
+            }
+
+            if (data->attrs != NULL)
+            {
+                data->attrs->release(data->attrs);
+                data->attrs = NULL;
+            }
+
+            crfsuite_data_finish(data);
+            crfsuite_data_init(data);
+        }
+    }
+
+    void Trainer::append(const ItemSequence &xseq, const StringList &yseq, int group)
+    {
+        // Create dictionary objects if necessary.
+        if (data->attrs == NULL || data->labels == NULL)
+        {
+            init();
+        }
+
+        // Make sure |y| == |x|.
+        if (xseq.size() != yseq.size())
+        {
+            std::stringstream ss;
+            ss << "The number of items and labels differ: |x| = " << xseq.size() << ", |y| = " << yseq.size();
+            throw std::invalid_argument(ss.str());
+        }
+
+        // Convert instance_type to crfsuite_instance_t.
+        crfsuite_instance_t _inst;
+        crfsuite_instance_init_n(&_inst, xseq.size());
+        for (size_t t = 0; t < xseq.size(); ++t)
+        {
+            const Item &item = xseq[t];
+            crfsuite_item_t *_item = &_inst.items[t];
+
+            // Set the attributes in the item.
+            crfsuite_item_init_n(_item, item.size());
+            for (size_t i = 0; i < item.size(); ++i)
+            {
+                _item->contents[i].aid = data->attrs->get(data->attrs, item[i].attr.c_str());
+                _item->contents[i].value = (floatval_t)item[i].value;
+            }
+
+            // Set the label of the item.
+            _inst.labels[t] = data->labels->get(data->labels, yseq[t].c_str());
+        }
+        _inst.group = group;
+
+        // Append the instance to the training set.
+        crfsuite_data_append(data, &_inst);
+
+        // Finish the instance.
+        crfsuite_instance_finish(&_inst);
+    }
+
+    bool Trainer::select(const std::string &algorithm, const std::string &type)
+    {
+        int ret;
+
+        // Release the trainer if it is already initialized.
+        if (tr != NULL)
+        {
+            tr->release(tr);
+            tr = NULL;
+        }
+
+        // Build the trainer string ID.
+        std::string tid = "train/";
+        tid += type;
+        tid += '/';
+        tid += algorithm;
+
+        // Create an instance of a trainer.
+        ret = crfsuite_create_instance(tid.c_str(), (void **)&tr);
+        if (!ret)
+        {
+            return false;
+        }
+
+        // Set the callback function for receiving messages.
+        tr->set_message_callback(tr, this, __logging_callback);
+
+        return true;
+    }
+
+    int Trainer::train(const std::string &model, int holdout)
+    {
+        int ret;
+
+        if (tr == NULL)
+        {
+            std::stringstream ss;
+            ss << "The trainer is not initialized. Call Trainer::select before Trainer::train.";
+            throw std::invalid_argument(ss.str());
+        }
+
+        if (data->attrs == NULL || data->labels == NULL)
+        {
+            std::stringstream ss;
+            ss << "The data is empty. Call Trainer::append before Trainer::train.";
+            throw std::invalid_argument(ss.str());
+        }
+
+        // Run the training algorithm.
+        ret = tr->train(tr, data, model.c_str(), holdout);
+
+        return ret;
+    }
+
+    StringList Trainer::params()
+    {
+        StringList pars;
+        crfsuite_params_t *params = tr->params(tr);
+        int n = params->num(params);
+        for (int i = 0; i < n; ++i)
+        {
+            char *name = NULL;
+            params->name(params, i, &name);
+            pars.push_back(name);
+            params->free(params, name);
+        }
+        return pars;
+    }
+
+    void Trainer::set(const std::string &name, const std::string &value)
+    {
+        crfsuite_params_t *params = tr->params(tr);
+        if (params->set(params, name.c_str(), value.c_str()) != 0)
+        {
+            std::stringstream ss;
+            ss << "Parameter not found: " << name << " = " << value;
+            params->release(params);
+            throw std::invalid_argument(ss.str());
+        }
+        params->release(params);
+    }
+
+    std::string Trainer::get(const std::string &name)
+    {
+        std::string value;
+        char *_value = NULL;
+        crfsuite_params_t *params = tr->params(tr);
+        if (params->get(params, name.c_str(), &_value) != 0)
+        {
+            std::stringstream ss;
+            ss << "Parameter not found: " << name << " = " << value;
+            params->release(params);
+            throw std::invalid_argument(ss.str());
+        }
+        value = _value;
+        params->free(params, _value);
+        params->release(params);
+        return value;
+    }
+
+    std::string Trainer::help(const std::string &name)
+    {
+        std::string str;
+        crfsuite_params_t *params = tr->params(tr);
+        char *_str = NULL;
+        if (params->help(params, name.c_str(), NULL, &_str) != 0)
+        {
+            std::stringstream ss;
+            ss << "Parameter not found: " << name;
+            params->release(params);
+            throw std::invalid_argument(ss.str());
+        }
+        str = _str;
+        params->free(params, _str);
+        params->release(params);
+        return str;
+    }
+
+    void Trainer::message(const std::string &msg)
+    {
+    }
+
+    int Trainer::__logging_callback(void *instance, const char *format, va_list args)
+    {
+        char buffer[65536];
+        vsnprintf(buffer, sizeof(buffer) - 1, format, args);
+        reinterpret_cast<Trainer *>(instance)->message(buffer);
+        return 0;
+    }
+
+    Tagger::Tagger()
+    {
+        model = NULL;
+        tagger = NULL;
+    }
+
+    Tagger::~Tagger()
+    {
+        this->close();
+    }
+
+    bool Tagger::open(const std::string &name)
+    {
+        int ret;
+
+        // Close the model if it is already opened.
+        this->close();
+
+        // Open the model file.
+        if ((ret = crfsuite_create_instance_from_file(name.c_str(), (void **)&model)))
+        {
+            return false;
+        }
+
+        // Obtain the tagger interface.
+        if ((ret = model->get_tagger(model, &tagger)))
+        {
+            throw std::runtime_error("Failed to obtain the tagger interface");
+        }
+
+        return true;
+    }
+
+    bool Tagger::open(const void *data, std::size_t size)
+    {
+        int ret;
+
+        // Close the model if it is already opened.
+        this->close();
+
+        // Open the model.
+        if ((ret = crfsuite_create_instance_from_memory(data, size, (void **)&model)))
+        {
+            return false;
+        }
+
+        // Obtain the tagger interface.
+        if ((ret = model->get_tagger(model, &tagger)))
+        {
+            throw std::runtime_error("Failed to obtain the tagger interface");
+        }
+
+        return true;
+    }
+
+    void Tagger::close()
+    {
+        if (tagger != NULL)
+        {
+            tagger->release(tagger);
+            tagger = NULL;
+        }
+        if (model != NULL)
+        {
+            model->release(model);
+            model = NULL;
+        }
+    }
+
+    StringList Tagger::labels()
+    {
+        int ret;
+        StringList lseq;
+        crfsuite_dictionary_t *labels = NULL;
+
+        if (model == NULL)
+        {
+            throw std::invalid_argument("The tagger is not opened.");
+        }
+
+        // Obtain the dictionary interface representing the labels in the model.
+        if ((ret = model->get_labels(model, &labels)))
+        {
+            throw std::runtime_error("Failed to obtain the dictionary interface for labels.");
+        }
+
+        // Collect all label strings to lseq.
+        for (int i = 0; i < labels->num(labels); ++i)
+        {
+            const char *label = NULL;
+            if (labels->to_string(labels, i, &label) != 0)
+            {
+                labels->release(labels);
+                throw std::runtime_error("Failed to convert a label identifier to string.");
+            }
+            lseq.push_back(label);
+            labels->free(labels, label);
+        }
+
+        labels->release(labels);
+        return lseq;
+    }
+
+    StringList Tagger::tag(const ItemSequence &xseq)
+    {
+        set(xseq);
+        return viterbi();
+    }
+
+    void Tagger::set(const ItemSequence &xseq)
+    {
+        int ret;
+        StringList yseq;
+        crfsuite_instance_t _inst;
+        crfsuite_dictionary_t *attrs = NULL;
+
+        if (model == NULL || tagger == NULL)
+        {
+            throw std::invalid_argument("The tagger is not opened.");
+        }
+
+        // Obtain the dictionary interface representing the attributes in the model.
+        if ((ret = model->get_attrs(model, &attrs)))
+        {
+            throw std::runtime_error("Failed to obtain the dictionary interface for attributes.");
+        }
+
+        // Build an instance.
+        crfsuite_instance_init_n(&_inst, xseq.size());
+        for (size_t t = 0; t < xseq.size(); ++t)
+        {
+            const Item &item = xseq[t];
+            crfsuite_item_t *_item = &_inst.items[t];
+
+            // Set the attributes in the item.
+            crfsuite_item_init(_item);
+            for (size_t i = 0; i < item.size(); ++i)
+            {
+                int aid = attrs->to_id(attrs, item[i].attr.c_str());
+                if (0 <= aid)
+                {
+                    crfsuite_attribute_t cont;
+                    crfsuite_attribute_set(&cont, aid, item[i].value);
+                    crfsuite_item_append_attribute(_item, &cont);
+                }
+            }
+        }
+
+        // Set the instance to the tagger.
+        if ((ret = tagger->set(tagger, &_inst)))
+        {
+            crfsuite_instance_finish(&_inst);
+            attrs->release(attrs);
+            throw std::runtime_error("Failed to set the instance to the tagger.");
+        }
+
+        crfsuite_instance_finish(&_inst);
+        attrs->release(attrs);
+    }
+
+    StringList Tagger::viterbi()
+    {
+        int ret;
+        StringList yseq;
+        crfsuite_dictionary_t *labels = NULL;
+
+        if (model == NULL || tagger == NULL)
+        {
+            throw std::invalid_argument("The tagger is not opened");
+        }
+
+        // Make sure that the current instance is not empty.
+        const size_t T = (size_t)tagger->length(tagger);
+        if (T <= 0)
+        {
+            return yseq;
+        }
+
+        // Obtain the dictionary interface representing the labels in the model.
+        if ((ret = model->get_labels(model, &labels)))
+        {
+            throw std::runtime_error("Failed to obtain the dictionary interface for labels.");
+        }
+
+        // Run the Viterbi algorithm.
+        floatval_t score;
+        int *path = new int[T];
+        if ((ret = tagger->viterbi(tagger, path, &score)))
+        {
+            delete[] path;
+            labels->release(labels);
+            throw std::runtime_error("Failed to find the Viterbi path.");
+        }
+
+        // Convert the Viterbi path to a label sequence.
+        yseq.resize(T);
+        for (size_t t = 0; t < T; ++t)
+        {
+            const char *label = NULL;
+            if (labels->to_string(labels, path[t], &label) != 0)
+            {
+                delete[] path;
+                labels->release(labels);
+                throw std::runtime_error("Failed to convert a label identifier to string.");
+            }
+            yseq[t] = label;
+            labels->free(labels, label);
+        }
+
+        labels->release(labels);
+        delete[] path;
+        return yseq;
+    }
+
+    double Tagger::probability(const StringList &yseq)
+    {
+        int ret;
+        size_t T;
+        int *path = NULL;
+        std::stringstream msg;
+        floatval_t score, lognorm;
+        crfsuite_dictionary_t *labels = NULL;
+
+        if (model == NULL || tagger == NULL)
+        {
+            msg << "The tagger is not opened";
+            throw std::invalid_argument(msg.str());
+        }
+
+        // Make sure that the current instance is not empty.
+        T = (size_t)tagger->length(tagger);
+        if (T <= 0)
+        {
+            return 0.;
+        }
+
+        // Make sure that |y| == |x|.
+        if (yseq.size() != T)
+        {
+            msg << "The numbers of items and labels differ: |x| = " << T << ", |y| = " << yseq.size();
+            throw std::invalid_argument(msg.str());
+        }
+
+        // Obtain the dictionary interface representing the labels in the model.
+        if ((ret = model->get_labels(model, &labels)))
+        {
+            msg << "Failed to obtain the dictionary interface for labels";
+            goto error_exit;
+        }
+
+        // Convert string labels into label IDs.
+        path = new int[T];
+        for (size_t t = 0; t < T; ++t)
+        {
+            int l = labels->to_id(labels, yseq[t].c_str());
+            if (l < 0)
+            {
+                msg << "Failed to convert into label identifier: " << yseq[t];
+                goto error_exit;
+            }
+            path[t] = l;
+        }
+
+        // Compute the score of the path.
+        if ((ret = tagger->score(tagger, path, &score)))
+        {
+            msg << "Failed to score the label sequence";
+            goto error_exit;
+        }
+
+        // Compute the partition factor.
+        if ((ret = tagger->lognorm(tagger, &lognorm)))
+        {
+            msg << "Failed to compute the partition factor";
+            goto error_exit;
+        }
+
+        labels->release(labels);
+        delete[] path;
+        return std::exp((double)(score - lognorm));
+
+    error_exit:
+        if (labels != NULL)
+        {
+            labels->release(labels);
+            labels = NULL;
+        }
+        delete[] path;
+        throw std::runtime_error(msg.str());
+    }
+
+    double Tagger::marginal(const std::string &y, const int t)
+    {
+        int l, ret, T;
+        floatval_t prob;
+        std::stringstream msg;
+        crfsuite_dictionary_t *labels = NULL;
+
+        if (model == NULL || tagger == NULL)
+        {
+            msg << "The tagger is not opened";
+            throw std::invalid_argument(msg.str());
+        }
+
+        // Make sure that the current instance is not empty.
+        T = tagger->length(tagger);
+        if (T <= 0)
+        {
+            return 0.;
+        }
+
+        // Make sure that 0 <= t < |x|.
+        if (t < 0 || T <= t)
+        {
+            msg << "The position, " << t << "is out of range of " << T;
+            throw std::invalid_argument(msg.str());
+        }
+
+        // Obtain the dictionary interface representing the labels in the model.
+        if ((ret = model->get_labels(model, &labels)))
+        {
+            msg << "Failed to obtain the dictionary interface for labels";
+            goto error_exit;
+        }
+
+        // Convert string labels into label IDs.
+        l = labels->to_id(labels, y.c_str());
+        if (l < 0)
+        {
+            msg << "Failed to convert into label identifier: " << y;
+            goto error_exit;
+        }
+
+        // Compute the score of the path.
+        if ((ret = tagger->marginal_point(tagger, l, t, &prob)))
+        {
+            msg << "Failed to compute the marginal probability of '" << y << "' at " << t;
+            goto error_exit;
+        }
+
+        labels->release(labels);
+        return prob;
+
+    error_exit:
+        if (labels != NULL)
+        {
+            labels->release(labels);
+            labels = NULL;
+        }
+        throw std::runtime_error(msg.str());
+    }
+
+    std::string version()
+    {
+        return CRFSUITE_VERSION;
+    }
+
+} // namespace CRFSuite
+
+#endif /*__CRFSUITE_HPP__*/
```

## chaine/_core/crfsuite/include/crfsuite_api.hpp

 * *Ordering differences only*

```diff
@@ -1,406 +1,406 @@
-/*
- *      CRFsuite C++/SWIG API.
- *
- * Copyright (c) 2007-2010, Naoaki Okazaki
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the names of the authors nor the names of its contributors
- *       may be used to endorse or promote products derived from this
- *       software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
- * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#ifndef __CRFSUITE_API_HPP__
-#define __CRFSUITE_API_HPP__
-
-#include <string>
-#include <stdexcept>
-#include <vector>
-#include <cstdarg>
-
-#ifndef __CRFSUITE_H__
-
-#ifdef __cplusplus
-extern "C"
-{
-#endif /*__cplusplus*/
-
-   struct tag_crfsuite_model;
-   typedef struct tag_crfsuite_model crfsuite_model_t;
-
-   struct tag_crfsuite_data;
-   typedef struct tag_crfsuite_data crfsuite_data_t;
-
-   struct tag_crfsuite_trainer;
-   typedef struct tag_crfsuite_trainer crfsuite_trainer_t;
-
-   struct tag_crfsuite_tagger;
-   typedef struct tag_crfsuite_tagger crfsuite_tagger_t;
-
-   struct tag_crfsuite_dictionary;
-   typedef struct tag_crfsuite_dictionary crfsuite_dictionary_t;
-
-   struct tag_crfsuite_params;
-   typedef struct tag_crfsuite_params crfsuite_params_t;
-
-#ifdef __cplusplus
-}
-#endif /*__cplusplus*/
-
-#endif /*__CRFSUITE_H__*/
-
-/**
-\page crfsuite_hpp_api CRFSuite C++/SWIG API
-
-@section crfsuite_hpp_api_intro Introduction
-
-The CRFSuite C++/SWIG API provides a high-level and easy-to-use library module
-for a number of programming languages. The C++/SWIG API is a wrapper for the
-CRFSuite C API.
-- @link crfsuite_hpp_api_doc API documentation @endlink
-
-@section crfsuite_hpp_api_cpp C++ API
-
-The C++ library is implemented in two header files, crfsuite_api.hpp and
-crfsuite.hpp. One can use the C++ API only by including crfsuite.hpp. The C++
-library has a dependency to the CRFSuite C library, which means that the
-C header file (crfsuite.h) and libcrfsuite library are necessary.
-
-@section crfsuite_hpp_api_swig SWIG API
-
-The SWIG API is identical to the C++ API. Currently, the CRFsuite distribution
-includes a Python module for CRFsuite. Please read README under swig/python
-directory for the information to build the Python module.
-
-@subsection crfsuite_hpp_api_sample Sample code
-
-This code demonstrates how to use the crfsuite.Trainer object. The script
-reads a training data from STDIN, trains a model using 'l2sgd' algorithm,
-and stores the model to a file (the first argument of the commend line).
-
-@include swig/python/sample_train.py
-
-This code demonstrates how to use the crfsuite.Tagger object. The script
-loads a model from a file (the first argument of the commend line), reads
-a data from STDIN, predicts label sequences.
-
-@include swig/python/sample_tag.py
-
- */
-
-namespace CRFSuite
-{
-
-   /**
-    * \addtogroup crfsuite_hpp_api_doc Data structures
-    * @{
-    */
-
-   /**
-    * Tuple of attribute and its value.
-    */
-   class Attribute
-   {
-   public:
-      /// Attribute.
-      std::string attr;
-      /// Attribute value (weight).
-      double value;
-
-      /**
-       * Construct an attribute with the default name and value.
-       */
-      Attribute() : value(1.)
-      {
-      }
-
-      /**
-       * Construct an attribute with the default value.
-       *  @param  name        The attribute name.
-       */
-      Attribute(const std::string &name) : attr(name), value(1.)
-      {
-      }
-
-      /**
-       * Construct an attribute.
-       *  @param  name        The attribute name.
-       *  @param  val         The attribute value.
-       */
-      Attribute(const std::string &name, double val) : attr(name), value(val)
-      {
-      }
-   };
-
-   /**
-    * Type of an item (equivalent to an attribute vector) in a sequence.
-    */
-   typedef std::vector<Attribute> Item;
-
-   /**
-    * Type of an item sequence (equivalent to item vector).
-    */
-   typedef std::vector<Item> ItemSequence;
-
-   /**
-    * Type of a string list.
-    */
-   typedef std::vector<std::string> StringList;
-
-   /**
-    * The trainer class.
-    *  This class maintains a data set for training, and provides an interface
-    *  to various graphical models and training algorithms. The standard
-    *  procedure for implementing a trainer is:
-    *  - create a class by inheriting this class
-    *  - overwrite message() function to receive messages of training progress
-    *  - call append() to append item/label sequences to the training set
-    *  - call select() to specify a graphical model and an algorithm
-    *  - call set() to configure parameters specific to the model and algorithm
-    *  - call train() to start a training process with the current setting
-    */
-   class Trainer
-   {
-   protected:
-      crfsuite_data_t *data;
-      crfsuite_trainer_t *tr;
-
-   public:
-      /**
-       * Construct a trainer.
-       */
-      Trainer();
-
-      /**
-       * Destruct a trainer.
-       */
-      virtual ~Trainer();
-
-      /**
-       * Remove all instances in the data set.
-       */
-      void clear();
-
-      /**
-       * Append an instance (item/label sequence) to the data set.
-       *  @param  xseq        The item sequence of the instance.
-       *  @param  yseq        The label sequence of the instance. The number
-       *                      of elements in yseq must be identical to that
-       *                      in xseq.
-       *  @param  group       The group number of the instance.
-       *  @throw  std::invalid_argument   Arguments xseq and yseq are invalid.
-       *  @throw  std::runtime_error      Out of memory.
-       */
-      void append(const ItemSequence &xseq, const StringList &yseq, int group);
-
-      /**
-       * Initialize the training algorithm.
-       *  @param  algorithm   The name of the training algorithm.
-       *  @param  type        The name of the graphical model.
-       *  @return bool        \c true if the training algorithm is successfully
-       *                      initialized, \c false otherwise.
-       */
-      bool select(const std::string &algorithm, const std::string &type);
-
-      /**
-       * Run the training algorithm.
-       *  This function starts the training algorithm with the data set given
-       *  by append() function. After starting the training process, the
-       *  training algorithm invokes the virtual function message() to report
-       *  the progress of the training process.
-       *  @param  model       The filename to which the trained model is stored.
-       *                      If this value is empty, this function does not
-       *                      write out a model file.
-       *  @param  holdout     The group number of holdout evaluation. The
-       *                      instances with this group number will not be used
-       *                      for training, but for holdout evaluation. Specify
-       *                      \c -1 to use all instances for training.
-       *  @return int         The status code.
-       */
-      int train(const std::string &model, int holdout);
-
-      /**
-       * Obtain the list of parameters.
-       *  This function returns the list of parameter names available for the
-       *  graphical model and training algorithm specified by select() function.
-       *  @return StringList  The list of parameters available for the current
-       *                      graphical model and training algorithm.
-       */
-      StringList params();
-
-      /**
-       * Set a training parameter.
-       *  This function sets a parameter value for the graphical model and
-       *  training algorithm specified by select() function.
-       *  @param  name        The parameter name.
-       *  @param  value       The value of the parameter.
-       *  @throw  std::invalid_argument   The parameter is not found.
-       */
-      void set(const std::string &name, const std::string &value);
-
-      /**
-       * Get the value of a training parameter.
-       *  This function gets a parameter value for the graphical model and
-       *  training algorithm specified by select() function.
-       *  @param  name        The parameter name.
-       *  @return std::string The value of the parameter.
-       *  @throw  std::invalid_argument   The parameter is not found.
-       */
-      std::string get(const std::string &name);
-
-      /**
-       * Get the description of a training parameter.
-       *  This function obtains the help message for the parameter specified
-       *  by the name. The graphical model and training algorithm must be
-       *  selected by select() function before calling this function.
-       *  @param  name        The parameter name.
-       *  @return std::string The description (help message) of the parameter.
-       */
-      std::string help(const std::string &name);
-
-      /**
-       * Receive messages from the training algorithm.
-       *  Override this member function to receive messages of the training
-       *  process.
-       *  @param  msg         The message
-       */
-      virtual void message(const std::string &msg);
-
-   protected:
-      void init();
-      static int __logging_callback(void *userdata, const char *format, va_list args);
-   };
-
-   /**
-    * The tagger class.
-    *  This class provides the functionality for predicting label sequences for
-    *  input sequences using a model.
-    */
-   class Tagger
-   {
-   protected:
-      crfsuite_model_t *model;
-      crfsuite_tagger_t *tagger;
-
-   public:
-      /**
-       * Construct a tagger.
-       */
-      Tagger();
-
-      /**
-       * Destruct a tagger.
-       */
-      virtual ~Tagger();
-
-      /**
-       * Open a model file.
-       *  @param  name        The file name of the model file.
-       *  @return bool        \c true if the model file is successfully opened,
-       *                      \c false otherwise (e.g., when the model file is
-       *                      not found).
-       *  @throw  std::runtime_error      An internal error in the model.
-       */
-      bool open(const std::string &name);
-
-      /**
-       * Open a model from memory.
-       *  @param  data        A pointer to the model data.
-       *                      Must be 16-byte aligned.
-       *  @param  size        A size (in bytes) of the model data.
-       *  @return bool        \c true if the model file is successfully opened,
-       *                      \c false otherwise (e.g., when the mode file is
-       *                      not found).
-       *  @throw  std::runtime_error      An internal error in the model.
-       */
-      bool open(const void *data, std::size_t size);
-
-      /**
-       * Close the model.
-       */
-      void close();
-
-      /**
-       * Obtain the list of labels.
-       *  @return StringList  The list of labels in the model.
-       *  @throw  std::invalid_argument   A model is not opened.
-       *  @throw  std::runtime_error      An internal error.
-       */
-      StringList labels();
-
-      /**
-       * Predict the label sequence for the item sequence.
-       *  This function calls set() and viterbi() functions to obtain the
-       *  label sequence predicted for the item sequence.
-       *  @param  xseq        The item sequence to be tagged.
-       *  @return StringList  The label sequence predicted.
-       *  @throw  std::invalid_argument   A model is not opened.
-       *  @throw  std::runtime_error      An internal error.
-       */
-      StringList tag(const ItemSequence &xseq);
-
-      /**
-       * Set an item sequence.
-       *  This function sets an item sequence for future calls for
-       *  viterbi(), probability(), and marginal() functions.
-       *  @param  xseq        The item sequence to be tagged
-       *  @throw  std::invalid_argument   A model is not opened.
-       *  @throw  std::runtime_error      An internal error.
-       */
-      void set(const ItemSequence &xseq);
-
-      /**
-       * Find the Viterbi label sequence for the item sequence.
-       *  @return StringList  The label sequence predicted.
-       *  @throw  std::invalid_argument   A model is not opened.
-       *  @throw  std::runtime_error      An internal error.
-       */
-      StringList viterbi();
-
-      /**
-       * Compute the probability of the label sequence.
-       *  @param  yseq        The label sequence.
-       *  @throw  std::invalid_argument   A model is not opened.
-       *  @throw  std::runtime_error      An internal error.
-       */
-      double probability(const StringList &yseq);
-
-      /**
-       * Compute the marginal probability of the label.
-       *  @param  y           The label.
-       *  @param  t           The position of the label.
-       *  @throw  std::invalid_argument   A model is not opened.
-       *  @throw  std::runtime_error      An internal error.
-       */
-      double marginal(const std::string &y, const int t);
-   };
-
-   /**
-    * Obtain the version number of the library.
-    *  @return std::string     The version string.
-    */
-   std::string version();
-
-   /**@} */
-
-} // namespace CRFSuite
-
-#endif /*__CRFSUITE_API_HPP__*/
+/*
+ *      CRFsuite C++/SWIG API.
+ *
+ * Copyright (c) 2007-2010, Naoaki Okazaki
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the names of the authors nor the names of its contributors
+ *       may be used to endorse or promote products derived from this
+ *       software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+ * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __CRFSUITE_API_HPP__
+#define __CRFSUITE_API_HPP__
+
+#include <string>
+#include <stdexcept>
+#include <vector>
+#include <cstdarg>
+
+#ifndef __CRFSUITE_H__
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif /*__cplusplus*/
+
+   struct tag_crfsuite_model;
+   typedef struct tag_crfsuite_model crfsuite_model_t;
+
+   struct tag_crfsuite_data;
+   typedef struct tag_crfsuite_data crfsuite_data_t;
+
+   struct tag_crfsuite_trainer;
+   typedef struct tag_crfsuite_trainer crfsuite_trainer_t;
+
+   struct tag_crfsuite_tagger;
+   typedef struct tag_crfsuite_tagger crfsuite_tagger_t;
+
+   struct tag_crfsuite_dictionary;
+   typedef struct tag_crfsuite_dictionary crfsuite_dictionary_t;
+
+   struct tag_crfsuite_params;
+   typedef struct tag_crfsuite_params crfsuite_params_t;
+
+#ifdef __cplusplus
+}
+#endif /*__cplusplus*/
+
+#endif /*__CRFSUITE_H__*/
+
+/**
+\page crfsuite_hpp_api CRFSuite C++/SWIG API
+
+@section crfsuite_hpp_api_intro Introduction
+
+The CRFSuite C++/SWIG API provides a high-level and easy-to-use library module
+for a number of programming languages. The C++/SWIG API is a wrapper for the
+CRFSuite C API.
+- @link crfsuite_hpp_api_doc API documentation @endlink
+
+@section crfsuite_hpp_api_cpp C++ API
+
+The C++ library is implemented in two header files, crfsuite_api.hpp and
+crfsuite.hpp. One can use the C++ API only by including crfsuite.hpp. The C++
+library has a dependency to the CRFSuite C library, which means that the
+C header file (crfsuite.h) and libcrfsuite library are necessary.
+
+@section crfsuite_hpp_api_swig SWIG API
+
+The SWIG API is identical to the C++ API. Currently, the CRFsuite distribution
+includes a Python module for CRFsuite. Please read README under swig/python
+directory for the information to build the Python module.
+
+@subsection crfsuite_hpp_api_sample Sample code
+
+This code demonstrates how to use the crfsuite.Trainer object. The script
+reads a training data from STDIN, trains a model using 'l2sgd' algorithm,
+and stores the model to a file (the first argument of the commend line).
+
+@include swig/python/sample_train.py
+
+This code demonstrates how to use the crfsuite.Tagger object. The script
+loads a model from a file (the first argument of the commend line), reads
+a data from STDIN, predicts label sequences.
+
+@include swig/python/sample_tag.py
+
+ */
+
+namespace CRFSuite
+{
+
+   /**
+    * \addtogroup crfsuite_hpp_api_doc Data structures
+    * @{
+    */
+
+   /**
+    * Tuple of attribute and its value.
+    */
+   class Attribute
+   {
+   public:
+      /// Attribute.
+      std::string attr;
+      /// Attribute value (weight).
+      double value;
+
+      /**
+       * Construct an attribute with the default name and value.
+       */
+      Attribute() : value(1.)
+      {
+      }
+
+      /**
+       * Construct an attribute with the default value.
+       *  @param  name        The attribute name.
+       */
+      Attribute(const std::string &name) : attr(name), value(1.)
+      {
+      }
+
+      /**
+       * Construct an attribute.
+       *  @param  name        The attribute name.
+       *  @param  val         The attribute value.
+       */
+      Attribute(const std::string &name, double val) : attr(name), value(val)
+      {
+      }
+   };
+
+   /**
+    * Type of an item (equivalent to an attribute vector) in a sequence.
+    */
+   typedef std::vector<Attribute> Item;
+
+   /**
+    * Type of an item sequence (equivalent to item vector).
+    */
+   typedef std::vector<Item> ItemSequence;
+
+   /**
+    * Type of a string list.
+    */
+   typedef std::vector<std::string> StringList;
+
+   /**
+    * The trainer class.
+    *  This class maintains a data set for training, and provides an interface
+    *  to various graphical models and training algorithms. The standard
+    *  procedure for implementing a trainer is:
+    *  - create a class by inheriting this class
+    *  - overwrite message() function to receive messages of training progress
+    *  - call append() to append item/label sequences to the training set
+    *  - call select() to specify a graphical model and an algorithm
+    *  - call set() to configure parameters specific to the model and algorithm
+    *  - call train() to start a training process with the current setting
+    */
+   class Trainer
+   {
+   protected:
+      crfsuite_data_t *data;
+      crfsuite_trainer_t *tr;
+
+   public:
+      /**
+       * Construct a trainer.
+       */
+      Trainer();
+
+      /**
+       * Destruct a trainer.
+       */
+      virtual ~Trainer();
+
+      /**
+       * Remove all instances in the data set.
+       */
+      void clear();
+
+      /**
+       * Append an instance (item/label sequence) to the data set.
+       *  @param  xseq        The item sequence of the instance.
+       *  @param  yseq        The label sequence of the instance. The number
+       *                      of elements in yseq must be identical to that
+       *                      in xseq.
+       *  @param  group       The group number of the instance.
+       *  @throw  std::invalid_argument   Arguments xseq and yseq are invalid.
+       *  @throw  std::runtime_error      Out of memory.
+       */
+      void append(const ItemSequence &xseq, const StringList &yseq, int group);
+
+      /**
+       * Initialize the training algorithm.
+       *  @param  algorithm   The name of the training algorithm.
+       *  @param  type        The name of the graphical model.
+       *  @return bool        \c true if the training algorithm is successfully
+       *                      initialized, \c false otherwise.
+       */
+      bool select(const std::string &algorithm, const std::string &type);
+
+      /**
+       * Run the training algorithm.
+       *  This function starts the training algorithm with the data set given
+       *  by append() function. After starting the training process, the
+       *  training algorithm invokes the virtual function message() to report
+       *  the progress of the training process.
+       *  @param  model       The filename to which the trained model is stored.
+       *                      If this value is empty, this function does not
+       *                      write out a model file.
+       *  @param  holdout     The group number of holdout evaluation. The
+       *                      instances with this group number will not be used
+       *                      for training, but for holdout evaluation. Specify
+       *                      \c -1 to use all instances for training.
+       *  @return int         The status code.
+       */
+      int train(const std::string &model, int holdout);
+
+      /**
+       * Obtain the list of parameters.
+       *  This function returns the list of parameter names available for the
+       *  graphical model and training algorithm specified by select() function.
+       *  @return StringList  The list of parameters available for the current
+       *                      graphical model and training algorithm.
+       */
+      StringList params();
+
+      /**
+       * Set a training parameter.
+       *  This function sets a parameter value for the graphical model and
+       *  training algorithm specified by select() function.
+       *  @param  name        The parameter name.
+       *  @param  value       The value of the parameter.
+       *  @throw  std::invalid_argument   The parameter is not found.
+       */
+      void set(const std::string &name, const std::string &value);
+
+      /**
+       * Get the value of a training parameter.
+       *  This function gets a parameter value for the graphical model and
+       *  training algorithm specified by select() function.
+       *  @param  name        The parameter name.
+       *  @return std::string The value of the parameter.
+       *  @throw  std::invalid_argument   The parameter is not found.
+       */
+      std::string get(const std::string &name);
+
+      /**
+       * Get the description of a training parameter.
+       *  This function obtains the help message for the parameter specified
+       *  by the name. The graphical model and training algorithm must be
+       *  selected by select() function before calling this function.
+       *  @param  name        The parameter name.
+       *  @return std::string The description (help message) of the parameter.
+       */
+      std::string help(const std::string &name);
+
+      /**
+       * Receive messages from the training algorithm.
+       *  Override this member function to receive messages of the training
+       *  process.
+       *  @param  msg         The message
+       */
+      virtual void message(const std::string &msg);
+
+   protected:
+      void init();
+      static int __logging_callback(void *userdata, const char *format, va_list args);
+   };
+
+   /**
+    * The tagger class.
+    *  This class provides the functionality for predicting label sequences for
+    *  input sequences using a model.
+    */
+   class Tagger
+   {
+   protected:
+      crfsuite_model_t *model;
+      crfsuite_tagger_t *tagger;
+
+   public:
+      /**
+       * Construct a tagger.
+       */
+      Tagger();
+
+      /**
+       * Destruct a tagger.
+       */
+      virtual ~Tagger();
+
+      /**
+       * Open a model file.
+       *  @param  name        The file name of the model file.
+       *  @return bool        \c true if the model file is successfully opened,
+       *                      \c false otherwise (e.g., when the model file is
+       *                      not found).
+       *  @throw  std::runtime_error      An internal error in the model.
+       */
+      bool open(const std::string &name);
+
+      /**
+       * Open a model from memory.
+       *  @param  data        A pointer to the model data.
+       *                      Must be 16-byte aligned.
+       *  @param  size        A size (in bytes) of the model data.
+       *  @return bool        \c true if the model file is successfully opened,
+       *                      \c false otherwise (e.g., when the mode file is
+       *                      not found).
+       *  @throw  std::runtime_error      An internal error in the model.
+       */
+      bool open(const void *data, std::size_t size);
+
+      /**
+       * Close the model.
+       */
+      void close();
+
+      /**
+       * Obtain the list of labels.
+       *  @return StringList  The list of labels in the model.
+       *  @throw  std::invalid_argument   A model is not opened.
+       *  @throw  std::runtime_error      An internal error.
+       */
+      StringList labels();
+
+      /**
+       * Predict the label sequence for the item sequence.
+       *  This function calls set() and viterbi() functions to obtain the
+       *  label sequence predicted for the item sequence.
+       *  @param  xseq        The item sequence to be tagged.
+       *  @return StringList  The label sequence predicted.
+       *  @throw  std::invalid_argument   A model is not opened.
+       *  @throw  std::runtime_error      An internal error.
+       */
+      StringList tag(const ItemSequence &xseq);
+
+      /**
+       * Set an item sequence.
+       *  This function sets an item sequence for future calls for
+       *  viterbi(), probability(), and marginal() functions.
+       *  @param  xseq        The item sequence to be tagged
+       *  @throw  std::invalid_argument   A model is not opened.
+       *  @throw  std::runtime_error      An internal error.
+       */
+      void set(const ItemSequence &xseq);
+
+      /**
+       * Find the Viterbi label sequence for the item sequence.
+       *  @return StringList  The label sequence predicted.
+       *  @throw  std::invalid_argument   A model is not opened.
+       *  @throw  std::runtime_error      An internal error.
+       */
+      StringList viterbi();
+
+      /**
+       * Compute the probability of the label sequence.
+       *  @param  yseq        The label sequence.
+       *  @throw  std::invalid_argument   A model is not opened.
+       *  @throw  std::runtime_error      An internal error.
+       */
+      double probability(const StringList &yseq);
+
+      /**
+       * Compute the marginal probability of the label.
+       *  @param  y           The label.
+       *  @param  t           The position of the label.
+       *  @throw  std::invalid_argument   A model is not opened.
+       *  @throw  std::runtime_error      An internal error.
+       */
+      double marginal(const std::string &y, const int t);
+   };
+
+   /**
+    * Obtain the version number of the library.
+    *  @return std::string     The version string.
+    */
+   std::string version();
+
+   /**@} */
+
+} // namespace CRFSuite
+
+#endif /*__CRFSUITE_API_HPP__*/
```

## chaine/_core/crfsuite/include/os.h

 * *Ordering differences only*

```diff
@@ -1,65 +1,65 @@
-/*
- *        Compatibility stuff among operating systems and compilers.
- *
- * Copyright (c) 2007-2010, Naoaki Okazaki
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the names of the authors nor the names of its contributors
- *       may be used to endorse or promote products derived from this
- *       software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
- * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-/* $Id$ */
-
-#ifndef __OS_H__
-#define __OS_H__
-
-//#define    __SSE__ 1
-#define LBFGS_FLOAT 64
-
-#ifdef _MSC_VER
-/* Microsoft Visual C/C++ specific */
-
-#define _CRT_SECURE_NO_WARNINGS 1
-#pragma warning(disable : 4996)
-
-#define alloca _alloca
-#define strdup _strdup
-#define open _open
-
-#if _MSC_VER < 1900
-/* Pre Microsoft Visual C 2015 */
-
-#define isfinite _finite
-#define snprintf _snprintf
-#endif /*_MSC_VER < 1900 */
-
-#ifndef __cplusplus
-/* Microsoft Visual C specific */
-
-#define inline __forceinline
-
-#endif /*__cplusplus*/
-
-#endif /*_MSC_VER*/
-
-#endif /*__OS_H__*/
+/*
+ *        Compatibility stuff among operating systems and compilers.
+ *
+ * Copyright (c) 2007-2010, Naoaki Okazaki
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the names of the authors nor the names of its contributors
+ *       may be used to endorse or promote products derived from this
+ *       software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+ * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/* $Id$ */
+
+#ifndef __OS_H__
+#define __OS_H__
+
+//#define    __SSE__ 1
+#define LBFGS_FLOAT 64
+
+#ifdef _MSC_VER
+/* Microsoft Visual C/C++ specific */
+
+#define _CRT_SECURE_NO_WARNINGS 1
+#pragma warning(disable : 4996)
+
+#define alloca _alloca
+#define strdup _strdup
+#define open _open
+
+#if _MSC_VER < 1900
+/* Pre Microsoft Visual C 2015 */
+
+#define isfinite _finite
+#define snprintf _snprintf
+#endif /*_MSC_VER < 1900 */
+
+#ifndef __cplusplus
+/* Microsoft Visual C specific */
+
+#define inline __forceinline
+
+#endif /*__cplusplus*/
+
+#endif /*_MSC_VER*/
+
+#endif /*__OS_H__*/
```

## chaine/_core/crfsuite/lib/cqdb/COPYING

 * *Ordering differences only*

```diff
@@ -1,28 +1,28 @@
-The BSD license.
-
-Copyright (c) 2007, Naoaki Okazaki
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in the
-      documentation and/or other materials provided with the distribution.
-    * Neither the name of the Northwestern University, University of Tokyo,
-      nor the names of its contributors may be used to endorse or promote
-      products derived from this software without specific prior written
-      permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
-OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
-EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
-PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+The BSD license.
+
+Copyright (c) 2007, Naoaki Okazaki
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+    * Neither the name of the Northwestern University, University of Tokyo,
+      nor the names of its contributors may be used to endorse or promote
+      products derived from this software without specific prior written
+      permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
```

## chaine/_core/crfsuite/lib/cqdb/include/cqdb.h

 * *Ordering differences only*

```diff
@@ -1,518 +1,518 @@
-/*
- *      Constant Quark Database (CQDB).
- *
- * Copyright (c) 2007, Naoaki Okazaki
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of the Northwestern University, University of Tokyo,
- *       nor the names of its contributors may be used to endorse or promote
- *       products derived from this software without specific prior written
- *       permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
- * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-/* $Id$ */
-
-#ifndef __CQDB_H__
-#define __CQDB_H__
-
-/** @file */
-
-/**
- * \addtogroup cqdb_const CQDB Constants
- * @{
- *
- *    The CQDB Constants.
- */
-
-/**
- * CQDB flags.
- */
-enum
-{
-    CQDB_NONE = 0,                    /**< No flag. */
-    CQDB_ONEWAY = 0x00000001,         /**< A reverse lookup array is omitted. */
-    CQDB_ERROR_OCCURRED = 0x00010000, /**< An error has occurred. */
-};
-
-/**
- * CQDB status codes.
- */
-enum
-{
-    CQDB_SUCCESS = 0,       /**< Success. */
-    CQDB_ERROR = -1024,     /**< Unspecified error. */
-    CQDB_ERROR_NOTFOUND,    /**< String not found. */
-    CQDB_ERROR_OUTOFMEMORY, /**< Insufficient memory. */
-    CQDB_ERROR_FILEWRITE,   /**< Error in fwrite() operations. */
-    CQDB_ERROR_FILETELL,    /**< Error in ftell() operations. */
-    CQDB_ERROR_FILESEEK,    /**< Error in fseek() operations. */
-    CQDB_ERROR_INVALIDID,   /**< Invalid parameters. */
-};
-
-/** @} */
-
-/**
- * \addtogroup cqdb_writer CQDB Writer API
- * @{
- *
- *    The CQDB Writer API constructs a CQDB chunk on a seekable stream. The
- *    seekable stream must be created by the fopen() function with writable and
- *    binary flags ("wb"). The CQDB Writer API can build a CQDB chunk at any
- *    position on the stream; one can thus write some data, append a CQDB chunk,
- *    and continue writing other data on the stream.
- *
- *    By default, the function cqdb_writer() constructs a database with forward
- *    (string to integer identifier) and backward (integer identifier to string)
- *    lookups. The data for reverse lookup is omitted with ::CQDB_ONEWAY flag
- *    specified.
- *
- *    It is recommended to keep the maximum number of identifiers as smallest as
- *    possible because reverse lookup is maintained by a array with the size of
- *    sizeof(int) * (maximum number of identifiers + 1). For example, putting a
- *    set of integer identifers (0, 1, 1000) creates a reverse lookup array with
- *    1001 elements only to waste the disk space for 998 (= 1001-3) elements in
- *    the array.
- */
-
-struct tag_cqdb_writer;
-typedef struct tag_cqdb_writer cqdb_writer_t; /**< Typedef of a CQDB writer. */
-
-/**
- * Create a new CQDB writer on a seekable stream.
- *
- *    This function initializes a database on the seekable stream and returns
- *    the pointer to a ::cqdb_writer_t instance to write the database.
- *    The stream must have the writable and binary flags. The database creation
- *    flag must be zero except when the reverse lookup array is unnecessary;
- *    specifying ::CQDB_ONEWAY flag will save the storage space for the reverse
- *    lookup array. Once calling this function, one should avoid accessing the
- *    seekable stream directly until calling cqdb_writer_close().
- *
- *    @param    fp                The pointer to the writable and seekable stream.
- *    @param    flag            Database creation flag.
- *    @retval    cqdb_writer_t*    The pointer to the new ::cqdb_writer_t instance if
- *                            successful; otherwise \c NULL.
- */
-cqdb_writer_t *cqdb_writer(FILE *fp, int flag);
-
-/**
- * Put a string/identifier association to the database.
- *
- *    This function append a string/identifier association into the database.
- *    Make sure that the string and/or identifier have never been inserted to
- *    the database and that the identifier is a non-negative value.
- *
- *    @param    dbw            The pointer to the ::cqdb_writer_t instance.
- *    @param    str            The pointer to the string.
- *    @param    id            The identifier.
- *    @retval    int            Zero if successful, or a status code otherwise.
- */
-int cqdb_writer_put(cqdb_writer_t *dbw, const char *str, int id);
-
-/**
- * Close a CQDB writer.
- *
- *    This function finalizes the database on the stream. If successful, the
- *    data remaining on the memory is flushed to the stream; the stream position
- *    is moved to the end of the chunk. If an unexpected error occurs, this
- *    function tries to rewind the stream position to the original position when
- *    the function cqdb_writer() was called.
- *
- *    @param    dbw            The pointer to the ::cqdb_writer_t instance.
- *    @retval    int            Zero if successful, or a status code otherwise.
- */
-int cqdb_writer_close(cqdb_writer_t *dbw);
-
-/** @} */
-
-/**
- * \addtogroup cqdb_reader CQDB Reader API
- * @{
- *
- *    The CQDB reader API provides a read access to the database whose memory
- *    image is loaded on a memory block. The memory-passing interface has
- *    several advantages. Firstly, one can choose an efficient way for their
- *    application to load a database image to a memory block, e.g., to read
- *    the whole image from a file, to use the Memory Mapped File (mmap) API,
- *    etc.
- *    Secondaly, one can design the file format freely only if the memory
- *    block for a database is extracted from the file.
- *
- *    The most fundamental operation on the CQDB reader API is forward lookup
- *    through the use of cqdb_to_id() function, which retrieves integer
- *    identifiers from strings. Reverse lookup (retrieving strings from integer
- *    identifiers) with cqdb_to_string() function is not supported if the
- *    database has been created with ::CQDB_ONEWAY flag.
- */
-
-struct tag_cqdb;
-typedef struct tag_cqdb cqdb_t; /**< Typedef of a CQDB reader. */
-
-/**
- * Open a new CQDB reader on a memory block.
- *
- *    This function initializes a database on a memory block and returns the
- *    pointer to a ::cqdb_t instance to access the database.
- *
- *    @param    buffer        The pointer to the memory block.
- *    @param    size        The size of the memory block.
- *    @retval    cqdb_t*        The pointer to the ::cqdb_t instance.
- */
-cqdb_t *cqdb_reader(const void *buffer, size_t size);
-
-/**
- * Delete the CQDB reader.
- *
- *    This function frees the work area allocated by cqdb_reader() function.
- *
- *    @param    db            The pointer to the ::cqdb_t instance.
- */
-void cqdb_delete(cqdb_t *db);
-
-/**
- * Retrieve the identifier associated with a string.
- *
- *    This function returns the identifier associated with a string.
- *
- *    @param    db            The pointer to the ::cqdb_t instance.
- *    @param    str            The pointer to a string.
- *    @retval    int            The non-negative identifier if successful, negative
- *                        status code otherwise.
- */
-int cqdb_to_id(cqdb_t *db, const char *str);
-
-/**
- * Retrieve the string associated with an identifier.
- *
- *    This function returns the string associated with an identifier.
- *
- *    @param    db            The pointer to the cqdb_t instance.
- *    @param    id            The id.
- *    @retval    const char*    The pointer to the string associated with the
- *                        identifier if successful; otherwise \c NULL.
- */
-const char *cqdb_to_string(cqdb_t *db, int id);
-
-/**
- * Get the number of associations in the database.
- *
- *    This function returns the number of associations in the database.
- *
- *    @param    db            The pointer to the ::cqdb_t instance.
- *    @retval    int            The number of string/identifier associations.
- */
-int cqdb_num(cqdb_t *db);
-
-/** @} */
-
-/**
-@mainpage Constant Quark Database (CQDB)
-
-@section intro Introduction
-
-It is a common technique for speed and memory optimizations that an
-application converts all string values into integer identifiers, does some
-processing with integer values, and then restores the original string values
-(if necessary). The data structure for two-way associations between strings
-and integer identifiers is known as Quark:
-- GQuark in GLib: http://www.gtk.org/
-- quark (C++): http://www.chokkan.org/software/sample/quark.h
-
-Constant Quark Database (CQDB) is a database library specialized for
-serialization and retrieval of <i>static</i> associations between strings and
-integer identifiers. The database provides several features:
-- <b>Fast look-ups.</b> Retrieving an integer identifier for a string is
-  usually done by accessing three memory blocks. Retrieving a string for an
-  integer identifier is always done by accessing two memory blocks.
-  See the @ref performance "performance" evaluation.
-- <b>Low overhead.</b> A CQDB database consists of a chunk header (24 bytes),
-  hash tables (2048 bytes and 16 bytes per record), a reverse lookup array
-  (4 bytes per integer identifier), and records (8 bytes + string size per
-  record).
-  See the @ref performance "performance" evaluation.
-- <b>Sophisticated hash function.</b> CQDB incorporates the fast and
-  collision-resistant hash function for strings
-  (<a href="http://www.burtleburtle.net/bob/c/lookup3.c">lookup3.c</a>)
-  implemented by Bob Jenkins.
-- <b>Chunk format.</b> The structure of CQDB is designed to store the data in
-  a chunk of a file; CQDB can be embedded into a file with other arbitrary
-  data.
-- <b>Omissible reverse look-up array.</b> The reverse look-up array can be
-  omitted if it is not necessary to retrieve strings from integer identifiers.
-- <b>Cross platform.</b> The source code can be compiled on Microsoft Visual
-  Studio 2005, GNU C Compiler (gcc), etc.
-- <b>Simple API.</b> The CQDB API exposes only a few functions.
-
-CQDB is suitable for implementing dictionaries in which fast look-ups of
-strings and identifiers are essential while a dictionary update rarely occurs.
-The data structure is a specialization (and extension) of the
-<a href="http://cr.yp.to/cdb.html">Constant Database</a> proposed by
-Daniel J. Bernstein.
-
-CQDB does not support assigning a unique integer identifier for a given string,
-modify associations, nor check collisions in strings and identifiers; thus,
-it may be necessary to use an existing Quark implementation to manage proper
-associations between strings and identifiers on memory.
-
-This library is used by the
-<a href="http://www.chokkan.org/software/crfsuite/">CRFsuite</a> project.
-
-@section download Download
-
-- <a href="http://www.chokkan.org/software/dist/cqdb-1.1.tar.gz">Source code</a>
-
-CQDB is distributed under the term of the
-<a href="http://www.opensource.org/licenses/bsd-license.php">modified BSD license</a>.
-
-@section changelog History
-- Version 1.1 (2007-12-01):
-    - Fixed a bug when a CQDB chunk is embedded to a file.
-
-- Version 1.0 (2007-09-20):
-    - Initial release.
-
-@section api Documentation
-
-- @ref cqdb_const "CQDB Constants"
-- @ref cqdb_reader "CQDB Reader API"
-- @ref cqdb_writer "CQDB Writer API"
-
-@section sample Sample programs
-@subsection sample_writer A writer sample
-
-This sample code constructs a database "test.cqdb" with 1,000,000
-string/identifier associations,
-"00000000"/0, "00000001"/1, ..., "01000000"/1000000.
-
-@code
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include "cqdb.h"
-
-#define    DBNAME        "test.cqdb"
-#define    NUMELEMS    1000000
-
-int main(int argc, char *argv[])
-{
-    int i, ret;
-    char str[10];
-    FILE *fp = NULL;
-    cqdb_writer_t* dbw = NULL;
-
-    // Open a file for writing.
-    fp = fopen(DBNAME, "wb");
-    if (fp == NULL) {
-        fprintf(stderr, "ERROR: failed to open the file.\n");
-        return 1;
-    }
-
-    // Create a CQDB on the file stream.
-    dbw = cqdb_writer(fp, 0);
-    if (dbw == NULL) {
-        fprintf(stderr, "ERROR: failed to create a CQDB on the file.\n");
-        goto error_exit;
-    }
-
-    // Put string/integer associations, "00000001"/1, ..., "01000000"/1000000.
-    for (i = 0;i < NUMELEMS;++i) {
-        sprintf(str, "%08d", i);
-        if (ret = cqdb_writer_put(dbw, str, i)) {
-            fprintf(stderr, "ERROR: failed to put a pair '%s'/%d.\n", str, i);
-            goto error_exit;
-        }
-    }
-
-    // Close the CQDB.
-    if (ret = cqdb_writer_close(dbw)) {
-        fprintf(stderr, "ERROR: failed to close the CQDB.\n");
-        goto error_exit;
-    }
-
-    // Close the file.
-    fclose(fp);
-    return 0;
-
-error_exit:
-    if (dbw != NULL) cqdb_writer_close(dbw);
-    if (fp != NULL) fclose(fp);
-    return 1;
-}
-
-@endcode
-
-@subsection sample_reader A reader sample
-
-This sample code issues string queries "00000000", ..., "01000000" to retrive
-integer identifiers (forward lookups) and integer queries 0, ..., 1000000 to
-retrieve the strings  "00000000", ..., "01000000".
-
-@code
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include "cqdb.h"
-
-#define    DBNAME        "test.cqdb"
-#define    NUMELEMS    1000000
-
-int main(int argc, char *argv[])
-{
-    int i, j, ret;
-    long size = 0;
-    char str[10], *value = NULL, *buffer = NULL;
-    FILE *fp = NULL;
-    cqdb_t* db = NULL;
-
-    // Open the database.
-    fp = fopen(DBNAME, "rb");
-    if (fp == NULL) {
-        fprintf(stderr, "ERROR: failed to open the file\n");
-        return 1;
-    }
-
-    // Obtain the file size.
-    fseek(fp, 0, SEEK_END);
-    size = ftell(fp);
-    fseek(fp, 0, SEEK_SET);
-
-    // Read the content of the file at a time.
-    buffer = (char *)malloc(size);
-    if (buffer == NULL) {
-        fprintf(stderr, "ERROR: out of memory.\n");
-        goto error_exit;
-    }
-    fread(buffer, 1, size, fp);
-    fclose(fp);
-    fp = NULL;
-
-    // Open the database on the memory.
-    db = cqdb_reader(buffer, size);
-    if (db == NULL) {
-        fprintf(stderr, "ERROR: failed to open a CQDB on the file.\n");
-        goto error_exit;
-    }
-
-    // Forward lookups: strings to integer identifiers.
-    for (i = 0;i < NUMELEMS;++i) {
-        sprintf(str, "%08d", i);
-        j = cqdb_to_id(db, str);
-        // Validity check.
-        if (j < 0 || i != j) {
-            fprintf(stderr, "ERROR: inconsistency error '%s'/%d.\n", str, i);
-            goto error_exit;
-        }
-    }
-
-    // Reverse lookups: integer identifiers to strings.
-    for (i = 0;i < NUMELEMS;++i) {
-        sprintf(str, "%08d", i);
-        value = cqdb_to_string(db, i);
-        // Validity check.
-        if (value == NULL || strcmp(str, value) != 0) {
-            fprintf(stderr, "ERROR: inconsistency error '%s'/%d.\n", str, i);
-            goto error_exit;
-        }
-    }
-
-    // Delete the instance of the CQDB.
-    cqdb_delete(db);
-    free(buffer);
-
-    return 0;
-
-error_exit:
-    if (fp != NULL) fclose(fp);
-    if (buffer != NULL) free(buffer);
-    return 1;
-}
-
-@endcode
-
-@section performance Performance
-
-An experiment for performance comparision with
-<a href="http://www.oracle.com/database/berkeley-db/">Berkeley DB (BDB) 4.5.20</a>
-and <a href="http://qdbm.sourceforge.net/">Quick Database Manager (QDBM) 1.8.75</a>
-was conducted.
-Constructing a database with 1,000,000 string/identifier associations,
-"00000000"/0, "00000001"/1, ..., "01000000"/1000000, this experiment issued
-string queries "00000000", ..., "01000000" (forward lookups) and integer
-queries 0, ..., 1000000 (reverse lookups) to the database. Since BDB and
-QDBM do not support reverse lookups, reverse items (key: identifier,
-value: string) were inserted to the database in addition to the forward items
-(key: string, value: integer). Microsoft Windows Vista Business was running on
-the test environment (Intel Core2Duo 6600 (2.40GHz) processor, Intel G965
-chipset, 2GB main memory, and Seagate ST3320620 HDD).
-The test codes were compiled with Microsoft Visual Studio 2005.
-
-This table shows the elapsed time for constructing the database (write time),
-the elapsed time for processing with the queries (read time), and the size of
-the database generated by each database library.
-The read/write access was extremely faster than those of other database
-libraries. The database was smaller than half the size of those generated by
-other libraries.
-This results suggest that the CQDB has the substantial advantage over the
-existing database libraries for implementing a static quark database.
-
-<table>
-<tr>
-<th>Database</th><th>Parameters</th><th>Write time [sec]</th><th>Read time [sec]</th><th>Database size [MB]</th>
-</tr>
-<tr align="right">
-<td align="left">Constant Quark Database (CQDB) 1.0</td>
-<td align="left">Default (none)</td>
-<td><b>1.48</b></td><td><b>0.65</b></td><td><b>35.2</b></td>
-</tr>
-<tr align="right">
-<td align="left">Berkeley DB (BDB) 4.5.20</td>
-<td align="left">Default</td>
-<td>91.8</td><td>37.5</td><td>79.7</td>
-</tr>
-<tr align="right">
-<td align="left">Berkeley DB (BDB) 4.5.20</td>
-<td align="left">table_size=4000000; cache_size=200MB</td>
-<td>57.8</td><td>37.5</td><td>79.7</td>
-</tr>
-<tr align="right">
-<td align="left">Quick Database Manager (QDBM) 1.8.75</td>
-<td align="left">Default</td>
-<td>95.4</td><td>80.6</td><td>76.3</td>
-</tr>
-<tr align="right">
-<td align="left">Quick Database Manager (QDBM) 1.8.75</td>
-<td align="left">table_size=4000000</td>
-<td>15.7</td><td>12.0</td><td>92.2</td>
-</tr>
-</table>
-
-@section reference Reference
-- <a href="http://cr.yp.to/cdb.html">cdb</a> by Daniel J. Bernstein.
-- <a href="http://www.corpit.ru/mjt/tinycdb.html">TinyCDB</a> by Michael Tokarev.
-- <a href="http://www.unixuser.org/~euske/doc/cdbinternals/index.html">Constant Database (cdb) Internals</a> by Yusuke Shinyama.
-- <a href="http://www.burtleburtle.net/bob/hash/index.html">Hash Functions and Block Ciphers</a> by Bob Jenkins.
-
-*/
-
-#endif /*__CQDB_H__*/
+/*
+ *      Constant Quark Database (CQDB).
+ *
+ * Copyright (c) 2007, Naoaki Okazaki
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the Northwestern University, University of Tokyo,
+ *       nor the names of its contributors may be used to endorse or promote
+ *       products derived from this software without specific prior written
+ *       permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+ * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/* $Id$ */
+
+#ifndef __CQDB_H__
+#define __CQDB_H__
+
+/** @file */
+
+/**
+ * \addtogroup cqdb_const CQDB Constants
+ * @{
+ *
+ *    The CQDB Constants.
+ */
+
+/**
+ * CQDB flags.
+ */
+enum
+{
+    CQDB_NONE = 0,                    /**< No flag. */
+    CQDB_ONEWAY = 0x00000001,         /**< A reverse lookup array is omitted. */
+    CQDB_ERROR_OCCURRED = 0x00010000, /**< An error has occurred. */
+};
+
+/**
+ * CQDB status codes.
+ */
+enum
+{
+    CQDB_SUCCESS = 0,       /**< Success. */
+    CQDB_ERROR = -1024,     /**< Unspecified error. */
+    CQDB_ERROR_NOTFOUND,    /**< String not found. */
+    CQDB_ERROR_OUTOFMEMORY, /**< Insufficient memory. */
+    CQDB_ERROR_FILEWRITE,   /**< Error in fwrite() operations. */
+    CQDB_ERROR_FILETELL,    /**< Error in ftell() operations. */
+    CQDB_ERROR_FILESEEK,    /**< Error in fseek() operations. */
+    CQDB_ERROR_INVALIDID,   /**< Invalid parameters. */
+};
+
+/** @} */
+
+/**
+ * \addtogroup cqdb_writer CQDB Writer API
+ * @{
+ *
+ *    The CQDB Writer API constructs a CQDB chunk on a seekable stream. The
+ *    seekable stream must be created by the fopen() function with writable and
+ *    binary flags ("wb"). The CQDB Writer API can build a CQDB chunk at any
+ *    position on the stream; one can thus write some data, append a CQDB chunk,
+ *    and continue writing other data on the stream.
+ *
+ *    By default, the function cqdb_writer() constructs a database with forward
+ *    (string to integer identifier) and backward (integer identifier to string)
+ *    lookups. The data for reverse lookup is omitted with ::CQDB_ONEWAY flag
+ *    specified.
+ *
+ *    It is recommended to keep the maximum number of identifiers as smallest as
+ *    possible because reverse lookup is maintained by a array with the size of
+ *    sizeof(int) * (maximum number of identifiers + 1). For example, putting a
+ *    set of integer identifers (0, 1, 1000) creates a reverse lookup array with
+ *    1001 elements only to waste the disk space for 998 (= 1001-3) elements in
+ *    the array.
+ */
+
+struct tag_cqdb_writer;
+typedef struct tag_cqdb_writer cqdb_writer_t; /**< Typedef of a CQDB writer. */
+
+/**
+ * Create a new CQDB writer on a seekable stream.
+ *
+ *    This function initializes a database on the seekable stream and returns
+ *    the pointer to a ::cqdb_writer_t instance to write the database.
+ *    The stream must have the writable and binary flags. The database creation
+ *    flag must be zero except when the reverse lookup array is unnecessary;
+ *    specifying ::CQDB_ONEWAY flag will save the storage space for the reverse
+ *    lookup array. Once calling this function, one should avoid accessing the
+ *    seekable stream directly until calling cqdb_writer_close().
+ *
+ *    @param    fp                The pointer to the writable and seekable stream.
+ *    @param    flag            Database creation flag.
+ *    @retval    cqdb_writer_t*    The pointer to the new ::cqdb_writer_t instance if
+ *                            successful; otherwise \c NULL.
+ */
+cqdb_writer_t *cqdb_writer(FILE *fp, int flag);
+
+/**
+ * Put a string/identifier association to the database.
+ *
+ *    This function append a string/identifier association into the database.
+ *    Make sure that the string and/or identifier have never been inserted to
+ *    the database and that the identifier is a non-negative value.
+ *
+ *    @param    dbw            The pointer to the ::cqdb_writer_t instance.
+ *    @param    str            The pointer to the string.
+ *    @param    id            The identifier.
+ *    @retval    int            Zero if successful, or a status code otherwise.
+ */
+int cqdb_writer_put(cqdb_writer_t *dbw, const char *str, int id);
+
+/**
+ * Close a CQDB writer.
+ *
+ *    This function finalizes the database on the stream. If successful, the
+ *    data remaining on the memory is flushed to the stream; the stream position
+ *    is moved to the end of the chunk. If an unexpected error occurs, this
+ *    function tries to rewind the stream position to the original position when
+ *    the function cqdb_writer() was called.
+ *
+ *    @param    dbw            The pointer to the ::cqdb_writer_t instance.
+ *    @retval    int            Zero if successful, or a status code otherwise.
+ */
+int cqdb_writer_close(cqdb_writer_t *dbw);
+
+/** @} */
+
+/**
+ * \addtogroup cqdb_reader CQDB Reader API
+ * @{
+ *
+ *    The CQDB reader API provides a read access to the database whose memory
+ *    image is loaded on a memory block. The memory-passing interface has
+ *    several advantages. Firstly, one can choose an efficient way for their
+ *    application to load a database image to a memory block, e.g., to read
+ *    the whole image from a file, to use the Memory Mapped File (mmap) API,
+ *    etc.
+ *    Secondaly, one can design the file format freely only if the memory
+ *    block for a database is extracted from the file.
+ *
+ *    The most fundamental operation on the CQDB reader API is forward lookup
+ *    through the use of cqdb_to_id() function, which retrieves integer
+ *    identifiers from strings. Reverse lookup (retrieving strings from integer
+ *    identifiers) with cqdb_to_string() function is not supported if the
+ *    database has been created with ::CQDB_ONEWAY flag.
+ */
+
+struct tag_cqdb;
+typedef struct tag_cqdb cqdb_t; /**< Typedef of a CQDB reader. */
+
+/**
+ * Open a new CQDB reader on a memory block.
+ *
+ *    This function initializes a database on a memory block and returns the
+ *    pointer to a ::cqdb_t instance to access the database.
+ *
+ *    @param    buffer        The pointer to the memory block.
+ *    @param    size        The size of the memory block.
+ *    @retval    cqdb_t*        The pointer to the ::cqdb_t instance.
+ */
+cqdb_t *cqdb_reader(const void *buffer, size_t size);
+
+/**
+ * Delete the CQDB reader.
+ *
+ *    This function frees the work area allocated by cqdb_reader() function.
+ *
+ *    @param    db            The pointer to the ::cqdb_t instance.
+ */
+void cqdb_delete(cqdb_t *db);
+
+/**
+ * Retrieve the identifier associated with a string.
+ *
+ *    This function returns the identifier associated with a string.
+ *
+ *    @param    db            The pointer to the ::cqdb_t instance.
+ *    @param    str            The pointer to a string.
+ *    @retval    int            The non-negative identifier if successful, negative
+ *                        status code otherwise.
+ */
+int cqdb_to_id(cqdb_t *db, const char *str);
+
+/**
+ * Retrieve the string associated with an identifier.
+ *
+ *    This function returns the string associated with an identifier.
+ *
+ *    @param    db            The pointer to the cqdb_t instance.
+ *    @param    id            The id.
+ *    @retval    const char*    The pointer to the string associated with the
+ *                        identifier if successful; otherwise \c NULL.
+ */
+const char *cqdb_to_string(cqdb_t *db, int id);
+
+/**
+ * Get the number of associations in the database.
+ *
+ *    This function returns the number of associations in the database.
+ *
+ *    @param    db            The pointer to the ::cqdb_t instance.
+ *    @retval    int            The number of string/identifier associations.
+ */
+int cqdb_num(cqdb_t *db);
+
+/** @} */
+
+/**
+@mainpage Constant Quark Database (CQDB)
+
+@section intro Introduction
+
+It is a common technique for speed and memory optimizations that an
+application converts all string values into integer identifiers, does some
+processing with integer values, and then restores the original string values
+(if necessary). The data structure for two-way associations between strings
+and integer identifiers is known as Quark:
+- GQuark in GLib: http://www.gtk.org/
+- quark (C++): http://www.chokkan.org/software/sample/quark.h
+
+Constant Quark Database (CQDB) is a database library specialized for
+serialization and retrieval of <i>static</i> associations between strings and
+integer identifiers. The database provides several features:
+- <b>Fast look-ups.</b> Retrieving an integer identifier for a string is
+  usually done by accessing three memory blocks. Retrieving a string for an
+  integer identifier is always done by accessing two memory blocks.
+  See the @ref performance "performance" evaluation.
+- <b>Low overhead.</b> A CQDB database consists of a chunk header (24 bytes),
+  hash tables (2048 bytes and 16 bytes per record), a reverse lookup array
+  (4 bytes per integer identifier), and records (8 bytes + string size per
+  record).
+  See the @ref performance "performance" evaluation.
+- <b>Sophisticated hash function.</b> CQDB incorporates the fast and
+  collision-resistant hash function for strings
+  (<a href="http://www.burtleburtle.net/bob/c/lookup3.c">lookup3.c</a>)
+  implemented by Bob Jenkins.
+- <b>Chunk format.</b> The structure of CQDB is designed to store the data in
+  a chunk of a file; CQDB can be embedded into a file with other arbitrary
+  data.
+- <b>Omissible reverse look-up array.</b> The reverse look-up array can be
+  omitted if it is not necessary to retrieve strings from integer identifiers.
+- <b>Cross platform.</b> The source code can be compiled on Microsoft Visual
+  Studio 2005, GNU C Compiler (gcc), etc.
+- <b>Simple API.</b> The CQDB API exposes only a few functions.
+
+CQDB is suitable for implementing dictionaries in which fast look-ups of
+strings and identifiers are essential while a dictionary update rarely occurs.
+The data structure is a specialization (and extension) of the
+<a href="http://cr.yp.to/cdb.html">Constant Database</a> proposed by
+Daniel J. Bernstein.
+
+CQDB does not support assigning a unique integer identifier for a given string,
+modify associations, nor check collisions in strings and identifiers; thus,
+it may be necessary to use an existing Quark implementation to manage proper
+associations between strings and identifiers on memory.
+
+This library is used by the
+<a href="http://www.chokkan.org/software/crfsuite/">CRFsuite</a> project.
+
+@section download Download
+
+- <a href="http://www.chokkan.org/software/dist/cqdb-1.1.tar.gz">Source code</a>
+
+CQDB is distributed under the term of the
+<a href="http://www.opensource.org/licenses/bsd-license.php">modified BSD license</a>.
+
+@section changelog History
+- Version 1.1 (2007-12-01):
+    - Fixed a bug when a CQDB chunk is embedded to a file.
+
+- Version 1.0 (2007-09-20):
+    - Initial release.
+
+@section api Documentation
+
+- @ref cqdb_const "CQDB Constants"
+- @ref cqdb_reader "CQDB Reader API"
+- @ref cqdb_writer "CQDB Writer API"
+
+@section sample Sample programs
+@subsection sample_writer A writer sample
+
+This sample code constructs a database "test.cqdb" with 1,000,000
+string/identifier associations,
+"00000000"/0, "00000001"/1, ..., "01000000"/1000000.
+
+@code
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include "cqdb.h"
+
+#define    DBNAME        "test.cqdb"
+#define    NUMELEMS    1000000
+
+int main(int argc, char *argv[])
+{
+    int i, ret;
+    char str[10];
+    FILE *fp = NULL;
+    cqdb_writer_t* dbw = NULL;
+
+    // Open a file for writing.
+    fp = fopen(DBNAME, "wb");
+    if (fp == NULL) {
+        fprintf(stderr, "ERROR: failed to open the file.\n");
+        return 1;
+    }
+
+    // Create a CQDB on the file stream.
+    dbw = cqdb_writer(fp, 0);
+    if (dbw == NULL) {
+        fprintf(stderr, "ERROR: failed to create a CQDB on the file.\n");
+        goto error_exit;
+    }
+
+    // Put string/integer associations, "00000001"/1, ..., "01000000"/1000000.
+    for (i = 0;i < NUMELEMS;++i) {
+        sprintf(str, "%08d", i);
+        if (ret = cqdb_writer_put(dbw, str, i)) {
+            fprintf(stderr, "ERROR: failed to put a pair '%s'/%d.\n", str, i);
+            goto error_exit;
+        }
+    }
+
+    // Close the CQDB.
+    if (ret = cqdb_writer_close(dbw)) {
+        fprintf(stderr, "ERROR: failed to close the CQDB.\n");
+        goto error_exit;
+    }
+
+    // Close the file.
+    fclose(fp);
+    return 0;
+
+error_exit:
+    if (dbw != NULL) cqdb_writer_close(dbw);
+    if (fp != NULL) fclose(fp);
+    return 1;
+}
+
+@endcode
+
+@subsection sample_reader A reader sample
+
+This sample code issues string queries "00000000", ..., "01000000" to retrive
+integer identifiers (forward lookups) and integer queries 0, ..., 1000000 to
+retrieve the strings  "00000000", ..., "01000000".
+
+@code
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include "cqdb.h"
+
+#define    DBNAME        "test.cqdb"
+#define    NUMELEMS    1000000
+
+int main(int argc, char *argv[])
+{
+    int i, j, ret;
+    long size = 0;
+    char str[10], *value = NULL, *buffer = NULL;
+    FILE *fp = NULL;
+    cqdb_t* db = NULL;
+
+    // Open the database.
+    fp = fopen(DBNAME, "rb");
+    if (fp == NULL) {
+        fprintf(stderr, "ERROR: failed to open the file\n");
+        return 1;
+    }
+
+    // Obtain the file size.
+    fseek(fp, 0, SEEK_END);
+    size = ftell(fp);
+    fseek(fp, 0, SEEK_SET);
+
+    // Read the content of the file at a time.
+    buffer = (char *)malloc(size);
+    if (buffer == NULL) {
+        fprintf(stderr, "ERROR: out of memory.\n");
+        goto error_exit;
+    }
+    fread(buffer, 1, size, fp);
+    fclose(fp);
+    fp = NULL;
+
+    // Open the database on the memory.
+    db = cqdb_reader(buffer, size);
+    if (db == NULL) {
+        fprintf(stderr, "ERROR: failed to open a CQDB on the file.\n");
+        goto error_exit;
+    }
+
+    // Forward lookups: strings to integer identifiers.
+    for (i = 0;i < NUMELEMS;++i) {
+        sprintf(str, "%08d", i);
+        j = cqdb_to_id(db, str);
+        // Validity check.
+        if (j < 0 || i != j) {
+            fprintf(stderr, "ERROR: inconsistency error '%s'/%d.\n", str, i);
+            goto error_exit;
+        }
+    }
+
+    // Reverse lookups: integer identifiers to strings.
+    for (i = 0;i < NUMELEMS;++i) {
+        sprintf(str, "%08d", i);
+        value = cqdb_to_string(db, i);
+        // Validity check.
+        if (value == NULL || strcmp(str, value) != 0) {
+            fprintf(stderr, "ERROR: inconsistency error '%s'/%d.\n", str, i);
+            goto error_exit;
+        }
+    }
+
+    // Delete the instance of the CQDB.
+    cqdb_delete(db);
+    free(buffer);
+
+    return 0;
+
+error_exit:
+    if (fp != NULL) fclose(fp);
+    if (buffer != NULL) free(buffer);
+    return 1;
+}
+
+@endcode
+
+@section performance Performance
+
+An experiment for performance comparision with
+<a href="http://www.oracle.com/database/berkeley-db/">Berkeley DB (BDB) 4.5.20</a>
+and <a href="http://qdbm.sourceforge.net/">Quick Database Manager (QDBM) 1.8.75</a>
+was conducted.
+Constructing a database with 1,000,000 string/identifier associations,
+"00000000"/0, "00000001"/1, ..., "01000000"/1000000, this experiment issued
+string queries "00000000", ..., "01000000" (forward lookups) and integer
+queries 0, ..., 1000000 (reverse lookups) to the database. Since BDB and
+QDBM do not support reverse lookups, reverse items (key: identifier,
+value: string) were inserted to the database in addition to the forward items
+(key: string, value: integer). Microsoft Windows Vista Business was running on
+the test environment (Intel Core2Duo 6600 (2.40GHz) processor, Intel G965
+chipset, 2GB main memory, and Seagate ST3320620 HDD).
+The test codes were compiled with Microsoft Visual Studio 2005.
+
+This table shows the elapsed time for constructing the database (write time),
+the elapsed time for processing with the queries (read time), and the size of
+the database generated by each database library.
+The read/write access was extremely faster than those of other database
+libraries. The database was smaller than half the size of those generated by
+other libraries.
+This results suggest that the CQDB has the substantial advantage over the
+existing database libraries for implementing a static quark database.
+
+<table>
+<tr>
+<th>Database</th><th>Parameters</th><th>Write time [sec]</th><th>Read time [sec]</th><th>Database size [MB]</th>
+</tr>
+<tr align="right">
+<td align="left">Constant Quark Database (CQDB) 1.0</td>
+<td align="left">Default (none)</td>
+<td><b>1.48</b></td><td><b>0.65</b></td><td><b>35.2</b></td>
+</tr>
+<tr align="right">
+<td align="left">Berkeley DB (BDB) 4.5.20</td>
+<td align="left">Default</td>
+<td>91.8</td><td>37.5</td><td>79.7</td>
+</tr>
+<tr align="right">
+<td align="left">Berkeley DB (BDB) 4.5.20</td>
+<td align="left">table_size=4000000; cache_size=200MB</td>
+<td>57.8</td><td>37.5</td><td>79.7</td>
+</tr>
+<tr align="right">
+<td align="left">Quick Database Manager (QDBM) 1.8.75</td>
+<td align="left">Default</td>
+<td>95.4</td><td>80.6</td><td>76.3</td>
+</tr>
+<tr align="right">
+<td align="left">Quick Database Manager (QDBM) 1.8.75</td>
+<td align="left">table_size=4000000</td>
+<td>15.7</td><td>12.0</td><td>92.2</td>
+</tr>
+</table>
+
+@section reference Reference
+- <a href="http://cr.yp.to/cdb.html">cdb</a> by Daniel J. Bernstein.
+- <a href="http://www.corpit.ru/mjt/tinycdb.html">TinyCDB</a> by Michael Tokarev.
+- <a href="http://www.unixuser.org/~euske/doc/cdbinternals/index.html">Constant Database (cdb) Internals</a> by Yusuke Shinyama.
+- <a href="http://www.burtleburtle.net/bob/hash/index.html">Hash Functions and Block Ciphers</a> by Bob Jenkins.
+
+*/
+
+#endif /*__CQDB_H__*/
```

## chaine/_core/crfsuite/lib/cqdb/src/cqdb.c

 * *Ordering differences only*

```diff
@@ -1,639 +1,639 @@
-/*
- *      Constant Quark Database (CQDB).
- *
- * Copyright (c) 2007, Naoaki Okazaki
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of the Northwestern University, University of Tokyo,
- *       nor the names of its contributors may be used to endorse or promote
- *       products derived from this software without specific prior written
- *       permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
- * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-/* $Id$ */
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <stdint.h>
-#include <string.h>
-
-#include <cqdb.h>
-
-#define CHUNKID "CQDB"
-#define BYTEORDER_CHECK (0x62445371)
-#define NUM_TABLES (256)
-#define OFFSET_REFS (0 + sizeof(header_t))
-#define OFFSET_DATA (OFFSET_REFS + sizeof(tableref_t) * NUM_TABLES)
-
-/**
- * An element of a hash table.
- */
-typedef struct
-{
-    uint32_t hash;   /**< Hash value of the record. */
-    uint32_t offset; /**< Offset address to the actual record. */
-} bucket_t;
-
-/**
- * A hash table.
- */
-typedef struct
-{
-    uint32_t num;     /**< Number of elements in the table. */
-    uint32_t size;    /**< Maximum number of elements. */
-    bucket_t *bucket; /**< Bucket (array of bucket_t). */
-} table_t;
-
-/**
- * CQDB chunk header.
- */
-typedef struct
-{
-    int8_t chunkid[4];   /**< Chunk identifier, "CQDB". */
-    uint32_t size;       /**< Chunk size including this header. */
-    uint32_t flag;       /**< Global flags. */
-    uint32_t byteorder;  /**< Byte-order indicator. */
-    uint32_t bwd_size;   /**< Number of elements in the backward array. */
-    uint32_t bwd_offset; /**< Offset to the backward array. */
-} header_t;
-
-/**
- * Reference to a hash table.
- */
-typedef struct
-{
-    uint32_t offset; /**< Offset to a hash table. */
-    uint32_t num;    /**< Number of elements in the hash table. */
-} tableref_t;
-
-/**
- * Writer for a constant quark database.
- */
-struct tag_cqdb_writer
-{
-    uint32_t flag;          /**< Operation flag. */
-    FILE *fp;               /**< File pointer. */
-    uint32_t begin;         /**< Offset address to the head of this database. */
-    uint32_t cur;           /**< Offset address to a new key/data pair. */
-    table_t ht[NUM_TABLES]; /**< Hash tables (string -> id). */
-
-    uint32_t *bwd;     /**< Backlink array. */
-    uint32_t bwd_num;  /**< */
-    uint32_t bwd_size; /**< Number of elements in the backlink array. */
-};
-
-/**
- * Constant quark database (CQDB).
- */
-struct tag_cqdb
-{
-    const uint8_t *buffer; /**< Pointer to the memory block. */
-    size_t size;           /**< Size of the memory block. */
-
-    header_t header;        /**< Chunk header. */
-    table_t ht[NUM_TABLES]; /**< Hash tables (string -> id). */
-
-    uint32_t *bwd; /**< Array for backward look-up (id -> string). */
-
-    int num; /**< Number of key/data pairs. */
-};
-
-uint32_t hashlittle(const void *key, size_t length, uint32_t initval);
-
-static size_t write_uint32(cqdb_writer_t *wt, uint32_t value)
-{
-    uint8_t buffer[4];
-    buffer[0] = (uint8_t)(value & 0xFF);
-    buffer[1] = (uint8_t)(value >> 8);
-    buffer[2] = (uint8_t)(value >> 16);
-    buffer[3] = (uint8_t)(value >> 24);
-    return fwrite(buffer, sizeof(uint8_t), 4, wt->fp) / sizeof(value);
-}
-
-static size_t write_data(cqdb_writer_t *wt, const void *data, size_t size)
-{
-    return fwrite(data, size, 1, wt->fp);
-}
-
-cqdb_writer_t *cqdb_writer(FILE *fp, int flag)
-{
-    int i;
-    cqdb_writer_t *dbw = (cqdb_writer_t *)calloc(1, sizeof(cqdb_writer_t));
-
-    if (dbw != NULL)
-    {
-        /* Initialize cqdb_writer_t members. */
-        memset(dbw, 0, sizeof(*dbw));
-        dbw->flag = flag;
-        dbw->fp = fp;
-        dbw->begin = ftell(dbw->fp);
-        dbw->cur = OFFSET_DATA;
-
-        /* Initialize the hash tables.*/
-        for (i = 0; i < NUM_TABLES; ++i)
-        {
-            dbw->ht[i].bucket = NULL;
-        }
-
-        dbw->bwd = NULL;
-        dbw->bwd_num = 0;
-        dbw->bwd_size = 0;
-
-        /* Move the file pointer to the offset to the first key/data pair. */
-        if (fseek(dbw->fp, dbw->begin + dbw->cur, SEEK_SET) != 0)
-        {
-            goto error_exit; /* Seek error. */
-        }
-    }
-
-    return dbw;
-
-error_exit:
-    free(dbw);
-    return NULL;
-}
-
-static int cqdb_writer_delete(cqdb_writer_t *dbw)
-{
-    int i;
-
-    /* Free allocated memory blocks. */
-    for (i = 0; i < NUM_TABLES; ++i)
-    {
-        free(dbw->ht[i].bucket);
-    }
-    free(dbw->bwd);
-    free(dbw);
-    return 0;
-}
-
-int cqdb_writer_put(cqdb_writer_t *dbw, const char *str, int id)
-{
-    int ret = 0;
-    const void *key = str;
-    uint32_t ksize = (uint32_t)(strlen(str) + 1);
-
-    /* Compute the hash value and choose a hash table. */
-    uint32_t hv = hashlittle(key, ksize, 0);
-    table_t *ht = &dbw->ht[hv % 256];
-
-    /* Check for non-negative identifier. */
-    if (id < 0)
-    {
-        ret = CQDB_ERROR_INVALIDID;
-        goto error_exit;
-    }
-
-    /* Write out the current data. */
-    write_uint32(dbw, (uint32_t)id);
-    write_uint32(dbw, (uint32_t)ksize);
-    write_data(dbw, key, ksize);
-    if (ferror(dbw->fp))
-    {
-        ret = CQDB_ERROR_FILEWRITE;
-        goto error_exit;
-    }
-
-    /* Expand the bucket if necessary. */
-    if (ht->size <= ht->num)
-    {
-        ht->size = (ht->size + 1) * 2;
-        ht->bucket = (bucket_t *)realloc(ht->bucket, sizeof(bucket_t) * ht->size);
-        if (ht->bucket == NULL)
-        {
-            ret = CQDB_ERROR_OUTOFMEMORY;
-            goto error_exit;
-        }
-    }
-
-    /* Set the hash value and current offset position. */
-    ht->bucket[ht->num].hash = hv;
-    ht->bucket[ht->num].offset = dbw->cur;
-    ++ht->num;
-
-    /* Store the backlink if specified. */
-    if (!(dbw->flag & CQDB_ONEWAY))
-    {
-        /* Expand the backlink array if necessary. */
-        if (dbw->bwd_size <= (uint32_t)id)
-        {
-            uint32_t size = dbw->bwd_size;
-
-            while (size <= (uint32_t)id)
-                size = (size + 1) * 2;
-            dbw->bwd = (uint32_t *)realloc(dbw->bwd, sizeof(uint32_t) * size);
-            if (dbw->bwd == NULL)
-            {
-                ret = CQDB_ERROR_OUTOFMEMORY;
-                goto error_exit;
-            }
-            while (dbw->bwd_size < size)
-            {
-                dbw->bwd[dbw->bwd_size++] = 0;
-            }
-        }
-
-        if (dbw->bwd_num <= (uint32_t)id)
-        {
-            dbw->bwd_num = (uint32_t)id + 1;
-        }
-
-        dbw->bwd[id] = dbw->cur;
-    }
-
-    /* Increment the current position. */
-    dbw->cur += sizeof(uint32_t) + sizeof(uint32_t) + ksize;
-    return 0;
-
-error_exit:
-    dbw->flag |= CQDB_ERROR_OCCURRED;
-    return ret;
-}
-
-int cqdb_writer_close(cqdb_writer_t *dbw)
-{
-    uint32_t i, j;
-    int k, ret = 0;
-    long offset = 0;
-    header_t header;
-
-    /* If an error have occurred, just free the memory blocks. */
-    if (dbw->flag & CQDB_ERROR_OCCURRED)
-    {
-        cqdb_writer_delete(dbw);
-        return 0;
-    }
-
-    /* Initialize the file header. */
-    strncpy((char *)header.chunkid, CHUNKID, 4);
-    header.flag = 0;
-    header.byteorder = BYTEORDER_CHECK;
-    header.bwd_offset = 0;
-    header.bwd_size = dbw->bwd_num;
-
-    /*
-        Store the hash tables. At this moment, the file pointer refers to
-        the offset succeeding the last key/data pair.
-     */
-    for (i = 0; i < NUM_TABLES; ++i)
-    {
-        table_t *ht = &dbw->ht[i];
-
-        /* Do not write empty hash tables. */
-        if (ht->bucket != NULL)
-        {
-            /*
-                Actual bucket will have the double size; half elements
-                in the bucket are kept empty.
-             */
-            int n = ht->num * 2;
-
-            /* Allocate the bucket. */
-            bucket_t *dst = (bucket_t *)calloc(n, sizeof(bucket_t));
-            if (dst == NULL)
-            {
-                ret = CQDB_ERROR_OUTOFMEMORY;
-                goto error_exit;
-            }
-
-            /*
-                Put hash elements to the bucket with the open-address method.
-             */
-            for (j = 0; j < ht->num; ++j)
-            {
-                const bucket_t *src = &ht->bucket[j];
-                int k = (src->hash >> 8) % n;
-
-                /* Find a vacant element. */
-                while (dst[k].offset != 0)
-                {
-                    k = (k + 1) % n;
-                }
-
-                /* Store the hash element. */
-                dst[k].hash = src->hash;
-                dst[k].offset = src->offset;
-            }
-
-            /* Write the bucket. */
-            for (k = 0; k < n; ++k)
-            {
-                write_uint32(dbw, dst[k].hash);
-                write_uint32(dbw, dst[k].offset);
-            }
-
-            /* Free the bucket. */
-            free(dst);
-        }
-    }
-
-    /* Write the backlink array if specified. */
-    if (!(dbw->flag & CQDB_ONEWAY) && 0 < dbw->bwd_size)
-    {
-        /* Store the offset to the head of this array. */
-        header.bwd_offset = ftell(dbw->fp) - dbw->begin;
-        /* Store the contents of the backlink array. */
-        for (i = 0; i < dbw->bwd_num; ++i)
-        {
-            write_uint32(dbw, dbw->bwd[i]);
-        }
-    }
-
-    /* Check for an occurrence of a file-related error. */
-    if (ferror(dbw->fp))
-    {
-        ret = CQDB_ERROR_FILEWRITE;
-        goto error_exit;
-    }
-
-    /* Store the current position. */
-    offset = ftell(dbw->fp);
-    if (offset == -1)
-    {
-        ret = CQDB_ERROR_FILETELL;
-        goto error_exit;
-    }
-    header.size = (uint32_t)offset - dbw->begin;
-
-    /* Rewind the current position to the beginning. */
-    if (fseek(dbw->fp, dbw->begin, SEEK_SET) != 0)
-    {
-        ret = CQDB_ERROR_FILESEEK;
-        goto error_exit;
-    }
-
-    /* Write the file header. */
-    write_data(dbw, header.chunkid, 4);
-    write_uint32(dbw, header.size);
-    write_uint32(dbw, header.flag);
-    write_uint32(dbw, header.byteorder);
-    write_uint32(dbw, header.bwd_size);
-    write_uint32(dbw, header.bwd_offset);
-
-    /*
-        Write references to hash tables. At this moment, dbw->cur points
-        to the offset succeeding the last key/data pair.
-     */
-    for (i = 0; i < NUM_TABLES; ++i)
-    {
-        /* Offset to the hash table (or zero for non-existent tables). */
-        write_uint32(dbw, dbw->ht[i].num ? dbw->cur : 0);
-        /* Bucket size is double to the number of elements. */
-        write_uint32(dbw, dbw->ht[i].num * 2);
-        /* Advance the offset counter. */
-        dbw->cur += (dbw->ht[i].num * 2) * sizeof(bucket_t);
-    }
-
-    /* Check an occurrence of a file-related error. */
-    if (ferror(dbw->fp))
-    {
-        ret = CQDB_ERROR_FILEWRITE;
-        goto error_exit;
-    }
-
-    /* Seek to the last position. */
-    if (fseek(dbw->fp, offset, SEEK_SET) != 0)
-    {
-        ret = CQDB_ERROR_FILESEEK;
-        goto error_exit;
-    }
-
-    cqdb_writer_delete(dbw);
-    return ret;
-
-error_exit:
-    /* Seek to the first position. */
-    fseek(dbw->fp, dbw->begin, SEEK_SET);
-    cqdb_writer_delete(dbw);
-    return ret;
-}
-
-static uint32_t read_uint32(const uint8_t *p)
-{
-    uint32_t value;
-    value = ((uint32_t)p[0]);
-    value |= ((uint32_t)p[1] << 8);
-    value |= ((uint32_t)p[2] << 16);
-    value |= ((uint32_t)p[3] << 24);
-    return value;
-}
-
-static const uint8_t *read_tableref(tableref_t *ref, const uint8_t *p)
-{
-    ref->offset = read_uint32(p);
-    p += sizeof(uint32_t);
-    ref->num = read_uint32(p);
-    p += sizeof(uint32_t);
-    return p;
-}
-
-static bucket_t *read_bucket(const uint8_t *p, uint32_t num)
-{
-    uint32_t i;
-    bucket_t *bucket = (bucket_t *)calloc(num, sizeof(bucket_t));
-    for (i = 0; i < num; ++i)
-    {
-        bucket[i].hash = read_uint32(p);
-        p += sizeof(uint32_t);
-        bucket[i].offset = read_uint32(p);
-        p += sizeof(uint32_t);
-    }
-    return bucket;
-}
-
-static uint32_t *read_backward_links(const uint8_t *p, uint32_t num)
-{
-    uint32_t i;
-    uint32_t *bwd = (uint32_t *)calloc(num, sizeof(uint32_t));
-    for (i = 0; i < num; ++i)
-    {
-        bwd[i] = read_uint32(p);
-        p += sizeof(uint32_t);
-    }
-    return bwd;
-}
-
-cqdb_t *cqdb_reader(const void *buffer, size_t size)
-{
-    int i;
-    cqdb_t *db = NULL;
-
-    /* The minimum size of a valid CQDB is OFFSET_DATA. */
-    if (size < OFFSET_DATA)
-    {
-        return NULL;
-    }
-
-    /* Check the file chunkid. */
-    if (memcmp(buffer, CHUNKID, 4) != 0)
-    {
-        return NULL;
-    }
-
-    db = (cqdb_t *)calloc(1, sizeof(cqdb_t));
-    if (db != NULL)
-    {
-        const uint8_t *p = NULL;
-
-        /* Set memory block and size. */
-        db->buffer = buffer;
-        db->size = size;
-
-        /* Read the database header. */
-        p = db->buffer;
-        strncpy((char *)db->header.chunkid, (const char *)p, 4);
-        p += sizeof(uint32_t);
-        db->header.size = read_uint32(p);
-        p += sizeof(uint32_t);
-        db->header.flag = read_uint32(p);
-        p += sizeof(uint32_t);
-        db->header.byteorder = read_uint32(p);
-        p += sizeof(uint32_t);
-        db->header.bwd_size = read_uint32(p);
-        p += sizeof(uint32_t);
-        db->header.bwd_offset = read_uint32(p);
-        p += sizeof(uint32_t);
-
-        /* Check the consistency of byte order. */
-        if (db->header.byteorder != BYTEORDER_CHECK)
-        {
-            free(db);
-            return NULL;
-        }
-
-        /* Check the chunk size. */
-        if (size < db->header.size)
-        {
-            free(db);
-            return NULL;
-        }
-
-        /* Set pointers to the hash tables. */
-        db->num = 0; /* Number of records. */
-        p = (db->buffer + OFFSET_REFS);
-        for (i = 0; i < NUM_TABLES; ++i)
-        {
-            tableref_t ref;
-            p = read_tableref(&ref, p);
-            if (ref.offset)
-            {
-                /* Set buckets. */
-                db->ht[i].bucket = read_bucket(db->buffer + ref.offset, ref.num);
-                db->ht[i].num = ref.num;
-            }
-            else
-            {
-                /* An empty hash table. */
-                db->ht[i].bucket = NULL;
-                db->ht[i].num = 0;
-            }
-
-            /* The number of records is the half of the table size.*/
-            db->num += ref.num / 2;
-        }
-
-        /* Set the pointer to the backlink array if any. */
-        if (db->header.bwd_offset)
-        {
-            db->bwd = read_backward_links(db->buffer + db->header.bwd_offset, db->num);
-        }
-        else
-        {
-            db->bwd = NULL;
-        }
-    }
-
-    return db;
-}
-
-void cqdb_delete(cqdb_t *db)
-{
-    int i;
-
-    if (db != NULL)
-    {
-        for (i = 0; i < NUM_TABLES; ++i)
-        {
-            free(db->ht[i].bucket);
-        }
-        free(db->bwd);
-        free(db);
-    }
-}
-
-int cqdb_to_id(cqdb_t *db, const char *str)
-{
-    uint32_t hv = hashlittle(str, strlen(str) + 1, 0);
-    int t = hv % 256;
-    table_t *ht = &db->ht[t];
-
-    if (ht->num && ht->bucket != NULL)
-    {
-        int n = ht->num;
-        int k = (hv >> 8) % n;
-        bucket_t *p = NULL;
-
-        while (p = &ht->bucket[k], p->offset)
-        {
-            if (p->hash == hv)
-            {
-                int value;
-                uint32_t ksize;
-                const uint8_t *q = db->buffer + p->offset;
-                value = (int)read_uint32(q);
-                q += sizeof(uint32_t);
-                ksize = read_uint32(q);
-                q += sizeof(uint32_t);
-                if (strcmp(str, (const char *)q) == 0)
-                {
-                    return value;
-                }
-            }
-            k = (k + 1) % n;
-        }
-    }
-
-    return CQDB_ERROR_NOTFOUND;
-}
-
-const char *cqdb_to_string(cqdb_t *db, int id)
-{
-    /* Check if the current database supports the backward look-up. */
-    if (db->bwd != NULL && (uint32_t)id < db->header.bwd_size)
-    {
-        uint32_t offset = db->bwd[id];
-        if (offset)
-        {
-            const uint8_t *p = db->buffer + offset;
-            p += sizeof(uint32_t); /* Skip key data. */
-            p += sizeof(uint32_t); /* Skip value size. */
-            return (const char *)p;
-        }
-    }
-
-    return NULL;
-}
-
-int cqdb_num(cqdb_t *db)
-{
-    return db->num;
-}
+/*
+ *      Constant Quark Database (CQDB).
+ *
+ * Copyright (c) 2007, Naoaki Okazaki
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the Northwestern University, University of Tokyo,
+ *       nor the names of its contributors may be used to endorse or promote
+ *       products derived from this software without specific prior written
+ *       permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+ * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/* $Id$ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <string.h>
+
+#include <cqdb.h>
+
+#define CHUNKID "CQDB"
+#define BYTEORDER_CHECK (0x62445371)
+#define NUM_TABLES (256)
+#define OFFSET_REFS (0 + sizeof(header_t))
+#define OFFSET_DATA (OFFSET_REFS + sizeof(tableref_t) * NUM_TABLES)
+
+/**
+ * An element of a hash table.
+ */
+typedef struct
+{
+    uint32_t hash;   /**< Hash value of the record. */
+    uint32_t offset; /**< Offset address to the actual record. */
+} bucket_t;
+
+/**
+ * A hash table.
+ */
+typedef struct
+{
+    uint32_t num;     /**< Number of elements in the table. */
+    uint32_t size;    /**< Maximum number of elements. */
+    bucket_t *bucket; /**< Bucket (array of bucket_t). */
+} table_t;
+
+/**
+ * CQDB chunk header.
+ */
+typedef struct
+{
+    int8_t chunkid[4];   /**< Chunk identifier, "CQDB". */
+    uint32_t size;       /**< Chunk size including this header. */
+    uint32_t flag;       /**< Global flags. */
+    uint32_t byteorder;  /**< Byte-order indicator. */
+    uint32_t bwd_size;   /**< Number of elements in the backward array. */
+    uint32_t bwd_offset; /**< Offset to the backward array. */
+} header_t;
+
+/**
+ * Reference to a hash table.
+ */
+typedef struct
+{
+    uint32_t offset; /**< Offset to a hash table. */
+    uint32_t num;    /**< Number of elements in the hash table. */
+} tableref_t;
+
+/**
+ * Writer for a constant quark database.
+ */
+struct tag_cqdb_writer
+{
+    uint32_t flag;          /**< Operation flag. */
+    FILE *fp;               /**< File pointer. */
+    uint32_t begin;         /**< Offset address to the head of this database. */
+    uint32_t cur;           /**< Offset address to a new key/data pair. */
+    table_t ht[NUM_TABLES]; /**< Hash tables (string -> id). */
+
+    uint32_t *bwd;     /**< Backlink array. */
+    uint32_t bwd_num;  /**< */
+    uint32_t bwd_size; /**< Number of elements in the backlink array. */
+};
+
+/**
+ * Constant quark database (CQDB).
+ */
+struct tag_cqdb
+{
+    const uint8_t *buffer; /**< Pointer to the memory block. */
+    size_t size;           /**< Size of the memory block. */
+
+    header_t header;        /**< Chunk header. */
+    table_t ht[NUM_TABLES]; /**< Hash tables (string -> id). */
+
+    uint32_t *bwd; /**< Array for backward look-up (id -> string). */
+
+    int num; /**< Number of key/data pairs. */
+};
+
+uint32_t hashlittle(const void *key, size_t length, uint32_t initval);
+
+static size_t write_uint32(cqdb_writer_t *wt, uint32_t value)
+{
+    uint8_t buffer[4];
+    buffer[0] = (uint8_t)(value & 0xFF);
+    buffer[1] = (uint8_t)(value >> 8);
+    buffer[2] = (uint8_t)(value >> 16);
+    buffer[3] = (uint8_t)(value >> 24);
+    return fwrite(buffer, sizeof(uint8_t), 4, wt->fp) / sizeof(value);
+}
+
+static size_t write_data(cqdb_writer_t *wt, const void *data, size_t size)
+{
+    return fwrite(data, size, 1, wt->fp);
+}
+
+cqdb_writer_t *cqdb_writer(FILE *fp, int flag)
+{
+    int i;
+    cqdb_writer_t *dbw = (cqdb_writer_t *)calloc(1, sizeof(cqdb_writer_t));
+
+    if (dbw != NULL)
+    {
+        /* Initialize cqdb_writer_t members. */
+        memset(dbw, 0, sizeof(*dbw));
+        dbw->flag = flag;
+        dbw->fp = fp;
+        dbw->begin = ftell(dbw->fp);
+        dbw->cur = OFFSET_DATA;
+
+        /* Initialize the hash tables.*/
+        for (i = 0; i < NUM_TABLES; ++i)
+        {
+            dbw->ht[i].bucket = NULL;
+        }
+
+        dbw->bwd = NULL;
+        dbw->bwd_num = 0;
+        dbw->bwd_size = 0;
+
+        /* Move the file pointer to the offset to the first key/data pair. */
+        if (fseek(dbw->fp, dbw->begin + dbw->cur, SEEK_SET) != 0)
+        {
+            goto error_exit; /* Seek error. */
+        }
+    }
+
+    return dbw;
+
+error_exit:
+    free(dbw);
+    return NULL;
+}
+
+static int cqdb_writer_delete(cqdb_writer_t *dbw)
+{
+    int i;
+
+    /* Free allocated memory blocks. */
+    for (i = 0; i < NUM_TABLES; ++i)
+    {
+        free(dbw->ht[i].bucket);
+    }
+    free(dbw->bwd);
+    free(dbw);
+    return 0;
+}
+
+int cqdb_writer_put(cqdb_writer_t *dbw, const char *str, int id)
+{
+    int ret = 0;
+    const void *key = str;
+    uint32_t ksize = (uint32_t)(strlen(str) + 1);
+
+    /* Compute the hash value and choose a hash table. */
+    uint32_t hv = hashlittle(key, ksize, 0);
+    table_t *ht = &dbw->ht[hv % 256];
+
+    /* Check for non-negative identifier. */
+    if (id < 0)
+    {
+        ret = CQDB_ERROR_INVALIDID;
+        goto error_exit;
+    }
+
+    /* Write out the current data. */
+    write_uint32(dbw, (uint32_t)id);
+    write_uint32(dbw, (uint32_t)ksize);
+    write_data(dbw, key, ksize);
+    if (ferror(dbw->fp))
+    {
+        ret = CQDB_ERROR_FILEWRITE;
+        goto error_exit;
+    }
+
+    /* Expand the bucket if necessary. */
+    if (ht->size <= ht->num)
+    {
+        ht->size = (ht->size + 1) * 2;
+        ht->bucket = (bucket_t *)realloc(ht->bucket, sizeof(bucket_t) * ht->size);
+        if (ht->bucket == NULL)
+        {
+            ret = CQDB_ERROR_OUTOFMEMORY;
+            goto error_exit;
+        }
+    }
+
+    /* Set the hash value and current offset position. */
+    ht->bucket[ht->num].hash = hv;
+    ht->bucket[ht->num].offset = dbw->cur;
+    ++ht->num;
+
+    /* Store the backlink if specified. */
+    if (!(dbw->flag & CQDB_ONEWAY))
+    {
+        /* Expand the backlink array if necessary. */
+        if (dbw->bwd_size <= (uint32_t)id)
+        {
+            uint32_t size = dbw->bwd_size;
+
+            while (size <= (uint32_t)id)
+                size = (size + 1) * 2;
+            dbw->bwd = (uint32_t *)realloc(dbw->bwd, sizeof(uint32_t) * size);
+            if (dbw->bwd == NULL)
+            {
+                ret = CQDB_ERROR_OUTOFMEMORY;
+                goto error_exit;
+            }
+            while (dbw->bwd_size < size)
+            {
+                dbw->bwd[dbw->bwd_size++] = 0;
+            }
+        }
+
+        if (dbw->bwd_num <= (uint32_t)id)
+        {
+            dbw->bwd_num = (uint32_t)id + 1;
+        }
+
+        dbw->bwd[id] = dbw->cur;
+    }
+
+    /* Increment the current position. */
+    dbw->cur += sizeof(uint32_t) + sizeof(uint32_t) + ksize;
+    return 0;
+
+error_exit:
+    dbw->flag |= CQDB_ERROR_OCCURRED;
+    return ret;
+}
+
+int cqdb_writer_close(cqdb_writer_t *dbw)
+{
+    uint32_t i, j;
+    int k, ret = 0;
+    long offset = 0;
+    header_t header;
+
+    /* If an error have occurred, just free the memory blocks. */
+    if (dbw->flag & CQDB_ERROR_OCCURRED)
+    {
+        cqdb_writer_delete(dbw);
+        return 0;
+    }
+
+    /* Initialize the file header. */
+    strncpy((char *)header.chunkid, CHUNKID, 4);
+    header.flag = 0;
+    header.byteorder = BYTEORDER_CHECK;
+    header.bwd_offset = 0;
+    header.bwd_size = dbw->bwd_num;
+
+    /*
+        Store the hash tables. At this moment, the file pointer refers to
+        the offset succeeding the last key/data pair.
+     */
+    for (i = 0; i < NUM_TABLES; ++i)
+    {
+        table_t *ht = &dbw->ht[i];
+
+        /* Do not write empty hash tables. */
+        if (ht->bucket != NULL)
+        {
+            /*
+                Actual bucket will have the double size; half elements
+                in the bucket are kept empty.
+             */
+            int n = ht->num * 2;
+
+            /* Allocate the bucket. */
+            bucket_t *dst = (bucket_t *)calloc(n, sizeof(bucket_t));
+            if (dst == NULL)
+            {
+                ret = CQDB_ERROR_OUTOFMEMORY;
+                goto error_exit;
+            }
+
+            /*
+                Put hash elements to the bucket with the open-address method.
+             */
+            for (j = 0; j < ht->num; ++j)
+            {
+                const bucket_t *src = &ht->bucket[j];
+                int k = (src->hash >> 8) % n;
+
+                /* Find a vacant element. */
+                while (dst[k].offset != 0)
+                {
+                    k = (k + 1) % n;
+                }
+
+                /* Store the hash element. */
+                dst[k].hash = src->hash;
+                dst[k].offset = src->offset;
+            }
+
+            /* Write the bucket. */
+            for (k = 0; k < n; ++k)
+            {
+                write_uint32(dbw, dst[k].hash);
+                write_uint32(dbw, dst[k].offset);
+            }
+
+            /* Free the bucket. */
+            free(dst);
+        }
+    }
+
+    /* Write the backlink array if specified. */
+    if (!(dbw->flag & CQDB_ONEWAY) && 0 < dbw->bwd_size)
+    {
+        /* Store the offset to the head of this array. */
+        header.bwd_offset = ftell(dbw->fp) - dbw->begin;
+        /* Store the contents of the backlink array. */
+        for (i = 0; i < dbw->bwd_num; ++i)
+        {
+            write_uint32(dbw, dbw->bwd[i]);
+        }
+    }
+
+    /* Check for an occurrence of a file-related error. */
+    if (ferror(dbw->fp))
+    {
+        ret = CQDB_ERROR_FILEWRITE;
+        goto error_exit;
+    }
+
+    /* Store the current position. */
+    offset = ftell(dbw->fp);
+    if (offset == -1)
+    {
+        ret = CQDB_ERROR_FILETELL;
+        goto error_exit;
+    }
+    header.size = (uint32_t)offset - dbw->begin;
+
+    /* Rewind the current position to the beginning. */
+    if (fseek(dbw->fp, dbw->begin, SEEK_SET) != 0)
+    {
+        ret = CQDB_ERROR_FILESEEK;
+        goto error_exit;
+    }
+
+    /* Write the file header. */
+    write_data(dbw, header.chunkid, 4);
+    write_uint32(dbw, header.size);
+    write_uint32(dbw, header.flag);
+    write_uint32(dbw, header.byteorder);
+    write_uint32(dbw, header.bwd_size);
+    write_uint32(dbw, header.bwd_offset);
+
+    /*
+        Write references to hash tables. At this moment, dbw->cur points
+        to the offset succeeding the last key/data pair.
+     */
+    for (i = 0; i < NUM_TABLES; ++i)
+    {
+        /* Offset to the hash table (or zero for non-existent tables). */
+        write_uint32(dbw, dbw->ht[i].num ? dbw->cur : 0);
+        /* Bucket size is double to the number of elements. */
+        write_uint32(dbw, dbw->ht[i].num * 2);
+        /* Advance the offset counter. */
+        dbw->cur += (dbw->ht[i].num * 2) * sizeof(bucket_t);
+    }
+
+    /* Check an occurrence of a file-related error. */
+    if (ferror(dbw->fp))
+    {
+        ret = CQDB_ERROR_FILEWRITE;
+        goto error_exit;
+    }
+
+    /* Seek to the last position. */
+    if (fseek(dbw->fp, offset, SEEK_SET) != 0)
+    {
+        ret = CQDB_ERROR_FILESEEK;
+        goto error_exit;
+    }
+
+    cqdb_writer_delete(dbw);
+    return ret;
+
+error_exit:
+    /* Seek to the first position. */
+    fseek(dbw->fp, dbw->begin, SEEK_SET);
+    cqdb_writer_delete(dbw);
+    return ret;
+}
+
+static uint32_t read_uint32(const uint8_t *p)
+{
+    uint32_t value;
+    value = ((uint32_t)p[0]);
+    value |= ((uint32_t)p[1] << 8);
+    value |= ((uint32_t)p[2] << 16);
+    value |= ((uint32_t)p[3] << 24);
+    return value;
+}
+
+static const uint8_t *read_tableref(tableref_t *ref, const uint8_t *p)
+{
+    ref->offset = read_uint32(p);
+    p += sizeof(uint32_t);
+    ref->num = read_uint32(p);
+    p += sizeof(uint32_t);
+    return p;
+}
+
+static bucket_t *read_bucket(const uint8_t *p, uint32_t num)
+{
+    uint32_t i;
+    bucket_t *bucket = (bucket_t *)calloc(num, sizeof(bucket_t));
+    for (i = 0; i < num; ++i)
+    {
+        bucket[i].hash = read_uint32(p);
+        p += sizeof(uint32_t);
+        bucket[i].offset = read_uint32(p);
+        p += sizeof(uint32_t);
+    }
+    return bucket;
+}
+
+static uint32_t *read_backward_links(const uint8_t *p, uint32_t num)
+{
+    uint32_t i;
+    uint32_t *bwd = (uint32_t *)calloc(num, sizeof(uint32_t));
+    for (i = 0; i < num; ++i)
+    {
+        bwd[i] = read_uint32(p);
+        p += sizeof(uint32_t);
+    }
+    return bwd;
+}
+
+cqdb_t *cqdb_reader(const void *buffer, size_t size)
+{
+    int i;
+    cqdb_t *db = NULL;
+
+    /* The minimum size of a valid CQDB is OFFSET_DATA. */
+    if (size < OFFSET_DATA)
+    {
+        return NULL;
+    }
+
+    /* Check the file chunkid. */
+    if (memcmp(buffer, CHUNKID, 4) != 0)
+    {
+        return NULL;
+    }
+
+    db = (cqdb_t *)calloc(1, sizeof(cqdb_t));
+    if (db != NULL)
+    {
+        const uint8_t *p = NULL;
+
+        /* Set memory block and size. */
+        db->buffer = buffer;
+        db->size = size;
+
+        /* Read the database header. */
+        p = db->buffer;
+        strncpy((char *)db->header.chunkid, (const char *)p, 4);
+        p += sizeof(uint32_t);
+        db->header.size = read_uint32(p);
+        p += sizeof(uint32_t);
+        db->header.flag = read_uint32(p);
+        p += sizeof(uint32_t);
+        db->header.byteorder = read_uint32(p);
+        p += sizeof(uint32_t);
+        db->header.bwd_size = read_uint32(p);
+        p += sizeof(uint32_t);
+        db->header.bwd_offset = read_uint32(p);
+        p += sizeof(uint32_t);
+
+        /* Check the consistency of byte order. */
+        if (db->header.byteorder != BYTEORDER_CHECK)
+        {
+            free(db);
+            return NULL;
+        }
+
+        /* Check the chunk size. */
+        if (size < db->header.size)
+        {
+            free(db);
+            return NULL;
+        }
+
+        /* Set pointers to the hash tables. */
+        db->num = 0; /* Number of records. */
+        p = (db->buffer + OFFSET_REFS);
+        for (i = 0; i < NUM_TABLES; ++i)
+        {
+            tableref_t ref;
+            p = read_tableref(&ref, p);
+            if (ref.offset)
+            {
+                /* Set buckets. */
+                db->ht[i].bucket = read_bucket(db->buffer + ref.offset, ref.num);
+                db->ht[i].num = ref.num;
+            }
+            else
+            {
+                /* An empty hash table. */
+                db->ht[i].bucket = NULL;
+                db->ht[i].num = 0;
+            }
+
+            /* The number of records is the half of the table size.*/
+            db->num += ref.num / 2;
+        }
+
+        /* Set the pointer to the backlink array if any. */
+        if (db->header.bwd_offset)
+        {
+            db->bwd = read_backward_links(db->buffer + db->header.bwd_offset, db->num);
+        }
+        else
+        {
+            db->bwd = NULL;
+        }
+    }
+
+    return db;
+}
+
+void cqdb_delete(cqdb_t *db)
+{
+    int i;
+
+    if (db != NULL)
+    {
+        for (i = 0; i < NUM_TABLES; ++i)
+        {
+            free(db->ht[i].bucket);
+        }
+        free(db->bwd);
+        free(db);
+    }
+}
+
+int cqdb_to_id(cqdb_t *db, const char *str)
+{
+    uint32_t hv = hashlittle(str, strlen(str) + 1, 0);
+    int t = hv % 256;
+    table_t *ht = &db->ht[t];
+
+    if (ht->num && ht->bucket != NULL)
+    {
+        int n = ht->num;
+        int k = (hv >> 8) % n;
+        bucket_t *p = NULL;
+
+        while (p = &ht->bucket[k], p->offset)
+        {
+            if (p->hash == hv)
+            {
+                int value;
+                uint32_t ksize;
+                const uint8_t *q = db->buffer + p->offset;
+                value = (int)read_uint32(q);
+                q += sizeof(uint32_t);
+                ksize = read_uint32(q);
+                q += sizeof(uint32_t);
+                if (strcmp(str, (const char *)q) == 0)
+                {
+                    return value;
+                }
+            }
+            k = (k + 1) % n;
+        }
+    }
+
+    return CQDB_ERROR_NOTFOUND;
+}
+
+const char *cqdb_to_string(cqdb_t *db, int id)
+{
+    /* Check if the current database supports the backward look-up. */
+    if (db->bwd != NULL && (uint32_t)id < db->header.bwd_size)
+    {
+        uint32_t offset = db->bwd[id];
+        if (offset)
+        {
+            const uint8_t *p = db->buffer + offset;
+            p += sizeof(uint32_t); /* Skip key data. */
+            p += sizeof(uint32_t); /* Skip value size. */
+            return (const char *)p;
+        }
+    }
+
+    return NULL;
+}
+
+int cqdb_num(cqdb_t *db)
+{
+    return db->num;
+}
```

## chaine/_core/crfsuite/lib/cqdb/src/lookup3.c

 * *Ordering differences only*

```diff
@@ -1,1271 +1,1271 @@
-/*
--------------------------------------------------------------------------------
-lookup3.c, by Bob Jenkins, May 2006, Public Domain.
-
-These are functions for producing 32-bit hashes for hash table lookup.
-hashword(), hashlittle(), hashlittle2(), hashbig(), mix(), and final()
-are externally useful functions.  Routines to test the hash are included
-if SELF_TEST is defined.  You can use this free for any purpose.  It's in
-the public domain.  It has no warranty.
-
-You probably want to use hashlittle().  hashlittle() and hashbig()
-hash byte arrays.  hashlittle() is is faster than hashbig() on
-little-endian machines.  Intel and AMD are little-endian machines.
-On second thought, you probably want hashlittle2(), which is identical to
-hashlittle() except it returns two 32-bit hashes for the price of one.
-You could implement hashbig2() if you wanted but I haven't bothered here.
-
-If you want to find a hash of, say, exactly 7 integers, do
-  a = i1;  b = i2;  c = i3;
-  mix(a,b,c);
-  a += i4; b += i5; c += i6;
-  mix(a,b,c);
-  a += i7;
-  final(a,b,c);
-then use c as the hash value.  If you have a variable length array of
-4-byte integers to hash, use hashword().  If you have a byte array (like
-a character string), use hashlittle().  If you have several byte arrays, or
-a mix of things, see the comments above hashlittle().
-
-Why is this so big?  I read 12 bytes at a time into 3 4-byte integers,
-then mix those integers.  This is fast (you can do a lot more thorough
-mixing with 12*3 instructions on 3 integers than you can with 3 instructions
-on 1 byte), but shoehorning those bytes into integers efficiently is messy.
--------------------------------------------------------------------------------
-*/
-//#define SELF_TEST 1
-
-#include <stdio.h>  /* defines printf for tests */
-#include <time.h>   /* defines time_t for timings in the test */
-#include <stdint.h> /* defines uint32_t etc */
-//#include <sys/param.h>  /* attempt to define endianness */
-#ifdef linux
-#include <endian.h> /* attempt to define endianness */
-#endif
-
-/*
- * My best guess at if you are big-endian or little-endian.  This may
- * need adjustment.
- */
-#if (defined(__BYTE_ORDER) && defined(__LITTLE_ENDIAN) &&       \
-     __BYTE_ORDER == __LITTLE_ENDIAN) ||                        \
-    (defined(i386) || defined(__i386__) || defined(__i486__) || \
-     defined(__i586__) || defined(__i686__) || defined(vax) || defined(MIPSEL))
-#define HASH_LITTLE_ENDIAN 1
-#define HASH_BIG_ENDIAN 0
-#elif (defined(__BYTE_ORDER) && defined(__BIG_ENDIAN) && \
-       __BYTE_ORDER == __BIG_ENDIAN) ||                  \
-    (defined(sparc) || defined(POWERPC) || defined(mc68000) || defined(sel))
-#define HASH_LITTLE_ENDIAN 0
-#define HASH_BIG_ENDIAN 1
-#else
-#define HASH_LITTLE_ENDIAN 0
-#define HASH_BIG_ENDIAN 0
-#endif
-
-#define hashsize(n) ((uint32_t)1 << (n))
-#define hashmask(n) (hashsize(n) - 1)
-#define rot(x, k) (((x) << (k)) | ((x) >> (32 - (k))))
-
-/*
--------------------------------------------------------------------------------
-mix -- mix 3 32-bit values reversibly.
-
-This is reversible, so any information in (a,b,c) before mix() is
-still in (a,b,c) after mix().
-
-If four pairs of (a,b,c) inputs are run through mix(), or through
-mix() in reverse, there are at least 32 bits of the output that
-are sometimes the same for one pair and different for another pair.
-This was tested for:
-* pairs that differed by one bit, by two bits, in any combination
-  of top bits of (a,b,c), or in any combination of bottom bits of
-  (a,b,c).
-* "differ" is defined as +, -, ^, or ~^.  For + and -, I transformed
-  the output delta to a Gray code (a^(a>>1)) so a string of 1's (as
-  is commonly produced by subtraction) look like a single 1-bit
-  difference.
-* the base values were pseudorandom, all zero but one bit set, or
-  all zero plus a counter that starts at zero.
-
-Some k values for my "a-=c; a^=rot(c,k); c+=b;" arrangement that
-satisfy this are
-    4  6  8 16 19  4
-    9 15  3 18 27 15
-   14  9  3  7 17  3
-Well, "9 15 3 18 27 15" didn't quite get 32 bits diffing
-for "differ" defined as + with a one-bit base and a two-bit delta.  I
-used http://burtleburtle.net/bob/hash/avalanche.html to choose
-the operations, constants, and arrangements of the variables.
-
-This does not achieve avalanche.  There are input bits of (a,b,c)
-that fail to affect some output bits of (a,b,c), especially of a.  The
-most thoroughly mixed value is c, but it doesn't really even achieve
-avalanche in c.
-
-This allows some parallelism.  Read-after-writes are good at doubling
-the number of bits affected, so the goal of mixing pulls in the opposite
-direction as the goal of parallelism.  I did what I could.  Rotates
-seem to cost as much as shifts on every machine I could lay my hands
-on, and rotates are much kinder to the top and bottom bits, so I used
-rotates.
--------------------------------------------------------------------------------
-*/
-#define mix(a, b, c) \
-  {                  \
-    a -= c;          \
-    a ^= rot(c, 4);  \
-    c += b;          \
-    b -= a;          \
-    b ^= rot(a, 6);  \
-    a += c;          \
-    c -= b;          \
-    c ^= rot(b, 8);  \
-    b += a;          \
-    a -= c;          \
-    a ^= rot(c, 16); \
-    c += b;          \
-    b -= a;          \
-    b ^= rot(a, 19); \
-    a += c;          \
-    c -= b;          \
-    c ^= rot(b, 4);  \
-    b += a;          \
-  }
-
-/*
--------------------------------------------------------------------------------
-final -- final mixing of 3 32-bit values (a,b,c) into c
-
-Pairs of (a,b,c) values differing in only a few bits will usually
-produce values of c that look totally different.  This was tested for
-* pairs that differed by one bit, by two bits, in any combination
-  of top bits of (a,b,c), or in any combination of bottom bits of
-  (a,b,c).
-* "differ" is defined as +, -, ^, or ~^.  For + and -, I transformed
-  the output delta to a Gray code (a^(a>>1)) so a string of 1's (as
-  is commonly produced by subtraction) look like a single 1-bit
-  difference.
-* the base values were pseudorandom, all zero but one bit set, or
-  all zero plus a counter that starts at zero.
-
-These constants passed:
- 14 11 25 16 4 14 24
- 12 14 25 16 4 14 24
-and these came close:
-  4  8 15 26 3 22 24
- 10  8 15 26 3 22 24
- 11  8 15 26 3 22 24
--------------------------------------------------------------------------------
-*/
-#define final(a, b, c) \
-  {                    \
-    c ^= b;            \
-    c -= rot(b, 14);   \
-    a ^= c;            \
-    a -= rot(c, 11);   \
-    b ^= a;            \
-    b -= rot(a, 25);   \
-    c ^= b;            \
-    c -= rot(b, 16);   \
-    a ^= c;            \
-    a -= rot(c, 4);    \
-    b ^= a;            \
-    b -= rot(a, 14);   \
-    c ^= b;            \
-    c -= rot(b, 24);   \
-  }
-
-/*
---------------------------------------------------------------------
- This works on all machines.  To be useful, it requires
- -- that the key be an array of uint32_t's, and
- -- that the length be the number of uint32_t's in the key
-
- The function hashword() is identical to hashlittle() on little-endian
- machines, and identical to hashbig() on big-endian machines,
- except that the length has to be measured in uint32_ts rather than in
- bytes.  hashlittle() is more complicated than hashword() only because
- hashlittle() has to dance around fitting the key bytes into registers.
---------------------------------------------------------------------
-*/
-uint32_t hashword(
-    const uint32_t *k, /* the key, an array of uint32_t values */
-    size_t length,     /* the length of the key, in uint32_ts */
-    uint32_t initval)  /* the previous hash, or an arbitrary value */
-{
-  uint32_t a, b, c;
-
-  /* Set up the internal state */
-  a = b = c = 0xdeadbeef + (((uint32_t)length) << 2) + initval;
-
-  /*------------------------------------------------- handle most of the key */
-  while (length > 3)
-  {
-    a += k[0];
-    b += k[1];
-    c += k[2];
-    mix(a, b, c);
-    length -= 3;
-    k += 3;
-  }
-
-  /*------------------------------------------- handle the last 3 uint32_t's */
-  switch (length) /* all the case statements fall through */
-  {
-  case 3:
-    c += k[2];
-  case 2:
-    b += k[1];
-  case 1:
-    a += k[0];
-    final(a, b, c);
-  case 0: /* case 0: nothing left to add */
-    break;
-  }
-  /*------------------------------------------------------ report the result */
-  return c;
-}
-
-/*
---------------------------------------------------------------------
-hashword2() -- same as hashword(), but take two seeds and return two
-32-bit values.  pc and pb must both be nonnull, and *pc and *pb must
-both be initialized with seeds.  If you pass in (*pb)==0, the output
-(*pc) will be the same as the return value from hashword().
---------------------------------------------------------------------
-*/
-void hashword2(
-    const uint32_t *k, /* the key, an array of uint32_t values */
-    size_t length,     /* the length of the key, in uint32_ts */
-    uint32_t *pc,      /* IN: seed OUT: primary hash value */
-    uint32_t *pb)      /* IN: more seed OUT: secondary hash value */
-{
-  uint32_t a, b, c;
-
-  /* Set up the internal state */
-  a = b = c = 0xdeadbeef + ((uint32_t)(length << 2)) + *pc;
-  c += *pb;
-
-  /*------------------------------------------------- handle most of the key */
-  while (length > 3)
-  {
-    a += k[0];
-    b += k[1];
-    c += k[2];
-    mix(a, b, c);
-    length -= 3;
-    k += 3;
-  }
-
-  /*------------------------------------------- handle the last 3 uint32_t's */
-  switch (length) /* all the case statements fall through */
-  {
-  case 3:
-    c += k[2];
-  case 2:
-    b += k[1];
-  case 1:
-    a += k[0];
-    final(a, b, c);
-  case 0: /* case 0: nothing left to add */
-    break;
-  }
-  /*------------------------------------------------------ report the result */
-  *pc = c;
-  *pb = b;
-}
-
-/*
--------------------------------------------------------------------------------
-hashlittle() -- hash a variable-length key into a 32-bit value
-  k       : the key (the unaligned variable-length array of bytes)
-  length  : the length of the key, counting by bytes
-  initval : can be any 4-byte value
-Returns a 32-bit value.  Every bit of the key affects every bit of
-the return value.  Two keys differing by one or two bits will have
-totally different hash values.
-
-The best hash table sizes are powers of 2.  There is no need to do
-mod a prime (mod is sooo slow!).  If you need less than 32 bits,
-use a bitmask.  For example, if you need only 10 bits, do
-  h = (h & hashmask(10));
-In which case, the hash table should have hashsize(10) elements.
-
-If you are hashing n strings (uint8_t **)k, do it like this:
-  for (i=0, h=0; i<n; ++i) h = hashlittle( k[i], len[i], h);
-
-By Bob Jenkins, 2006.  bob_jenkins@burtleburtle.net.  You may use this
-code any way you wish, private, educational, or commercial.  It's free.
-
-Use for hash table lookup, or anything where one collision in 2^^32 is
-acceptable.  Do NOT use for cryptographic purposes.
--------------------------------------------------------------------------------
-*/
-
-uint32_t hashlittle(const void *key, size_t length, uint32_t initval)
-{
-  uint32_t a, b, c; /* internal state */
-  union
-  {
-    const void *ptr;
-    size_t i;
-  } u; /* needed for Mac Powerbook G4 */
-
-  /* Set up the internal state */
-  a = b = c = 0xdeadbeef + ((uint32_t)length) + initval;
-
-  u.ptr = key;
-  if (HASH_LITTLE_ENDIAN && ((u.i & 0x3) == 0))
-  {
-    const uint32_t *k = (const uint32_t *)key; /* read 32-bit chunks */
-
-    /*------ all but last block: aligned reads and affect 32 bits of (a,b,c) */
-    while (length > 12)
-    {
-      a += k[0];
-      b += k[1];
-      c += k[2];
-      mix(a, b, c);
-      length -= 12;
-      k += 3;
-    }
-
-    /*----------------------------- handle the last (probably partial) block */
-    /*
-     * "k[2]&0xffffff" actually reads beyond the end of the string, but
-     * then masks off the part it's not allowed to read.  Because the
-     * string is aligned, the masked-off tail is in the same word as the
-     * rest of the string.  Every machine with memory protection I've seen
-     * does it on word boundaries, so is OK with this.  But VALGRIND will
-     * still catch it and complain.  The masking trick does make the hash
-     * noticably faster for short strings (like English words).
-     */
-#ifndef VALGRIND
-
-    switch (length)
-    {
-    case 12:
-      c += k[2];
-      b += k[1];
-      a += k[0];
-      break;
-    case 11:
-      c += k[2] & 0xffffff;
-      b += k[1];
-      a += k[0];
-      break;
-    case 10:
-      c += k[2] & 0xffff;
-      b += k[1];
-      a += k[0];
-      break;
-    case 9:
-      c += k[2] & 0xff;
-      b += k[1];
-      a += k[0];
-      break;
-    case 8:
-      b += k[1];
-      a += k[0];
-      break;
-    case 7:
-      b += k[1] & 0xffffff;
-      a += k[0];
-      break;
-    case 6:
-      b += k[1] & 0xffff;
-      a += k[0];
-      break;
-    case 5:
-      b += k[1] & 0xff;
-      a += k[0];
-      break;
-    case 4:
-      a += k[0];
-      break;
-    case 3:
-      a += k[0] & 0xffffff;
-      break;
-    case 2:
-      a += k[0] & 0xffff;
-      break;
-    case 1:
-      a += k[0] & 0xff;
-      break;
-    case 0:
-      return c; /* zero length strings require no mixing */
-    }
-
-#else /* make valgrind happy */
-
-    k8 = (const uint8_t *)k;
-    switch (length)
-    {
-    case 12:
-      c += k[2];
-      b += k[1];
-      a += k[0];
-      break;
-    case 11:
-      c += ((uint32_t)k8[10]) << 16; /* fall through */
-    case 10:
-      c += ((uint32_t)k8[9]) << 8; /* fall through */
-    case 9:
-      c += k8[8]; /* fall through */
-    case 8:
-      b += k[1];
-      a += k[0];
-      break;
-    case 7:
-      b += ((uint32_t)k8[6]) << 16; /* fall through */
-    case 6:
-      b += ((uint32_t)k8[5]) << 8; /* fall through */
-    case 5:
-      b += k8[4]; /* fall through */
-    case 4:
-      a += k[0];
-      break;
-    case 3:
-      a += ((uint32_t)k8[2]) << 16; /* fall through */
-    case 2:
-      a += ((uint32_t)k8[1]) << 8; /* fall through */
-    case 1:
-      a += k8[0];
-      break;
-    case 0:
-      return c;
-    }
-
-#endif /* !valgrind */
-  }
-  else if (HASH_LITTLE_ENDIAN && ((u.i & 0x1) == 0))
-  {
-    const uint16_t *k = (const uint16_t *)key; /* read 16-bit chunks */
-    const uint8_t *k8;
-
-    /*--------------- all but last block: aligned reads and different mixing */
-    while (length > 12)
-    {
-      a += k[0] + (((uint32_t)k[1]) << 16);
-      b += k[2] + (((uint32_t)k[3]) << 16);
-      c += k[4] + (((uint32_t)k[5]) << 16);
-      mix(a, b, c);
-      length -= 12;
-      k += 6;
-    }
-
-    /*----------------------------- handle the last (probably partial) block */
-    k8 = (const uint8_t *)k;
-    switch (length)
-    {
-    case 12:
-      c += k[4] + (((uint32_t)k[5]) << 16);
-      b += k[2] + (((uint32_t)k[3]) << 16);
-      a += k[0] + (((uint32_t)k[1]) << 16);
-      break;
-    case 11:
-      c += ((uint32_t)k8[10]) << 16; /* fall through */
-    case 10:
-      c += k[4];
-      b += k[2] + (((uint32_t)k[3]) << 16);
-      a += k[0] + (((uint32_t)k[1]) << 16);
-      break;
-    case 9:
-      c += k8[8]; /* fall through */
-    case 8:
-      b += k[2] + (((uint32_t)k[3]) << 16);
-      a += k[0] + (((uint32_t)k[1]) << 16);
-      break;
-    case 7:
-      b += ((uint32_t)k8[6]) << 16; /* fall through */
-    case 6:
-      b += k[2];
-      a += k[0] + (((uint32_t)k[1]) << 16);
-      break;
-    case 5:
-      b += k8[4]; /* fall through */
-    case 4:
-      a += k[0] + (((uint32_t)k[1]) << 16);
-      break;
-    case 3:
-      a += ((uint32_t)k8[2]) << 16; /* fall through */
-    case 2:
-      a += k[0];
-      break;
-    case 1:
-      a += k8[0];
-      break;
-    case 0:
-      return c; /* zero length requires no mixing */
-    }
-  }
-  else
-  { /* need to read the key one byte at a time */
-    const uint8_t *k = (const uint8_t *)key;
-
-    /*--------------- all but the last block: affect some 32 bits of (a,b,c) */
-    while (length > 12)
-    {
-      a += k[0];
-      a += ((uint32_t)k[1]) << 8;
-      a += ((uint32_t)k[2]) << 16;
-      a += ((uint32_t)k[3]) << 24;
-      b += k[4];
-      b += ((uint32_t)k[5]) << 8;
-      b += ((uint32_t)k[6]) << 16;
-      b += ((uint32_t)k[7]) << 24;
-      c += k[8];
-      c += ((uint32_t)k[9]) << 8;
-      c += ((uint32_t)k[10]) << 16;
-      c += ((uint32_t)k[11]) << 24;
-      mix(a, b, c);
-      length -= 12;
-      k += 12;
-    }
-
-    /*-------------------------------- last block: affect all 32 bits of (c) */
-    switch (length) /* all the case statements fall through */
-    {
-    case 12:
-      c += ((uint32_t)k[11]) << 24;
-    case 11:
-      c += ((uint32_t)k[10]) << 16;
-    case 10:
-      c += ((uint32_t)k[9]) << 8;
-    case 9:
-      c += k[8];
-    case 8:
-      b += ((uint32_t)k[7]) << 24;
-    case 7:
-      b += ((uint32_t)k[6]) << 16;
-    case 6:
-      b += ((uint32_t)k[5]) << 8;
-    case 5:
-      b += k[4];
-    case 4:
-      a += ((uint32_t)k[3]) << 24;
-    case 3:
-      a += ((uint32_t)k[2]) << 16;
-    case 2:
-      a += ((uint32_t)k[1]) << 8;
-    case 1:
-      a += k[0];
-      break;
-    case 0:
-      return c;
-    }
-  }
-
-  final(a, b, c);
-  return c;
-}
-
-/*
- * hashlittle2: return 2 32-bit hash values
- *
- * This is identical to hashlittle(), except it returns two 32-bit hash
- * values instead of just one.  This is good enough for hash table
- * lookup with 2^^64 buckets, or if you want a second hash if you're not
- * happy with the first, or if you want a probably-unique 64-bit ID for
- * the key.  *pc is better mixed than *pb, so use *pc first.  If you want
- * a 64-bit value do something like "*pc + (((uint64_t)*pb)<<32)".
- */
-void hashlittle2(
-    const void *key, /* the key to hash */
-    size_t length,   /* length of the key */
-    uint32_t *pc,    /* IN: primary initval, OUT: primary hash */
-    uint32_t *pb)    /* IN: secondary initval, OUT: secondary hash */
-{
-  uint32_t a, b, c; /* internal state */
-  union
-  {
-    const void *ptr;
-    size_t i;
-  } u; /* needed for Mac Powerbook G4 */
-
-  /* Set up the internal state */
-  a = b = c = 0xdeadbeef + ((uint32_t)length) + *pc;
-  c += *pb;
-
-  u.ptr = key;
-  if (HASH_LITTLE_ENDIAN && ((u.i & 0x3) == 0))
-  {
-    const uint32_t *k = (const uint32_t *)key; /* read 32-bit chunks */
-
-    /*------ all but last block: aligned reads and affect 32 bits of (a,b,c) */
-    while (length > 12)
-    {
-      a += k[0];
-      b += k[1];
-      c += k[2];
-      mix(a, b, c);
-      length -= 12;
-      k += 3;
-    }
-
-    /*----------------------------- handle the last (probably partial) block */
-    /*
-     * "k[2]&0xffffff" actually reads beyond the end of the string, but
-     * then masks off the part it's not allowed to read.  Because the
-     * string is aligned, the masked-off tail is in the same word as the
-     * rest of the string.  Every machine with memory protection I've seen
-     * does it on word boundaries, so is OK with this.  But VALGRIND will
-     * still catch it and complain.  The masking trick does make the hash
-     * noticably faster for short strings (like English words).
-     */
-#ifndef VALGRIND
-
-    switch (length)
-    {
-    case 12:
-      c += k[2];
-      b += k[1];
-      a += k[0];
-      break;
-    case 11:
-      c += k[2] & 0xffffff;
-      b += k[1];
-      a += k[0];
-      break;
-    case 10:
-      c += k[2] & 0xffff;
-      b += k[1];
-      a += k[0];
-      break;
-    case 9:
-      c += k[2] & 0xff;
-      b += k[1];
-      a += k[0];
-      break;
-    case 8:
-      b += k[1];
-      a += k[0];
-      break;
-    case 7:
-      b += k[1] & 0xffffff;
-      a += k[0];
-      break;
-    case 6:
-      b += k[1] & 0xffff;
-      a += k[0];
-      break;
-    case 5:
-      b += k[1] & 0xff;
-      a += k[0];
-      break;
-    case 4:
-      a += k[0];
-      break;
-    case 3:
-      a += k[0] & 0xffffff;
-      break;
-    case 2:
-      a += k[0] & 0xffff;
-      break;
-    case 1:
-      a += k[0] & 0xff;
-      break;
-    case 0:
-      *pc = c;
-      *pb = b;
-      return; /* zero length strings require no mixing */
-    }
-
-#else /* make valgrind happy */
-
-    k8 = (const uint8_t *)k;
-    switch (length)
-    {
-    case 12:
-      c += k[2];
-      b += k[1];
-      a += k[0];
-      break;
-    case 11:
-      c += ((uint32_t)k8[10]) << 16; /* fall through */
-    case 10:
-      c += ((uint32_t)k8[9]) << 8; /* fall through */
-    case 9:
-      c += k8[8]; /* fall through */
-    case 8:
-      b += k[1];
-      a += k[0];
-      break;
-    case 7:
-      b += ((uint32_t)k8[6]) << 16; /* fall through */
-    case 6:
-      b += ((uint32_t)k8[5]) << 8; /* fall through */
-    case 5:
-      b += k8[4]; /* fall through */
-    case 4:
-      a += k[0];
-      break;
-    case 3:
-      a += ((uint32_t)k8[2]) << 16; /* fall through */
-    case 2:
-      a += ((uint32_t)k8[1]) << 8; /* fall through */
-    case 1:
-      a += k8[0];
-      break;
-    case 0:
-      *pc = c;
-      *pb = b;
-      return; /* zero length strings require no mixing */
-    }
-
-#endif /* !valgrind */
-  }
-  else if (HASH_LITTLE_ENDIAN && ((u.i & 0x1) == 0))
-  {
-    const uint16_t *k = (const uint16_t *)key; /* read 16-bit chunks */
-    const uint8_t *k8;
-
-    /*--------------- all but last block: aligned reads and different mixing */
-    while (length > 12)
-    {
-      a += k[0] + (((uint32_t)k[1]) << 16);
-      b += k[2] + (((uint32_t)k[3]) << 16);
-      c += k[4] + (((uint32_t)k[5]) << 16);
-      mix(a, b, c);
-      length -= 12;
-      k += 6;
-    }
-
-    /*----------------------------- handle the last (probably partial) block */
-    k8 = (const uint8_t *)k;
-    switch (length)
-    {
-    case 12:
-      c += k[4] + (((uint32_t)k[5]) << 16);
-      b += k[2] + (((uint32_t)k[3]) << 16);
-      a += k[0] + (((uint32_t)k[1]) << 16);
-      break;
-    case 11:
-      c += ((uint32_t)k8[10]) << 16; /* fall through */
-    case 10:
-      c += k[4];
-      b += k[2] + (((uint32_t)k[3]) << 16);
-      a += k[0] + (((uint32_t)k[1]) << 16);
-      break;
-    case 9:
-      c += k8[8]; /* fall through */
-    case 8:
-      b += k[2] + (((uint32_t)k[3]) << 16);
-      a += k[0] + (((uint32_t)k[1]) << 16);
-      break;
-    case 7:
-      b += ((uint32_t)k8[6]) << 16; /* fall through */
-    case 6:
-      b += k[2];
-      a += k[0] + (((uint32_t)k[1]) << 16);
-      break;
-    case 5:
-      b += k8[4]; /* fall through */
-    case 4:
-      a += k[0] + (((uint32_t)k[1]) << 16);
-      break;
-    case 3:
-      a += ((uint32_t)k8[2]) << 16; /* fall through */
-    case 2:
-      a += k[0];
-      break;
-    case 1:
-      a += k8[0];
-      break;
-    case 0:
-      *pc = c;
-      *pb = b;
-      return; /* zero length strings require no mixing */
-    }
-  }
-  else
-  { /* need to read the key one byte at a time */
-    const uint8_t *k = (const uint8_t *)key;
-
-    /*--------------- all but the last block: affect some 32 bits of (a,b,c) */
-    while (length > 12)
-    {
-      a += k[0];
-      a += ((uint32_t)k[1]) << 8;
-      a += ((uint32_t)k[2]) << 16;
-      a += ((uint32_t)k[3]) << 24;
-      b += k[4];
-      b += ((uint32_t)k[5]) << 8;
-      b += ((uint32_t)k[6]) << 16;
-      b += ((uint32_t)k[7]) << 24;
-      c += k[8];
-      c += ((uint32_t)k[9]) << 8;
-      c += ((uint32_t)k[10]) << 16;
-      c += ((uint32_t)k[11]) << 24;
-      mix(a, b, c);
-      length -= 12;
-      k += 12;
-    }
-
-    /*-------------------------------- last block: affect all 32 bits of (c) */
-    switch (length) /* all the case statements fall through */
-    {
-    case 12:
-      c += ((uint32_t)k[11]) << 24;
-    case 11:
-      c += ((uint32_t)k[10]) << 16;
-    case 10:
-      c += ((uint32_t)k[9]) << 8;
-    case 9:
-      c += k[8];
-    case 8:
-      b += ((uint32_t)k[7]) << 24;
-    case 7:
-      b += ((uint32_t)k[6]) << 16;
-    case 6:
-      b += ((uint32_t)k[5]) << 8;
-    case 5:
-      b += k[4];
-    case 4:
-      a += ((uint32_t)k[3]) << 24;
-    case 3:
-      a += ((uint32_t)k[2]) << 16;
-    case 2:
-      a += ((uint32_t)k[1]) << 8;
-    case 1:
-      a += k[0];
-      break;
-    case 0:
-      *pc = c;
-      *pb = b;
-      return; /* zero length strings require no mixing */
-    }
-  }
-
-  final(a, b, c);
-  *pc = c;
-  *pb = b;
-}
-
-/*
- * hashbig():
- * This is the same as hashword() on big-endian machines.  It is different
- * from hashlittle() on all machines.  hashbig() takes advantage of
- * big-endian byte ordering.
- */
-uint32_t hashbig(const void *key, size_t length, uint32_t initval)
-{
-  uint32_t a, b, c;
-  union
-  {
-    const void *ptr;
-    size_t i;
-  } u; /* to cast key to (size_t) happily */
-
-  /* Set up the internal state */
-  a = b = c = 0xdeadbeef + ((uint32_t)length) + initval;
-
-  u.ptr = key;
-  if (HASH_BIG_ENDIAN && ((u.i & 0x3) == 0))
-  {
-    const uint32_t *k = (const uint32_t *)key; /* read 32-bit chunks */
-
-    /*------ all but last block: aligned reads and affect 32 bits of (a,b,c) */
-    while (length > 12)
-    {
-      a += k[0];
-      b += k[1];
-      c += k[2];
-      mix(a, b, c);
-      length -= 12;
-      k += 3;
-    }
-
-    /*----------------------------- handle the last (probably partial) block */
-    /*
-     * "k[2]<<8" actually reads beyond the end of the string, but
-     * then shifts out the part it's not allowed to read.  Because the
-     * string is aligned, the illegal read is in the same word as the
-     * rest of the string.  Every machine with memory protection I've seen
-     * does it on word boundaries, so is OK with this.  But VALGRIND will
-     * still catch it and complain.  The masking trick does make the hash
-     * noticably faster for short strings (like English words).
-     */
-#ifndef VALGRIND
-
-    switch (length)
-    {
-    case 12:
-      c += k[2];
-      b += k[1];
-      a += k[0];
-      break;
-    case 11:
-      c += k[2] & 0xffffff00;
-      b += k[1];
-      a += k[0];
-      break;
-    case 10:
-      c += k[2] & 0xffff0000;
-      b += k[1];
-      a += k[0];
-      break;
-    case 9:
-      c += k[2] & 0xff000000;
-      b += k[1];
-      a += k[0];
-      break;
-    case 8:
-      b += k[1];
-      a += k[0];
-      break;
-    case 7:
-      b += k[1] & 0xffffff00;
-      a += k[0];
-      break;
-    case 6:
-      b += k[1] & 0xffff0000;
-      a += k[0];
-      break;
-    case 5:
-      b += k[1] & 0xff000000;
-      a += k[0];
-      break;
-    case 4:
-      a += k[0];
-      break;
-    case 3:
-      a += k[0] & 0xffffff00;
-      break;
-    case 2:
-      a += k[0] & 0xffff0000;
-      break;
-    case 1:
-      a += k[0] & 0xff000000;
-      break;
-    case 0:
-      return c; /* zero length strings require no mixing */
-    }
-
-#else /* make valgrind happy */
-
-    k8 = (const uint8_t *)k;
-    switch (length) /* all the case statements fall through */
-    {
-    case 12:
-      c += k[2];
-      b += k[1];
-      a += k[0];
-      break;
-    case 11:
-      c += ((uint32_t)k8[10]) << 8; /* fall through */
-    case 10:
-      c += ((uint32_t)k8[9]) << 16; /* fall through */
-    case 9:
-      c += ((uint32_t)k8[8]) << 24; /* fall through */
-    case 8:
-      b += k[1];
-      a += k[0];
-      break;
-    case 7:
-      b += ((uint32_t)k8[6]) << 8; /* fall through */
-    case 6:
-      b += ((uint32_t)k8[5]) << 16; /* fall through */
-    case 5:
-      b += ((uint32_t)k8[4]) << 24; /* fall through */
-    case 4:
-      a += k[0];
-      break;
-    case 3:
-      a += ((uint32_t)k8[2]) << 8; /* fall through */
-    case 2:
-      a += ((uint32_t)k8[1]) << 16; /* fall through */
-    case 1:
-      a += ((uint32_t)k8[0]) << 24;
-      break;
-    case 0:
-      return c;
-    }
-
-#endif /* !VALGRIND */
-  }
-  else
-  { /* need to read the key one byte at a time */
-    const uint8_t *k = (const uint8_t *)key;
-
-    /*--------------- all but the last block: affect some 32 bits of (a,b,c) */
-    while (length > 12)
-    {
-      a += ((uint32_t)k[0]) << 24;
-      a += ((uint32_t)k[1]) << 16;
-      a += ((uint32_t)k[2]) << 8;
-      a += ((uint32_t)k[3]);
-      b += ((uint32_t)k[4]) << 24;
-      b += ((uint32_t)k[5]) << 16;
-      b += ((uint32_t)k[6]) << 8;
-      b += ((uint32_t)k[7]);
-      c += ((uint32_t)k[8]) << 24;
-      c += ((uint32_t)k[9]) << 16;
-      c += ((uint32_t)k[10]) << 8;
-      c += ((uint32_t)k[11]);
-      mix(a, b, c);
-      length -= 12;
-      k += 12;
-    }
-
-    /*-------------------------------- last block: affect all 32 bits of (c) */
-    switch (length) /* all the case statements fall through */
-    {
-    case 12:
-      c += k[11];
-    case 11:
-      c += ((uint32_t)k[10]) << 8;
-    case 10:
-      c += ((uint32_t)k[9]) << 16;
-    case 9:
-      c += ((uint32_t)k[8]) << 24;
-    case 8:
-      b += k[7];
-    case 7:
-      b += ((uint32_t)k[6]) << 8;
-    case 6:
-      b += ((uint32_t)k[5]) << 16;
-    case 5:
-      b += ((uint32_t)k[4]) << 24;
-    case 4:
-      a += k[3];
-    case 3:
-      a += ((uint32_t)k[2]) << 8;
-    case 2:
-      a += ((uint32_t)k[1]) << 16;
-    case 1:
-      a += ((uint32_t)k[0]) << 24;
-      break;
-    case 0:
-      return c;
-    }
-  }
-
-  final(a, b, c);
-  return c;
-}
-
-#ifdef SELF_TEST
-
-/* used for timings */
-void driver1()
-{
-  uint8_t buf[256];
-  uint32_t i;
-  uint32_t h = 0;
-  time_t a, z;
-
-  time(&a);
-  for (i = 0; i < 256; ++i)
-    buf[i] = 'x';
-  for (i = 0; i < 1; ++i)
-  {
-    h = hashlittle(&buf[0], 1, h);
-  }
-  time(&z);
-  if (z - a > 0)
-    printf("time %d %.8x\n", z - a, h);
-}
-
-/* check that every input bit changes every output bit half the time */
-#define HASHSTATE 1
-#define HASHLEN 1
-#define MAXPAIR 60
-#define MAXLEN 70
-void driver2()
-{
-  uint8_t qa[MAXLEN + 1], qb[MAXLEN + 2], *a = &qa[0], *b = &qb[1];
-  uint32_t c[HASHSTATE], d[HASHSTATE], i = 0, j = 0, k, l, m = 0, z;
-  uint32_t e[HASHSTATE], f[HASHSTATE], g[HASHSTATE], h[HASHSTATE];
-  uint32_t x[HASHSTATE], y[HASHSTATE];
-  uint32_t hlen;
-
-  printf("No more than %d trials should ever be needed \n", MAXPAIR / 2);
-  for (hlen = 0; hlen < MAXLEN; ++hlen)
-  {
-    z = 0;
-    for (i = 0; i < hlen; ++i) /*----------------------- for each input byte, */
-    {
-      for (j = 0; j < 8; ++j) /*------------------------ for each input bit, */
-      {
-        for (m = 1; m < 8; ++m) /*------------ for serveral possible initvals, */
-        {
-          for (l = 0; l < HASHSTATE; ++l)
-            e[l] = f[l] = g[l] = h[l] = x[l] = y[l] = ~((uint32_t)0);
-
-          /*---- check that every output bit is affected by that input bit */
-          for (k = 0; k < MAXPAIR; k += 2)
-          {
-            uint32_t finished = 1;
-            /* keys have one bit different */
-            for (l = 0; l < hlen + 1; ++l)
-            {
-              a[l] = b[l] = (uint8_t)0;
-            }
-            /* have a and b be two keys differing in only one bit */
-            a[i] ^= (k << j);
-            a[i] ^= (k >> (8 - j));
-            c[0] = hashlittle(a, hlen, m);
-            b[i] ^= ((k + 1) << j);
-            b[i] ^= ((k + 1) >> (8 - j));
-            d[0] = hashlittle(b, hlen, m);
-            /* check every bit is 1, 0, set, and not set at least once */
-            for (l = 0; l < HASHSTATE; ++l)
-            {
-              e[l] &= (c[l] ^ d[l]);
-              f[l] &= ~(c[l] ^ d[l]);
-              g[l] &= c[l];
-              h[l] &= ~c[l];
-              x[l] &= d[l];
-              y[l] &= ~d[l];
-              if (e[l] | f[l] | g[l] | h[l] | x[l] | y[l])
-                finished = 0;
-            }
-            if (finished)
-              break;
-          }
-          if (k > z)
-            z = k;
-          if (k == MAXPAIR)
-          {
-            printf("Some bit didn't change: ");
-            printf("%.8x %.8x %.8x %.8x %.8x %.8x  ",
-                   e[0], f[0], g[0], h[0], x[0], y[0]);
-            printf("i %d j %d m %d len %d\n", i, j, m, hlen);
-          }
-          if (z == MAXPAIR)
-            goto done;
-        }
-      }
-    }
-  done:
-    if (z < MAXPAIR)
-    {
-      printf("Mix success  %2d bytes  %2d initvals  ", i, m);
-      printf("required  %d  trials\n", z / 2);
-    }
-  }
-  printf("\n");
-}
-
-/* Check for reading beyond the end of the buffer and alignment problems */
-void driver3()
-{
-  uint8_t buf[MAXLEN + 20], *b;
-  uint32_t len;
-  uint8_t q[] = "This is the time for all good men to come to the aid of their country...";
-  uint32_t h;
-  uint8_t qq[] = "xThis is the time for all good men to come to the aid of their country...";
-  uint32_t i;
-  uint8_t qqq[] = "xxThis is the time for all good men to come to the aid of their country...";
-  uint32_t j;
-  uint8_t qqqq[] = "xxxThis is the time for all good men to come to the aid of their country...";
-  uint32_t ref, x, y;
-  uint8_t *p;
-
-  printf("Endianness.  These lines should all be the same (for values filled in):\n");
-  printf("%.8x                            %.8x                            %.8x\n",
-         hashword((const uint32_t *)q, (sizeof(q) - 1) / 4, 13),
-         hashword((const uint32_t *)q, (sizeof(q) - 5) / 4, 13),
-         hashword((const uint32_t *)q, (sizeof(q) - 9) / 4, 13));
-  p = q;
-  printf("%.8x %.8x %.8x %.8x %.8x %.8x %.8x %.8x %.8x %.8x %.8x %.8x\n",
-         hashlittle(p, sizeof(q) - 1, 13), hashlittle(p, sizeof(q) - 2, 13),
-         hashlittle(p, sizeof(q) - 3, 13), hashlittle(p, sizeof(q) - 4, 13),
-         hashlittle(p, sizeof(q) - 5, 13), hashlittle(p, sizeof(q) - 6, 13),
-         hashlittle(p, sizeof(q) - 7, 13), hashlittle(p, sizeof(q) - 8, 13),
-         hashlittle(p, sizeof(q) - 9, 13), hashlittle(p, sizeof(q) - 10, 13),
-         hashlittle(p, sizeof(q) - 11, 13), hashlittle(p, sizeof(q) - 12, 13));
-  p = &qq[1];
-  printf("%.8x %.8x %.8x %.8x %.8x %.8x %.8x %.8x %.8x %.8x %.8x %.8x\n",
-         hashlittle(p, sizeof(q) - 1, 13), hashlittle(p, sizeof(q) - 2, 13),
-         hashlittle(p, sizeof(q) - 3, 13), hashlittle(p, sizeof(q) - 4, 13),
-         hashlittle(p, sizeof(q) - 5, 13), hashlittle(p, sizeof(q) - 6, 13),
-         hashlittle(p, sizeof(q) - 7, 13), hashlittle(p, sizeof(q) - 8, 13),
-         hashlittle(p, sizeof(q) - 9, 13), hashlittle(p, sizeof(q) - 10, 13),
-         hashlittle(p, sizeof(q) - 11, 13), hashlittle(p, sizeof(q) - 12, 13));
-  p = &qqq[2];
-  printf("%.8x %.8x %.8x %.8x %.8x %.8x %.8x %.8x %.8x %.8x %.8x %.8x\n",
-         hashlittle(p, sizeof(q) - 1, 13), hashlittle(p, sizeof(q) - 2, 13),
-         hashlittle(p, sizeof(q) - 3, 13), hashlittle(p, sizeof(q) - 4, 13),
-         hashlittle(p, sizeof(q) - 5, 13), hashlittle(p, sizeof(q) - 6, 13),
-         hashlittle(p, sizeof(q) - 7, 13), hashlittle(p, sizeof(q) - 8, 13),
-         hashlittle(p, sizeof(q) - 9, 13), hashlittle(p, sizeof(q) - 10, 13),
-         hashlittle(p, sizeof(q) - 11, 13), hashlittle(p, sizeof(q) - 12, 13));
-  p = &qqqq[3];
-  printf("%.8x %.8x %.8x %.8x %.8x %.8x %.8x %.8x %.8x %.8x %.8x %.8x\n",
-         hashlittle(p, sizeof(q) - 1, 13), hashlittle(p, sizeof(q) - 2, 13),
-         hashlittle(p, sizeof(q) - 3, 13), hashlittle(p, sizeof(q) - 4, 13),
-         hashlittle(p, sizeof(q) - 5, 13), hashlittle(p, sizeof(q) - 6, 13),
-         hashlittle(p, sizeof(q) - 7, 13), hashlittle(p, sizeof(q) - 8, 13),
-         hashlittle(p, sizeof(q) - 9, 13), hashlittle(p, sizeof(q) - 10, 13),
-         hashlittle(p, sizeof(q) - 11, 13), hashlittle(p, sizeof(q) - 12, 13));
-  printf("\n");
-
-  /* check that hashlittle2 and hashlittle produce the same results */
-  i = 47;
-  j = 0;
-  hashlittle2(q, sizeof(q), &i, &j);
-  if (hashlittle(q, sizeof(q), 47) != i)
-    printf("hashlittle2 and hashlittle mismatch\n");
-
-  /* check that hashword2 and hashword produce the same results */
-  len = 0xdeadbeef;
-  i = 47, j = 0;
-  hashword2(&len, 1, &i, &j);
-  if (hashword(&len, 1, 47) != i)
-    printf("hashword2 and hashword mismatch %x %x\n",
-           i, hashword(&len, 1, 47));
-
-  /* check hashlittle doesn't read before or after the ends of the string */
-  for (h = 0, b = buf + 1; h < 8; ++h, ++b)
-  {
-    for (i = 0; i < MAXLEN; ++i)
-    {
-      len = i;
-      for (j = 0; j < i; ++j)
-        *(b + j) = 0;
-
-      /* these should all be equal */
-      ref = hashlittle(b, len, (uint32_t)1);
-      *(b + i) = (uint8_t)~0;
-      *(b - 1) = (uint8_t)~0;
-      x = hashlittle(b, len, (uint32_t)1);
-      y = hashlittle(b, len, (uint32_t)1);
-      if ((ref != x) || (ref != y))
-      {
-        printf("alignment error: %.8x %.8x %.8x %d %d\n", ref, x, y,
-               h, i);
-      }
-    }
-  }
-}
-
-/* check for problems with nulls */
-void driver4()
-{
-  uint8_t buf[1];
-  uint32_t h, i, state[HASHSTATE];
-
-  buf[0] = ~0;
-  for (i = 0; i < HASHSTATE; ++i)
-    state[i] = 1;
-  printf("These should all be different\n");
-  for (i = 0, h = 0; i < 8; ++i)
-  {
-    h = hashlittle(buf, 0, h);
-    printf("%2ld  0-byte strings, hash is  %.8x\n", i, h);
-  }
-}
-
-int main()
-{
-  driver1(); /* test that the key is hashed: used for timings */
-  driver2(); /* test that whole key is hashed thoroughly */
-  driver3(); /* test that nothing but the key is hashed */
-  driver4(); /* test hashing multiple buffers (all buffers are null) */
-  return 1;
-}
-
-#endif /* SELF_TEST */
+/*
+-------------------------------------------------------------------------------
+lookup3.c, by Bob Jenkins, May 2006, Public Domain.
+
+These are functions for producing 32-bit hashes for hash table lookup.
+hashword(), hashlittle(), hashlittle2(), hashbig(), mix(), and final()
+are externally useful functions.  Routines to test the hash are included
+if SELF_TEST is defined.  You can use this free for any purpose.  It's in
+the public domain.  It has no warranty.
+
+You probably want to use hashlittle().  hashlittle() and hashbig()
+hash byte arrays.  hashlittle() is is faster than hashbig() on
+little-endian machines.  Intel and AMD are little-endian machines.
+On second thought, you probably want hashlittle2(), which is identical to
+hashlittle() except it returns two 32-bit hashes for the price of one.
+You could implement hashbig2() if you wanted but I haven't bothered here.
+
+If you want to find a hash of, say, exactly 7 integers, do
+  a = i1;  b = i2;  c = i3;
+  mix(a,b,c);
+  a += i4; b += i5; c += i6;
+  mix(a,b,c);
+  a += i7;
+  final(a,b,c);
+then use c as the hash value.  If you have a variable length array of
+4-byte integers to hash, use hashword().  If you have a byte array (like
+a character string), use hashlittle().  If you have several byte arrays, or
+a mix of things, see the comments above hashlittle().
+
+Why is this so big?  I read 12 bytes at a time into 3 4-byte integers,
+then mix those integers.  This is fast (you can do a lot more thorough
+mixing with 12*3 instructions on 3 integers than you can with 3 instructions
+on 1 byte), but shoehorning those bytes into integers efficiently is messy.
+-------------------------------------------------------------------------------
+*/
+//#define SELF_TEST 1
+
+#include <stdio.h>  /* defines printf for tests */
+#include <time.h>   /* defines time_t for timings in the test */
+#include <stdint.h> /* defines uint32_t etc */
+//#include <sys/param.h>  /* attempt to define endianness */
+#ifdef linux
+#include <endian.h> /* attempt to define endianness */
+#endif
+
+/*
+ * My best guess at if you are big-endian or little-endian.  This may
+ * need adjustment.
+ */
+#if (defined(__BYTE_ORDER) && defined(__LITTLE_ENDIAN) &&       \
+     __BYTE_ORDER == __LITTLE_ENDIAN) ||                        \
+    (defined(i386) || defined(__i386__) || defined(__i486__) || \
+     defined(__i586__) || defined(__i686__) || defined(vax) || defined(MIPSEL))
+#define HASH_LITTLE_ENDIAN 1
+#define HASH_BIG_ENDIAN 0
+#elif (defined(__BYTE_ORDER) && defined(__BIG_ENDIAN) && \
+       __BYTE_ORDER == __BIG_ENDIAN) ||                  \
+    (defined(sparc) || defined(POWERPC) || defined(mc68000) || defined(sel))
+#define HASH_LITTLE_ENDIAN 0
+#define HASH_BIG_ENDIAN 1
+#else
+#define HASH_LITTLE_ENDIAN 0
+#define HASH_BIG_ENDIAN 0
+#endif
+
+#define hashsize(n) ((uint32_t)1 << (n))
+#define hashmask(n) (hashsize(n) - 1)
+#define rot(x, k) (((x) << (k)) | ((x) >> (32 - (k))))
+
+/*
+-------------------------------------------------------------------------------
+mix -- mix 3 32-bit values reversibly.
+
+This is reversible, so any information in (a,b,c) before mix() is
+still in (a,b,c) after mix().
+
+If four pairs of (a,b,c) inputs are run through mix(), or through
+mix() in reverse, there are at least 32 bits of the output that
+are sometimes the same for one pair and different for another pair.
+This was tested for:
+* pairs that differed by one bit, by two bits, in any combination
+  of top bits of (a,b,c), or in any combination of bottom bits of
+  (a,b,c).
+* "differ" is defined as +, -, ^, or ~^.  For + and -, I transformed
+  the output delta to a Gray code (a^(a>>1)) so a string of 1's (as
+  is commonly produced by subtraction) look like a single 1-bit
+  difference.
+* the base values were pseudorandom, all zero but one bit set, or
+  all zero plus a counter that starts at zero.
+
+Some k values for my "a-=c; a^=rot(c,k); c+=b;" arrangement that
+satisfy this are
+    4  6  8 16 19  4
+    9 15  3 18 27 15
+   14  9  3  7 17  3
+Well, "9 15 3 18 27 15" didn't quite get 32 bits diffing
+for "differ" defined as + with a one-bit base and a two-bit delta.  I
+used http://burtleburtle.net/bob/hash/avalanche.html to choose
+the operations, constants, and arrangements of the variables.
+
+This does not achieve avalanche.  There are input bits of (a,b,c)
+that fail to affect some output bits of (a,b,c), especially of a.  The
+most thoroughly mixed value is c, but it doesn't really even achieve
+avalanche in c.
+
+This allows some parallelism.  Read-after-writes are good at doubling
+the number of bits affected, so the goal of mixing pulls in the opposite
+direction as the goal of parallelism.  I did what I could.  Rotates
+seem to cost as much as shifts on every machine I could lay my hands
+on, and rotates are much kinder to the top and bottom bits, so I used
+rotates.
+-------------------------------------------------------------------------------
+*/
+#define mix(a, b, c) \
+  {                  \
+    a -= c;          \
+    a ^= rot(c, 4);  \
+    c += b;          \
+    b -= a;          \
+    b ^= rot(a, 6);  \
+    a += c;          \
+    c -= b;          \
+    c ^= rot(b, 8);  \
+    b += a;          \
+    a -= c;          \
+    a ^= rot(c, 16); \
+    c += b;          \
+    b -= a;          \
+    b ^= rot(a, 19); \
+    a += c;          \
+    c -= b;          \
+    c ^= rot(b, 4);  \
+    b += a;          \
+  }
+
+/*
+-------------------------------------------------------------------------------
+final -- final mixing of 3 32-bit values (a,b,c) into c
+
+Pairs of (a,b,c) values differing in only a few bits will usually
+produce values of c that look totally different.  This was tested for
+* pairs that differed by one bit, by two bits, in any combination
+  of top bits of (a,b,c), or in any combination of bottom bits of
+  (a,b,c).
+* "differ" is defined as +, -, ^, or ~^.  For + and -, I transformed
+  the output delta to a Gray code (a^(a>>1)) so a string of 1's (as
+  is commonly produced by subtraction) look like a single 1-bit
+  difference.
+* the base values were pseudorandom, all zero but one bit set, or
+  all zero plus a counter that starts at zero.
+
+These constants passed:
+ 14 11 25 16 4 14 24
+ 12 14 25 16 4 14 24
+and these came close:
+  4  8 15 26 3 22 24
+ 10  8 15 26 3 22 24
+ 11  8 15 26 3 22 24
+-------------------------------------------------------------------------------
+*/
+#define final(a, b, c) \
+  {                    \
+    c ^= b;            \
+    c -= rot(b, 14);   \
+    a ^= c;            \
+    a -= rot(c, 11);   \
+    b ^= a;            \
+    b -= rot(a, 25);   \
+    c ^= b;            \
+    c -= rot(b, 16);   \
+    a ^= c;            \
+    a -= rot(c, 4);    \
+    b ^= a;            \
+    b -= rot(a, 14);   \
+    c ^= b;            \
+    c -= rot(b, 24);   \
+  }
+
+/*
+--------------------------------------------------------------------
+ This works on all machines.  To be useful, it requires
+ -- that the key be an array of uint32_t's, and
+ -- that the length be the number of uint32_t's in the key
+
+ The function hashword() is identical to hashlittle() on little-endian
+ machines, and identical to hashbig() on big-endian machines,
+ except that the length has to be measured in uint32_ts rather than in
+ bytes.  hashlittle() is more complicated than hashword() only because
+ hashlittle() has to dance around fitting the key bytes into registers.
+--------------------------------------------------------------------
+*/
+uint32_t hashword(
+    const uint32_t *k, /* the key, an array of uint32_t values */
+    size_t length,     /* the length of the key, in uint32_ts */
+    uint32_t initval)  /* the previous hash, or an arbitrary value */
+{
+  uint32_t a, b, c;
+
+  /* Set up the internal state */
+  a = b = c = 0xdeadbeef + (((uint32_t)length) << 2) + initval;
+
+  /*------------------------------------------------- handle most of the key */
+  while (length > 3)
+  {
+    a += k[0];
+    b += k[1];
+    c += k[2];
+    mix(a, b, c);
+    length -= 3;
+    k += 3;
+  }
+
+  /*------------------------------------------- handle the last 3 uint32_t's */
+  switch (length) /* all the case statements fall through */
+  {
+  case 3:
+    c += k[2];
+  case 2:
+    b += k[1];
+  case 1:
+    a += k[0];
+    final(a, b, c);
+  case 0: /* case 0: nothing left to add */
+    break;
+  }
+  /*------------------------------------------------------ report the result */
+  return c;
+}
+
+/*
+--------------------------------------------------------------------
+hashword2() -- same as hashword(), but take two seeds and return two
+32-bit values.  pc and pb must both be nonnull, and *pc and *pb must
+both be initialized with seeds.  If you pass in (*pb)==0, the output
+(*pc) will be the same as the return value from hashword().
+--------------------------------------------------------------------
+*/
+void hashword2(
+    const uint32_t *k, /* the key, an array of uint32_t values */
+    size_t length,     /* the length of the key, in uint32_ts */
+    uint32_t *pc,      /* IN: seed OUT: primary hash value */
+    uint32_t *pb)      /* IN: more seed OUT: secondary hash value */
+{
+  uint32_t a, b, c;
+
+  /* Set up the internal state */
+  a = b = c = 0xdeadbeef + ((uint32_t)(length << 2)) + *pc;
+  c += *pb;
+
+  /*------------------------------------------------- handle most of the key */
+  while (length > 3)
+  {
+    a += k[0];
+    b += k[1];
+    c += k[2];
+    mix(a, b, c);
+    length -= 3;
+    k += 3;
+  }
+
+  /*------------------------------------------- handle the last 3 uint32_t's */
+  switch (length) /* all the case statements fall through */
+  {
+  case 3:
+    c += k[2];
+  case 2:
+    b += k[1];
+  case 1:
+    a += k[0];
+    final(a, b, c);
+  case 0: /* case 0: nothing left to add */
+    break;
+  }
+  /*------------------------------------------------------ report the result */
+  *pc = c;
+  *pb = b;
+}
+
+/*
+-------------------------------------------------------------------------------
+hashlittle() -- hash a variable-length key into a 32-bit value
+  k       : the key (the unaligned variable-length array of bytes)
+  length  : the length of the key, counting by bytes
+  initval : can be any 4-byte value
+Returns a 32-bit value.  Every bit of the key affects every bit of
+the return value.  Two keys differing by one or two bits will have
+totally different hash values.
+
+The best hash table sizes are powers of 2.  There is no need to do
+mod a prime (mod is sooo slow!).  If you need less than 32 bits,
+use a bitmask.  For example, if you need only 10 bits, do
+  h = (h & hashmask(10));
+In which case, the hash table should have hashsize(10) elements.
+
+If you are hashing n strings (uint8_t **)k, do it like this:
+  for (i=0, h=0; i<n; ++i) h = hashlittle( k[i], len[i], h);
+
+By Bob Jenkins, 2006.  bob_jenkins@burtleburtle.net.  You may use this
+code any way you wish, private, educational, or commercial.  It's free.
+
+Use for hash table lookup, or anything where one collision in 2^^32 is
+acceptable.  Do NOT use for cryptographic purposes.
+-------------------------------------------------------------------------------
+*/
+
+uint32_t hashlittle(const void *key, size_t length, uint32_t initval)
+{
+  uint32_t a, b, c; /* internal state */
+  union
+  {
+    const void *ptr;
+    size_t i;
+  } u; /* needed for Mac Powerbook G4 */
+
+  /* Set up the internal state */
+  a = b = c = 0xdeadbeef + ((uint32_t)length) + initval;
+
+  u.ptr = key;
+  if (HASH_LITTLE_ENDIAN && ((u.i & 0x3) == 0))
+  {
+    const uint32_t *k = (const uint32_t *)key; /* read 32-bit chunks */
+
+    /*------ all but last block: aligned reads and affect 32 bits of (a,b,c) */
+    while (length > 12)
+    {
+      a += k[0];
+      b += k[1];
+      c += k[2];
+      mix(a, b, c);
+      length -= 12;
+      k += 3;
+    }
+
+    /*----------------------------- handle the last (probably partial) block */
+    /*
+     * "k[2]&0xffffff" actually reads beyond the end of the string, but
+     * then masks off the part it's not allowed to read.  Because the
+     * string is aligned, the masked-off tail is in the same word as the
+     * rest of the string.  Every machine with memory protection I've seen
+     * does it on word boundaries, so is OK with this.  But VALGRIND will
+     * still catch it and complain.  The masking trick does make the hash
+     * noticably faster for short strings (like English words).
+     */
+#ifndef VALGRIND
+
+    switch (length)
+    {
+    case 12:
+      c += k[2];
+      b += k[1];
+      a += k[0];
+      break;
+    case 11:
+      c += k[2] & 0xffffff;
+      b += k[1];
+      a += k[0];
+      break;
+    case 10:
+      c += k[2] & 0xffff;
+      b += k[1];
+      a += k[0];
+      break;
+    case 9:
+      c += k[2] & 0xff;
+      b += k[1];
+      a += k[0];
+      break;
+    case 8:
+      b += k[1];
+      a += k[0];
+      break;
+    case 7:
+      b += k[1] & 0xffffff;
+      a += k[0];
+      break;
+    case 6:
+      b += k[1] & 0xffff;
+      a += k[0];
+      break;
+    case 5:
+      b += k[1] & 0xff;
+      a += k[0];
+      break;
+    case 4:
+      a += k[0];
+      break;
+    case 3:
+      a += k[0] & 0xffffff;
+      break;
+    case 2:
+      a += k[0] & 0xffff;
+      break;
+    case 1:
+      a += k[0] & 0xff;
+      break;
+    case 0:
+      return c; /* zero length strings require no mixing */
+    }
+
+#else /* make valgrind happy */
+
+    k8 = (const uint8_t *)k;
+    switch (length)
+    {
+    case 12:
+      c += k[2];
+      b += k[1];
+      a += k[0];
+      break;
+    case 11:
+      c += ((uint32_t)k8[10]) << 16; /* fall through */
+    case 10:
+      c += ((uint32_t)k8[9]) << 8; /* fall through */
+    case 9:
+      c += k8[8]; /* fall through */
+    case 8:
+      b += k[1];
+      a += k[0];
+      break;
+    case 7:
+      b += ((uint32_t)k8[6]) << 16; /* fall through */
+    case 6:
+      b += ((uint32_t)k8[5]) << 8; /* fall through */
+    case 5:
+      b += k8[4]; /* fall through */
+    case 4:
+      a += k[0];
+      break;
+    case 3:
+      a += ((uint32_t)k8[2]) << 16; /* fall through */
+    case 2:
+      a += ((uint32_t)k8[1]) << 8; /* fall through */
+    case 1:
+      a += k8[0];
+      break;
+    case 0:
+      return c;
+    }
+
+#endif /* !valgrind */
+  }
+  else if (HASH_LITTLE_ENDIAN && ((u.i & 0x1) == 0))
+  {
+    const uint16_t *k = (const uint16_t *)key; /* read 16-bit chunks */
+    const uint8_t *k8;
+
+    /*--------------- all but last block: aligned reads and different mixing */
+    while (length > 12)
+    {
+      a += k[0] + (((uint32_t)k[1]) << 16);
+      b += k[2] + (((uint32_t)k[3]) << 16);
+      c += k[4] + (((uint32_t)k[5]) << 16);
+      mix(a, b, c);
+      length -= 12;
+      k += 6;
+    }
+
+    /*----------------------------- handle the last (probably partial) block */
+    k8 = (const uint8_t *)k;
+    switch (length)
+    {
+    case 12:
+      c += k[4] + (((uint32_t)k[5]) << 16);
+      b += k[2] + (((uint32_t)k[3]) << 16);
+      a += k[0] + (((uint32_t)k[1]) << 16);
+      break;
+    case 11:
+      c += ((uint32_t)k8[10]) << 16; /* fall through */
+    case 10:
+      c += k[4];
+      b += k[2] + (((uint32_t)k[3]) << 16);
+      a += k[0] + (((uint32_t)k[1]) << 16);
+      break;
+    case 9:
+      c += k8[8]; /* fall through */
+    case 8:
+      b += k[2] + (((uint32_t)k[3]) << 16);
+      a += k[0] + (((uint32_t)k[1]) << 16);
+      break;
+    case 7:
+      b += ((uint32_t)k8[6]) << 16; /* fall through */
+    case 6:
+      b += k[2];
+      a += k[0] + (((uint32_t)k[1]) << 16);
+      break;
+    case 5:
+      b += k8[4]; /* fall through */
+    case 4:
+      a += k[0] + (((uint32_t)k[1]) << 16);
+      break;
+    case 3:
+      a += ((uint32_t)k8[2]) << 16; /* fall through */
+    case 2:
+      a += k[0];
+      break;
+    case 1:
+      a += k8[0];
+      break;
+    case 0:
+      return c; /* zero length requires no mixing */
+    }
+  }
+  else
+  { /* need to read the key one byte at a time */
+    const uint8_t *k = (const uint8_t *)key;
+
+    /*--------------- all but the last block: affect some 32 bits of (a,b,c) */
+    while (length > 12)
+    {
+      a += k[0];
+      a += ((uint32_t)k[1]) << 8;
+      a += ((uint32_t)k[2]) << 16;
+      a += ((uint32_t)k[3]) << 24;
+      b += k[4];
+      b += ((uint32_t)k[5]) << 8;
+      b += ((uint32_t)k[6]) << 16;
+      b += ((uint32_t)k[7]) << 24;
+      c += k[8];
+      c += ((uint32_t)k[9]) << 8;
+      c += ((uint32_t)k[10]) << 16;
+      c += ((uint32_t)k[11]) << 24;
+      mix(a, b, c);
+      length -= 12;
+      k += 12;
+    }
+
+    /*-------------------------------- last block: affect all 32 bits of (c) */
+    switch (length) /* all the case statements fall through */
+    {
+    case 12:
+      c += ((uint32_t)k[11]) << 24;
+    case 11:
+      c += ((uint32_t)k[10]) << 16;
+    case 10:
+      c += ((uint32_t)k[9]) << 8;
+    case 9:
+      c += k[8];
+    case 8:
+      b += ((uint32_t)k[7]) << 24;
+    case 7:
+      b += ((uint32_t)k[6]) << 16;
+    case 6:
+      b += ((uint32_t)k[5]) << 8;
+    case 5:
+      b += k[4];
+    case 4:
+      a += ((uint32_t)k[3]) << 24;
+    case 3:
+      a += ((uint32_t)k[2]) << 16;
+    case 2:
+      a += ((uint32_t)k[1]) << 8;
+    case 1:
+      a += k[0];
+      break;
+    case 0:
+      return c;
+    }
+  }
+
+  final(a, b, c);
+  return c;
+}
+
+/*
+ * hashlittle2: return 2 32-bit hash values
+ *
+ * This is identical to hashlittle(), except it returns two 32-bit hash
+ * values instead of just one.  This is good enough for hash table
+ * lookup with 2^^64 buckets, or if you want a second hash if you're not
+ * happy with the first, or if you want a probably-unique 64-bit ID for
+ * the key.  *pc is better mixed than *pb, so use *pc first.  If you want
+ * a 64-bit value do something like "*pc + (((uint64_t)*pb)<<32)".
+ */
+void hashlittle2(
+    const void *key, /* the key to hash */
+    size_t length,   /* length of the key */
+    uint32_t *pc,    /* IN: primary initval, OUT: primary hash */
+    uint32_t *pb)    /* IN: secondary initval, OUT: secondary hash */
+{
+  uint32_t a, b, c; /* internal state */
+  union
+  {
+    const void *ptr;
+    size_t i;
+  } u; /* needed for Mac Powerbook G4 */
+
+  /* Set up the internal state */
+  a = b = c = 0xdeadbeef + ((uint32_t)length) + *pc;
+  c += *pb;
+
+  u.ptr = key;
+  if (HASH_LITTLE_ENDIAN && ((u.i & 0x3) == 0))
+  {
+    const uint32_t *k = (const uint32_t *)key; /* read 32-bit chunks */
+
+    /*------ all but last block: aligned reads and affect 32 bits of (a,b,c) */
+    while (length > 12)
+    {
+      a += k[0];
+      b += k[1];
+      c += k[2];
+      mix(a, b, c);
+      length -= 12;
+      k += 3;
+    }
+
+    /*----------------------------- handle the last (probably partial) block */
+    /*
+     * "k[2]&0xffffff" actually reads beyond the end of the string, but
+     * then masks off the part it's not allowed to read.  Because the
+     * string is aligned, the masked-off tail is in the same word as the
+     * rest of the string.  Every machine with memory protection I've seen
+     * does it on word boundaries, so is OK with this.  But VALGRIND will
+     * still catch it and complain.  The masking trick does make the hash
+     * noticably faster for short strings (like English words).
+     */
+#ifndef VALGRIND
+
+    switch (length)
+    {
+    case 12:
+      c += k[2];
+      b += k[1];
+      a += k[0];
+      break;
+    case 11:
+      c += k[2] & 0xffffff;
+      b += k[1];
+      a += k[0];
+      break;
+    case 10:
+      c += k[2] & 0xffff;
+      b += k[1];
+      a += k[0];
+      break;
+    case 9:
+      c += k[2] & 0xff;
+      b += k[1];
+      a += k[0];
+      break;
+    case 8:
+      b += k[1];
+      a += k[0];
+      break;
+    case 7:
+      b += k[1] & 0xffffff;
+      a += k[0];
+      break;
+    case 6:
+      b += k[1] & 0xffff;
+      a += k[0];
+      break;
+    case 5:
+      b += k[1] & 0xff;
+      a += k[0];
+      break;
+    case 4:
+      a += k[0];
+      break;
+    case 3:
+      a += k[0] & 0xffffff;
+      break;
+    case 2:
+      a += k[0] & 0xffff;
+      break;
+    case 1:
+      a += k[0] & 0xff;
+      break;
+    case 0:
+      *pc = c;
+      *pb = b;
+      return; /* zero length strings require no mixing */
+    }
+
+#else /* make valgrind happy */
+
+    k8 = (const uint8_t *)k;
+    switch (length)
+    {
+    case 12:
+      c += k[2];
+      b += k[1];
+      a += k[0];
+      break;
+    case 11:
+      c += ((uint32_t)k8[10]) << 16; /* fall through */
+    case 10:
+      c += ((uint32_t)k8[9]) << 8; /* fall through */
+    case 9:
+      c += k8[8]; /* fall through */
+    case 8:
+      b += k[1];
+      a += k[0];
+      break;
+    case 7:
+      b += ((uint32_t)k8[6]) << 16; /* fall through */
+    case 6:
+      b += ((uint32_t)k8[5]) << 8; /* fall through */
+    case 5:
+      b += k8[4]; /* fall through */
+    case 4:
+      a += k[0];
+      break;
+    case 3:
+      a += ((uint32_t)k8[2]) << 16; /* fall through */
+    case 2:
+      a += ((uint32_t)k8[1]) << 8; /* fall through */
+    case 1:
+      a += k8[0];
+      break;
+    case 0:
+      *pc = c;
+      *pb = b;
+      return; /* zero length strings require no mixing */
+    }
+
+#endif /* !valgrind */
+  }
+  else if (HASH_LITTLE_ENDIAN && ((u.i & 0x1) == 0))
+  {
+    const uint16_t *k = (const uint16_t *)key; /* read 16-bit chunks */
+    const uint8_t *k8;
+
+    /*--------------- all but last block: aligned reads and different mixing */
+    while (length > 12)
+    {
+      a += k[0] + (((uint32_t)k[1]) << 16);
+      b += k[2] + (((uint32_t)k[3]) << 16);
+      c += k[4] + (((uint32_t)k[5]) << 16);
+      mix(a, b, c);
+      length -= 12;
+      k += 6;
+    }
+
+    /*----------------------------- handle the last (probably partial) block */
+    k8 = (const uint8_t *)k;
+    switch (length)
+    {
+    case 12:
+      c += k[4] + (((uint32_t)k[5]) << 16);
+      b += k[2] + (((uint32_t)k[3]) << 16);
+      a += k[0] + (((uint32_t)k[1]) << 16);
+      break;
+    case 11:
+      c += ((uint32_t)k8[10]) << 16; /* fall through */
+    case 10:
+      c += k[4];
+      b += k[2] + (((uint32_t)k[3]) << 16);
+      a += k[0] + (((uint32_t)k[1]) << 16);
+      break;
+    case 9:
+      c += k8[8]; /* fall through */
+    case 8:
+      b += k[2] + (((uint32_t)k[3]) << 16);
+      a += k[0] + (((uint32_t)k[1]) << 16);
+      break;
+    case 7:
+      b += ((uint32_t)k8[6]) << 16; /* fall through */
+    case 6:
+      b += k[2];
+      a += k[0] + (((uint32_t)k[1]) << 16);
+      break;
+    case 5:
+      b += k8[4]; /* fall through */
+    case 4:
+      a += k[0] + (((uint32_t)k[1]) << 16);
+      break;
+    case 3:
+      a += ((uint32_t)k8[2]) << 16; /* fall through */
+    case 2:
+      a += k[0];
+      break;
+    case 1:
+      a += k8[0];
+      break;
+    case 0:
+      *pc = c;
+      *pb = b;
+      return; /* zero length strings require no mixing */
+    }
+  }
+  else
+  { /* need to read the key one byte at a time */
+    const uint8_t *k = (const uint8_t *)key;
+
+    /*--------------- all but the last block: affect some 32 bits of (a,b,c) */
+    while (length > 12)
+    {
+      a += k[0];
+      a += ((uint32_t)k[1]) << 8;
+      a += ((uint32_t)k[2]) << 16;
+      a += ((uint32_t)k[3]) << 24;
+      b += k[4];
+      b += ((uint32_t)k[5]) << 8;
+      b += ((uint32_t)k[6]) << 16;
+      b += ((uint32_t)k[7]) << 24;
+      c += k[8];
+      c += ((uint32_t)k[9]) << 8;
+      c += ((uint32_t)k[10]) << 16;
+      c += ((uint32_t)k[11]) << 24;
+      mix(a, b, c);
+      length -= 12;
+      k += 12;
+    }
+
+    /*-------------------------------- last block: affect all 32 bits of (c) */
+    switch (length) /* all the case statements fall through */
+    {
+    case 12:
+      c += ((uint32_t)k[11]) << 24;
+    case 11:
+      c += ((uint32_t)k[10]) << 16;
+    case 10:
+      c += ((uint32_t)k[9]) << 8;
+    case 9:
+      c += k[8];
+    case 8:
+      b += ((uint32_t)k[7]) << 24;
+    case 7:
+      b += ((uint32_t)k[6]) << 16;
+    case 6:
+      b += ((uint32_t)k[5]) << 8;
+    case 5:
+      b += k[4];
+    case 4:
+      a += ((uint32_t)k[3]) << 24;
+    case 3:
+      a += ((uint32_t)k[2]) << 16;
+    case 2:
+      a += ((uint32_t)k[1]) << 8;
+    case 1:
+      a += k[0];
+      break;
+    case 0:
+      *pc = c;
+      *pb = b;
+      return; /* zero length strings require no mixing */
+    }
+  }
+
+  final(a, b, c);
+  *pc = c;
+  *pb = b;
+}
+
+/*
+ * hashbig():
+ * This is the same as hashword() on big-endian machines.  It is different
+ * from hashlittle() on all machines.  hashbig() takes advantage of
+ * big-endian byte ordering.
+ */
+uint32_t hashbig(const void *key, size_t length, uint32_t initval)
+{
+  uint32_t a, b, c;
+  union
+  {
+    const void *ptr;
+    size_t i;
+  } u; /* to cast key to (size_t) happily */
+
+  /* Set up the internal state */
+  a = b = c = 0xdeadbeef + ((uint32_t)length) + initval;
+
+  u.ptr = key;
+  if (HASH_BIG_ENDIAN && ((u.i & 0x3) == 0))
+  {
+    const uint32_t *k = (const uint32_t *)key; /* read 32-bit chunks */
+
+    /*------ all but last block: aligned reads and affect 32 bits of (a,b,c) */
+    while (length > 12)
+    {
+      a += k[0];
+      b += k[1];
+      c += k[2];
+      mix(a, b, c);
+      length -= 12;
+      k += 3;
+    }
+
+    /*----------------------------- handle the last (probably partial) block */
+    /*
+     * "k[2]<<8" actually reads beyond the end of the string, but
+     * then shifts out the part it's not allowed to read.  Because the
+     * string is aligned, the illegal read is in the same word as the
+     * rest of the string.  Every machine with memory protection I've seen
+     * does it on word boundaries, so is OK with this.  But VALGRIND will
+     * still catch it and complain.  The masking trick does make the hash
+     * noticably faster for short strings (like English words).
+     */
+#ifndef VALGRIND
+
+    switch (length)
+    {
+    case 12:
+      c += k[2];
+      b += k[1];
+      a += k[0];
+      break;
+    case 11:
+      c += k[2] & 0xffffff00;
+      b += k[1];
+      a += k[0];
+      break;
+    case 10:
+      c += k[2] & 0xffff0000;
+      b += k[1];
+      a += k[0];
+      break;
+    case 9:
+      c += k[2] & 0xff000000;
+      b += k[1];
+      a += k[0];
+      break;
+    case 8:
+      b += k[1];
+      a += k[0];
+      break;
+    case 7:
+      b += k[1] & 0xffffff00;
+      a += k[0];
+      break;
+    case 6:
+      b += k[1] & 0xffff0000;
+      a += k[0];
+      break;
+    case 5:
+      b += k[1] & 0xff000000;
+      a += k[0];
+      break;
+    case 4:
+      a += k[0];
+      break;
+    case 3:
+      a += k[0] & 0xffffff00;
+      break;
+    case 2:
+      a += k[0] & 0xffff0000;
+      break;
+    case 1:
+      a += k[0] & 0xff000000;
+      break;
+    case 0:
+      return c; /* zero length strings require no mixing */
+    }
+
+#else /* make valgrind happy */
+
+    k8 = (const uint8_t *)k;
+    switch (length) /* all the case statements fall through */
+    {
+    case 12:
+      c += k[2];
+      b += k[1];
+      a += k[0];
+      break;
+    case 11:
+      c += ((uint32_t)k8[10]) << 8; /* fall through */
+    case 10:
+      c += ((uint32_t)k8[9]) << 16; /* fall through */
+    case 9:
+      c += ((uint32_t)k8[8]) << 24; /* fall through */
+    case 8:
+      b += k[1];
+      a += k[0];
+      break;
+    case 7:
+      b += ((uint32_t)k8[6]) << 8; /* fall through */
+    case 6:
+      b += ((uint32_t)k8[5]) << 16; /* fall through */
+    case 5:
+      b += ((uint32_t)k8[4]) << 24; /* fall through */
+    case 4:
+      a += k[0];
+      break;
+    case 3:
+      a += ((uint32_t)k8[2]) << 8; /* fall through */
+    case 2:
+      a += ((uint32_t)k8[1]) << 16; /* fall through */
+    case 1:
+      a += ((uint32_t)k8[0]) << 24;
+      break;
+    case 0:
+      return c;
+    }
+
+#endif /* !VALGRIND */
+  }
+  else
+  { /* need to read the key one byte at a time */
+    const uint8_t *k = (const uint8_t *)key;
+
+    /*--------------- all but the last block: affect some 32 bits of (a,b,c) */
+    while (length > 12)
+    {
+      a += ((uint32_t)k[0]) << 24;
+      a += ((uint32_t)k[1]) << 16;
+      a += ((uint32_t)k[2]) << 8;
+      a += ((uint32_t)k[3]);
+      b += ((uint32_t)k[4]) << 24;
+      b += ((uint32_t)k[5]) << 16;
+      b += ((uint32_t)k[6]) << 8;
+      b += ((uint32_t)k[7]);
+      c += ((uint32_t)k[8]) << 24;
+      c += ((uint32_t)k[9]) << 16;
+      c += ((uint32_t)k[10]) << 8;
+      c += ((uint32_t)k[11]);
+      mix(a, b, c);
+      length -= 12;
+      k += 12;
+    }
+
+    /*-------------------------------- last block: affect all 32 bits of (c) */
+    switch (length) /* all the case statements fall through */
+    {
+    case 12:
+      c += k[11];
+    case 11:
+      c += ((uint32_t)k[10]) << 8;
+    case 10:
+      c += ((uint32_t)k[9]) << 16;
+    case 9:
+      c += ((uint32_t)k[8]) << 24;
+    case 8:
+      b += k[7];
+    case 7:
+      b += ((uint32_t)k[6]) << 8;
+    case 6:
+      b += ((uint32_t)k[5]) << 16;
+    case 5:
+      b += ((uint32_t)k[4]) << 24;
+    case 4:
+      a += k[3];
+    case 3:
+      a += ((uint32_t)k[2]) << 8;
+    case 2:
+      a += ((uint32_t)k[1]) << 16;
+    case 1:
+      a += ((uint32_t)k[0]) << 24;
+      break;
+    case 0:
+      return c;
+    }
+  }
+
+  final(a, b, c);
+  return c;
+}
+
+#ifdef SELF_TEST
+
+/* used for timings */
+void driver1()
+{
+  uint8_t buf[256];
+  uint32_t i;
+  uint32_t h = 0;
+  time_t a, z;
+
+  time(&a);
+  for (i = 0; i < 256; ++i)
+    buf[i] = 'x';
+  for (i = 0; i < 1; ++i)
+  {
+    h = hashlittle(&buf[0], 1, h);
+  }
+  time(&z);
+  if (z - a > 0)
+    printf("time %d %.8x\n", z - a, h);
+}
+
+/* check that every input bit changes every output bit half the time */
+#define HASHSTATE 1
+#define HASHLEN 1
+#define MAXPAIR 60
+#define MAXLEN 70
+void driver2()
+{
+  uint8_t qa[MAXLEN + 1], qb[MAXLEN + 2], *a = &qa[0], *b = &qb[1];
+  uint32_t c[HASHSTATE], d[HASHSTATE], i = 0, j = 0, k, l, m = 0, z;
+  uint32_t e[HASHSTATE], f[HASHSTATE], g[HASHSTATE], h[HASHSTATE];
+  uint32_t x[HASHSTATE], y[HASHSTATE];
+  uint32_t hlen;
+
+  printf("No more than %d trials should ever be needed \n", MAXPAIR / 2);
+  for (hlen = 0; hlen < MAXLEN; ++hlen)
+  {
+    z = 0;
+    for (i = 0; i < hlen; ++i) /*----------------------- for each input byte, */
+    {
+      for (j = 0; j < 8; ++j) /*------------------------ for each input bit, */
+      {
+        for (m = 1; m < 8; ++m) /*------------ for serveral possible initvals, */
+        {
+          for (l = 0; l < HASHSTATE; ++l)
+            e[l] = f[l] = g[l] = h[l] = x[l] = y[l] = ~((uint32_t)0);
+
+          /*---- check that every output bit is affected by that input bit */
+          for (k = 0; k < MAXPAIR; k += 2)
+          {
+            uint32_t finished = 1;
+            /* keys have one bit different */
+            for (l = 0; l < hlen + 1; ++l)
+            {
+              a[l] = b[l] = (uint8_t)0;
+            }
+            /* have a and b be two keys differing in only one bit */
+            a[i] ^= (k << j);
+            a[i] ^= (k >> (8 - j));
+            c[0] = hashlittle(a, hlen, m);
+            b[i] ^= ((k + 1) << j);
+            b[i] ^= ((k + 1) >> (8 - j));
+            d[0] = hashlittle(b, hlen, m);
+            /* check every bit is 1, 0, set, and not set at least once */
+            for (l = 0; l < HASHSTATE; ++l)
+            {
+              e[l] &= (c[l] ^ d[l]);
+              f[l] &= ~(c[l] ^ d[l]);
+              g[l] &= c[l];
+              h[l] &= ~c[l];
+              x[l] &= d[l];
+              y[l] &= ~d[l];
+              if (e[l] | f[l] | g[l] | h[l] | x[l] | y[l])
+                finished = 0;
+            }
+            if (finished)
+              break;
+          }
+          if (k > z)
+            z = k;
+          if (k == MAXPAIR)
+          {
+            printf("Some bit didn't change: ");
+            printf("%.8x %.8x %.8x %.8x %.8x %.8x  ",
+                   e[0], f[0], g[0], h[0], x[0], y[0]);
+            printf("i %d j %d m %d len %d\n", i, j, m, hlen);
+          }
+          if (z == MAXPAIR)
+            goto done;
+        }
+      }
+    }
+  done:
+    if (z < MAXPAIR)
+    {
+      printf("Mix success  %2d bytes  %2d initvals  ", i, m);
+      printf("required  %d  trials\n", z / 2);
+    }
+  }
+  printf("\n");
+}
+
+/* Check for reading beyond the end of the buffer and alignment problems */
+void driver3()
+{
+  uint8_t buf[MAXLEN + 20], *b;
+  uint32_t len;
+  uint8_t q[] = "This is the time for all good men to come to the aid of their country...";
+  uint32_t h;
+  uint8_t qq[] = "xThis is the time for all good men to come to the aid of their country...";
+  uint32_t i;
+  uint8_t qqq[] = "xxThis is the time for all good men to come to the aid of their country...";
+  uint32_t j;
+  uint8_t qqqq[] = "xxxThis is the time for all good men to come to the aid of their country...";
+  uint32_t ref, x, y;
+  uint8_t *p;
+
+  printf("Endianness.  These lines should all be the same (for values filled in):\n");
+  printf("%.8x                            %.8x                            %.8x\n",
+         hashword((const uint32_t *)q, (sizeof(q) - 1) / 4, 13),
+         hashword((const uint32_t *)q, (sizeof(q) - 5) / 4, 13),
+         hashword((const uint32_t *)q, (sizeof(q) - 9) / 4, 13));
+  p = q;
+  printf("%.8x %.8x %.8x %.8x %.8x %.8x %.8x %.8x %.8x %.8x %.8x %.8x\n",
+         hashlittle(p, sizeof(q) - 1, 13), hashlittle(p, sizeof(q) - 2, 13),
+         hashlittle(p, sizeof(q) - 3, 13), hashlittle(p, sizeof(q) - 4, 13),
+         hashlittle(p, sizeof(q) - 5, 13), hashlittle(p, sizeof(q) - 6, 13),
+         hashlittle(p, sizeof(q) - 7, 13), hashlittle(p, sizeof(q) - 8, 13),
+         hashlittle(p, sizeof(q) - 9, 13), hashlittle(p, sizeof(q) - 10, 13),
+         hashlittle(p, sizeof(q) - 11, 13), hashlittle(p, sizeof(q) - 12, 13));
+  p = &qq[1];
+  printf("%.8x %.8x %.8x %.8x %.8x %.8x %.8x %.8x %.8x %.8x %.8x %.8x\n",
+         hashlittle(p, sizeof(q) - 1, 13), hashlittle(p, sizeof(q) - 2, 13),
+         hashlittle(p, sizeof(q) - 3, 13), hashlittle(p, sizeof(q) - 4, 13),
+         hashlittle(p, sizeof(q) - 5, 13), hashlittle(p, sizeof(q) - 6, 13),
+         hashlittle(p, sizeof(q) - 7, 13), hashlittle(p, sizeof(q) - 8, 13),
+         hashlittle(p, sizeof(q) - 9, 13), hashlittle(p, sizeof(q) - 10, 13),
+         hashlittle(p, sizeof(q) - 11, 13), hashlittle(p, sizeof(q) - 12, 13));
+  p = &qqq[2];
+  printf("%.8x %.8x %.8x %.8x %.8x %.8x %.8x %.8x %.8x %.8x %.8x %.8x\n",
+         hashlittle(p, sizeof(q) - 1, 13), hashlittle(p, sizeof(q) - 2, 13),
+         hashlittle(p, sizeof(q) - 3, 13), hashlittle(p, sizeof(q) - 4, 13),
+         hashlittle(p, sizeof(q) - 5, 13), hashlittle(p, sizeof(q) - 6, 13),
+         hashlittle(p, sizeof(q) - 7, 13), hashlittle(p, sizeof(q) - 8, 13),
+         hashlittle(p, sizeof(q) - 9, 13), hashlittle(p, sizeof(q) - 10, 13),
+         hashlittle(p, sizeof(q) - 11, 13), hashlittle(p, sizeof(q) - 12, 13));
+  p = &qqqq[3];
+  printf("%.8x %.8x %.8x %.8x %.8x %.8x %.8x %.8x %.8x %.8x %.8x %.8x\n",
+         hashlittle(p, sizeof(q) - 1, 13), hashlittle(p, sizeof(q) - 2, 13),
+         hashlittle(p, sizeof(q) - 3, 13), hashlittle(p, sizeof(q) - 4, 13),
+         hashlittle(p, sizeof(q) - 5, 13), hashlittle(p, sizeof(q) - 6, 13),
+         hashlittle(p, sizeof(q) - 7, 13), hashlittle(p, sizeof(q) - 8, 13),
+         hashlittle(p, sizeof(q) - 9, 13), hashlittle(p, sizeof(q) - 10, 13),
+         hashlittle(p, sizeof(q) - 11, 13), hashlittle(p, sizeof(q) - 12, 13));
+  printf("\n");
+
+  /* check that hashlittle2 and hashlittle produce the same results */
+  i = 47;
+  j = 0;
+  hashlittle2(q, sizeof(q), &i, &j);
+  if (hashlittle(q, sizeof(q), 47) != i)
+    printf("hashlittle2 and hashlittle mismatch\n");
+
+  /* check that hashword2 and hashword produce the same results */
+  len = 0xdeadbeef;
+  i = 47, j = 0;
+  hashword2(&len, 1, &i, &j);
+  if (hashword(&len, 1, 47) != i)
+    printf("hashword2 and hashword mismatch %x %x\n",
+           i, hashword(&len, 1, 47));
+
+  /* check hashlittle doesn't read before or after the ends of the string */
+  for (h = 0, b = buf + 1; h < 8; ++h, ++b)
+  {
+    for (i = 0; i < MAXLEN; ++i)
+    {
+      len = i;
+      for (j = 0; j < i; ++j)
+        *(b + j) = 0;
+
+      /* these should all be equal */
+      ref = hashlittle(b, len, (uint32_t)1);
+      *(b + i) = (uint8_t)~0;
+      *(b - 1) = (uint8_t)~0;
+      x = hashlittle(b, len, (uint32_t)1);
+      y = hashlittle(b, len, (uint32_t)1);
+      if ((ref != x) || (ref != y))
+      {
+        printf("alignment error: %.8x %.8x %.8x %d %d\n", ref, x, y,
+               h, i);
+      }
+    }
+  }
+}
+
+/* check for problems with nulls */
+void driver4()
+{
+  uint8_t buf[1];
+  uint32_t h, i, state[HASHSTATE];
+
+  buf[0] = ~0;
+  for (i = 0; i < HASHSTATE; ++i)
+    state[i] = 1;
+  printf("These should all be different\n");
+  for (i = 0, h = 0; i < 8; ++i)
+  {
+    h = hashlittle(buf, 0, h);
+    printf("%2ld  0-byte strings, hash is  %.8x\n", i, h);
+  }
+}
+
+int main()
+{
+  driver1(); /* test that the key is hashed: used for timings */
+  driver2(); /* test that whole key is hashed thoroughly */
+  driver3(); /* test that nothing but the key is hashed */
+  driver4(); /* test hashing multiple buffers (all buffers are null) */
+  return 1;
+}
+
+#endif /* SELF_TEST */
```

## chaine/_core/crfsuite/lib/cqdb/src/main.c

 * *Ordering differences only*

```diff
@@ -1,184 +1,184 @@
-/*
- *      Test program for Constant Quark Database (CQDB).
- *
- * Copyright (c) 2007, Naoaki Okazaki
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of the Northwestern University, University of Tokyo,
- *       nor the names of its contributors may be used to endorse or promote
- *       products derived from this software without specific prior written
- *       permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
- * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-/* $Id$ */
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include "cqdb.h"
-
-//#define    TEST_WRITE    1
-#define CHECK_VALIDITY
-
-#define DBNAME "test.cqdb"
-#define NUMELEMS 1000000
-
-#ifdef TEST_WRITE
-
-int main(int argc, char *argv[])
-{
-    int i, ret;
-    char str[10];
-    FILE *fp = NULL;
-    cqdb_writer_t *dbw = NULL;
-
-    // Open a file for writing.
-    fp = fopen(DBNAME, "wb");
-    if (fp == NULL)
-    {
-        fprintf(stderr, "ERROR: failed to open the file.\n");
-        return 1;
-    }
-
-    // Create a CQDB on the file stream.
-    dbw = cqdb_writer(fp, 0);
-    if (dbw == NULL)
-    {
-        fprintf(stderr, "ERROR: failed to create a CQDB on the file.\n");
-        goto error_exit;
-    }
-
-    // Put string/integer associations, "00000001"/1, ..., "01000000"/1000000.
-    for (i = 0; i < NUMELEMS; ++i)
-    {
-        sprintf(str, "%08d", i);
-        if (ret = cqdb_writer_put(dbw, str, i))
-        {
-            fprintf(stderr, "ERROR: failed to put a pair '%s'/%d.\n", str, i);
-            goto error_exit;
-        }
-    }
-
-    // Close the CQDB.
-    if (ret = cqdb_writer_close(dbw))
-    {
-        fprintf(stderr, "ERROR: failed to close the CQDB.\n");
-        goto error_exit;
-    }
-
-    // Close the file.
-    fclose(fp);
-    return 0;
-
-error_exit:
-    if (dbw != NULL)
-        cqdb_writer_close(dbw);
-    if (fp != NULL)
-        fclose(fp);
-    return 1;
-}
-
-#else /*TEST_WRITE*/
-
-int main(int argc, char *argv[])
-{
-    int i, j, ret;
-    long size = 0;
-    const char *value = NULL;
-    char str[10], *buffer = NULL;
-    FILE *fp = NULL;
-    cqdb_t *db = NULL;
-
-    // Open the database.
-    fp = fopen(DBNAME, "rb");
-    if (fp == NULL)
-    {
-        fprintf(stderr, "ERROR: failed to open the file\n");
-        return 1;
-    }
-
-    // Obtain the file size at one time.
-    fseek(fp, 0, SEEK_END);
-    size = ftell(fp);
-    fseek(fp, 0, SEEK_SET);
-
-    // Read the content of the file.
-    buffer = (char *)malloc(size);
-    if (buffer == NULL)
-    {
-        fprintf(stderr, "ERROR: out of memory.\n");
-        goto error_exit;
-    }
-    fread(buffer, 1, size, fp);
-    fclose(fp);
-    fp = NULL;
-
-    // Open the database on the memory.
-    db = cqdb_reader(buffer, size);
-    if (db == NULL)
-    {
-        fprintf(stderr, "ERROR: failed to open a CQDB on the file.\n");
-        goto error_exit;
-    }
-
-    // Forward lookups: strings to integer identifiers.
-    for (i = 0; i < NUMELEMS; ++i)
-    {
-        sprintf(str, "%08d", i);
-        j = cqdb_to_id(db, str);
-#ifdef CHECK_VALIDITY
-        if (i != j)
-        {
-            fprintf(stderr, "ERROR: inconsistency error '%s'/%d.\n", str, i);
-            goto error_exit;
-        }
-#endif /*CHECK_VALIDITY*/
-    }
-
-    // Backward lookups: integer identifiers to strings.
-    for (i = 0; i < NUMELEMS; ++i)
-    {
-        sprintf(str, "%08d", i);
-        value = cqdb_to_string(db, i);
-#ifdef CHECK_VALIDITY
-        if (strcmp(str, value) != 0)
-        {
-            fprintf(stderr, "ERROR: inconsistency error '%s'/%d.\n", str, i);
-            goto error_exit;
-        }
-#endif /*CHECK_VALIDITY*/
-    }
-
-    cqdb_delete(db);
-    free(buffer);
-
-    return 0;
-
-error_exit:
-    if (fp != NULL)
-        fclose(fp);
-    if (buffer != NULL)
-        free(buffer);
-    return 1;
-}
-
-#endif /*TEST_WRITE*/
+/*
+ *      Test program for Constant Quark Database (CQDB).
+ *
+ * Copyright (c) 2007, Naoaki Okazaki
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the Northwestern University, University of Tokyo,
+ *       nor the names of its contributors may be used to endorse or promote
+ *       products derived from this software without specific prior written
+ *       permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+ * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/* $Id$ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include "cqdb.h"
+
+//#define    TEST_WRITE    1
+#define CHECK_VALIDITY
+
+#define DBNAME "test.cqdb"
+#define NUMELEMS 1000000
+
+#ifdef TEST_WRITE
+
+int main(int argc, char *argv[])
+{
+    int i, ret;
+    char str[10];
+    FILE *fp = NULL;
+    cqdb_writer_t *dbw = NULL;
+
+    // Open a file for writing.
+    fp = fopen(DBNAME, "wb");
+    if (fp == NULL)
+    {
+        fprintf(stderr, "ERROR: failed to open the file.\n");
+        return 1;
+    }
+
+    // Create a CQDB on the file stream.
+    dbw = cqdb_writer(fp, 0);
+    if (dbw == NULL)
+    {
+        fprintf(stderr, "ERROR: failed to create a CQDB on the file.\n");
+        goto error_exit;
+    }
+
+    // Put string/integer associations, "00000001"/1, ..., "01000000"/1000000.
+    for (i = 0; i < NUMELEMS; ++i)
+    {
+        sprintf(str, "%08d", i);
+        if (ret = cqdb_writer_put(dbw, str, i))
+        {
+            fprintf(stderr, "ERROR: failed to put a pair '%s'/%d.\n", str, i);
+            goto error_exit;
+        }
+    }
+
+    // Close the CQDB.
+    if (ret = cqdb_writer_close(dbw))
+    {
+        fprintf(stderr, "ERROR: failed to close the CQDB.\n");
+        goto error_exit;
+    }
+
+    // Close the file.
+    fclose(fp);
+    return 0;
+
+error_exit:
+    if (dbw != NULL)
+        cqdb_writer_close(dbw);
+    if (fp != NULL)
+        fclose(fp);
+    return 1;
+}
+
+#else /*TEST_WRITE*/
+
+int main(int argc, char *argv[])
+{
+    int i, j, ret;
+    long size = 0;
+    const char *value = NULL;
+    char str[10], *buffer = NULL;
+    FILE *fp = NULL;
+    cqdb_t *db = NULL;
+
+    // Open the database.
+    fp = fopen(DBNAME, "rb");
+    if (fp == NULL)
+    {
+        fprintf(stderr, "ERROR: failed to open the file\n");
+        return 1;
+    }
+
+    // Obtain the file size at one time.
+    fseek(fp, 0, SEEK_END);
+    size = ftell(fp);
+    fseek(fp, 0, SEEK_SET);
+
+    // Read the content of the file.
+    buffer = (char *)malloc(size);
+    if (buffer == NULL)
+    {
+        fprintf(stderr, "ERROR: out of memory.\n");
+        goto error_exit;
+    }
+    fread(buffer, 1, size, fp);
+    fclose(fp);
+    fp = NULL;
+
+    // Open the database on the memory.
+    db = cqdb_reader(buffer, size);
+    if (db == NULL)
+    {
+        fprintf(stderr, "ERROR: failed to open a CQDB on the file.\n");
+        goto error_exit;
+    }
+
+    // Forward lookups: strings to integer identifiers.
+    for (i = 0; i < NUMELEMS; ++i)
+    {
+        sprintf(str, "%08d", i);
+        j = cqdb_to_id(db, str);
+#ifdef CHECK_VALIDITY
+        if (i != j)
+        {
+            fprintf(stderr, "ERROR: inconsistency error '%s'/%d.\n", str, i);
+            goto error_exit;
+        }
+#endif /*CHECK_VALIDITY*/
+    }
+
+    // Backward lookups: integer identifiers to strings.
+    for (i = 0; i < NUMELEMS; ++i)
+    {
+        sprintf(str, "%08d", i);
+        value = cqdb_to_string(db, i);
+#ifdef CHECK_VALIDITY
+        if (strcmp(str, value) != 0)
+        {
+            fprintf(stderr, "ERROR: inconsistency error '%s'/%d.\n", str, i);
+            goto error_exit;
+        }
+#endif /*CHECK_VALIDITY*/
+    }
+
+    cqdb_delete(db);
+    free(buffer);
+
+    return 0;
+
+error_exit:
+    if (fp != NULL)
+        fclose(fp);
+    if (buffer != NULL)
+        free(buffer);
+    return 1;
+}
+
+#endif /*TEST_WRITE*/
```

## chaine/_core/crfsuite/lib/crf/src/crf1d.h

 * *Ordering differences only*

```diff
@@ -1,354 +1,354 @@
-/*
- *      The 1st-order linear-chain CRF with dyad features (CRF1d).
- *
- * Copyright (c) 2007-2010, Naoaki Okazaki
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the names of the authors nor the names of its contributors
- *       may be used to endorse or promote products derived from this
- *       software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
- * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-/* $Id$ */
-
-#ifndef __CRF1D_H__
-#define __CRF1D_H__
-
-#include <crfsuite.h>
-#include "crfsuite_internal.h"
-
-/**
- * \defgroup crf1d_context.c
- */
-/** @{ */
-
-/**
- * Functionality flags for contexts.
- *  @see    crf1dc_new().
- */
-enum
-{
-    CTXF_BASE = 0x01,
-    CTXF_VITERBI = 0x01,
-    CTXF_MARGINALS = 0x02,
-    CTXF_ALL = 0xFF,
-};
-
-/**
- * Reset flags.
- *  @see    crf1dc_reset().
- */
-enum
-{
-    RF_STATE = 0x01, /**< Reset state scores. */
-    RF_TRANS = 0x02, /**< Reset transition scores. */
-    RF_ALL = 0xFF,   /**< Reset all. */
-};
-
-/**
- * Context structure.
- *  This structure maintains internal data for an instance.
- */
-typedef struct
-{
-    /**
-     * Flag specifying the functionality.
-     */
-    int flag;
-
-    /**
-     * The total number of distinct labels (L).
-     */
-    int num_labels;
-
-    /**
-     * The number of items (T) in the instance.
-     */
-    int num_items;
-
-    /**
-     * The maximum number of labels.
-     */
-    int cap_items;
-
-    /**
-     * Logarithm of the normalization factor for the instance.
-     *  This is equivalent to the total scores of all paths in the lattice.
-     */
-    floatval_t log_norm;
-
-    /**
-     * State scores.
-     *  This is a [T][L] matrix whose element [t][l] presents total score
-     *  of state features associating label #l at #t.
-     */
-    floatval_t *state;
-
-    /**
-     * Transition scores.
-     *  This is a [L][L] matrix whose element [i][j] represents the total
-     *  score of transition features associating labels #i and #j.
-     */
-    floatval_t *trans;
-
-    /**
-     * Alpha score matrix.
-     *  This is a [T][L] matrix whose element [t][l] presents the total
-     *  score of paths starting at BOS and arraiving at (t, l).
-     */
-    floatval_t *alpha_score;
-
-    /**
-     * Beta score matrix.
-     *  This is a [T][L] matrix whose element [t][l] presents the total
-     *  score of paths starting at (t, l) and arraiving at EOS.
-     */
-    floatval_t *beta_score;
-
-    /**
-     * Scale factor vector.
-     *  This is a [T] vector whose element [t] presents the scaling
-     *  coefficient for the alpha_score and beta_score.
-     */
-    floatval_t *scale_factor;
-
-    /**
-     * Row vector (work space).
-     *  This is a [T] vector used internally for a work space.
-     */
-    floatval_t *row;
-
-    /**
-     * Backward edges.
-     *  This is a [T][L] matrix whose element [t][j] represents the label #i
-     *  that yields the maximum score to arrive at (t, j).
-     *  This member is available only with CTXF_VITERBI flag enabled.
-     */
-    int *backward_edge;
-
-    /**
-     * Exponents of state scores.
-     *  This is a [T][L] matrix whose element [t][l] presents the exponent
-     *  of the total score of state features associating label #l at #t.
-     *  This member is available only with CTXF_MARGINALS flag.
-     */
-    floatval_t *exp_state;
-
-    /**
-     * Exponents of transition scores.
-     *  This is a [L][L] matrix whose element [i][j] represents the exponent
-     *  of the total score of transition features associating labels #i and #j.
-     *  This member is available only with CTXF_MARGINALS flag.
-     */
-    floatval_t *exp_trans;
-
-    /**
-     * Model expectations of states.
-     *  This is a [T][L] matrix whose element [t][l] presents the model
-     *  expectation (marginal probability) of the state (t,l)
-     *  This member is available only with CTXF_MARGINALS flag.
-     */
-    floatval_t *mexp_state;
-
-    /**
-     * Model expectations of transitions.
-     *  This is a [L][L] matrix whose element [i][j] presents the model
-     *  expectation of the transition (i--j).
-     *  This member is available only with CTXF_MARGINALS flag.
-     */
-    floatval_t *mexp_trans;
-
-} crf1d_context_t;
-
-#define MATRIX(p, xl, x, y) ((p)[(xl) * (y) + (x)])
-
-#define ALPHA_SCORE(ctx, t) \
-    (&MATRIX(ctx->alpha_score, ctx->num_labels, 0, t))
-#define BETA_SCORE(ctx, t) \
-    (&MATRIX(ctx->beta_score, ctx->num_labels, 0, t))
-#define STATE_SCORE(ctx, i) \
-    (&MATRIX(ctx->state, ctx->num_labels, 0, i))
-#define TRANS_SCORE(ctx, i) \
-    (&MATRIX(ctx->trans, ctx->num_labels, 0, i))
-#define EXP_STATE_SCORE(ctx, i) \
-    (&MATRIX(ctx->exp_state, ctx->num_labels, 0, i))
-#define EXP_TRANS_SCORE(ctx, i) \
-    (&MATRIX(ctx->exp_trans, ctx->num_labels, 0, i))
-#define STATE_MEXP(ctx, i) \
-    (&MATRIX(ctx->mexp_state, ctx->num_labels, 0, i))
-#define TRANS_MEXP(ctx, i) \
-    (&MATRIX(ctx->mexp_trans, ctx->num_labels, 0, i))
-#define BACKWARD_EDGE_AT(ctx, t) \
-    (&MATRIX(ctx->backward_edge, ctx->num_labels, 0, t))
-
-crf1d_context_t *crf1dc_new(int flag, int L, int T);
-int crf1dc_set_num_items(crf1d_context_t *ctx, int T);
-void crf1dc_delete(crf1d_context_t *ctx);
-void crf1dc_reset(crf1d_context_t *ctx, int flag);
-void crf1dc_exp_state(crf1d_context_t *ctx);
-void crf1dc_exp_transition(crf1d_context_t *ctx);
-void crf1dc_alpha_score(crf1d_context_t *ctx);
-void crf1dc_beta_score(crf1d_context_t *ctx);
-void crf1dc_marginals(crf1d_context_t *ctx);
-floatval_t crf1dc_marginal_point(crf1d_context_t *ctx, int l, int t);
-floatval_t crf1dc_marginal_path(crf1d_context_t *ctx, const int *path, int begin, int end);
-floatval_t crf1dc_score(crf1d_context_t *ctx, const int *labels);
-floatval_t crf1dc_lognorm(crf1d_context_t *ctx);
-floatval_t crf1dc_viterbi(crf1d_context_t *ctx, int *labels);
-void crf1dc_debug_context(FILE *fp);
-
-/** @} */
-
-/**
- * \defgroup crf1d_feature.c
- */
-/** @{ */
-
-/**
- * Feature type.
- */
-enum
-{
-    FT_STATE = 0, /**< State features. */
-    FT_TRANS,     /**< Transition features. */
-};
-
-/**
- * A feature (for either state or transition).
- */
-typedef struct
-{
-    /**
-     * Feature type.
-     *    Possible values are:
-     *    - FT_STATE (0) for state features.
-     *    - FT_TRANS (1) for transition features.
-     */
-    int type;
-
-    /**
-     * Source id.
-     *    The semantic of this field depends on the feature type:
-     *    - attribute id for state features (type == 0).
-     *    - output label id for transition features (type != 0).
-     */
-    int src;
-
-    /**
-     * Destination id.
-     *    Label id emitted by this feature.
-     */
-    int dst;
-
-    /**
-     * Frequency (observation expectation).
-     */
-    floatval_t freq;
-} crf1df_feature_t;
-
-/**
- * Feature references.
- *    This is a collection of feature ids used for faster accesses.
- */
-typedef struct
-{
-    int num_features; /**< Number of features referred */
-    int *fids;        /**< Array of feature ids */
-} feature_refs_t;
-
-crf1df_feature_t *crf1df_generate(
-    int *ptr_num_features,
-    dataset_t *ds,
-    int num_labels,
-    int num_attributes,
-    int connect_all_attrs,
-    int connect_all_edges,
-    floatval_t minfreq,
-    crfsuite_logging_callback func,
-    void *instance);
-
-int crf1df_init_references(
-    feature_refs_t **ptr_attributes,
-    feature_refs_t **ptr_trans,
-    const crf1df_feature_t *features,
-    const int K,
-    const int A,
-    const int L);
-
-/** @} */
-
-/**
- * \defgroup crf1d_model.c
- */
-/** @{ */
-
-struct tag_crf1dm;
-typedef struct tag_crf1dm crf1dm_t;
-
-struct tag_crf1dmw;
-typedef struct tag_crf1dmw crf1dmw_t;
-
-typedef struct
-{
-    int type;
-    int src;
-    int dst;
-    floatval_t weight;
-} crf1dm_feature_t;
-
-crf1dmw_t *crf1mmw(const char *filename);
-int crf1dmw_close(crf1dmw_t *writer);
-int crf1dmw_open_labels(crf1dmw_t *writer, int num_labels);
-int crf1dmw_close_labels(crf1dmw_t *writer);
-int crf1dmw_put_label(crf1dmw_t *writer, int lid, const char *value);
-int crf1dmw_open_attrs(crf1dmw_t *writer, int num_attributes);
-int crf1dmw_close_attrs(crf1dmw_t *writer);
-int crf1dmw_put_attr(crf1dmw_t *writer, int aid, const char *value);
-int crf1dmw_open_labelrefs(crf1dmw_t *writer, int num_labels);
-int crf1dmw_close_labelrefs(crf1dmw_t *writer);
-int crf1dmw_put_labelref(crf1dmw_t *writer, int lid, const feature_refs_t *ref, int *map);
-int crf1dmw_open_attrrefs(crf1dmw_t *writer, int num_attrs);
-int crf1dmw_close_attrrefs(crf1dmw_t *writer);
-int crf1dmw_put_attrref(crf1dmw_t *writer, int aid, const feature_refs_t *ref, int *map);
-int crf1dmw_open_features(crf1dmw_t *writer);
-int crf1dmw_close_features(crf1dmw_t *writer);
-int crf1dmw_put_feature(crf1dmw_t *writer, int fid, const crf1dm_feature_t *f);
-
-crf1dm_t *crf1dm_new(const char *filename);
-crf1dm_t *crf1dm_new_from_memory(const void *data, size_t size);
-void crf1dm_close(crf1dm_t *model);
-int crf1dm_get_num_attrs(crf1dm_t *model);
-int crf1dm_get_num_labels(crf1dm_t *model);
-const char *crf1dm_to_label(crf1dm_t *model, int lid);
-int crf1dm_to_lid(crf1dm_t *model, const char *value);
-int crf1dm_to_aid(crf1dm_t *model, const char *value);
-const char *crf1dm_to_attr(crf1dm_t *model, int aid);
-int crf1dm_get_labelref(crf1dm_t *model, int lid, feature_refs_t *ref);
-int crf1dm_get_attrref(crf1dm_t *model, int aid, feature_refs_t *ref);
-int crf1dm_get_featureid(feature_refs_t *ref, int i);
-int crf1dm_get_feature(crf1dm_t *model, int fid, crf1dm_feature_t *f);
-void crf1dm_dump_states(crf1dm_t *model, FILE *fp);
-void crf1dm_dump_transitions(crf1dm_t *model, FILE *fp);
-
-/** @} */
-
-#endif /*__CRF1D_H__*/
+/*
+ *      The 1st-order linear-chain CRF with dyad features (CRF1d).
+ *
+ * Copyright (c) 2007-2010, Naoaki Okazaki
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the names of the authors nor the names of its contributors
+ *       may be used to endorse or promote products derived from this
+ *       software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+ * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/* $Id$ */
+
+#ifndef __CRF1D_H__
+#define __CRF1D_H__
+
+#include <crfsuite.h>
+#include "crfsuite_internal.h"
+
+/**
+ * \defgroup crf1d_context.c
+ */
+/** @{ */
+
+/**
+ * Functionality flags for contexts.
+ *  @see    crf1dc_new().
+ */
+enum
+{
+    CTXF_BASE = 0x01,
+    CTXF_VITERBI = 0x01,
+    CTXF_MARGINALS = 0x02,
+    CTXF_ALL = 0xFF,
+};
+
+/**
+ * Reset flags.
+ *  @see    crf1dc_reset().
+ */
+enum
+{
+    RF_STATE = 0x01, /**< Reset state scores. */
+    RF_TRANS = 0x02, /**< Reset transition scores. */
+    RF_ALL = 0xFF,   /**< Reset all. */
+};
+
+/**
+ * Context structure.
+ *  This structure maintains internal data for an instance.
+ */
+typedef struct
+{
+    /**
+     * Flag specifying the functionality.
+     */
+    int flag;
+
+    /**
+     * The total number of distinct labels (L).
+     */
+    int num_labels;
+
+    /**
+     * The number of items (T) in the instance.
+     */
+    int num_items;
+
+    /**
+     * The maximum number of labels.
+     */
+    int cap_items;
+
+    /**
+     * Logarithm of the normalization factor for the instance.
+     *  This is equivalent to the total scores of all paths in the lattice.
+     */
+    floatval_t log_norm;
+
+    /**
+     * State scores.
+     *  This is a [T][L] matrix whose element [t][l] presents total score
+     *  of state features associating label #l at #t.
+     */
+    floatval_t *state;
+
+    /**
+     * Transition scores.
+     *  This is a [L][L] matrix whose element [i][j] represents the total
+     *  score of transition features associating labels #i and #j.
+     */
+    floatval_t *trans;
+
+    /**
+     * Alpha score matrix.
+     *  This is a [T][L] matrix whose element [t][l] presents the total
+     *  score of paths starting at BOS and arraiving at (t, l).
+     */
+    floatval_t *alpha_score;
+
+    /**
+     * Beta score matrix.
+     *  This is a [T][L] matrix whose element [t][l] presents the total
+     *  score of paths starting at (t, l) and arraiving at EOS.
+     */
+    floatval_t *beta_score;
+
+    /**
+     * Scale factor vector.
+     *  This is a [T] vector whose element [t] presents the scaling
+     *  coefficient for the alpha_score and beta_score.
+     */
+    floatval_t *scale_factor;
+
+    /**
+     * Row vector (work space).
+     *  This is a [T] vector used internally for a work space.
+     */
+    floatval_t *row;
+
+    /**
+     * Backward edges.
+     *  This is a [T][L] matrix whose element [t][j] represents the label #i
+     *  that yields the maximum score to arrive at (t, j).
+     *  This member is available only with CTXF_VITERBI flag enabled.
+     */
+    int *backward_edge;
+
+    /**
+     * Exponents of state scores.
+     *  This is a [T][L] matrix whose element [t][l] presents the exponent
+     *  of the total score of state features associating label #l at #t.
+     *  This member is available only with CTXF_MARGINALS flag.
+     */
+    floatval_t *exp_state;
+
+    /**
+     * Exponents of transition scores.
+     *  This is a [L][L] matrix whose element [i][j] represents the exponent
+     *  of the total score of transition features associating labels #i and #j.
+     *  This member is available only with CTXF_MARGINALS flag.
+     */
+    floatval_t *exp_trans;
+
+    /**
+     * Model expectations of states.
+     *  This is a [T][L] matrix whose element [t][l] presents the model
+     *  expectation (marginal probability) of the state (t,l)
+     *  This member is available only with CTXF_MARGINALS flag.
+     */
+    floatval_t *mexp_state;
+
+    /**
+     * Model expectations of transitions.
+     *  This is a [L][L] matrix whose element [i][j] presents the model
+     *  expectation of the transition (i--j).
+     *  This member is available only with CTXF_MARGINALS flag.
+     */
+    floatval_t *mexp_trans;
+
+} crf1d_context_t;
+
+#define MATRIX(p, xl, x, y) ((p)[(xl) * (y) + (x)])
+
+#define ALPHA_SCORE(ctx, t) \
+    (&MATRIX(ctx->alpha_score, ctx->num_labels, 0, t))
+#define BETA_SCORE(ctx, t) \
+    (&MATRIX(ctx->beta_score, ctx->num_labels, 0, t))
+#define STATE_SCORE(ctx, i) \
+    (&MATRIX(ctx->state, ctx->num_labels, 0, i))
+#define TRANS_SCORE(ctx, i) \
+    (&MATRIX(ctx->trans, ctx->num_labels, 0, i))
+#define EXP_STATE_SCORE(ctx, i) \
+    (&MATRIX(ctx->exp_state, ctx->num_labels, 0, i))
+#define EXP_TRANS_SCORE(ctx, i) \
+    (&MATRIX(ctx->exp_trans, ctx->num_labels, 0, i))
+#define STATE_MEXP(ctx, i) \
+    (&MATRIX(ctx->mexp_state, ctx->num_labels, 0, i))
+#define TRANS_MEXP(ctx, i) \
+    (&MATRIX(ctx->mexp_trans, ctx->num_labels, 0, i))
+#define BACKWARD_EDGE_AT(ctx, t) \
+    (&MATRIX(ctx->backward_edge, ctx->num_labels, 0, t))
+
+crf1d_context_t *crf1dc_new(int flag, int L, int T);
+int crf1dc_set_num_items(crf1d_context_t *ctx, int T);
+void crf1dc_delete(crf1d_context_t *ctx);
+void crf1dc_reset(crf1d_context_t *ctx, int flag);
+void crf1dc_exp_state(crf1d_context_t *ctx);
+void crf1dc_exp_transition(crf1d_context_t *ctx);
+void crf1dc_alpha_score(crf1d_context_t *ctx);
+void crf1dc_beta_score(crf1d_context_t *ctx);
+void crf1dc_marginals(crf1d_context_t *ctx);
+floatval_t crf1dc_marginal_point(crf1d_context_t *ctx, int l, int t);
+floatval_t crf1dc_marginal_path(crf1d_context_t *ctx, const int *path, int begin, int end);
+floatval_t crf1dc_score(crf1d_context_t *ctx, const int *labels);
+floatval_t crf1dc_lognorm(crf1d_context_t *ctx);
+floatval_t crf1dc_viterbi(crf1d_context_t *ctx, int *labels);
+void crf1dc_debug_context(FILE *fp);
+
+/** @} */
+
+/**
+ * \defgroup crf1d_feature.c
+ */
+/** @{ */
+
+/**
+ * Feature type.
+ */
+enum
+{
+    FT_STATE = 0, /**< State features. */
+    FT_TRANS,     /**< Transition features. */
+};
+
+/**
+ * A feature (for either state or transition).
+ */
+typedef struct
+{
+    /**
+     * Feature type.
+     *    Possible values are:
+     *    - FT_STATE (0) for state features.
+     *    - FT_TRANS (1) for transition features.
+     */
+    int type;
+
+    /**
+     * Source id.
+     *    The semantic of this field depends on the feature type:
+     *    - attribute id for state features (type == 0).
+     *    - output label id for transition features (type != 0).
+     */
+    int src;
+
+    /**
+     * Destination id.
+     *    Label id emitted by this feature.
+     */
+    int dst;
+
+    /**
+     * Frequency (observation expectation).
+     */
+    floatval_t freq;
+} crf1df_feature_t;
+
+/**
+ * Feature references.
+ *    This is a collection of feature ids used for faster accesses.
+ */
+typedef struct
+{
+    int num_features; /**< Number of features referred */
+    int *fids;        /**< Array of feature ids */
+} feature_refs_t;
+
+crf1df_feature_t *crf1df_generate(
+    int *ptr_num_features,
+    dataset_t *ds,
+    int num_labels,
+    int num_attributes,
+    int connect_all_attrs,
+    int connect_all_edges,
+    floatval_t minfreq,
+    crfsuite_logging_callback func,
+    void *instance);
+
+int crf1df_init_references(
+    feature_refs_t **ptr_attributes,
+    feature_refs_t **ptr_trans,
+    const crf1df_feature_t *features,
+    const int K,
+    const int A,
+    const int L);
+
+/** @} */
+
+/**
+ * \defgroup crf1d_model.c
+ */
+/** @{ */
+
+struct tag_crf1dm;
+typedef struct tag_crf1dm crf1dm_t;
+
+struct tag_crf1dmw;
+typedef struct tag_crf1dmw crf1dmw_t;
+
+typedef struct
+{
+    int type;
+    int src;
+    int dst;
+    floatval_t weight;
+} crf1dm_feature_t;
+
+crf1dmw_t *crf1mmw(const char *filename);
+int crf1dmw_close(crf1dmw_t *writer);
+int crf1dmw_open_labels(crf1dmw_t *writer, int num_labels);
+int crf1dmw_close_labels(crf1dmw_t *writer);
+int crf1dmw_put_label(crf1dmw_t *writer, int lid, const char *value);
+int crf1dmw_open_attrs(crf1dmw_t *writer, int num_attributes);
+int crf1dmw_close_attrs(crf1dmw_t *writer);
+int crf1dmw_put_attr(crf1dmw_t *writer, int aid, const char *value);
+int crf1dmw_open_labelrefs(crf1dmw_t *writer, int num_labels);
+int crf1dmw_close_labelrefs(crf1dmw_t *writer);
+int crf1dmw_put_labelref(crf1dmw_t *writer, int lid, const feature_refs_t *ref, int *map);
+int crf1dmw_open_attrrefs(crf1dmw_t *writer, int num_attrs);
+int crf1dmw_close_attrrefs(crf1dmw_t *writer);
+int crf1dmw_put_attrref(crf1dmw_t *writer, int aid, const feature_refs_t *ref, int *map);
+int crf1dmw_open_features(crf1dmw_t *writer);
+int crf1dmw_close_features(crf1dmw_t *writer);
+int crf1dmw_put_feature(crf1dmw_t *writer, int fid, const crf1dm_feature_t *f);
+
+crf1dm_t *crf1dm_new(const char *filename);
+crf1dm_t *crf1dm_new_from_memory(const void *data, size_t size);
+void crf1dm_close(crf1dm_t *model);
+int crf1dm_get_num_attrs(crf1dm_t *model);
+int crf1dm_get_num_labels(crf1dm_t *model);
+const char *crf1dm_to_label(crf1dm_t *model, int lid);
+int crf1dm_to_lid(crf1dm_t *model, const char *value);
+int crf1dm_to_aid(crf1dm_t *model, const char *value);
+const char *crf1dm_to_attr(crf1dm_t *model, int aid);
+int crf1dm_get_labelref(crf1dm_t *model, int lid, feature_refs_t *ref);
+int crf1dm_get_attrref(crf1dm_t *model, int aid, feature_refs_t *ref);
+int crf1dm_get_featureid(feature_refs_t *ref, int i);
+int crf1dm_get_feature(crf1dm_t *model, int fid, crf1dm_feature_t *f);
+void crf1dm_dump_states(crf1dm_t *model, FILE *fp);
+void crf1dm_dump_transitions(crf1dm_t *model, FILE *fp);
+
+/** @} */
+
+#endif /*__CRF1D_H__*/
```

## chaine/_core/crfsuite/lib/crf/src/crf1d_context.c

 * *Ordering differences only*

```diff
@@ -1,788 +1,788 @@
-/*
- *      CRF1d context (forward-backward, viterbi, etc).
- *
- * Copyright (c) 2007-2010, Naoaki Okazaki
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the names of the authors nor the names of its contributors
- *       may be used to endorse or promote products derived from this
- *       software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
- * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-/* $Id$ */
-
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif /*HAVE_CONFIG_H*/
-
-#include <os.h>
-
-#include <float.h>
-#include <math.h>
-#include <stdio.h>
-#include <stdlib.h>
-
-#include <crfsuite.h>
-
-#include "crf1d.h"
-#include "vecmath.h"
-
-crf1d_context_t *crf1dc_new(int flag, int L, int T)
-{
-    int ret = 0;
-    crf1d_context_t *ctx = NULL;
-
-    ctx = (crf1d_context_t *)calloc(1, sizeof(crf1d_context_t));
-    if (ctx != NULL)
-    {
-        ctx->flag = flag;
-        ctx->num_labels = L;
-
-        ctx->trans = (floatval_t *)calloc(L * L, sizeof(floatval_t));
-        if (ctx->trans == NULL)
-            goto error_exit;
-
-        if (ctx->flag & CTXF_MARGINALS)
-        {
-            ctx->exp_trans = (floatval_t *)_aligned_malloc((L * L + 4) * sizeof(floatval_t), 16);
-            if (ctx->exp_trans == NULL)
-                goto error_exit;
-            ctx->mexp_trans = (floatval_t *)calloc(L * L, sizeof(floatval_t));
-            if (ctx->mexp_trans == NULL)
-                goto error_exit;
-        }
-
-        if (ret = crf1dc_set_num_items(ctx, T))
-        {
-            goto error_exit;
-        }
-
-        /* T gives the 'hint' for maximum length of items. */
-        ctx->num_items = 0;
-    }
-
-    return ctx;
-
-error_exit:
-    crf1dc_delete(ctx);
-    return NULL;
-}
-
-int crf1dc_set_num_items(crf1d_context_t *ctx, int T)
-{
-    const int L = ctx->num_labels;
-
-    ctx->num_items = T;
-
-    if (ctx->cap_items < T)
-    {
-        free(ctx->backward_edge);
-        free(ctx->mexp_state);
-        _aligned_free(ctx->exp_state);
-        free(ctx->scale_factor);
-        free(ctx->row);
-        free(ctx->beta_score);
-        free(ctx->alpha_score);
-        free(ctx->state);
-
-        ctx->alpha_score = (floatval_t *)calloc(T * L, sizeof(floatval_t));
-        if (ctx->alpha_score == NULL)
-            return CRFSUITEERR_OUTOFMEMORY;
-        ctx->beta_score = (floatval_t *)calloc(T * L, sizeof(floatval_t));
-        if (ctx->beta_score == NULL)
-            return CRFSUITEERR_OUTOFMEMORY;
-        ctx->scale_factor = (floatval_t *)calloc(T, sizeof(floatval_t));
-        if (ctx->scale_factor == NULL)
-            return CRFSUITEERR_OUTOFMEMORY;
-        ctx->row = (floatval_t *)calloc(L, sizeof(floatval_t));
-        if (ctx->row == NULL)
-            return CRFSUITEERR_OUTOFMEMORY;
-
-        if (ctx->flag & CTXF_VITERBI)
-        {
-            ctx->backward_edge = (int *)calloc(T * L, sizeof(int));
-            if (ctx->backward_edge == NULL)
-                return CRFSUITEERR_OUTOFMEMORY;
-        }
-
-        ctx->state = (floatval_t *)calloc(T * L, sizeof(floatval_t));
-        if (ctx->state == NULL)
-            return CRFSUITEERR_OUTOFMEMORY;
-
-        if (ctx->flag & CTXF_MARGINALS)
-        {
-            ctx->exp_state = (floatval_t *)_aligned_malloc((T * L + 4) * sizeof(floatval_t), 16);
-            if (ctx->exp_state == NULL)
-                return CRFSUITEERR_OUTOFMEMORY;
-            ctx->mexp_state = (floatval_t *)calloc(T * L, sizeof(floatval_t));
-            if (ctx->mexp_state == NULL)
-                return CRFSUITEERR_OUTOFMEMORY;
-        }
-
-        ctx->cap_items = T;
-    }
-
-    return 0;
-}
-
-void crf1dc_delete(crf1d_context_t *ctx)
-{
-    if (ctx != NULL)
-    {
-        free(ctx->backward_edge);
-        free(ctx->mexp_state);
-        _aligned_free(ctx->exp_state);
-        free(ctx->state);
-        free(ctx->scale_factor);
-        free(ctx->row);
-        free(ctx->beta_score);
-        free(ctx->alpha_score);
-        free(ctx->mexp_trans);
-        _aligned_free(ctx->exp_trans);
-        free(ctx->trans);
-    }
-    free(ctx);
-}
-
-void crf1dc_reset(crf1d_context_t *ctx, int flag)
-{
-    const int T = ctx->num_items;
-    const int L = ctx->num_labels;
-
-    if (flag & RF_STATE)
-    {
-        veczero(ctx->state, T * L);
-    }
-    if (flag & RF_TRANS)
-    {
-        veczero(ctx->trans, L * L);
-    }
-
-    if (ctx->flag & CTXF_MARGINALS)
-    {
-        veczero(ctx->mexp_state, T * L);
-        veczero(ctx->mexp_trans, L * L);
-        ctx->log_norm = 0;
-    }
-}
-
-void crf1dc_exp_state(crf1d_context_t *ctx)
-{
-    const int T = ctx->num_items;
-    const int L = ctx->num_labels;
-
-    veccopy(ctx->exp_state, ctx->state, L * T);
-    vecexp(ctx->exp_state, L * T);
-}
-
-void crf1dc_exp_transition(crf1d_context_t *ctx)
-{
-    const int L = ctx->num_labels;
-
-    veccopy(ctx->exp_trans, ctx->trans, L * L);
-    vecexp(ctx->exp_trans, L * L);
-}
-
-void crf1dc_alpha_score(crf1d_context_t *ctx)
-{
-    int i, t;
-    floatval_t sum, *cur = NULL;
-    floatval_t *scale = &ctx->scale_factor[0];
-    const floatval_t *prev = NULL, *trans = NULL, *state = NULL;
-    const int T = ctx->num_items;
-    const int L = ctx->num_labels;
-
-    /* Compute the alpha scores on nodes (0, *).
-        alpha[0][j] = state[0][j]
-     */
-    cur = ALPHA_SCORE(ctx, 0);
-    state = EXP_STATE_SCORE(ctx, 0);
-    veccopy(cur, state, L);
-    sum = vecsum(cur, L);
-    *scale = (sum != 0.) ? 1. / sum : 1.;
-    vecscale(cur, *scale, L);
-    ++scale;
-
-    /* Compute the alpha scores on nodes (t, *).
-        alpha[t][j] = state[t][j] * \sum_{i} alpha[t-1][i] * trans[i][j]
-     */
-    for (t = 1; t < T; ++t)
-    {
-        prev = ALPHA_SCORE(ctx, t - 1);
-        cur = ALPHA_SCORE(ctx, t);
-        state = EXP_STATE_SCORE(ctx, t);
-
-        veczero(cur, L);
-        for (i = 0; i < L; ++i)
-        {
-            trans = EXP_TRANS_SCORE(ctx, i);
-            vecaadd(cur, prev[i], trans, L);
-        }
-        vecmul(cur, state, L);
-        sum = vecsum(cur, L);
-        *scale = (sum != 0.) ? 1. / sum : 1.;
-        vecscale(cur, *scale, L);
-        ++scale;
-    }
-
-    /* Compute the logarithm of the normalization factor here.
-        norm = 1. / (C[0] * C[1] ... * C[T-1])
-        log(norm) = - \sum_{t = 0}^{T-1} log(C[t]).
-     */
-    ctx->log_norm = -vecsumlog(ctx->scale_factor, T);
-}
-
-void crf1dc_beta_score(crf1d_context_t *ctx)
-{
-    int i, t;
-    floatval_t *cur = NULL;
-    floatval_t *row = ctx->row;
-    const floatval_t *next = NULL, *state = NULL, *trans = NULL;
-    const int T = ctx->num_items;
-    const int L = ctx->num_labels;
-    const floatval_t *scale = &ctx->scale_factor[T - 1];
-
-    /* Compute the beta scores at (T-1, *). */
-    cur = BETA_SCORE(ctx, T - 1);
-    vecset(cur, *scale, L);
-    --scale;
-
-    /* Compute the beta scores at (t, *). */
-    for (t = T - 2; 0 <= t; --t)
-    {
-        cur = BETA_SCORE(ctx, t);
-        next = BETA_SCORE(ctx, t + 1);
-        state = EXP_STATE_SCORE(ctx, t + 1);
-
-        veccopy(row, next, L);
-        vecmul(row, state, L);
-
-        /* Compute the beta score at (t, i). */
-        for (i = 0; i < L; ++i)
-        {
-            trans = EXP_TRANS_SCORE(ctx, i);
-            cur[i] = vecdot(trans, row, L);
-        }
-        vecscale(cur, *scale, L);
-        --scale;
-    }
-}
-
-void crf1dc_marginals(crf1d_context_t *ctx)
-{
-    int i, j, t;
-    const int T = ctx->num_items;
-    const int L = ctx->num_labels;
-
-    /*
-        Compute the model expectations of states.
-            p(t,i) = fwd[t][i] * bwd[t][i] / norm
-                   = (1. / C[t]) * fwd'[t][i] * bwd'[t][i]
-     */
-    for (t = 0; t < T; ++t)
-    {
-        floatval_t *fwd = ALPHA_SCORE(ctx, t);
-        floatval_t *bwd = BETA_SCORE(ctx, t);
-        floatval_t *prob = STATE_MEXP(ctx, t);
-        veccopy(prob, fwd, L);
-        vecmul(prob, bwd, L);
-        vecscale(prob, 1. / ctx->scale_factor[t], L);
-    }
-
-    /*
-        Compute the model expectations of transitions.
-            p(t,i,t+1,j)
-                = fwd[t][i] * edge[i][j] * state[t+1][j] * bwd[t+1][j] / norm
-                = (fwd'[t][i] / (C[0] ... C[t])) * edge[i][j] * state[t+1][j] * (bwd'[t+1][j] / (C[t+1] ... C[T-1])) * (C[0] * ... * C[T-1])
-                = fwd'[t][i] * edge[i][j] * state[t+1][j] * bwd'[t+1][j]
-        The model expectation of a transition (i -> j) is the sum of the marginal
-        probabilities p(t,i,t+1,j) over t.
-     */
-    for (t = 0; t < T - 1; ++t)
-    {
-        floatval_t *fwd = ALPHA_SCORE(ctx, t);
-        floatval_t *state = EXP_STATE_SCORE(ctx, t + 1);
-        floatval_t *bwd = BETA_SCORE(ctx, t + 1);
-        floatval_t *row = ctx->row;
-
-        /* row[j] = state[t+1][j] * bwd'[t+1][j] */
-        veccopy(row, bwd, L);
-        vecmul(row, state, L);
-
-        for (i = 0; i < L; ++i)
-        {
-            floatval_t *edge = EXP_TRANS_SCORE(ctx, i);
-            floatval_t *prob = TRANS_MEXP(ctx, i);
-            for (j = 0; j < L; ++j)
-            {
-                prob[j] += fwd[i] * edge[j] * row[j];
-            }
-        }
-    }
-}
-
-floatval_t crf1dc_marginal_point(crf1d_context_t *ctx, int l, int t)
-{
-    floatval_t *fwd = ALPHA_SCORE(ctx, t);
-    floatval_t *bwd = BETA_SCORE(ctx, t);
-    return fwd[l] * bwd[l] / ctx->scale_factor[t];
-}
-
-floatval_t crf1dc_marginal_path(crf1d_context_t *ctx, const int *path, int begin, int end)
-{
-    int t;
-    /*
-        Compute the marginal probability of a (partial) path.
-            a = path[begin], b = path[begin+1], ..., y = path[end-2], z = path[end-1]
-            fwd[begin][a] = (fwd'[begin][a] / (C[0] ... C[begin])
-            bwd[end-1][z] = (bwd'[end-1][z] / (C[end-1] ... C[T-1]))
-            norm = 1 / (C[0] * ... * C[T-1])
-            p(a, b, ..., z)
-                = fwd[begin][a] * edge[a][b] * state[begin+1][b] * ... * edge[y][z] * state[end-1][z] * bwd[end-1][z] / norm
-                = fwd'[begin][a] * edge[a][b] * state[begin+1][b] * ... * edge[y][z] * state[end-1][z] * bwd'[end-1][z] * (C[begin+1] * ... * C[end-2])
-     */
-    floatval_t *fwd = ALPHA_SCORE(ctx, begin);
-    floatval_t *bwd = BETA_SCORE(ctx, end - 1);
-    floatval_t prob = fwd[path[begin]] * bwd[path[end - 1]] / ctx->scale_factor[begin];
-
-    for (t = begin; t < end - 1; ++t)
-    {
-        floatval_t *state = EXP_STATE_SCORE(ctx, t + 1);
-        floatval_t *edge = EXP_TRANS_SCORE(ctx, path[t]);
-        prob *= (edge[path[t + 1]] * state[path[t + 1]] * ctx->scale_factor[t]);
-    }
-
-    return prob;
-}
-
-#if 0
-/* Sigh, this was found to be slower than the forward-backward algorithm. */
-
-#define ADJACENCY(ctx, i) \
-    (&MATRIX(ctx->adj, ctx->num_labels, 0, i))
-
-void crf1dc_marginal_without_beta(crf1d_context_t* ctx)
-{
-    int i, j, t;
-    floatval_t *prob = NULL;
-    floatval_t *row = ctx->row;
-    const floatval_t *fwd = NULL;
-    const int T = ctx->num_items;
-    const int L = ctx->num_labels;
-
-    /*
-        Compute marginal probabilities of states at T-1
-            p(T-1,j) = fwd'[T-1][j]
-     */
-    fwd = ALPHA_SCORE(ctx, T-1);
-    prob = STATE_MEXP(ctx, T-1);
-    veccopy(prob, fwd, L);
-
-    /*
-        Repeat the following computation for t = T-1,T-2, ..., 1.
-            1) Compute p(t-1,i,t,j) using p(t,j)
-            2) Compute p(t,i) using p(t-1,i,t,j)
-     */
-    for (t = T-1;0 < t;--t) {
-        fwd = ALPHA_SCORE(ctx, t-1);
-        prob = STATE_MEXP(ctx, t);
-
-        veczero(ctx->adj, L*L);
-        veczero(row, L);
-
-        /*
-            Compute adj[i][j] and row[j].
-                adj[i][j] = fwd'[t-1][i] * edge[i][j]
-                row[j] = \sum_{i} adj[i][j]
-         */
-        for (i = 0;i < L;++i) {
-            floatval_t *adj = ADJACENCY(ctx, i);
-            floatval_t *edge = EXP_TRANS_SCORE(ctx, i);
-            vecaadd(adj, fwd[i], edge, L);
-            vecadd(row, adj, L);
-        }
-
-        /*
-            Find z such that z * \sum_{i] adj[i][j] = p(t,j).
-            Thus, z = p(t,j) / row[j]; we overwrite row with z.
-         */
-        vecinv(row, L);
-        vecmul(row, prob, L);
-
-        /*
-            Apply the partition factor z (row[j]) to adj[i][j].
-         */
-        for (i = 0;i < L;++i) {
-            floatval_t *adj = ADJACENCY(ctx, i);
-            vecmul(adj, row, L);
-        }
-
-        /*
-            Now that adj[i][j] presents p(t-1,i,t,j),
-            accumulate model expectations of transitions.
-         */
-        for (i = 0;i < L;++i) {
-            floatval_t *adj = ADJACENCY(ctx, i);
-            floatval_t *prob = TRANS_MEXP(ctx, i);
-            vecadd(prob, adj, L);
-        }
-
-        /*
-            Compute the marginal probability of states at t-1.
-                p(t-1,i) = \sum_{j} p(t-1,i,t,j)
-         */
-        prob = STATE_MEXP(ctx, t-1);
-        for (i = 0;i < L;++i) {
-            floatval_t *adj = ADJACENCY(ctx, i);
-            prob[i] = vecsum(adj, L);
-        }
-    }
-}
-#endif
-
-floatval_t crf1dc_score(crf1d_context_t *ctx, const int *labels)
-{
-    int i, j, t;
-    floatval_t ret = 0;
-    const floatval_t *state = NULL, *cur = NULL, *trans = NULL;
-    const int T = ctx->num_items;
-    const int L = ctx->num_labels;
-
-    /* Stay at (0, labels[0]). */
-    i = labels[0];
-    state = STATE_SCORE(ctx, 0);
-    ret = state[i];
-
-    /* Loop over the rest of items. */
-    for (t = 1; t < T; ++t)
-    {
-        j = labels[t];
-        trans = TRANS_SCORE(ctx, i);
-        state = STATE_SCORE(ctx, t);
-
-        /* Transit from (t-1, i) to (t, j). */
-        ret += trans[j];
-        ret += state[j];
-        i = j;
-    }
-    return ret;
-}
-
-floatval_t crf1dc_lognorm(crf1d_context_t *ctx)
-{
-    return ctx->log_norm;
-}
-
-floatval_t crf1dc_viterbi(crf1d_context_t *ctx, int *labels)
-{
-    int i, j, t;
-    int *back = NULL;
-    floatval_t max_score, score, *cur = NULL;
-    int argmax_score;
-    const floatval_t *prev = NULL, *state = NULL, *trans = NULL;
-    const int T = ctx->num_items;
-    const int L = ctx->num_labels;
-
-    /*
-        This function assumes state and trans scores to be in the logarithm domain.
-     */
-
-    /* Compute the scores at (0, *). */
-    cur = ALPHA_SCORE(ctx, 0);
-    state = STATE_SCORE(ctx, 0);
-    for (j = 0; j < L; ++j)
-    {
-        cur[j] = state[j];
-    }
-
-    /* Compute the scores at (t, *). */
-    for (t = 1; t < T; ++t)
-    {
-        prev = ALPHA_SCORE(ctx, t - 1);
-        cur = ALPHA_SCORE(ctx, t);
-        state = STATE_SCORE(ctx, t);
-        back = BACKWARD_EDGE_AT(ctx, t);
-
-        /* Compute the score of (t, j). */
-        for (j = 0; j < L; ++j)
-        {
-            max_score = -FLOAT_MAX;
-            argmax_score = -1;
-            for (i = 0; i < L; ++i)
-            {
-                /* Transit from (t-1, i) to (t, j). */
-                trans = TRANS_SCORE(ctx, i);
-                score = prev[i] + trans[j];
-
-                /* Store this path if it has the maximum score. */
-                if (max_score < score)
-                {
-                    max_score = score;
-                    argmax_score = i;
-                }
-            }
-            /* Backward link (#t, #j) -> (#t-1, #i). */
-            if (argmax_score >= 0)
-                back[j] = argmax_score;
-            /* Add the state score on (t, j). */
-            cur[j] = max_score + state[j];
-        }
-    }
-
-    /* Find the node (#T, #i) that reaches EOS with the maximum score. */
-    max_score = -FLOAT_MAX;
-    prev = ALPHA_SCORE(ctx, T - 1);
-    /* Set a score for T-1 to be overwritten later. Just in case we don't
-       end up with something beating -FLOAT_MAX. */
-    labels[T - 1] = 0;
-    for (i = 0; i < L; ++i)
-    {
-        if (max_score < prev[i])
-        {
-            max_score = prev[i];
-            labels[T - 1] = i; /* Tag the item #T. */
-        }
-    }
-
-    /* Tag labels by tracing the backward links. */
-    for (t = T - 2; 0 <= t; --t)
-    {
-        back = BACKWARD_EDGE_AT(ctx, t + 1);
-        labels[t] = back[labels[t + 1]];
-    }
-
-    /* Return the maximum score (without the normalization factor subtracted). */
-    return max_score;
-}
-
-static void check_values(FILE *fp, floatval_t cv, floatval_t tv)
-{
-    if (fabs(cv - tv) < 1e-9)
-    {
-        fprintf(fp, "OK (%f)\n", cv);
-    }
-    else
-    {
-        fprintf(fp, "FAIL: %f (%f)\n", cv, tv);
-    }
-}
-
-void crf1dc_debug_context(FILE *fp)
-{
-    int y1, y2, y3;
-    floatval_t norm = 0;
-    const int L = 3;
-    const int T = 3;
-    crf1d_context_t *ctx = crf1dc_new(CTXF_MARGINALS, L, T);
-    floatval_t *trans = NULL, *state = NULL;
-    floatval_t scores[3][3][3];
-    int labels[3];
-
-    /* Initialize the state scores. */
-    state = EXP_STATE_SCORE(ctx, 0);
-    state[0] = .4;
-    state[1] = .5;
-    state[2] = .1;
-    state = EXP_STATE_SCORE(ctx, 1);
-    state[0] = .4;
-    state[1] = .1;
-    state[2] = .5;
-    state = EXP_STATE_SCORE(ctx, 2);
-    state[0] = .4;
-    state[1] = .1;
-    state[2] = .5;
-
-    /* Initialize the transition scores. */
-    trans = EXP_TRANS_SCORE(ctx, 0);
-    trans[0] = .3;
-    trans[1] = .1;
-    trans[2] = .4;
-    trans = EXP_TRANS_SCORE(ctx, 1);
-    trans[0] = .6;
-    trans[1] = .2;
-    trans[2] = .1;
-    trans = EXP_TRANS_SCORE(ctx, 2);
-    trans[0] = .5;
-    trans[1] = .2;
-    trans[2] = .1;
-
-    ctx->num_items = ctx->cap_items;
-    crf1dc_alpha_score(ctx);
-    crf1dc_beta_score(ctx);
-
-    /* Compute the score of every label sequence. */
-    for (y1 = 0; y1 < L; ++y1)
-    {
-        floatval_t s1 = EXP_STATE_SCORE(ctx, 0)[y1];
-        for (y2 = 0; y2 < L; ++y2)
-        {
-            floatval_t s2 = s1;
-            s2 *= EXP_TRANS_SCORE(ctx, y1)[y2];
-            s2 *= EXP_STATE_SCORE(ctx, 1)[y2];
-            for (y3 = 0; y3 < L; ++y3)
-            {
-                floatval_t s3 = s2;
-                s3 *= EXP_TRANS_SCORE(ctx, y2)[y3];
-                s3 *= EXP_STATE_SCORE(ctx, 2)[y3];
-                scores[y1][y2][y3] = s3;
-            }
-        }
-    }
-
-    /* Compute the partition factor. */
-    norm = 0.;
-    for (y1 = 0; y1 < L; ++y1)
-    {
-        for (y2 = 0; y2 < L; ++y2)
-        {
-            for (y3 = 0; y3 < L; ++y3)
-            {
-                norm += scores[y1][y2][y3];
-            }
-        }
-    }
-
-    /* Check the partition factor. */
-    fprintf(fp, "Check for the partition factor... ");
-    check_values(fp, exp(ctx->log_norm), norm);
-
-    /* Compute the sequence probabilities. */
-    for (y1 = 0; y1 < L; ++y1)
-    {
-        for (y2 = 0; y2 < L; ++y2)
-        {
-            for (y3 = 0; y3 < L; ++y3)
-            {
-                floatval_t logp;
-
-                labels[0] = y1;
-                labels[1] = y2;
-                labels[2] = y3;
-                logp = crf1dc_score(ctx, labels) - crf1dc_lognorm(ctx);
-
-                fprintf(fp, "Check for the sequence %d-%d-%d... ", y1, y2, y3);
-                check_values(fp, exp(logp), scores[y1][y2][y3] / norm);
-            }
-        }
-    }
-
-    /* Compute the marginal probability at t=0 */
-    for (y1 = 0; y1 < L; ++y1)
-    {
-        floatval_t a, b, c, s = 0.;
-        for (y2 = 0; y2 < L; ++y2)
-        {
-            for (y3 = 0; y3 < L; ++y3)
-            {
-                s += scores[y1][y2][y3];
-            }
-        }
-
-        a = ALPHA_SCORE(ctx, 0)[y1];
-        b = BETA_SCORE(ctx, 0)[y1];
-        c = 1. / ctx->scale_factor[0];
-
-        fprintf(fp, "Check for the marginal probability (0,%d)... ", y1);
-        check_values(fp, a * b * c, s / norm);
-    }
-
-    /* Compute the marginal probability at t=1 */
-    for (y2 = 0; y2 < L; ++y2)
-    {
-        floatval_t a, b, c, s = 0.;
-        for (y1 = 0; y1 < L; ++y1)
-        {
-            for (y3 = 0; y3 < L; ++y3)
-            {
-                s += scores[y1][y2][y3];
-            }
-        }
-
-        a = ALPHA_SCORE(ctx, 1)[y2];
-        b = BETA_SCORE(ctx, 1)[y2];
-        c = 1. / ctx->scale_factor[1];
-
-        fprintf(fp, "Check for the marginal probability (1,%d)... ", y2);
-        check_values(fp, a * b * c, s / norm);
-    }
-
-    /* Compute the marginal probability at t=2 */
-    for (y3 = 0; y3 < L; ++y3)
-    {
-        floatval_t a, b, c, s = 0.;
-        for (y1 = 0; y1 < L; ++y1)
-        {
-            for (y2 = 0; y2 < L; ++y2)
-            {
-                s += scores[y1][y2][y3];
-            }
-        }
-
-        a = ALPHA_SCORE(ctx, 2)[y3];
-        b = BETA_SCORE(ctx, 2)[y3];
-        c = 1. / ctx->scale_factor[2];
-
-        fprintf(fp, "Check for the marginal probability (2,%d)... ", y3);
-        check_values(fp, a * b * c, s / norm);
-    }
-
-    /* Compute the marginal probabilities of transitions. */
-    for (y1 = 0; y1 < L; ++y1)
-    {
-        for (y2 = 0; y2 < L; ++y2)
-        {
-            floatval_t a, b, s, t, p = 0.;
-            for (y3 = 0; y3 < L; ++y3)
-            {
-                p += scores[y1][y2][y3];
-            }
-
-            a = ALPHA_SCORE(ctx, 0)[y1];
-            b = BETA_SCORE(ctx, 1)[y2];
-            s = EXP_STATE_SCORE(ctx, 1)[y2];
-            t = EXP_TRANS_SCORE(ctx, y1)[y2];
-
-            fprintf(fp, "Check for the marginal probability (0,%d)-(1,%d)... ", y1, y2);
-            check_values(fp, a * t * s * b, p / norm);
-        }
-    }
-
-    for (y2 = 0; y2 < L; ++y2)
-    {
-        for (y3 = 0; y3 < L; ++y3)
-        {
-            floatval_t a, b, s, t, p = 0.;
-            for (y1 = 0; y1 < L; ++y1)
-            {
-                p += scores[y1][y2][y3];
-            }
-
-            a = ALPHA_SCORE(ctx, 1)[y2];
-            b = BETA_SCORE(ctx, 2)[y3];
-            s = EXP_STATE_SCORE(ctx, 2)[y3];
-            t = EXP_TRANS_SCORE(ctx, y2)[y3];
-
-            fprintf(fp, "Check for the marginal probability (1,%d)-(2,%d)... ", y2, y3);
-            check_values(fp, a * t * s * b, p / norm);
-        }
-    }
-}
+/*
+ *      CRF1d context (forward-backward, viterbi, etc).
+ *
+ * Copyright (c) 2007-2010, Naoaki Okazaki
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the names of the authors nor the names of its contributors
+ *       may be used to endorse or promote products derived from this
+ *       software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+ * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/* $Id$ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif /*HAVE_CONFIG_H*/
+
+#include <os.h>
+
+#include <float.h>
+#include <math.h>
+#include <stdio.h>
+#include <stdlib.h>
+
+#include <crfsuite.h>
+
+#include "crf1d.h"
+#include "vecmath.h"
+
+crf1d_context_t *crf1dc_new(int flag, int L, int T)
+{
+    int ret = 0;
+    crf1d_context_t *ctx = NULL;
+
+    ctx = (crf1d_context_t *)calloc(1, sizeof(crf1d_context_t));
+    if (ctx != NULL)
+    {
+        ctx->flag = flag;
+        ctx->num_labels = L;
+
+        ctx->trans = (floatval_t *)calloc(L * L, sizeof(floatval_t));
+        if (ctx->trans == NULL)
+            goto error_exit;
+
+        if (ctx->flag & CTXF_MARGINALS)
+        {
+            ctx->exp_trans = (floatval_t *)_aligned_malloc((L * L + 4) * sizeof(floatval_t), 16);
+            if (ctx->exp_trans == NULL)
+                goto error_exit;
+            ctx->mexp_trans = (floatval_t *)calloc(L * L, sizeof(floatval_t));
+            if (ctx->mexp_trans == NULL)
+                goto error_exit;
+        }
+
+        if (ret = crf1dc_set_num_items(ctx, T))
+        {
+            goto error_exit;
+        }
+
+        /* T gives the 'hint' for maximum length of items. */
+        ctx->num_items = 0;
+    }
+
+    return ctx;
+
+error_exit:
+    crf1dc_delete(ctx);
+    return NULL;
+}
+
+int crf1dc_set_num_items(crf1d_context_t *ctx, int T)
+{
+    const int L = ctx->num_labels;
+
+    ctx->num_items = T;
+
+    if (ctx->cap_items < T)
+    {
+        free(ctx->backward_edge);
+        free(ctx->mexp_state);
+        _aligned_free(ctx->exp_state);
+        free(ctx->scale_factor);
+        free(ctx->row);
+        free(ctx->beta_score);
+        free(ctx->alpha_score);
+        free(ctx->state);
+
+        ctx->alpha_score = (floatval_t *)calloc(T * L, sizeof(floatval_t));
+        if (ctx->alpha_score == NULL)
+            return CRFSUITEERR_OUTOFMEMORY;
+        ctx->beta_score = (floatval_t *)calloc(T * L, sizeof(floatval_t));
+        if (ctx->beta_score == NULL)
+            return CRFSUITEERR_OUTOFMEMORY;
+        ctx->scale_factor = (floatval_t *)calloc(T, sizeof(floatval_t));
+        if (ctx->scale_factor == NULL)
+            return CRFSUITEERR_OUTOFMEMORY;
+        ctx->row = (floatval_t *)calloc(L, sizeof(floatval_t));
+        if (ctx->row == NULL)
+            return CRFSUITEERR_OUTOFMEMORY;
+
+        if (ctx->flag & CTXF_VITERBI)
+        {
+            ctx->backward_edge = (int *)calloc(T * L, sizeof(int));
+            if (ctx->backward_edge == NULL)
+                return CRFSUITEERR_OUTOFMEMORY;
+        }
+
+        ctx->state = (floatval_t *)calloc(T * L, sizeof(floatval_t));
+        if (ctx->state == NULL)
+            return CRFSUITEERR_OUTOFMEMORY;
+
+        if (ctx->flag & CTXF_MARGINALS)
+        {
+            ctx->exp_state = (floatval_t *)_aligned_malloc((T * L + 4) * sizeof(floatval_t), 16);
+            if (ctx->exp_state == NULL)
+                return CRFSUITEERR_OUTOFMEMORY;
+            ctx->mexp_state = (floatval_t *)calloc(T * L, sizeof(floatval_t));
+            if (ctx->mexp_state == NULL)
+                return CRFSUITEERR_OUTOFMEMORY;
+        }
+
+        ctx->cap_items = T;
+    }
+
+    return 0;
+}
+
+void crf1dc_delete(crf1d_context_t *ctx)
+{
+    if (ctx != NULL)
+    {
+        free(ctx->backward_edge);
+        free(ctx->mexp_state);
+        _aligned_free(ctx->exp_state);
+        free(ctx->state);
+        free(ctx->scale_factor);
+        free(ctx->row);
+        free(ctx->beta_score);
+        free(ctx->alpha_score);
+        free(ctx->mexp_trans);
+        _aligned_free(ctx->exp_trans);
+        free(ctx->trans);
+    }
+    free(ctx);
+}
+
+void crf1dc_reset(crf1d_context_t *ctx, int flag)
+{
+    const int T = ctx->num_items;
+    const int L = ctx->num_labels;
+
+    if (flag & RF_STATE)
+    {
+        veczero(ctx->state, T * L);
+    }
+    if (flag & RF_TRANS)
+    {
+        veczero(ctx->trans, L * L);
+    }
+
+    if (ctx->flag & CTXF_MARGINALS)
+    {
+        veczero(ctx->mexp_state, T * L);
+        veczero(ctx->mexp_trans, L * L);
+        ctx->log_norm = 0;
+    }
+}
+
+void crf1dc_exp_state(crf1d_context_t *ctx)
+{
+    const int T = ctx->num_items;
+    const int L = ctx->num_labels;
+
+    veccopy(ctx->exp_state, ctx->state, L * T);
+    vecexp(ctx->exp_state, L * T);
+}
+
+void crf1dc_exp_transition(crf1d_context_t *ctx)
+{
+    const int L = ctx->num_labels;
+
+    veccopy(ctx->exp_trans, ctx->trans, L * L);
+    vecexp(ctx->exp_trans, L * L);
+}
+
+void crf1dc_alpha_score(crf1d_context_t *ctx)
+{
+    int i, t;
+    floatval_t sum, *cur = NULL;
+    floatval_t *scale = &ctx->scale_factor[0];
+    const floatval_t *prev = NULL, *trans = NULL, *state = NULL;
+    const int T = ctx->num_items;
+    const int L = ctx->num_labels;
+
+    /* Compute the alpha scores on nodes (0, *).
+        alpha[0][j] = state[0][j]
+     */
+    cur = ALPHA_SCORE(ctx, 0);
+    state = EXP_STATE_SCORE(ctx, 0);
+    veccopy(cur, state, L);
+    sum = vecsum(cur, L);
+    *scale = (sum != 0.) ? 1. / sum : 1.;
+    vecscale(cur, *scale, L);
+    ++scale;
+
+    /* Compute the alpha scores on nodes (t, *).
+        alpha[t][j] = state[t][j] * \sum_{i} alpha[t-1][i] * trans[i][j]
+     */
+    for (t = 1; t < T; ++t)
+    {
+        prev = ALPHA_SCORE(ctx, t - 1);
+        cur = ALPHA_SCORE(ctx, t);
+        state = EXP_STATE_SCORE(ctx, t);
+
+        veczero(cur, L);
+        for (i = 0; i < L; ++i)
+        {
+            trans = EXP_TRANS_SCORE(ctx, i);
+            vecaadd(cur, prev[i], trans, L);
+        }
+        vecmul(cur, state, L);
+        sum = vecsum(cur, L);
+        *scale = (sum != 0.) ? 1. / sum : 1.;
+        vecscale(cur, *scale, L);
+        ++scale;
+    }
+
+    /* Compute the logarithm of the normalization factor here.
+        norm = 1. / (C[0] * C[1] ... * C[T-1])
+        log(norm) = - \sum_{t = 0}^{T-1} log(C[t]).
+     */
+    ctx->log_norm = -vecsumlog(ctx->scale_factor, T);
+}
+
+void crf1dc_beta_score(crf1d_context_t *ctx)
+{
+    int i, t;
+    floatval_t *cur = NULL;
+    floatval_t *row = ctx->row;
+    const floatval_t *next = NULL, *state = NULL, *trans = NULL;
+    const int T = ctx->num_items;
+    const int L = ctx->num_labels;
+    const floatval_t *scale = &ctx->scale_factor[T - 1];
+
+    /* Compute the beta scores at (T-1, *). */
+    cur = BETA_SCORE(ctx, T - 1);
+    vecset(cur, *scale, L);
+    --scale;
+
+    /* Compute the beta scores at (t, *). */
+    for (t = T - 2; 0 <= t; --t)
+    {
+        cur = BETA_SCORE(ctx, t);
+        next = BETA_SCORE(ctx, t + 1);
+        state = EXP_STATE_SCORE(ctx, t + 1);
+
+        veccopy(row, next, L);
+        vecmul(row, state, L);
+
+        /* Compute the beta score at (t, i). */
+        for (i = 0; i < L; ++i)
+        {
+            trans = EXP_TRANS_SCORE(ctx, i);
+            cur[i] = vecdot(trans, row, L);
+        }
+        vecscale(cur, *scale, L);
+        --scale;
+    }
+}
+
+void crf1dc_marginals(crf1d_context_t *ctx)
+{
+    int i, j, t;
+    const int T = ctx->num_items;
+    const int L = ctx->num_labels;
+
+    /*
+        Compute the model expectations of states.
+            p(t,i) = fwd[t][i] * bwd[t][i] / norm
+                   = (1. / C[t]) * fwd'[t][i] * bwd'[t][i]
+     */
+    for (t = 0; t < T; ++t)
+    {
+        floatval_t *fwd = ALPHA_SCORE(ctx, t);
+        floatval_t *bwd = BETA_SCORE(ctx, t);
+        floatval_t *prob = STATE_MEXP(ctx, t);
+        veccopy(prob, fwd, L);
+        vecmul(prob, bwd, L);
+        vecscale(prob, 1. / ctx->scale_factor[t], L);
+    }
+
+    /*
+        Compute the model expectations of transitions.
+            p(t,i,t+1,j)
+                = fwd[t][i] * edge[i][j] * state[t+1][j] * bwd[t+1][j] / norm
+                = (fwd'[t][i] / (C[0] ... C[t])) * edge[i][j] * state[t+1][j] * (bwd'[t+1][j] / (C[t+1] ... C[T-1])) * (C[0] * ... * C[T-1])
+                = fwd'[t][i] * edge[i][j] * state[t+1][j] * bwd'[t+1][j]
+        The model expectation of a transition (i -> j) is the sum of the marginal
+        probabilities p(t,i,t+1,j) over t.
+     */
+    for (t = 0; t < T - 1; ++t)
+    {
+        floatval_t *fwd = ALPHA_SCORE(ctx, t);
+        floatval_t *state = EXP_STATE_SCORE(ctx, t + 1);
+        floatval_t *bwd = BETA_SCORE(ctx, t + 1);
+        floatval_t *row = ctx->row;
+
+        /* row[j] = state[t+1][j] * bwd'[t+1][j] */
+        veccopy(row, bwd, L);
+        vecmul(row, state, L);
+
+        for (i = 0; i < L; ++i)
+        {
+            floatval_t *edge = EXP_TRANS_SCORE(ctx, i);
+            floatval_t *prob = TRANS_MEXP(ctx, i);
+            for (j = 0; j < L; ++j)
+            {
+                prob[j] += fwd[i] * edge[j] * row[j];
+            }
+        }
+    }
+}
+
+floatval_t crf1dc_marginal_point(crf1d_context_t *ctx, int l, int t)
+{
+    floatval_t *fwd = ALPHA_SCORE(ctx, t);
+    floatval_t *bwd = BETA_SCORE(ctx, t);
+    return fwd[l] * bwd[l] / ctx->scale_factor[t];
+}
+
+floatval_t crf1dc_marginal_path(crf1d_context_t *ctx, const int *path, int begin, int end)
+{
+    int t;
+    /*
+        Compute the marginal probability of a (partial) path.
+            a = path[begin], b = path[begin+1], ..., y = path[end-2], z = path[end-1]
+            fwd[begin][a] = (fwd'[begin][a] / (C[0] ... C[begin])
+            bwd[end-1][z] = (bwd'[end-1][z] / (C[end-1] ... C[T-1]))
+            norm = 1 / (C[0] * ... * C[T-1])
+            p(a, b, ..., z)
+                = fwd[begin][a] * edge[a][b] * state[begin+1][b] * ... * edge[y][z] * state[end-1][z] * bwd[end-1][z] / norm
+                = fwd'[begin][a] * edge[a][b] * state[begin+1][b] * ... * edge[y][z] * state[end-1][z] * bwd'[end-1][z] * (C[begin+1] * ... * C[end-2])
+     */
+    floatval_t *fwd = ALPHA_SCORE(ctx, begin);
+    floatval_t *bwd = BETA_SCORE(ctx, end - 1);
+    floatval_t prob = fwd[path[begin]] * bwd[path[end - 1]] / ctx->scale_factor[begin];
+
+    for (t = begin; t < end - 1; ++t)
+    {
+        floatval_t *state = EXP_STATE_SCORE(ctx, t + 1);
+        floatval_t *edge = EXP_TRANS_SCORE(ctx, path[t]);
+        prob *= (edge[path[t + 1]] * state[path[t + 1]] * ctx->scale_factor[t]);
+    }
+
+    return prob;
+}
+
+#if 0
+/* Sigh, this was found to be slower than the forward-backward algorithm. */
+
+#define ADJACENCY(ctx, i) \
+    (&MATRIX(ctx->adj, ctx->num_labels, 0, i))
+
+void crf1dc_marginal_without_beta(crf1d_context_t* ctx)
+{
+    int i, j, t;
+    floatval_t *prob = NULL;
+    floatval_t *row = ctx->row;
+    const floatval_t *fwd = NULL;
+    const int T = ctx->num_items;
+    const int L = ctx->num_labels;
+
+    /*
+        Compute marginal probabilities of states at T-1
+            p(T-1,j) = fwd'[T-1][j]
+     */
+    fwd = ALPHA_SCORE(ctx, T-1);
+    prob = STATE_MEXP(ctx, T-1);
+    veccopy(prob, fwd, L);
+
+    /*
+        Repeat the following computation for t = T-1,T-2, ..., 1.
+            1) Compute p(t-1,i,t,j) using p(t,j)
+            2) Compute p(t,i) using p(t-1,i,t,j)
+     */
+    for (t = T-1;0 < t;--t) {
+        fwd = ALPHA_SCORE(ctx, t-1);
+        prob = STATE_MEXP(ctx, t);
+
+        veczero(ctx->adj, L*L);
+        veczero(row, L);
+
+        /*
+            Compute adj[i][j] and row[j].
+                adj[i][j] = fwd'[t-1][i] * edge[i][j]
+                row[j] = \sum_{i} adj[i][j]
+         */
+        for (i = 0;i < L;++i) {
+            floatval_t *adj = ADJACENCY(ctx, i);
+            floatval_t *edge = EXP_TRANS_SCORE(ctx, i);
+            vecaadd(adj, fwd[i], edge, L);
+            vecadd(row, adj, L);
+        }
+
+        /*
+            Find z such that z * \sum_{i] adj[i][j] = p(t,j).
+            Thus, z = p(t,j) / row[j]; we overwrite row with z.
+         */
+        vecinv(row, L);
+        vecmul(row, prob, L);
+
+        /*
+            Apply the partition factor z (row[j]) to adj[i][j].
+         */
+        for (i = 0;i < L;++i) {
+            floatval_t *adj = ADJACENCY(ctx, i);
+            vecmul(adj, row, L);
+        }
+
+        /*
+            Now that adj[i][j] presents p(t-1,i,t,j),
+            accumulate model expectations of transitions.
+         */
+        for (i = 0;i < L;++i) {
+            floatval_t *adj = ADJACENCY(ctx, i);
+            floatval_t *prob = TRANS_MEXP(ctx, i);
+            vecadd(prob, adj, L);
+        }
+
+        /*
+            Compute the marginal probability of states at t-1.
+                p(t-1,i) = \sum_{j} p(t-1,i,t,j)
+         */
+        prob = STATE_MEXP(ctx, t-1);
+        for (i = 0;i < L;++i) {
+            floatval_t *adj = ADJACENCY(ctx, i);
+            prob[i] = vecsum(adj, L);
+        }
+    }
+}
+#endif
+
+floatval_t crf1dc_score(crf1d_context_t *ctx, const int *labels)
+{
+    int i, j, t;
+    floatval_t ret = 0;
+    const floatval_t *state = NULL, *cur = NULL, *trans = NULL;
+    const int T = ctx->num_items;
+    const int L = ctx->num_labels;
+
+    /* Stay at (0, labels[0]). */
+    i = labels[0];
+    state = STATE_SCORE(ctx, 0);
+    ret = state[i];
+
+    /* Loop over the rest of items. */
+    for (t = 1; t < T; ++t)
+    {
+        j = labels[t];
+        trans = TRANS_SCORE(ctx, i);
+        state = STATE_SCORE(ctx, t);
+
+        /* Transit from (t-1, i) to (t, j). */
+        ret += trans[j];
+        ret += state[j];
+        i = j;
+    }
+    return ret;
+}
+
+floatval_t crf1dc_lognorm(crf1d_context_t *ctx)
+{
+    return ctx->log_norm;
+}
+
+floatval_t crf1dc_viterbi(crf1d_context_t *ctx, int *labels)
+{
+    int i, j, t;
+    int *back = NULL;
+    floatval_t max_score, score, *cur = NULL;
+    int argmax_score;
+    const floatval_t *prev = NULL, *state = NULL, *trans = NULL;
+    const int T = ctx->num_items;
+    const int L = ctx->num_labels;
+
+    /*
+        This function assumes state and trans scores to be in the logarithm domain.
+     */
+
+    /* Compute the scores at (0, *). */
+    cur = ALPHA_SCORE(ctx, 0);
+    state = STATE_SCORE(ctx, 0);
+    for (j = 0; j < L; ++j)
+    {
+        cur[j] = state[j];
+    }
+
+    /* Compute the scores at (t, *). */
+    for (t = 1; t < T; ++t)
+    {
+        prev = ALPHA_SCORE(ctx, t - 1);
+        cur = ALPHA_SCORE(ctx, t);
+        state = STATE_SCORE(ctx, t);
+        back = BACKWARD_EDGE_AT(ctx, t);
+
+        /* Compute the score of (t, j). */
+        for (j = 0; j < L; ++j)
+        {
+            max_score = -FLOAT_MAX;
+            argmax_score = -1;
+            for (i = 0; i < L; ++i)
+            {
+                /* Transit from (t-1, i) to (t, j). */
+                trans = TRANS_SCORE(ctx, i);
+                score = prev[i] + trans[j];
+
+                /* Store this path if it has the maximum score. */
+                if (max_score < score)
+                {
+                    max_score = score;
+                    argmax_score = i;
+                }
+            }
+            /* Backward link (#t, #j) -> (#t-1, #i). */
+            if (argmax_score >= 0)
+                back[j] = argmax_score;
+            /* Add the state score on (t, j). */
+            cur[j] = max_score + state[j];
+        }
+    }
+
+    /* Find the node (#T, #i) that reaches EOS with the maximum score. */
+    max_score = -FLOAT_MAX;
+    prev = ALPHA_SCORE(ctx, T - 1);
+    /* Set a score for T-1 to be overwritten later. Just in case we don't
+       end up with something beating -FLOAT_MAX. */
+    labels[T - 1] = 0;
+    for (i = 0; i < L; ++i)
+    {
+        if (max_score < prev[i])
+        {
+            max_score = prev[i];
+            labels[T - 1] = i; /* Tag the item #T. */
+        }
+    }
+
+    /* Tag labels by tracing the backward links. */
+    for (t = T - 2; 0 <= t; --t)
+    {
+        back = BACKWARD_EDGE_AT(ctx, t + 1);
+        labels[t] = back[labels[t + 1]];
+    }
+
+    /* Return the maximum score (without the normalization factor subtracted). */
+    return max_score;
+}
+
+static void check_values(FILE *fp, floatval_t cv, floatval_t tv)
+{
+    if (fabs(cv - tv) < 1e-9)
+    {
+        fprintf(fp, "OK (%f)\n", cv);
+    }
+    else
+    {
+        fprintf(fp, "FAIL: %f (%f)\n", cv, tv);
+    }
+}
+
+void crf1dc_debug_context(FILE *fp)
+{
+    int y1, y2, y3;
+    floatval_t norm = 0;
+    const int L = 3;
+    const int T = 3;
+    crf1d_context_t *ctx = crf1dc_new(CTXF_MARGINALS, L, T);
+    floatval_t *trans = NULL, *state = NULL;
+    floatval_t scores[3][3][3];
+    int labels[3];
+
+    /* Initialize the state scores. */
+    state = EXP_STATE_SCORE(ctx, 0);
+    state[0] = .4;
+    state[1] = .5;
+    state[2] = .1;
+    state = EXP_STATE_SCORE(ctx, 1);
+    state[0] = .4;
+    state[1] = .1;
+    state[2] = .5;
+    state = EXP_STATE_SCORE(ctx, 2);
+    state[0] = .4;
+    state[1] = .1;
+    state[2] = .5;
+
+    /* Initialize the transition scores. */
+    trans = EXP_TRANS_SCORE(ctx, 0);
+    trans[0] = .3;
+    trans[1] = .1;
+    trans[2] = .4;
+    trans = EXP_TRANS_SCORE(ctx, 1);
+    trans[0] = .6;
+    trans[1] = .2;
+    trans[2] = .1;
+    trans = EXP_TRANS_SCORE(ctx, 2);
+    trans[0] = .5;
+    trans[1] = .2;
+    trans[2] = .1;
+
+    ctx->num_items = ctx->cap_items;
+    crf1dc_alpha_score(ctx);
+    crf1dc_beta_score(ctx);
+
+    /* Compute the score of every label sequence. */
+    for (y1 = 0; y1 < L; ++y1)
+    {
+        floatval_t s1 = EXP_STATE_SCORE(ctx, 0)[y1];
+        for (y2 = 0; y2 < L; ++y2)
+        {
+            floatval_t s2 = s1;
+            s2 *= EXP_TRANS_SCORE(ctx, y1)[y2];
+            s2 *= EXP_STATE_SCORE(ctx, 1)[y2];
+            for (y3 = 0; y3 < L; ++y3)
+            {
+                floatval_t s3 = s2;
+                s3 *= EXP_TRANS_SCORE(ctx, y2)[y3];
+                s3 *= EXP_STATE_SCORE(ctx, 2)[y3];
+                scores[y1][y2][y3] = s3;
+            }
+        }
+    }
+
+    /* Compute the partition factor. */
+    norm = 0.;
+    for (y1 = 0; y1 < L; ++y1)
+    {
+        for (y2 = 0; y2 < L; ++y2)
+        {
+            for (y3 = 0; y3 < L; ++y3)
+            {
+                norm += scores[y1][y2][y3];
+            }
+        }
+    }
+
+    /* Check the partition factor. */
+    fprintf(fp, "Check for the partition factor... ");
+    check_values(fp, exp(ctx->log_norm), norm);
+
+    /* Compute the sequence probabilities. */
+    for (y1 = 0; y1 < L; ++y1)
+    {
+        for (y2 = 0; y2 < L; ++y2)
+        {
+            for (y3 = 0; y3 < L; ++y3)
+            {
+                floatval_t logp;
+
+                labels[0] = y1;
+                labels[1] = y2;
+                labels[2] = y3;
+                logp = crf1dc_score(ctx, labels) - crf1dc_lognorm(ctx);
+
+                fprintf(fp, "Check for the sequence %d-%d-%d... ", y1, y2, y3);
+                check_values(fp, exp(logp), scores[y1][y2][y3] / norm);
+            }
+        }
+    }
+
+    /* Compute the marginal probability at t=0 */
+    for (y1 = 0; y1 < L; ++y1)
+    {
+        floatval_t a, b, c, s = 0.;
+        for (y2 = 0; y2 < L; ++y2)
+        {
+            for (y3 = 0; y3 < L; ++y3)
+            {
+                s += scores[y1][y2][y3];
+            }
+        }
+
+        a = ALPHA_SCORE(ctx, 0)[y1];
+        b = BETA_SCORE(ctx, 0)[y1];
+        c = 1. / ctx->scale_factor[0];
+
+        fprintf(fp, "Check for the marginal probability (0,%d)... ", y1);
+        check_values(fp, a * b * c, s / norm);
+    }
+
+    /* Compute the marginal probability at t=1 */
+    for (y2 = 0; y2 < L; ++y2)
+    {
+        floatval_t a, b, c, s = 0.;
+        for (y1 = 0; y1 < L; ++y1)
+        {
+            for (y3 = 0; y3 < L; ++y3)
+            {
+                s += scores[y1][y2][y3];
+            }
+        }
+
+        a = ALPHA_SCORE(ctx, 1)[y2];
+        b = BETA_SCORE(ctx, 1)[y2];
+        c = 1. / ctx->scale_factor[1];
+
+        fprintf(fp, "Check for the marginal probability (1,%d)... ", y2);
+        check_values(fp, a * b * c, s / norm);
+    }
+
+    /* Compute the marginal probability at t=2 */
+    for (y3 = 0; y3 < L; ++y3)
+    {
+        floatval_t a, b, c, s = 0.;
+        for (y1 = 0; y1 < L; ++y1)
+        {
+            for (y2 = 0; y2 < L; ++y2)
+            {
+                s += scores[y1][y2][y3];
+            }
+        }
+
+        a = ALPHA_SCORE(ctx, 2)[y3];
+        b = BETA_SCORE(ctx, 2)[y3];
+        c = 1. / ctx->scale_factor[2];
+
+        fprintf(fp, "Check for the marginal probability (2,%d)... ", y3);
+        check_values(fp, a * b * c, s / norm);
+    }
+
+    /* Compute the marginal probabilities of transitions. */
+    for (y1 = 0; y1 < L; ++y1)
+    {
+        for (y2 = 0; y2 < L; ++y2)
+        {
+            floatval_t a, b, s, t, p = 0.;
+            for (y3 = 0; y3 < L; ++y3)
+            {
+                p += scores[y1][y2][y3];
+            }
+
+            a = ALPHA_SCORE(ctx, 0)[y1];
+            b = BETA_SCORE(ctx, 1)[y2];
+            s = EXP_STATE_SCORE(ctx, 1)[y2];
+            t = EXP_TRANS_SCORE(ctx, y1)[y2];
+
+            fprintf(fp, "Check for the marginal probability (0,%d)-(1,%d)... ", y1, y2);
+            check_values(fp, a * t * s * b, p / norm);
+        }
+    }
+
+    for (y2 = 0; y2 < L; ++y2)
+    {
+        for (y3 = 0; y3 < L; ++y3)
+        {
+            floatval_t a, b, s, t, p = 0.;
+            for (y1 = 0; y1 < L; ++y1)
+            {
+                p += scores[y1][y2][y3];
+            }
+
+            a = ALPHA_SCORE(ctx, 1)[y2];
+            b = BETA_SCORE(ctx, 2)[y3];
+            s = EXP_STATE_SCORE(ctx, 2)[y3];
+            t = EXP_TRANS_SCORE(ctx, y2)[y3];
+
+            fprintf(fp, "Check for the marginal probability (1,%d)-(2,%d)... ", y2, y3);
+            check_values(fp, a * t * s * b, p / norm);
+        }
+    }
+}
```

## chaine/_core/crfsuite/lib/crf/src/crf1d_encode.c

 * *Ordering differences only*

```diff
@@ -1,1020 +1,1020 @@
-/*
- *      CRF1d encoder (routines for training).
- *
- * Copyright (c) 2007-2010, Naoaki Okazaki
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the names of the authors nor the names of its contributors
- *       may be used to endorse or promote products derived from this
- *       software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
- * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-/* $Id$ */
-
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif /*HAVE_CONFIG_H*/
-
-#include <os.h>
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <memory.h>
-#include <time.h>
-
-#include <crfsuite.h>
-#include "crfsuite_internal.h"
-#include "crf1d.h"
-#include "params.h"
-#include "logging.h"
-
-/**
- * Parameters for feature generation.
- */
-typedef struct
-{
-    floatval_t feature_minfreq;       /** The threshold for occurrences of features. */
-    int feature_possible_states;      /** Dense state features. */
-    int feature_possible_transitions; /** Dense transition features. */
-} crf1de_option_t;
-
-/**
- * CRF1d internal data.
- */
-typedef struct
-{
-    int num_labels;     /**< Number of distinct output labels (L). */
-    int num_attributes; /**< Number of distinct attributes (A). */
-
-    int cap_items; /**< Maximum length of sequences in the data set. */
-
-    int num_features;              /**< Number of distinct features (K). */
-    crf1df_feature_t *features;    /**< Array of feature descriptors [K]. */
-    feature_refs_t *attributes;    /**< References to attribute features [A]. */
-    feature_refs_t *forward_trans; /**< References to transition features [L]. */
-
-    crf1d_context_t *ctx; /**< CRF1d context. */
-    crf1de_option_t opt;  /**< CRF1d options. */
-} crf1de_t;
-
-#define FEATURE(crf1de, k) \
-    (&(crf1de)->features[(k)])
-#define ATTRIBUTE(crf1de, a) \
-    (&(crf1de)->attributes[(a)])
-#define TRANSITION(crf1de, i) \
-    (&(crf1de)->forward_trans[(i)])
-
-static void crf1de_init(crf1de_t *crf1de)
-{
-    crf1de->num_labels = 0;
-    crf1de->num_attributes = 0;
-    crf1de->cap_items = 0;
-    crf1de->num_features = 0;
-    crf1de->features = NULL;
-    crf1de->attributes = NULL;
-    crf1de->forward_trans = NULL;
-    crf1de->ctx = NULL;
-    /* Initialize except for opt. */
-}
-
-static void crf1de_finish(crf1de_t *crf1de)
-{
-    int i;
-
-    if (crf1de->ctx != NULL)
-    {
-        crf1dc_delete(crf1de->ctx);
-        crf1de->ctx = NULL;
-    }
-    if (crf1de->features != NULL)
-    {
-        free(crf1de->features);
-        crf1de->features = NULL;
-    }
-    if (crf1de->attributes != NULL)
-    {
-        for (i = 0; i < crf1de->num_attributes; ++i)
-        {
-            free(crf1de->attributes[i].fids);
-        }
-        free(crf1de->attributes);
-        crf1de->attributes = NULL;
-    }
-    if (crf1de->forward_trans != NULL)
-    {
-        for (i = 0; i < crf1de->num_labels; ++i)
-        {
-            free(crf1de->forward_trans[i].fids);
-        }
-        free(crf1de->forward_trans);
-        crf1de->forward_trans = NULL;
-    }
-}
-
-static void crf1de_state_score(
-    crf1de_t *crf1de,
-    const crfsuite_instance_t *inst,
-    const floatval_t *w)
-{
-    int i, t, r;
-    crf1d_context_t *ctx = crf1de->ctx;
-    const int T = inst->num_items;
-    const int L = crf1de->num_labels;
-
-    /* Loop over the items in the sequence. */
-    for (t = 0; t < T; ++t)
-    {
-        const crfsuite_item_t *item = &inst->items[t];
-        floatval_t *state = STATE_SCORE(ctx, t);
-
-        /* Loop over the contents (attributes) attached to the item. */
-        for (i = 0; i < item->num_contents; ++i)
-        {
-            /* Access the list of state features associated with the attribute. */
-            int a = item->contents[i].aid;
-            const feature_refs_t *attr = ATTRIBUTE(crf1de, a);
-            floatval_t value = item->contents[i].value;
-
-            /* Loop over the state features associated with the attribute. */
-            for (r = 0; r < attr->num_features; ++r)
-            {
-                /* State feature associates the attribute #a with the label #(f->dst). */
-                int fid = attr->fids[r];
-                const crf1df_feature_t *f = FEATURE(crf1de, fid);
-                state[f->dst] += w[fid] * value;
-            }
-        }
-    }
-}
-
-static void
-crf1de_state_score_scaled(
-    crf1de_t *crf1de,
-    const crfsuite_instance_t *inst,
-    const floatval_t *w,
-    const floatval_t scale)
-{
-    int i, t, r;
-    crf1d_context_t *ctx = crf1de->ctx;
-    const int T = inst->num_items;
-    const int L = crf1de->num_labels;
-
-    /* Forward to the non-scaling version for fast computation when scale == 1. */
-    if (scale == 1.)
-    {
-        crf1de_state_score(crf1de, inst, w);
-        return;
-    }
-
-    /* Loop over the items in the sequence. */
-    for (t = 0; t < T; ++t)
-    {
-        const crfsuite_item_t *item = &inst->items[t];
-        floatval_t *state = STATE_SCORE(ctx, t);
-
-        /* Loop over the contents (attributes) attached to the item. */
-        for (i = 0; i < item->num_contents; ++i)
-        {
-            /* Access the list of state features associated with the attribute. */
-            int a = item->contents[i].aid;
-            const feature_refs_t *attr = ATTRIBUTE(crf1de, a);
-            floatval_t value = item->contents[i].value * scale;
-
-            /* Loop over the state features associated with the attribute. */
-            for (r = 0; r < attr->num_features; ++r)
-            {
-                /* State feature associates the attribute #a with the label #(f->dst). */
-                int fid = attr->fids[r];
-                const crf1df_feature_t *f = FEATURE(crf1de, fid);
-                state[f->dst] += w[fid] * value;
-            }
-        }
-    }
-}
-
-static void
-crf1de_transition_score(
-    crf1de_t *crf1de,
-    const floatval_t *w)
-{
-    int i, r;
-    crf1d_context_t *ctx = crf1de->ctx;
-    const int L = crf1de->num_labels;
-
-    /* Compute transition scores between two labels. */
-    for (i = 0; i < L; ++i)
-    {
-        floatval_t *trans = TRANS_SCORE(ctx, i);
-        const feature_refs_t *edge = TRANSITION(crf1de, i);
-        for (r = 0; r < edge->num_features; ++r)
-        {
-            /* Transition feature from #i to #(f->dst). */
-            int fid = edge->fids[r];
-            const crf1df_feature_t *f = FEATURE(crf1de, fid);
-            trans[f->dst] = w[fid];
-        }
-    }
-}
-
-static void
-crf1de_transition_score_scaled(
-    crf1de_t *crf1de,
-    const floatval_t *w,
-    const floatval_t scale)
-{
-    int i, r;
-    crf1d_context_t *ctx = crf1de->ctx;
-    const int L = crf1de->num_labels;
-
-    /* Forward to the non-scaling version for fast computation when scale == 1. */
-    if (scale == 1.)
-    {
-        crf1de_transition_score(crf1de, w);
-        return;
-    }
-
-    /* Compute transition scores between two labels. */
-    for (i = 0; i < L; ++i)
-    {
-        floatval_t *trans = TRANS_SCORE(ctx, i);
-        const feature_refs_t *edge = TRANSITION(crf1de, i);
-        for (r = 0; r < edge->num_features; ++r)
-        {
-            /* Transition feature from #i to #(f->dst). */
-            int fid = edge->fids[r];
-            const crf1df_feature_t *f = FEATURE(crf1de, fid);
-            trans[f->dst] = w[fid] * scale;
-        }
-    }
-}
-
-static void
-crf1de_features_on_path(
-    crf1de_t *crf1de,
-    const crfsuite_instance_t *inst,
-    const int *labels,
-    crfsuite_encoder_features_on_path_callback func,
-    void *instance)
-{
-    int c, i = -1, t, r;
-    crf1d_context_t *ctx = crf1de->ctx;
-    const int T = inst->num_items;
-    const int L = crf1de->num_labels;
-
-    /* Loop over the items in the sequence. */
-    for (t = 0; t < T; ++t)
-    {
-        const crfsuite_item_t *item = &inst->items[t];
-        const int j = labels[t];
-
-        /* Loop over the contents (attributes) attached to the item. */
-        for (c = 0; c < item->num_contents; ++c)
-        {
-            /* Access the list of state features associated with the attribute. */
-            int a = item->contents[c].aid;
-            const feature_refs_t *attr = ATTRIBUTE(crf1de, a);
-            floatval_t value = item->contents[c].value;
-
-            /* Loop over the state features associated with the attribute. */
-            for (r = 0; r < attr->num_features; ++r)
-            {
-                /* State feature associates the attribute #a with the label #(f->dst). */
-                int fid = attr->fids[r];
-                const crf1df_feature_t *f = FEATURE(crf1de, fid);
-                if (f->dst == j)
-                {
-                    func(instance, fid, value);
-                }
-            }
-        }
-
-        if (i != -1)
-        {
-            const feature_refs_t *edge = TRANSITION(crf1de, i);
-            for (r = 0; r < edge->num_features; ++r)
-            {
-                /* Transition feature from #i to #(f->dst). */
-                int fid = edge->fids[r];
-                const crf1df_feature_t *f = FEATURE(crf1de, fid);
-                if (f->dst == j)
-                {
-                    func(instance, fid, 1.);
-                }
-            }
-        }
-
-        i = j;
-    }
-}
-
-static void
-crf1de_observation_expectation(
-    crf1de_t *crf1de,
-    const crfsuite_instance_t *inst,
-    const int *labels,
-    floatval_t *w,
-    const floatval_t scale)
-{
-    int c, i = -1, t, r;
-    crf1d_context_t *ctx = crf1de->ctx;
-    const int T = inst->num_items;
-    const int L = crf1de->num_labels;
-
-    /* Loop over the items in the sequence. */
-    for (t = 0; t < T; ++t)
-    {
-        const crfsuite_item_t *item = &inst->items[t];
-        const int j = labels[t];
-
-        /* Loop over the contents (attributes) attached to the item. */
-        for (c = 0; c < item->num_contents; ++c)
-        {
-            /* Access the list of state features associated with the attribute. */
-            int a = item->contents[c].aid;
-            const feature_refs_t *attr = ATTRIBUTE(crf1de, a);
-            floatval_t value = item->contents[c].value;
-
-            /* Loop over the state features associated with the attribute. */
-            for (r = 0; r < attr->num_features; ++r)
-            {
-                /* State feature associates the attribute #a with the label #(f->dst). */
-                int fid = attr->fids[r];
-                const crf1df_feature_t *f = FEATURE(crf1de, fid);
-                if (f->dst == j)
-                {
-                    w[fid] += value * scale;
-                }
-            }
-        }
-
-        if (i != -1)
-        {
-            const feature_refs_t *edge = TRANSITION(crf1de, i);
-            for (r = 0; r < edge->num_features; ++r)
-            {
-                /* Transition feature from #i to #(f->dst). */
-                int fid = edge->fids[r];
-                const crf1df_feature_t *f = FEATURE(crf1de, fid);
-                if (f->dst == j)
-                {
-                    w[fid] += scale;
-                }
-            }
-        }
-
-        i = j;
-    }
-}
-
-static void
-crf1de_model_expectation(
-    crf1de_t *crf1de,
-    const crfsuite_instance_t *inst,
-    floatval_t *w,
-    const floatval_t scale)
-{
-    int a, c, i, t, r;
-    crf1d_context_t *ctx = crf1de->ctx;
-    const feature_refs_t *attr = NULL, *trans = NULL;
-    const crfsuite_item_t *item = NULL;
-    const int T = inst->num_items;
-    const int L = crf1de->num_labels;
-
-    for (t = 0; t < T; ++t)
-    {
-        floatval_t *prob = STATE_MEXP(ctx, t);
-
-        /* Compute expectations for state features at position #t. */
-        item = &inst->items[t];
-        for (c = 0; c < item->num_contents; ++c)
-        {
-            /* Access the attribute. */
-            floatval_t value = item->contents[c].value;
-            a = item->contents[c].aid;
-            attr = ATTRIBUTE(crf1de, a);
-
-            /* Loop over state features for the attribute. */
-            for (r = 0; r < attr->num_features; ++r)
-            {
-                int fid = attr->fids[r];
-                crf1df_feature_t *f = FEATURE(crf1de, fid);
-                w[fid] += prob[f->dst] * value * scale;
-            }
-        }
-    }
-
-    /* Loop over the labels (t, i) */
-    for (i = 0; i < L; ++i)
-    {
-        const floatval_t *prob = TRANS_MEXP(ctx, i);
-        const feature_refs_t *edge = TRANSITION(crf1de, i);
-        for (r = 0; r < edge->num_features; ++r)
-        {
-            /* Transition feature from #i to #(f->dst). */
-            int fid = edge->fids[r];
-            crf1df_feature_t *f = FEATURE(crf1de, fid);
-            w[fid] += prob[f->dst] * scale;
-        }
-    }
-}
-
-static int
-crf1de_set_data(
-    crf1de_t *crf1de,
-    dataset_t *ds,
-    int num_labels,
-    int num_attributes,
-    logging_t *lg)
-{
-    int i, ret = 0;
-    clock_t begin = 0;
-    int T = 0;
-    const int L = num_labels;
-    const int A = num_attributes;
-    const int N = ds->num_instances;
-    crf1de_option_t *opt = &crf1de->opt;
-
-    /* Initialize the member variables. */
-    crf1de_init(crf1de);
-    crf1de->num_attributes = A;
-    crf1de->num_labels = L;
-
-    /* Find the maximum length of items in the data set. */
-    for (i = 0; i < N; ++i)
-    {
-        const crfsuite_instance_t *inst = dataset_get(ds, i);
-        if (T < inst->num_items)
-        {
-            T = inst->num_items;
-        }
-    }
-
-    /* Construct a CRF context. */
-    crf1de->ctx = crf1dc_new(CTXF_MARGINALS | CTXF_VITERBI, L, T);
-    if (crf1de->ctx == NULL)
-    {
-        ret = CRFSUITEERR_OUTOFMEMORY;
-        goto error_exit;
-    }
-
-    /* Feature generation. */
-    logging(lg, "Processing training data");
-    begin = clock();
-    crf1de->features = crf1df_generate(
-        &crf1de->num_features,
-        ds,
-        L,
-        A,
-        opt->feature_possible_states ? 1 : 0,
-        opt->feature_possible_transitions ? 1 : 0,
-        opt->feature_minfreq,
-        lg->func,
-        lg->instance);
-    if (crf1de->features == NULL)
-    {
-        ret = CRFSUITEERR_OUTOFMEMORY;
-        goto error_exit;
-    }
-
-    /* Initialize the feature references. */
-    crf1df_init_references(
-        &crf1de->attributes,
-        &crf1de->forward_trans,
-        crf1de->features,
-        crf1de->num_features,
-        A,
-        L);
-    if (crf1de->attributes == NULL || crf1de->forward_trans == NULL)
-    {
-        ret = CRFSUITEERR_OUTOFMEMORY;
-        goto error_exit;
-    }
-
-    return ret;
-
-error_exit:
-    crf1de_finish(crf1de);
-    return ret;
-}
-
-static int
-crf1de_save_model(
-    crf1de_t *crf1de,
-    const char *filename,
-    const floatval_t *w,
-    crfsuite_dictionary_t *attrs,
-    crfsuite_dictionary_t *labels,
-    logging_t *lg)
-{
-    int a, k, l, ret;
-    clock_t begin;
-    int *fmap = NULL, *amap = NULL;
-    crf1dmw_t *writer = NULL;
-    const feature_refs_t *edge = NULL, *attr = NULL;
-    const floatval_t threshold = 0.01;
-    const int L = crf1de->num_labels;
-    const int A = crf1de->num_attributes;
-    const int K = crf1de->num_features;
-    int J = 0, B = 0;
-
-    /* Start storing the model. */
-    logging(lg, "Saving model");
-    begin = clock();
-
-    /* Allocate and initialize the feature mapping. */
-    fmap = (int *)calloc(K, sizeof(int));
-    if (fmap == NULL)
-    {
-        goto error_exit;
-    }
-#ifdef CRF_TRAIN_SAVE_NO_PRUNING
-    for (k = 0; k < K; ++k)
-        fmap[k] = k;
-    J = K;
-#else
-    for (k = 0; k < K; ++k)
-        fmap[k] = -1;
-#endif /*CRF_TRAIN_SAVE_NO_PRUNING*/
-
-    /* Allocate and initialize the attribute mapping. */
-    amap = (int *)calloc(A, sizeof(int));
-    if (amap == NULL)
-    {
-        goto error_exit;
-    }
-#ifdef CRF_TRAIN_SAVE_NO_PRUNING
-    for (a = 0; a < A; ++a)
-        amap[a] = a;
-    B = A;
-#else
-    for (a = 0; a < A; ++a)
-        amap[a] = -1;
-#endif /*CRF_TRAIN_SAVE_NO_PRUNING*/
-
-    /*
-     *  Open a model writer.
-     */
-    writer = crf1mmw(filename);
-    if (writer == NULL)
-    {
-        goto error_exit;
-    }
-
-    /* Open a feature chunk in the model file. */
-    if (ret = crf1dmw_open_features(writer))
-    {
-        goto error_exit;
-    }
-
-    /*
-     *  Write the feature values.
-     *     (with determining active features and attributes).
-     */
-    for (k = 0; k < K; ++k)
-    {
-        crf1df_feature_t *f = &crf1de->features[k];
-        if (w[k] != 0)
-        {
-            int src;
-            crf1dm_feature_t feat;
-
-#ifndef CRF_TRAIN_SAVE_NO_PRUNING
-            /* The feature (#k) will have a new feature id (#J). */
-            fmap[k] = J++; /* Feature #k -> #fmap[k]. */
-
-            /* Map the source of the field. */
-            if (f->type == FT_STATE)
-            {
-                /* The attribute #(f->src) will have a new attribute id (#B). */
-                if (amap[f->src] < 0)
-                    amap[f->src] = B++; /* Attribute #a -> #amap[a]. */
-                src = amap[f->src];
-            }
-            else
-            {
-                src = f->src;
-            }
-#endif /*CRF_TRAIN_SAVE_NO_PRUNING*/
-
-            feat.type = f->type;
-            feat.src = src;
-            feat.dst = f->dst;
-            feat.weight = w[k];
-
-            /* Write the feature. */
-            if (ret = crf1dmw_put_feature(writer, fmap[k], &feat))
-            {
-                goto error_exit;
-            }
-        }
-    }
-
-    /* Close the feature chunk. */
-    if (ret = crf1dmw_close_features(writer))
-    {
-        goto error_exit;
-    }
-
-    /* Write labels. */
-    if (ret = crf1dmw_open_labels(writer, L))
-    {
-        goto error_exit;
-    }
-    for (l = 0; l < L; ++l)
-    {
-        const char *str = NULL;
-        labels->to_string(labels, l, &str);
-        if (str != NULL)
-        {
-            if (ret = crf1dmw_put_label(writer, l, str))
-            {
-                goto error_exit;
-            }
-            labels->free(labels, str);
-        }
-    }
-    if (ret = crf1dmw_close_labels(writer))
-    {
-        goto error_exit;
-    }
-
-    /* Write attributes. */
-    if (ret = crf1dmw_open_attrs(writer, B))
-    {
-        goto error_exit;
-    }
-    for (a = 0; a < A; ++a)
-    {
-        if (0 <= amap[a])
-        {
-            const char *str = NULL;
-            attrs->to_string(attrs, a, &str);
-            if (str != NULL)
-            {
-                if (ret = crf1dmw_put_attr(writer, amap[a], str))
-                {
-                    goto error_exit;
-                }
-                attrs->free(attrs, str);
-            }
-        }
-    }
-    if (ret = crf1dmw_close_attrs(writer))
-    {
-        goto error_exit;
-    }
-
-    /* Write label feature references. */
-    if (ret = crf1dmw_open_labelrefs(writer, L + 2))
-    {
-        goto error_exit;
-    }
-    for (l = 0; l < L; ++l)
-    {
-        edge = TRANSITION(crf1de, l);
-        if (ret = crf1dmw_put_labelref(writer, l, edge, fmap))
-        {
-            goto error_exit;
-        }
-    }
-    if (ret = crf1dmw_close_labelrefs(writer))
-    {
-        goto error_exit;
-    }
-
-    /* Write attribute feature references. */
-    if (ret = crf1dmw_open_attrrefs(writer, B))
-    {
-        goto error_exit;
-    }
-    for (a = 0; a < A; ++a)
-    {
-        if (0 <= amap[a])
-        {
-            attr = ATTRIBUTE(crf1de, a);
-            if (ret = crf1dmw_put_attrref(writer, amap[a], attr, fmap))
-            {
-                goto error_exit;
-            }
-        }
-    }
-    if (ret = crf1dmw_close_attrrefs(writer))
-    {
-        goto error_exit;
-    }
-
-    /* Close the writer. */
-    crf1dmw_close(writer);
-
-    free(amap);
-    free(fmap);
-    return 0;
-
-error_exit:
-    if (writer != NULL)
-    {
-        crf1dmw_close(writer);
-    }
-    if (amap != NULL)
-    {
-        free(amap);
-    }
-    if (fmap != NULL)
-    {
-        free(fmap);
-    }
-    return ret;
-}
-
-static int crf1de_exchange_options(crfsuite_params_t *params, crf1de_option_t *opt, int mode)
-{
-    BEGIN_PARAM_MAP(params, mode)
-    DDX_PARAM_FLOAT(
-        "feature.minfreq", opt->feature_minfreq, 0.0,
-        "The minimum frequency of features.")
-    DDX_PARAM_INT(
-        "feature.possible_states", opt->feature_possible_states, 0,
-        "Force to generate possible state features.")
-    DDX_PARAM_INT(
-        "feature.possible_transitions", opt->feature_possible_transitions, 0,
-        "Force to generate possible transition features.")
-    END_PARAM_MAP()
-
-    return 0;
-}
-
-/*
- *    Implementation of encoder_t object.
- */
-
-enum
-{
-    /** No precomputation. */
-    LEVEL_NONE = 0,
-    /** Feature weights are set. */
-    LEVEL_WEIGHT,
-    /** Instance is set. */
-    LEVEL_INSTANCE,
-    /** Performed the forward-backward algorithm. */
-    LEVEL_ALPHABETA,
-    /** Computed marginal probabilities. */
-    LEVEL_MARGINAL,
-};
-
-static void set_level(encoder_t *self, int level)
-{
-    int prev = self->level;
-    crf1de_t *crf1de = (crf1de_t *)self->internal;
-
-    /*
-        Each training algorithm has a different requirement for processing a
-        training instance. For example, the perceptron algorithm need compute
-        Viterbi paths whereas gradient-based algorithms (e.g., SGD) need
-        marginal probabilities computed by the forward-backward algorithm.
-     */
-
-    /* LEVEL_WEIGHT: set transition scores. */
-    if (LEVEL_WEIGHT <= level && prev < LEVEL_WEIGHT)
-    {
-        crf1dc_reset(crf1de->ctx, RF_TRANS);
-        crf1de_transition_score_scaled(crf1de, self->w, self->scale);
-    }
-
-    /* LEVEL_INSTANCE: set state scores. */
-    if (LEVEL_INSTANCE <= level && prev < LEVEL_INSTANCE)
-    {
-        crf1dc_set_num_items(crf1de->ctx, self->inst->num_items);
-        crf1dc_reset(crf1de->ctx, RF_STATE);
-        crf1de_state_score_scaled(crf1de, self->inst, self->w, self->scale);
-    }
-
-    /* LEVEL_ALPHABETA: perform the forward-backward algorithm. */
-    if (LEVEL_ALPHABETA <= level && prev < LEVEL_ALPHABETA)
-    {
-        crf1dc_exp_transition(crf1de->ctx);
-        crf1dc_exp_state(crf1de->ctx);
-        crf1dc_alpha_score(crf1de->ctx);
-        crf1dc_beta_score(crf1de->ctx);
-    }
-
-    /* LEVEL_MARGINAL: compute the marginal probability. */
-    if (LEVEL_MARGINAL <= level && prev < LEVEL_MARGINAL)
-    {
-        crf1dc_marginals(crf1de->ctx);
-    }
-
-    self->level = level;
-}
-
-static int encoder_exchange_options(encoder_t *self, crfsuite_params_t *params, int mode)
-{
-    crf1de_t *crf1de = (crf1de_t *)self->internal;
-    return crf1de_exchange_options(params, &crf1de->opt, mode);
-}
-
-static int encoder_initialize(encoder_t *self, dataset_t *ds, logging_t *lg)
-{
-    int ret;
-    crf1de_t *crf1de = (crf1de_t *)self->internal;
-
-    ret = crf1de_set_data(
-        crf1de,
-        ds,
-        ds->data->labels->num(ds->data->labels),
-        ds->data->attrs->num(ds->data->attrs),
-        lg);
-    self->ds = ds;
-    self->num_features = crf1de->num_features;
-    self->cap_items = crf1de->ctx->cap_items;
-    return ret;
-}
-
-/* LEVEL_NONE -> LEVEL_NONE. */
-static int encoder_objective_and_gradients_batch(encoder_t *self, dataset_t *ds, const floatval_t *w, floatval_t *f, floatval_t *g)
-{
-    int i;
-    floatval_t logp = 0, logl = 0;
-    crf1de_t *crf1de = (crf1de_t *)self->internal;
-    const int N = ds->num_instances;
-    const int K = crf1de->num_features;
-
-    /*
-        Initialize the gradients with observation expectations.
-     */
-    for (i = 0; i < K; ++i)
-    {
-        crf1df_feature_t *f = &crf1de->features[i];
-        g[i] = -f->freq;
-    }
-
-    /*
-        Set the scores (weights) of transition features here because
-        these are independent of input label sequences.
-     */
-    crf1dc_reset(crf1de->ctx, RF_TRANS);
-    crf1de_transition_score(crf1de, w);
-    crf1dc_exp_transition(crf1de->ctx);
-
-    /*
-        Compute model expectations.
-     */
-    for (i = 0; i < N; ++i)
-    {
-        const crfsuite_instance_t *seq = dataset_get(ds, i);
-
-        /* Set label sequences and state scores. */
-        crf1dc_set_num_items(crf1de->ctx, seq->num_items);
-        crf1dc_reset(crf1de->ctx, RF_STATE);
-        crf1de_state_score(crf1de, seq, w);
-        crf1dc_exp_state(crf1de->ctx);
-
-        /* Compute forward/backward scores. */
-        crf1dc_alpha_score(crf1de->ctx);
-        crf1dc_beta_score(crf1de->ctx);
-        crf1dc_marginals(crf1de->ctx);
-
-        /* Compute the probability of the input sequence on the model. */
-        logp = crf1dc_score(crf1de->ctx, seq->labels) - crf1dc_lognorm(crf1de->ctx);
-        /* Update the log-likelihood. */
-        logl += logp * seq->weight;
-
-        /* Update the model expectations of features. */
-        crf1de_model_expectation(crf1de, seq, g, seq->weight);
-    }
-
-    *f = -logl;
-    return 0;
-}
-
-/* LEVEL_NONE -> LEVEL_NONE. */
-static int encoder_features_on_path(encoder_t *self, const crfsuite_instance_t *inst, const int *path, crfsuite_encoder_features_on_path_callback func, void *instance)
-{
-    crf1de_t *crf1de = (crf1de_t *)self->internal;
-    crf1de_features_on_path(crf1de, inst, path, func, instance);
-    return 0;
-}
-
-/* LEVEL_NONE -> LEVEL_NONE. */
-static int encoder_save_model(encoder_t *self, const char *filename, const floatval_t *w, logging_t *lg)
-{
-    crf1de_t *crf1de = (crf1de_t *)self->internal;
-    return crf1de_save_model(crf1de, filename, w, self->ds->data->attrs, self->ds->data->labels, lg);
-}
-
-/* LEVEL_NONE -> LEVEL_WEIGHT. */
-static int encoder_set_weights(encoder_t *self, const floatval_t *w, floatval_t scale)
-{
-    self->w = w;
-    self->scale = scale;
-    self->level = LEVEL_WEIGHT - 1;
-    set_level(self, LEVEL_WEIGHT);
-    return 0;
-}
-
-/* LEVEL_WEIGHT -> LEVEL_INSTANCE. */
-static int encoder_set_instance(encoder_t *self, const crfsuite_instance_t *inst)
-{
-    self->inst = inst;
-    self->level = LEVEL_INSTANCE - 1;
-    set_level(self, LEVEL_INSTANCE);
-    return 0;
-}
-
-/* LEVEL_INSTANCE -> LEVEL_INSTANCE. */
-static int encoder_score(encoder_t *self, const int *path, floatval_t *ptr_score)
-{
-    crf1de_t *crf1de = (crf1de_t *)self->internal;
-    *ptr_score = crf1dc_score(crf1de->ctx, path);
-    return 0;
-}
-
-/* LEVEL_INSTANCE -> LEVEL_INSTANCE. */
-static int encoder_viterbi(encoder_t *self, int *path, floatval_t *ptr_score)
-{
-    int i;
-    floatval_t score;
-    crf1de_t *crf1de = (crf1de_t *)self->internal;
-    score = crf1dc_viterbi(crf1de->ctx, path);
-    if (ptr_score != NULL)
-    {
-        *ptr_score = score;
-    }
-    return 0;
-}
-
-/* LEVEL_INSTANCE -> LEVEL_ALPHABETA. */
-static int encoder_partition_factor(encoder_t *self, floatval_t *ptr_pf)
-{
-    crf1de_t *crf1de = (crf1de_t *)self->internal;
-    set_level(self, LEVEL_ALPHABETA);
-    *ptr_pf = crf1dc_lognorm(crf1de->ctx);
-    return 0;
-}
-
-/* LEVEL_INSTANCE -> LEVEL_MARGINAL. */
-static int encoder_objective_and_gradients(encoder_t *self, floatval_t *f, floatval_t *g, floatval_t gain, floatval_t weight)
-{
-    crf1de_t *crf1de = (crf1de_t *)self->internal;
-    set_level(self, LEVEL_MARGINAL);
-    gain *= weight;
-    crf1de_observation_expectation(crf1de, self->inst, self->inst->labels, g, gain);
-    crf1de_model_expectation(crf1de, self->inst, g, -gain);
-    *f = (-crf1dc_score(crf1de->ctx, self->inst->labels) + crf1dc_lognorm(crf1de->ctx)) * weight;
-    return 0;
-}
-
-static void encoder_release(encoder_t *self)
-{
-    crf1de_t *crf1de = (crf1de_t *)self->internal;
-    crf1de_finish(crf1de);
-    free(crf1de);
-    free(self);
-}
-
-encoder_t *crf1d_create_encoder()
-{
-    encoder_t *self = (encoder_t *)calloc(1, sizeof(encoder_t));
-    if (self != NULL)
-    {
-        crf1de_t *enc = (crf1de_t *)calloc(1, sizeof(crf1de_t));
-        if (enc != NULL)
-        {
-            crf1de_init(enc);
-
-            self->exchange_options = encoder_exchange_options;
-            self->initialize = encoder_initialize;
-            self->objective_and_gradients_batch = encoder_objective_and_gradients_batch;
-            self->save_model = encoder_save_model;
-            self->features_on_path = encoder_features_on_path;
-            self->set_weights = encoder_set_weights;
-            self->set_instance = encoder_set_instance;
-            self->score = encoder_score;
-            self->viterbi = encoder_viterbi;
-            self->partition_factor = encoder_partition_factor;
-            self->objective_and_gradients = encoder_objective_and_gradients;
-            self->release = encoder_release;
-            self->internal = enc;
-        }
-    }
-
-    return self;
-}
+/*
+ *      CRF1d encoder (routines for training).
+ *
+ * Copyright (c) 2007-2010, Naoaki Okazaki
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the names of the authors nor the names of its contributors
+ *       may be used to endorse or promote products derived from this
+ *       software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+ * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/* $Id$ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif /*HAVE_CONFIG_H*/
+
+#include <os.h>
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <memory.h>
+#include <time.h>
+
+#include <crfsuite.h>
+#include "crfsuite_internal.h"
+#include "crf1d.h"
+#include "params.h"
+#include "logging.h"
+
+/**
+ * Parameters for feature generation.
+ */
+typedef struct
+{
+    floatval_t feature_minfreq;       /** The threshold for occurrences of features. */
+    int feature_possible_states;      /** Dense state features. */
+    int feature_possible_transitions; /** Dense transition features. */
+} crf1de_option_t;
+
+/**
+ * CRF1d internal data.
+ */
+typedef struct
+{
+    int num_labels;     /**< Number of distinct output labels (L). */
+    int num_attributes; /**< Number of distinct attributes (A). */
+
+    int cap_items; /**< Maximum length of sequences in the data set. */
+
+    int num_features;              /**< Number of distinct features (K). */
+    crf1df_feature_t *features;    /**< Array of feature descriptors [K]. */
+    feature_refs_t *attributes;    /**< References to attribute features [A]. */
+    feature_refs_t *forward_trans; /**< References to transition features [L]. */
+
+    crf1d_context_t *ctx; /**< CRF1d context. */
+    crf1de_option_t opt;  /**< CRF1d options. */
+} crf1de_t;
+
+#define FEATURE(crf1de, k) \
+    (&(crf1de)->features[(k)])
+#define ATTRIBUTE(crf1de, a) \
+    (&(crf1de)->attributes[(a)])
+#define TRANSITION(crf1de, i) \
+    (&(crf1de)->forward_trans[(i)])
+
+static void crf1de_init(crf1de_t *crf1de)
+{
+    crf1de->num_labels = 0;
+    crf1de->num_attributes = 0;
+    crf1de->cap_items = 0;
+    crf1de->num_features = 0;
+    crf1de->features = NULL;
+    crf1de->attributes = NULL;
+    crf1de->forward_trans = NULL;
+    crf1de->ctx = NULL;
+    /* Initialize except for opt. */
+}
+
+static void crf1de_finish(crf1de_t *crf1de)
+{
+    int i;
+
+    if (crf1de->ctx != NULL)
+    {
+        crf1dc_delete(crf1de->ctx);
+        crf1de->ctx = NULL;
+    }
+    if (crf1de->features != NULL)
+    {
+        free(crf1de->features);
+        crf1de->features = NULL;
+    }
+    if (crf1de->attributes != NULL)
+    {
+        for (i = 0; i < crf1de->num_attributes; ++i)
+        {
+            free(crf1de->attributes[i].fids);
+        }
+        free(crf1de->attributes);
+        crf1de->attributes = NULL;
+    }
+    if (crf1de->forward_trans != NULL)
+    {
+        for (i = 0; i < crf1de->num_labels; ++i)
+        {
+            free(crf1de->forward_trans[i].fids);
+        }
+        free(crf1de->forward_trans);
+        crf1de->forward_trans = NULL;
+    }
+}
+
+static void crf1de_state_score(
+    crf1de_t *crf1de,
+    const crfsuite_instance_t *inst,
+    const floatval_t *w)
+{
+    int i, t, r;
+    crf1d_context_t *ctx = crf1de->ctx;
+    const int T = inst->num_items;
+    const int L = crf1de->num_labels;
+
+    /* Loop over the items in the sequence. */
+    for (t = 0; t < T; ++t)
+    {
+        const crfsuite_item_t *item = &inst->items[t];
+        floatval_t *state = STATE_SCORE(ctx, t);
+
+        /* Loop over the contents (attributes) attached to the item. */
+        for (i = 0; i < item->num_contents; ++i)
+        {
+            /* Access the list of state features associated with the attribute. */
+            int a = item->contents[i].aid;
+            const feature_refs_t *attr = ATTRIBUTE(crf1de, a);
+            floatval_t value = item->contents[i].value;
+
+            /* Loop over the state features associated with the attribute. */
+            for (r = 0; r < attr->num_features; ++r)
+            {
+                /* State feature associates the attribute #a with the label #(f->dst). */
+                int fid = attr->fids[r];
+                const crf1df_feature_t *f = FEATURE(crf1de, fid);
+                state[f->dst] += w[fid] * value;
+            }
+        }
+    }
+}
+
+static void
+crf1de_state_score_scaled(
+    crf1de_t *crf1de,
+    const crfsuite_instance_t *inst,
+    const floatval_t *w,
+    const floatval_t scale)
+{
+    int i, t, r;
+    crf1d_context_t *ctx = crf1de->ctx;
+    const int T = inst->num_items;
+    const int L = crf1de->num_labels;
+
+    /* Forward to the non-scaling version for fast computation when scale == 1. */
+    if (scale == 1.)
+    {
+        crf1de_state_score(crf1de, inst, w);
+        return;
+    }
+
+    /* Loop over the items in the sequence. */
+    for (t = 0; t < T; ++t)
+    {
+        const crfsuite_item_t *item = &inst->items[t];
+        floatval_t *state = STATE_SCORE(ctx, t);
+
+        /* Loop over the contents (attributes) attached to the item. */
+        for (i = 0; i < item->num_contents; ++i)
+        {
+            /* Access the list of state features associated with the attribute. */
+            int a = item->contents[i].aid;
+            const feature_refs_t *attr = ATTRIBUTE(crf1de, a);
+            floatval_t value = item->contents[i].value * scale;
+
+            /* Loop over the state features associated with the attribute. */
+            for (r = 0; r < attr->num_features; ++r)
+            {
+                /* State feature associates the attribute #a with the label #(f->dst). */
+                int fid = attr->fids[r];
+                const crf1df_feature_t *f = FEATURE(crf1de, fid);
+                state[f->dst] += w[fid] * value;
+            }
+        }
+    }
+}
+
+static void
+crf1de_transition_score(
+    crf1de_t *crf1de,
+    const floatval_t *w)
+{
+    int i, r;
+    crf1d_context_t *ctx = crf1de->ctx;
+    const int L = crf1de->num_labels;
+
+    /* Compute transition scores between two labels. */
+    for (i = 0; i < L; ++i)
+    {
+        floatval_t *trans = TRANS_SCORE(ctx, i);
+        const feature_refs_t *edge = TRANSITION(crf1de, i);
+        for (r = 0; r < edge->num_features; ++r)
+        {
+            /* Transition feature from #i to #(f->dst). */
+            int fid = edge->fids[r];
+            const crf1df_feature_t *f = FEATURE(crf1de, fid);
+            trans[f->dst] = w[fid];
+        }
+    }
+}
+
+static void
+crf1de_transition_score_scaled(
+    crf1de_t *crf1de,
+    const floatval_t *w,
+    const floatval_t scale)
+{
+    int i, r;
+    crf1d_context_t *ctx = crf1de->ctx;
+    const int L = crf1de->num_labels;
+
+    /* Forward to the non-scaling version for fast computation when scale == 1. */
+    if (scale == 1.)
+    {
+        crf1de_transition_score(crf1de, w);
+        return;
+    }
+
+    /* Compute transition scores between two labels. */
+    for (i = 0; i < L; ++i)
+    {
+        floatval_t *trans = TRANS_SCORE(ctx, i);
+        const feature_refs_t *edge = TRANSITION(crf1de, i);
+        for (r = 0; r < edge->num_features; ++r)
+        {
+            /* Transition feature from #i to #(f->dst). */
+            int fid = edge->fids[r];
+            const crf1df_feature_t *f = FEATURE(crf1de, fid);
+            trans[f->dst] = w[fid] * scale;
+        }
+    }
+}
+
+static void
+crf1de_features_on_path(
+    crf1de_t *crf1de,
+    const crfsuite_instance_t *inst,
+    const int *labels,
+    crfsuite_encoder_features_on_path_callback func,
+    void *instance)
+{
+    int c, i = -1, t, r;
+    crf1d_context_t *ctx = crf1de->ctx;
+    const int T = inst->num_items;
+    const int L = crf1de->num_labels;
+
+    /* Loop over the items in the sequence. */
+    for (t = 0; t < T; ++t)
+    {
+        const crfsuite_item_t *item = &inst->items[t];
+        const int j = labels[t];
+
+        /* Loop over the contents (attributes) attached to the item. */
+        for (c = 0; c < item->num_contents; ++c)
+        {
+            /* Access the list of state features associated with the attribute. */
+            int a = item->contents[c].aid;
+            const feature_refs_t *attr = ATTRIBUTE(crf1de, a);
+            floatval_t value = item->contents[c].value;
+
+            /* Loop over the state features associated with the attribute. */
+            for (r = 0; r < attr->num_features; ++r)
+            {
+                /* State feature associates the attribute #a with the label #(f->dst). */
+                int fid = attr->fids[r];
+                const crf1df_feature_t *f = FEATURE(crf1de, fid);
+                if (f->dst == j)
+                {
+                    func(instance, fid, value);
+                }
+            }
+        }
+
+        if (i != -1)
+        {
+            const feature_refs_t *edge = TRANSITION(crf1de, i);
+            for (r = 0; r < edge->num_features; ++r)
+            {
+                /* Transition feature from #i to #(f->dst). */
+                int fid = edge->fids[r];
+                const crf1df_feature_t *f = FEATURE(crf1de, fid);
+                if (f->dst == j)
+                {
+                    func(instance, fid, 1.);
+                }
+            }
+        }
+
+        i = j;
+    }
+}
+
+static void
+crf1de_observation_expectation(
+    crf1de_t *crf1de,
+    const crfsuite_instance_t *inst,
+    const int *labels,
+    floatval_t *w,
+    const floatval_t scale)
+{
+    int c, i = -1, t, r;
+    crf1d_context_t *ctx = crf1de->ctx;
+    const int T = inst->num_items;
+    const int L = crf1de->num_labels;
+
+    /* Loop over the items in the sequence. */
+    for (t = 0; t < T; ++t)
+    {
+        const crfsuite_item_t *item = &inst->items[t];
+        const int j = labels[t];
+
+        /* Loop over the contents (attributes) attached to the item. */
+        for (c = 0; c < item->num_contents; ++c)
+        {
+            /* Access the list of state features associated with the attribute. */
+            int a = item->contents[c].aid;
+            const feature_refs_t *attr = ATTRIBUTE(crf1de, a);
+            floatval_t value = item->contents[c].value;
+
+            /* Loop over the state features associated with the attribute. */
+            for (r = 0; r < attr->num_features; ++r)
+            {
+                /* State feature associates the attribute #a with the label #(f->dst). */
+                int fid = attr->fids[r];
+                const crf1df_feature_t *f = FEATURE(crf1de, fid);
+                if (f->dst == j)
+                {
+                    w[fid] += value * scale;
+                }
+            }
+        }
+
+        if (i != -1)
+        {
+            const feature_refs_t *edge = TRANSITION(crf1de, i);
+            for (r = 0; r < edge->num_features; ++r)
+            {
+                /* Transition feature from #i to #(f->dst). */
+                int fid = edge->fids[r];
+                const crf1df_feature_t *f = FEATURE(crf1de, fid);
+                if (f->dst == j)
+                {
+                    w[fid] += scale;
+                }
+            }
+        }
+
+        i = j;
+    }
+}
+
+static void
+crf1de_model_expectation(
+    crf1de_t *crf1de,
+    const crfsuite_instance_t *inst,
+    floatval_t *w,
+    const floatval_t scale)
+{
+    int a, c, i, t, r;
+    crf1d_context_t *ctx = crf1de->ctx;
+    const feature_refs_t *attr = NULL, *trans = NULL;
+    const crfsuite_item_t *item = NULL;
+    const int T = inst->num_items;
+    const int L = crf1de->num_labels;
+
+    for (t = 0; t < T; ++t)
+    {
+        floatval_t *prob = STATE_MEXP(ctx, t);
+
+        /* Compute expectations for state features at position #t. */
+        item = &inst->items[t];
+        for (c = 0; c < item->num_contents; ++c)
+        {
+            /* Access the attribute. */
+            floatval_t value = item->contents[c].value;
+            a = item->contents[c].aid;
+            attr = ATTRIBUTE(crf1de, a);
+
+            /* Loop over state features for the attribute. */
+            for (r = 0; r < attr->num_features; ++r)
+            {
+                int fid = attr->fids[r];
+                crf1df_feature_t *f = FEATURE(crf1de, fid);
+                w[fid] += prob[f->dst] * value * scale;
+            }
+        }
+    }
+
+    /* Loop over the labels (t, i) */
+    for (i = 0; i < L; ++i)
+    {
+        const floatval_t *prob = TRANS_MEXP(ctx, i);
+        const feature_refs_t *edge = TRANSITION(crf1de, i);
+        for (r = 0; r < edge->num_features; ++r)
+        {
+            /* Transition feature from #i to #(f->dst). */
+            int fid = edge->fids[r];
+            crf1df_feature_t *f = FEATURE(crf1de, fid);
+            w[fid] += prob[f->dst] * scale;
+        }
+    }
+}
+
+static int
+crf1de_set_data(
+    crf1de_t *crf1de,
+    dataset_t *ds,
+    int num_labels,
+    int num_attributes,
+    logging_t *lg)
+{
+    int i, ret = 0;
+    clock_t begin = 0;
+    int T = 0;
+    const int L = num_labels;
+    const int A = num_attributes;
+    const int N = ds->num_instances;
+    crf1de_option_t *opt = &crf1de->opt;
+
+    /* Initialize the member variables. */
+    crf1de_init(crf1de);
+    crf1de->num_attributes = A;
+    crf1de->num_labels = L;
+
+    /* Find the maximum length of items in the data set. */
+    for (i = 0; i < N; ++i)
+    {
+        const crfsuite_instance_t *inst = dataset_get(ds, i);
+        if (T < inst->num_items)
+        {
+            T = inst->num_items;
+        }
+    }
+
+    /* Construct a CRF context. */
+    crf1de->ctx = crf1dc_new(CTXF_MARGINALS | CTXF_VITERBI, L, T);
+    if (crf1de->ctx == NULL)
+    {
+        ret = CRFSUITEERR_OUTOFMEMORY;
+        goto error_exit;
+    }
+
+    /* Feature generation. */
+    logging(lg, "Processing training data");
+    begin = clock();
+    crf1de->features = crf1df_generate(
+        &crf1de->num_features,
+        ds,
+        L,
+        A,
+        opt->feature_possible_states ? 1 : 0,
+        opt->feature_possible_transitions ? 1 : 0,
+        opt->feature_minfreq,
+        lg->func,
+        lg->instance);
+    if (crf1de->features == NULL)
+    {
+        ret = CRFSUITEERR_OUTOFMEMORY;
+        goto error_exit;
+    }
+
+    /* Initialize the feature references. */
+    crf1df_init_references(
+        &crf1de->attributes,
+        &crf1de->forward_trans,
+        crf1de->features,
+        crf1de->num_features,
+        A,
+        L);
+    if (crf1de->attributes == NULL || crf1de->forward_trans == NULL)
+    {
+        ret = CRFSUITEERR_OUTOFMEMORY;
+        goto error_exit;
+    }
+
+    return ret;
+
+error_exit:
+    crf1de_finish(crf1de);
+    return ret;
+}
+
+static int
+crf1de_save_model(
+    crf1de_t *crf1de,
+    const char *filename,
+    const floatval_t *w,
+    crfsuite_dictionary_t *attrs,
+    crfsuite_dictionary_t *labels,
+    logging_t *lg)
+{
+    int a, k, l, ret;
+    clock_t begin;
+    int *fmap = NULL, *amap = NULL;
+    crf1dmw_t *writer = NULL;
+    const feature_refs_t *edge = NULL, *attr = NULL;
+    const floatval_t threshold = 0.01;
+    const int L = crf1de->num_labels;
+    const int A = crf1de->num_attributes;
+    const int K = crf1de->num_features;
+    int J = 0, B = 0;
+
+    /* Start storing the model. */
+    logging(lg, "Saving model");
+    begin = clock();
+
+    /* Allocate and initialize the feature mapping. */
+    fmap = (int *)calloc(K, sizeof(int));
+    if (fmap == NULL)
+    {
+        goto error_exit;
+    }
+#ifdef CRF_TRAIN_SAVE_NO_PRUNING
+    for (k = 0; k < K; ++k)
+        fmap[k] = k;
+    J = K;
+#else
+    for (k = 0; k < K; ++k)
+        fmap[k] = -1;
+#endif /*CRF_TRAIN_SAVE_NO_PRUNING*/
+
+    /* Allocate and initialize the attribute mapping. */
+    amap = (int *)calloc(A, sizeof(int));
+    if (amap == NULL)
+    {
+        goto error_exit;
+    }
+#ifdef CRF_TRAIN_SAVE_NO_PRUNING
+    for (a = 0; a < A; ++a)
+        amap[a] = a;
+    B = A;
+#else
+    for (a = 0; a < A; ++a)
+        amap[a] = -1;
+#endif /*CRF_TRAIN_SAVE_NO_PRUNING*/
+
+    /*
+     *  Open a model writer.
+     */
+    writer = crf1mmw(filename);
+    if (writer == NULL)
+    {
+        goto error_exit;
+    }
+
+    /* Open a feature chunk in the model file. */
+    if (ret = crf1dmw_open_features(writer))
+    {
+        goto error_exit;
+    }
+
+    /*
+     *  Write the feature values.
+     *     (with determining active features and attributes).
+     */
+    for (k = 0; k < K; ++k)
+    {
+        crf1df_feature_t *f = &crf1de->features[k];
+        if (w[k] != 0)
+        {
+            int src;
+            crf1dm_feature_t feat;
+
+#ifndef CRF_TRAIN_SAVE_NO_PRUNING
+            /* The feature (#k) will have a new feature id (#J). */
+            fmap[k] = J++; /* Feature #k -> #fmap[k]. */
+
+            /* Map the source of the field. */
+            if (f->type == FT_STATE)
+            {
+                /* The attribute #(f->src) will have a new attribute id (#B). */
+                if (amap[f->src] < 0)
+                    amap[f->src] = B++; /* Attribute #a -> #amap[a]. */
+                src = amap[f->src];
+            }
+            else
+            {
+                src = f->src;
+            }
+#endif /*CRF_TRAIN_SAVE_NO_PRUNING*/
+
+            feat.type = f->type;
+            feat.src = src;
+            feat.dst = f->dst;
+            feat.weight = w[k];
+
+            /* Write the feature. */
+            if (ret = crf1dmw_put_feature(writer, fmap[k], &feat))
+            {
+                goto error_exit;
+            }
+        }
+    }
+
+    /* Close the feature chunk. */
+    if (ret = crf1dmw_close_features(writer))
+    {
+        goto error_exit;
+    }
+
+    /* Write labels. */
+    if (ret = crf1dmw_open_labels(writer, L))
+    {
+        goto error_exit;
+    }
+    for (l = 0; l < L; ++l)
+    {
+        const char *str = NULL;
+        labels->to_string(labels, l, &str);
+        if (str != NULL)
+        {
+            if (ret = crf1dmw_put_label(writer, l, str))
+            {
+                goto error_exit;
+            }
+            labels->free(labels, str);
+        }
+    }
+    if (ret = crf1dmw_close_labels(writer))
+    {
+        goto error_exit;
+    }
+
+    /* Write attributes. */
+    if (ret = crf1dmw_open_attrs(writer, B))
+    {
+        goto error_exit;
+    }
+    for (a = 0; a < A; ++a)
+    {
+        if (0 <= amap[a])
+        {
+            const char *str = NULL;
+            attrs->to_string(attrs, a, &str);
+            if (str != NULL)
+            {
+                if (ret = crf1dmw_put_attr(writer, amap[a], str))
+                {
+                    goto error_exit;
+                }
+                attrs->free(attrs, str);
+            }
+        }
+    }
+    if (ret = crf1dmw_close_attrs(writer))
+    {
+        goto error_exit;
+    }
+
+    /* Write label feature references. */
+    if (ret = crf1dmw_open_labelrefs(writer, L + 2))
+    {
+        goto error_exit;
+    }
+    for (l = 0; l < L; ++l)
+    {
+        edge = TRANSITION(crf1de, l);
+        if (ret = crf1dmw_put_labelref(writer, l, edge, fmap))
+        {
+            goto error_exit;
+        }
+    }
+    if (ret = crf1dmw_close_labelrefs(writer))
+    {
+        goto error_exit;
+    }
+
+    /* Write attribute feature references. */
+    if (ret = crf1dmw_open_attrrefs(writer, B))
+    {
+        goto error_exit;
+    }
+    for (a = 0; a < A; ++a)
+    {
+        if (0 <= amap[a])
+        {
+            attr = ATTRIBUTE(crf1de, a);
+            if (ret = crf1dmw_put_attrref(writer, amap[a], attr, fmap))
+            {
+                goto error_exit;
+            }
+        }
+    }
+    if (ret = crf1dmw_close_attrrefs(writer))
+    {
+        goto error_exit;
+    }
+
+    /* Close the writer. */
+    crf1dmw_close(writer);
+
+    free(amap);
+    free(fmap);
+    return 0;
+
+error_exit:
+    if (writer != NULL)
+    {
+        crf1dmw_close(writer);
+    }
+    if (amap != NULL)
+    {
+        free(amap);
+    }
+    if (fmap != NULL)
+    {
+        free(fmap);
+    }
+    return ret;
+}
+
+static int crf1de_exchange_options(crfsuite_params_t *params, crf1de_option_t *opt, int mode)
+{
+    BEGIN_PARAM_MAP(params, mode)
+    DDX_PARAM_FLOAT(
+        "feature.minfreq", opt->feature_minfreq, 0.0,
+        "The minimum frequency of features.")
+    DDX_PARAM_INT(
+        "feature.possible_states", opt->feature_possible_states, 0,
+        "Force to generate possible state features.")
+    DDX_PARAM_INT(
+        "feature.possible_transitions", opt->feature_possible_transitions, 0,
+        "Force to generate possible transition features.")
+    END_PARAM_MAP()
+
+    return 0;
+}
+
+/*
+ *    Implementation of encoder_t object.
+ */
+
+enum
+{
+    /** No precomputation. */
+    LEVEL_NONE = 0,
+    /** Feature weights are set. */
+    LEVEL_WEIGHT,
+    /** Instance is set. */
+    LEVEL_INSTANCE,
+    /** Performed the forward-backward algorithm. */
+    LEVEL_ALPHABETA,
+    /** Computed marginal probabilities. */
+    LEVEL_MARGINAL,
+};
+
+static void set_level(encoder_t *self, int level)
+{
+    int prev = self->level;
+    crf1de_t *crf1de = (crf1de_t *)self->internal;
+
+    /*
+        Each training algorithm has a different requirement for processing a
+        training instance. For example, the perceptron algorithm need compute
+        Viterbi paths whereas gradient-based algorithms (e.g., SGD) need
+        marginal probabilities computed by the forward-backward algorithm.
+     */
+
+    /* LEVEL_WEIGHT: set transition scores. */
+    if (LEVEL_WEIGHT <= level && prev < LEVEL_WEIGHT)
+    {
+        crf1dc_reset(crf1de->ctx, RF_TRANS);
+        crf1de_transition_score_scaled(crf1de, self->w, self->scale);
+    }
+
+    /* LEVEL_INSTANCE: set state scores. */
+    if (LEVEL_INSTANCE <= level && prev < LEVEL_INSTANCE)
+    {
+        crf1dc_set_num_items(crf1de->ctx, self->inst->num_items);
+        crf1dc_reset(crf1de->ctx, RF_STATE);
+        crf1de_state_score_scaled(crf1de, self->inst, self->w, self->scale);
+    }
+
+    /* LEVEL_ALPHABETA: perform the forward-backward algorithm. */
+    if (LEVEL_ALPHABETA <= level && prev < LEVEL_ALPHABETA)
+    {
+        crf1dc_exp_transition(crf1de->ctx);
+        crf1dc_exp_state(crf1de->ctx);
+        crf1dc_alpha_score(crf1de->ctx);
+        crf1dc_beta_score(crf1de->ctx);
+    }
+
+    /* LEVEL_MARGINAL: compute the marginal probability. */
+    if (LEVEL_MARGINAL <= level && prev < LEVEL_MARGINAL)
+    {
+        crf1dc_marginals(crf1de->ctx);
+    }
+
+    self->level = level;
+}
+
+static int encoder_exchange_options(encoder_t *self, crfsuite_params_t *params, int mode)
+{
+    crf1de_t *crf1de = (crf1de_t *)self->internal;
+    return crf1de_exchange_options(params, &crf1de->opt, mode);
+}
+
+static int encoder_initialize(encoder_t *self, dataset_t *ds, logging_t *lg)
+{
+    int ret;
+    crf1de_t *crf1de = (crf1de_t *)self->internal;
+
+    ret = crf1de_set_data(
+        crf1de,
+        ds,
+        ds->data->labels->num(ds->data->labels),
+        ds->data->attrs->num(ds->data->attrs),
+        lg);
+    self->ds = ds;
+    self->num_features = crf1de->num_features;
+    self->cap_items = crf1de->ctx->cap_items;
+    return ret;
+}
+
+/* LEVEL_NONE -> LEVEL_NONE. */
+static int encoder_objective_and_gradients_batch(encoder_t *self, dataset_t *ds, const floatval_t *w, floatval_t *f, floatval_t *g)
+{
+    int i;
+    floatval_t logp = 0, logl = 0;
+    crf1de_t *crf1de = (crf1de_t *)self->internal;
+    const int N = ds->num_instances;
+    const int K = crf1de->num_features;
+
+    /*
+        Initialize the gradients with observation expectations.
+     */
+    for (i = 0; i < K; ++i)
+    {
+        crf1df_feature_t *f = &crf1de->features[i];
+        g[i] = -f->freq;
+    }
+
+    /*
+        Set the scores (weights) of transition features here because
+        these are independent of input label sequences.
+     */
+    crf1dc_reset(crf1de->ctx, RF_TRANS);
+    crf1de_transition_score(crf1de, w);
+    crf1dc_exp_transition(crf1de->ctx);
+
+    /*
+        Compute model expectations.
+     */
+    for (i = 0; i < N; ++i)
+    {
+        const crfsuite_instance_t *seq = dataset_get(ds, i);
+
+        /* Set label sequences and state scores. */
+        crf1dc_set_num_items(crf1de->ctx, seq->num_items);
+        crf1dc_reset(crf1de->ctx, RF_STATE);
+        crf1de_state_score(crf1de, seq, w);
+        crf1dc_exp_state(crf1de->ctx);
+
+        /* Compute forward/backward scores. */
+        crf1dc_alpha_score(crf1de->ctx);
+        crf1dc_beta_score(crf1de->ctx);
+        crf1dc_marginals(crf1de->ctx);
+
+        /* Compute the probability of the input sequence on the model. */
+        logp = crf1dc_score(crf1de->ctx, seq->labels) - crf1dc_lognorm(crf1de->ctx);
+        /* Update the log-likelihood. */
+        logl += logp * seq->weight;
+
+        /* Update the model expectations of features. */
+        crf1de_model_expectation(crf1de, seq, g, seq->weight);
+    }
+
+    *f = -logl;
+    return 0;
+}
+
+/* LEVEL_NONE -> LEVEL_NONE. */
+static int encoder_features_on_path(encoder_t *self, const crfsuite_instance_t *inst, const int *path, crfsuite_encoder_features_on_path_callback func, void *instance)
+{
+    crf1de_t *crf1de = (crf1de_t *)self->internal;
+    crf1de_features_on_path(crf1de, inst, path, func, instance);
+    return 0;
+}
+
+/* LEVEL_NONE -> LEVEL_NONE. */
+static int encoder_save_model(encoder_t *self, const char *filename, const floatval_t *w, logging_t *lg)
+{
+    crf1de_t *crf1de = (crf1de_t *)self->internal;
+    return crf1de_save_model(crf1de, filename, w, self->ds->data->attrs, self->ds->data->labels, lg);
+}
+
+/* LEVEL_NONE -> LEVEL_WEIGHT. */
+static int encoder_set_weights(encoder_t *self, const floatval_t *w, floatval_t scale)
+{
+    self->w = w;
+    self->scale = scale;
+    self->level = LEVEL_WEIGHT - 1;
+    set_level(self, LEVEL_WEIGHT);
+    return 0;
+}
+
+/* LEVEL_WEIGHT -> LEVEL_INSTANCE. */
+static int encoder_set_instance(encoder_t *self, const crfsuite_instance_t *inst)
+{
+    self->inst = inst;
+    self->level = LEVEL_INSTANCE - 1;
+    set_level(self, LEVEL_INSTANCE);
+    return 0;
+}
+
+/* LEVEL_INSTANCE -> LEVEL_INSTANCE. */
+static int encoder_score(encoder_t *self, const int *path, floatval_t *ptr_score)
+{
+    crf1de_t *crf1de = (crf1de_t *)self->internal;
+    *ptr_score = crf1dc_score(crf1de->ctx, path);
+    return 0;
+}
+
+/* LEVEL_INSTANCE -> LEVEL_INSTANCE. */
+static int encoder_viterbi(encoder_t *self, int *path, floatval_t *ptr_score)
+{
+    int i;
+    floatval_t score;
+    crf1de_t *crf1de = (crf1de_t *)self->internal;
+    score = crf1dc_viterbi(crf1de->ctx, path);
+    if (ptr_score != NULL)
+    {
+        *ptr_score = score;
+    }
+    return 0;
+}
+
+/* LEVEL_INSTANCE -> LEVEL_ALPHABETA. */
+static int encoder_partition_factor(encoder_t *self, floatval_t *ptr_pf)
+{
+    crf1de_t *crf1de = (crf1de_t *)self->internal;
+    set_level(self, LEVEL_ALPHABETA);
+    *ptr_pf = crf1dc_lognorm(crf1de->ctx);
+    return 0;
+}
+
+/* LEVEL_INSTANCE -> LEVEL_MARGINAL. */
+static int encoder_objective_and_gradients(encoder_t *self, floatval_t *f, floatval_t *g, floatval_t gain, floatval_t weight)
+{
+    crf1de_t *crf1de = (crf1de_t *)self->internal;
+    set_level(self, LEVEL_MARGINAL);
+    gain *= weight;
+    crf1de_observation_expectation(crf1de, self->inst, self->inst->labels, g, gain);
+    crf1de_model_expectation(crf1de, self->inst, g, -gain);
+    *f = (-crf1dc_score(crf1de->ctx, self->inst->labels) + crf1dc_lognorm(crf1de->ctx)) * weight;
+    return 0;
+}
+
+static void encoder_release(encoder_t *self)
+{
+    crf1de_t *crf1de = (crf1de_t *)self->internal;
+    crf1de_finish(crf1de);
+    free(crf1de);
+    free(self);
+}
+
+encoder_t *crf1d_create_encoder()
+{
+    encoder_t *self = (encoder_t *)calloc(1, sizeof(encoder_t));
+    if (self != NULL)
+    {
+        crf1de_t *enc = (crf1de_t *)calloc(1, sizeof(crf1de_t));
+        if (enc != NULL)
+        {
+            crf1de_init(enc);
+
+            self->exchange_options = encoder_exchange_options;
+            self->initialize = encoder_initialize;
+            self->objective_and_gradients_batch = encoder_objective_and_gradients_batch;
+            self->save_model = encoder_save_model;
+            self->features_on_path = encoder_features_on_path;
+            self->set_weights = encoder_set_weights;
+            self->set_instance = encoder_set_instance;
+            self->score = encoder_score;
+            self->viterbi = encoder_viterbi;
+            self->partition_factor = encoder_partition_factor;
+            self->objective_and_gradients = encoder_objective_and_gradients;
+            self->release = encoder_release;
+            self->internal = enc;
+        }
+    }
+
+    return self;
+}
```

## chaine/_core/crfsuite/lib/crf/src/crf1d_feature.c

 * *Ordering differences only*

```diff
@@ -1,382 +1,382 @@
-/*
- *      CRF1d feature generator (dyad features).
- *
- * Copyright (c) 2007-2010, Naoaki Okazaki
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the names of the authors nor the names of its contributors
- *       may be used to endorse or promote products derived from this
- *       software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
- * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-/* $Id$ */
-
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif /*HAVE_CONFIG_H*/
-
-#include <os.h>
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-
-#include <crfsuite.h>
-
-#include "logging.h"
-#include "crf1d.h"
-#include "rumavl.h" /* AVL tree library necessary for feature generation. */
-
-/**
- * Feature set.
- */
-typedef struct
-{
-    RUMAVL *avl; /**< Root node of the AVL tree. */
-    int num;     /**< Number of features in the AVL tree. */
-} featureset_t;
-
-#define COMP(a, b) ((a) > (b)) - ((a) < (b))
-
-static int featureset_comp(const void *x, const void *y, size_t n, void *udata)
-{
-    int ret = 0;
-    const crf1df_feature_t *f1 = (const crf1df_feature_t *)x;
-    const crf1df_feature_t *f2 = (const crf1df_feature_t *)y;
-
-    ret = COMP(f1->type, f2->type);
-    if (ret == 0)
-    {
-        ret = COMP(f1->src, f2->src);
-        if (ret == 0)
-        {
-            ret = COMP(f1->dst, f2->dst);
-        }
-    }
-    return ret;
-}
-
-static featureset_t *featureset_new()
-{
-    featureset_t *set = NULL;
-    set = (featureset_t *)calloc(1, sizeof(featureset_t));
-    if (set != NULL)
-    {
-        set->num = 0;
-        set->avl = rumavl_new(
-            sizeof(crf1df_feature_t), featureset_comp, NULL, NULL);
-        if (set->avl == NULL)
-        {
-            free(set);
-            set = NULL;
-        }
-    }
-    return set;
-}
-
-static void featureset_delete(featureset_t *set)
-{
-    if (set != NULL)
-    {
-        rumavl_destroy(set->avl);
-        free(set);
-    }
-}
-
-static int featureset_add(featureset_t *set, const crf1df_feature_t *f)
-{
-    /* Check whether if the feature already exists. */
-    crf1df_feature_t *p = (crf1df_feature_t *)rumavl_find(set->avl, f);
-    if (p == NULL)
-    {
-        /* Insert the feature to the feature set. */
-        rumavl_insert(set->avl, f);
-        ++set->num;
-    }
-    else
-    {
-        /* An existing feature: add the observation expectation. */
-        p->freq += f->freq;
-    }
-    return 0;
-}
-
-static crf1df_feature_t *
-featureset_generate(
-    int *ptr_num_features,
-    featureset_t *set,
-    floatval_t minfreq)
-{
-    int n = 0, k = 0;
-    RUMAVL_NODE *node = NULL;
-    crf1df_feature_t *f = NULL;
-    crf1df_feature_t *features = NULL;
-
-    /* The first pass: count the number of valid features. */
-    while ((node = rumavl_node_next(set->avl, node, 1, (void **)&f)) != NULL)
-    {
-        if (minfreq <= f->freq)
-        {
-            ++n;
-        }
-    }
-
-    /* The second path: copy the valid features to the feature array. */
-    features = (crf1df_feature_t *)calloc(n, sizeof(crf1df_feature_t));
-    if (features != NULL)
-    {
-        node = NULL;
-        while ((node = rumavl_node_next(set->avl, node, 1, (void **)&f)) != NULL)
-        {
-            if (minfreq <= f->freq)
-            {
-                memcpy(&features[k], f, sizeof(crf1df_feature_t));
-                ++k;
-            }
-        }
-        *ptr_num_features = n;
-        return features;
-    }
-    else
-    {
-        *ptr_num_features = 0;
-        return NULL;
-    }
-}
-
-crf1df_feature_t *crf1df_generate(
-    int *ptr_num_features,
-    dataset_t *ds,
-    int num_labels,
-    int num_attributes,
-    int connect_all_attrs,
-    int connect_all_edges,
-    floatval_t minfreq,
-    crfsuite_logging_callback func,
-    void *instance)
-{
-    int c, i, j, s, t;
-    crf1df_feature_t f;
-    crf1df_feature_t *features = NULL;
-    featureset_t *set = NULL;
-    const int N = ds->num_instances;
-    const int L = num_labels;
-    logging_t lg;
-
-    lg.func = func;
-    lg.instance = instance;
-    lg.percent = 0;
-
-    /* Create an instance of feature set. */
-    set = featureset_new();
-
-    /* Loop over the sequences in the training data. */
-    for (s = 0; s < N; ++s)
-    {
-        int prev = L, cur = 0;
-        const crfsuite_item_t *item = NULL;
-        const crfsuite_instance_t *seq = dataset_get(ds, s);
-        const int T = seq->num_items;
-
-        /* Loop over the items in the sequence. */
-        for (t = 0; t < T; ++t)
-        {
-            item = &seq->items[t];
-            cur = seq->labels[t];
-
-            /* Transition feature: label #prev -> label #(item->yid).
-               Features with previous label #L are transition BOS. */
-            if (prev != L)
-            {
-                f.type = FT_TRANS;
-                f.src = prev;
-                f.dst = cur;
-                f.freq = seq->weight;
-                featureset_add(set, &f);
-            }
-
-            for (c = 0; c < item->num_contents; ++c)
-            {
-                /* State feature: attribute #a -> state #(item->yid). */
-                f.type = FT_STATE;
-                f.src = item->contents[c].aid;
-                f.dst = cur;
-                f.freq = seq->weight * item->contents[c].value;
-                featureset_add(set, &f);
-
-                /* Generate state features connecting attributes with all
-                   output labels. These features are not unobserved in the
-                   training data (zero expexcations). */
-                if (connect_all_attrs)
-                {
-                    for (i = 0; i < L; ++i)
-                    {
-                        f.type = FT_STATE;
-                        f.src = item->contents[c].aid;
-                        f.dst = i;
-                        f.freq = 0;
-                        featureset_add(set, &f);
-                    }
-                }
-            }
-
-            prev = cur;
-        }
-
-        logging_progress(&lg, s * 100 / N);
-    }
-    logging_progress_end(&lg);
-
-    /* Generate edge features representing all pairs of labels.
-       These features are not unobserved in the training data
-       (zero expexcations). */
-    if (connect_all_edges)
-    {
-        for (i = 0; i < L; ++i)
-        {
-            for (j = 0; j < L; ++j)
-            {
-                f.type = FT_TRANS;
-                f.src = i;
-                f.dst = j;
-                f.freq = 0;
-                featureset_add(set, &f);
-            }
-        }
-    }
-
-    /* Convert the feature set to an feature array. */
-    features = featureset_generate(ptr_num_features, set, minfreq);
-
-    /* Delete the feature set. */
-    featureset_delete(set);
-
-    return features;
-}
-
-int crf1df_init_references(
-    feature_refs_t **ptr_attributes,
-    feature_refs_t **ptr_trans,
-    const crf1df_feature_t *features,
-    const int K,
-    const int A,
-    const int L)
-{
-    int i, k;
-    feature_refs_t *fl = NULL;
-    feature_refs_t *attributes = NULL;
-    feature_refs_t *trans = NULL;
-
-    /*
-        The purpose of this routine is to collect references (indices) of:
-        - state features fired by each attribute (attributes)
-        - transition features pointing from each label (trans)
-    */
-
-    /* Allocate arrays for feature references. */
-    attributes = (feature_refs_t *)calloc(A, sizeof(feature_refs_t));
-    if (attributes == NULL)
-        goto error_exit;
-    trans = (feature_refs_t *)calloc(L, sizeof(feature_refs_t));
-    if (trans == NULL)
-        goto error_exit;
-
-    /*
-        Firstly, loop over the features to count the number of references.
-        We don't use realloc() to avoid memory fragmentation.
-     */
-    for (k = 0; k < K; ++k)
-    {
-        const crf1df_feature_t *f = &features[k];
-        switch (f->type)
-        {
-        case FT_STATE:
-            attributes[f->src].num_features++;
-            break;
-        case FT_TRANS:
-            trans[f->src].num_features++;
-            break;
-        }
-    }
-
-    /*
-        Secondarily, allocate memory blocks to store the feature references.
-        We also clear fl->num_features fields, which will be used as indices
-        in the next phase.
-     */
-    for (i = 0; i < A; ++i)
-    {
-        fl = &attributes[i];
-        fl->fids = (int *)calloc(fl->num_features, sizeof(int));
-        if (fl->fids == NULL)
-            goto error_exit;
-        fl->num_features = 0;
-    }
-    for (i = 0; i < L; ++i)
-    {
-        fl = &trans[i];
-        fl->fids = (int *)calloc(fl->num_features, sizeof(int));
-        if (fl->fids == NULL)
-            goto error_exit;
-        fl->num_features = 0;
-    }
-
-    /*
-        Finally, store the feature indices.
-     */
-    for (k = 0; k < K; ++k)
-    {
-        const crf1df_feature_t *f = &features[k];
-        switch (f->type)
-        {
-        case FT_STATE:
-            fl = &attributes[f->src];
-            fl->fids[fl->num_features++] = k;
-            break;
-        case FT_TRANS:
-            fl = &trans[f->src];
-            fl->fids[fl->num_features++] = k;
-            break;
-        }
-    }
-
-    *ptr_attributes = attributes;
-    *ptr_trans = trans;
-    return 0;
-
-error_exit:
-    if (attributes != NULL)
-    {
-        for (i = 0; i < A; ++i)
-            free(attributes[i].fids);
-        free(attributes);
-    }
-    if (trans != NULL)
-    {
-        for (i = 0; i < L; ++i)
-            free(trans[i].fids);
-        free(trans);
-    }
-    *ptr_attributes = NULL;
-    *ptr_trans = NULL;
-    return -1;
-}
+/*
+ *      CRF1d feature generator (dyad features).
+ *
+ * Copyright (c) 2007-2010, Naoaki Okazaki
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the names of the authors nor the names of its contributors
+ *       may be used to endorse or promote products derived from this
+ *       software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+ * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/* $Id$ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif /*HAVE_CONFIG_H*/
+
+#include <os.h>
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include <crfsuite.h>
+
+#include "logging.h"
+#include "crf1d.h"
+#include "rumavl.h" /* AVL tree library necessary for feature generation. */
+
+/**
+ * Feature set.
+ */
+typedef struct
+{
+    RUMAVL *avl; /**< Root node of the AVL tree. */
+    int num;     /**< Number of features in the AVL tree. */
+} featureset_t;
+
+#define COMP(a, b) ((a) > (b)) - ((a) < (b))
+
+static int featureset_comp(const void *x, const void *y, size_t n, void *udata)
+{
+    int ret = 0;
+    const crf1df_feature_t *f1 = (const crf1df_feature_t *)x;
+    const crf1df_feature_t *f2 = (const crf1df_feature_t *)y;
+
+    ret = COMP(f1->type, f2->type);
+    if (ret == 0)
+    {
+        ret = COMP(f1->src, f2->src);
+        if (ret == 0)
+        {
+            ret = COMP(f1->dst, f2->dst);
+        }
+    }
+    return ret;
+}
+
+static featureset_t *featureset_new()
+{
+    featureset_t *set = NULL;
+    set = (featureset_t *)calloc(1, sizeof(featureset_t));
+    if (set != NULL)
+    {
+        set->num = 0;
+        set->avl = rumavl_new(
+            sizeof(crf1df_feature_t), featureset_comp, NULL, NULL);
+        if (set->avl == NULL)
+        {
+            free(set);
+            set = NULL;
+        }
+    }
+    return set;
+}
+
+static void featureset_delete(featureset_t *set)
+{
+    if (set != NULL)
+    {
+        rumavl_destroy(set->avl);
+        free(set);
+    }
+}
+
+static int featureset_add(featureset_t *set, const crf1df_feature_t *f)
+{
+    /* Check whether if the feature already exists. */
+    crf1df_feature_t *p = (crf1df_feature_t *)rumavl_find(set->avl, f);
+    if (p == NULL)
+    {
+        /* Insert the feature to the feature set. */
+        rumavl_insert(set->avl, f);
+        ++set->num;
+    }
+    else
+    {
+        /* An existing feature: add the observation expectation. */
+        p->freq += f->freq;
+    }
+    return 0;
+}
+
+static crf1df_feature_t *
+featureset_generate(
+    int *ptr_num_features,
+    featureset_t *set,
+    floatval_t minfreq)
+{
+    int n = 0, k = 0;
+    RUMAVL_NODE *node = NULL;
+    crf1df_feature_t *f = NULL;
+    crf1df_feature_t *features = NULL;
+
+    /* The first pass: count the number of valid features. */
+    while ((node = rumavl_node_next(set->avl, node, 1, (void **)&f)) != NULL)
+    {
+        if (minfreq <= f->freq)
+        {
+            ++n;
+        }
+    }
+
+    /* The second path: copy the valid features to the feature array. */
+    features = (crf1df_feature_t *)calloc(n, sizeof(crf1df_feature_t));
+    if (features != NULL)
+    {
+        node = NULL;
+        while ((node = rumavl_node_next(set->avl, node, 1, (void **)&f)) != NULL)
+        {
+            if (minfreq <= f->freq)
+            {
+                memcpy(&features[k], f, sizeof(crf1df_feature_t));
+                ++k;
+            }
+        }
+        *ptr_num_features = n;
+        return features;
+    }
+    else
+    {
+        *ptr_num_features = 0;
+        return NULL;
+    }
+}
+
+crf1df_feature_t *crf1df_generate(
+    int *ptr_num_features,
+    dataset_t *ds,
+    int num_labels,
+    int num_attributes,
+    int connect_all_attrs,
+    int connect_all_edges,
+    floatval_t minfreq,
+    crfsuite_logging_callback func,
+    void *instance)
+{
+    int c, i, j, s, t;
+    crf1df_feature_t f;
+    crf1df_feature_t *features = NULL;
+    featureset_t *set = NULL;
+    const int N = ds->num_instances;
+    const int L = num_labels;
+    logging_t lg;
+
+    lg.func = func;
+    lg.instance = instance;
+    lg.percent = 0;
+
+    /* Create an instance of feature set. */
+    set = featureset_new();
+
+    /* Loop over the sequences in the training data. */
+    for (s = 0; s < N; ++s)
+    {
+        int prev = L, cur = 0;
+        const crfsuite_item_t *item = NULL;
+        const crfsuite_instance_t *seq = dataset_get(ds, s);
+        const int T = seq->num_items;
+
+        /* Loop over the items in the sequence. */
+        for (t = 0; t < T; ++t)
+        {
+            item = &seq->items[t];
+            cur = seq->labels[t];
+
+            /* Transition feature: label #prev -> label #(item->yid).
+               Features with previous label #L are transition BOS. */
+            if (prev != L)
+            {
+                f.type = FT_TRANS;
+                f.src = prev;
+                f.dst = cur;
+                f.freq = seq->weight;
+                featureset_add(set, &f);
+            }
+
+            for (c = 0; c < item->num_contents; ++c)
+            {
+                /* State feature: attribute #a -> state #(item->yid). */
+                f.type = FT_STATE;
+                f.src = item->contents[c].aid;
+                f.dst = cur;
+                f.freq = seq->weight * item->contents[c].value;
+                featureset_add(set, &f);
+
+                /* Generate state features connecting attributes with all
+                   output labels. These features are not unobserved in the
+                   training data (zero expexcations). */
+                if (connect_all_attrs)
+                {
+                    for (i = 0; i < L; ++i)
+                    {
+                        f.type = FT_STATE;
+                        f.src = item->contents[c].aid;
+                        f.dst = i;
+                        f.freq = 0;
+                        featureset_add(set, &f);
+                    }
+                }
+            }
+
+            prev = cur;
+        }
+
+        logging_progress(&lg, s * 100 / N);
+    }
+    logging_progress_end(&lg);
+
+    /* Generate edge features representing all pairs of labels.
+       These features are not unobserved in the training data
+       (zero expexcations). */
+    if (connect_all_edges)
+    {
+        for (i = 0; i < L; ++i)
+        {
+            for (j = 0; j < L; ++j)
+            {
+                f.type = FT_TRANS;
+                f.src = i;
+                f.dst = j;
+                f.freq = 0;
+                featureset_add(set, &f);
+            }
+        }
+    }
+
+    /* Convert the feature set to an feature array. */
+    features = featureset_generate(ptr_num_features, set, minfreq);
+
+    /* Delete the feature set. */
+    featureset_delete(set);
+
+    return features;
+}
+
+int crf1df_init_references(
+    feature_refs_t **ptr_attributes,
+    feature_refs_t **ptr_trans,
+    const crf1df_feature_t *features,
+    const int K,
+    const int A,
+    const int L)
+{
+    int i, k;
+    feature_refs_t *fl = NULL;
+    feature_refs_t *attributes = NULL;
+    feature_refs_t *trans = NULL;
+
+    /*
+        The purpose of this routine is to collect references (indices) of:
+        - state features fired by each attribute (attributes)
+        - transition features pointing from each label (trans)
+    */
+
+    /* Allocate arrays for feature references. */
+    attributes = (feature_refs_t *)calloc(A, sizeof(feature_refs_t));
+    if (attributes == NULL)
+        goto error_exit;
+    trans = (feature_refs_t *)calloc(L, sizeof(feature_refs_t));
+    if (trans == NULL)
+        goto error_exit;
+
+    /*
+        Firstly, loop over the features to count the number of references.
+        We don't use realloc() to avoid memory fragmentation.
+     */
+    for (k = 0; k < K; ++k)
+    {
+        const crf1df_feature_t *f = &features[k];
+        switch (f->type)
+        {
+        case FT_STATE:
+            attributes[f->src].num_features++;
+            break;
+        case FT_TRANS:
+            trans[f->src].num_features++;
+            break;
+        }
+    }
+
+    /*
+        Secondarily, allocate memory blocks to store the feature references.
+        We also clear fl->num_features fields, which will be used as indices
+        in the next phase.
+     */
+    for (i = 0; i < A; ++i)
+    {
+        fl = &attributes[i];
+        fl->fids = (int *)calloc(fl->num_features, sizeof(int));
+        if (fl->fids == NULL)
+            goto error_exit;
+        fl->num_features = 0;
+    }
+    for (i = 0; i < L; ++i)
+    {
+        fl = &trans[i];
+        fl->fids = (int *)calloc(fl->num_features, sizeof(int));
+        if (fl->fids == NULL)
+            goto error_exit;
+        fl->num_features = 0;
+    }
+
+    /*
+        Finally, store the feature indices.
+     */
+    for (k = 0; k < K; ++k)
+    {
+        const crf1df_feature_t *f = &features[k];
+        switch (f->type)
+        {
+        case FT_STATE:
+            fl = &attributes[f->src];
+            fl->fids[fl->num_features++] = k;
+            break;
+        case FT_TRANS:
+            fl = &trans[f->src];
+            fl->fids[fl->num_features++] = k;
+            break;
+        }
+    }
+
+    *ptr_attributes = attributes;
+    *ptr_trans = trans;
+    return 0;
+
+error_exit:
+    if (attributes != NULL)
+    {
+        for (i = 0; i < A; ++i)
+            free(attributes[i].fids);
+        free(attributes);
+    }
+    if (trans != NULL)
+    {
+        for (i = 0; i < L; ++i)
+            free(trans[i].fids);
+        free(trans);
+    }
+    *ptr_attributes = NULL;
+    *ptr_trans = NULL;
+    return -1;
+}
```

## chaine/_core/crfsuite/lib/crf/src/crf1d_model.c

 * *Ordering differences only*

```diff
@@ -1,1085 +1,1085 @@
-/*
- *      CRF1d model.
- *
- * Copyright (c) 2007-2010, Naoaki Okazaki
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the names of the authors nor the names of its contributors
- *       may be used to endorse or promote products derived from this
- *       software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
- * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-/* $Id$ */
-
-#include "os.h"
-
-#include <inttypes.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <cqdb.h>
-
-#include <crfsuite.h>
-#include "crf1d.h"
-#include "json.h"
-
-#define FILEMAGIC "lCRF"
-#define MODELTYPE "FOMC"
-#define VERSION_NUMBER (100)
-#define CHUNK_LABELREF "LFRF"
-#define CHUNK_ATTRREF "AFRF"
-#define CHUNK_FEATURE "FEAT"
-#define HEADER_SIZE 48
-#define CHUNK_SIZE 12
-#define FEATURE_SIZE 20
-
-enum
-{
-    WSTATE_NONE,
-    WSTATE_LABELS,
-    WSTATE_ATTRS,
-    WSTATE_LABELREFS,
-    WSTATE_ATTRREFS,
-    WSTATE_FEATURES,
-};
-
-typedef struct
-{
-    uint8_t magic[4];       /* File magic. */
-    uint32_t size;          /* File size. */
-    uint8_t type[4];        /* Model type */
-    uint32_t version;       /* Version number. */
-    uint32_t num_features;  /* Number of features. */
-    uint32_t num_labels;    /* Number of labels. */
-    uint32_t num_attrs;     /* Number of attributes. */
-    uint32_t off_features;  /* Offset to features. */
-    uint32_t off_labels;    /* Offset to label CQDB. */
-    uint32_t off_attrs;     /* Offset to attribute CQDB. */
-    uint32_t off_labelrefs; /* Offset to label feature references. */
-    uint32_t off_attrrefs;  /* Offset to attribute feature references. */
-} header_t;
-
-typedef struct
-{
-    uint8_t chunk[4];    /* Chunk id */
-    uint32_t size;       /* Chunk size. */
-    uint32_t num;        /* Number of items. */
-    uint32_t offsets[1]; /* Offsets. */
-} featureref_header_t;
-
-typedef struct
-{
-    uint8_t chunk[4]; /* Chunk id */
-    uint32_t size;    /* Chunk size. */
-    uint32_t num;     /* Number of items. */
-} feature_header_t;
-
-struct tag_crf1dm
-{
-    uint8_t *buffer_orig;
-    const uint8_t *buffer;
-    uint32_t size;
-    header_t *header;
-    cqdb_t *labels;
-    cqdb_t *attrs;
-};
-
-struct tag_crf1dmw
-{
-    FILE *fp;
-    int state;
-    header_t header;
-    cqdb_writer_t *dbw;
-    featureref_header_t *href;
-    feature_header_t *hfeat;
-};
-
-enum
-{
-    KT_GLOBAL = 'A',
-    KT_NUMATTRS,
-    KT_NUMLABELS,
-    KT_STR2LID,
-    KT_LID2STR,
-    KT_STR2AID,
-    KT_FEATURE,
-};
-
-static int write_uint8(FILE *fp, uint8_t value)
-{
-    return fwrite(&value, sizeof(value), 1, fp) == 1 ? 0 : 1;
-}
-
-static int read_uint8(const uint8_t *buffer, uint8_t *value)
-{
-    *value = *buffer;
-    return sizeof(*value);
-}
-
-static int write_uint32(FILE *fp, uint32_t value)
-{
-    uint8_t buffer[4];
-    buffer[0] = (uint8_t)(value & 0xFF);
-    buffer[1] = (uint8_t)(value >> 8);
-    buffer[2] = (uint8_t)(value >> 16);
-    buffer[3] = (uint8_t)(value >> 24);
-    return fwrite(buffer, sizeof(uint8_t), 4, fp) == 4 ? 0 : 1;
-}
-
-static int read_uint32(const uint8_t *buffer, uint32_t *value)
-{
-    *value = ((uint32_t)buffer[0]);
-    *value |= ((uint32_t)buffer[1] << 8);
-    *value |= ((uint32_t)buffer[2] << 16);
-    *value |= ((uint32_t)buffer[3] << 24);
-    return sizeof(*value);
-}
-
-static int write_uint8_array(FILE *fp, uint8_t *array, size_t n)
-{
-    size_t i;
-    int ret = 0;
-    for (i = 0; i < n; ++i)
-    {
-        ret |= write_uint8(fp, array[i]);
-    }
-    return ret;
-}
-
-static int read_uint8_array(const uint8_t *buffer, uint8_t *array, size_t n)
-{
-    size_t i;
-    int ret = 0;
-    for (i = 0; i < n; ++i)
-    {
-        int size = read_uint8(buffer, &array[i]);
-        buffer += size;
-        ret += size;
-    }
-    return ret;
-}
-
-static void write_float(FILE *fp, floatval_t value)
-{
-    /*
-        We assume:
-            - sizeof(floatval_t) = sizeof(double) = sizeof(uint64_t)
-            - the byte order of floatval_t and uint64_t is the same
-            - ARM's mixed-endian is not supported
-    */
-    uint64_t iv;
-    uint8_t buffer[8];
-
-    /* Copy the memory image of floatval_t value to uint64_t. */
-    memcpy(&iv, &value, sizeof(iv));
-
-    buffer[0] = (uint8_t)(iv & 0xFF);
-    buffer[1] = (uint8_t)(iv >> 8);
-    buffer[2] = (uint8_t)(iv >> 16);
-    buffer[3] = (uint8_t)(iv >> 24);
-    buffer[4] = (uint8_t)(iv >> 32);
-    buffer[5] = (uint8_t)(iv >> 40);
-    buffer[6] = (uint8_t)(iv >> 48);
-    buffer[7] = (uint8_t)(iv >> 56);
-    fwrite(buffer, sizeof(uint8_t), 8, fp);
-}
-
-static int read_float(const uint8_t *buffer, floatval_t *value)
-{
-    uint64_t iv;
-    iv = ((uint64_t)buffer[0]);
-    iv |= ((uint64_t)buffer[1] << 8);
-    iv |= ((uint64_t)buffer[2] << 16);
-    iv |= ((uint64_t)buffer[3] << 24);
-    iv |= ((uint64_t)buffer[4] << 32);
-    iv |= ((uint64_t)buffer[5] << 40);
-    iv |= ((uint64_t)buffer[6] << 48);
-    iv |= ((uint64_t)buffer[7] << 56);
-    memcpy(value, &iv, sizeof(*value));
-    return sizeof(*value);
-}
-
-crf1dmw_t *crf1mmw(const char *filename)
-{
-    header_t *header = NULL;
-    crf1dmw_t *writer = NULL;
-
-    /* Create a writer instance. */
-    writer = (crf1dmw_t *)calloc(1, sizeof(crf1dmw_t));
-    if (writer == NULL)
-    {
-        goto error_exit;
-    }
-
-    /* Open the file for writing. */
-    writer->fp = fopen(filename, "wb");
-    if (writer->fp == NULL)
-    {
-        goto error_exit;
-    }
-
-    /* Fill the members in the header. */
-    header = &writer->header;
-    memcpy(header->magic, FILEMAGIC, 4);
-    memcpy(header->type, MODELTYPE, 4);
-    header->version = VERSION_NUMBER;
-
-    /* Advance the file position to skip the file header. */
-    if (fseek(writer->fp, HEADER_SIZE, SEEK_CUR) != 0)
-    {
-        goto error_exit;
-    }
-
-    return writer;
-
-error_exit:
-    if (writer != NULL)
-    {
-        if (writer->fp != NULL)
-        {
-            fclose(writer->fp);
-        }
-        free(writer);
-    }
-    return NULL;
-}
-
-int crf1dmw_close(crf1dmw_t *writer)
-{
-    FILE *fp = writer->fp;
-    header_t *header = &writer->header;
-
-    /* Store the file size. */
-    header->size = (uint32_t)ftell(fp);
-
-    /* Move the file position to the head. */
-    if (fseek(fp, 0, SEEK_SET) != 0)
-    {
-        goto error_exit;
-    }
-
-    /* Write the file header. */
-    write_uint8_array(fp, header->magic, sizeof(header->magic));
-    write_uint32(fp, header->size);
-    write_uint8_array(fp, header->type, sizeof(header->type));
-    write_uint32(fp, header->version);
-    write_uint32(fp, header->num_features);
-    write_uint32(fp, header->num_labels);
-    write_uint32(fp, header->num_attrs);
-    write_uint32(fp, header->off_features);
-    write_uint32(fp, header->off_labels);
-    write_uint32(fp, header->off_attrs);
-    write_uint32(fp, header->off_labelrefs);
-    write_uint32(fp, header->off_attrrefs);
-
-    /* Check for any error occurrence. */
-    if (ferror(fp))
-    {
-        goto error_exit;
-    }
-
-    /* Close the writer. */
-    fclose(fp);
-    free(writer);
-    return 0;
-
-error_exit:
-    if (writer != NULL)
-    {
-        if (writer->fp != NULL)
-        {
-            fclose(writer->fp);
-        }
-        free(writer);
-    }
-    return 1;
-}
-
-int crf1dmw_open_labels(crf1dmw_t *writer, int num_labels)
-{
-    /* Check if we aren't writing anything at this moment. */
-    if (writer->state != WSTATE_NONE)
-    {
-        return 1;
-    }
-
-    /* Store the current offset. */
-    writer->header.off_labels = (uint32_t)ftell(writer->fp);
-
-    /* Open a CQDB chunk for writing. */
-    writer->dbw = cqdb_writer(writer->fp, 0);
-    if (writer->dbw == NULL)
-    {
-        writer->header.off_labels = 0;
-        return 1;
-    }
-
-    writer->state = WSTATE_LABELS;
-    writer->header.num_labels = num_labels;
-    return 0;
-}
-
-int crf1dmw_close_labels(crf1dmw_t *writer)
-{
-    /* Make sure that we are writing labels. */
-    if (writer->state != WSTATE_LABELS)
-    {
-        return 1;
-    }
-
-    /* Close the CQDB chunk. */
-    if (cqdb_writer_close(writer->dbw))
-    {
-        return 1;
-    }
-
-    writer->dbw = NULL;
-    writer->state = WSTATE_NONE;
-    return 0;
-}
-
-int crf1dmw_put_label(crf1dmw_t *writer, int lid, const char *value)
-{
-    /* Make sure that we are writing labels. */
-    if (writer->state != WSTATE_LABELS)
-    {
-        return 1;
-    }
-
-    /* Put the label. */
-    if (cqdb_writer_put(writer->dbw, value, lid))
-    {
-        return 1;
-    }
-
-    return 0;
-}
-
-int crf1dmw_open_attrs(crf1dmw_t *writer, int num_attrs)
-{
-    /* Check if we aren't writing anything at this moment. */
-    if (writer->state != WSTATE_NONE)
-    {
-        return 1;
-    }
-
-    /* Store the current offset. */
-    writer->header.off_attrs = (uint32_t)ftell(writer->fp);
-
-    /* Open a CQDB chunk for writing. */
-    writer->dbw = cqdb_writer(writer->fp, 0);
-    if (writer->dbw == NULL)
-    {
-        writer->header.off_attrs = 0;
-        return 1;
-    }
-
-    writer->state = WSTATE_ATTRS;
-    writer->header.num_attrs = num_attrs;
-    return 0;
-}
-
-int crf1dmw_close_attrs(crf1dmw_t *writer)
-{
-    /* Make sure that we are writing attributes. */
-    if (writer->state != WSTATE_ATTRS)
-    {
-        return 1;
-    }
-
-    /* Close the CQDB chunk. */
-    if (cqdb_writer_close(writer->dbw))
-    {
-        return 1;
-    }
-
-    writer->dbw = NULL;
-    writer->state = WSTATE_NONE;
-    return 0;
-}
-
-int crf1dmw_put_attr(crf1dmw_t *writer, int aid, const char *value)
-{
-    /* Make sure that we are writing labels. */
-    if (writer->state != WSTATE_ATTRS)
-    {
-        return 1;
-    }
-
-    /* Put the attribute. */
-    if (cqdb_writer_put(writer->dbw, value, aid))
-    {
-        return 1;
-    }
-
-    return 0;
-}
-
-int crf1dmw_open_labelrefs(crf1dmw_t *writer, int num_labels)
-{
-    uint32_t offset;
-    FILE *fp = writer->fp;
-    featureref_header_t *href = NULL;
-    size_t size = CHUNK_SIZE + sizeof(uint32_t) * num_labels;
-
-    /* Check if we aren't writing anything at this moment. */
-    if (writer->state != WSTATE_NONE)
-    {
-        return CRFSUITEERR_INTERNAL_LOGIC;
-    }
-
-    /* Allocate a feature reference array. */
-    href = (featureref_header_t *)calloc(size, 1);
-    if (href == NULL)
-    {
-        return CRFSUITEERR_OUTOFMEMORY;
-    }
-
-    /* Align the offset to a DWORD boundary. */
-    offset = (uint32_t)ftell(fp);
-    while (offset % 4 != 0)
-    {
-        uint8_t c = 0;
-        fwrite(&c, sizeof(uint8_t), 1, fp);
-        ++offset;
-    }
-
-    /* Store the current offset position to the file header. */
-    writer->header.off_labelrefs = offset;
-    fseek(fp, size, SEEK_CUR);
-
-    /* Fill members in the feature reference header. */
-    memcpy(href->chunk, CHUNK_LABELREF, 4);
-    href->size = 0;
-    href->num = num_labels;
-
-    writer->href = href;
-    writer->state = WSTATE_LABELREFS;
-    return 0;
-}
-
-int crf1dmw_close_labelrefs(crf1dmw_t *writer)
-{
-    uint32_t i;
-    FILE *fp = writer->fp;
-    featureref_header_t *href = writer->href;
-    uint32_t begin = writer->header.off_labelrefs, end = 0;
-
-    /* Make sure that we are writing label feature references. */
-    if (writer->state != WSTATE_LABELREFS)
-    {
-        return CRFSUITEERR_INTERNAL_LOGIC;
-    }
-
-    /* Store the current offset position. */
-    end = (uint32_t)ftell(fp);
-
-    /* Compute the size of this chunk. */
-    href->size = (end - begin);
-
-    /* Write the chunk header and offset array. */
-    fseek(fp, begin, SEEK_SET);
-    write_uint8_array(fp, href->chunk, 4);
-    write_uint32(fp, href->size);
-    write_uint32(fp, href->num);
-    for (i = 0; i < href->num; ++i)
-    {
-        write_uint32(fp, href->offsets[i]);
-    }
-
-    /* Move the file pointer to the tail. */
-    fseek(fp, end, SEEK_SET);
-
-    /* Uninitialize. */
-    free(href);
-    writer->href = NULL;
-    writer->state = WSTATE_NONE;
-    return 0;
-}
-
-int crf1dmw_put_labelref(crf1dmw_t *writer, int lid, const feature_refs_t *ref, int *map)
-{
-    int i, fid;
-    uint32_t n = 0, offset = 0;
-    FILE *fp = writer->fp;
-    featureref_header_t *href = writer->href;
-
-    /* Make sure that we are writing label feature references. */
-    if (writer->state != WSTATE_LABELREFS)
-    {
-        return CRFSUITEERR_INTERNAL_LOGIC;
-    }
-
-    /* Store the current offset to the offset array. */
-    href->offsets[lid] = ftell(fp);
-
-    /* Count the number of references to active features. */
-    for (i = 0; i < ref->num_features; ++i)
-    {
-        if (0 <= map[ref->fids[i]])
-            ++n;
-    }
-
-    /* Write the feature reference. */
-    write_uint32(fp, (uint32_t)n);
-    for (i = 0; i < ref->num_features; ++i)
-    {
-        fid = map[ref->fids[i]];
-        if (0 <= fid)
-            write_uint32(fp, (uint32_t)fid);
-    }
-
-    return 0;
-}
-
-int crf1dmw_open_attrrefs(crf1dmw_t *writer, int num_attrs)
-{
-    uint32_t offset;
-    FILE *fp = writer->fp;
-    featureref_header_t *href = NULL;
-    size_t size = CHUNK_SIZE + sizeof(uint32_t) * num_attrs;
-
-    /* Check if we aren't writing anything at this moment. */
-    if (writer->state != WSTATE_NONE)
-    {
-        return CRFSUITEERR_INTERNAL_LOGIC;
-    }
-
-    /* Allocate a feature reference array. */
-    href = (featureref_header_t *)calloc(size, 1);
-    if (href == NULL)
-    {
-        return CRFSUITEERR_OUTOFMEMORY;
-    }
-
-    /* Align the offset to a DWORD boundary. */
-    offset = (uint32_t)ftell(fp);
-    while (offset % 4 != 0)
-    {
-        uint8_t c = 0;
-        fwrite(&c, sizeof(uint8_t), 1, fp);
-        ++offset;
-    }
-
-    /* Store the current offset position to the file header. */
-    writer->header.off_attrrefs = offset;
-    fseek(fp, size, SEEK_CUR);
-
-    /* Fill members in the feature reference header. */
-    memcpy(href->chunk, CHUNK_ATTRREF, 4);
-    href->size = 0;
-    href->num = num_attrs;
-
-    writer->href = href;
-    writer->state = WSTATE_ATTRREFS;
-    return 0;
-}
-
-int crf1dmw_close_attrrefs(crf1dmw_t *writer)
-{
-    uint32_t i;
-    FILE *fp = writer->fp;
-    featureref_header_t *href = writer->href;
-    uint32_t begin = writer->header.off_attrrefs, end = 0;
-
-    /* Make sure that we are writing attribute feature references. */
-    if (writer->state != WSTATE_ATTRREFS)
-    {
-        return CRFSUITEERR_INTERNAL_LOGIC;
-    }
-
-    /* Store the current offset position. */
-    end = (uint32_t)ftell(fp);
-
-    /* Compute the size of this chunk. */
-    href->size = (end - begin);
-
-    /* Write the chunk header and offset array. */
-    fseek(fp, begin, SEEK_SET);
-    write_uint8_array(fp, href->chunk, 4);
-    write_uint32(fp, href->size);
-    write_uint32(fp, href->num);
-    for (i = 0; i < href->num; ++i)
-    {
-        write_uint32(fp, href->offsets[i]);
-    }
-
-    /* Move the file pointer to the tail. */
-    fseek(fp, end, SEEK_SET);
-
-    /* Uninitialize. */
-    free(href);
-    writer->href = NULL;
-    writer->state = WSTATE_NONE;
-    return 0;
-}
-
-int crf1dmw_put_attrref(crf1dmw_t *writer, int aid, const feature_refs_t *ref, int *map)
-{
-    int i, fid;
-    uint32_t n = 0, offset = 0;
-    FILE *fp = writer->fp;
-    featureref_header_t *href = writer->href;
-
-    /* Make sure that we are writing attribute feature references. */
-    if (writer->state != WSTATE_ATTRREFS)
-    {
-        return CRFSUITEERR_INTERNAL_LOGIC;
-    }
-
-    /* Store the current offset to the offset array. */
-    href->offsets[aid] = ftell(fp);
-
-    /* Count the number of references to active features. */
-    for (i = 0; i < ref->num_features; ++i)
-    {
-        if (0 <= map[ref->fids[i]])
-            ++n;
-    }
-
-    /* Write the feature reference. */
-    write_uint32(fp, (uint32_t)n);
-    for (i = 0; i < ref->num_features; ++i)
-    {
-        fid = map[ref->fids[i]];
-        if (0 <= fid)
-            write_uint32(fp, (uint32_t)fid);
-    }
-
-    return 0;
-}
-
-int crf1dmw_open_features(crf1dmw_t *writer)
-{
-    FILE *fp = writer->fp;
-    feature_header_t *hfeat = NULL;
-
-    /* Check if we aren't writing anything at this moment. */
-    if (writer->state != WSTATE_NONE)
-    {
-        return CRFSUITEERR_INTERNAL_LOGIC;
-    }
-
-    /* Allocate a feature chunk header. */
-    hfeat = (feature_header_t *)calloc(sizeof(feature_header_t), 1);
-    if (hfeat == NULL)
-    {
-        return CRFSUITEERR_OUTOFMEMORY;
-    }
-
-    writer->header.off_features = (uint32_t)ftell(fp);
-    fseek(fp, CHUNK_SIZE, SEEK_CUR);
-
-    memcpy(hfeat->chunk, CHUNK_FEATURE, 4);
-    writer->hfeat = hfeat;
-
-    writer->state = WSTATE_FEATURES;
-    return 0;
-}
-
-int crf1dmw_close_features(crf1dmw_t *writer)
-{
-    FILE *fp = writer->fp;
-    feature_header_t *hfeat = writer->hfeat;
-    uint32_t begin = writer->header.off_features, end = 0;
-
-    /* Make sure that we are writing attribute feature references. */
-    if (writer->state != WSTATE_FEATURES)
-    {
-        return CRFSUITEERR_INTERNAL_LOGIC;
-    }
-
-    /* Store the current offset position. */
-    end = (uint32_t)ftell(fp);
-
-    /* Compute the size of this chunk. */
-    hfeat->size = (end - begin);
-
-    /* Write the chunk header and offset array. */
-    fseek(fp, begin, SEEK_SET);
-    write_uint8_array(fp, hfeat->chunk, 4);
-    write_uint32(fp, hfeat->size);
-    write_uint32(fp, hfeat->num);
-
-    /* Move the file pointer to the tail. */
-    fseek(fp, end, SEEK_SET);
-
-    /* Uninitialize. */
-    free(hfeat);
-    writer->hfeat = NULL;
-    writer->state = WSTATE_NONE;
-    return 0;
-}
-
-int crf1dmw_put_feature(crf1dmw_t *writer, int fid, const crf1dm_feature_t *f)
-{
-    FILE *fp = writer->fp;
-    feature_header_t *hfeat = writer->hfeat;
-
-    /* Make sure that we are writing attribute feature references. */
-    if (writer->state != WSTATE_FEATURES)
-    {
-        return CRFSUITEERR_INTERNAL_LOGIC;
-    }
-
-    /* We must put features #0, #1, ..., #(K-1) in this order. */
-    if (fid != hfeat->num)
-    {
-        return CRFSUITEERR_INTERNAL_LOGIC;
-    }
-
-    write_uint32(fp, f->type);
-    write_uint32(fp, f->src);
-    write_uint32(fp, f->dst);
-    write_float(fp, f->weight);
-    ++hfeat->num;
-    return 0;
-}
-
-static crf1dm_t *crf1dm_new_impl(uint8_t *buffer_orig, const uint8_t *buffer, uint32_t size)
-{
-    const uint8_t *p = NULL;
-    crf1dm_t *model = NULL;
-    header_t *header = NULL;
-
-    model = (crf1dm_t *)calloc(1, sizeof(crf1dm_t));
-    if (model == NULL)
-    {
-        goto error_exit;
-    }
-
-    model->buffer_orig = buffer_orig;
-    model->buffer = buffer;
-    model->size = size;
-
-    if (model->size <= sizeof(header_t))
-    {
-        goto error_exit;
-    }
-
-    header = (header_t *)calloc(1, sizeof(header_t));
-    if (header == NULL)
-    {
-        goto error_exit;
-    }
-
-    /* Read the file header. */
-    p = model->buffer;
-    p += read_uint8_array(p, header->magic, sizeof(header->magic));
-    p += read_uint32(p, &header->size);
-    p += read_uint8_array(p, header->type, sizeof(header->type));
-    p += read_uint32(p, &header->version);
-    p += read_uint32(p, &header->num_features);
-    p += read_uint32(p, &header->num_labels);
-    p += read_uint32(p, &header->num_attrs);
-    p += read_uint32(p, &header->off_features);
-    p += read_uint32(p, &header->off_labels);
-    p += read_uint32(p, &header->off_attrs);
-    p += read_uint32(p, &header->off_labelrefs);
-    p += read_uint32(p, &header->off_attrrefs);
-    model->header = header;
-
-    model->labels = cqdb_reader(
-        model->buffer + header->off_labels,
-        model->size - header->off_labels);
-
-    model->attrs = cqdb_reader(
-        model->buffer + header->off_attrs,
-        model->size - header->off_attrs);
-
-    return model;
-
-error_exit:
-    free(header);
-    free(model);
-    free(buffer_orig);
-    return NULL;
-}
-
-crf1dm_t *crf1dm_new(const char *filename)
-{
-    FILE *fp = NULL;
-    uint32_t size = 0;
-    uint8_t *buffer_orig = NULL;
-    uint8_t *buffer = NULL;
-
-    fp = fopen(filename, "rb");
-    if (fp == NULL)
-    {
-        goto error_exit;
-    }
-
-    fseek(fp, 0, SEEK_END);
-    size = (uint32_t)ftell(fp);
-    fseek(fp, 0, SEEK_SET);
-
-    buffer = buffer_orig = (uint8_t *)malloc(size + 16);
-    if (buffer_orig == NULL)
-    {
-        goto error_exit;
-    }
-
-    /* Align the buffer to 16 bytes. */
-    while ((uintptr_t)buffer % 16 != 0)
-    {
-        ++buffer;
-    }
-
-    if (fread(buffer, 1, size, fp) != size)
-    {
-        goto error_exit;
-    }
-    fclose(fp);
-
-    return crf1dm_new_impl(buffer_orig, buffer, size);
-
-error_exit:
-    free(buffer_orig);
-    if (fp != NULL)
-    {
-        fclose(fp);
-    }
-    return NULL;
-}
-
-crf1dm_t *crf1dm_new_from_memory(const void *data, size_t size)
-{
-    return crf1dm_new_impl(NULL, data, size);
-}
-
-void crf1dm_close(crf1dm_t *model)
-{
-    if (model->labels != NULL)
-    {
-        cqdb_delete(model->labels);
-    }
-    if (model->attrs != NULL)
-    {
-        cqdb_delete(model->attrs);
-    }
-    if (model->header != NULL)
-    {
-        free(model->header);
-        model->header = NULL;
-    }
-    if (model->buffer_orig != NULL)
-    {
-        free(model->buffer_orig);
-        model->buffer_orig = NULL;
-    }
-    model->buffer = NULL;
-    free(model);
-}
-
-int crf1dm_get_num_attrs(crf1dm_t *model)
-{
-    return model->header->num_attrs;
-}
-
-int crf1dm_get_num_labels(crf1dm_t *model)
-{
-    return model->header->num_labels;
-}
-
-const char *crf1dm_to_label(crf1dm_t *model, int lid)
-{
-    if (model->labels != NULL)
-    {
-        return cqdb_to_string(model->labels, lid);
-    }
-    else
-    {
-        return NULL;
-    }
-}
-
-int crf1dm_to_lid(crf1dm_t *model, const char *value)
-{
-    if (model->labels != NULL)
-    {
-        return cqdb_to_id(model->labels, value);
-    }
-    else
-    {
-        return -1;
-    }
-}
-
-int crf1dm_to_aid(crf1dm_t *model, const char *value)
-{
-    if (model->attrs != NULL)
-    {
-        return cqdb_to_id(model->attrs, value);
-    }
-    else
-    {
-        return -1;
-    }
-}
-
-const char *crf1dm_to_attr(crf1dm_t *model, int aid)
-{
-    if (model->attrs != NULL)
-    {
-        return cqdb_to_string(model->attrs, aid);
-    }
-    else
-    {
-        return NULL;
-    }
-}
-
-int crf1dm_get_labelref(crf1dm_t *model, int lid, feature_refs_t *ref)
-{
-    const uint8_t *p = model->buffer;
-    uint32_t offset;
-    uint32_t num_features;
-
-    p += model->header->off_labelrefs;
-    p += CHUNK_SIZE;
-    p += sizeof(uint32_t) * lid;
-    read_uint32(p, &offset);
-
-    p = model->buffer + offset;
-    p += read_uint32(p, &num_features);
-    ref->num_features = num_features;
-    ref->fids = (int *)p;
-    return 0;
-}
-
-int crf1dm_get_attrref(crf1dm_t *model, int aid, feature_refs_t *ref)
-{
-    const uint8_t *p = model->buffer;
-    uint32_t offset;
-    uint32_t num_features;
-
-    p += model->header->off_attrrefs;
-    p += CHUNK_SIZE;
-    p += sizeof(uint32_t) * aid;
-    read_uint32(p, &offset);
-
-    p = model->buffer + offset;
-    p += read_uint32(p, &num_features);
-    ref->num_features = num_features;
-    ref->fids = (int *)p;
-    return 0;
-}
-
-int crf1dm_get_featureid(feature_refs_t *ref, int i)
-{
-    uint32_t fid;
-    uint8_t *p = (uint8_t *)ref->fids;
-    p += sizeof(uint32_t) * i;
-    read_uint32(p, &fid);
-    return (int)fid;
-}
-
-int crf1dm_get_feature(crf1dm_t *model, int fid, crf1dm_feature_t *f)
-{
-    const uint8_t *p = NULL;
-    uint32_t val = 0;
-    uint32_t offset = model->header->off_features + CHUNK_SIZE;
-    offset += FEATURE_SIZE * fid;
-    p = model->buffer + offset;
-    p += read_uint32(p, &val);
-    f->type = val;
-    p += read_uint32(p, &val);
-    f->src = val;
-    p += read_uint32(p, &val);
-    f->dst = val;
-    p += read_float(p, &f->weight);
-    return 0;
-}
-
-void crf1dm_dump_states(crf1dm_t *crf1dm, FILE *fp)
-{
-    int j;
-    uint32_t i;
-    feature_refs_t refs;
-    const header_t *hfile = crf1dm->header;
-    const char *stringified_json;
-    JsonNode *states = json_mkarray();
-
-    for (i = 0; i < hfile->num_attrs; ++i)
-    {
-        crf1dm_get_attrref(crf1dm, i, &refs);
-        for (j = 0; j < refs.num_features; ++j)
-        {
-            crf1dm_feature_t f;
-            int fid = crf1dm_get_featureid(&refs, j);
-            const char *attr = NULL, *label = NULL;
-            JsonNode *state = json_mkobject();
-
-            crf1dm_get_feature(crf1dm, fid, &f);
-
-            attr = crf1dm_to_attr(crf1dm, f.src);
-            label = crf1dm_to_label(crf1dm, f.dst);
-
-            json_append_member(state, "feature", json_mkstring(attr));
-            json_append_member(state, "label", json_mkstring(label));
-            json_append_member(state, "weight", json_mknumber(f.weight));
-
-            json_append_element(states, state);
-        }
-    }
-
-    stringified_json = json_stringify(states, "  ");
-    fprintf(fp, stringified_json);
-    free(stringified_json);
-}
-
-void crf1dm_dump_transitions(crf1dm_t *crf1dm, FILE *fp)
-{
-    int j;
-    uint32_t i;
-    feature_refs_t refs;
-    const header_t *hfile = crf1dm->header;
-    const char *stringified_json;
-    JsonNode *transitions = json_mkarray();
-
-    for (i = 0; i < hfile->num_labels; ++i)
-    {
-        crf1dm_get_labelref(crf1dm, i, &refs);
-        for (j = 0; j < refs.num_features; ++j)
-        {
-            crf1dm_feature_t f;
-            int fid = crf1dm_get_featureid(&refs, j);
-            const char *from = NULL, *to = NULL;
-            JsonNode *transition = json_mkobject();
-
-            crf1dm_get_feature(crf1dm, fid, &f);
-
-            from = crf1dm_to_label(crf1dm, f.src);
-            to = crf1dm_to_label(crf1dm, f.dst);
-
-            json_append_member(transition, "from", json_mkstring(from));
-            json_append_member(transition, "to", json_mkstring(to));
-            json_append_member(transition, "weight", json_mknumber(f.weight));
-
-            json_append_element(transitions, transition);
-        }
-    }
-
-    stringified_json = json_stringify(transitions, "  ");
-    fprintf(fp, stringified_json);
-    free(stringified_json);
-}
+/*
+ *      CRF1d model.
+ *
+ * Copyright (c) 2007-2010, Naoaki Okazaki
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the names of the authors nor the names of its contributors
+ *       may be used to endorse or promote products derived from this
+ *       software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+ * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/* $Id$ */
+
+#include "os.h"
+
+#include <inttypes.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <cqdb.h>
+
+#include <crfsuite.h>
+#include "crf1d.h"
+#include "json.h"
+
+#define FILEMAGIC "lCRF"
+#define MODELTYPE "FOMC"
+#define VERSION_NUMBER (100)
+#define CHUNK_LABELREF "LFRF"
+#define CHUNK_ATTRREF "AFRF"
+#define CHUNK_FEATURE "FEAT"
+#define HEADER_SIZE 48
+#define CHUNK_SIZE 12
+#define FEATURE_SIZE 20
+
+enum
+{
+    WSTATE_NONE,
+    WSTATE_LABELS,
+    WSTATE_ATTRS,
+    WSTATE_LABELREFS,
+    WSTATE_ATTRREFS,
+    WSTATE_FEATURES,
+};
+
+typedef struct
+{
+    uint8_t magic[4];       /* File magic. */
+    uint32_t size;          /* File size. */
+    uint8_t type[4];        /* Model type */
+    uint32_t version;       /* Version number. */
+    uint32_t num_features;  /* Number of features. */
+    uint32_t num_labels;    /* Number of labels. */
+    uint32_t num_attrs;     /* Number of attributes. */
+    uint32_t off_features;  /* Offset to features. */
+    uint32_t off_labels;    /* Offset to label CQDB. */
+    uint32_t off_attrs;     /* Offset to attribute CQDB. */
+    uint32_t off_labelrefs; /* Offset to label feature references. */
+    uint32_t off_attrrefs;  /* Offset to attribute feature references. */
+} header_t;
+
+typedef struct
+{
+    uint8_t chunk[4];    /* Chunk id */
+    uint32_t size;       /* Chunk size. */
+    uint32_t num;        /* Number of items. */
+    uint32_t offsets[1]; /* Offsets. */
+} featureref_header_t;
+
+typedef struct
+{
+    uint8_t chunk[4]; /* Chunk id */
+    uint32_t size;    /* Chunk size. */
+    uint32_t num;     /* Number of items. */
+} feature_header_t;
+
+struct tag_crf1dm
+{
+    uint8_t *buffer_orig;
+    const uint8_t *buffer;
+    uint32_t size;
+    header_t *header;
+    cqdb_t *labels;
+    cqdb_t *attrs;
+};
+
+struct tag_crf1dmw
+{
+    FILE *fp;
+    int state;
+    header_t header;
+    cqdb_writer_t *dbw;
+    featureref_header_t *href;
+    feature_header_t *hfeat;
+};
+
+enum
+{
+    KT_GLOBAL = 'A',
+    KT_NUMATTRS,
+    KT_NUMLABELS,
+    KT_STR2LID,
+    KT_LID2STR,
+    KT_STR2AID,
+    KT_FEATURE,
+};
+
+static int write_uint8(FILE *fp, uint8_t value)
+{
+    return fwrite(&value, sizeof(value), 1, fp) == 1 ? 0 : 1;
+}
+
+static int read_uint8(const uint8_t *buffer, uint8_t *value)
+{
+    *value = *buffer;
+    return sizeof(*value);
+}
+
+static int write_uint32(FILE *fp, uint32_t value)
+{
+    uint8_t buffer[4];
+    buffer[0] = (uint8_t)(value & 0xFF);
+    buffer[1] = (uint8_t)(value >> 8);
+    buffer[2] = (uint8_t)(value >> 16);
+    buffer[3] = (uint8_t)(value >> 24);
+    return fwrite(buffer, sizeof(uint8_t), 4, fp) == 4 ? 0 : 1;
+}
+
+static int read_uint32(const uint8_t *buffer, uint32_t *value)
+{
+    *value = ((uint32_t)buffer[0]);
+    *value |= ((uint32_t)buffer[1] << 8);
+    *value |= ((uint32_t)buffer[2] << 16);
+    *value |= ((uint32_t)buffer[3] << 24);
+    return sizeof(*value);
+}
+
+static int write_uint8_array(FILE *fp, uint8_t *array, size_t n)
+{
+    size_t i;
+    int ret = 0;
+    for (i = 0; i < n; ++i)
+    {
+        ret |= write_uint8(fp, array[i]);
+    }
+    return ret;
+}
+
+static int read_uint8_array(const uint8_t *buffer, uint8_t *array, size_t n)
+{
+    size_t i;
+    int ret = 0;
+    for (i = 0; i < n; ++i)
+    {
+        int size = read_uint8(buffer, &array[i]);
+        buffer += size;
+        ret += size;
+    }
+    return ret;
+}
+
+static void write_float(FILE *fp, floatval_t value)
+{
+    /*
+        We assume:
+            - sizeof(floatval_t) = sizeof(double) = sizeof(uint64_t)
+            - the byte order of floatval_t and uint64_t is the same
+            - ARM's mixed-endian is not supported
+    */
+    uint64_t iv;
+    uint8_t buffer[8];
+
+    /* Copy the memory image of floatval_t value to uint64_t. */
+    memcpy(&iv, &value, sizeof(iv));
+
+    buffer[0] = (uint8_t)(iv & 0xFF);
+    buffer[1] = (uint8_t)(iv >> 8);
+    buffer[2] = (uint8_t)(iv >> 16);
+    buffer[3] = (uint8_t)(iv >> 24);
+    buffer[4] = (uint8_t)(iv >> 32);
+    buffer[5] = (uint8_t)(iv >> 40);
+    buffer[6] = (uint8_t)(iv >> 48);
+    buffer[7] = (uint8_t)(iv >> 56);
+    fwrite(buffer, sizeof(uint8_t), 8, fp);
+}
+
+static int read_float(const uint8_t *buffer, floatval_t *value)
+{
+    uint64_t iv;
+    iv = ((uint64_t)buffer[0]);
+    iv |= ((uint64_t)buffer[1] << 8);
+    iv |= ((uint64_t)buffer[2] << 16);
+    iv |= ((uint64_t)buffer[3] << 24);
+    iv |= ((uint64_t)buffer[4] << 32);
+    iv |= ((uint64_t)buffer[5] << 40);
+    iv |= ((uint64_t)buffer[6] << 48);
+    iv |= ((uint64_t)buffer[7] << 56);
+    memcpy(value, &iv, sizeof(*value));
+    return sizeof(*value);
+}
+
+crf1dmw_t *crf1mmw(const char *filename)
+{
+    header_t *header = NULL;
+    crf1dmw_t *writer = NULL;
+
+    /* Create a writer instance. */
+    writer = (crf1dmw_t *)calloc(1, sizeof(crf1dmw_t));
+    if (writer == NULL)
+    {
+        goto error_exit;
+    }
+
+    /* Open the file for writing. */
+    writer->fp = fopen(filename, "wb");
+    if (writer->fp == NULL)
+    {
+        goto error_exit;
+    }
+
+    /* Fill the members in the header. */
+    header = &writer->header;
+    memcpy(header->magic, FILEMAGIC, 4);
+    memcpy(header->type, MODELTYPE, 4);
+    header->version = VERSION_NUMBER;
+
+    /* Advance the file position to skip the file header. */
+    if (fseek(writer->fp, HEADER_SIZE, SEEK_CUR) != 0)
+    {
+        goto error_exit;
+    }
+
+    return writer;
+
+error_exit:
+    if (writer != NULL)
+    {
+        if (writer->fp != NULL)
+        {
+            fclose(writer->fp);
+        }
+        free(writer);
+    }
+    return NULL;
+}
+
+int crf1dmw_close(crf1dmw_t *writer)
+{
+    FILE *fp = writer->fp;
+    header_t *header = &writer->header;
+
+    /* Store the file size. */
+    header->size = (uint32_t)ftell(fp);
+
+    /* Move the file position to the head. */
+    if (fseek(fp, 0, SEEK_SET) != 0)
+    {
+        goto error_exit;
+    }
+
+    /* Write the file header. */
+    write_uint8_array(fp, header->magic, sizeof(header->magic));
+    write_uint32(fp, header->size);
+    write_uint8_array(fp, header->type, sizeof(header->type));
+    write_uint32(fp, header->version);
+    write_uint32(fp, header->num_features);
+    write_uint32(fp, header->num_labels);
+    write_uint32(fp, header->num_attrs);
+    write_uint32(fp, header->off_features);
+    write_uint32(fp, header->off_labels);
+    write_uint32(fp, header->off_attrs);
+    write_uint32(fp, header->off_labelrefs);
+    write_uint32(fp, header->off_attrrefs);
+
+    /* Check for any error occurrence. */
+    if (ferror(fp))
+    {
+        goto error_exit;
+    }
+
+    /* Close the writer. */
+    fclose(fp);
+    free(writer);
+    return 0;
+
+error_exit:
+    if (writer != NULL)
+    {
+        if (writer->fp != NULL)
+        {
+            fclose(writer->fp);
+        }
+        free(writer);
+    }
+    return 1;
+}
+
+int crf1dmw_open_labels(crf1dmw_t *writer, int num_labels)
+{
+    /* Check if we aren't writing anything at this moment. */
+    if (writer->state != WSTATE_NONE)
+    {
+        return 1;
+    }
+
+    /* Store the current offset. */
+    writer->header.off_labels = (uint32_t)ftell(writer->fp);
+
+    /* Open a CQDB chunk for writing. */
+    writer->dbw = cqdb_writer(writer->fp, 0);
+    if (writer->dbw == NULL)
+    {
+        writer->header.off_labels = 0;
+        return 1;
+    }
+
+    writer->state = WSTATE_LABELS;
+    writer->header.num_labels = num_labels;
+    return 0;
+}
+
+int crf1dmw_close_labels(crf1dmw_t *writer)
+{
+    /* Make sure that we are writing labels. */
+    if (writer->state != WSTATE_LABELS)
+    {
+        return 1;
+    }
+
+    /* Close the CQDB chunk. */
+    if (cqdb_writer_close(writer->dbw))
+    {
+        return 1;
+    }
+
+    writer->dbw = NULL;
+    writer->state = WSTATE_NONE;
+    return 0;
+}
+
+int crf1dmw_put_label(crf1dmw_t *writer, int lid, const char *value)
+{
+    /* Make sure that we are writing labels. */
+    if (writer->state != WSTATE_LABELS)
+    {
+        return 1;
+    }
+
+    /* Put the label. */
+    if (cqdb_writer_put(writer->dbw, value, lid))
+    {
+        return 1;
+    }
+
+    return 0;
+}
+
+int crf1dmw_open_attrs(crf1dmw_t *writer, int num_attrs)
+{
+    /* Check if we aren't writing anything at this moment. */
+    if (writer->state != WSTATE_NONE)
+    {
+        return 1;
+    }
+
+    /* Store the current offset. */
+    writer->header.off_attrs = (uint32_t)ftell(writer->fp);
+
+    /* Open a CQDB chunk for writing. */
+    writer->dbw = cqdb_writer(writer->fp, 0);
+    if (writer->dbw == NULL)
+    {
+        writer->header.off_attrs = 0;
+        return 1;
+    }
+
+    writer->state = WSTATE_ATTRS;
+    writer->header.num_attrs = num_attrs;
+    return 0;
+}
+
+int crf1dmw_close_attrs(crf1dmw_t *writer)
+{
+    /* Make sure that we are writing attributes. */
+    if (writer->state != WSTATE_ATTRS)
+    {
+        return 1;
+    }
+
+    /* Close the CQDB chunk. */
+    if (cqdb_writer_close(writer->dbw))
+    {
+        return 1;
+    }
+
+    writer->dbw = NULL;
+    writer->state = WSTATE_NONE;
+    return 0;
+}
+
+int crf1dmw_put_attr(crf1dmw_t *writer, int aid, const char *value)
+{
+    /* Make sure that we are writing labels. */
+    if (writer->state != WSTATE_ATTRS)
+    {
+        return 1;
+    }
+
+    /* Put the attribute. */
+    if (cqdb_writer_put(writer->dbw, value, aid))
+    {
+        return 1;
+    }
+
+    return 0;
+}
+
+int crf1dmw_open_labelrefs(crf1dmw_t *writer, int num_labels)
+{
+    uint32_t offset;
+    FILE *fp = writer->fp;
+    featureref_header_t *href = NULL;
+    size_t size = CHUNK_SIZE + sizeof(uint32_t) * num_labels;
+
+    /* Check if we aren't writing anything at this moment. */
+    if (writer->state != WSTATE_NONE)
+    {
+        return CRFSUITEERR_INTERNAL_LOGIC;
+    }
+
+    /* Allocate a feature reference array. */
+    href = (featureref_header_t *)calloc(size, 1);
+    if (href == NULL)
+    {
+        return CRFSUITEERR_OUTOFMEMORY;
+    }
+
+    /* Align the offset to a DWORD boundary. */
+    offset = (uint32_t)ftell(fp);
+    while (offset % 4 != 0)
+    {
+        uint8_t c = 0;
+        fwrite(&c, sizeof(uint8_t), 1, fp);
+        ++offset;
+    }
+
+    /* Store the current offset position to the file header. */
+    writer->header.off_labelrefs = offset;
+    fseek(fp, size, SEEK_CUR);
+
+    /* Fill members in the feature reference header. */
+    memcpy(href->chunk, CHUNK_LABELREF, 4);
+    href->size = 0;
+    href->num = num_labels;
+
+    writer->href = href;
+    writer->state = WSTATE_LABELREFS;
+    return 0;
+}
+
+int crf1dmw_close_labelrefs(crf1dmw_t *writer)
+{
+    uint32_t i;
+    FILE *fp = writer->fp;
+    featureref_header_t *href = writer->href;
+    uint32_t begin = writer->header.off_labelrefs, end = 0;
+
+    /* Make sure that we are writing label feature references. */
+    if (writer->state != WSTATE_LABELREFS)
+    {
+        return CRFSUITEERR_INTERNAL_LOGIC;
+    }
+
+    /* Store the current offset position. */
+    end = (uint32_t)ftell(fp);
+
+    /* Compute the size of this chunk. */
+    href->size = (end - begin);
+
+    /* Write the chunk header and offset array. */
+    fseek(fp, begin, SEEK_SET);
+    write_uint8_array(fp, href->chunk, 4);
+    write_uint32(fp, href->size);
+    write_uint32(fp, href->num);
+    for (i = 0; i < href->num; ++i)
+    {
+        write_uint32(fp, href->offsets[i]);
+    }
+
+    /* Move the file pointer to the tail. */
+    fseek(fp, end, SEEK_SET);
+
+    /* Uninitialize. */
+    free(href);
+    writer->href = NULL;
+    writer->state = WSTATE_NONE;
+    return 0;
+}
+
+int crf1dmw_put_labelref(crf1dmw_t *writer, int lid, const feature_refs_t *ref, int *map)
+{
+    int i, fid;
+    uint32_t n = 0, offset = 0;
+    FILE *fp = writer->fp;
+    featureref_header_t *href = writer->href;
+
+    /* Make sure that we are writing label feature references. */
+    if (writer->state != WSTATE_LABELREFS)
+    {
+        return CRFSUITEERR_INTERNAL_LOGIC;
+    }
+
+    /* Store the current offset to the offset array. */
+    href->offsets[lid] = ftell(fp);
+
+    /* Count the number of references to active features. */
+    for (i = 0; i < ref->num_features; ++i)
+    {
+        if (0 <= map[ref->fids[i]])
+            ++n;
+    }
+
+    /* Write the feature reference. */
+    write_uint32(fp, (uint32_t)n);
+    for (i = 0; i < ref->num_features; ++i)
+    {
+        fid = map[ref->fids[i]];
+        if (0 <= fid)
+            write_uint32(fp, (uint32_t)fid);
+    }
+
+    return 0;
+}
+
+int crf1dmw_open_attrrefs(crf1dmw_t *writer, int num_attrs)
+{
+    uint32_t offset;
+    FILE *fp = writer->fp;
+    featureref_header_t *href = NULL;
+    size_t size = CHUNK_SIZE + sizeof(uint32_t) * num_attrs;
+
+    /* Check if we aren't writing anything at this moment. */
+    if (writer->state != WSTATE_NONE)
+    {
+        return CRFSUITEERR_INTERNAL_LOGIC;
+    }
+
+    /* Allocate a feature reference array. */
+    href = (featureref_header_t *)calloc(size, 1);
+    if (href == NULL)
+    {
+        return CRFSUITEERR_OUTOFMEMORY;
+    }
+
+    /* Align the offset to a DWORD boundary. */
+    offset = (uint32_t)ftell(fp);
+    while (offset % 4 != 0)
+    {
+        uint8_t c = 0;
+        fwrite(&c, sizeof(uint8_t), 1, fp);
+        ++offset;
+    }
+
+    /* Store the current offset position to the file header. */
+    writer->header.off_attrrefs = offset;
+    fseek(fp, size, SEEK_CUR);
+
+    /* Fill members in the feature reference header. */
+    memcpy(href->chunk, CHUNK_ATTRREF, 4);
+    href->size = 0;
+    href->num = num_attrs;
+
+    writer->href = href;
+    writer->state = WSTATE_ATTRREFS;
+    return 0;
+}
+
+int crf1dmw_close_attrrefs(crf1dmw_t *writer)
+{
+    uint32_t i;
+    FILE *fp = writer->fp;
+    featureref_header_t *href = writer->href;
+    uint32_t begin = writer->header.off_attrrefs, end = 0;
+
+    /* Make sure that we are writing attribute feature references. */
+    if (writer->state != WSTATE_ATTRREFS)
+    {
+        return CRFSUITEERR_INTERNAL_LOGIC;
+    }
+
+    /* Store the current offset position. */
+    end = (uint32_t)ftell(fp);
+
+    /* Compute the size of this chunk. */
+    href->size = (end - begin);
+
+    /* Write the chunk header and offset array. */
+    fseek(fp, begin, SEEK_SET);
+    write_uint8_array(fp, href->chunk, 4);
+    write_uint32(fp, href->size);
+    write_uint32(fp, href->num);
+    for (i = 0; i < href->num; ++i)
+    {
+        write_uint32(fp, href->offsets[i]);
+    }
+
+    /* Move the file pointer to the tail. */
+    fseek(fp, end, SEEK_SET);
+
+    /* Uninitialize. */
+    free(href);
+    writer->href = NULL;
+    writer->state = WSTATE_NONE;
+    return 0;
+}
+
+int crf1dmw_put_attrref(crf1dmw_t *writer, int aid, const feature_refs_t *ref, int *map)
+{
+    int i, fid;
+    uint32_t n = 0, offset = 0;
+    FILE *fp = writer->fp;
+    featureref_header_t *href = writer->href;
+
+    /* Make sure that we are writing attribute feature references. */
+    if (writer->state != WSTATE_ATTRREFS)
+    {
+        return CRFSUITEERR_INTERNAL_LOGIC;
+    }
+
+    /* Store the current offset to the offset array. */
+    href->offsets[aid] = ftell(fp);
+
+    /* Count the number of references to active features. */
+    for (i = 0; i < ref->num_features; ++i)
+    {
+        if (0 <= map[ref->fids[i]])
+            ++n;
+    }
+
+    /* Write the feature reference. */
+    write_uint32(fp, (uint32_t)n);
+    for (i = 0; i < ref->num_features; ++i)
+    {
+        fid = map[ref->fids[i]];
+        if (0 <= fid)
+            write_uint32(fp, (uint32_t)fid);
+    }
+
+    return 0;
+}
+
+int crf1dmw_open_features(crf1dmw_t *writer)
+{
+    FILE *fp = writer->fp;
+    feature_header_t *hfeat = NULL;
+
+    /* Check if we aren't writing anything at this moment. */
+    if (writer->state != WSTATE_NONE)
+    {
+        return CRFSUITEERR_INTERNAL_LOGIC;
+    }
+
+    /* Allocate a feature chunk header. */
+    hfeat = (feature_header_t *)calloc(sizeof(feature_header_t), 1);
+    if (hfeat == NULL)
+    {
+        return CRFSUITEERR_OUTOFMEMORY;
+    }
+
+    writer->header.off_features = (uint32_t)ftell(fp);
+    fseek(fp, CHUNK_SIZE, SEEK_CUR);
+
+    memcpy(hfeat->chunk, CHUNK_FEATURE, 4);
+    writer->hfeat = hfeat;
+
+    writer->state = WSTATE_FEATURES;
+    return 0;
+}
+
+int crf1dmw_close_features(crf1dmw_t *writer)
+{
+    FILE *fp = writer->fp;
+    feature_header_t *hfeat = writer->hfeat;
+    uint32_t begin = writer->header.off_features, end = 0;
+
+    /* Make sure that we are writing attribute feature references. */
+    if (writer->state != WSTATE_FEATURES)
+    {
+        return CRFSUITEERR_INTERNAL_LOGIC;
+    }
+
+    /* Store the current offset position. */
+    end = (uint32_t)ftell(fp);
+
+    /* Compute the size of this chunk. */
+    hfeat->size = (end - begin);
+
+    /* Write the chunk header and offset array. */
+    fseek(fp, begin, SEEK_SET);
+    write_uint8_array(fp, hfeat->chunk, 4);
+    write_uint32(fp, hfeat->size);
+    write_uint32(fp, hfeat->num);
+
+    /* Move the file pointer to the tail. */
+    fseek(fp, end, SEEK_SET);
+
+    /* Uninitialize. */
+    free(hfeat);
+    writer->hfeat = NULL;
+    writer->state = WSTATE_NONE;
+    return 0;
+}
+
+int crf1dmw_put_feature(crf1dmw_t *writer, int fid, const crf1dm_feature_t *f)
+{
+    FILE *fp = writer->fp;
+    feature_header_t *hfeat = writer->hfeat;
+
+    /* Make sure that we are writing attribute feature references. */
+    if (writer->state != WSTATE_FEATURES)
+    {
+        return CRFSUITEERR_INTERNAL_LOGIC;
+    }
+
+    /* We must put features #0, #1, ..., #(K-1) in this order. */
+    if (fid != hfeat->num)
+    {
+        return CRFSUITEERR_INTERNAL_LOGIC;
+    }
+
+    write_uint32(fp, f->type);
+    write_uint32(fp, f->src);
+    write_uint32(fp, f->dst);
+    write_float(fp, f->weight);
+    ++hfeat->num;
+    return 0;
+}
+
+static crf1dm_t *crf1dm_new_impl(uint8_t *buffer_orig, const uint8_t *buffer, uint32_t size)
+{
+    const uint8_t *p = NULL;
+    crf1dm_t *model = NULL;
+    header_t *header = NULL;
+
+    model = (crf1dm_t *)calloc(1, sizeof(crf1dm_t));
+    if (model == NULL)
+    {
+        goto error_exit;
+    }
+
+    model->buffer_orig = buffer_orig;
+    model->buffer = buffer;
+    model->size = size;
+
+    if (model->size <= sizeof(header_t))
+    {
+        goto error_exit;
+    }
+
+    header = (header_t *)calloc(1, sizeof(header_t));
+    if (header == NULL)
+    {
+        goto error_exit;
+    }
+
+    /* Read the file header. */
+    p = model->buffer;
+    p += read_uint8_array(p, header->magic, sizeof(header->magic));
+    p += read_uint32(p, &header->size);
+    p += read_uint8_array(p, header->type, sizeof(header->type));
+    p += read_uint32(p, &header->version);
+    p += read_uint32(p, &header->num_features);
+    p += read_uint32(p, &header->num_labels);
+    p += read_uint32(p, &header->num_attrs);
+    p += read_uint32(p, &header->off_features);
+    p += read_uint32(p, &header->off_labels);
+    p += read_uint32(p, &header->off_attrs);
+    p += read_uint32(p, &header->off_labelrefs);
+    p += read_uint32(p, &header->off_attrrefs);
+    model->header = header;
+
+    model->labels = cqdb_reader(
+        model->buffer + header->off_labels,
+        model->size - header->off_labels);
+
+    model->attrs = cqdb_reader(
+        model->buffer + header->off_attrs,
+        model->size - header->off_attrs);
+
+    return model;
+
+error_exit:
+    free(header);
+    free(model);
+    free(buffer_orig);
+    return NULL;
+}
+
+crf1dm_t *crf1dm_new(const char *filename)
+{
+    FILE *fp = NULL;
+    uint32_t size = 0;
+    uint8_t *buffer_orig = NULL;
+    uint8_t *buffer = NULL;
+
+    fp = fopen(filename, "rb");
+    if (fp == NULL)
+    {
+        goto error_exit;
+    }
+
+    fseek(fp, 0, SEEK_END);
+    size = (uint32_t)ftell(fp);
+    fseek(fp, 0, SEEK_SET);
+
+    buffer = buffer_orig = (uint8_t *)malloc(size + 16);
+    if (buffer_orig == NULL)
+    {
+        goto error_exit;
+    }
+
+    /* Align the buffer to 16 bytes. */
+    while ((uintptr_t)buffer % 16 != 0)
+    {
+        ++buffer;
+    }
+
+    if (fread(buffer, 1, size, fp) != size)
+    {
+        goto error_exit;
+    }
+    fclose(fp);
+
+    return crf1dm_new_impl(buffer_orig, buffer, size);
+
+error_exit:
+    free(buffer_orig);
+    if (fp != NULL)
+    {
+        fclose(fp);
+    }
+    return NULL;
+}
+
+crf1dm_t *crf1dm_new_from_memory(const void *data, size_t size)
+{
+    return crf1dm_new_impl(NULL, data, size);
+}
+
+void crf1dm_close(crf1dm_t *model)
+{
+    if (model->labels != NULL)
+    {
+        cqdb_delete(model->labels);
+    }
+    if (model->attrs != NULL)
+    {
+        cqdb_delete(model->attrs);
+    }
+    if (model->header != NULL)
+    {
+        free(model->header);
+        model->header = NULL;
+    }
+    if (model->buffer_orig != NULL)
+    {
+        free(model->buffer_orig);
+        model->buffer_orig = NULL;
+    }
+    model->buffer = NULL;
+    free(model);
+}
+
+int crf1dm_get_num_attrs(crf1dm_t *model)
+{
+    return model->header->num_attrs;
+}
+
+int crf1dm_get_num_labels(crf1dm_t *model)
+{
+    return model->header->num_labels;
+}
+
+const char *crf1dm_to_label(crf1dm_t *model, int lid)
+{
+    if (model->labels != NULL)
+    {
+        return cqdb_to_string(model->labels, lid);
+    }
+    else
+    {
+        return NULL;
+    }
+}
+
+int crf1dm_to_lid(crf1dm_t *model, const char *value)
+{
+    if (model->labels != NULL)
+    {
+        return cqdb_to_id(model->labels, value);
+    }
+    else
+    {
+        return -1;
+    }
+}
+
+int crf1dm_to_aid(crf1dm_t *model, const char *value)
+{
+    if (model->attrs != NULL)
+    {
+        return cqdb_to_id(model->attrs, value);
+    }
+    else
+    {
+        return -1;
+    }
+}
+
+const char *crf1dm_to_attr(crf1dm_t *model, int aid)
+{
+    if (model->attrs != NULL)
+    {
+        return cqdb_to_string(model->attrs, aid);
+    }
+    else
+    {
+        return NULL;
+    }
+}
+
+int crf1dm_get_labelref(crf1dm_t *model, int lid, feature_refs_t *ref)
+{
+    const uint8_t *p = model->buffer;
+    uint32_t offset;
+    uint32_t num_features;
+
+    p += model->header->off_labelrefs;
+    p += CHUNK_SIZE;
+    p += sizeof(uint32_t) * lid;
+    read_uint32(p, &offset);
+
+    p = model->buffer + offset;
+    p += read_uint32(p, &num_features);
+    ref->num_features = num_features;
+    ref->fids = (int *)p;
+    return 0;
+}
+
+int crf1dm_get_attrref(crf1dm_t *model, int aid, feature_refs_t *ref)
+{
+    const uint8_t *p = model->buffer;
+    uint32_t offset;
+    uint32_t num_features;
+
+    p += model->header->off_attrrefs;
+    p += CHUNK_SIZE;
+    p += sizeof(uint32_t) * aid;
+    read_uint32(p, &offset);
+
+    p = model->buffer + offset;
+    p += read_uint32(p, &num_features);
+    ref->num_features = num_features;
+    ref->fids = (int *)p;
+    return 0;
+}
+
+int crf1dm_get_featureid(feature_refs_t *ref, int i)
+{
+    uint32_t fid;
+    uint8_t *p = (uint8_t *)ref->fids;
+    p += sizeof(uint32_t) * i;
+    read_uint32(p, &fid);
+    return (int)fid;
+}
+
+int crf1dm_get_feature(crf1dm_t *model, int fid, crf1dm_feature_t *f)
+{
+    const uint8_t *p = NULL;
+    uint32_t val = 0;
+    uint32_t offset = model->header->off_features + CHUNK_SIZE;
+    offset += FEATURE_SIZE * fid;
+    p = model->buffer + offset;
+    p += read_uint32(p, &val);
+    f->type = val;
+    p += read_uint32(p, &val);
+    f->src = val;
+    p += read_uint32(p, &val);
+    f->dst = val;
+    p += read_float(p, &f->weight);
+    return 0;
+}
+
+void crf1dm_dump_states(crf1dm_t *crf1dm, FILE *fp)
+{
+    int j;
+    uint32_t i;
+    feature_refs_t refs;
+    const header_t *hfile = crf1dm->header;
+    const char *stringified_json;
+    JsonNode *states = json_mkarray();
+
+    for (i = 0; i < hfile->num_attrs; ++i)
+    {
+        crf1dm_get_attrref(crf1dm, i, &refs);
+        for (j = 0; j < refs.num_features; ++j)
+        {
+            crf1dm_feature_t f;
+            int fid = crf1dm_get_featureid(&refs, j);
+            const char *attr = NULL, *label = NULL;
+            JsonNode *state = json_mkobject();
+
+            crf1dm_get_feature(crf1dm, fid, &f);
+
+            attr = crf1dm_to_attr(crf1dm, f.src);
+            label = crf1dm_to_label(crf1dm, f.dst);
+
+            json_append_member(state, "feature", json_mkstring(attr));
+            json_append_member(state, "label", json_mkstring(label));
+            json_append_member(state, "weight", json_mknumber(f.weight));
+
+            json_append_element(states, state);
+        }
+    }
+
+    stringified_json = json_stringify(states, "  ");
+    fprintf(fp, stringified_json);
+    free(stringified_json);
+}
+
+void crf1dm_dump_transitions(crf1dm_t *crf1dm, FILE *fp)
+{
+    int j;
+    uint32_t i;
+    feature_refs_t refs;
+    const header_t *hfile = crf1dm->header;
+    const char *stringified_json;
+    JsonNode *transitions = json_mkarray();
+
+    for (i = 0; i < hfile->num_labels; ++i)
+    {
+        crf1dm_get_labelref(crf1dm, i, &refs);
+        for (j = 0; j < refs.num_features; ++j)
+        {
+            crf1dm_feature_t f;
+            int fid = crf1dm_get_featureid(&refs, j);
+            const char *from = NULL, *to = NULL;
+            JsonNode *transition = json_mkobject();
+
+            crf1dm_get_feature(crf1dm, fid, &f);
+
+            from = crf1dm_to_label(crf1dm, f.src);
+            to = crf1dm_to_label(crf1dm, f.dst);
+
+            json_append_member(transition, "from", json_mkstring(from));
+            json_append_member(transition, "to", json_mkstring(to));
+            json_append_member(transition, "weight", json_mknumber(f.weight));
+
+            json_append_element(transitions, transition);
+        }
+    }
+
+    stringified_json = json_stringify(transitions, "  ");
+    fprintf(fp, stringified_json);
+    free(stringified_json);
+}
```

## chaine/_core/crfsuite/lib/crf/src/crf1d_tag.c

 * *Ordering differences only*

```diff
@@ -1,582 +1,582 @@
-/*
- *      CRF1d tagger (implementation of crfsuite_model_t and crfsuite_tagger_t).
- *
- * Copyright (c) 2007-2010, Naoaki Okazaki
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the names of the authors nor the names of its contributors
- *       may be used to endorse or promote products derived from this
- *       software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
- * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-/* $Id$ */
-
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif /*HAVE_CONFIG_H*/
-
-#include <os.h>
-
-#include <math.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-
-#include <crfsuite.h>
-
-#include "crf1d.h"
-
-enum
-{
-    LEVEL_NONE = 0,
-    LEVEL_SET,
-    LEVEL_ALPHABETA,
-};
-
-typedef struct
-{
-    crf1dm_t *model;      /**< CRF model. */
-    crf1d_context_t *ctx; /**< CRF context. */
-    int num_labels;       /**< Number of distinct output labels (L). */
-    int num_attributes;   /**< Number of distinct attributes (A). */
-    int level;
-} crf1dt_t;
-
-static void crf1dt_state_score(crf1dt_t *crf1dt, const crfsuite_instance_t *inst)
-{
-    int a, i, l, t, r, fid;
-    crf1dm_feature_t f;
-    feature_refs_t attr;
-    floatval_t value, *state = NULL;
-    crf1dm_t *model = crf1dt->model;
-    crf1d_context_t *ctx = crf1dt->ctx;
-    const crfsuite_item_t *item = NULL;
-    const int T = inst->num_items;
-    const int L = crf1dt->num_labels;
-
-    /* Loop over the items in the sequence. */
-    for (t = 0; t < T; ++t)
-    {
-        item = &inst->items[t];
-        state = STATE_SCORE(ctx, t);
-
-        /* Loop over the contents (attributes) attached to the item. */
-        for (i = 0; i < item->num_contents; ++i)
-        {
-            /* Access the list of state features associated with the attribute. */
-            a = item->contents[i].aid;
-            crf1dm_get_attrref(model, a, &attr);
-            /* A scale usually represents the atrribute frequency in the item. */
-            value = item->contents[i].value;
-
-            /* Loop over the state features associated with the attribute. */
-            for (r = 0; r < attr.num_features; ++r)
-            {
-                /* The state feature #(attr->fids[r]), which is represented by
-                   the attribute #a, outputs the label #(f->dst). */
-                fid = crf1dm_get_featureid(&attr, r);
-                crf1dm_get_feature(model, fid, &f);
-                l = f.dst;
-                state[l] += f.weight * value;
-            }
-        }
-    }
-}
-
-static void crf1dt_transition_score(crf1dt_t *crf1dt)
-{
-    int i, r, fid;
-    crf1dm_feature_t f;
-    feature_refs_t edge;
-    floatval_t *trans = NULL;
-    crf1dm_t *model = crf1dt->model;
-    crf1d_context_t *ctx = crf1dt->ctx;
-    const int L = crf1dt->num_labels;
-
-    /* Compute transition scores between two labels. */
-    for (i = 0; i < L; ++i)
-    {
-        trans = TRANS_SCORE(ctx, i);
-        crf1dm_get_labelref(model, i, &edge);
-        for (r = 0; r < edge.num_features; ++r)
-        {
-            /* Transition feature from #i to #(f->dst). */
-            fid = crf1dm_get_featureid(&edge, r);
-            crf1dm_get_feature(model, fid, &f);
-            trans[f.dst] = f.weight;
-        }
-    }
-}
-
-static void crf1dt_set_level(crf1dt_t *crf1dt, int level)
-{
-    int prev = crf1dt->level;
-    crf1d_context_t *ctx = crf1dt->ctx;
-
-    if (level <= LEVEL_ALPHABETA && prev < LEVEL_ALPHABETA)
-    {
-        crf1dc_exp_state(ctx);
-        crf1dc_alpha_score(ctx);
-        crf1dc_beta_score(ctx);
-    }
-
-    crf1dt->level = level;
-}
-
-static void crf1dt_delete(crf1dt_t *crf1dt)
-{
-    /* Note: we don't own the model object (crf1t->model). */
-    if (crf1dt->ctx != NULL)
-    {
-        crf1dc_delete(crf1dt->ctx);
-        crf1dt->ctx = NULL;
-    }
-    free(crf1dt);
-}
-
-static crf1dt_t *crf1dt_new(crf1dm_t *crf1dm)
-{
-    crf1dt_t *crf1dt = NULL;
-
-    crf1dt = (crf1dt_t *)calloc(1, sizeof(crf1dt_t));
-    if (crf1dt != NULL)
-    {
-        crf1dt->num_labels = crf1dm_get_num_labels(crf1dm);
-        crf1dt->num_attributes = crf1dm_get_num_attrs(crf1dm);
-        crf1dt->model = crf1dm;
-        crf1dt->ctx = crf1dc_new(CTXF_VITERBI | CTXF_MARGINALS, crf1dt->num_labels, 0);
-        if (crf1dt->ctx != NULL)
-        {
-            crf1dc_reset(crf1dt->ctx, RF_TRANS);
-            crf1dt_transition_score(crf1dt);
-            crf1dc_exp_transition(crf1dt->ctx);
-        }
-        else
-        {
-            crf1dt_delete(crf1dt);
-            crf1dt = NULL;
-        }
-        crf1dt->level = LEVEL_NONE;
-    }
-
-    return crf1dt;
-}
-
-/*
- *    Implementation of crfsuite_tagger_t object.
- *    This object is instantiated only by a crfsuite_model_t object.
- */
-
-static int tagger_addref(crfsuite_tagger_t *tagger)
-{
-    return crfsuite_interlocked_increment(&tagger->nref);
-}
-
-static int tagger_release(crfsuite_tagger_t *tagger)
-{
-    int count = crfsuite_interlocked_decrement(&tagger->nref);
-    if (count == 0)
-    {
-        /* This instance is being destroyed. */
-        crf1dt_delete((crf1dt_t *)tagger->internal);
-        free(tagger);
-    }
-    return count;
-}
-
-static int tagger_set(crfsuite_tagger_t *tagger, crfsuite_instance_t *inst)
-{
-    crf1dt_t *crf1dt = (crf1dt_t *)tagger->internal;
-    crf1d_context_t *ctx = crf1dt->ctx;
-    crf1dc_set_num_items(ctx, inst->num_items);
-    crf1dc_reset(crf1dt->ctx, RF_STATE);
-    crf1dt_state_score(crf1dt, inst);
-    crf1dt->level = LEVEL_SET;
-    return 0;
-}
-
-static int tagger_length(crfsuite_tagger_t *tagger)
-{
-    crf1dt_t *crf1dt = (crf1dt_t *)tagger->internal;
-    crf1d_context_t *ctx = crf1dt->ctx;
-    return ctx->num_items;
-}
-
-static int tagger_viterbi(crfsuite_tagger_t *tagger, int *labels, floatval_t *ptr_score)
-{
-    floatval_t score;
-    crf1dt_t *crf1dt = (crf1dt_t *)tagger->internal;
-    crf1d_context_t *ctx = crf1dt->ctx;
-
-    score = crf1dc_viterbi(ctx, labels);
-    if (ptr_score != NULL)
-    {
-        *ptr_score = score;
-    }
-
-    return 0;
-}
-
-static int tagger_score(crfsuite_tagger_t *tagger, int *path, floatval_t *ptr_score)
-{
-    floatval_t score;
-    crf1dt_t *crf1dt = (crf1dt_t *)tagger->internal;
-    crf1d_context_t *ctx = crf1dt->ctx;
-    score = crf1dc_score(ctx, path);
-    if (ptr_score != NULL)
-    {
-        *ptr_score = score;
-    }
-    return 0;
-}
-
-static int tagger_lognorm(crfsuite_tagger_t *tagger, floatval_t *ptr_norm)
-{
-    crf1dt_t *crf1dt = (crf1dt_t *)tagger->internal;
-    crf1dt_set_level(crf1dt, LEVEL_ALPHABETA);
-    *ptr_norm = crf1dc_lognorm(crf1dt->ctx);
-    return 0;
-}
-
-static int tagger_marginal_point(crfsuite_tagger_t *tagger, int l, int t, floatval_t *ptr_prob)
-{
-    crf1dt_t *crf1dt = (crf1dt_t *)tagger->internal;
-    crf1dt_set_level(crf1dt, LEVEL_ALPHABETA);
-    *ptr_prob = crf1dc_marginal_point(crf1dt->ctx, l, t);
-    return 0;
-}
-
-static int tagger_marginal_path(crfsuite_tagger_t *tagger, const int *path, int begin, int end, floatval_t *ptr_prob)
-{
-    crf1dt_t *crf1dt = (crf1dt_t *)tagger->internal;
-    crf1dt_set_level(crf1dt, LEVEL_ALPHABETA);
-    *ptr_prob = crf1dc_marginal_path(crf1dt->ctx, path, begin, end);
-    return 0;
-}
-
-/*
- *    Implementation of crfsuite_dictionary_t object for attributes.
- *    This object is instantiated only by a crfsuite_model_t object.
- */
-
-static int model_attrs_addref(crfsuite_dictionary_t *dic)
-{
-    /* This object is owned only by a crfsuite_model_t object. */
-    return dic->nref;
-}
-
-static int model_attrs_release(crfsuite_dictionary_t *dic)
-{
-    /* This object is owned and freed only by a crfsuite_model_t object. */
-    return dic->nref;
-}
-
-static int model_attrs_get(crfsuite_dictionary_t *dic, const char *str)
-{
-    /* This object is ready only. */
-    return CRFSUITEERR_NOTSUPPORTED;
-}
-
-static int model_attrs_to_id(crfsuite_dictionary_t *dic, const char *str)
-{
-    crf1dm_t *crf1dm = (crf1dm_t *)dic->internal;
-    return crf1dm_to_aid(crf1dm, str);
-}
-
-static int model_attrs_to_string(crfsuite_dictionary_t *dic, int id, char const **pstr)
-{
-    crf1dm_t *crf1dm = (crf1dm_t *)dic->internal;
-    *pstr = crf1dm_to_attr(crf1dm, id);
-    return 0;
-}
-
-static int model_attrs_num(crfsuite_dictionary_t *dic)
-{
-    crf1dm_t *crf1dm = (crf1dm_t *)dic->internal;
-    return crf1dm_get_num_attrs(crf1dm);
-}
-
-static void model_attrs_free(crfsuite_dictionary_t *dic, const char *str)
-{
-    /* all strings are freed on the release of the dictionary object. */
-}
-
-/*
- *    Implementation of crfsuite_dictionary_t object for labels.
- *    This object is instantiated only by a crfsuite_model_t object.
- */
-
-static int model_labels_addref(crfsuite_dictionary_t *dic)
-{
-    /* This object is owned only by a crfsuite_model_t object. */
-    return dic->nref;
-}
-
-static int model_labels_release(crfsuite_dictionary_t *dic)
-{
-    /* This object is owned and freed only by a crfsuite_model_t object. */
-    return dic->nref;
-}
-
-static int model_labels_get(crfsuite_dictionary_t *dic, const char *str)
-{
-    /* This object is ready only. */
-    return CRFSUITEERR_NOTSUPPORTED;
-}
-
-static int model_labels_to_id(crfsuite_dictionary_t *dic, const char *str)
-{
-    crf1dm_t *crf1dm = (crf1dm_t *)dic->internal;
-    return crf1dm_to_lid(crf1dm, str);
-}
-
-static int model_labels_to_string(crfsuite_dictionary_t *dic, int id, char const **pstr)
-{
-    crf1dm_t *crf1dm = (crf1dm_t *)dic->internal;
-    *pstr = crf1dm_to_label(crf1dm, id);
-    return 0;
-}
-
-static int model_labels_num(crfsuite_dictionary_t *dic)
-{
-    crf1dm_t *crf1dm = (crf1dm_t *)dic->internal;
-    return crf1dm_get_num_labels(crf1dm);
-}
-
-static void model_labels_free(crfsuite_dictionary_t *dic, const char *str)
-{
-    /* all strings are freed on the release of the dictionary object. */
-}
-
-/*
- *    Implementation of crfsuite_model_t object.
- *    This object is instantiated by crf1m_model_create() function.
- */
-
-typedef struct
-{
-    crf1dm_t *crf1dm;
-
-    crfsuite_dictionary_t *attrs;
-    crfsuite_dictionary_t *labels;
-} model_internal_t;
-
-static int model_addref(crfsuite_model_t *model)
-{
-    return crfsuite_interlocked_increment(&model->nref);
-}
-
-static int model_release(crfsuite_model_t *model)
-{
-    int count = crfsuite_interlocked_decrement(&model->nref);
-    if (count == 0)
-    {
-        /* This instance is being destroyed. */
-        model_internal_t *internal = (model_internal_t *)model->internal;
-        free(internal->labels);
-        free(internal->attrs);
-        crf1dm_close(internal->crf1dm);
-        free(internal);
-        free(model);
-    }
-    return count;
-}
-
-static int model_get_tagger(crfsuite_model_t *model, crfsuite_tagger_t **ptr_tagger)
-{
-    int ret = 0;
-    crf1dt_t *crf1dt = NULL;
-    crfsuite_tagger_t *tagger = NULL;
-    model_internal_t *internal = (model_internal_t *)model->internal;
-
-    /* Construct a tagger based on the model. */
-    crf1dt = crf1dt_new(internal->crf1dm);
-    if (crf1dt == NULL)
-    {
-        ret = CRFSUITEERR_OUTOFMEMORY;
-        goto error_exit;
-    }
-
-    /* Create an instance of tagger object. */
-    tagger = (crfsuite_tagger_t *)calloc(1, sizeof(crfsuite_tagger_t));
-    if (tagger == NULL)
-    {
-        ret = CRFSUITEERR_OUTOFMEMORY;
-        goto error_exit;
-    }
-    tagger->internal = crf1dt;
-    tagger->nref = 1;
-    tagger->addref = tagger_addref;
-    tagger->release = tagger_release;
-    tagger->set = tagger_set;
-    tagger->length = tagger_length;
-    tagger->viterbi = tagger_viterbi;
-    tagger->score = tagger_score;
-    tagger->lognorm = tagger_lognorm;
-    tagger->marginal_point = tagger_marginal_point;
-    tagger->marginal_path = tagger_marginal_path;
-
-    *ptr_tagger = tagger;
-    return 0;
-
-error_exit:
-    free(tagger);
-    if (crf1dt != NULL)
-    {
-        crf1dt_delete(crf1dt);
-    }
-    return ret;
-}
-
-static int model_get_labels(crfsuite_model_t *model, crfsuite_dictionary_t **ptr_labels)
-{
-    model_internal_t *internal = (model_internal_t *)model->internal;
-    /* We don't increment the reference counter. */
-    *ptr_labels = internal->labels;
-    return 0;
-}
-
-static int model_get_attrs(crfsuite_model_t *model, crfsuite_dictionary_t **ptr_attrs)
-{
-    model_internal_t *internal = (model_internal_t *)model->internal;
-    /* We don't increment the reference counter. */
-    *ptr_attrs = internal->attrs;
-    return 0;
-}
-
-static int model_dump_transitions(crfsuite_model_t *model, FILE *fpo)
-{
-    model_internal_t *internal = (model_internal_t *)model->internal;
-    crf1dm_dump_transitions(internal->crf1dm, fpo);
-    return 0;
-}
-
-static int model_dump_states(crfsuite_model_t *model, FILE *fpo)
-{
-    model_internal_t *internal = (model_internal_t *)model->internal;
-    crf1dm_dump_states(internal->crf1dm, fpo);
-    return 0;
-}
-
-static int crf1m_model_create(crf1dm_t *crf1dm, void **ptr_model)
-{
-    int ret = 0;
-    crfsuite_model_t *model = NULL;
-    model_internal_t *internal = NULL;
-    crfsuite_dictionary_t *attrs = NULL, *labels = NULL;
-
-    *ptr_model = NULL;
-
-    if (crf1dm == NULL)
-    {
-        ret = CRFSUITEERR_INCOMPATIBLE;
-        goto error_exit;
-    }
-
-    /* Create an instance of internal data attached to the model. */
-    internal = (model_internal_t *)calloc(1, sizeof(model_internal_t));
-    if (internal == NULL)
-    {
-        ret = CRFSUITEERR_OUTOFMEMORY;
-        goto error_exit;
-    }
-
-    /* Create an instance of dictionary object for attributes. */
-    attrs = (crfsuite_dictionary_t *)calloc(1, sizeof(crfsuite_dictionary_t));
-    if (attrs == NULL)
-    {
-        ret = CRFSUITEERR_OUTOFMEMORY;
-        goto error_exit;
-    }
-    attrs->internal = crf1dm;
-    attrs->nref = 1;
-    attrs->addref = model_attrs_addref;
-    attrs->release = model_attrs_release;
-    attrs->get = model_attrs_get;
-    attrs->to_id = model_attrs_to_id;
-    attrs->to_string = model_attrs_to_string;
-    attrs->num = model_attrs_num;
-    attrs->free = model_attrs_free;
-
-    /* Create an instance of dictionary object for labels. */
-    labels = (crfsuite_dictionary_t *)calloc(1, sizeof(crfsuite_dictionary_t));
-    if (labels == NULL)
-    {
-        ret = CRFSUITEERR_OUTOFMEMORY;
-        goto error_exit;
-    }
-    labels->internal = crf1dm;
-    labels->nref = 1;
-    labels->addref = model_labels_addref;
-    labels->release = model_labels_release;
-    labels->get = model_labels_get;
-    labels->to_id = model_labels_to_id;
-    labels->to_string = model_labels_to_string;
-    labels->num = model_labels_num;
-    labels->free = model_labels_free;
-
-    /* Set the internal data for the model object. */
-    internal->crf1dm = crf1dm;
-    internal->attrs = attrs;
-    internal->labels = labels;
-
-    /* Create an instance of model object. */
-    model = (crfsuite_model_t *)calloc(1, sizeof(crfsuite_model_t));
-    if (model == NULL)
-    {
-        ret = CRFSUITEERR_OUTOFMEMORY;
-        goto error_exit;
-    }
-    model->internal = internal;
-    model->nref = 1;
-    model->addref = model_addref;
-    model->release = model_release;
-    model->get_attrs = model_get_attrs;
-    model->get_labels = model_get_labels;
-    model->get_tagger = model_get_tagger;
-    model->dump_transitions = model_dump_transitions;
-    model->dump_states = model_dump_states;
-
-    *ptr_model = model;
-    return 0;
-
-error_exit:
-    free(labels);
-    free(attrs);
-    if (crf1dm != NULL)
-    {
-        crf1dm_close(crf1dm);
-    }
-    free(internal);
-    free(model);
-    return ret;
-}
-
-int crf1m_create_instance_from_file(const char *filename, void **ptr)
-{
-    return crf1m_model_create(crf1dm_new(filename), ptr);
-}
-
-int crf1m_create_instance_from_memory(const void *data, size_t size, void **ptr)
-{
-    return crf1m_model_create(crf1dm_new_from_memory(data, size), ptr);
-}
+/*
+ *      CRF1d tagger (implementation of crfsuite_model_t and crfsuite_tagger_t).
+ *
+ * Copyright (c) 2007-2010, Naoaki Okazaki
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the names of the authors nor the names of its contributors
+ *       may be used to endorse or promote products derived from this
+ *       software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+ * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/* $Id$ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif /*HAVE_CONFIG_H*/
+
+#include <os.h>
+
+#include <math.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include <crfsuite.h>
+
+#include "crf1d.h"
+
+enum
+{
+    LEVEL_NONE = 0,
+    LEVEL_SET,
+    LEVEL_ALPHABETA,
+};
+
+typedef struct
+{
+    crf1dm_t *model;      /**< CRF model. */
+    crf1d_context_t *ctx; /**< CRF context. */
+    int num_labels;       /**< Number of distinct output labels (L). */
+    int num_attributes;   /**< Number of distinct attributes (A). */
+    int level;
+} crf1dt_t;
+
+static void crf1dt_state_score(crf1dt_t *crf1dt, const crfsuite_instance_t *inst)
+{
+    int a, i, l, t, r, fid;
+    crf1dm_feature_t f;
+    feature_refs_t attr;
+    floatval_t value, *state = NULL;
+    crf1dm_t *model = crf1dt->model;
+    crf1d_context_t *ctx = crf1dt->ctx;
+    const crfsuite_item_t *item = NULL;
+    const int T = inst->num_items;
+    const int L = crf1dt->num_labels;
+
+    /* Loop over the items in the sequence. */
+    for (t = 0; t < T; ++t)
+    {
+        item = &inst->items[t];
+        state = STATE_SCORE(ctx, t);
+
+        /* Loop over the contents (attributes) attached to the item. */
+        for (i = 0; i < item->num_contents; ++i)
+        {
+            /* Access the list of state features associated with the attribute. */
+            a = item->contents[i].aid;
+            crf1dm_get_attrref(model, a, &attr);
+            /* A scale usually represents the atrribute frequency in the item. */
+            value = item->contents[i].value;
+
+            /* Loop over the state features associated with the attribute. */
+            for (r = 0; r < attr.num_features; ++r)
+            {
+                /* The state feature #(attr->fids[r]), which is represented by
+                   the attribute #a, outputs the label #(f->dst). */
+                fid = crf1dm_get_featureid(&attr, r);
+                crf1dm_get_feature(model, fid, &f);
+                l = f.dst;
+                state[l] += f.weight * value;
+            }
+        }
+    }
+}
+
+static void crf1dt_transition_score(crf1dt_t *crf1dt)
+{
+    int i, r, fid;
+    crf1dm_feature_t f;
+    feature_refs_t edge;
+    floatval_t *trans = NULL;
+    crf1dm_t *model = crf1dt->model;
+    crf1d_context_t *ctx = crf1dt->ctx;
+    const int L = crf1dt->num_labels;
+
+    /* Compute transition scores between two labels. */
+    for (i = 0; i < L; ++i)
+    {
+        trans = TRANS_SCORE(ctx, i);
+        crf1dm_get_labelref(model, i, &edge);
+        for (r = 0; r < edge.num_features; ++r)
+        {
+            /* Transition feature from #i to #(f->dst). */
+            fid = crf1dm_get_featureid(&edge, r);
+            crf1dm_get_feature(model, fid, &f);
+            trans[f.dst] = f.weight;
+        }
+    }
+}
+
+static void crf1dt_set_level(crf1dt_t *crf1dt, int level)
+{
+    int prev = crf1dt->level;
+    crf1d_context_t *ctx = crf1dt->ctx;
+
+    if (level <= LEVEL_ALPHABETA && prev < LEVEL_ALPHABETA)
+    {
+        crf1dc_exp_state(ctx);
+        crf1dc_alpha_score(ctx);
+        crf1dc_beta_score(ctx);
+    }
+
+    crf1dt->level = level;
+}
+
+static void crf1dt_delete(crf1dt_t *crf1dt)
+{
+    /* Note: we don't own the model object (crf1t->model). */
+    if (crf1dt->ctx != NULL)
+    {
+        crf1dc_delete(crf1dt->ctx);
+        crf1dt->ctx = NULL;
+    }
+    free(crf1dt);
+}
+
+static crf1dt_t *crf1dt_new(crf1dm_t *crf1dm)
+{
+    crf1dt_t *crf1dt = NULL;
+
+    crf1dt = (crf1dt_t *)calloc(1, sizeof(crf1dt_t));
+    if (crf1dt != NULL)
+    {
+        crf1dt->num_labels = crf1dm_get_num_labels(crf1dm);
+        crf1dt->num_attributes = crf1dm_get_num_attrs(crf1dm);
+        crf1dt->model = crf1dm;
+        crf1dt->ctx = crf1dc_new(CTXF_VITERBI | CTXF_MARGINALS, crf1dt->num_labels, 0);
+        if (crf1dt->ctx != NULL)
+        {
+            crf1dc_reset(crf1dt->ctx, RF_TRANS);
+            crf1dt_transition_score(crf1dt);
+            crf1dc_exp_transition(crf1dt->ctx);
+        }
+        else
+        {
+            crf1dt_delete(crf1dt);
+            crf1dt = NULL;
+        }
+        crf1dt->level = LEVEL_NONE;
+    }
+
+    return crf1dt;
+}
+
+/*
+ *    Implementation of crfsuite_tagger_t object.
+ *    This object is instantiated only by a crfsuite_model_t object.
+ */
+
+static int tagger_addref(crfsuite_tagger_t *tagger)
+{
+    return crfsuite_interlocked_increment(&tagger->nref);
+}
+
+static int tagger_release(crfsuite_tagger_t *tagger)
+{
+    int count = crfsuite_interlocked_decrement(&tagger->nref);
+    if (count == 0)
+    {
+        /* This instance is being destroyed. */
+        crf1dt_delete((crf1dt_t *)tagger->internal);
+        free(tagger);
+    }
+    return count;
+}
+
+static int tagger_set(crfsuite_tagger_t *tagger, crfsuite_instance_t *inst)
+{
+    crf1dt_t *crf1dt = (crf1dt_t *)tagger->internal;
+    crf1d_context_t *ctx = crf1dt->ctx;
+    crf1dc_set_num_items(ctx, inst->num_items);
+    crf1dc_reset(crf1dt->ctx, RF_STATE);
+    crf1dt_state_score(crf1dt, inst);
+    crf1dt->level = LEVEL_SET;
+    return 0;
+}
+
+static int tagger_length(crfsuite_tagger_t *tagger)
+{
+    crf1dt_t *crf1dt = (crf1dt_t *)tagger->internal;
+    crf1d_context_t *ctx = crf1dt->ctx;
+    return ctx->num_items;
+}
+
+static int tagger_viterbi(crfsuite_tagger_t *tagger, int *labels, floatval_t *ptr_score)
+{
+    floatval_t score;
+    crf1dt_t *crf1dt = (crf1dt_t *)tagger->internal;
+    crf1d_context_t *ctx = crf1dt->ctx;
+
+    score = crf1dc_viterbi(ctx, labels);
+    if (ptr_score != NULL)
+    {
+        *ptr_score = score;
+    }
+
+    return 0;
+}
+
+static int tagger_score(crfsuite_tagger_t *tagger, int *path, floatval_t *ptr_score)
+{
+    floatval_t score;
+    crf1dt_t *crf1dt = (crf1dt_t *)tagger->internal;
+    crf1d_context_t *ctx = crf1dt->ctx;
+    score = crf1dc_score(ctx, path);
+    if (ptr_score != NULL)
+    {
+        *ptr_score = score;
+    }
+    return 0;
+}
+
+static int tagger_lognorm(crfsuite_tagger_t *tagger, floatval_t *ptr_norm)
+{
+    crf1dt_t *crf1dt = (crf1dt_t *)tagger->internal;
+    crf1dt_set_level(crf1dt, LEVEL_ALPHABETA);
+    *ptr_norm = crf1dc_lognorm(crf1dt->ctx);
+    return 0;
+}
+
+static int tagger_marginal_point(crfsuite_tagger_t *tagger, int l, int t, floatval_t *ptr_prob)
+{
+    crf1dt_t *crf1dt = (crf1dt_t *)tagger->internal;
+    crf1dt_set_level(crf1dt, LEVEL_ALPHABETA);
+    *ptr_prob = crf1dc_marginal_point(crf1dt->ctx, l, t);
+    return 0;
+}
+
+static int tagger_marginal_path(crfsuite_tagger_t *tagger, const int *path, int begin, int end, floatval_t *ptr_prob)
+{
+    crf1dt_t *crf1dt = (crf1dt_t *)tagger->internal;
+    crf1dt_set_level(crf1dt, LEVEL_ALPHABETA);
+    *ptr_prob = crf1dc_marginal_path(crf1dt->ctx, path, begin, end);
+    return 0;
+}
+
+/*
+ *    Implementation of crfsuite_dictionary_t object for attributes.
+ *    This object is instantiated only by a crfsuite_model_t object.
+ */
+
+static int model_attrs_addref(crfsuite_dictionary_t *dic)
+{
+    /* This object is owned only by a crfsuite_model_t object. */
+    return dic->nref;
+}
+
+static int model_attrs_release(crfsuite_dictionary_t *dic)
+{
+    /* This object is owned and freed only by a crfsuite_model_t object. */
+    return dic->nref;
+}
+
+static int model_attrs_get(crfsuite_dictionary_t *dic, const char *str)
+{
+    /* This object is ready only. */
+    return CRFSUITEERR_NOTSUPPORTED;
+}
+
+static int model_attrs_to_id(crfsuite_dictionary_t *dic, const char *str)
+{
+    crf1dm_t *crf1dm = (crf1dm_t *)dic->internal;
+    return crf1dm_to_aid(crf1dm, str);
+}
+
+static int model_attrs_to_string(crfsuite_dictionary_t *dic, int id, char const **pstr)
+{
+    crf1dm_t *crf1dm = (crf1dm_t *)dic->internal;
+    *pstr = crf1dm_to_attr(crf1dm, id);
+    return 0;
+}
+
+static int model_attrs_num(crfsuite_dictionary_t *dic)
+{
+    crf1dm_t *crf1dm = (crf1dm_t *)dic->internal;
+    return crf1dm_get_num_attrs(crf1dm);
+}
+
+static void model_attrs_free(crfsuite_dictionary_t *dic, const char *str)
+{
+    /* all strings are freed on the release of the dictionary object. */
+}
+
+/*
+ *    Implementation of crfsuite_dictionary_t object for labels.
+ *    This object is instantiated only by a crfsuite_model_t object.
+ */
+
+static int model_labels_addref(crfsuite_dictionary_t *dic)
+{
+    /* This object is owned only by a crfsuite_model_t object. */
+    return dic->nref;
+}
+
+static int model_labels_release(crfsuite_dictionary_t *dic)
+{
+    /* This object is owned and freed only by a crfsuite_model_t object. */
+    return dic->nref;
+}
+
+static int model_labels_get(crfsuite_dictionary_t *dic, const char *str)
+{
+    /* This object is ready only. */
+    return CRFSUITEERR_NOTSUPPORTED;
+}
+
+static int model_labels_to_id(crfsuite_dictionary_t *dic, const char *str)
+{
+    crf1dm_t *crf1dm = (crf1dm_t *)dic->internal;
+    return crf1dm_to_lid(crf1dm, str);
+}
+
+static int model_labels_to_string(crfsuite_dictionary_t *dic, int id, char const **pstr)
+{
+    crf1dm_t *crf1dm = (crf1dm_t *)dic->internal;
+    *pstr = crf1dm_to_label(crf1dm, id);
+    return 0;
+}
+
+static int model_labels_num(crfsuite_dictionary_t *dic)
+{
+    crf1dm_t *crf1dm = (crf1dm_t *)dic->internal;
+    return crf1dm_get_num_labels(crf1dm);
+}
+
+static void model_labels_free(crfsuite_dictionary_t *dic, const char *str)
+{
+    /* all strings are freed on the release of the dictionary object. */
+}
+
+/*
+ *    Implementation of crfsuite_model_t object.
+ *    This object is instantiated by crf1m_model_create() function.
+ */
+
+typedef struct
+{
+    crf1dm_t *crf1dm;
+
+    crfsuite_dictionary_t *attrs;
+    crfsuite_dictionary_t *labels;
+} model_internal_t;
+
+static int model_addref(crfsuite_model_t *model)
+{
+    return crfsuite_interlocked_increment(&model->nref);
+}
+
+static int model_release(crfsuite_model_t *model)
+{
+    int count = crfsuite_interlocked_decrement(&model->nref);
+    if (count == 0)
+    {
+        /* This instance is being destroyed. */
+        model_internal_t *internal = (model_internal_t *)model->internal;
+        free(internal->labels);
+        free(internal->attrs);
+        crf1dm_close(internal->crf1dm);
+        free(internal);
+        free(model);
+    }
+    return count;
+}
+
+static int model_get_tagger(crfsuite_model_t *model, crfsuite_tagger_t **ptr_tagger)
+{
+    int ret = 0;
+    crf1dt_t *crf1dt = NULL;
+    crfsuite_tagger_t *tagger = NULL;
+    model_internal_t *internal = (model_internal_t *)model->internal;
+
+    /* Construct a tagger based on the model. */
+    crf1dt = crf1dt_new(internal->crf1dm);
+    if (crf1dt == NULL)
+    {
+        ret = CRFSUITEERR_OUTOFMEMORY;
+        goto error_exit;
+    }
+
+    /* Create an instance of tagger object. */
+    tagger = (crfsuite_tagger_t *)calloc(1, sizeof(crfsuite_tagger_t));
+    if (tagger == NULL)
+    {
+        ret = CRFSUITEERR_OUTOFMEMORY;
+        goto error_exit;
+    }
+    tagger->internal = crf1dt;
+    tagger->nref = 1;
+    tagger->addref = tagger_addref;
+    tagger->release = tagger_release;
+    tagger->set = tagger_set;
+    tagger->length = tagger_length;
+    tagger->viterbi = tagger_viterbi;
+    tagger->score = tagger_score;
+    tagger->lognorm = tagger_lognorm;
+    tagger->marginal_point = tagger_marginal_point;
+    tagger->marginal_path = tagger_marginal_path;
+
+    *ptr_tagger = tagger;
+    return 0;
+
+error_exit:
+    free(tagger);
+    if (crf1dt != NULL)
+    {
+        crf1dt_delete(crf1dt);
+    }
+    return ret;
+}
+
+static int model_get_labels(crfsuite_model_t *model, crfsuite_dictionary_t **ptr_labels)
+{
+    model_internal_t *internal = (model_internal_t *)model->internal;
+    /* We don't increment the reference counter. */
+    *ptr_labels = internal->labels;
+    return 0;
+}
+
+static int model_get_attrs(crfsuite_model_t *model, crfsuite_dictionary_t **ptr_attrs)
+{
+    model_internal_t *internal = (model_internal_t *)model->internal;
+    /* We don't increment the reference counter. */
+    *ptr_attrs = internal->attrs;
+    return 0;
+}
+
+static int model_dump_transitions(crfsuite_model_t *model, FILE *fpo)
+{
+    model_internal_t *internal = (model_internal_t *)model->internal;
+    crf1dm_dump_transitions(internal->crf1dm, fpo);
+    return 0;
+}
+
+static int model_dump_states(crfsuite_model_t *model, FILE *fpo)
+{
+    model_internal_t *internal = (model_internal_t *)model->internal;
+    crf1dm_dump_states(internal->crf1dm, fpo);
+    return 0;
+}
+
+static int crf1m_model_create(crf1dm_t *crf1dm, void **ptr_model)
+{
+    int ret = 0;
+    crfsuite_model_t *model = NULL;
+    model_internal_t *internal = NULL;
+    crfsuite_dictionary_t *attrs = NULL, *labels = NULL;
+
+    *ptr_model = NULL;
+
+    if (crf1dm == NULL)
+    {
+        ret = CRFSUITEERR_INCOMPATIBLE;
+        goto error_exit;
+    }
+
+    /* Create an instance of internal data attached to the model. */
+    internal = (model_internal_t *)calloc(1, sizeof(model_internal_t));
+    if (internal == NULL)
+    {
+        ret = CRFSUITEERR_OUTOFMEMORY;
+        goto error_exit;
+    }
+
+    /* Create an instance of dictionary object for attributes. */
+    attrs = (crfsuite_dictionary_t *)calloc(1, sizeof(crfsuite_dictionary_t));
+    if (attrs == NULL)
+    {
+        ret = CRFSUITEERR_OUTOFMEMORY;
+        goto error_exit;
+    }
+    attrs->internal = crf1dm;
+    attrs->nref = 1;
+    attrs->addref = model_attrs_addref;
+    attrs->release = model_attrs_release;
+    attrs->get = model_attrs_get;
+    attrs->to_id = model_attrs_to_id;
+    attrs->to_string = model_attrs_to_string;
+    attrs->num = model_attrs_num;
+    attrs->free = model_attrs_free;
+
+    /* Create an instance of dictionary object for labels. */
+    labels = (crfsuite_dictionary_t *)calloc(1, sizeof(crfsuite_dictionary_t));
+    if (labels == NULL)
+    {
+        ret = CRFSUITEERR_OUTOFMEMORY;
+        goto error_exit;
+    }
+    labels->internal = crf1dm;
+    labels->nref = 1;
+    labels->addref = model_labels_addref;
+    labels->release = model_labels_release;
+    labels->get = model_labels_get;
+    labels->to_id = model_labels_to_id;
+    labels->to_string = model_labels_to_string;
+    labels->num = model_labels_num;
+    labels->free = model_labels_free;
+
+    /* Set the internal data for the model object. */
+    internal->crf1dm = crf1dm;
+    internal->attrs = attrs;
+    internal->labels = labels;
+
+    /* Create an instance of model object. */
+    model = (crfsuite_model_t *)calloc(1, sizeof(crfsuite_model_t));
+    if (model == NULL)
+    {
+        ret = CRFSUITEERR_OUTOFMEMORY;
+        goto error_exit;
+    }
+    model->internal = internal;
+    model->nref = 1;
+    model->addref = model_addref;
+    model->release = model_release;
+    model->get_attrs = model_get_attrs;
+    model->get_labels = model_get_labels;
+    model->get_tagger = model_get_tagger;
+    model->dump_transitions = model_dump_transitions;
+    model->dump_states = model_dump_states;
+
+    *ptr_model = model;
+    return 0;
+
+error_exit:
+    free(labels);
+    free(attrs);
+    if (crf1dm != NULL)
+    {
+        crf1dm_close(crf1dm);
+    }
+    free(internal);
+    free(model);
+    return ret;
+}
+
+int crf1m_create_instance_from_file(const char *filename, void **ptr)
+{
+    return crf1m_model_create(crf1dm_new(filename), ptr);
+}
+
+int crf1m_create_instance_from_memory(const void *data, size_t size, void **ptr)
+{
+    return crf1m_model_create(crf1dm_new_from_memory(data, size), ptr);
+}
```

## chaine/_core/crfsuite/lib/crf/src/crfsuite.c

 * *Ordering differences only*

```diff
@@ -1,500 +1,500 @@
-/*
- *      CRFsuite library.
- *
- * Copyright (c) 2007-2010, Naoaki Okazaki
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the names of the authors nor the names of its contributors
- *       may be used to endorse or promote products derived from this
- *       software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
- * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-/* $Id$ */
-
-#include <os.h>
-
-#include <stdarg.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-
-#include <crfsuite.h>
-#include "logging.h"
-
-int crf1de_create_instance(const char *iid, void **ptr);
-int crfsuite_dictionary_create_instance(const char *interface, void **ptr);
-int crf1m_create_instance_from_file(const char *filename, void **ptr);
-int crf1m_create_instance_from_memory(const void *data, size_t size, void **ptr);
-
-int crfsuite_create_instance(const char *iid, void **ptr)
-{
-    int ret =
-        crf1de_create_instance(iid, ptr) == 0 ||
-        crfsuite_dictionary_create_instance(iid, ptr) == 0;
-
-    return ret;
-}
-
-int crfsuite_create_instance_from_file(const char *filename, void **ptr)
-{
-    int ret = crf1m_create_instance_from_file(filename, ptr);
-    return ret;
-}
-
-int crfsuite_create_instance_from_memory(const void *data, size_t size, void **ptr)
-{
-    int ret = crf1m_create_instance_from_memory(data, size, ptr);
-    return ret;
-}
-
-void crfsuite_attribute_init(crfsuite_attribute_t *cont)
-{
-    memset(cont, 0, sizeof(*cont));
-    cont->value = 1;
-}
-
-void crfsuite_attribute_set(crfsuite_attribute_t *cont, int aid, floatval_t value)
-{
-    crfsuite_attribute_init(cont);
-    cont->aid = aid;
-    cont->value = value;
-}
-
-void crfsuite_attribute_copy(crfsuite_attribute_t *dst, const crfsuite_attribute_t *src)
-{
-    dst->aid = src->aid;
-    dst->value = src->value;
-}
-
-void crfsuite_attribute_swap(crfsuite_attribute_t *x, crfsuite_attribute_t *y)
-{
-    crfsuite_attribute_t tmp = *x;
-    x->aid = y->aid;
-    x->value = y->value;
-    y->aid = tmp.aid;
-    y->value = tmp.value;
-}
-
-void crfsuite_item_init(crfsuite_item_t *item)
-{
-    memset(item, 0, sizeof(*item));
-}
-
-void crfsuite_item_init_n(crfsuite_item_t *item, int num_contents)
-{
-    crfsuite_item_init(item);
-    item->num_contents = num_contents;
-    item->cap_contents = num_contents;
-    item->contents = (crfsuite_attribute_t *)calloc(num_contents, sizeof(crfsuite_attribute_t));
-}
-
-void crfsuite_item_finish(crfsuite_item_t *item)
-{
-    free(item->contents);
-    crfsuite_item_init(item);
-}
-
-void crfsuite_item_copy(crfsuite_item_t *dst, const crfsuite_item_t *src)
-{
-    int i;
-
-    dst->num_contents = src->num_contents;
-    dst->cap_contents = src->cap_contents;
-    dst->contents = (crfsuite_attribute_t *)calloc(dst->num_contents, sizeof(crfsuite_attribute_t));
-    for (i = 0; i < dst->num_contents; ++i)
-    {
-        crfsuite_attribute_copy(&dst->contents[i], &src->contents[i]);
-    }
-}
-
-void crfsuite_item_swap(crfsuite_item_t *x, crfsuite_item_t *y)
-{
-    crfsuite_item_t tmp = *x;
-    x->num_contents = y->num_contents;
-    x->cap_contents = y->cap_contents;
-    x->contents = y->contents;
-    y->num_contents = tmp.num_contents;
-    y->cap_contents = tmp.cap_contents;
-    y->contents = tmp.contents;
-}
-
-int crfsuite_item_append_attribute(crfsuite_item_t *item, const crfsuite_attribute_t *cont)
-{
-    if (item->cap_contents <= item->num_contents)
-    {
-        item->cap_contents = (item->cap_contents + 1) * 2;
-        item->contents = (crfsuite_attribute_t *)realloc(
-            item->contents, sizeof(crfsuite_attribute_t) * item->cap_contents);
-    }
-    crfsuite_attribute_copy(&item->contents[item->num_contents++], cont);
-    return 0;
-}
-
-int crfsuite_item_empty(crfsuite_item_t *item)
-{
-    return (item->num_contents == 0);
-}
-
-void crfsuite_instance_init(crfsuite_instance_t *inst)
-{
-    memset(inst, 0, sizeof(*inst));
-    inst->weight = 1.;
-}
-
-void crfsuite_instance_init_n(crfsuite_instance_t *inst, int num_items)
-{
-    crfsuite_instance_init(inst);
-    inst->num_items = num_items;
-    inst->cap_items = num_items;
-    inst->items = (crfsuite_item_t *)calloc(num_items, sizeof(crfsuite_item_t));
-    inst->labels = (int *)calloc(num_items, sizeof(int));
-}
-
-void crfsuite_instance_finish(crfsuite_instance_t *inst)
-{
-    int i;
-
-    for (i = 0; i < inst->num_items; ++i)
-    {
-        crfsuite_item_finish(&inst->items[i]);
-    }
-    free(inst->labels);
-    free(inst->items);
-    crfsuite_instance_init(inst);
-}
-
-void crfsuite_instance_copy(crfsuite_instance_t *dst, const crfsuite_instance_t *src)
-{
-    int i;
-
-    dst->num_items = src->num_items;
-    dst->cap_items = src->cap_items;
-    dst->items = (crfsuite_item_t *)calloc(dst->num_items, sizeof(crfsuite_item_t));
-    dst->labels = (int *)calloc(dst->num_items, sizeof(int));
-    dst->weight = src->weight;
-    dst->group = src->group;
-    for (i = 0; i < dst->num_items; ++i)
-    {
-        crfsuite_item_copy(&dst->items[i], &src->items[i]);
-        dst->labels[i] = src->labels[i];
-    }
-}
-
-void crfsuite_instance_swap(crfsuite_instance_t *x, crfsuite_instance_t *y)
-{
-    crfsuite_instance_t tmp = *x;
-    x->num_items = y->num_items;
-    x->cap_items = y->cap_items;
-    x->items = y->items;
-    x->labels = y->labels;
-    x->weight = y->weight;
-    x->group = y->group;
-    y->num_items = tmp.num_items;
-    y->cap_items = tmp.cap_items;
-    y->items = tmp.items;
-    y->labels = tmp.labels;
-    y->weight = tmp.weight;
-    y->group = tmp.group;
-}
-
-int crfsuite_instance_append(crfsuite_instance_t *inst, const crfsuite_item_t *item, int label)
-{
-    if (inst->cap_items <= inst->num_items)
-    {
-        inst->cap_items = (inst->cap_items + 1) * 2;
-        inst->items = (crfsuite_item_t *)realloc(inst->items, sizeof(crfsuite_item_t) * inst->cap_items);
-        inst->labels = (int *)realloc(inst->labels, sizeof(int) * inst->cap_items);
-    }
-    crfsuite_item_copy(&inst->items[inst->num_items], item);
-    inst->labels[inst->num_items] = label;
-    ++inst->num_items;
-    return 0;
-}
-
-int crfsuite_instance_empty(crfsuite_instance_t *inst)
-{
-    return (inst->num_items == 0);
-}
-
-void crfsuite_data_init(crfsuite_data_t *data)
-{
-    memset(data, 0, sizeof(*data));
-}
-
-void crfsuite_data_init_n(crfsuite_data_t *data, int n)
-{
-    crfsuite_data_init(data);
-    data->num_instances = n;
-    data->cap_instances = n;
-    data->instances = (crfsuite_instance_t *)calloc(n, sizeof(crfsuite_instance_t));
-}
-
-void crfsuite_data_finish(crfsuite_data_t *data)
-{
-    int i;
-
-    for (i = 0; i < data->num_instances; ++i)
-    {
-        crfsuite_instance_finish(&data->instances[i]);
-    }
-    free(data->instances);
-    crfsuite_data_init(data);
-}
-
-void crfsuite_data_copy(crfsuite_data_t *dst, const crfsuite_data_t *src)
-{
-    int i;
-
-    dst->num_instances = src->num_instances;
-    dst->cap_instances = src->cap_instances;
-    dst->instances = (crfsuite_instance_t *)calloc(dst->num_instances, sizeof(crfsuite_instance_t));
-    for (i = 0; i < dst->num_instances; ++i)
-    {
-        crfsuite_instance_copy(&dst->instances[i], &src->instances[i]);
-    }
-}
-
-void crfsuite_data_swap(crfsuite_data_t *x, crfsuite_data_t *y)
-{
-    crfsuite_data_t tmp = *x;
-    x->num_instances = y->num_instances;
-    x->cap_instances = y->cap_instances;
-    x->instances = y->instances;
-    y->num_instances = tmp.num_instances;
-    y->cap_instances = tmp.cap_instances;
-    y->instances = tmp.instances;
-}
-
-int crfsuite_data_append(crfsuite_data_t *data, const crfsuite_instance_t *inst)
-{
-    if (0 < inst->num_items)
-    {
-        if (data->cap_instances <= data->num_instances)
-        {
-            data->cap_instances = (data->cap_instances + 1) * 2;
-            data->instances = (crfsuite_instance_t *)realloc(
-                data->instances, sizeof(crfsuite_instance_t) * data->cap_instances);
-        }
-        crfsuite_instance_copy(&data->instances[data->num_instances++], inst);
-    }
-    return 0;
-}
-
-int crfsuite_data_maxlength(crfsuite_data_t *data)
-{
-    int i, T = 0;
-    for (i = 0; i < data->num_instances; ++i)
-    {
-        if (T < data->instances[i].num_items)
-        {
-            T = data->instances[i].num_items;
-        }
-    }
-    return T;
-}
-
-int crfsuite_data_totalitems(crfsuite_data_t *data)
-{
-    int i, n = 0;
-    for (i = 0; i < data->num_instances; ++i)
-    {
-        n += data->instances[i].num_items;
-    }
-    return n;
-}
-
-static char *safe_strncpy(char *dst, const char *src, size_t n)
-{
-    strncpy(dst, src, n - 1);
-    dst[n - 1] = 0;
-    return dst;
-}
-
-void crfsuite_evaluation_init(crfsuite_evaluation_t *eval, int n)
-{
-    memset(eval, 0, sizeof(*eval));
-    eval->tbl = (crfsuite_label_evaluation_t *)calloc(n + 1, sizeof(crfsuite_label_evaluation_t));
-    if (eval->tbl != NULL)
-    {
-        eval->num_labels = n;
-    }
-}
-
-void crfsuite_evaluation_clear(crfsuite_evaluation_t *eval)
-{
-    int i;
-    for (i = 0; i <= eval->num_labels; ++i)
-    {
-        memset(&eval->tbl[i], 0, sizeof(eval->tbl[i]));
-    }
-
-    eval->item_total_correct = 0;
-    eval->item_total_num = 0;
-    eval->item_total_model = 0;
-    eval->item_total_observation = 0;
-    eval->item_accuracy = 0;
-
-    eval->inst_total_correct = 0;
-    eval->inst_total_num = 0;
-    eval->inst_accuracy = 0;
-
-    eval->macro_precision = 0;
-    eval->macro_recall = 0;
-    eval->macro_fmeasure = 0;
-}
-
-void crfsuite_evaluation_finish(crfsuite_evaluation_t *eval)
-{
-    free(eval->tbl);
-    memset(eval, 0, sizeof(*eval));
-}
-
-int crfsuite_evaluation_accmulate(crfsuite_evaluation_t *eval, const int *reference, const int *prediction, int T)
-{
-    int t, nc = 0;
-
-    for (t = 0; t < T; ++t)
-    {
-        int lr = reference[t];
-        int lt = prediction[t];
-
-        if (eval->num_labels <= lr || eval->num_labels <= lt)
-        {
-            return 1;
-        }
-
-        ++eval->tbl[lr].num_observation;
-        ++eval->tbl[lt].num_model;
-        if (lr == lt)
-        {
-            ++eval->tbl[lr].num_correct;
-            ++nc;
-        }
-        ++eval->item_total_num;
-    }
-
-    if (nc == T)
-    {
-        ++eval->inst_total_correct;
-    }
-    ++eval->inst_total_num;
-
-    return 0;
-}
-
-void crfsuite_evaluation_finalize(crfsuite_evaluation_t *eval)
-{
-    int i;
-
-    for (i = 0; i <= eval->num_labels; ++i)
-    {
-        crfsuite_label_evaluation_t *lev = &eval->tbl[i];
-
-        /* Do not evaluate labels that does not in the test data. */
-        if (lev->num_observation == 0)
-        {
-            continue;
-        }
-
-        /* Sum the number of correct labels for accuracy calculation. */
-        eval->item_total_correct += lev->num_correct;
-        eval->item_total_model += lev->num_model;
-        eval->item_total_observation += lev->num_observation;
-
-        /* Initialize the precision, recall, and f1-measure values. */
-        lev->precision = 0;
-        lev->recall = 0;
-        lev->fmeasure = 0;
-
-        /* Compute the precision, recall, and f1-measure values. */
-        if (lev->num_model > 0)
-        {
-            lev->precision = lev->num_correct / (double)lev->num_model;
-        }
-        if (lev->num_observation > 0)
-        {
-            lev->recall = lev->num_correct / (double)lev->num_observation;
-        }
-        if (lev->precision + lev->recall > 0)
-        {
-            lev->fmeasure = lev->precision * lev->recall * 2 / (lev->precision + lev->recall);
-        }
-
-        /* Exclude unknown labels from calculation of macro-average values. */
-        if (i != eval->num_labels)
-        {
-            eval->macro_precision += lev->precision;
-            eval->macro_recall += lev->recall;
-            eval->macro_fmeasure += lev->fmeasure;
-        }
-    }
-
-    /* Copute the macro precision, recall, and f1-measure values. */
-    eval->macro_precision /= eval->num_labels;
-    eval->macro_recall /= eval->num_labels;
-    eval->macro_fmeasure /= eval->num_labels;
-
-    /* Compute the item accuracy. */
-    eval->item_accuracy = 0;
-    if (0 < eval->item_total_num)
-    {
-        eval->item_accuracy = eval->item_total_correct / (double)eval->item_total_num;
-    }
-
-    /* Compute the instance accuracy. */
-    eval->inst_accuracy = 0;
-    if (0 < eval->inst_total_num)
-    {
-        eval->inst_accuracy = eval->inst_total_correct / (double)eval->inst_total_num;
-    }
-}
-
-void crfsuite_evaluation_output(crfsuite_evaluation_t *eval, crfsuite_dictionary_t *labels, crfsuite_logging_callback cbm, void *instance)
-{
-    int i;
-    const char *lstr = NULL;
-    logging_t lg;
-
-    lg.func = cbm;
-    lg.instance = instance;
-
-    for (i = 0; i < eval->num_labels; ++i)
-    {
-        const crfsuite_label_evaluation_t *lev = &eval->tbl[i];
-
-        labels->to_string(labels, i, &lstr);
-        if (lstr == NULL)
-            lstr = "[UNKNOWN]";
-
-        labels->free(labels, lstr);
-    }
-}
-
-int crfsuite_interlocked_increment(int *count)
-{
-    return ++(*count);
-}
-
-int crfsuite_interlocked_decrement(int *count)
-{
-    return --(*count);
-}
+/*
+ *      CRFsuite library.
+ *
+ * Copyright (c) 2007-2010, Naoaki Okazaki
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the names of the authors nor the names of its contributors
+ *       may be used to endorse or promote products derived from this
+ *       software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+ * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/* $Id$ */
+
+#include <os.h>
+
+#include <stdarg.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include <crfsuite.h>
+#include "logging.h"
+
+int crf1de_create_instance(const char *iid, void **ptr);
+int crfsuite_dictionary_create_instance(const char *interface, void **ptr);
+int crf1m_create_instance_from_file(const char *filename, void **ptr);
+int crf1m_create_instance_from_memory(const void *data, size_t size, void **ptr);
+
+int crfsuite_create_instance(const char *iid, void **ptr)
+{
+    int ret =
+        crf1de_create_instance(iid, ptr) == 0 ||
+        crfsuite_dictionary_create_instance(iid, ptr) == 0;
+
+    return ret;
+}
+
+int crfsuite_create_instance_from_file(const char *filename, void **ptr)
+{
+    int ret = crf1m_create_instance_from_file(filename, ptr);
+    return ret;
+}
+
+int crfsuite_create_instance_from_memory(const void *data, size_t size, void **ptr)
+{
+    int ret = crf1m_create_instance_from_memory(data, size, ptr);
+    return ret;
+}
+
+void crfsuite_attribute_init(crfsuite_attribute_t *cont)
+{
+    memset(cont, 0, sizeof(*cont));
+    cont->value = 1;
+}
+
+void crfsuite_attribute_set(crfsuite_attribute_t *cont, int aid, floatval_t value)
+{
+    crfsuite_attribute_init(cont);
+    cont->aid = aid;
+    cont->value = value;
+}
+
+void crfsuite_attribute_copy(crfsuite_attribute_t *dst, const crfsuite_attribute_t *src)
+{
+    dst->aid = src->aid;
+    dst->value = src->value;
+}
+
+void crfsuite_attribute_swap(crfsuite_attribute_t *x, crfsuite_attribute_t *y)
+{
+    crfsuite_attribute_t tmp = *x;
+    x->aid = y->aid;
+    x->value = y->value;
+    y->aid = tmp.aid;
+    y->value = tmp.value;
+}
+
+void crfsuite_item_init(crfsuite_item_t *item)
+{
+    memset(item, 0, sizeof(*item));
+}
+
+void crfsuite_item_init_n(crfsuite_item_t *item, int num_contents)
+{
+    crfsuite_item_init(item);
+    item->num_contents = num_contents;
+    item->cap_contents = num_contents;
+    item->contents = (crfsuite_attribute_t *)calloc(num_contents, sizeof(crfsuite_attribute_t));
+}
+
+void crfsuite_item_finish(crfsuite_item_t *item)
+{
+    free(item->contents);
+    crfsuite_item_init(item);
+}
+
+void crfsuite_item_copy(crfsuite_item_t *dst, const crfsuite_item_t *src)
+{
+    int i;
+
+    dst->num_contents = src->num_contents;
+    dst->cap_contents = src->cap_contents;
+    dst->contents = (crfsuite_attribute_t *)calloc(dst->num_contents, sizeof(crfsuite_attribute_t));
+    for (i = 0; i < dst->num_contents; ++i)
+    {
+        crfsuite_attribute_copy(&dst->contents[i], &src->contents[i]);
+    }
+}
+
+void crfsuite_item_swap(crfsuite_item_t *x, crfsuite_item_t *y)
+{
+    crfsuite_item_t tmp = *x;
+    x->num_contents = y->num_contents;
+    x->cap_contents = y->cap_contents;
+    x->contents = y->contents;
+    y->num_contents = tmp.num_contents;
+    y->cap_contents = tmp.cap_contents;
+    y->contents = tmp.contents;
+}
+
+int crfsuite_item_append_attribute(crfsuite_item_t *item, const crfsuite_attribute_t *cont)
+{
+    if (item->cap_contents <= item->num_contents)
+    {
+        item->cap_contents = (item->cap_contents + 1) * 2;
+        item->contents = (crfsuite_attribute_t *)realloc(
+            item->contents, sizeof(crfsuite_attribute_t) * item->cap_contents);
+    }
+    crfsuite_attribute_copy(&item->contents[item->num_contents++], cont);
+    return 0;
+}
+
+int crfsuite_item_empty(crfsuite_item_t *item)
+{
+    return (item->num_contents == 0);
+}
+
+void crfsuite_instance_init(crfsuite_instance_t *inst)
+{
+    memset(inst, 0, sizeof(*inst));
+    inst->weight = 1.;
+}
+
+void crfsuite_instance_init_n(crfsuite_instance_t *inst, int num_items)
+{
+    crfsuite_instance_init(inst);
+    inst->num_items = num_items;
+    inst->cap_items = num_items;
+    inst->items = (crfsuite_item_t *)calloc(num_items, sizeof(crfsuite_item_t));
+    inst->labels = (int *)calloc(num_items, sizeof(int));
+}
+
+void crfsuite_instance_finish(crfsuite_instance_t *inst)
+{
+    int i;
+
+    for (i = 0; i < inst->num_items; ++i)
+    {
+        crfsuite_item_finish(&inst->items[i]);
+    }
+    free(inst->labels);
+    free(inst->items);
+    crfsuite_instance_init(inst);
+}
+
+void crfsuite_instance_copy(crfsuite_instance_t *dst, const crfsuite_instance_t *src)
+{
+    int i;
+
+    dst->num_items = src->num_items;
+    dst->cap_items = src->cap_items;
+    dst->items = (crfsuite_item_t *)calloc(dst->num_items, sizeof(crfsuite_item_t));
+    dst->labels = (int *)calloc(dst->num_items, sizeof(int));
+    dst->weight = src->weight;
+    dst->group = src->group;
+    for (i = 0; i < dst->num_items; ++i)
+    {
+        crfsuite_item_copy(&dst->items[i], &src->items[i]);
+        dst->labels[i] = src->labels[i];
+    }
+}
+
+void crfsuite_instance_swap(crfsuite_instance_t *x, crfsuite_instance_t *y)
+{
+    crfsuite_instance_t tmp = *x;
+    x->num_items = y->num_items;
+    x->cap_items = y->cap_items;
+    x->items = y->items;
+    x->labels = y->labels;
+    x->weight = y->weight;
+    x->group = y->group;
+    y->num_items = tmp.num_items;
+    y->cap_items = tmp.cap_items;
+    y->items = tmp.items;
+    y->labels = tmp.labels;
+    y->weight = tmp.weight;
+    y->group = tmp.group;
+}
+
+int crfsuite_instance_append(crfsuite_instance_t *inst, const crfsuite_item_t *item, int label)
+{
+    if (inst->cap_items <= inst->num_items)
+    {
+        inst->cap_items = (inst->cap_items + 1) * 2;
+        inst->items = (crfsuite_item_t *)realloc(inst->items, sizeof(crfsuite_item_t) * inst->cap_items);
+        inst->labels = (int *)realloc(inst->labels, sizeof(int) * inst->cap_items);
+    }
+    crfsuite_item_copy(&inst->items[inst->num_items], item);
+    inst->labels[inst->num_items] = label;
+    ++inst->num_items;
+    return 0;
+}
+
+int crfsuite_instance_empty(crfsuite_instance_t *inst)
+{
+    return (inst->num_items == 0);
+}
+
+void crfsuite_data_init(crfsuite_data_t *data)
+{
+    memset(data, 0, sizeof(*data));
+}
+
+void crfsuite_data_init_n(crfsuite_data_t *data, int n)
+{
+    crfsuite_data_init(data);
+    data->num_instances = n;
+    data->cap_instances = n;
+    data->instances = (crfsuite_instance_t *)calloc(n, sizeof(crfsuite_instance_t));
+}
+
+void crfsuite_data_finish(crfsuite_data_t *data)
+{
+    int i;
+
+    for (i = 0; i < data->num_instances; ++i)
+    {
+        crfsuite_instance_finish(&data->instances[i]);
+    }
+    free(data->instances);
+    crfsuite_data_init(data);
+}
+
+void crfsuite_data_copy(crfsuite_data_t *dst, const crfsuite_data_t *src)
+{
+    int i;
+
+    dst->num_instances = src->num_instances;
+    dst->cap_instances = src->cap_instances;
+    dst->instances = (crfsuite_instance_t *)calloc(dst->num_instances, sizeof(crfsuite_instance_t));
+    for (i = 0; i < dst->num_instances; ++i)
+    {
+        crfsuite_instance_copy(&dst->instances[i], &src->instances[i]);
+    }
+}
+
+void crfsuite_data_swap(crfsuite_data_t *x, crfsuite_data_t *y)
+{
+    crfsuite_data_t tmp = *x;
+    x->num_instances = y->num_instances;
+    x->cap_instances = y->cap_instances;
+    x->instances = y->instances;
+    y->num_instances = tmp.num_instances;
+    y->cap_instances = tmp.cap_instances;
+    y->instances = tmp.instances;
+}
+
+int crfsuite_data_append(crfsuite_data_t *data, const crfsuite_instance_t *inst)
+{
+    if (0 < inst->num_items)
+    {
+        if (data->cap_instances <= data->num_instances)
+        {
+            data->cap_instances = (data->cap_instances + 1) * 2;
+            data->instances = (crfsuite_instance_t *)realloc(
+                data->instances, sizeof(crfsuite_instance_t) * data->cap_instances);
+        }
+        crfsuite_instance_copy(&data->instances[data->num_instances++], inst);
+    }
+    return 0;
+}
+
+int crfsuite_data_maxlength(crfsuite_data_t *data)
+{
+    int i, T = 0;
+    for (i = 0; i < data->num_instances; ++i)
+    {
+        if (T < data->instances[i].num_items)
+        {
+            T = data->instances[i].num_items;
+        }
+    }
+    return T;
+}
+
+int crfsuite_data_totalitems(crfsuite_data_t *data)
+{
+    int i, n = 0;
+    for (i = 0; i < data->num_instances; ++i)
+    {
+        n += data->instances[i].num_items;
+    }
+    return n;
+}
+
+static char *safe_strncpy(char *dst, const char *src, size_t n)
+{
+    strncpy(dst, src, n - 1);
+    dst[n - 1] = 0;
+    return dst;
+}
+
+void crfsuite_evaluation_init(crfsuite_evaluation_t *eval, int n)
+{
+    memset(eval, 0, sizeof(*eval));
+    eval->tbl = (crfsuite_label_evaluation_t *)calloc(n + 1, sizeof(crfsuite_label_evaluation_t));
+    if (eval->tbl != NULL)
+    {
+        eval->num_labels = n;
+    }
+}
+
+void crfsuite_evaluation_clear(crfsuite_evaluation_t *eval)
+{
+    int i;
+    for (i = 0; i <= eval->num_labels; ++i)
+    {
+        memset(&eval->tbl[i], 0, sizeof(eval->tbl[i]));
+    }
+
+    eval->item_total_correct = 0;
+    eval->item_total_num = 0;
+    eval->item_total_model = 0;
+    eval->item_total_observation = 0;
+    eval->item_accuracy = 0;
+
+    eval->inst_total_correct = 0;
+    eval->inst_total_num = 0;
+    eval->inst_accuracy = 0;
+
+    eval->macro_precision = 0;
+    eval->macro_recall = 0;
+    eval->macro_fmeasure = 0;
+}
+
+void crfsuite_evaluation_finish(crfsuite_evaluation_t *eval)
+{
+    free(eval->tbl);
+    memset(eval, 0, sizeof(*eval));
+}
+
+int crfsuite_evaluation_accmulate(crfsuite_evaluation_t *eval, const int *reference, const int *prediction, int T)
+{
+    int t, nc = 0;
+
+    for (t = 0; t < T; ++t)
+    {
+        int lr = reference[t];
+        int lt = prediction[t];
+
+        if (eval->num_labels <= lr || eval->num_labels <= lt)
+        {
+            return 1;
+        }
+
+        ++eval->tbl[lr].num_observation;
+        ++eval->tbl[lt].num_model;
+        if (lr == lt)
+        {
+            ++eval->tbl[lr].num_correct;
+            ++nc;
+        }
+        ++eval->item_total_num;
+    }
+
+    if (nc == T)
+    {
+        ++eval->inst_total_correct;
+    }
+    ++eval->inst_total_num;
+
+    return 0;
+}
+
+void crfsuite_evaluation_finalize(crfsuite_evaluation_t *eval)
+{
+    int i;
+
+    for (i = 0; i <= eval->num_labels; ++i)
+    {
+        crfsuite_label_evaluation_t *lev = &eval->tbl[i];
+
+        /* Do not evaluate labels that does not in the test data. */
+        if (lev->num_observation == 0)
+        {
+            continue;
+        }
+
+        /* Sum the number of correct labels for accuracy calculation. */
+        eval->item_total_correct += lev->num_correct;
+        eval->item_total_model += lev->num_model;
+        eval->item_total_observation += lev->num_observation;
+
+        /* Initialize the precision, recall, and f1-measure values. */
+        lev->precision = 0;
+        lev->recall = 0;
+        lev->fmeasure = 0;
+
+        /* Compute the precision, recall, and f1-measure values. */
+        if (lev->num_model > 0)
+        {
+            lev->precision = lev->num_correct / (double)lev->num_model;
+        }
+        if (lev->num_observation > 0)
+        {
+            lev->recall = lev->num_correct / (double)lev->num_observation;
+        }
+        if (lev->precision + lev->recall > 0)
+        {
+            lev->fmeasure = lev->precision * lev->recall * 2 / (lev->precision + lev->recall);
+        }
+
+        /* Exclude unknown labels from calculation of macro-average values. */
+        if (i != eval->num_labels)
+        {
+            eval->macro_precision += lev->precision;
+            eval->macro_recall += lev->recall;
+            eval->macro_fmeasure += lev->fmeasure;
+        }
+    }
+
+    /* Copute the macro precision, recall, and f1-measure values. */
+    eval->macro_precision /= eval->num_labels;
+    eval->macro_recall /= eval->num_labels;
+    eval->macro_fmeasure /= eval->num_labels;
+
+    /* Compute the item accuracy. */
+    eval->item_accuracy = 0;
+    if (0 < eval->item_total_num)
+    {
+        eval->item_accuracy = eval->item_total_correct / (double)eval->item_total_num;
+    }
+
+    /* Compute the instance accuracy. */
+    eval->inst_accuracy = 0;
+    if (0 < eval->inst_total_num)
+    {
+        eval->inst_accuracy = eval->inst_total_correct / (double)eval->inst_total_num;
+    }
+}
+
+void crfsuite_evaluation_output(crfsuite_evaluation_t *eval, crfsuite_dictionary_t *labels, crfsuite_logging_callback cbm, void *instance)
+{
+    int i;
+    const char *lstr = NULL;
+    logging_t lg;
+
+    lg.func = cbm;
+    lg.instance = instance;
+
+    for (i = 0; i < eval->num_labels; ++i)
+    {
+        const crfsuite_label_evaluation_t *lev = &eval->tbl[i];
+
+        labels->to_string(labels, i, &lstr);
+        if (lstr == NULL)
+            lstr = "[UNKNOWN]";
+
+        labels->free(labels, lstr);
+    }
+}
+
+int crfsuite_interlocked_increment(int *count)
+{
+    return ++(*count);
+}
+
+int crfsuite_interlocked_decrement(int *count)
+{
+    return --(*count);
+}
```

## chaine/_core/crfsuite/lib/crf/src/crfsuite_internal.h

 * *Ordering differences only*

```diff
@@ -1,233 +1,233 @@
-/*
- *      CRFsuite internal interface.
- *
- * Copyright (c) 2007-2010, Naoaki Okazaki
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the names of the authors nor the names of its contributors
- *       may be used to endorse or promote products derived from this
- *       software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
- * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-/* $Id$ */
-
-#ifndef __CRFSUITE_INTERNAL_H__
-#define __CRFSUITE_INTERNAL_H__
-
-#include <crfsuite.h>
-#include "logging.h"
-
-enum
-{
-    FTYPE_NONE = 0, /**< Unselected. */
-    FTYPE_CRF1D,    /**< 1st-order tyad features. */
-    FTYPE_CRF1T,    /**< 1st-order triad features. */
-};
-
-enum
-{
-    TRAIN_NONE = 0,            /**< Unselected. */
-    TRAIN_LBFGS,               /**< L-BFGS batch training. */
-    TRAIN_L2SGD,               /**< Pegasos online training. */
-    TRAIN_AVERAGED_PERCEPTRON, /**< Averaged perceptron. */
-    TRAIN_PASSIVE_AGGRESSIVE,
-    TRAIN_AROW,
-};
-
-struct tag_crfsuite_train_internal;
-typedef struct tag_crfsuite_train_internal crfsuite_train_internal_t;
-
-struct tag_encoder;
-typedef struct tag_encoder encoder_t;
-
-typedef struct
-{
-    crfsuite_data_t *data;
-    int *perm;
-    int num_instances;
-} dataset_t;
-
-void dataset_init_trainset(dataset_t *ds, crfsuite_data_t *data, int holdout);
-void dataset_init_testset(dataset_t *ds, crfsuite_data_t *data, int holdout);
-void dataset_finish(dataset_t *ds);
-void dataset_shuffle(dataset_t *ds);
-crfsuite_instance_t *dataset_get(dataset_t *ds, int i);
-
-typedef void (*crfsuite_encoder_features_on_path_callback)(void *instance, int fid, floatval_t value);
-
-/**
- * Internal data structure for
- */
-struct tag_crfsuite_train_internal
-{
-    encoder_t *gm;             /** Interface to the graphical model. */
-    crfsuite_params_t *params; /**< Parameter interface. */
-    logging_t *lg;             /**< Logging interface. */
-    int feature_type;          /**< Feature type. */
-    int algorithm;             /**< Training algorithm. */
-};
-
-/**
- * Interface for a graphical model.
- */
-struct tag_encoder
-{
-    void *internal;
-
-    const floatval_t *w;
-    floatval_t scale;
-
-    dataset_t *ds;
-    const crfsuite_instance_t *inst;
-    int level;
-
-    int num_features;
-    int cap_items;
-
-    /**
-     * Exchanges options.
-     *  @param  self        The encoder instance.
-     *  @param  params      The parameter interface.
-     *  @param  mode        The direction of parameter exchange.
-     *  @return             A status code.
-     */
-    int (*exchange_options)(encoder_t *self, crfsuite_params_t *params, int mode);
-
-    /**
-     * Initializes the encoder with a training data set.
-     *  @param  self        The encoder instance.
-     *  @param  ds          The data set for training.
-     *  @param  lg          The logging interface.
-     *  @return             A status code.
-     */
-    int (*initialize)(encoder_t *self, dataset_t *ds, logging_t *lg);
-
-    /**
-     * Compute the objective value and gradients for the whole data set.
-     *  @param  self        The encoder instance.
-     *  @param  ds          The data set.
-     *  @param  w           The feature weights.
-     *  @param  f           The pointer to a floatval_t variable to which the
-     *                      objective value is stored by this function.
-     *  @param  g           The pointer to the array that receives gradients.
-     *  @return             A status code.
-     */
-    int (*objective_and_gradients_batch)(encoder_t *self, dataset_t *ds, const floatval_t *w, floatval_t *f, floatval_t *g);
-
-    int (*features_on_path)(encoder_t *self, const crfsuite_instance_t *inst, const int *path, crfsuite_encoder_features_on_path_callback func, void *instance);
-
-    /**
-     * Sets the feature weights (and their scale factor).
-     *  @param  self        The encoder instance.
-     *  @param  w           The array of feature weights.
-     *  @param  scale       The scale factor that should be applied to the
-     *                      feature weights.
-     *  @return             A status code.
-     */
-    int (*set_weights)(encoder_t *self, const floatval_t *w, floatval_t scale);
-
-    /* Instance-wise operations. */
-    int (*set_instance)(encoder_t *self, const crfsuite_instance_t *inst);
-
-    /* Level 0. */
-
-    /* Level 1 (feature weights). */
-    int (*score)(encoder_t *self, const int *path, floatval_t *ptr_score);
-    int (*viterbi)(encoder_t *self, int *path, floatval_t *ptr_score);
-
-    /* Level 2 (forward-backward). */
-    int (*partition_factor)(encoder_t *self, floatval_t *ptr_pf);
-
-    /* Level 3 (marginals). */
-    int (*objective_and_gradients)(encoder_t *self, floatval_t *f, floatval_t *g, floatval_t gain, floatval_t weight);
-
-    int (*save_model)(encoder_t *self, const char *filename, const floatval_t *w, logging_t *lg);
-
-    void (*release)(encoder_t *self);
-};
-
-/**
- * \defgroup crf1d_encode.c
- */
-/** @{ */
-
-encoder_t *crf1d_create_encoder();
-
-/** @} */
-
-void holdout_evaluation(
-    encoder_t *gm,
-    dataset_t *testset,
-    const floatval_t *w,
-    logging_t *lg);
-
-int crfsuite_train_lbfgs(
-    encoder_t *gm,
-    dataset_t *trainset,
-    dataset_t *testset,
-    crfsuite_params_t *params,
-    logging_t *lg,
-    floatval_t **ptr_w);
-
-void crfsuite_train_lbfgs_init(crfsuite_params_t *params);
-
-void crfsuite_train_averaged_perceptron_init(crfsuite_params_t *params);
-
-int crfsuite_train_averaged_perceptron(
-    encoder_t *gm,
-    dataset_t *trainset,
-    dataset_t *testset,
-    crfsuite_params_t *params,
-    logging_t *lg,
-    floatval_t **ptr_w);
-
-void crfsuite_train_l2sgd_init(crfsuite_params_t *params);
-
-int crfsuite_train_l2sgd(
-    encoder_t *gm,
-    dataset_t *trainset,
-    dataset_t *testset,
-    crfsuite_params_t *params,
-    logging_t *lg,
-    floatval_t **ptr_w);
-
-void crfsuite_train_passive_aggressive_init(crfsuite_params_t *params);
-
-int crfsuite_train_passive_aggressive(
-    encoder_t *gm,
-    dataset_t *trainset,
-    dataset_t *testset,
-    crfsuite_params_t *params,
-    logging_t *lg,
-    floatval_t **ptr_w);
-
-void crfsuite_train_arow_init(crfsuite_params_t *params);
-
-int crfsuite_train_arow(
-    encoder_t *gm,
-    dataset_t *trainset,
-    dataset_t *testset,
-    crfsuite_params_t *params,
-    logging_t *lg,
-    floatval_t **ptr_w);
-
-#endif /*__CRFSUITE_INTERNAL_H__*/
+/*
+ *      CRFsuite internal interface.
+ *
+ * Copyright (c) 2007-2010, Naoaki Okazaki
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the names of the authors nor the names of its contributors
+ *       may be used to endorse or promote products derived from this
+ *       software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+ * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/* $Id$ */
+
+#ifndef __CRFSUITE_INTERNAL_H__
+#define __CRFSUITE_INTERNAL_H__
+
+#include <crfsuite.h>
+#include "logging.h"
+
+enum
+{
+    FTYPE_NONE = 0, /**< Unselected. */
+    FTYPE_CRF1D,    /**< 1st-order tyad features. */
+    FTYPE_CRF1T,    /**< 1st-order triad features. */
+};
+
+enum
+{
+    TRAIN_NONE = 0,            /**< Unselected. */
+    TRAIN_LBFGS,               /**< L-BFGS batch training. */
+    TRAIN_L2SGD,               /**< Pegasos online training. */
+    TRAIN_AVERAGED_PERCEPTRON, /**< Averaged perceptron. */
+    TRAIN_PASSIVE_AGGRESSIVE,
+    TRAIN_AROW,
+};
+
+struct tag_crfsuite_train_internal;
+typedef struct tag_crfsuite_train_internal crfsuite_train_internal_t;
+
+struct tag_encoder;
+typedef struct tag_encoder encoder_t;
+
+typedef struct
+{
+    crfsuite_data_t *data;
+    int *perm;
+    int num_instances;
+} dataset_t;
+
+void dataset_init_trainset(dataset_t *ds, crfsuite_data_t *data, int holdout);
+void dataset_init_testset(dataset_t *ds, crfsuite_data_t *data, int holdout);
+void dataset_finish(dataset_t *ds);
+void dataset_shuffle(dataset_t *ds);
+crfsuite_instance_t *dataset_get(dataset_t *ds, int i);
+
+typedef void (*crfsuite_encoder_features_on_path_callback)(void *instance, int fid, floatval_t value);
+
+/**
+ * Internal data structure for
+ */
+struct tag_crfsuite_train_internal
+{
+    encoder_t *gm;             /** Interface to the graphical model. */
+    crfsuite_params_t *params; /**< Parameter interface. */
+    logging_t *lg;             /**< Logging interface. */
+    int feature_type;          /**< Feature type. */
+    int algorithm;             /**< Training algorithm. */
+};
+
+/**
+ * Interface for a graphical model.
+ */
+struct tag_encoder
+{
+    void *internal;
+
+    const floatval_t *w;
+    floatval_t scale;
+
+    dataset_t *ds;
+    const crfsuite_instance_t *inst;
+    int level;
+
+    int num_features;
+    int cap_items;
+
+    /**
+     * Exchanges options.
+     *  @param  self        The encoder instance.
+     *  @param  params      The parameter interface.
+     *  @param  mode        The direction of parameter exchange.
+     *  @return             A status code.
+     */
+    int (*exchange_options)(encoder_t *self, crfsuite_params_t *params, int mode);
+
+    /**
+     * Initializes the encoder with a training data set.
+     *  @param  self        The encoder instance.
+     *  @param  ds          The data set for training.
+     *  @param  lg          The logging interface.
+     *  @return             A status code.
+     */
+    int (*initialize)(encoder_t *self, dataset_t *ds, logging_t *lg);
+
+    /**
+     * Compute the objective value and gradients for the whole data set.
+     *  @param  self        The encoder instance.
+     *  @param  ds          The data set.
+     *  @param  w           The feature weights.
+     *  @param  f           The pointer to a floatval_t variable to which the
+     *                      objective value is stored by this function.
+     *  @param  g           The pointer to the array that receives gradients.
+     *  @return             A status code.
+     */
+    int (*objective_and_gradients_batch)(encoder_t *self, dataset_t *ds, const floatval_t *w, floatval_t *f, floatval_t *g);
+
+    int (*features_on_path)(encoder_t *self, const crfsuite_instance_t *inst, const int *path, crfsuite_encoder_features_on_path_callback func, void *instance);
+
+    /**
+     * Sets the feature weights (and their scale factor).
+     *  @param  self        The encoder instance.
+     *  @param  w           The array of feature weights.
+     *  @param  scale       The scale factor that should be applied to the
+     *                      feature weights.
+     *  @return             A status code.
+     */
+    int (*set_weights)(encoder_t *self, const floatval_t *w, floatval_t scale);
+
+    /* Instance-wise operations. */
+    int (*set_instance)(encoder_t *self, const crfsuite_instance_t *inst);
+
+    /* Level 0. */
+
+    /* Level 1 (feature weights). */
+    int (*score)(encoder_t *self, const int *path, floatval_t *ptr_score);
+    int (*viterbi)(encoder_t *self, int *path, floatval_t *ptr_score);
+
+    /* Level 2 (forward-backward). */
+    int (*partition_factor)(encoder_t *self, floatval_t *ptr_pf);
+
+    /* Level 3 (marginals). */
+    int (*objective_and_gradients)(encoder_t *self, floatval_t *f, floatval_t *g, floatval_t gain, floatval_t weight);
+
+    int (*save_model)(encoder_t *self, const char *filename, const floatval_t *w, logging_t *lg);
+
+    void (*release)(encoder_t *self);
+};
+
+/**
+ * \defgroup crf1d_encode.c
+ */
+/** @{ */
+
+encoder_t *crf1d_create_encoder();
+
+/** @} */
+
+void holdout_evaluation(
+    encoder_t *gm,
+    dataset_t *testset,
+    const floatval_t *w,
+    logging_t *lg);
+
+int crfsuite_train_lbfgs(
+    encoder_t *gm,
+    dataset_t *trainset,
+    dataset_t *testset,
+    crfsuite_params_t *params,
+    logging_t *lg,
+    floatval_t **ptr_w);
+
+void crfsuite_train_lbfgs_init(crfsuite_params_t *params);
+
+void crfsuite_train_averaged_perceptron_init(crfsuite_params_t *params);
+
+int crfsuite_train_averaged_perceptron(
+    encoder_t *gm,
+    dataset_t *trainset,
+    dataset_t *testset,
+    crfsuite_params_t *params,
+    logging_t *lg,
+    floatval_t **ptr_w);
+
+void crfsuite_train_l2sgd_init(crfsuite_params_t *params);
+
+int crfsuite_train_l2sgd(
+    encoder_t *gm,
+    dataset_t *trainset,
+    dataset_t *testset,
+    crfsuite_params_t *params,
+    logging_t *lg,
+    floatval_t **ptr_w);
+
+void crfsuite_train_passive_aggressive_init(crfsuite_params_t *params);
+
+int crfsuite_train_passive_aggressive(
+    encoder_t *gm,
+    dataset_t *trainset,
+    dataset_t *testset,
+    crfsuite_params_t *params,
+    logging_t *lg,
+    floatval_t **ptr_w);
+
+void crfsuite_train_arow_init(crfsuite_params_t *params);
+
+int crfsuite_train_arow(
+    encoder_t *gm,
+    dataset_t *trainset,
+    dataset_t *testset,
+    crfsuite_params_t *params,
+    logging_t *lg,
+    floatval_t **ptr_w);
+
+#endif /*__CRFSUITE_INTERNAL_H__*/
```

## chaine/_core/crfsuite/lib/crf/src/crfsuite_train.c

 * *Ordering differences only*

```diff
@@ -1,302 +1,302 @@
-/*
- *      Implementation of the training interface (crfsuite_trainer_t).
- *
- * Copyright (c) 2007-2010, Naoaki Okazaki
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the names of the authors nor the names of its contributors
- *       may be used to endorse or promote products derived from this
- *       software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
- * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-/* $Id$ */
-
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif /*HAVE_CONFIG_H*/
-
-#include <os.h>
-
-#include <stdlib.h>
-#include <string.h>
-
-#include <crfsuite.h>
-#include "crfsuite_internal.h"
-#include "params.h"
-#include "logging.h"
-#include "crf1d.h"
-
-static crfsuite_train_internal_t *crfsuite_train_new(int ftype, int algorithm)
-{
-    crfsuite_train_internal_t *tr = (crfsuite_train_internal_t *)calloc(1, sizeof(crfsuite_train_internal_t));
-    if (tr != NULL)
-    {
-        tr->lg = (logging_t *)calloc(1, sizeof(logging_t));
-        tr->params = params_create_instance();
-        tr->feature_type = ftype;
-        tr->algorithm = algorithm;
-
-        tr->gm = crf1d_create_encoder();
-        tr->gm->exchange_options(tr->gm, tr->params, 0);
-
-        /* Initialize parameters for the training algorithm. */
-        switch (algorithm)
-        {
-        case TRAIN_LBFGS:
-            crfsuite_train_lbfgs_init(tr->params);
-            break;
-        case TRAIN_L2SGD:
-            crfsuite_train_l2sgd_init(tr->params);
-            break;
-        case TRAIN_AVERAGED_PERCEPTRON:
-            crfsuite_train_averaged_perceptron_init(tr->params);
-            break;
-        case TRAIN_PASSIVE_AGGRESSIVE:
-            crfsuite_train_passive_aggressive_init(tr->params);
-            break;
-        case TRAIN_AROW:
-            crfsuite_train_arow_init(tr->params);
-            break;
-        }
-    }
-
-    return tr;
-}
-
-static void crfsuite_train_delete(crfsuite_trainer_t *self)
-{
-    crfsuite_train_internal_t *tr = (crfsuite_train_internal_t *)self->internal;
-    if (tr != NULL)
-    {
-        if (tr->gm != NULL)
-        {
-            tr->gm->release(tr->gm);
-        }
-        if (tr->params != NULL)
-        {
-            tr->params->release(tr->params);
-        }
-        free(tr->lg);
-        free(tr);
-    }
-    free(self);
-}
-
-static int crfsuite_train_addref(crfsuite_trainer_t *tr)
-{
-    return crfsuite_interlocked_increment(&tr->nref);
-}
-
-static int crfsuite_train_release(crfsuite_trainer_t *self)
-{
-    int count = crfsuite_interlocked_decrement(&self->nref);
-    if (count == 0)
-    {
-        crfsuite_train_delete(self);
-    }
-    return count;
-}
-
-static void crfsuite_train_set_message_callback(crfsuite_trainer_t *self, void *instance, crfsuite_logging_callback cbm)
-{
-    crfsuite_train_internal_t *tr = (crfsuite_train_internal_t *)self->internal;
-    tr->lg->func = cbm;
-    tr->lg->instance = instance;
-}
-
-static crfsuite_params_t *crfsuite_train_params(crfsuite_trainer_t *self)
-{
-    crfsuite_train_internal_t *tr = (crfsuite_train_internal_t *)self->internal;
-    crfsuite_params_t *params = tr->params;
-    params->addref(params);
-    return params;
-}
-
-static int crfsuite_train_train(
-    crfsuite_trainer_t *self,
-    const crfsuite_data_t *data,
-    const char *filename,
-    int holdout)
-{
-    char *algorithm = NULL;
-    crfsuite_train_internal_t *tr = (crfsuite_train_internal_t *)self->internal;
-    logging_t *lg = tr->lg;
-    encoder_t *gm = tr->gm;
-    floatval_t *w = NULL;
-    dataset_t trainset;
-    dataset_t testset;
-
-    /* Prepare the data set(s) for training (and holdout evaluation). */
-    dataset_init_trainset(&trainset, (crfsuite_data_t *)data, holdout);
-    if (0 <= holdout)
-    {
-        dataset_init_testset(&testset, (crfsuite_data_t *)data, holdout);
-    }
-
-    /* Set the training set to the CRF, and generate features. */
-    gm->exchange_options(gm, tr->params, -1);
-    gm->initialize(gm, &trainset, lg);
-
-    /* Call the training algorithm. */
-    switch (tr->algorithm)
-    {
-    case TRAIN_LBFGS:
-        crfsuite_train_lbfgs(
-            gm,
-            &trainset,
-            (holdout != -1 ? &testset : NULL),
-            tr->params,
-            lg,
-            &w);
-        break;
-    case TRAIN_L2SGD:
-        crfsuite_train_l2sgd(
-            gm,
-            &trainset,
-            (holdout != -1 ? &testset : NULL),
-            tr->params,
-            lg,
-            &w);
-        break;
-    case TRAIN_AVERAGED_PERCEPTRON:
-        crfsuite_train_averaged_perceptron(
-            gm,
-            &trainset,
-            (holdout != -1 ? &testset : NULL),
-            tr->params,
-            lg,
-            &w);
-        break;
-    case TRAIN_PASSIVE_AGGRESSIVE:
-        crfsuite_train_passive_aggressive(
-            gm,
-            &trainset,
-            (holdout != -1 ? &testset : NULL),
-            tr->params,
-            lg,
-            &w);
-        break;
-    case TRAIN_AROW:
-        crfsuite_train_arow(
-            gm,
-            &trainset,
-            (holdout != -1 ? &testset : NULL),
-            tr->params,
-            lg,
-            &w);
-        break;
-    }
-
-    /* Store the model file. */
-    if (filename != NULL && *filename != '\0')
-    {
-        gm->save_model(gm, filename, w, lg);
-    }
-
-    if (0 <= holdout)
-    {
-        dataset_finish(&testset);
-    }
-    dataset_finish(&trainset);
-    free(w);
-
-    return 0;
-}
-
-int crf1de_create_instance(const char *interface, void **ptr)
-{
-    int ftype = FTYPE_NONE;
-    int algorithm = TRAIN_NONE;
-
-    /* Check if the interface name begins with "train/". */
-    if (strncmp(interface, "train/", 6) != 0)
-    {
-        return 1;
-    }
-    interface += 6;
-
-    /* Obtain the feature type. */
-    if (strncmp(interface, "crf1d/", 6) == 0)
-    {
-        ftype = FTYPE_CRF1D;
-        interface += 6;
-    }
-    else
-    {
-        return 1;
-    }
-
-    /* Obtain the training algorithm. */
-    if (strcmp(interface, "lbfgs") == 0)
-    {
-        algorithm = TRAIN_LBFGS;
-    }
-    else if (strcmp(interface, "l2sgd") == 0)
-    {
-        algorithm = TRAIN_L2SGD;
-    }
-    else if (strcmp(interface, "averaged-perceptron") == 0)
-    {
-        algorithm = TRAIN_AVERAGED_PERCEPTRON;
-    }
-    else if (strcmp(interface, "passive-aggressive") == 0)
-    {
-        algorithm = TRAIN_PASSIVE_AGGRESSIVE;
-    }
-    else if (strcmp(interface, "arow") == 0)
-    {
-        algorithm = TRAIN_AROW;
-    }
-    else
-    {
-        return 1;
-    }
-
-    /* Create an instance. */
-    if (ftype != FTYPE_NONE && algorithm != TRAIN_NONE)
-    {
-        crfsuite_trainer_t *trainer = (crfsuite_trainer_t *)calloc(1, sizeof(crfsuite_trainer_t));
-        if (trainer != NULL)
-        {
-            trainer->internal = crfsuite_train_new(ftype, algorithm);
-            if (trainer->internal != NULL)
-            {
-                trainer->nref = 1;
-                trainer->addref = crfsuite_train_addref;
-                trainer->release = crfsuite_train_release;
-                trainer->params = crfsuite_train_params;
-                trainer->set_message_callback = crfsuite_train_set_message_callback;
-                trainer->train = crfsuite_train_train;
-
-                *ptr = trainer;
-                return 0;
-            }
-            else
-            {
-                free(trainer);
-                trainer = NULL;
-            }
-        }
-    }
-
-    return 1;
-}
+/*
+ *      Implementation of the training interface (crfsuite_trainer_t).
+ *
+ * Copyright (c) 2007-2010, Naoaki Okazaki
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the names of the authors nor the names of its contributors
+ *       may be used to endorse or promote products derived from this
+ *       software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+ * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/* $Id$ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif /*HAVE_CONFIG_H*/
+
+#include <os.h>
+
+#include <stdlib.h>
+#include <string.h>
+
+#include <crfsuite.h>
+#include "crfsuite_internal.h"
+#include "params.h"
+#include "logging.h"
+#include "crf1d.h"
+
+static crfsuite_train_internal_t *crfsuite_train_new(int ftype, int algorithm)
+{
+    crfsuite_train_internal_t *tr = (crfsuite_train_internal_t *)calloc(1, sizeof(crfsuite_train_internal_t));
+    if (tr != NULL)
+    {
+        tr->lg = (logging_t *)calloc(1, sizeof(logging_t));
+        tr->params = params_create_instance();
+        tr->feature_type = ftype;
+        tr->algorithm = algorithm;
+
+        tr->gm = crf1d_create_encoder();
+        tr->gm->exchange_options(tr->gm, tr->params, 0);
+
+        /* Initialize parameters for the training algorithm. */
+        switch (algorithm)
+        {
+        case TRAIN_LBFGS:
+            crfsuite_train_lbfgs_init(tr->params);
+            break;
+        case TRAIN_L2SGD:
+            crfsuite_train_l2sgd_init(tr->params);
+            break;
+        case TRAIN_AVERAGED_PERCEPTRON:
+            crfsuite_train_averaged_perceptron_init(tr->params);
+            break;
+        case TRAIN_PASSIVE_AGGRESSIVE:
+            crfsuite_train_passive_aggressive_init(tr->params);
+            break;
+        case TRAIN_AROW:
+            crfsuite_train_arow_init(tr->params);
+            break;
+        }
+    }
+
+    return tr;
+}
+
+static void crfsuite_train_delete(crfsuite_trainer_t *self)
+{
+    crfsuite_train_internal_t *tr = (crfsuite_train_internal_t *)self->internal;
+    if (tr != NULL)
+    {
+        if (tr->gm != NULL)
+        {
+            tr->gm->release(tr->gm);
+        }
+        if (tr->params != NULL)
+        {
+            tr->params->release(tr->params);
+        }
+        free(tr->lg);
+        free(tr);
+    }
+    free(self);
+}
+
+static int crfsuite_train_addref(crfsuite_trainer_t *tr)
+{
+    return crfsuite_interlocked_increment(&tr->nref);
+}
+
+static int crfsuite_train_release(crfsuite_trainer_t *self)
+{
+    int count = crfsuite_interlocked_decrement(&self->nref);
+    if (count == 0)
+    {
+        crfsuite_train_delete(self);
+    }
+    return count;
+}
+
+static void crfsuite_train_set_message_callback(crfsuite_trainer_t *self, void *instance, crfsuite_logging_callback cbm)
+{
+    crfsuite_train_internal_t *tr = (crfsuite_train_internal_t *)self->internal;
+    tr->lg->func = cbm;
+    tr->lg->instance = instance;
+}
+
+static crfsuite_params_t *crfsuite_train_params(crfsuite_trainer_t *self)
+{
+    crfsuite_train_internal_t *tr = (crfsuite_train_internal_t *)self->internal;
+    crfsuite_params_t *params = tr->params;
+    params->addref(params);
+    return params;
+}
+
+static int crfsuite_train_train(
+    crfsuite_trainer_t *self,
+    const crfsuite_data_t *data,
+    const char *filename,
+    int holdout)
+{
+    char *algorithm = NULL;
+    crfsuite_train_internal_t *tr = (crfsuite_train_internal_t *)self->internal;
+    logging_t *lg = tr->lg;
+    encoder_t *gm = tr->gm;
+    floatval_t *w = NULL;
+    dataset_t trainset;
+    dataset_t testset;
+
+    /* Prepare the data set(s) for training (and holdout evaluation). */
+    dataset_init_trainset(&trainset, (crfsuite_data_t *)data, holdout);
+    if (0 <= holdout)
+    {
+        dataset_init_testset(&testset, (crfsuite_data_t *)data, holdout);
+    }
+
+    /* Set the training set to the CRF, and generate features. */
+    gm->exchange_options(gm, tr->params, -1);
+    gm->initialize(gm, &trainset, lg);
+
+    /* Call the training algorithm. */
+    switch (tr->algorithm)
+    {
+    case TRAIN_LBFGS:
+        crfsuite_train_lbfgs(
+            gm,
+            &trainset,
+            (holdout != -1 ? &testset : NULL),
+            tr->params,
+            lg,
+            &w);
+        break;
+    case TRAIN_L2SGD:
+        crfsuite_train_l2sgd(
+            gm,
+            &trainset,
+            (holdout != -1 ? &testset : NULL),
+            tr->params,
+            lg,
+            &w);
+        break;
+    case TRAIN_AVERAGED_PERCEPTRON:
+        crfsuite_train_averaged_perceptron(
+            gm,
+            &trainset,
+            (holdout != -1 ? &testset : NULL),
+            tr->params,
+            lg,
+            &w);
+        break;
+    case TRAIN_PASSIVE_AGGRESSIVE:
+        crfsuite_train_passive_aggressive(
+            gm,
+            &trainset,
+            (holdout != -1 ? &testset : NULL),
+            tr->params,
+            lg,
+            &w);
+        break;
+    case TRAIN_AROW:
+        crfsuite_train_arow(
+            gm,
+            &trainset,
+            (holdout != -1 ? &testset : NULL),
+            tr->params,
+            lg,
+            &w);
+        break;
+    }
+
+    /* Store the model file. */
+    if (filename != NULL && *filename != '\0')
+    {
+        gm->save_model(gm, filename, w, lg);
+    }
+
+    if (0 <= holdout)
+    {
+        dataset_finish(&testset);
+    }
+    dataset_finish(&trainset);
+    free(w);
+
+    return 0;
+}
+
+int crf1de_create_instance(const char *interface, void **ptr)
+{
+    int ftype = FTYPE_NONE;
+    int algorithm = TRAIN_NONE;
+
+    /* Check if the interface name begins with "train/". */
+    if (strncmp(interface, "train/", 6) != 0)
+    {
+        return 1;
+    }
+    interface += 6;
+
+    /* Obtain the feature type. */
+    if (strncmp(interface, "crf1d/", 6) == 0)
+    {
+        ftype = FTYPE_CRF1D;
+        interface += 6;
+    }
+    else
+    {
+        return 1;
+    }
+
+    /* Obtain the training algorithm. */
+    if (strcmp(interface, "lbfgs") == 0)
+    {
+        algorithm = TRAIN_LBFGS;
+    }
+    else if (strcmp(interface, "l2sgd") == 0)
+    {
+        algorithm = TRAIN_L2SGD;
+    }
+    else if (strcmp(interface, "averaged-perceptron") == 0)
+    {
+        algorithm = TRAIN_AVERAGED_PERCEPTRON;
+    }
+    else if (strcmp(interface, "passive-aggressive") == 0)
+    {
+        algorithm = TRAIN_PASSIVE_AGGRESSIVE;
+    }
+    else if (strcmp(interface, "arow") == 0)
+    {
+        algorithm = TRAIN_AROW;
+    }
+    else
+    {
+        return 1;
+    }
+
+    /* Create an instance. */
+    if (ftype != FTYPE_NONE && algorithm != TRAIN_NONE)
+    {
+        crfsuite_trainer_t *trainer = (crfsuite_trainer_t *)calloc(1, sizeof(crfsuite_trainer_t));
+        if (trainer != NULL)
+        {
+            trainer->internal = crfsuite_train_new(ftype, algorithm);
+            if (trainer->internal != NULL)
+            {
+                trainer->nref = 1;
+                trainer->addref = crfsuite_train_addref;
+                trainer->release = crfsuite_train_release;
+                trainer->params = crfsuite_train_params;
+                trainer->set_message_callback = crfsuite_train_set_message_callback;
+                trainer->train = crfsuite_train_train;
+
+                *ptr = trainer;
+                return 0;
+            }
+            else
+            {
+                free(trainer);
+                trainer = NULL;
+            }
+        }
+    }
+
+    return 1;
+}
```

## chaine/_core/crfsuite/lib/crf/src/dataset.c

 * *Ordering differences only*

```diff
@@ -1,115 +1,115 @@
-/*
- *      Implementation for data sets (dataset_t).
- *
- * Copyright (c) 2007-2010, Naoaki Okazaki
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the names of the authors nor the names of its contributors
- *       may be used to endorse or promote products derived from this
- *       software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
- * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-/* $Id$ */
-
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif /*HAVE_CONFIG_H*/
-
-#include <os.h>
-
-#include <stdlib.h>
-#include <crfsuite.h>
-#include "crfsuite_internal.h"
-
-void dataset_init_trainset(dataset_t *ds, crfsuite_data_t *data, int holdout)
-{
-    int i, n = 0;
-
-    for (i = 0; i < data->num_instances; ++i)
-    {
-        if (data->instances[i].group != holdout)
-        {
-            ++n;
-        }
-    }
-
-    ds->data = data;
-    ds->num_instances = n;
-    ds->perm = (int *)malloc(sizeof(int) * n);
-
-    n = 0;
-    for (i = 0; i < data->num_instances; ++i)
-    {
-        if (data->instances[i].group != holdout)
-        {
-            ds->perm[n++] = i;
-        }
-    }
-}
-
-void dataset_init_testset(dataset_t *ds, crfsuite_data_t *data, int holdout)
-{
-    int i, n = 0;
-
-    for (i = 0; i < data->num_instances; ++i)
-    {
-        if (data->instances[i].group == holdout)
-        {
-            ++n;
-        }
-    }
-
-    ds->data = data;
-    ds->num_instances = n;
-    ds->perm = (int *)malloc(sizeof(int) * n);
-
-    n = 0;
-    for (i = 0; i < data->num_instances; ++i)
-    {
-        if (data->instances[i].group == holdout)
-        {
-            ds->perm[n++] = i;
-        }
-    }
-}
-
-void dataset_finish(dataset_t *ds)
-{
-    free(ds->perm);
-}
-
-void dataset_shuffle(dataset_t *ds)
-{
-    int i;
-    for (i = 0; i < ds->num_instances; ++i)
-    {
-        int j = rand() % ds->num_instances;
-        int tmp = ds->perm[j];
-        ds->perm[j] = ds->perm[i];
-        ds->perm[i] = tmp;
-    }
-}
-
-crfsuite_instance_t *dataset_get(dataset_t *ds, int i)
-{
-    return &ds->data->instances[ds->perm[i]];
-}
+/*
+ *      Implementation for data sets (dataset_t).
+ *
+ * Copyright (c) 2007-2010, Naoaki Okazaki
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the names of the authors nor the names of its contributors
+ *       may be used to endorse or promote products derived from this
+ *       software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+ * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/* $Id$ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif /*HAVE_CONFIG_H*/
+
+#include <os.h>
+
+#include <stdlib.h>
+#include <crfsuite.h>
+#include "crfsuite_internal.h"
+
+void dataset_init_trainset(dataset_t *ds, crfsuite_data_t *data, int holdout)
+{
+    int i, n = 0;
+
+    for (i = 0; i < data->num_instances; ++i)
+    {
+        if (data->instances[i].group != holdout)
+        {
+            ++n;
+        }
+    }
+
+    ds->data = data;
+    ds->num_instances = n;
+    ds->perm = (int *)malloc(sizeof(int) * n);
+
+    n = 0;
+    for (i = 0; i < data->num_instances; ++i)
+    {
+        if (data->instances[i].group != holdout)
+        {
+            ds->perm[n++] = i;
+        }
+    }
+}
+
+void dataset_init_testset(dataset_t *ds, crfsuite_data_t *data, int holdout)
+{
+    int i, n = 0;
+
+    for (i = 0; i < data->num_instances; ++i)
+    {
+        if (data->instances[i].group == holdout)
+        {
+            ++n;
+        }
+    }
+
+    ds->data = data;
+    ds->num_instances = n;
+    ds->perm = (int *)malloc(sizeof(int) * n);
+
+    n = 0;
+    for (i = 0; i < data->num_instances; ++i)
+    {
+        if (data->instances[i].group == holdout)
+        {
+            ds->perm[n++] = i;
+        }
+    }
+}
+
+void dataset_finish(dataset_t *ds)
+{
+    free(ds->perm);
+}
+
+void dataset_shuffle(dataset_t *ds)
+{
+    int i;
+    for (i = 0; i < ds->num_instances; ++i)
+    {
+        int j = rand() % ds->num_instances;
+        int tmp = ds->perm[j];
+        ds->perm[j] = ds->perm[i];
+        ds->perm[i] = tmp;
+    }
+}
+
+crfsuite_instance_t *dataset_get(dataset_t *ds, int i)
+{
+    return &ds->data->instances[ds->perm[i]];
+}
```

## chaine/_core/crfsuite/lib/crf/src/dictionary.c

 * *Ordering differences only*

```diff
@@ -1,127 +1,127 @@
-/*
- *      Implementation of dictionary.
- *
- * Copyright (c) 2007-2010, Naoaki Okazaki
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the names of the authors nor the names of its contributors
- *       may be used to endorse or promote products derived from this
- *       software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
- * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-/* $Id$ */
-
-#include <os.h>
-
-#include <stdlib.h>
-#include <string.h>
-
-#include <crfsuite.h>
-#include "quark.h"
-
-static int dictionary_addref(crfsuite_dictionary_t *dic)
-{
-    return crfsuite_interlocked_increment(&dic->nref);
-}
-
-static int dictionary_release(crfsuite_dictionary_t *dic)
-{
-    int count = crfsuite_interlocked_decrement(&dic->nref);
-    if (count == 0)
-    {
-        quark_t *qrk = (quark_t *)dic->internal;
-        quark_delete(qrk);
-        free(dic);
-    }
-    return count;
-}
-
-static int dictionary_get(crfsuite_dictionary_t *dic, const char *str)
-{
-    quark_t *qrk = (quark_t *)dic->internal;
-    return quark_get(qrk, str);
-}
-
-static int dictionary_to_id(crfsuite_dictionary_t *dic, const char *str)
-{
-    quark_t *qrk = (quark_t *)dic->internal;
-    return quark_to_id(qrk, str);
-}
-
-static int dictionary_to_string(crfsuite_dictionary_t *dic, int id, char const **pstr)
-{
-    quark_t *qrk = (quark_t *)dic->internal;
-    const char *str = quark_to_string(qrk, id);
-    if (str != NULL)
-    {
-        char *dst = (char *)malloc(strlen(str) + 1);
-        if (dst)
-        {
-            strcpy(dst, str);
-            *pstr = dst;
-            return 0;
-        }
-    }
-    return 1;
-}
-
-static int dictionary_num(crfsuite_dictionary_t *dic)
-{
-    quark_t *qrk = (quark_t *)dic->internal;
-    return quark_num(qrk);
-}
-
-static void dictionary_free(crfsuite_dictionary_t *dic, const char *str)
-{
-    free((char *)str);
-}
-
-int crfsuite_dictionary_create_instance(const char *interface, void **ptr)
-{
-    if (strcmp(interface, "dictionary") == 0)
-    {
-        crfsuite_dictionary_t *dic = (crfsuite_dictionary_t *)calloc(1, sizeof(crfsuite_dictionary_t));
-
-        if (dic != NULL)
-        {
-            dic->internal = quark_new();
-            dic->nref = 1;
-            dic->addref = dictionary_addref;
-            dic->release = dictionary_release;
-            dic->get = dictionary_get;
-            dic->to_id = dictionary_to_id;
-            dic->to_string = dictionary_to_string;
-            dic->num = dictionary_num;
-            dic->free = dictionary_free;
-            *ptr = dic;
-            return 0;
-        }
-        else
-        {
-            return -1;
-        }
-    }
-    else
-    {
-        return 1;
-    }
-}
+/*
+ *      Implementation of dictionary.
+ *
+ * Copyright (c) 2007-2010, Naoaki Okazaki
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the names of the authors nor the names of its contributors
+ *       may be used to endorse or promote products derived from this
+ *       software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+ * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/* $Id$ */
+
+#include <os.h>
+
+#include <stdlib.h>
+#include <string.h>
+
+#include <crfsuite.h>
+#include "quark.h"
+
+static int dictionary_addref(crfsuite_dictionary_t *dic)
+{
+    return crfsuite_interlocked_increment(&dic->nref);
+}
+
+static int dictionary_release(crfsuite_dictionary_t *dic)
+{
+    int count = crfsuite_interlocked_decrement(&dic->nref);
+    if (count == 0)
+    {
+        quark_t *qrk = (quark_t *)dic->internal;
+        quark_delete(qrk);
+        free(dic);
+    }
+    return count;
+}
+
+static int dictionary_get(crfsuite_dictionary_t *dic, const char *str)
+{
+    quark_t *qrk = (quark_t *)dic->internal;
+    return quark_get(qrk, str);
+}
+
+static int dictionary_to_id(crfsuite_dictionary_t *dic, const char *str)
+{
+    quark_t *qrk = (quark_t *)dic->internal;
+    return quark_to_id(qrk, str);
+}
+
+static int dictionary_to_string(crfsuite_dictionary_t *dic, int id, char const **pstr)
+{
+    quark_t *qrk = (quark_t *)dic->internal;
+    const char *str = quark_to_string(qrk, id);
+    if (str != NULL)
+    {
+        char *dst = (char *)malloc(strlen(str) + 1);
+        if (dst)
+        {
+            strcpy(dst, str);
+            *pstr = dst;
+            return 0;
+        }
+    }
+    return 1;
+}
+
+static int dictionary_num(crfsuite_dictionary_t *dic)
+{
+    quark_t *qrk = (quark_t *)dic->internal;
+    return quark_num(qrk);
+}
+
+static void dictionary_free(crfsuite_dictionary_t *dic, const char *str)
+{
+    free((char *)str);
+}
+
+int crfsuite_dictionary_create_instance(const char *interface, void **ptr)
+{
+    if (strcmp(interface, "dictionary") == 0)
+    {
+        crfsuite_dictionary_t *dic = (crfsuite_dictionary_t *)calloc(1, sizeof(crfsuite_dictionary_t));
+
+        if (dic != NULL)
+        {
+            dic->internal = quark_new();
+            dic->nref = 1;
+            dic->addref = dictionary_addref;
+            dic->release = dictionary_release;
+            dic->get = dictionary_get;
+            dic->to_id = dictionary_to_id;
+            dic->to_string = dictionary_to_string;
+            dic->num = dictionary_num;
+            dic->free = dictionary_free;
+            *ptr = dic;
+            return 0;
+        }
+        else
+        {
+            return -1;
+        }
+    }
+    else
+    {
+        return 1;
+    }
+}
```

## chaine/_core/crfsuite/lib/crf/src/holdout.c

 * *Ordering differences only*

```diff
@@ -1,83 +1,83 @@
-/*
- *      Holdout evaluation.
- *
- * Copyright (c) 2007-2010, Naoaki Okazaki
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the names of the authors nor the names of its contributors
- *       may be used to endorse or promote products derived from this
- *       software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
- * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-/* $Id$ */
-
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif /*HAVE_CONFIG_H*/
-
-#include <os.h>
-
-#include <stdlib.h>
-#include <crfsuite.h>
-#include "crfsuite_internal.h"
-#include "logging.h"
-
-void holdout_evaluation(
-    encoder_t *gm,
-    dataset_t *ds,
-    const floatval_t *w,
-    logging_t *lg)
-{
-    int i;
-    crfsuite_evaluation_t eval;
-    const int N = ds->num_instances;
-    int *viterbi = NULL;
-    int max_length = 0;
-
-    /* Initialize the evaluation table. */
-    crfsuite_evaluation_init(&eval, ds->data->labels->num(ds->data->labels));
-
-    gm->set_weights(gm, w, 1.);
-
-    for (i = 0; i < N; ++i)
-    {
-        floatval_t score;
-        const crfsuite_instance_t *inst = dataset_get(ds, i);
-
-        if (max_length < inst->num_items)
-        {
-            free(viterbi);
-            viterbi = (int *)malloc(sizeof(int) * inst->num_items);
-        }
-
-        gm->set_instance(gm, inst);
-        gm->viterbi(gm, viterbi, &score);
-
-        crfsuite_evaluation_accmulate(&eval, inst->labels, viterbi, inst->num_items);
-    }
-
-    /* Report the performance. */
-    crfsuite_evaluation_finalize(&eval);
-    crfsuite_evaluation_output(&eval, ds->data->labels, lg->func, lg->instance);
-    if (viterbi)
-        free(viterbi);
-}
+/*
+ *      Holdout evaluation.
+ *
+ * Copyright (c) 2007-2010, Naoaki Okazaki
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the names of the authors nor the names of its contributors
+ *       may be used to endorse or promote products derived from this
+ *       software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+ * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/* $Id$ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif /*HAVE_CONFIG_H*/
+
+#include <os.h>
+
+#include <stdlib.h>
+#include <crfsuite.h>
+#include "crfsuite_internal.h"
+#include "logging.h"
+
+void holdout_evaluation(
+    encoder_t *gm,
+    dataset_t *ds,
+    const floatval_t *w,
+    logging_t *lg)
+{
+    int i;
+    crfsuite_evaluation_t eval;
+    const int N = ds->num_instances;
+    int *viterbi = NULL;
+    int max_length = 0;
+
+    /* Initialize the evaluation table. */
+    crfsuite_evaluation_init(&eval, ds->data->labels->num(ds->data->labels));
+
+    gm->set_weights(gm, w, 1.);
+
+    for (i = 0; i < N; ++i)
+    {
+        floatval_t score;
+        const crfsuite_instance_t *inst = dataset_get(ds, i);
+
+        if (max_length < inst->num_items)
+        {
+            free(viterbi);
+            viterbi = (int *)malloc(sizeof(int) * inst->num_items);
+        }
+
+        gm->set_instance(gm, inst);
+        gm->viterbi(gm, viterbi, &score);
+
+        crfsuite_evaluation_accmulate(&eval, inst->labels, viterbi, inst->num_items);
+    }
+
+    /* Report the performance. */
+    crfsuite_evaluation_finalize(&eval);
+    crfsuite_evaluation_output(&eval, ds->data->labels, lg->func, lg->instance);
+    if (viterbi)
+        free(viterbi);
+}
```

## chaine/_core/crfsuite/lib/crf/src/json.c

 * *Ordering differences only*

```diff
@@ -1,1497 +1,1497 @@
-/*
-  Copyright (C) 2011 Joseph A. Adams (joeyadams3.14159@gmail.com)
-  All rights reserved.
-
-  Permission is hereby granted, free of charge, to any person obtaining a copy
-  of this software and associated documentation files (the "Software"), to deal
-  in the Software without restriction, including without limitation the rights
-  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-  copies of the Software, and to permit persons to whom the Software is
-  furnished to do so, subject to the following conditions:
-
-  The above copyright notice and this permission notice shall be included in
-  all copies or substantial portions of the Software.
-
-  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
-  THE SOFTWARE.
-*/
-
-#include "json.h"
-
-#include <assert.h>
-#include <stdint.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-
-#define out_of_memory()                      \
-	do                                       \
-	{                                        \
-		fprintf(stderr, "Out of memory.\n"); \
-		exit(EXIT_FAILURE);                  \
-	} while (0)
-
-/* Sadly, strdup is not portable. */
-static char *json_strdup(const char *str)
-{
-	char *ret = (char *)malloc(strlen(str) + 1);
-	if (ret == NULL)
-		out_of_memory();
-	strcpy(ret, str);
-	return ret;
-}
-
-/* String buffer */
-
-typedef struct
-{
-	char *cur;
-	char *end;
-	char *start;
-} SB;
-
-static void sb_init(SB *sb)
-{
-	sb->start = (char *)malloc(17);
-	if (sb->start == NULL)
-		out_of_memory();
-	sb->cur = sb->start;
-	sb->end = sb->start + 16;
-}
-
-/* sb and need may be evaluated multiple times. */
-#define sb_need(sb, need)                   \
-	do                                      \
-	{                                       \
-		if ((sb)->end - (sb)->cur < (need)) \
-			sb_grow(sb, need);              \
-	} while (0)
-
-static void sb_grow(SB *sb, int need)
-{
-	size_t length = sb->cur - sb->start;
-	size_t alloc = sb->end - sb->start;
-
-	do
-	{
-		alloc *= 2;
-	} while (alloc < length + need);
-
-	sb->start = (char *)realloc(sb->start, alloc + 1);
-	if (sb->start == NULL)
-		out_of_memory();
-	sb->cur = sb->start + length;
-	sb->end = sb->start + alloc;
-}
-
-static void sb_put(SB *sb, const char *bytes, int count)
-{
-	sb_need(sb, count);
-	memcpy(sb->cur, bytes, count);
-	sb->cur += count;
-}
-
-#define sb_putc(sb, c)              \
-	do                              \
-	{                               \
-		if ((sb)->cur >= (sb)->end) \
-			sb_grow(sb, 1);         \
-		*(sb)->cur++ = (c);         \
-	} while (0)
-
-static void sb_puts(SB *sb, const char *str)
-{
-	sb_put(sb, str, strlen(str));
-}
-
-static char *sb_finish(SB *sb)
-{
-	*sb->cur = 0;
-	assert(sb->start <= sb->cur && strlen(sb->start) == (size_t)(sb->cur - sb->start));
-	return sb->start;
-}
-
-static void sb_free(SB *sb)
-{
-	free(sb->start);
-}
-
-/*
- * Unicode helper functions
- *
- * These are taken from the ccan/charset module and customized a bit.
- * Putting them here means the compiler can (choose to) inline them,
- * and it keeps ccan/json from having a dependency.
- */
-
-/*
- * Type for Unicode codepoints.
- * We need our own because wchar_t might be 16 bits.
- */
-typedef uint32_t uchar_t;
-
-/*
- * Validate a single UTF-8 character starting at @s.
- * The string must be null-terminated.
- *
- * If it's valid, return its length (1 thru 4).
- * If it's invalid or clipped, return 0.
- *
- * This function implements the syntax given in RFC3629, which is
- * the same as that given in The Unicode Standard, Version 6.0.
- *
- * It has the following properties:
- *
- *  * All codepoints U+0000..U+10FFFF may be encoded,
- *    except for U+D800..U+DFFF, which are reserved
- *    for UTF-16 surrogate pair encoding.
- *  * UTF-8 byte sequences longer than 4 bytes are not permitted,
- *    as they exceed the range of Unicode.
- *  * The sixty-six Unicode "non-characters" are permitted
- *    (namely, U+FDD0..U+FDEF, U+xxFFFE, and U+xxFFFF).
- */
-static int utf8_validate_cz(const char *s)
-{
-	unsigned char c = *s++;
-
-	if (c <= 0x7F)
-	{ /* 00..7F */
-		return 1;
-	}
-	else if (c <= 0xC1)
-	{ /* 80..C1 */
-		/* Disallow overlong 2-byte sequence. */
-		return 0;
-	}
-	else if (c <= 0xDF)
-	{ /* C2..DF */
-		/* Make sure subsequent byte is in the range 0x80..0xBF. */
-		if (((unsigned char)*s++ & 0xC0) != 0x80)
-			return 0;
-
-		return 2;
-	}
-	else if (c <= 0xEF)
-	{ /* E0..EF */
-		/* Disallow overlong 3-byte sequence. */
-		if (c == 0xE0 && (unsigned char)*s < 0xA0)
-			return 0;
-
-		/* Disallow U+D800..U+DFFF. */
-		if (c == 0xED && (unsigned char)*s > 0x9F)
-			return 0;
-
-		/* Make sure subsequent bytes are in the range 0x80..0xBF. */
-		if (((unsigned char)*s++ & 0xC0) != 0x80)
-			return 0;
-		if (((unsigned char)*s++ & 0xC0) != 0x80)
-			return 0;
-
-		return 3;
-	}
-	else if (c <= 0xF4)
-	{ /* F0..F4 */
-		/* Disallow overlong 4-byte sequence. */
-		if (c == 0xF0 && (unsigned char)*s < 0x90)
-			return 0;
-
-		/* Disallow codepoints beyond U+10FFFF. */
-		if (c == 0xF4 && (unsigned char)*s > 0x8F)
-			return 0;
-
-		/* Make sure subsequent bytes are in the range 0x80..0xBF. */
-		if (((unsigned char)*s++ & 0xC0) != 0x80)
-			return 0;
-		if (((unsigned char)*s++ & 0xC0) != 0x80)
-			return 0;
-		if (((unsigned char)*s++ & 0xC0) != 0x80)
-			return 0;
-
-		return 4;
-	}
-	else
-	{ /* F5..FF */
-		return 0;
-	}
-}
-
-/* Validate a null-terminated UTF-8 string. */
-static bool utf8_validate(const char *s)
-{
-	int len;
-
-	for (; *s != 0; s += len)
-	{
-		len = utf8_validate_cz(s);
-		if (len == 0)
-			return false;
-	}
-
-	return true;
-}
-
-/*
- * Read a single UTF-8 character starting at @s,
- * returning the length, in bytes, of the character read.
- *
- * This function assumes input is valid UTF-8,
- * and that there are enough characters in front of @s.
- */
-static int utf8_read_char(const char *s, uchar_t *out)
-{
-	const unsigned char *c = (const unsigned char *)s;
-
-	assert(utf8_validate_cz(s));
-
-	if (c[0] <= 0x7F)
-	{
-		/* 00..7F */
-		*out = c[0];
-		return 1;
-	}
-	else if (c[0] <= 0xDF)
-	{
-		/* C2..DF (unless input is invalid) */
-		*out = ((uchar_t)c[0] & 0x1F) << 6 |
-			   ((uchar_t)c[1] & 0x3F);
-		return 2;
-	}
-	else if (c[0] <= 0xEF)
-	{
-		/* E0..EF */
-		*out = ((uchar_t)c[0] & 0xF) << 12 |
-			   ((uchar_t)c[1] & 0x3F) << 6 |
-			   ((uchar_t)c[2] & 0x3F);
-		return 3;
-	}
-	else
-	{
-		/* F0..F4 (unless input is invalid) */
-		*out = ((uchar_t)c[0] & 0x7) << 18 |
-			   ((uchar_t)c[1] & 0x3F) << 12 |
-			   ((uchar_t)c[2] & 0x3F) << 6 |
-			   ((uchar_t)c[3] & 0x3F);
-		return 4;
-	}
-}
-
-/*
- * Write a single UTF-8 character to @s,
- * returning the length, in bytes, of the character written.
- *
- * @unicode must be U+0000..U+10FFFF, but not U+D800..U+DFFF.
- *
- * This function will write up to 4 bytes to @out.
- */
-static int utf8_write_char(uchar_t unicode, char *out)
-{
-	unsigned char *o = (unsigned char *)out;
-
-	assert(unicode <= 0x10FFFF && !(unicode >= 0xD800 && unicode <= 0xDFFF));
-
-	if (unicode <= 0x7F)
-	{
-		/* U+0000..U+007F */
-		*o++ = unicode;
-		return 1;
-	}
-	else if (unicode <= 0x7FF)
-	{
-		/* U+0080..U+07FF */
-		*o++ = 0xC0 | unicode >> 6;
-		*o++ = 0x80 | (unicode & 0x3F);
-		return 2;
-	}
-	else if (unicode <= 0xFFFF)
-	{
-		/* U+0800..U+FFFF */
-		*o++ = 0xE0 | unicode >> 12;
-		*o++ = 0x80 | (unicode >> 6 & 0x3F);
-		*o++ = 0x80 | (unicode & 0x3F);
-		return 3;
-	}
-	else
-	{
-		/* U+10000..U+10FFFF */
-		*o++ = 0xF0 | unicode >> 18;
-		*o++ = 0x80 | (unicode >> 12 & 0x3F);
-		*o++ = 0x80 | (unicode >> 6 & 0x3F);
-		*o++ = 0x80 | (unicode & 0x3F);
-		return 4;
-	}
-}
-
-/*
- * Compute the Unicode codepoint of a UTF-16 surrogate pair.
- *
- * @uc should be 0xD800..0xDBFF, and @lc should be 0xDC00..0xDFFF.
- * If they aren't, this function returns false.
- */
-static bool from_surrogate_pair(uint16_t uc, uint16_t lc, uchar_t *unicode)
-{
-	if (uc >= 0xD800 && uc <= 0xDBFF && lc >= 0xDC00 && lc <= 0xDFFF)
-	{
-		*unicode = 0x10000 + ((((uchar_t)uc & 0x3FF) << 10) | (lc & 0x3FF));
-		return true;
-	}
-	else
-	{
-		return false;
-	}
-}
-
-/*
- * Construct a UTF-16 surrogate pair given a Unicode codepoint.
- *
- * @unicode must be U+10000..U+10FFFF.
- */
-static void to_surrogate_pair(uchar_t unicode, uint16_t *uc, uint16_t *lc)
-{
-	uchar_t n;
-
-	assert(unicode >= 0x10000 && unicode <= 0x10FFFF);
-
-	n = unicode - 0x10000;
-	*uc = ((n >> 10) & 0x3FF) | 0xD800;
-	*lc = (n & 0x3FF) | 0xDC00;
-}
-
-#define is_space(c) ((c) == '\t' || (c) == '\n' || (c) == '\r' || (c) == ' ')
-#define is_digit(c) ((c) >= '0' && (c) <= '9')
-
-static bool parse_value(const char **sp, JsonNode **out);
-static bool parse_string(const char **sp, char **out);
-static bool parse_number(const char **sp, double *out);
-static bool parse_array(const char **sp, JsonNode **out);
-static bool parse_object(const char **sp, JsonNode **out);
-static bool parse_hex16(const char **sp, uint16_t *out);
-
-static bool expect_literal(const char **sp, const char *str);
-static void skip_space(const char **sp);
-
-static void emit_value(SB *out, const JsonNode *node);
-static void emit_value_indented(SB *out, const JsonNode *node, const char *space, int indent_level);
-static void emit_string(SB *out, const char *str);
-static void emit_number(SB *out, double num);
-static void emit_array(SB *out, const JsonNode *array);
-static void emit_array_indented(SB *out, const JsonNode *array, const char *space, int indent_level);
-static void emit_object(SB *out, const JsonNode *object);
-static void emit_object_indented(SB *out, const JsonNode *object, const char *space, int indent_level);
-
-static int write_hex16(char *out, uint16_t val);
-
-static JsonNode *mknode(JsonTag tag);
-static void append_node(JsonNode *parent, JsonNode *child);
-static void prepend_node(JsonNode *parent, JsonNode *child);
-static void append_member(JsonNode *object, char *key, JsonNode *value);
-
-/* Assertion-friendly validity checks */
-static bool tag_is_valid(unsigned int tag);
-static bool number_is_valid(const char *num);
-
-JsonNode *json_decode(const char *json)
-{
-	const char *s = json;
-	JsonNode *ret;
-
-	skip_space(&s);
-	if (!parse_value(&s, &ret))
-		return NULL;
-
-	skip_space(&s);
-	if (*s != 0)
-	{
-		json_delete(ret);
-		return NULL;
-	}
-
-	return ret;
-}
-
-char *json_encode(const JsonNode *node)
-{
-	return json_stringify(node, NULL);
-}
-
-char *json_encode_string(const char *str)
-{
-	SB sb;
-	sb_init(&sb);
-
-	emit_string(&sb, str);
-
-	return sb_finish(&sb);
-}
-
-char *json_stringify(const JsonNode *node, const char *space)
-{
-	SB sb;
-	sb_init(&sb);
-
-	if (space != NULL)
-		emit_value_indented(&sb, node, space, 0);
-	else
-		emit_value(&sb, node);
-
-	return sb_finish(&sb);
-}
-
-void json_delete(JsonNode *node)
-{
-	if (node != NULL)
-	{
-		json_remove_from_parent(node);
-
-		switch (node->tag)
-		{
-		case JSON_STRING:
-			free(node->string_);
-			break;
-		case JSON_ARRAY:
-		case JSON_OBJECT:
-		{
-			JsonNode *child, *next;
-			for (child = node->children.head; child != NULL; child = next)
-			{
-				next = child->next;
-				json_delete(child);
-			}
-			break;
-		}
-		default:;
-		}
-
-		free(node);
-	}
-}
-
-bool json_validate(const char *json)
-{
-	const char *s = json;
-
-	skip_space(&s);
-	if (!parse_value(&s, NULL))
-		return false;
-
-	skip_space(&s);
-	if (*s != 0)
-		return false;
-
-	return true;
-}
-
-JsonNode *json_find_element(JsonNode *array, int index)
-{
-	JsonNode *element;
-	int i = 0;
-
-	if (array == NULL || array->tag != JSON_ARRAY)
-		return NULL;
-
-	json_foreach(element, array)
-	{
-		if (i == index)
-			return element;
-		i++;
-	}
-
-	return NULL;
-}
-
-JsonNode *json_find_member(JsonNode *object, const char *name)
-{
-	JsonNode *member;
-
-	if (object == NULL || object->tag != JSON_OBJECT)
-		return NULL;
-
-	json_foreach(member, object) if (strcmp(member->key, name) == 0) return member;
-
-	return NULL;
-}
-
-JsonNode *json_first_child(const JsonNode *node)
-{
-	if (node != NULL && (node->tag == JSON_ARRAY || node->tag == JSON_OBJECT))
-		return node->children.head;
-	return NULL;
-}
-
-static JsonNode *mknode(JsonTag tag)
-{
-	JsonNode *ret = (JsonNode *)calloc(1, sizeof(JsonNode));
-	if (ret == NULL)
-		out_of_memory();
-	ret->tag = tag;
-	return ret;
-}
-
-JsonNode *json_mknull(void)
-{
-	return mknode(JSON_NULL);
-}
-
-JsonNode *json_mkbool(bool b)
-{
-	JsonNode *ret = mknode(JSON_BOOL);
-	ret->bool_ = b;
-	return ret;
-}
-
-static JsonNode *mkstring(char *s)
-{
-	JsonNode *ret = mknode(JSON_STRING);
-	ret->string_ = s;
-	return ret;
-}
-
-JsonNode *json_mkstring(const char *s)
-{
-	return mkstring(json_strdup(s));
-}
-
-JsonNode *json_mknumber(double n)
-{
-	JsonNode *node = mknode(JSON_NUMBER);
-	node->number_ = n;
-	return node;
-}
-
-JsonNode *json_mkarray(void)
-{
-	return mknode(JSON_ARRAY);
-}
-
-JsonNode *json_mkobject(void)
-{
-	return mknode(JSON_OBJECT);
-}
-
-static void append_node(JsonNode *parent, JsonNode *child)
-{
-	child->parent = parent;
-	child->prev = parent->children.tail;
-	child->next = NULL;
-
-	if (parent->children.tail != NULL)
-		parent->children.tail->next = child;
-	else
-		parent->children.head = child;
-	parent->children.tail = child;
-}
-
-static void prepend_node(JsonNode *parent, JsonNode *child)
-{
-	child->parent = parent;
-	child->prev = NULL;
-	child->next = parent->children.head;
-
-	if (parent->children.head != NULL)
-		parent->children.head->prev = child;
-	else
-		parent->children.tail = child;
-	parent->children.head = child;
-}
-
-static void append_member(JsonNode *object, char *key, JsonNode *value)
-{
-	value->key = key;
-	append_node(object, value);
-}
-
-void json_append_element(JsonNode *array, JsonNode *element)
-{
-	assert(array->tag == JSON_ARRAY);
-	assert(element->parent == NULL);
-
-	append_node(array, element);
-}
-
-void json_prepend_element(JsonNode *array, JsonNode *element)
-{
-	assert(array->tag == JSON_ARRAY);
-	assert(element->parent == NULL);
-
-	prepend_node(array, element);
-}
-
-void json_append_member(JsonNode *object, const char *key, JsonNode *value)
-{
-	assert(object->tag == JSON_OBJECT);
-	assert(value->parent == NULL);
-
-	append_member(object, json_strdup(key), value);
-}
-
-void json_prepend_member(JsonNode *object, const char *key, JsonNode *value)
-{
-	assert(object->tag == JSON_OBJECT);
-	assert(value->parent == NULL);
-
-	value->key = json_strdup(key);
-	prepend_node(object, value);
-}
-
-void json_remove_from_parent(JsonNode *node)
-{
-	JsonNode *parent = node->parent;
-
-	if (parent != NULL)
-	{
-		if (node->prev != NULL)
-			node->prev->next = node->next;
-		else
-			parent->children.head = node->next;
-		if (node->next != NULL)
-			node->next->prev = node->prev;
-		else
-			parent->children.tail = node->prev;
-
-		free(node->key);
-
-		node->parent = NULL;
-		node->prev = node->next = NULL;
-		node->key = NULL;
-	}
-}
-
-static bool parse_value(const char **sp, JsonNode **out)
-{
-	const char *s = *sp;
-
-	switch (*s)
-	{
-	case 'n':
-		if (expect_literal(&s, "null"))
-		{
-			if (out)
-				*out = json_mknull();
-			*sp = s;
-			return true;
-		}
-		return false;
-
-	case 'f':
-		if (expect_literal(&s, "false"))
-		{
-			if (out)
-				*out = json_mkbool(false);
-			*sp = s;
-			return true;
-		}
-		return false;
-
-	case 't':
-		if (expect_literal(&s, "true"))
-		{
-			if (out)
-				*out = json_mkbool(true);
-			*sp = s;
-			return true;
-		}
-		return false;
-
-	case '"':
-	{
-		char *str;
-		if (parse_string(&s, out ? &str : NULL))
-		{
-			if (out)
-				*out = mkstring(str);
-			*sp = s;
-			return true;
-		}
-		return false;
-	}
-
-	case '[':
-		if (parse_array(&s, out))
-		{
-			*sp = s;
-			return true;
-		}
-		return false;
-
-	case '{':
-		if (parse_object(&s, out))
-		{
-			*sp = s;
-			return true;
-		}
-		return false;
-
-	default:
-	{
-		double num;
-		if (parse_number(&s, out ? &num : NULL))
-		{
-			if (out)
-				*out = json_mknumber(num);
-			*sp = s;
-			return true;
-		}
-		return false;
-	}
-	}
-}
-
-static bool parse_array(const char **sp, JsonNode **out)
-{
-	const char *s = *sp;
-	JsonNode *ret = out ? json_mkarray() : NULL;
-	JsonNode *element;
-
-	if (*s++ != '[')
-		goto failure;
-	skip_space(&s);
-
-	if (*s == ']')
-	{
-		s++;
-		goto success;
-	}
-
-	for (;;)
-	{
-		if (!parse_value(&s, out ? &element : NULL))
-			goto failure;
-		skip_space(&s);
-
-		if (out)
-			json_append_element(ret, element);
-
-		if (*s == ']')
-		{
-			s++;
-			goto success;
-		}
-
-		if (*s++ != ',')
-			goto failure;
-		skip_space(&s);
-	}
-
-success:
-	*sp = s;
-	if (out)
-		*out = ret;
-	return true;
-
-failure:
-	json_delete(ret);
-	return false;
-}
-
-static bool parse_object(const char **sp, JsonNode **out)
-{
-	const char *s = *sp;
-	JsonNode *ret = out ? json_mkobject() : NULL;
-	char *key;
-	JsonNode *value;
-
-	if (*s++ != '{')
-		goto failure;
-	skip_space(&s);
-
-	if (*s == '}')
-	{
-		s++;
-		goto success;
-	}
-
-	for (;;)
-	{
-		if (!parse_string(&s, out ? &key : NULL))
-			goto failure;
-		skip_space(&s);
-
-		if (*s++ != ':')
-			goto failure_free_key;
-		skip_space(&s);
-
-		if (!parse_value(&s, out ? &value : NULL))
-			goto failure_free_key;
-		skip_space(&s);
-
-		if (out)
-			append_member(ret, key, value);
-
-		if (*s == '}')
-		{
-			s++;
-			goto success;
-		}
-
-		if (*s++ != ',')
-			goto failure;
-		skip_space(&s);
-	}
-
-success:
-	*sp = s;
-	if (out)
-		*out = ret;
-	return true;
-
-failure_free_key:
-	if (out)
-		free(key);
-failure:
-	json_delete(ret);
-	return false;
-}
-
-bool parse_string(const char **sp, char **out)
-{
-	const char *s = *sp;
-	SB sb;
-	char throwaway_buffer[4];
-	/* enough space for a UTF-8 character */
-	char *b;
-
-	if (*s++ != '"')
-		return false;
-
-	if (out)
-	{
-		sb_init(&sb);
-		sb_need(&sb, 4);
-		b = sb.cur;
-	}
-	else
-	{
-		b = throwaway_buffer;
-	}
-
-	while (*s != '"')
-	{
-		unsigned char c = *s++;
-
-		/* Parse next character, and write it to b. */
-		if (c == '\\')
-		{
-			c = *s++;
-			switch (c)
-			{
-			case '"':
-			case '\\':
-			case '/':
-				*b++ = c;
-				break;
-			case 'b':
-				*b++ = '\b';
-				break;
-			case 'f':
-				*b++ = '\f';
-				break;
-			case 'n':
-				*b++ = '\n';
-				break;
-			case 'r':
-				*b++ = '\r';
-				break;
-			case 't':
-				*b++ = '\t';
-				break;
-			case 'u':
-			{
-				uint16_t uc, lc;
-				uchar_t unicode;
-
-				if (!parse_hex16(&s, &uc))
-					goto failed;
-
-				if (uc >= 0xD800 && uc <= 0xDFFF)
-				{
-					/* Handle UTF-16 surrogate pair. */
-					if (*s++ != '\\' || *s++ != 'u' || !parse_hex16(&s, &lc))
-						goto failed; /* Incomplete surrogate pair. */
-					if (!from_surrogate_pair(uc, lc, &unicode))
-						goto failed; /* Invalid surrogate pair. */
-				}
-				else if (uc == 0)
-				{
-					/* Disallow "\u0000". */
-					goto failed;
-				}
-				else
-				{
-					unicode = uc;
-				}
-
-				b += utf8_write_char(unicode, b);
-				break;
-			}
-			default:
-				/* Invalid escape */
-				goto failed;
-			}
-		}
-		else if (c <= 0x1F)
-		{
-			/* Control characters are not allowed in string literals. */
-			goto failed;
-		}
-		else
-		{
-			/* Validate and echo a UTF-8 character. */
-			int len;
-
-			s--;
-			len = utf8_validate_cz(s);
-			if (len == 0)
-				goto failed; /* Invalid UTF-8 character. */
-
-			while (len--)
-				*b++ = *s++;
-		}
-
-		/*
-		 * Update sb to know about the new bytes,
-		 * and set up b to write another character.
-		 */
-		if (out)
-		{
-			sb.cur = b;
-			sb_need(&sb, 4);
-			b = sb.cur;
-		}
-		else
-		{
-			b = throwaway_buffer;
-		}
-	}
-	s++;
-
-	if (out)
-		*out = sb_finish(&sb);
-	*sp = s;
-	return true;
-
-failed:
-	if (out)
-		sb_free(&sb);
-	return false;
-}
-
-/*
- * The JSON spec says that a number shall follow this precise pattern
- * (spaces and quotes added for readability):
- *	 '-'? (0 | [1-9][0-9]*) ('.' [0-9]+)? ([Ee] [+-]? [0-9]+)?
- *
- * However, some JSON parsers are more liberal.  For instance, PHP accepts
- * '.5' and '1.'.  JSON.parse accepts '+3'.
- *
- * This function takes the strict approach.
- */
-bool parse_number(const char **sp, double *out)
-{
-	const char *s = *sp;
-
-	/* '-'? */
-	if (*s == '-')
-		s++;
-
-	/* (0 | [1-9][0-9]*) */
-	if (*s == '0')
-	{
-		s++;
-	}
-	else
-	{
-		if (!is_digit(*s))
-			return false;
-		do
-		{
-			s++;
-		} while (is_digit(*s));
-	}
-
-	/* ('.' [0-9]+)? */
-	if (*s == '.')
-	{
-		s++;
-		if (!is_digit(*s))
-			return false;
-		do
-		{
-			s++;
-		} while (is_digit(*s));
-	}
-
-	/* ([Ee] [+-]? [0-9]+)? */
-	if (*s == 'E' || *s == 'e')
-	{
-		s++;
-		if (*s == '+' || *s == '-')
-			s++;
-		if (!is_digit(*s))
-			return false;
-		do
-		{
-			s++;
-		} while (is_digit(*s));
-	}
-
-	if (out)
-		*out = strtod(*sp, NULL);
-
-	*sp = s;
-	return true;
-}
-
-static void skip_space(const char **sp)
-{
-	const char *s = *sp;
-	while (is_space(*s))
-		s++;
-	*sp = s;
-}
-
-static void emit_value(SB *out, const JsonNode *node)
-{
-	assert(tag_is_valid(node->tag));
-	switch (node->tag)
-	{
-	case JSON_NULL:
-		sb_puts(out, "null");
-		break;
-	case JSON_BOOL:
-		sb_puts(out, node->bool_ ? "true" : "false");
-		break;
-	case JSON_STRING:
-		emit_string(out, node->string_);
-		break;
-	case JSON_NUMBER:
-		emit_number(out, node->number_);
-		break;
-	case JSON_ARRAY:
-		emit_array(out, node);
-		break;
-	case JSON_OBJECT:
-		emit_object(out, node);
-		break;
-	default:
-		assert(false);
-	}
-}
-
-void emit_value_indented(SB *out, const JsonNode *node, const char *space, int indent_level)
-{
-	assert(tag_is_valid(node->tag));
-	switch (node->tag)
-	{
-	case JSON_NULL:
-		sb_puts(out, "null");
-		break;
-	case JSON_BOOL:
-		sb_puts(out, node->bool_ ? "true" : "false");
-		break;
-	case JSON_STRING:
-		emit_string(out, node->string_);
-		break;
-	case JSON_NUMBER:
-		emit_number(out, node->number_);
-		break;
-	case JSON_ARRAY:
-		emit_array_indented(out, node, space, indent_level);
-		break;
-	case JSON_OBJECT:
-		emit_object_indented(out, node, space, indent_level);
-		break;
-	default:
-		assert(false);
-	}
-}
-
-static void emit_array(SB *out, const JsonNode *array)
-{
-	const JsonNode *element;
-
-	sb_putc(out, '[');
-	json_foreach(element, array)
-	{
-		emit_value(out, element);
-		if (element->next != NULL)
-			sb_putc(out, ',');
-	}
-	sb_putc(out, ']');
-}
-
-static void emit_array_indented(SB *out, const JsonNode *array, const char *space, int indent_level)
-{
-	const JsonNode *element = array->children.head;
-	int i;
-
-	if (element == NULL)
-	{
-		sb_puts(out, "[]");
-		return;
-	}
-
-	sb_puts(out, "[\n");
-	while (element != NULL)
-	{
-		for (i = 0; i < indent_level + 1; i++)
-			sb_puts(out, space);
-		emit_value_indented(out, element, space, indent_level + 1);
-
-		element = element->next;
-		sb_puts(out, element != NULL ? ",\n" : "\n");
-	}
-	for (i = 0; i < indent_level; i++)
-		sb_puts(out, space);
-	sb_putc(out, ']');
-}
-
-static void emit_object(SB *out, const JsonNode *object)
-{
-	const JsonNode *member;
-
-	sb_putc(out, '{');
-	json_foreach(member, object)
-	{
-		emit_string(out, member->key);
-		sb_putc(out, ':');
-		emit_value(out, member);
-		if (member->next != NULL)
-			sb_putc(out, ',');
-	}
-	sb_putc(out, '}');
-}
-
-static void emit_object_indented(SB *out, const JsonNode *object, const char *space, int indent_level)
-{
-	const JsonNode *member = object->children.head;
-	int i;
-
-	if (member == NULL)
-	{
-		sb_puts(out, "{}");
-		return;
-	}
-
-	sb_puts(out, "{\n");
-	while (member != NULL)
-	{
-		for (i = 0; i < indent_level + 1; i++)
-			sb_puts(out, space);
-		emit_string(out, member->key);
-		sb_puts(out, ": ");
-		emit_value_indented(out, member, space, indent_level + 1);
-
-		member = member->next;
-		sb_puts(out, member != NULL ? ",\n" : "\n");
-	}
-	for (i = 0; i < indent_level; i++)
-		sb_puts(out, space);
-	sb_putc(out, '}');
-}
-
-void emit_string(SB *out, const char *str)
-{
-	bool escape_unicode = false;
-	const char *s = str;
-	char *b;
-
-	assert(utf8_validate(str));
-
-	/*
-	 * 14 bytes is enough space to write up to two
-	 * \uXXXX escapes and two quotation marks.
-	 */
-	sb_need(out, 14);
-	b = out->cur;
-
-	*b++ = '"';
-	while (*s != 0)
-	{
-		unsigned char c = *s++;
-
-		/* Encode the next character, and write it to b. */
-		switch (c)
-		{
-		case '"':
-			*b++ = '\\';
-			*b++ = '"';
-			break;
-		case '\\':
-			*b++ = '\\';
-			*b++ = '\\';
-			break;
-		case '\b':
-			*b++ = '\\';
-			*b++ = 'b';
-			break;
-		case '\f':
-			*b++ = '\\';
-			*b++ = 'f';
-			break;
-		case '\n':
-			*b++ = '\\';
-			*b++ = 'n';
-			break;
-		case '\r':
-			*b++ = '\\';
-			*b++ = 'r';
-			break;
-		case '\t':
-			*b++ = '\\';
-			*b++ = 't';
-			break;
-		default:
-		{
-			int len;
-
-			s--;
-			len = utf8_validate_cz(s);
-
-			if (len == 0)
-			{
-				/*
-				 * Handle invalid UTF-8 character gracefully in production
-				 * by writing a replacement character (U+FFFD)
-				 * and skipping a single byte.
-				 *
-				 * This should never happen when assertions are enabled
-				 * due to the assertion at the beginning of this function.
-				 */
-				assert(false);
-				if (escape_unicode)
-				{
-					strcpy(b, "\\uFFFD");
-					b += 6;
-				}
-				else
-				{
-					*b++ = 0xEF;
-					*b++ = 0xBF;
-					*b++ = 0xBD;
-				}
-				s++;
-			}
-			else if (c < 0x1F || (c >= 0x80 && escape_unicode))
-			{
-				/* Encode using \u.... */
-				uint32_t unicode;
-
-				s += utf8_read_char(s, &unicode);
-
-				if (unicode <= 0xFFFF)
-				{
-					*b++ = '\\';
-					*b++ = 'u';
-					b += write_hex16(b, unicode);
-				}
-				else
-				{
-					/* Produce a surrogate pair. */
-					uint16_t uc, lc;
-					assert(unicode <= 0x10FFFF);
-					to_surrogate_pair(unicode, &uc, &lc);
-					*b++ = '\\';
-					*b++ = 'u';
-					b += write_hex16(b, uc);
-					*b++ = '\\';
-					*b++ = 'u';
-					b += write_hex16(b, lc);
-				}
-			}
-			else
-			{
-				/* Write the character directly. */
-				while (len--)
-					*b++ = *s++;
-			}
-
-			break;
-		}
-		}
-
-		/*
-		 * Update *out to know about the new bytes,
-		 * and set up b to write another encoded character.
-		 */
-		out->cur = b;
-		sb_need(out, 14);
-		b = out->cur;
-	}
-	*b++ = '"';
-
-	out->cur = b;
-}
-
-static void emit_number(SB *out, double num)
-{
-	/*
-	 * This isn't exactly how JavaScript renders numbers,
-	 * but it should produce valid JSON for reasonable numbers
-	 * preserve precision well enough, and avoid some oddities
-	 * like 0.3 -> 0.299999999999999988898 .
-	 */
-	char buf[64];
-	sprintf(buf, "%.16g", num);
-
-	if (number_is_valid(buf))
-		sb_puts(out, buf);
-	else
-		sb_puts(out, "null");
-}
-
-static bool tag_is_valid(unsigned int tag)
-{
-	return (/* tag >= JSON_NULL && */ tag <= JSON_OBJECT);
-}
-
-static bool number_is_valid(const char *num)
-{
-	return (parse_number(&num, NULL) && *num == '\0');
-}
-
-static bool expect_literal(const char **sp, const char *str)
-{
-	const char *s = *sp;
-
-	while (*str != '\0')
-		if (*s++ != *str++)
-			return false;
-
-	*sp = s;
-	return true;
-}
-
-/*
- * Parses exactly 4 hex characters (capital or lowercase).
- * Fails if any input chars are not [0-9A-Fa-f].
- */
-static bool parse_hex16(const char **sp, uint16_t *out)
-{
-	const char *s = *sp;
-	uint16_t ret = 0;
-	uint16_t i;
-	uint16_t tmp;
-	char c;
-
-	for (i = 0; i < 4; i++)
-	{
-		c = *s++;
-		if (c >= '0' && c <= '9')
-			tmp = c - '0';
-		else if (c >= 'A' && c <= 'F')
-			tmp = c - 'A' + 10;
-		else if (c >= 'a' && c <= 'f')
-			tmp = c - 'a' + 10;
-		else
-			return false;
-
-		ret <<= 4;
-		ret += tmp;
-	}
-
-	if (out)
-		*out = ret;
-	*sp = s;
-	return true;
-}
-
-/*
- * Encodes a 16-bit number into hexadecimal,
- * writing exactly 4 hex chars.
- */
-static int write_hex16(char *out, uint16_t val)
-{
-	const char *hex = "0123456789ABCDEF";
-
-	*out++ = hex[(val >> 12) & 0xF];
-	*out++ = hex[(val >> 8) & 0xF];
-	*out++ = hex[(val >> 4) & 0xF];
-	*out++ = hex[val & 0xF];
-
-	return 4;
-}
-
-bool json_check(const JsonNode *node, char errmsg[256])
-{
-#define problem(...)                            \
-	do                                          \
-	{                                           \
-		if (errmsg != NULL)                     \
-			snprintf(errmsg, 256, __VA_ARGS__); \
-		return false;                           \
-	} while (0)
-
-	if (node->key != NULL && !utf8_validate(node->key))
-		problem("key contains invalid UTF-8");
-
-	if (!tag_is_valid(node->tag))
-		problem("tag is invalid (%u)", node->tag);
-
-	if (node->tag == JSON_BOOL)
-	{
-		if (node->bool_ != false && node->bool_ != true)
-			problem("bool_ is neither false (%d) nor true (%d)", (int)false, (int)true);
-	}
-	else if (node->tag == JSON_STRING)
-	{
-		if (node->string_ == NULL)
-			problem("string_ is NULL");
-		if (!utf8_validate(node->string_))
-			problem("string_ contains invalid UTF-8");
-	}
-	else if (node->tag == JSON_ARRAY || node->tag == JSON_OBJECT)
-	{
-		JsonNode *head = node->children.head;
-		JsonNode *tail = node->children.tail;
-
-		if (head == NULL || tail == NULL)
-		{
-			if (head != NULL)
-				problem("tail is NULL, but head is not");
-			if (tail != NULL)
-				problem("head is NULL, but tail is not");
-		}
-		else
-		{
-			JsonNode *child;
-			JsonNode *last = NULL;
-
-			if (head->prev != NULL)
-				problem("First child's prev pointer is not NULL");
-
-			for (child = head; child != NULL; last = child, child = child->next)
-			{
-				if (child == node)
-					problem("node is its own child");
-				if (child->next == child)
-					problem("child->next == child (cycle)");
-				if (child->next == head)
-					problem("child->next == head (cycle)");
-
-				if (child->parent != node)
-					problem("child does not point back to parent");
-				if (child->next != NULL && child->next->prev != child)
-					problem("child->next does not point back to child");
-
-				if (node->tag == JSON_ARRAY && child->key != NULL)
-					problem("Array element's key is not NULL");
-				if (node->tag == JSON_OBJECT && child->key == NULL)
-					problem("Object member's key is NULL");
-
-				if (!json_check(child, errmsg))
-					return false;
-			}
-
-			if (last != tail)
-				problem("tail does not match pointer found by starting at head and following next links");
-		}
-	}
-
-	return true;
-
-#undef problem
-}
+/*
+  Copyright (C) 2011 Joseph A. Adams (joeyadams3.14159@gmail.com)
+  All rights reserved.
+
+  Permission is hereby granted, free of charge, to any person obtaining a copy
+  of this software and associated documentation files (the "Software"), to deal
+  in the Software without restriction, including without limitation the rights
+  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+  copies of the Software, and to permit persons to whom the Software is
+  furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included in
+  all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+  THE SOFTWARE.
+*/
+
+#include "json.h"
+
+#include <assert.h>
+#include <stdint.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#define out_of_memory()                      \
+	do                                       \
+	{                                        \
+		fprintf(stderr, "Out of memory.\n"); \
+		exit(EXIT_FAILURE);                  \
+	} while (0)
+
+/* Sadly, strdup is not portable. */
+static char *json_strdup(const char *str)
+{
+	char *ret = (char *)malloc(strlen(str) + 1);
+	if (ret == NULL)
+		out_of_memory();
+	strcpy(ret, str);
+	return ret;
+}
+
+/* String buffer */
+
+typedef struct
+{
+	char *cur;
+	char *end;
+	char *start;
+} SB;
+
+static void sb_init(SB *sb)
+{
+	sb->start = (char *)malloc(17);
+	if (sb->start == NULL)
+		out_of_memory();
+	sb->cur = sb->start;
+	sb->end = sb->start + 16;
+}
+
+/* sb and need may be evaluated multiple times. */
+#define sb_need(sb, need)                   \
+	do                                      \
+	{                                       \
+		if ((sb)->end - (sb)->cur < (need)) \
+			sb_grow(sb, need);              \
+	} while (0)
+
+static void sb_grow(SB *sb, int need)
+{
+	size_t length = sb->cur - sb->start;
+	size_t alloc = sb->end - sb->start;
+
+	do
+	{
+		alloc *= 2;
+	} while (alloc < length + need);
+
+	sb->start = (char *)realloc(sb->start, alloc + 1);
+	if (sb->start == NULL)
+		out_of_memory();
+	sb->cur = sb->start + length;
+	sb->end = sb->start + alloc;
+}
+
+static void sb_put(SB *sb, const char *bytes, int count)
+{
+	sb_need(sb, count);
+	memcpy(sb->cur, bytes, count);
+	sb->cur += count;
+}
+
+#define sb_putc(sb, c)              \
+	do                              \
+	{                               \
+		if ((sb)->cur >= (sb)->end) \
+			sb_grow(sb, 1);         \
+		*(sb)->cur++ = (c);         \
+	} while (0)
+
+static void sb_puts(SB *sb, const char *str)
+{
+	sb_put(sb, str, strlen(str));
+}
+
+static char *sb_finish(SB *sb)
+{
+	*sb->cur = 0;
+	assert(sb->start <= sb->cur && strlen(sb->start) == (size_t)(sb->cur - sb->start));
+	return sb->start;
+}
+
+static void sb_free(SB *sb)
+{
+	free(sb->start);
+}
+
+/*
+ * Unicode helper functions
+ *
+ * These are taken from the ccan/charset module and customized a bit.
+ * Putting them here means the compiler can (choose to) inline them,
+ * and it keeps ccan/json from having a dependency.
+ */
+
+/*
+ * Type for Unicode codepoints.
+ * We need our own because wchar_t might be 16 bits.
+ */
+typedef uint32_t uchar_t;
+
+/*
+ * Validate a single UTF-8 character starting at @s.
+ * The string must be null-terminated.
+ *
+ * If it's valid, return its length (1 thru 4).
+ * If it's invalid or clipped, return 0.
+ *
+ * This function implements the syntax given in RFC3629, which is
+ * the same as that given in The Unicode Standard, Version 6.0.
+ *
+ * It has the following properties:
+ *
+ *  * All codepoints U+0000..U+10FFFF may be encoded,
+ *    except for U+D800..U+DFFF, which are reserved
+ *    for UTF-16 surrogate pair encoding.
+ *  * UTF-8 byte sequences longer than 4 bytes are not permitted,
+ *    as they exceed the range of Unicode.
+ *  * The sixty-six Unicode "non-characters" are permitted
+ *    (namely, U+FDD0..U+FDEF, U+xxFFFE, and U+xxFFFF).
+ */
+static int utf8_validate_cz(const char *s)
+{
+	unsigned char c = *s++;
+
+	if (c <= 0x7F)
+	{ /* 00..7F */
+		return 1;
+	}
+	else if (c <= 0xC1)
+	{ /* 80..C1 */
+		/* Disallow overlong 2-byte sequence. */
+		return 0;
+	}
+	else if (c <= 0xDF)
+	{ /* C2..DF */
+		/* Make sure subsequent byte is in the range 0x80..0xBF. */
+		if (((unsigned char)*s++ & 0xC0) != 0x80)
+			return 0;
+
+		return 2;
+	}
+	else if (c <= 0xEF)
+	{ /* E0..EF */
+		/* Disallow overlong 3-byte sequence. */
+		if (c == 0xE0 && (unsigned char)*s < 0xA0)
+			return 0;
+
+		/* Disallow U+D800..U+DFFF. */
+		if (c == 0xED && (unsigned char)*s > 0x9F)
+			return 0;
+
+		/* Make sure subsequent bytes are in the range 0x80..0xBF. */
+		if (((unsigned char)*s++ & 0xC0) != 0x80)
+			return 0;
+		if (((unsigned char)*s++ & 0xC0) != 0x80)
+			return 0;
+
+		return 3;
+	}
+	else if (c <= 0xF4)
+	{ /* F0..F4 */
+		/* Disallow overlong 4-byte sequence. */
+		if (c == 0xF0 && (unsigned char)*s < 0x90)
+			return 0;
+
+		/* Disallow codepoints beyond U+10FFFF. */
+		if (c == 0xF4 && (unsigned char)*s > 0x8F)
+			return 0;
+
+		/* Make sure subsequent bytes are in the range 0x80..0xBF. */
+		if (((unsigned char)*s++ & 0xC0) != 0x80)
+			return 0;
+		if (((unsigned char)*s++ & 0xC0) != 0x80)
+			return 0;
+		if (((unsigned char)*s++ & 0xC0) != 0x80)
+			return 0;
+
+		return 4;
+	}
+	else
+	{ /* F5..FF */
+		return 0;
+	}
+}
+
+/* Validate a null-terminated UTF-8 string. */
+static bool utf8_validate(const char *s)
+{
+	int len;
+
+	for (; *s != 0; s += len)
+	{
+		len = utf8_validate_cz(s);
+		if (len == 0)
+			return false;
+	}
+
+	return true;
+}
+
+/*
+ * Read a single UTF-8 character starting at @s,
+ * returning the length, in bytes, of the character read.
+ *
+ * This function assumes input is valid UTF-8,
+ * and that there are enough characters in front of @s.
+ */
+static int utf8_read_char(const char *s, uchar_t *out)
+{
+	const unsigned char *c = (const unsigned char *)s;
+
+	assert(utf8_validate_cz(s));
+
+	if (c[0] <= 0x7F)
+	{
+		/* 00..7F */
+		*out = c[0];
+		return 1;
+	}
+	else if (c[0] <= 0xDF)
+	{
+		/* C2..DF (unless input is invalid) */
+		*out = ((uchar_t)c[0] & 0x1F) << 6 |
+			   ((uchar_t)c[1] & 0x3F);
+		return 2;
+	}
+	else if (c[0] <= 0xEF)
+	{
+		/* E0..EF */
+		*out = ((uchar_t)c[0] & 0xF) << 12 |
+			   ((uchar_t)c[1] & 0x3F) << 6 |
+			   ((uchar_t)c[2] & 0x3F);
+		return 3;
+	}
+	else
+	{
+		/* F0..F4 (unless input is invalid) */
+		*out = ((uchar_t)c[0] & 0x7) << 18 |
+			   ((uchar_t)c[1] & 0x3F) << 12 |
+			   ((uchar_t)c[2] & 0x3F) << 6 |
+			   ((uchar_t)c[3] & 0x3F);
+		return 4;
+	}
+}
+
+/*
+ * Write a single UTF-8 character to @s,
+ * returning the length, in bytes, of the character written.
+ *
+ * @unicode must be U+0000..U+10FFFF, but not U+D800..U+DFFF.
+ *
+ * This function will write up to 4 bytes to @out.
+ */
+static int utf8_write_char(uchar_t unicode, char *out)
+{
+	unsigned char *o = (unsigned char *)out;
+
+	assert(unicode <= 0x10FFFF && !(unicode >= 0xD800 && unicode <= 0xDFFF));
+
+	if (unicode <= 0x7F)
+	{
+		/* U+0000..U+007F */
+		*o++ = unicode;
+		return 1;
+	}
+	else if (unicode <= 0x7FF)
+	{
+		/* U+0080..U+07FF */
+		*o++ = 0xC0 | unicode >> 6;
+		*o++ = 0x80 | (unicode & 0x3F);
+		return 2;
+	}
+	else if (unicode <= 0xFFFF)
+	{
+		/* U+0800..U+FFFF */
+		*o++ = 0xE0 | unicode >> 12;
+		*o++ = 0x80 | (unicode >> 6 & 0x3F);
+		*o++ = 0x80 | (unicode & 0x3F);
+		return 3;
+	}
+	else
+	{
+		/* U+10000..U+10FFFF */
+		*o++ = 0xF0 | unicode >> 18;
+		*o++ = 0x80 | (unicode >> 12 & 0x3F);
+		*o++ = 0x80 | (unicode >> 6 & 0x3F);
+		*o++ = 0x80 | (unicode & 0x3F);
+		return 4;
+	}
+}
+
+/*
+ * Compute the Unicode codepoint of a UTF-16 surrogate pair.
+ *
+ * @uc should be 0xD800..0xDBFF, and @lc should be 0xDC00..0xDFFF.
+ * If they aren't, this function returns false.
+ */
+static bool from_surrogate_pair(uint16_t uc, uint16_t lc, uchar_t *unicode)
+{
+	if (uc >= 0xD800 && uc <= 0xDBFF && lc >= 0xDC00 && lc <= 0xDFFF)
+	{
+		*unicode = 0x10000 + ((((uchar_t)uc & 0x3FF) << 10) | (lc & 0x3FF));
+		return true;
+	}
+	else
+	{
+		return false;
+	}
+}
+
+/*
+ * Construct a UTF-16 surrogate pair given a Unicode codepoint.
+ *
+ * @unicode must be U+10000..U+10FFFF.
+ */
+static void to_surrogate_pair(uchar_t unicode, uint16_t *uc, uint16_t *lc)
+{
+	uchar_t n;
+
+	assert(unicode >= 0x10000 && unicode <= 0x10FFFF);
+
+	n = unicode - 0x10000;
+	*uc = ((n >> 10) & 0x3FF) | 0xD800;
+	*lc = (n & 0x3FF) | 0xDC00;
+}
+
+#define is_space(c) ((c) == '\t' || (c) == '\n' || (c) == '\r' || (c) == ' ')
+#define is_digit(c) ((c) >= '0' && (c) <= '9')
+
+static bool parse_value(const char **sp, JsonNode **out);
+static bool parse_string(const char **sp, char **out);
+static bool parse_number(const char **sp, double *out);
+static bool parse_array(const char **sp, JsonNode **out);
+static bool parse_object(const char **sp, JsonNode **out);
+static bool parse_hex16(const char **sp, uint16_t *out);
+
+static bool expect_literal(const char **sp, const char *str);
+static void skip_space(const char **sp);
+
+static void emit_value(SB *out, const JsonNode *node);
+static void emit_value_indented(SB *out, const JsonNode *node, const char *space, int indent_level);
+static void emit_string(SB *out, const char *str);
+static void emit_number(SB *out, double num);
+static void emit_array(SB *out, const JsonNode *array);
+static void emit_array_indented(SB *out, const JsonNode *array, const char *space, int indent_level);
+static void emit_object(SB *out, const JsonNode *object);
+static void emit_object_indented(SB *out, const JsonNode *object, const char *space, int indent_level);
+
+static int write_hex16(char *out, uint16_t val);
+
+static JsonNode *mknode(JsonTag tag);
+static void append_node(JsonNode *parent, JsonNode *child);
+static void prepend_node(JsonNode *parent, JsonNode *child);
+static void append_member(JsonNode *object, char *key, JsonNode *value);
+
+/* Assertion-friendly validity checks */
+static bool tag_is_valid(unsigned int tag);
+static bool number_is_valid(const char *num);
+
+JsonNode *json_decode(const char *json)
+{
+	const char *s = json;
+	JsonNode *ret;
+
+	skip_space(&s);
+	if (!parse_value(&s, &ret))
+		return NULL;
+
+	skip_space(&s);
+	if (*s != 0)
+	{
+		json_delete(ret);
+		return NULL;
+	}
+
+	return ret;
+}
+
+char *json_encode(const JsonNode *node)
+{
+	return json_stringify(node, NULL);
+}
+
+char *json_encode_string(const char *str)
+{
+	SB sb;
+	sb_init(&sb);
+
+	emit_string(&sb, str);
+
+	return sb_finish(&sb);
+}
+
+char *json_stringify(const JsonNode *node, const char *space)
+{
+	SB sb;
+	sb_init(&sb);
+
+	if (space != NULL)
+		emit_value_indented(&sb, node, space, 0);
+	else
+		emit_value(&sb, node);
+
+	return sb_finish(&sb);
+}
+
+void json_delete(JsonNode *node)
+{
+	if (node != NULL)
+	{
+		json_remove_from_parent(node);
+
+		switch (node->tag)
+		{
+		case JSON_STRING:
+			free(node->string_);
+			break;
+		case JSON_ARRAY:
+		case JSON_OBJECT:
+		{
+			JsonNode *child, *next;
+			for (child = node->children.head; child != NULL; child = next)
+			{
+				next = child->next;
+				json_delete(child);
+			}
+			break;
+		}
+		default:;
+		}
+
+		free(node);
+	}
+}
+
+bool json_validate(const char *json)
+{
+	const char *s = json;
+
+	skip_space(&s);
+	if (!parse_value(&s, NULL))
+		return false;
+
+	skip_space(&s);
+	if (*s != 0)
+		return false;
+
+	return true;
+}
+
+JsonNode *json_find_element(JsonNode *array, int index)
+{
+	JsonNode *element;
+	int i = 0;
+
+	if (array == NULL || array->tag != JSON_ARRAY)
+		return NULL;
+
+	json_foreach(element, array)
+	{
+		if (i == index)
+			return element;
+		i++;
+	}
+
+	return NULL;
+}
+
+JsonNode *json_find_member(JsonNode *object, const char *name)
+{
+	JsonNode *member;
+
+	if (object == NULL || object->tag != JSON_OBJECT)
+		return NULL;
+
+	json_foreach(member, object) if (strcmp(member->key, name) == 0) return member;
+
+	return NULL;
+}
+
+JsonNode *json_first_child(const JsonNode *node)
+{
+	if (node != NULL && (node->tag == JSON_ARRAY || node->tag == JSON_OBJECT))
+		return node->children.head;
+	return NULL;
+}
+
+static JsonNode *mknode(JsonTag tag)
+{
+	JsonNode *ret = (JsonNode *)calloc(1, sizeof(JsonNode));
+	if (ret == NULL)
+		out_of_memory();
+	ret->tag = tag;
+	return ret;
+}
+
+JsonNode *json_mknull(void)
+{
+	return mknode(JSON_NULL);
+}
+
+JsonNode *json_mkbool(bool b)
+{
+	JsonNode *ret = mknode(JSON_BOOL);
+	ret->bool_ = b;
+	return ret;
+}
+
+static JsonNode *mkstring(char *s)
+{
+	JsonNode *ret = mknode(JSON_STRING);
+	ret->string_ = s;
+	return ret;
+}
+
+JsonNode *json_mkstring(const char *s)
+{
+	return mkstring(json_strdup(s));
+}
+
+JsonNode *json_mknumber(double n)
+{
+	JsonNode *node = mknode(JSON_NUMBER);
+	node->number_ = n;
+	return node;
+}
+
+JsonNode *json_mkarray(void)
+{
+	return mknode(JSON_ARRAY);
+}
+
+JsonNode *json_mkobject(void)
+{
+	return mknode(JSON_OBJECT);
+}
+
+static void append_node(JsonNode *parent, JsonNode *child)
+{
+	child->parent = parent;
+	child->prev = parent->children.tail;
+	child->next = NULL;
+
+	if (parent->children.tail != NULL)
+		parent->children.tail->next = child;
+	else
+		parent->children.head = child;
+	parent->children.tail = child;
+}
+
+static void prepend_node(JsonNode *parent, JsonNode *child)
+{
+	child->parent = parent;
+	child->prev = NULL;
+	child->next = parent->children.head;
+
+	if (parent->children.head != NULL)
+		parent->children.head->prev = child;
+	else
+		parent->children.tail = child;
+	parent->children.head = child;
+}
+
+static void append_member(JsonNode *object, char *key, JsonNode *value)
+{
+	value->key = key;
+	append_node(object, value);
+}
+
+void json_append_element(JsonNode *array, JsonNode *element)
+{
+	assert(array->tag == JSON_ARRAY);
+	assert(element->parent == NULL);
+
+	append_node(array, element);
+}
+
+void json_prepend_element(JsonNode *array, JsonNode *element)
+{
+	assert(array->tag == JSON_ARRAY);
+	assert(element->parent == NULL);
+
+	prepend_node(array, element);
+}
+
+void json_append_member(JsonNode *object, const char *key, JsonNode *value)
+{
+	assert(object->tag == JSON_OBJECT);
+	assert(value->parent == NULL);
+
+	append_member(object, json_strdup(key), value);
+}
+
+void json_prepend_member(JsonNode *object, const char *key, JsonNode *value)
+{
+	assert(object->tag == JSON_OBJECT);
+	assert(value->parent == NULL);
+
+	value->key = json_strdup(key);
+	prepend_node(object, value);
+}
+
+void json_remove_from_parent(JsonNode *node)
+{
+	JsonNode *parent = node->parent;
+
+	if (parent != NULL)
+	{
+		if (node->prev != NULL)
+			node->prev->next = node->next;
+		else
+			parent->children.head = node->next;
+		if (node->next != NULL)
+			node->next->prev = node->prev;
+		else
+			parent->children.tail = node->prev;
+
+		free(node->key);
+
+		node->parent = NULL;
+		node->prev = node->next = NULL;
+		node->key = NULL;
+	}
+}
+
+static bool parse_value(const char **sp, JsonNode **out)
+{
+	const char *s = *sp;
+
+	switch (*s)
+	{
+	case 'n':
+		if (expect_literal(&s, "null"))
+		{
+			if (out)
+				*out = json_mknull();
+			*sp = s;
+			return true;
+		}
+		return false;
+
+	case 'f':
+		if (expect_literal(&s, "false"))
+		{
+			if (out)
+				*out = json_mkbool(false);
+			*sp = s;
+			return true;
+		}
+		return false;
+
+	case 't':
+		if (expect_literal(&s, "true"))
+		{
+			if (out)
+				*out = json_mkbool(true);
+			*sp = s;
+			return true;
+		}
+		return false;
+
+	case '"':
+	{
+		char *str;
+		if (parse_string(&s, out ? &str : NULL))
+		{
+			if (out)
+				*out = mkstring(str);
+			*sp = s;
+			return true;
+		}
+		return false;
+	}
+
+	case '[':
+		if (parse_array(&s, out))
+		{
+			*sp = s;
+			return true;
+		}
+		return false;
+
+	case '{':
+		if (parse_object(&s, out))
+		{
+			*sp = s;
+			return true;
+		}
+		return false;
+
+	default:
+	{
+		double num;
+		if (parse_number(&s, out ? &num : NULL))
+		{
+			if (out)
+				*out = json_mknumber(num);
+			*sp = s;
+			return true;
+		}
+		return false;
+	}
+	}
+}
+
+static bool parse_array(const char **sp, JsonNode **out)
+{
+	const char *s = *sp;
+	JsonNode *ret = out ? json_mkarray() : NULL;
+	JsonNode *element;
+
+	if (*s++ != '[')
+		goto failure;
+	skip_space(&s);
+
+	if (*s == ']')
+	{
+		s++;
+		goto success;
+	}
+
+	for (;;)
+	{
+		if (!parse_value(&s, out ? &element : NULL))
+			goto failure;
+		skip_space(&s);
+
+		if (out)
+			json_append_element(ret, element);
+
+		if (*s == ']')
+		{
+			s++;
+			goto success;
+		}
+
+		if (*s++ != ',')
+			goto failure;
+		skip_space(&s);
+	}
+
+success:
+	*sp = s;
+	if (out)
+		*out = ret;
+	return true;
+
+failure:
+	json_delete(ret);
+	return false;
+}
+
+static bool parse_object(const char **sp, JsonNode **out)
+{
+	const char *s = *sp;
+	JsonNode *ret = out ? json_mkobject() : NULL;
+	char *key;
+	JsonNode *value;
+
+	if (*s++ != '{')
+		goto failure;
+	skip_space(&s);
+
+	if (*s == '}')
+	{
+		s++;
+		goto success;
+	}
+
+	for (;;)
+	{
+		if (!parse_string(&s, out ? &key : NULL))
+			goto failure;
+		skip_space(&s);
+
+		if (*s++ != ':')
+			goto failure_free_key;
+		skip_space(&s);
+
+		if (!parse_value(&s, out ? &value : NULL))
+			goto failure_free_key;
+		skip_space(&s);
+
+		if (out)
+			append_member(ret, key, value);
+
+		if (*s == '}')
+		{
+			s++;
+			goto success;
+		}
+
+		if (*s++ != ',')
+			goto failure;
+		skip_space(&s);
+	}
+
+success:
+	*sp = s;
+	if (out)
+		*out = ret;
+	return true;
+
+failure_free_key:
+	if (out)
+		free(key);
+failure:
+	json_delete(ret);
+	return false;
+}
+
+bool parse_string(const char **sp, char **out)
+{
+	const char *s = *sp;
+	SB sb;
+	char throwaway_buffer[4];
+	/* enough space for a UTF-8 character */
+	char *b;
+
+	if (*s++ != '"')
+		return false;
+
+	if (out)
+	{
+		sb_init(&sb);
+		sb_need(&sb, 4);
+		b = sb.cur;
+	}
+	else
+	{
+		b = throwaway_buffer;
+	}
+
+	while (*s != '"')
+	{
+		unsigned char c = *s++;
+
+		/* Parse next character, and write it to b. */
+		if (c == '\\')
+		{
+			c = *s++;
+			switch (c)
+			{
+			case '"':
+			case '\\':
+			case '/':
+				*b++ = c;
+				break;
+			case 'b':
+				*b++ = '\b';
+				break;
+			case 'f':
+				*b++ = '\f';
+				break;
+			case 'n':
+				*b++ = '\n';
+				break;
+			case 'r':
+				*b++ = '\r';
+				break;
+			case 't':
+				*b++ = '\t';
+				break;
+			case 'u':
+			{
+				uint16_t uc, lc;
+				uchar_t unicode;
+
+				if (!parse_hex16(&s, &uc))
+					goto failed;
+
+				if (uc >= 0xD800 && uc <= 0xDFFF)
+				{
+					/* Handle UTF-16 surrogate pair. */
+					if (*s++ != '\\' || *s++ != 'u' || !parse_hex16(&s, &lc))
+						goto failed; /* Incomplete surrogate pair. */
+					if (!from_surrogate_pair(uc, lc, &unicode))
+						goto failed; /* Invalid surrogate pair. */
+				}
+				else if (uc == 0)
+				{
+					/* Disallow "\u0000". */
+					goto failed;
+				}
+				else
+				{
+					unicode = uc;
+				}
+
+				b += utf8_write_char(unicode, b);
+				break;
+			}
+			default:
+				/* Invalid escape */
+				goto failed;
+			}
+		}
+		else if (c <= 0x1F)
+		{
+			/* Control characters are not allowed in string literals. */
+			goto failed;
+		}
+		else
+		{
+			/* Validate and echo a UTF-8 character. */
+			int len;
+
+			s--;
+			len = utf8_validate_cz(s);
+			if (len == 0)
+				goto failed; /* Invalid UTF-8 character. */
+
+			while (len--)
+				*b++ = *s++;
+		}
+
+		/*
+		 * Update sb to know about the new bytes,
+		 * and set up b to write another character.
+		 */
+		if (out)
+		{
+			sb.cur = b;
+			sb_need(&sb, 4);
+			b = sb.cur;
+		}
+		else
+		{
+			b = throwaway_buffer;
+		}
+	}
+	s++;
+
+	if (out)
+		*out = sb_finish(&sb);
+	*sp = s;
+	return true;
+
+failed:
+	if (out)
+		sb_free(&sb);
+	return false;
+}
+
+/*
+ * The JSON spec says that a number shall follow this precise pattern
+ * (spaces and quotes added for readability):
+ *	 '-'? (0 | [1-9][0-9]*) ('.' [0-9]+)? ([Ee] [+-]? [0-9]+)?
+ *
+ * However, some JSON parsers are more liberal.  For instance, PHP accepts
+ * '.5' and '1.'.  JSON.parse accepts '+3'.
+ *
+ * This function takes the strict approach.
+ */
+bool parse_number(const char **sp, double *out)
+{
+	const char *s = *sp;
+
+	/* '-'? */
+	if (*s == '-')
+		s++;
+
+	/* (0 | [1-9][0-9]*) */
+	if (*s == '0')
+	{
+		s++;
+	}
+	else
+	{
+		if (!is_digit(*s))
+			return false;
+		do
+		{
+			s++;
+		} while (is_digit(*s));
+	}
+
+	/* ('.' [0-9]+)? */
+	if (*s == '.')
+	{
+		s++;
+		if (!is_digit(*s))
+			return false;
+		do
+		{
+			s++;
+		} while (is_digit(*s));
+	}
+
+	/* ([Ee] [+-]? [0-9]+)? */
+	if (*s == 'E' || *s == 'e')
+	{
+		s++;
+		if (*s == '+' || *s == '-')
+			s++;
+		if (!is_digit(*s))
+			return false;
+		do
+		{
+			s++;
+		} while (is_digit(*s));
+	}
+
+	if (out)
+		*out = strtod(*sp, NULL);
+
+	*sp = s;
+	return true;
+}
+
+static void skip_space(const char **sp)
+{
+	const char *s = *sp;
+	while (is_space(*s))
+		s++;
+	*sp = s;
+}
+
+static void emit_value(SB *out, const JsonNode *node)
+{
+	assert(tag_is_valid(node->tag));
+	switch (node->tag)
+	{
+	case JSON_NULL:
+		sb_puts(out, "null");
+		break;
+	case JSON_BOOL:
+		sb_puts(out, node->bool_ ? "true" : "false");
+		break;
+	case JSON_STRING:
+		emit_string(out, node->string_);
+		break;
+	case JSON_NUMBER:
+		emit_number(out, node->number_);
+		break;
+	case JSON_ARRAY:
+		emit_array(out, node);
+		break;
+	case JSON_OBJECT:
+		emit_object(out, node);
+		break;
+	default:
+		assert(false);
+	}
+}
+
+void emit_value_indented(SB *out, const JsonNode *node, const char *space, int indent_level)
+{
+	assert(tag_is_valid(node->tag));
+	switch (node->tag)
+	{
+	case JSON_NULL:
+		sb_puts(out, "null");
+		break;
+	case JSON_BOOL:
+		sb_puts(out, node->bool_ ? "true" : "false");
+		break;
+	case JSON_STRING:
+		emit_string(out, node->string_);
+		break;
+	case JSON_NUMBER:
+		emit_number(out, node->number_);
+		break;
+	case JSON_ARRAY:
+		emit_array_indented(out, node, space, indent_level);
+		break;
+	case JSON_OBJECT:
+		emit_object_indented(out, node, space, indent_level);
+		break;
+	default:
+		assert(false);
+	}
+}
+
+static void emit_array(SB *out, const JsonNode *array)
+{
+	const JsonNode *element;
+
+	sb_putc(out, '[');
+	json_foreach(element, array)
+	{
+		emit_value(out, element);
+		if (element->next != NULL)
+			sb_putc(out, ',');
+	}
+	sb_putc(out, ']');
+}
+
+static void emit_array_indented(SB *out, const JsonNode *array, const char *space, int indent_level)
+{
+	const JsonNode *element = array->children.head;
+	int i;
+
+	if (element == NULL)
+	{
+		sb_puts(out, "[]");
+		return;
+	}
+
+	sb_puts(out, "[\n");
+	while (element != NULL)
+	{
+		for (i = 0; i < indent_level + 1; i++)
+			sb_puts(out, space);
+		emit_value_indented(out, element, space, indent_level + 1);
+
+		element = element->next;
+		sb_puts(out, element != NULL ? ",\n" : "\n");
+	}
+	for (i = 0; i < indent_level; i++)
+		sb_puts(out, space);
+	sb_putc(out, ']');
+}
+
+static void emit_object(SB *out, const JsonNode *object)
+{
+	const JsonNode *member;
+
+	sb_putc(out, '{');
+	json_foreach(member, object)
+	{
+		emit_string(out, member->key);
+		sb_putc(out, ':');
+		emit_value(out, member);
+		if (member->next != NULL)
+			sb_putc(out, ',');
+	}
+	sb_putc(out, '}');
+}
+
+static void emit_object_indented(SB *out, const JsonNode *object, const char *space, int indent_level)
+{
+	const JsonNode *member = object->children.head;
+	int i;
+
+	if (member == NULL)
+	{
+		sb_puts(out, "{}");
+		return;
+	}
+
+	sb_puts(out, "{\n");
+	while (member != NULL)
+	{
+		for (i = 0; i < indent_level + 1; i++)
+			sb_puts(out, space);
+		emit_string(out, member->key);
+		sb_puts(out, ": ");
+		emit_value_indented(out, member, space, indent_level + 1);
+
+		member = member->next;
+		sb_puts(out, member != NULL ? ",\n" : "\n");
+	}
+	for (i = 0; i < indent_level; i++)
+		sb_puts(out, space);
+	sb_putc(out, '}');
+}
+
+void emit_string(SB *out, const char *str)
+{
+	bool escape_unicode = false;
+	const char *s = str;
+	char *b;
+
+	assert(utf8_validate(str));
+
+	/*
+	 * 14 bytes is enough space to write up to two
+	 * \uXXXX escapes and two quotation marks.
+	 */
+	sb_need(out, 14);
+	b = out->cur;
+
+	*b++ = '"';
+	while (*s != 0)
+	{
+		unsigned char c = *s++;
+
+		/* Encode the next character, and write it to b. */
+		switch (c)
+		{
+		case '"':
+			*b++ = '\\';
+			*b++ = '"';
+			break;
+		case '\\':
+			*b++ = '\\';
+			*b++ = '\\';
+			break;
+		case '\b':
+			*b++ = '\\';
+			*b++ = 'b';
+			break;
+		case '\f':
+			*b++ = '\\';
+			*b++ = 'f';
+			break;
+		case '\n':
+			*b++ = '\\';
+			*b++ = 'n';
+			break;
+		case '\r':
+			*b++ = '\\';
+			*b++ = 'r';
+			break;
+		case '\t':
+			*b++ = '\\';
+			*b++ = 't';
+			break;
+		default:
+		{
+			int len;
+
+			s--;
+			len = utf8_validate_cz(s);
+
+			if (len == 0)
+			{
+				/*
+				 * Handle invalid UTF-8 character gracefully in production
+				 * by writing a replacement character (U+FFFD)
+				 * and skipping a single byte.
+				 *
+				 * This should never happen when assertions are enabled
+				 * due to the assertion at the beginning of this function.
+				 */
+				assert(false);
+				if (escape_unicode)
+				{
+					strcpy(b, "\\uFFFD");
+					b += 6;
+				}
+				else
+				{
+					*b++ = 0xEF;
+					*b++ = 0xBF;
+					*b++ = 0xBD;
+				}
+				s++;
+			}
+			else if (c < 0x1F || (c >= 0x80 && escape_unicode))
+			{
+				/* Encode using \u.... */
+				uint32_t unicode;
+
+				s += utf8_read_char(s, &unicode);
+
+				if (unicode <= 0xFFFF)
+				{
+					*b++ = '\\';
+					*b++ = 'u';
+					b += write_hex16(b, unicode);
+				}
+				else
+				{
+					/* Produce a surrogate pair. */
+					uint16_t uc, lc;
+					assert(unicode <= 0x10FFFF);
+					to_surrogate_pair(unicode, &uc, &lc);
+					*b++ = '\\';
+					*b++ = 'u';
+					b += write_hex16(b, uc);
+					*b++ = '\\';
+					*b++ = 'u';
+					b += write_hex16(b, lc);
+				}
+			}
+			else
+			{
+				/* Write the character directly. */
+				while (len--)
+					*b++ = *s++;
+			}
+
+			break;
+		}
+		}
+
+		/*
+		 * Update *out to know about the new bytes,
+		 * and set up b to write another encoded character.
+		 */
+		out->cur = b;
+		sb_need(out, 14);
+		b = out->cur;
+	}
+	*b++ = '"';
+
+	out->cur = b;
+}
+
+static void emit_number(SB *out, double num)
+{
+	/*
+	 * This isn't exactly how JavaScript renders numbers,
+	 * but it should produce valid JSON for reasonable numbers
+	 * preserve precision well enough, and avoid some oddities
+	 * like 0.3 -> 0.299999999999999988898 .
+	 */
+	char buf[64];
+	sprintf(buf, "%.16g", num);
+
+	if (number_is_valid(buf))
+		sb_puts(out, buf);
+	else
+		sb_puts(out, "null");
+}
+
+static bool tag_is_valid(unsigned int tag)
+{
+	return (/* tag >= JSON_NULL && */ tag <= JSON_OBJECT);
+}
+
+static bool number_is_valid(const char *num)
+{
+	return (parse_number(&num, NULL) && *num == '\0');
+}
+
+static bool expect_literal(const char **sp, const char *str)
+{
+	const char *s = *sp;
+
+	while (*str != '\0')
+		if (*s++ != *str++)
+			return false;
+
+	*sp = s;
+	return true;
+}
+
+/*
+ * Parses exactly 4 hex characters (capital or lowercase).
+ * Fails if any input chars are not [0-9A-Fa-f].
+ */
+static bool parse_hex16(const char **sp, uint16_t *out)
+{
+	const char *s = *sp;
+	uint16_t ret = 0;
+	uint16_t i;
+	uint16_t tmp;
+	char c;
+
+	for (i = 0; i < 4; i++)
+	{
+		c = *s++;
+		if (c >= '0' && c <= '9')
+			tmp = c - '0';
+		else if (c >= 'A' && c <= 'F')
+			tmp = c - 'A' + 10;
+		else if (c >= 'a' && c <= 'f')
+			tmp = c - 'a' + 10;
+		else
+			return false;
+
+		ret <<= 4;
+		ret += tmp;
+	}
+
+	if (out)
+		*out = ret;
+	*sp = s;
+	return true;
+}
+
+/*
+ * Encodes a 16-bit number into hexadecimal,
+ * writing exactly 4 hex chars.
+ */
+static int write_hex16(char *out, uint16_t val)
+{
+	const char *hex = "0123456789ABCDEF";
+
+	*out++ = hex[(val >> 12) & 0xF];
+	*out++ = hex[(val >> 8) & 0xF];
+	*out++ = hex[(val >> 4) & 0xF];
+	*out++ = hex[val & 0xF];
+
+	return 4;
+}
+
+bool json_check(const JsonNode *node, char errmsg[256])
+{
+#define problem(...)                            \
+	do                                          \
+	{                                           \
+		if (errmsg != NULL)                     \
+			snprintf(errmsg, 256, __VA_ARGS__); \
+		return false;                           \
+	} while (0)
+
+	if (node->key != NULL && !utf8_validate(node->key))
+		problem("key contains invalid UTF-8");
+
+	if (!tag_is_valid(node->tag))
+		problem("tag is invalid (%u)", node->tag);
+
+	if (node->tag == JSON_BOOL)
+	{
+		if (node->bool_ != false && node->bool_ != true)
+			problem("bool_ is neither false (%d) nor true (%d)", (int)false, (int)true);
+	}
+	else if (node->tag == JSON_STRING)
+	{
+		if (node->string_ == NULL)
+			problem("string_ is NULL");
+		if (!utf8_validate(node->string_))
+			problem("string_ contains invalid UTF-8");
+	}
+	else if (node->tag == JSON_ARRAY || node->tag == JSON_OBJECT)
+	{
+		JsonNode *head = node->children.head;
+		JsonNode *tail = node->children.tail;
+
+		if (head == NULL || tail == NULL)
+		{
+			if (head != NULL)
+				problem("tail is NULL, but head is not");
+			if (tail != NULL)
+				problem("head is NULL, but tail is not");
+		}
+		else
+		{
+			JsonNode *child;
+			JsonNode *last = NULL;
+
+			if (head->prev != NULL)
+				problem("First child's prev pointer is not NULL");
+
+			for (child = head; child != NULL; last = child, child = child->next)
+			{
+				if (child == node)
+					problem("node is its own child");
+				if (child->next == child)
+					problem("child->next == child (cycle)");
+				if (child->next == head)
+					problem("child->next == head (cycle)");
+
+				if (child->parent != node)
+					problem("child does not point back to parent");
+				if (child->next != NULL && child->next->prev != child)
+					problem("child->next does not point back to child");
+
+				if (node->tag == JSON_ARRAY && child->key != NULL)
+					problem("Array element's key is not NULL");
+				if (node->tag == JSON_OBJECT && child->key == NULL)
+					problem("Object member's key is NULL");
+
+				if (!json_check(child, errmsg))
+					return false;
+			}
+
+			if (last != tail)
+				problem("tail does not match pointer found by starting at head and following next links");
+		}
+	}
+
+	return true;
+
+#undef problem
+}
```

## chaine/_core/crfsuite/lib/crf/src/json.h

 * *Ordering differences only*

```diff
@@ -1,120 +1,120 @@
-/*
-  Copyright (C) 2011 Joseph A. Adams (joeyadams3.14159@gmail.com)
-  All rights reserved.
-
-  Permission is hereby granted, free of charge, to any person obtaining a copy
-  of this software and associated documentation files (the "Software"), to deal
-  in the Software without restriction, including without limitation the rights
-  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-  copies of the Software, and to permit persons to whom the Software is
-  furnished to do so, subject to the following conditions:
-
-  The above copyright notice and this permission notice shall be included in
-  all copies or substantial portions of the Software.
-
-  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
-  THE SOFTWARE.
-*/
-
-#ifndef CCAN_JSON_H
-#define CCAN_JSON_H
-
-#include <stdbool.h>
-#include <stddef.h>
-
-typedef enum
-{
-	JSON_NULL,
-	JSON_BOOL,
-	JSON_STRING,
-	JSON_NUMBER,
-	JSON_ARRAY,
-	JSON_OBJECT,
-} JsonTag;
-
-typedef struct JsonNode JsonNode;
-
-struct JsonNode
-{
-	/* only if parent is an object or array (NULL otherwise) */
-	JsonNode *parent;
-	JsonNode *prev, *next;
-
-	/* only if parent is an object (NULL otherwise) */
-	char *key; /* Must be valid UTF-8. */
-
-	JsonTag tag;
-	union
-	{
-		/* JSON_BOOL */
-		bool bool_;
-
-		/* JSON_STRING */
-		char *string_; /* Must be valid UTF-8. */
-
-		/* JSON_NUMBER */
-		double number_;
-
-		/* JSON_ARRAY */
-		/* JSON_OBJECT */
-		struct
-		{
-			JsonNode *head, *tail;
-		} children;
-	};
-};
-
-/*** Encoding, decoding, and validation ***/
-
-JsonNode *json_decode(const char *json);
-char *json_encode(const JsonNode *node);
-char *json_encode_string(const char *str);
-char *json_stringify(const JsonNode *node, const char *space);
-void json_delete(JsonNode *node);
-
-bool json_validate(const char *json);
-
-/*** Lookup and traversal ***/
-
-JsonNode *json_find_element(JsonNode *array, int index);
-JsonNode *json_find_member(JsonNode *object, const char *name);
-
-JsonNode *json_first_child(const JsonNode *node);
-
-#define json_foreach(i, object_or_array)          \
-	for ((i) = json_first_child(object_or_array); \
-		 (i) != NULL;                             \
-		 (i) = (i)->next)
-
-/*** Construction and manipulation ***/
-
-JsonNode *json_mknull(void);
-JsonNode *json_mkbool(bool b);
-JsonNode *json_mkstring(const char *s);
-JsonNode *json_mknumber(double n);
-JsonNode *json_mkarray(void);
-JsonNode *json_mkobject(void);
-
-void json_append_element(JsonNode *array, JsonNode *element);
-void json_prepend_element(JsonNode *array, JsonNode *element);
-void json_append_member(JsonNode *object, const char *key, JsonNode *value);
-void json_prepend_member(JsonNode *object, const char *key, JsonNode *value);
-
-void json_remove_from_parent(JsonNode *node);
-
-/*** Debugging ***/
-
-/*
- * Look for structure and encoding problems in a JsonNode or its descendents.
- *
- * If a problem is detected, return false, writing a description of the problem
- * to errmsg (unless errmsg is NULL).
- */
-bool json_check(const JsonNode *node, char errmsg[256]);
-
-#endif
+/*
+  Copyright (C) 2011 Joseph A. Adams (joeyadams3.14159@gmail.com)
+  All rights reserved.
+
+  Permission is hereby granted, free of charge, to any person obtaining a copy
+  of this software and associated documentation files (the "Software"), to deal
+  in the Software without restriction, including without limitation the rights
+  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+  copies of the Software, and to permit persons to whom the Software is
+  furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included in
+  all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+  THE SOFTWARE.
+*/
+
+#ifndef CCAN_JSON_H
+#define CCAN_JSON_H
+
+#include <stdbool.h>
+#include <stddef.h>
+
+typedef enum
+{
+	JSON_NULL,
+	JSON_BOOL,
+	JSON_STRING,
+	JSON_NUMBER,
+	JSON_ARRAY,
+	JSON_OBJECT,
+} JsonTag;
+
+typedef struct JsonNode JsonNode;
+
+struct JsonNode
+{
+	/* only if parent is an object or array (NULL otherwise) */
+	JsonNode *parent;
+	JsonNode *prev, *next;
+
+	/* only if parent is an object (NULL otherwise) */
+	char *key; /* Must be valid UTF-8. */
+
+	JsonTag tag;
+	union
+	{
+		/* JSON_BOOL */
+		bool bool_;
+
+		/* JSON_STRING */
+		char *string_; /* Must be valid UTF-8. */
+
+		/* JSON_NUMBER */
+		double number_;
+
+		/* JSON_ARRAY */
+		/* JSON_OBJECT */
+		struct
+		{
+			JsonNode *head, *tail;
+		} children;
+	};
+};
+
+/*** Encoding, decoding, and validation ***/
+
+JsonNode *json_decode(const char *json);
+char *json_encode(const JsonNode *node);
+char *json_encode_string(const char *str);
+char *json_stringify(const JsonNode *node, const char *space);
+void json_delete(JsonNode *node);
+
+bool json_validate(const char *json);
+
+/*** Lookup and traversal ***/
+
+JsonNode *json_find_element(JsonNode *array, int index);
+JsonNode *json_find_member(JsonNode *object, const char *name);
+
+JsonNode *json_first_child(const JsonNode *node);
+
+#define json_foreach(i, object_or_array)          \
+	for ((i) = json_first_child(object_or_array); \
+		 (i) != NULL;                             \
+		 (i) = (i)->next)
+
+/*** Construction and manipulation ***/
+
+JsonNode *json_mknull(void);
+JsonNode *json_mkbool(bool b);
+JsonNode *json_mkstring(const char *s);
+JsonNode *json_mknumber(double n);
+JsonNode *json_mkarray(void);
+JsonNode *json_mkobject(void);
+
+void json_append_element(JsonNode *array, JsonNode *element);
+void json_prepend_element(JsonNode *array, JsonNode *element);
+void json_append_member(JsonNode *object, const char *key, JsonNode *value);
+void json_prepend_member(JsonNode *object, const char *key, JsonNode *value);
+
+void json_remove_from_parent(JsonNode *node);
+
+/*** Debugging ***/
+
+/*
+ * Look for structure and encoding problems in a JsonNode or its descendents.
+ *
+ * If a problem is detected, return false, writing a description of the problem
+ * to errmsg (unless errmsg is NULL).
+ */
+bool json_check(const JsonNode *node, char errmsg[256]);
+
+#endif
```

## chaine/_core/crfsuite/lib/crf/src/logging.c

 * *Ordering differences only*

```diff
@@ -1,85 +1,85 @@
-/*
- *      Logging utility.
- *
- * Copyright (c) 2007-2010, Naoaki Okazaki
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the names of the authors nor the names of its contributors
- *       may be used to endorse or promote products derived from this
- *       software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
- * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-/* $Id$ */
-
-#include <os.h>
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <time.h>
-
-#include <crfsuite.h>
-#include "logging.h"
-
-void logging(logging_t *lg, const char *format, ...)
-{
-    va_list args;
-    va_start(args, format);
-
-    if (lg != NULL && lg->func != NULL)
-    {
-        lg->func(lg->instance, format, args);
-    }
-}
-
-void logging_timestamp(logging_t *lg, const char *format)
-{
-    time_t ts;
-    char timestamp[80];
-
-    time(&ts);
-    strftime(
-        timestamp, sizeof(timestamp),
-        "%Y-%m-%dT%H:%M:%SZ",
-        gmtime(&ts));
-    logging(lg, format, timestamp);
-}
-
-void logging_progress(logging_t *lg, int percent)
-{
-    while (lg->percent < percent)
-    {
-        ++lg->percent;
-        if (lg->percent % 2 == 0)
-        {
-            if (lg->percent % 10 == 0)
-            {
-                logging(lg, "Processed %d%% of the training data", lg->percent);
-            }
-        }
-    }
-}
-
-void logging_progress_end(logging_t *lg)
-{
-    logging_progress(lg, 100);
-}
+/*
+ *      Logging utility.
+ *
+ * Copyright (c) 2007-2010, Naoaki Okazaki
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the names of the authors nor the names of its contributors
+ *       may be used to endorse or promote products derived from this
+ *       software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+ * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/* $Id$ */
+
+#include <os.h>
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <time.h>
+
+#include <crfsuite.h>
+#include "logging.h"
+
+void logging(logging_t *lg, const char *format, ...)
+{
+    va_list args;
+    va_start(args, format);
+
+    if (lg != NULL && lg->func != NULL)
+    {
+        lg->func(lg->instance, format, args);
+    }
+}
+
+void logging_timestamp(logging_t *lg, const char *format)
+{
+    time_t ts;
+    char timestamp[80];
+
+    time(&ts);
+    strftime(
+        timestamp, sizeof(timestamp),
+        "%Y-%m-%dT%H:%M:%SZ",
+        gmtime(&ts));
+    logging(lg, format, timestamp);
+}
+
+void logging_progress(logging_t *lg, int percent)
+{
+    while (lg->percent < percent)
+    {
+        ++lg->percent;
+        if (lg->percent % 2 == 0)
+        {
+            if (lg->percent % 10 == 0)
+            {
+                logging(lg, "Processed %d%% of the training data", lg->percent);
+            }
+        }
+    }
+}
+
+void logging_progress_end(logging_t *lg)
+{
+    logging_progress(lg, 100);
+}
```

## chaine/_core/crfsuite/lib/crf/src/logging.h

 * *Ordering differences only*

```diff
@@ -1,49 +1,49 @@
-/*
- *      Logging utility.
- *
- * Copyright (c) 2007-2010, Naoaki Okazaki
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the names of the authors nor the names of its contributors
- *       may be used to endorse or promote products derived from this
- *       software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
- * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-/* $Id$ */
-
-#ifndef __LOGGING_H__
-#define __LOGGING_H__
-
-typedef struct
-{
-    void *instance;
-    crfsuite_logging_callback func;
-    int percent;
-} logging_t;
-
-void logging(logging_t *lg, const char *format, ...);
-void logging_timestamp(logging_t *lg, const char *format);
-void logging_progress_start(logging_t *lg);
-void logging_progress(logging_t *lg, int percent);
-void logging_progress_end(logging_t *lg);
-
-#endif /*__LOGGING_H__*/
+/*
+ *      Logging utility.
+ *
+ * Copyright (c) 2007-2010, Naoaki Okazaki
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the names of the authors nor the names of its contributors
+ *       may be used to endorse or promote products derived from this
+ *       software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+ * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/* $Id$ */
+
+#ifndef __LOGGING_H__
+#define __LOGGING_H__
+
+typedef struct
+{
+    void *instance;
+    crfsuite_logging_callback func;
+    int percent;
+} logging_t;
+
+void logging(logging_t *lg, const char *format, ...);
+void logging_timestamp(logging_t *lg, const char *format);
+void logging_progress_start(logging_t *lg);
+void logging_progress(logging_t *lg, int percent);
+void logging_progress_end(logging_t *lg);
+
+#endif /*__LOGGING_H__*/
```

## chaine/_core/crfsuite/lib/crf/src/params.c

 * *Ordering differences only*

```diff
@@ -1,370 +1,370 @@
-/*
- *      Parameter exchange.
- *
- * Copyright (c) 2007-2010, Naoaki Okazaki
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the names of the authors nor the names of its contributors
- *       may be used to endorse or promote products derived from this
- *       software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
- * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-/* $Id$ */
-
-#include <os.h>
-
-#include <stdlib.h>
-#include <string.h>
-
-#include <crfsuite.h>
-#include "quark.h"
-
-enum
-{
-    PT_NONE = 0,
-    PT_INT,
-    PT_FLOAT,
-    PT_STRING,
-};
-
-typedef struct
-{
-    char *name;
-    int type;
-    int val_i;
-    floatval_t val_f;
-    char *val_s;
-    char *help;
-} param_t;
-
-typedef struct
-{
-    int num_params;
-    param_t *params;
-} params_t;
-
-static char *mystrdup(const char *src)
-{
-    char *dst = (char *)malloc(strlen(src) + 1);
-    if (dst != NULL)
-    {
-        strcpy(dst, src);
-    }
-    return dst;
-}
-
-static int params_addref(crfsuite_params_t *params)
-{
-    return crfsuite_interlocked_increment(&params->nref);
-}
-
-static int params_release(crfsuite_params_t *params)
-{
-    int count = crfsuite_interlocked_decrement(&params->nref);
-    if (count == 0)
-    {
-        int i;
-        params_t *pars = (params_t *)params->internal;
-        for (i = 0; i < pars->num_params; ++i)
-        {
-            free(pars->params[i].name);
-            free(pars->params[i].val_s);
-            free(pars->params[i].help);
-        }
-        free(pars->params);
-        free(pars);
-        free(params);
-    }
-    return count;
-}
-
-static param_t *find_param(params_t *pars, const char *name)
-{
-    int i;
-
-    for (i = 0; i < pars->num_params; ++i)
-    {
-        if (strcmp(pars->params[i].name, name) == 0)
-        {
-            return &pars->params[i];
-        }
-    }
-
-    return NULL;
-}
-
-static int params_num(crfsuite_params_t *params)
-{
-    params_t *pars = (params_t *)params->internal;
-    return pars->num_params;
-}
-
-static int params_name(crfsuite_params_t *params, int i, char **ptr_name)
-{
-    params_t *pars = (params_t *)params->internal;
-    *ptr_name = mystrdup(pars->params[i].name);
-    return 0;
-}
-
-static int params_set(crfsuite_params_t *params, const char *name, const char *value)
-{
-    params_t *pars = (params_t *)params->internal;
-    param_t *par = find_param(pars, name);
-    if (par == NULL)
-        return -1;
-    switch (par->type)
-    {
-    case PT_INT:
-        par->val_i = (value != NULL) ? atoi(value) : 0;
-        break;
-    case PT_FLOAT:
-        par->val_f = (value != NULL) ? (floatval_t)atof(value) : 0;
-        break;
-    case PT_STRING:
-        free(par->val_s);
-        par->val_s = (value != NULL) ? mystrdup(value) : mystrdup("");
-    }
-    return 0;
-}
-
-static int params_get(crfsuite_params_t *params, const char *name, char **value)
-{
-    char buffer[1024];
-    params_t *pars = (params_t *)params->internal;
-    param_t *par = find_param(pars, name);
-    if (par == NULL)
-        return -1;
-    switch (par->type)
-    {
-    case PT_INT:
-        snprintf(buffer, sizeof(buffer) - 1, "%d", par->val_i);
-        *value = mystrdup(buffer);
-        break;
-    case PT_FLOAT:
-        snprintf(buffer, sizeof(buffer) - 1, "%f", par->val_f);
-        *value = mystrdup(buffer);
-        break;
-    case PT_STRING:
-        *value = mystrdup(par->val_s);
-    }
-    return 0;
-}
-
-static void params_free(crfsuite_params_t *params, const char *value)
-{
-    free((char *)value);
-}
-
-static int params_set_int(crfsuite_params_t *params, const char *name, int value)
-{
-    params_t *pars = (params_t *)params->internal;
-    param_t *par = find_param(pars, name);
-    if (par == NULL)
-        return -1;
-    if (par->type != PT_INT)
-        return -1;
-    par->val_i = value;
-    return 0;
-}
-
-static int params_set_float(crfsuite_params_t *params, const char *name, floatval_t value)
-{
-    params_t *pars = (params_t *)params->internal;
-    param_t *par = find_param(pars, name);
-    if (par == NULL)
-        return -1;
-    if (par->type != PT_FLOAT)
-        return -1;
-    par->val_f = value;
-    return 0;
-}
-
-static int params_set_string(crfsuite_params_t *params, const char *name, const char *value)
-{
-    params_t *pars = (params_t *)params->internal;
-    param_t *par = find_param(pars, name);
-    if (par == NULL)
-        return -1;
-    if (par->type != PT_STRING)
-        return -1;
-    free(par->val_s);
-    par->val_s = mystrdup(value);
-    return 0;
-}
-
-static int params_get_int(crfsuite_params_t *params, const char *name, int *value)
-{
-    params_t *pars = (params_t *)params->internal;
-    param_t *par = find_param(pars, name);
-    if (par == NULL)
-        return -1;
-    if (par->type != PT_INT)
-        return -1;
-    *value = par->val_i;
-    return 0;
-}
-
-static int params_get_float(crfsuite_params_t *params, const char *name, floatval_t *value)
-{
-    params_t *pars = (params_t *)params->internal;
-    param_t *par = find_param(pars, name);
-    if (par == NULL)
-        return -1;
-    if (par->type != PT_FLOAT)
-        return -1;
-    *value = par->val_f;
-    return 0;
-}
-
-static int params_get_string(crfsuite_params_t *params, const char *name, char **value)
-{
-    params_t *pars = (params_t *)params->internal;
-    param_t *par = find_param(pars, name);
-    if (par == NULL)
-        return -1;
-    if (par->type != PT_STRING)
-        return -1;
-    *value = par->val_s;
-    return 0;
-}
-
-static int params_help(crfsuite_params_t *params, const char *name, char **ptr_type, char **ptr_help)
-{
-    params_t *pars = (params_t *)params->internal;
-    param_t *par = find_param(pars, name);
-    if (par == NULL)
-        return -1;
-    if (ptr_type != NULL)
-    {
-        switch (par->type)
-        {
-        case PT_INT:
-            *ptr_type = mystrdup("int");
-            break;
-        case PT_FLOAT:
-            *ptr_type = mystrdup("float");
-            break;
-        case PT_STRING:
-            *ptr_type = mystrdup("string");
-            break;
-        default:
-            *ptr_type = mystrdup("unknown");
-        }
-    }
-    if (ptr_help != NULL)
-    {
-        *ptr_help = mystrdup(par->help);
-    }
-    return 0;
-}
-
-crfsuite_params_t *params_create_instance()
-{
-    crfsuite_params_t *params = (crfsuite_params_t *)calloc(1, sizeof(crfsuite_params_t));
-
-    if (params != NULL)
-    {
-        /* Construct the internal data. */
-        params->internal = (params_t *)calloc(1, sizeof(params_t));
-        if (params->internal == NULL)
-        {
-            free(params);
-            return NULL;
-        }
-
-        /* Set member functions. */
-        params->nref = 1;
-        params->addref = params_addref;
-        params->release = params_release;
-        params->num = params_num;
-        params->name = params_name;
-        params->set = params_set;
-        params->get = params_get;
-        params->free = params_free;
-        params->set_int = params_set_int;
-        params->set_float = params_set_float;
-        params->set_string = params_set_string;
-        params->get_int = params_get_int;
-        params->get_float = params_get_float;
-        params->get_string = params_get_string;
-        params->help = params_help;
-    }
-
-    return params;
-}
-
-int params_add_int(crfsuite_params_t *params, const char *name, int value, const char *help)
-{
-    param_t *par = NULL;
-    params_t *pars = (params_t *)params->internal;
-    pars->params = (param_t *)realloc(pars->params, (pars->num_params + 1) * sizeof(param_t));
-    if (pars->params == NULL)
-    {
-        return -1;
-    }
-
-    par = &pars->params[pars->num_params++];
-    memset(par, 0, sizeof(*par));
-    par->name = mystrdup(name);
-    par->type = PT_INT;
-    par->val_i = value;
-    par->help = mystrdup(help);
-    return 0;
-}
-
-int params_add_float(crfsuite_params_t *params, const char *name, floatval_t value, const char *help)
-{
-    param_t *par = NULL;
-    params_t *pars = (params_t *)params->internal;
-    pars->params = (param_t *)realloc(pars->params, (pars->num_params + 1) * sizeof(param_t));
-    if (pars->params == NULL)
-    {
-        return -1;
-    }
-
-    par = &pars->params[pars->num_params++];
-    memset(par, 0, sizeof(*par));
-    par->name = mystrdup(name);
-    par->type = PT_FLOAT;
-    par->val_f = value;
-    par->help = mystrdup(help);
-    return 0;
-}
-
-int params_add_string(crfsuite_params_t *params, const char *name, const char *value, const char *help)
-{
-    param_t *par = NULL;
-    params_t *pars = (params_t *)params->internal;
-    pars->params = (param_t *)realloc(pars->params, (pars->num_params + 1) * sizeof(param_t));
-    if (pars->params == NULL)
-    {
-        return -1;
-    }
-
-    par = &pars->params[pars->num_params++];
-    memset(par, 0, sizeof(*par));
-    par->name = mystrdup(name);
-    par->type = PT_STRING;
-    par->val_s = mystrdup(value);
-    par->help = mystrdup(help);
-    return 0;
-}
+/*
+ *      Parameter exchange.
+ *
+ * Copyright (c) 2007-2010, Naoaki Okazaki
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the names of the authors nor the names of its contributors
+ *       may be used to endorse or promote products derived from this
+ *       software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+ * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/* $Id$ */
+
+#include <os.h>
+
+#include <stdlib.h>
+#include <string.h>
+
+#include <crfsuite.h>
+#include "quark.h"
+
+enum
+{
+    PT_NONE = 0,
+    PT_INT,
+    PT_FLOAT,
+    PT_STRING,
+};
+
+typedef struct
+{
+    char *name;
+    int type;
+    int val_i;
+    floatval_t val_f;
+    char *val_s;
+    char *help;
+} param_t;
+
+typedef struct
+{
+    int num_params;
+    param_t *params;
+} params_t;
+
+static char *mystrdup(const char *src)
+{
+    char *dst = (char *)malloc(strlen(src) + 1);
+    if (dst != NULL)
+    {
+        strcpy(dst, src);
+    }
+    return dst;
+}
+
+static int params_addref(crfsuite_params_t *params)
+{
+    return crfsuite_interlocked_increment(&params->nref);
+}
+
+static int params_release(crfsuite_params_t *params)
+{
+    int count = crfsuite_interlocked_decrement(&params->nref);
+    if (count == 0)
+    {
+        int i;
+        params_t *pars = (params_t *)params->internal;
+        for (i = 0; i < pars->num_params; ++i)
+        {
+            free(pars->params[i].name);
+            free(pars->params[i].val_s);
+            free(pars->params[i].help);
+        }
+        free(pars->params);
+        free(pars);
+        free(params);
+    }
+    return count;
+}
+
+static param_t *find_param(params_t *pars, const char *name)
+{
+    int i;
+
+    for (i = 0; i < pars->num_params; ++i)
+    {
+        if (strcmp(pars->params[i].name, name) == 0)
+        {
+            return &pars->params[i];
+        }
+    }
+
+    return NULL;
+}
+
+static int params_num(crfsuite_params_t *params)
+{
+    params_t *pars = (params_t *)params->internal;
+    return pars->num_params;
+}
+
+static int params_name(crfsuite_params_t *params, int i, char **ptr_name)
+{
+    params_t *pars = (params_t *)params->internal;
+    *ptr_name = mystrdup(pars->params[i].name);
+    return 0;
+}
+
+static int params_set(crfsuite_params_t *params, const char *name, const char *value)
+{
+    params_t *pars = (params_t *)params->internal;
+    param_t *par = find_param(pars, name);
+    if (par == NULL)
+        return -1;
+    switch (par->type)
+    {
+    case PT_INT:
+        par->val_i = (value != NULL) ? atoi(value) : 0;
+        break;
+    case PT_FLOAT:
+        par->val_f = (value != NULL) ? (floatval_t)atof(value) : 0;
+        break;
+    case PT_STRING:
+        free(par->val_s);
+        par->val_s = (value != NULL) ? mystrdup(value) : mystrdup("");
+    }
+    return 0;
+}
+
+static int params_get(crfsuite_params_t *params, const char *name, char **value)
+{
+    char buffer[1024];
+    params_t *pars = (params_t *)params->internal;
+    param_t *par = find_param(pars, name);
+    if (par == NULL)
+        return -1;
+    switch (par->type)
+    {
+    case PT_INT:
+        snprintf(buffer, sizeof(buffer) - 1, "%d", par->val_i);
+        *value = mystrdup(buffer);
+        break;
+    case PT_FLOAT:
+        snprintf(buffer, sizeof(buffer) - 1, "%f", par->val_f);
+        *value = mystrdup(buffer);
+        break;
+    case PT_STRING:
+        *value = mystrdup(par->val_s);
+    }
+    return 0;
+}
+
+static void params_free(crfsuite_params_t *params, const char *value)
+{
+    free((char *)value);
+}
+
+static int params_set_int(crfsuite_params_t *params, const char *name, int value)
+{
+    params_t *pars = (params_t *)params->internal;
+    param_t *par = find_param(pars, name);
+    if (par == NULL)
+        return -1;
+    if (par->type != PT_INT)
+        return -1;
+    par->val_i = value;
+    return 0;
+}
+
+static int params_set_float(crfsuite_params_t *params, const char *name, floatval_t value)
+{
+    params_t *pars = (params_t *)params->internal;
+    param_t *par = find_param(pars, name);
+    if (par == NULL)
+        return -1;
+    if (par->type != PT_FLOAT)
+        return -1;
+    par->val_f = value;
+    return 0;
+}
+
+static int params_set_string(crfsuite_params_t *params, const char *name, const char *value)
+{
+    params_t *pars = (params_t *)params->internal;
+    param_t *par = find_param(pars, name);
+    if (par == NULL)
+        return -1;
+    if (par->type != PT_STRING)
+        return -1;
+    free(par->val_s);
+    par->val_s = mystrdup(value);
+    return 0;
+}
+
+static int params_get_int(crfsuite_params_t *params, const char *name, int *value)
+{
+    params_t *pars = (params_t *)params->internal;
+    param_t *par = find_param(pars, name);
+    if (par == NULL)
+        return -1;
+    if (par->type != PT_INT)
+        return -1;
+    *value = par->val_i;
+    return 0;
+}
+
+static int params_get_float(crfsuite_params_t *params, const char *name, floatval_t *value)
+{
+    params_t *pars = (params_t *)params->internal;
+    param_t *par = find_param(pars, name);
+    if (par == NULL)
+        return -1;
+    if (par->type != PT_FLOAT)
+        return -1;
+    *value = par->val_f;
+    return 0;
+}
+
+static int params_get_string(crfsuite_params_t *params, const char *name, char **value)
+{
+    params_t *pars = (params_t *)params->internal;
+    param_t *par = find_param(pars, name);
+    if (par == NULL)
+        return -1;
+    if (par->type != PT_STRING)
+        return -1;
+    *value = par->val_s;
+    return 0;
+}
+
+static int params_help(crfsuite_params_t *params, const char *name, char **ptr_type, char **ptr_help)
+{
+    params_t *pars = (params_t *)params->internal;
+    param_t *par = find_param(pars, name);
+    if (par == NULL)
+        return -1;
+    if (ptr_type != NULL)
+    {
+        switch (par->type)
+        {
+        case PT_INT:
+            *ptr_type = mystrdup("int");
+            break;
+        case PT_FLOAT:
+            *ptr_type = mystrdup("float");
+            break;
+        case PT_STRING:
+            *ptr_type = mystrdup("string");
+            break;
+        default:
+            *ptr_type = mystrdup("unknown");
+        }
+    }
+    if (ptr_help != NULL)
+    {
+        *ptr_help = mystrdup(par->help);
+    }
+    return 0;
+}
+
+crfsuite_params_t *params_create_instance()
+{
+    crfsuite_params_t *params = (crfsuite_params_t *)calloc(1, sizeof(crfsuite_params_t));
+
+    if (params != NULL)
+    {
+        /* Construct the internal data. */
+        params->internal = (params_t *)calloc(1, sizeof(params_t));
+        if (params->internal == NULL)
+        {
+            free(params);
+            return NULL;
+        }
+
+        /* Set member functions. */
+        params->nref = 1;
+        params->addref = params_addref;
+        params->release = params_release;
+        params->num = params_num;
+        params->name = params_name;
+        params->set = params_set;
+        params->get = params_get;
+        params->free = params_free;
+        params->set_int = params_set_int;
+        params->set_float = params_set_float;
+        params->set_string = params_set_string;
+        params->get_int = params_get_int;
+        params->get_float = params_get_float;
+        params->get_string = params_get_string;
+        params->help = params_help;
+    }
+
+    return params;
+}
+
+int params_add_int(crfsuite_params_t *params, const char *name, int value, const char *help)
+{
+    param_t *par = NULL;
+    params_t *pars = (params_t *)params->internal;
+    pars->params = (param_t *)realloc(pars->params, (pars->num_params + 1) * sizeof(param_t));
+    if (pars->params == NULL)
+    {
+        return -1;
+    }
+
+    par = &pars->params[pars->num_params++];
+    memset(par, 0, sizeof(*par));
+    par->name = mystrdup(name);
+    par->type = PT_INT;
+    par->val_i = value;
+    par->help = mystrdup(help);
+    return 0;
+}
+
+int params_add_float(crfsuite_params_t *params, const char *name, floatval_t value, const char *help)
+{
+    param_t *par = NULL;
+    params_t *pars = (params_t *)params->internal;
+    pars->params = (param_t *)realloc(pars->params, (pars->num_params + 1) * sizeof(param_t));
+    if (pars->params == NULL)
+    {
+        return -1;
+    }
+
+    par = &pars->params[pars->num_params++];
+    memset(par, 0, sizeof(*par));
+    par->name = mystrdup(name);
+    par->type = PT_FLOAT;
+    par->val_f = value;
+    par->help = mystrdup(help);
+    return 0;
+}
+
+int params_add_string(crfsuite_params_t *params, const char *name, const char *value, const char *help)
+{
+    param_t *par = NULL;
+    params_t *pars = (params_t *)params->internal;
+    pars->params = (param_t *)realloc(pars->params, (pars->num_params + 1) * sizeof(param_t));
+    if (pars->params == NULL)
+    {
+        return -1;
+    }
+
+    par = &pars->params[pars->num_params++];
+    memset(par, 0, sizeof(*par));
+    par->name = mystrdup(name);
+    par->type = PT_STRING;
+    par->val_s = mystrdup(value);
+    par->help = mystrdup(help);
+    return 0;
+}
```

## chaine/_core/crfsuite/lib/crf/src/params.h

 * *Ordering differences only*

```diff
@@ -1,84 +1,84 @@
-/*
- *      Parameter exchange.
- *
- * Copyright (c) 2007-2010, Naoaki Okazaki
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the names of the authors nor the names of its contributors
- *       may be used to endorse or promote products derived from this
- *       software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
- * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-/* $Id$ */
-
-#ifndef __PARAMS_H__
-#define __PARAMS_H__
-
-crfsuite_params_t *params_create_instance();
-int params_add_int(crfsuite_params_t *params, const char *name, int value, const char *help);
-int params_add_float(crfsuite_params_t *params, const char *name, floatval_t value, const char *help);
-int params_add_string(crfsuite_params_t *params, const char *name, const char *value, const char *help);
-
-enum
-{
-    PARAMS_READ = -1,
-    PARAMS_INIT = 0,
-    PARAMS_WRITE = 1,
-};
-
-#define BEGIN_PARAM_MAP(params, mode) \
-    do                                \
-    {                                 \
-        int __ret = 0;                \
-        int __mode = mode;            \
-        crfsuite_params_t *__params = params;
-
-#define END_PARAM_MAP() \
-    }                   \
-    while (0)           \
-        ;
-
-#define DDX_PARAM_INT(name, var, defval, help)           \
-    if (__mode < 0)                                      \
-        __ret = __params->get_int(__params, name, &var); \
-    else if (__mode > 0)                                 \
-        __ret = __params->set_int(__params, name, var);  \
-    else                                                 \
-        __ret = params_add_int(__params, name, defval, help);
-
-#define DDX_PARAM_FLOAT(name, var, defval, help)           \
-    if (__mode < 0)                                        \
-        __ret = __params->get_float(__params, name, &var); \
-    else if (__mode > 0)                                   \
-        __ret = __params->set_float(__params, name, var);  \
-    else                                                   \
-        __ret = params_add_float(__params, name, defval, help);
-
-#define DDX_PARAM_STRING(name, var, defval, help)           \
-    if (__mode < 0)                                         \
-        __ret = __params->get_string(__params, name, &var); \
-    else if (__mode > 0)                                    \
-        __ret = __params->set_string(__params, name, var);  \
-    else                                                    \
-        __ret = params_add_string(__params, name, defval, help);
-
-#endif /*__PARAMS_H__*/
+/*
+ *      Parameter exchange.
+ *
+ * Copyright (c) 2007-2010, Naoaki Okazaki
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the names of the authors nor the names of its contributors
+ *       may be used to endorse or promote products derived from this
+ *       software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+ * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/* $Id$ */
+
+#ifndef __PARAMS_H__
+#define __PARAMS_H__
+
+crfsuite_params_t *params_create_instance();
+int params_add_int(crfsuite_params_t *params, const char *name, int value, const char *help);
+int params_add_float(crfsuite_params_t *params, const char *name, floatval_t value, const char *help);
+int params_add_string(crfsuite_params_t *params, const char *name, const char *value, const char *help);
+
+enum
+{
+    PARAMS_READ = -1,
+    PARAMS_INIT = 0,
+    PARAMS_WRITE = 1,
+};
+
+#define BEGIN_PARAM_MAP(params, mode) \
+    do                                \
+    {                                 \
+        int __ret = 0;                \
+        int __mode = mode;            \
+        crfsuite_params_t *__params = params;
+
+#define END_PARAM_MAP() \
+    }                   \
+    while (0)           \
+        ;
+
+#define DDX_PARAM_INT(name, var, defval, help)           \
+    if (__mode < 0)                                      \
+        __ret = __params->get_int(__params, name, &var); \
+    else if (__mode > 0)                                 \
+        __ret = __params->set_int(__params, name, var);  \
+    else                                                 \
+        __ret = params_add_int(__params, name, defval, help);
+
+#define DDX_PARAM_FLOAT(name, var, defval, help)           \
+    if (__mode < 0)                                        \
+        __ret = __params->get_float(__params, name, &var); \
+    else if (__mode > 0)                                   \
+        __ret = __params->set_float(__params, name, var);  \
+    else                                                   \
+        __ret = params_add_float(__params, name, defval, help);
+
+#define DDX_PARAM_STRING(name, var, defval, help)           \
+    if (__mode < 0)                                         \
+        __ret = __params->get_string(__params, name, &var); \
+    else if (__mode > 0)                                    \
+        __ret = __params->set_string(__params, name, var);  \
+    else                                                    \
+        __ret = params_add_string(__params, name, defval, help);
+
+#endif /*__PARAMS_H__*/
```

## chaine/_core/crfsuite/lib/crf/src/quark.c

 * *Ordering differences only*

```diff
@@ -1,180 +1,180 @@
-/*
- *      Quark object.
- *
- * Copyright (c) 2007-2010, Naoaki Okazaki
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the names of the authors nor the names of its contributors
- *       may be used to endorse or promote products derived from this
- *       software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
- * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-/* $Id$ */
-
-#include "os.h"
-#include <stdlib.h>
-#include <string.h>
-#include "rumavl.h"
-#include "quark.h"
-
-typedef struct
-{
-    char *str;
-    int qid;
-} record_t;
-
-struct tag_quark
-{
-    int num;
-    int max;
-    RUMAVL *string_to_id;
-    char **id_to_string;
-};
-
-static int keycmp(const void *_x, const void *_y, size_t n, void *udata)
-{
-    const record_t *x = (const record_t *)_x;
-    const record_t *y = (const record_t *)_y;
-    return strcmp(x->str, y->str);
-}
-
-static int owcb(RUMAVL *tree, RUMAVL_NODE *n, void *_x, const void *_y, void *udata)
-{
-    record_t *x = (record_t *)_x;
-    free(x->str);
-    return 0;
-}
-
-static int delcb(RUMAVL *tree, RUMAVL_NODE *n, void *_record, void *udata)
-{
-    record_t *record = (record_t *)_record;
-    free(record->str);
-    return 0;
-}
-
-quark_t *quark_new()
-{
-    quark_t *qrk = (quark_t *)malloc(sizeof(quark_t));
-    if (qrk != NULL)
-    {
-        qrk->num = 0;
-        qrk->max = 0;
-        qrk->string_to_id = rumavl_new(sizeof(record_t), keycmp, NULL, NULL);
-        if (qrk->string_to_id != NULL)
-        {
-            *rumavl_delcb(qrk->string_to_id) = delcb;
-            *rumavl_owcb(qrk->string_to_id) = owcb;
-        }
-        qrk->id_to_string = NULL;
-    }
-    return qrk;
-}
-
-void quark_delete(quark_t *qrk)
-{
-    if (qrk != NULL)
-    {
-        rumavl_destroy(qrk->string_to_id);
-        free(qrk->id_to_string);
-        free(qrk);
-    }
-}
-
-int quark_get(quark_t *qrk, const char *str)
-{
-    record_t key, *record = NULL;
-
-    key.str = (char *)str;
-    record = (record_t *)rumavl_find(qrk->string_to_id, &key);
-    if (record == NULL)
-    {
-        char *newstr = (char *)malloc(strlen(str) + 1);
-        if (newstr != NULL)
-        {
-            strcpy(newstr, str);
-        }
-
-        if (qrk->max <= qrk->num)
-        {
-            qrk->max = (qrk->max + 1) * 2;
-            qrk->id_to_string = (char **)realloc(qrk->id_to_string, sizeof(char *) * qrk->max);
-        }
-
-        qrk->id_to_string[qrk->num] = newstr;
-        key.str = newstr;
-        key.qid = qrk->num;
-        rumavl_insert(qrk->string_to_id, &key);
-
-        ++qrk->num;
-        return key.qid;
-    }
-    else
-    {
-        return record->qid;
-    }
-}
-
-int quark_to_id(quark_t *qrk, const char *str)
-{
-    record_t key, *record = NULL;
-
-    key.str = (char *)str;
-    record = (record_t *)rumavl_find(qrk->string_to_id, &key);
-    return (record != NULL) ? record->qid : -1;
-}
-
-const char *quark_to_string(quark_t *qrk, int qid)
-{
-    return (qid < qrk->num) ? qrk->id_to_string[qid] : NULL;
-}
-
-int quark_num(quark_t *qrk)
-{
-    return qrk->num;
-}
-
-#if 0
-int main(int argc, char *argv[])
-{
-    quark_t *qrk = quark_new();
-    int qid = 0;
-
-    qid = quark_get(qrk, "zero");
-    qid = quark_get(qrk, "one");
-    qid = quark_get(qrk, "zero");
-    qid = quark_to_id(qrk, "three");
-    qid = quark_get(qrk, "two");
-    qid = quark_get(qrk, "three");
-    qid = quark_to_id(qrk, "three");
-    qid = quark_get(qrk, "zero");
-    qid = quark_get(qrk, "one");
-
-    printf("%s\n", quark_to_string(qrk, 0));
-    printf("%s\n", quark_to_string(qrk, 1));
-    printf("%s\n", quark_to_string(qrk, 2));
-    printf("%s\n", quark_to_string(qrk, 3));
-
-    quark_delete(qrk);
-    
-    return 0;
-}
-#endif
+/*
+ *      Quark object.
+ *
+ * Copyright (c) 2007-2010, Naoaki Okazaki
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the names of the authors nor the names of its contributors
+ *       may be used to endorse or promote products derived from this
+ *       software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+ * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/* $Id$ */
+
+#include "os.h"
+#include <stdlib.h>
+#include <string.h>
+#include "rumavl.h"
+#include "quark.h"
+
+typedef struct
+{
+    char *str;
+    int qid;
+} record_t;
+
+struct tag_quark
+{
+    int num;
+    int max;
+    RUMAVL *string_to_id;
+    char **id_to_string;
+};
+
+static int keycmp(const void *_x, const void *_y, size_t n, void *udata)
+{
+    const record_t *x = (const record_t *)_x;
+    const record_t *y = (const record_t *)_y;
+    return strcmp(x->str, y->str);
+}
+
+static int owcb(RUMAVL *tree, RUMAVL_NODE *n, void *_x, const void *_y, void *udata)
+{
+    record_t *x = (record_t *)_x;
+    free(x->str);
+    return 0;
+}
+
+static int delcb(RUMAVL *tree, RUMAVL_NODE *n, void *_record, void *udata)
+{
+    record_t *record = (record_t *)_record;
+    free(record->str);
+    return 0;
+}
+
+quark_t *quark_new()
+{
+    quark_t *qrk = (quark_t *)malloc(sizeof(quark_t));
+    if (qrk != NULL)
+    {
+        qrk->num = 0;
+        qrk->max = 0;
+        qrk->string_to_id = rumavl_new(sizeof(record_t), keycmp, NULL, NULL);
+        if (qrk->string_to_id != NULL)
+        {
+            *rumavl_delcb(qrk->string_to_id) = delcb;
+            *rumavl_owcb(qrk->string_to_id) = owcb;
+        }
+        qrk->id_to_string = NULL;
+    }
+    return qrk;
+}
+
+void quark_delete(quark_t *qrk)
+{
+    if (qrk != NULL)
+    {
+        rumavl_destroy(qrk->string_to_id);
+        free(qrk->id_to_string);
+        free(qrk);
+    }
+}
+
+int quark_get(quark_t *qrk, const char *str)
+{
+    record_t key, *record = NULL;
+
+    key.str = (char *)str;
+    record = (record_t *)rumavl_find(qrk->string_to_id, &key);
+    if (record == NULL)
+    {
+        char *newstr = (char *)malloc(strlen(str) + 1);
+        if (newstr != NULL)
+        {
+            strcpy(newstr, str);
+        }
+
+        if (qrk->max <= qrk->num)
+        {
+            qrk->max = (qrk->max + 1) * 2;
+            qrk->id_to_string = (char **)realloc(qrk->id_to_string, sizeof(char *) * qrk->max);
+        }
+
+        qrk->id_to_string[qrk->num] = newstr;
+        key.str = newstr;
+        key.qid = qrk->num;
+        rumavl_insert(qrk->string_to_id, &key);
+
+        ++qrk->num;
+        return key.qid;
+    }
+    else
+    {
+        return record->qid;
+    }
+}
+
+int quark_to_id(quark_t *qrk, const char *str)
+{
+    record_t key, *record = NULL;
+
+    key.str = (char *)str;
+    record = (record_t *)rumavl_find(qrk->string_to_id, &key);
+    return (record != NULL) ? record->qid : -1;
+}
+
+const char *quark_to_string(quark_t *qrk, int qid)
+{
+    return (qid < qrk->num) ? qrk->id_to_string[qid] : NULL;
+}
+
+int quark_num(quark_t *qrk)
+{
+    return qrk->num;
+}
+
+#if 0
+int main(int argc, char *argv[])
+{
+    quark_t *qrk = quark_new();
+    int qid = 0;
+
+    qid = quark_get(qrk, "zero");
+    qid = quark_get(qrk, "one");
+    qid = quark_get(qrk, "zero");
+    qid = quark_to_id(qrk, "three");
+    qid = quark_get(qrk, "two");
+    qid = quark_get(qrk, "three");
+    qid = quark_to_id(qrk, "three");
+    qid = quark_get(qrk, "zero");
+    qid = quark_get(qrk, "one");
+
+    printf("%s\n", quark_to_string(qrk, 0));
+    printf("%s\n", quark_to_string(qrk, 1));
+    printf("%s\n", quark_to_string(qrk, 2));
+    printf("%s\n", quark_to_string(qrk, 3));
+
+    quark_delete(qrk);
+    
+    return 0;
+}
+#endif
```

## chaine/_core/crfsuite/lib/crf/src/quark.h

 * *Ordering differences only*

```diff
@@ -1,46 +1,46 @@
-/*
- *      Quark object.
- *
- * Copyright (c) 2007-2010, Naoaki Okazaki
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the names of the authors nor the names of its contributors
- *       may be used to endorse or promote products derived from this
- *       software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
- * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-/* $Id$ */
-
-#ifndef __QUARK_H__
-#define __QUARK_H__
-
-struct tag_quark;
-typedef struct tag_quark quark_t;
-
-quark_t *quark_new();
-void quark_delete(quark_t *qrk);
-int quark_get(quark_t *qrk, const char *str);
-int quark_to_id(quark_t *qrk, const char *str);
-const char *quark_to_string(quark_t *qrk, int qid);
-int quark_num(quark_t *qrk);
-
-#endif /*__QUARK_H__*/
+/*
+ *      Quark object.
+ *
+ * Copyright (c) 2007-2010, Naoaki Okazaki
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the names of the authors nor the names of its contributors
+ *       may be used to endorse or promote products derived from this
+ *       software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+ * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/* $Id$ */
+
+#ifndef __QUARK_H__
+#define __QUARK_H__
+
+struct tag_quark;
+typedef struct tag_quark quark_t;
+
+quark_t *quark_new();
+void quark_delete(quark_t *qrk);
+int quark_get(quark_t *qrk, const char *str);
+int quark_to_id(quark_t *qrk, const char *str);
+const char *quark_to_string(quark_t *qrk, int qid);
+int quark_num(quark_t *qrk);
+
+#endif /*__QUARK_H__*/
```

## chaine/_core/crfsuite/lib/crf/src/rumavl.c

 * *Ordering differences only*

```diff
@@ -1,1178 +1,1178 @@
-/*----------------------------------------------------------------------------
- * RumAVL - Threaded AVL Tree Implementation
- *
- * Copyright (c) 2005-2007 Jesse Long <jpl@unknown.za.net>
- * All rights reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- *   1. The above copyright notice and this permission notice shall be
- *	included in all copies or substantial portions of the Software.
- *   2. The origin of the Software must not be misrepresented; you must not
- *	claim that you wrote the original Software.
- *   3. Altered source versions of the Software must be plainly marked as
- *	such, and must not be misrepresented as being the original Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- *--------------------------------------------------------------------------*/
-
-/*----------------------------------------------------------------------------
- * Although not required by the license, I would appreciate it if you would
- * send me a mail notifying me of bugfixes and enhancements you make to this
- * code. My email address is <jpl@unknown.za.net>
- *--------------------------------------------------------------------------*/
-
-/*----------------------------------------------------------------------------
- *			     DEVELOPEMENT NOTES
- *
- * Links
- *    Each node has two links, link[0] is the left child, and link[1] is the
- *    right child. When a link points to a node that is actually below it in
- *    the BST, the respective thread flag is marked 0. When the link is a
- *    thread, the respective thread flag is marked 1, or 2 if the thread is
- *    to the opposite edge of the BST.
- *
- * Direction
- *    In RumAVL we use the numbers -1 (RUMAVL_DESC) and +1 (RUMAVL_ASC) to
- *    indicate direction, where -1 (RUMAVL_DESC) means left or descending in
- *    value, and +1 (RUMAVL_ASC) means right or ascending in value.
- *
- * Threads
- *    In RumAVL, the threads (non-bst links of leaves) are implemented in a
- *    sort of circular list. It is important to note that you cannot go
- *    through the entire list by following the same link, as you would when
- *    going through a linked list. Draw an example threaded AVL tree on paper
- *    and see why.
- *
- *--------------------------------------------------------------------------*/
-
-#include <stdlib.h>
-#include <string.h>
-
-#include "rumavl.h"
-
-/* For memory allocation debugging
-#ifdef USE_MEMBUG
-  #define MEMBUG_DEFINES
-  #include <membug.h>
-#endif */
-
-/*****************************************************************************
- *
- * MACROS - to make readability better
- *
- ****************************************************************************/
-
-/* Link numbers */
-#define LEFT (0)
-#define RIGHT (1)
-
-/* Direction to link no, expects RUMAVL_DESC or RUMAVL_ASC */
-#define LINK_NO(i) (((i) + 1) / 2) /* -1 => 0; 1 => 1 */
-/* Get opposite link number, expects LEFT or RIGHT */
-#define OTHER_LINK(i) ((i) ^ 1) /* 1 => 0; 0 => 1 */
-
-/* link no to direction, expects LEFT or RIGHT */
-#define DIR_NO(i) (((i)*2) - 1) /* 0 => -1; 1 => 1 */
-/* opposite direction, expects RUMAVL_DESC or RUMAVL_ASC */
-#define OTHER_DIR(i) ((i) * -1) /* -1 => 1; 1 => -1 */
-
-/* Memory allocation functions */
-#define mem_alloc(tree, bytes) mem_mgr((tree), NULL, (bytes))
-#define mem_free(tree, ptr) mem_mgr((tree), (ptr), 0)
-#define mem_relloc(tree, ptr, bytes) mem_mgr((tree), (ptr), (bytes))
-
-/*****************************************************************************
- *
- * DATA TYPES
- *
- ****************************************************************************/
-
-/*
- * RUMAVL - the handle on the tree
- *
- * All settings for a tree are in the RUMAVL object, including memory
- * management, delete and overwrite callback functions, and the record
- * comparison function pointer.
- */
-struct rumavl
-{
-	RUMAVL_NODE *root;		 /* root node in tree */
-	size_t reclen;			 /* length of records */
-	int (*cmp)(const void *, /* function to compare records */
-			   const void *,
-			   size_t,
-			   void *);
-	int (*owcb)(RUMAVL *, RUMAVL_NODE *, void *, const void *, void *);
-	int (*delcb)(RUMAVL *, RUMAVL_NODE *, void *, void *);
-	void *(*alloc)(void *, size_t, void *);
-	void *udata; /* user data for callbacks */
-};
-
-/*
- * RUMAVL_NODE - the node structure
- *
- * RUMAVL_NODE's contain all information about a specific node, including
- * links to the right and left children of the node, and flags (thread)
- * indicating whether or not the links are threads or not, and the balance
- * factor of the node.
- *
- * The record associated with each node is allocated along with the node,
- * and can be found directly after the node, by using the NODE_REC() macro.
- */
-struct rumavl_node
-{
-	RUMAVL_NODE *link[2]; /* links to child nodes */
-	char thread[2];		  /* flags for links, normal link or thread? */
-	signed char balance;  /* balance factor for node */
-	void *rec;
-#define NODE_REC(node) ((node)->rec)
-};
-
-/*
- * RUMAVL_STACK - a stack of nodes forming a path to a node
- *
- * RUMAVL_STACK's are used while deleting and inserting nodes, where effects
- * could be felt by all parents of the node. RUMAVL_STACK's are implemented
- * in a singly linked list. This is a change from the method used by most AVL
- * trees, where a static array node pointers are allocated. Linked lists allow
- * fo an unlimited height in the AVL tree.
- *
- * node is a pointer to the parent node's pointer to the node in question.
- * dir is the direction of the descent from this node.
- */
-typedef struct rumavl_stack RUMAVL_STACK;
-struct rumavl_stack
-{
-	RUMAVL_STACK *next;
-	RUMAVL_NODE **node;
-	int dir;
-};
-
-/* various other RumAVL specific structs defined in rumavl.h */
-
-/*****************************************************************************
- *
- * FORWARD DECLERATIONS
- *
- ****************************************************************************/
-
-static RUMAVL_NODE *seq_next(RUMAVL_NODE *node, int dir);
-static RUMAVL_NODE *node_new(RUMAVL *tree, const void *record);
-static void node_destroy(RUMAVL *tree, RUMAVL_NODE *node);
-static int stack_push(RUMAVL *tree, RUMAVL_STACK **stack, RUMAVL_NODE **node,
-					  int dir);
-static void stack_destroy(RUMAVL *tree, RUMAVL_STACK *stack);
-static void stack_update(RUMAVL *tree, RUMAVL_STACK *stack, signed char diff);
-
-static signed char balance(RUMAVL_NODE **node, int dir);
-static signed char rotate(RUMAVL_NODE **node, int dir);
-
-static void *mem_mgr(RUMAVL *tree, void *ptr, size_t size);
-
-static int rec_cmp(RUMAVL *tree, const void *reca, const void *recb);
-static int my_cmp(const void *a, const void *b, size_t n, void *udata);
-
-static int insert_cb(RUMAVL *t, RUMAVL_NODE *n, void *r1, const void *r2,
-					 void *udata);
-
-/*****************************************************************************
- *
- * PUBLIC FUNCTIONS
- *
- ****************************************************************************/
-
-/*----------------------------------------------------------------------------
- * rumavl_new - allocates a new RUMAVL object, and initialises it. This is the
- * only time the user gets to set the record length and record comparison
- * function, to avoid data loss.
- *--------------------------------------------------------------------------*/
-RUMAVL *rumavl_new(size_t reclen,
-				   int (*cmp)(const void *, const void *, size_t, void *),
-				   void *(*alloc)(void *, size_t, void *),
-				   void *udata)
-{
-	RUMAVL *tree;
-
-	if (reclen < 1)
-		return NULL;
-
-	if (alloc == NULL)
-		tree = malloc(sizeof(RUMAVL));
-	else
-		tree = alloc(NULL, sizeof(RUMAVL), udata);
-
-	if (tree == NULL)
-		return NULL;
-
-	tree->root = NULL;
-
-	tree->owcb = NULL;
-	tree->delcb = NULL;
-
-	tree->alloc = alloc;
-
-	tree->reclen = reclen;
-	tree->udata = udata;
-
-	if (cmp == NULL)
-		tree->cmp = my_cmp;
-	else
-		tree->cmp = cmp;
-
-	return tree;
-}
-
-/*----------------------------------------------------------------------------
- * rumavl_destroy - cleanly frees all memory used by the RUMAVL, as well as
- * all nodes. All nodes are passed to the delete callback function in case the
- * user has a special way of destroying nodes. The return value of the delete
- * callback function is ignored, because once we start destroying we cant
- * simply undestroy half the nodes.
- *--------------------------------------------------------------------------*/
-void rumavl_destroy(RUMAVL *tree)
-{
-	RUMAVL_NODE *node, *tmp;
-
-	if (tree->root != NULL)
-	{
-		/* walk through tree deleting all */
-		node = tree->root;
-		while (node->thread[LEFT] == 0) /* move to bottom left most node */
-			node = node->link[LEFT];
-		while (node != NULL)
-		{
-			tmp = seq_next(node, RUMAVL_ASC);
-			if (tree->delcb != NULL)
-			{
-				tree->delcb(tree, node, NODE_REC(node), tree->udata);
-			}
-			node_destroy(tree, node);
-			node = tmp;
-		}
-	}
-
-	if (tree->alloc == NULL)
-		free(tree);
-	else
-		tree->alloc(tree, 0, tree->udata);
-}
-
-/*---------------------------------------------------------------------------
- * rumavl_udata - get a pointer to the tree's user pointer
- *-------------------------------------------------------------------------*/
-void **rumavl_udata(RUMAVL *tree)
-{
-	return &tree->udata;
-}
-
-int (**rumavl_owcb(RUMAVL *tree))(RUMAVL *, RUMAVL_NODE *, void *,
-								  const void *, void *)
-{
-	return &tree->owcb;
-}
-
-int (**rumavl_delcb(RUMAVL *tree))(RUMAVL *, RUMAVL_NODE *, void *, void *)
-{
-	return &tree->delcb;
-}
-
-/*----------------------------------------------------------------------------
- * rumavl_set - set a node, overwriting if necessary, or creating if the node
- * does not exist
- *--------------------------------------------------------------------------*/
-int rumavl_set(RUMAVL *tree, const void *record)
-{
-	RUMAVL_NODE **node, *tmp;
-	RUMAVL_STACK *stack;
-	int ln;
-
-	if (tree->root == NULL)
-	{
-		/* This is the first node in the tree */
-		if ((tree->root = node_new(tree, record)) == NULL)
-			return RUMAVL_ERR_NOMEM;
-		tree->root->link[LEFT] = tree->root;
-		tree->root->link[RIGHT] = tree->root;
-		tree->root->thread[LEFT] = 2;
-		tree->root->thread[RIGHT] = 2;
-		return 0;
-	}
-
-	/* Since the tree is not empty, we must descend towards the nodes ideal
-	 * possition, and we may even find an existing node with the same record.
-	 * We keep a list parents for the eventual node position, because these
-	 * parents may become inbalanced by a new insertion. */
-
-	stack = NULL;
-	node = &tree->root;
-	for (;;)
-	{
-		if ((ln = rec_cmp(tree, record, NODE_REC(*node))) == 0)
-		{
-			/* OK, we found the exact node we wish to set, and we now
-			 * overwrite it. No change happens to the tree structure */
-			stack_destroy(tree, stack);
-
-			if (tree->owcb != NULL &&
-				(ln = tree->owcb(tree, *node, NODE_REC(*node),
-								 record, tree->udata)) != 0)
-			{
-				return ln;
-			}
-
-			memcpy(NODE_REC(*node), record, tree->reclen);
-			return 0;
-		}
-
-		/* *node is not the node we seek */
-
-		if (stack_push(tree, &stack, node, ln))
-		{
-			stack_destroy(tree, stack);
-			return RUMAVL_ERR_NOMEM;
-		}
-
-		ln = LINK_NO(ln);
-		if ((*node)->thread[ln] > 0)
-		{
-			/* This is as close to the correct node as we can get. We will
-			 * now break and add the new node as a leaf */
-			break;
-		}
-
-		node = &(*node)->link[ln];
-	}
-
-	/* we have reached a leaf, add new node here */
-	if ((tmp = node_new(tree, record)) == NULL)
-	{
-		stack_destroy(tree, stack);
-		return RUMAVL_ERR_NOMEM;
-	}
-	/* new child inherits parent thread */
-	tmp->link[ln] = (*node)->link[ln];
-	tmp->thread[ln] = (*node)->thread[ln];
-	if (tmp->thread[ln] == 2)
-		tmp->link[ln]->link[OTHER_LINK(ln)] = tmp;
-
-	tmp->link[OTHER_LINK(ln)] = *node;
-	tmp->thread[OTHER_LINK(ln)] = 1;
-	(*node)->link[ln] = tmp;
-	(*node)->thread[ln] = 0;
-
-	/* all parentage is now one level heavier - balance where necessary */
-	stack_update(tree, stack, +1);
-
-	return 0;
-}
-
-/*----------------------------------------------------------------------------
- * rumavl_insert - like rumavl_set, but only works if the node does not
- * exist. Temporarily replaces overwrite callback with a function that
- * always prevents overwrite, and calls rumavl_set()
- *--------------------------------------------------------------------------*/
-int rumavl_insert(RUMAVL *tree, const void *record)
-{
-	int retv;
-	int (*tmp)(RUMAVL *, RUMAVL_NODE *, void *, const void *, void *);
-
-	tmp = tree->owcb;
-	tree->owcb = insert_cb;
-	retv = rumavl_set(tree, record);
-	tree->owcb = tmp;
-	return retv;
-}
-
-/*----------------------------------------------------------------------------
- * rumavl_delete - deletes a node. Beware! this function is the worst part of
- * the library. Think (and draw pictures) when you edit this function.
- *--------------------------------------------------------------------------*/
-int rumavl_delete(RUMAVL *tree, const void *record)
-{
-	RUMAVL_NODE **node, *tmpnode;
-	RUMAVL_STACK *stack;
-	int dir, ln;
-
-	if (tree->root == NULL) /* tree is empty */
-		return RUMAVL_ERR_NOENT;
-
-	stack = NULL;
-	node = &tree->root;
-
-	/* Find desired node */
-	while ((dir = rec_cmp(tree, record, NODE_REC(*node))) != 0)
-	{
-		if (stack_push(tree, &stack, node, dir) != 0)
-			goto nomemout;
-
-		if ((*node)->thread[LINK_NO(dir)] > 0)
-		{
-			/* desired node does not exist */
-			stack_destroy(tree, stack);
-			return RUMAVL_ERR_NOENT;
-		}
-		node = &(*node)->link[LINK_NO(dir)];
-	}
-
-	/* OK, we got the node to be deleted, now get confirmation from user */
-	if (tree->delcb != NULL &&
-		(ln = tree->delcb(tree, *node, NODE_REC(*node), tree->udata)) != 0)
-	{
-		stack_destroy(tree, stack);
-		return ln;
-	}
-
-	if ((*node)->thread[LEFT] > 0)
-	{
-		if ((*node)->thread[RIGHT] > 0)
-		{
-			/* ooh look, we're a leaf */
-			tmpnode = *node;
-			if (stack != NULL)
-			{
-				/* This node has a parent, which will need to take over a
-				 * thread from the node being deleted. First we work out
-				 * which (left/right) child we are of parent, then give
-				 * parent the respective thread. If the thread destination
-				 * points back to us (edge of tree thread), update it to
-				 * point to our parent. */
-				ln = LINK_NO(stack->dir);
-				(*stack->node)->link[ln] = tmpnode->link[ln];
-				(*stack->node)->thread[ln] = tmpnode->thread[ln];
-				if ((*stack->node)->thread[ln] == 2)
-					(*stack->node)->link[ln]->link[OTHER_LINK(ln)] =
-						*stack->node;
-			}
-			else
-			{
-				/*
-				 * the only time stack will == NULL is when we are
-				 * deleting the root of the tree. We already know that
-				 * this is a leaf, so we will be leaving the tree empty.
-				 */
-				tree->root = NULL;
-			}
-			node_destroy(tree, tmpnode);
-		}
-		else
-		{
-			/* *node has only one child, and can be pruned by replacing
-			 * *node with its only child. This block of code and the next
-			 * should be identical, except that all directions and link
-			 * numbers are opposite.
-			 *
-			 * Let node being deleted = DELNODE for this comment.
-			 * DELNODE only has one child (the right child). The left
-			 * most descendant of DELNODE will have a thread (left thread)
-			 * pointing to DELNODE. This thread must be updated to point
-			 * to the node currently pointed to by DELNODE's left thread.
-			 *
-			 * DELNODE's left thread may point to the opposite edge of the
-			 * BST. In this case, the destination of the thread will have
-			 * a thread back to DELNODE. This will need to be updated to
-			 * point back to the leftmost descendant of DELNODE.
-			 */
-			tmpnode = *node;			  /* node being deleted */
-			*node = (*node)->link[RIGHT]; /* right child */
-			/* find left most descendant */
-			while ((*node)->thread[LEFT] == 0)
-				node = &(*node)->link[LEFT];
-			/* inherit thread from node being deleted */
-			(*node)->link[LEFT] = tmpnode->link[LEFT];
-			(*node)->thread[LEFT] = tmpnode->thread[LEFT];
-			/* update reverse thread if necessary */
-			if ((*node)->thread[LEFT] == 2)
-				(*node)->link[LEFT]->link[RIGHT] = *node;
-			node_destroy(tree, tmpnode);
-		}
-	}
-	else if ((*node)->thread[RIGHT] > 0)
-	{
-		/* see above */
-		tmpnode = *node;
-		*node = (*node)->link[LEFT];
-		while ((*node)->thread[RIGHT] == 0)
-			node = &(*node)->link[RIGHT];
-		(*node)->link[RIGHT] = tmpnode->link[RIGHT];
-		(*node)->thread[RIGHT] = tmpnode->thread[RIGHT];
-		if ((*node)->thread[RIGHT] == 2)
-			(*node)->link[RIGHT]->link[LEFT] = *node;
-		node_destroy(tree, tmpnode);
-	}
-	else
-	{
-		/* Delete a node with children on both sides. We do this by replacing
-		 * the node to be deleted (delnode) with its inner most child
-		 * on the heavier side (repnode). This in place replacement is quicker
-		 * than the previously used method of rotating delnode until it is a
-		 * (semi) leaf.
-		 *
-		 * At this point node points to delnode's parent's link to delnode. */
-		RUMAVL_NODE *repnode, *parent;
-		int outdir, outln;
-
-		/* find heaviest subtree */
-		if ((*node)->balance > 0)
-		{
-			outdir = +1; /* outter direction */
-			dir = -1;	 /* inner direction */
-			outln = 1;	 /* outer link number */
-			ln = 0;		 /* inner link number */
-		}
-		else
-		{
-			outdir = -1; /* same as above, but opposite subtree */
-			dir = +1;
-			outln = 0;
-			ln = 1;
-		}
-
-		/* Add node to be deleted to the list of nodes to be rebalanced.
-		 * Rememer that the replacement node will actually be acted apon,
-		 * and that the replacement node should feel the effect of its own
-		 * move */
-		if (stack_push(tree, &stack, node, outdir) != 0)
-			goto nomemout;
-
-		parent = *node;
-		repnode = parent->link[outln];
-
-		if (repnode->thread[ln] != 0)
-		{
-			/* repnode inherits delnode's lighter tree, and balance, and gets
-			 * balance readjusted below */
-			repnode->link[ln] = (*node)->link[ln];
-			repnode->thread[ln] = (*node)->thread[ln];
-			repnode->balance = (*node)->balance;
-		}
-		else
-		{
-			/* Now we add delnodes direct child to the list of "to update".
-			 * We pass a pointer to delnode's link to its direct child to
-			 * stack_push(), but that pointer is invalid, because when
-			 * stack_update() tries to access the link, delnode would have
-			 * been destroyed. So, we remember the stack position at which
-			 * we passed the faulty pointer to stack_push, and update its
-			 * node pointer when we find repnode to point to repnodes
-			 * link on the same side */
-			RUMAVL_STACK *tmpstack;
-
-			if (stack_push(tree, &stack, &parent->link[outln], dir) != 0)
-				goto nomemout;
-
-			tmpstack = stack;
-
-			parent = repnode;
-			repnode = repnode->link[ln];
-
-			/* move towards the innermost child of delnode */
-			while (repnode->thread[ln] == 0)
-			{
-				if (stack_push(tree, &stack, &parent->link[ln], dir) != 0)
-					goto nomemout;
-				parent = repnode;
-				repnode = repnode->link[ln];
-			}
-
-			if (repnode->thread[outln] == 0)
-			{
-				/* repnode's parent inherits repnodes only child */
-				parent->link[ln] = repnode->link[outln];
-			}
-			else
-			{
-				/* parent already has a link to repnode, but it must now be
-				 * marked as a thread */
-				parent->thread[ln] = 1;
-			}
-
-			repnode->link[0] = (*node)->link[0];
-			repnode->thread[0] = (*node)->thread[0];
-			repnode->link[1] = (*node)->link[1];
-			repnode->thread[1] = (*node)->thread[1];
-			repnode->balance = (*node)->balance;
-
-			/* see comment above */
-			tmpstack->node = &repnode->link[outln];
-		}
-		node_destroy(tree, *node);
-		*node = repnode;
-
-		/* innermost child in lighter tree has an invalid thread to delnode,
-		 * update it to point to repnode */
-		repnode = seq_next(repnode, dir);
-		repnode->link[outln] = *node;
-	}
-
-	/* update parents' balances */
-	stack_update(tree, stack, -1);
-	return 0;
-
-nomemout:
-	stack_destroy(tree, stack);
-	return RUMAVL_ERR_NOMEM;
-}
-
-/*----------------------------------------------------------------------------
- * rumavl_find
- *
- * Returns a pointer to the record that matches "record".
- *--------------------------------------------------------------------------*/
-void *rumavl_find(RUMAVL *tree, const void *find)
-{
-	void *record;
-	rumavl_node_find(tree, find, &record);
-	return record;
-}
-
-void *(**rumavl_alloc(RUMAVL *tree))(void *ptr, size_t size, void *udata)
-{
-	return &tree->alloc;
-}
-
-/*----------------------------------------------------------------------------
- * rumavl_record_size - returns size of all records in a tree
- *--------------------------------------------------------------------------*/
-size_t rumavl_record_size(RUMAVL *tree)
-{
-	return tree->reclen;
-}
-
-/*----------------------------------------------------------------------------
- * rumavl_node_find
- *
- * Returns a pointer to the node that matches "record".
- *--------------------------------------------------------------------------*/
-RUMAVL_NODE *rumavl_node_find(RUMAVL *tree, const void *find, void **record)
-{
-	RUMAVL_NODE *node;
-	int ln;
-
-	if (find == NULL || tree->root == NULL)
-		goto fail;
-
-	node = tree->root;
-	for (;;)
-	{
-		if ((ln = rec_cmp(tree, find, NODE_REC(node))) == 0)
-		{
-			if (record != NULL)
-				*record = NODE_REC(node);
-			return node;
-		}
-
-		ln = LINK_NO(ln);
-		if (node->thread[ln] > 0)
-			break;
-
-		node = node->link[ln];
-	}
-	/* we didn't find the desired node */
-
-fail:
-	if (record != NULL)
-		*record = NULL;
-
-	return NULL;
-}
-
-/*----------------------------------------------------------------------------
- * rumavl_node_next - find next node
- *--------------------------------------------------------------------------*/
-RUMAVL_NODE *rumavl_node_next(RUMAVL *tree, RUMAVL_NODE *node, int dir,
-							  void **record)
-{
-	/* make sure `dir' is either RUMAVL_ASC or RUMAVL_DESC */
-	if (dir == 0)
-		goto fail;
-	else if (dir > 0)
-		dir = RUMAVL_ASC;
-	else
-		dir = RUMAVL_DESC;
-
-	/* if node is uninitialised, start with first possible node in `dir'
-	 * direction */
-	if (node == NULL)
-	{
-		/* unless the tree is empty of course */
-		if (tree->root == NULL)
-			goto fail;
-
-		dir = OTHER_LINK(LINK_NO(dir));
-		node = tree->root;
-		while (node->thread[dir] == 0)
-		{
-			node = node->link[dir];
-		}
-		goto found;
-	}
-
-	if ((node = seq_next(node, dir)) == NULL)
-		goto fail;
-
-	/* fall through */
-
-found:
-	if (record != NULL)
-		*record = NODE_REC(node);
-	return node;
-
-fail:
-	if (record != NULL)
-		*record = NULL;
-	return NULL;
-}
-
-/*----------------------------------------------------------------------------
- * rumavl_node_record - returns a pointer to the record stored in a node
- *--------------------------------------------------------------------------*/
-void *rumavl_node_record(RUMAVL_NODE *node)
-{
-	return NODE_REC(node);
-}
-
-/*----------------------------------------------------------------------------
- * rumavl_foreach - loop through entire tree, using temporary iterator
- *--------------------------------------------------------------------------*/
-extern int rumavl_foreach(RUMAVL *tree, int dir,
-						  int (*cbfn)(RUMAVL *, void *, void *), void *udata)
-{
-	RUMAVL_NODE *node;
-	int retv;
-	void *record;
-
-	if (cbfn == NULL)
-		return RUMAVL_ERR_INVAL;
-
-	retv = RUMAVL_ERR_NOENT;
-	node = NULL;
-	while ((node = rumavl_node_next(tree, node, dir, &record)) != NULL)
-	{
-		if ((retv = cbfn(tree, record, udata)) != 0)
-			break;
-	}
-
-	return retv;
-}
-
-/*----------------------------------------------------------------------------
- * rumavl_strerror - return string description of RumAVL error code
- *--------------------------------------------------------------------------*/
-const char *rumavl_strerror(int errno)
-{
-	switch (errno)
-	{
-	case 0:
-		return "Operation successful";
-	case RUMAVL_ERR_INVAL:
-		return "Invalid argument to function";
-	case RUMAVL_ERR_NOMEM:
-		return "Insufficient memory to complete operation";
-	case RUMAVL_ERR_NOENT:
-		return "Entry does not exist";
-	case RUMAVL_ERR_EORNG:
-		return "No more entries in range";
-	case RUMAVL_ERR_EXIST:
-		return "Entry already exists";
-	}
-	return "UNKNOWN ERROR";
-}
-
-/*****************************************************************************
- *
- * PRIVATE FUNCTIONS
- *
- ****************************************************************************/
-
-/*----------------------------------------------------------------------------
- * insert_cb - used by rumavl_insert() to disallow any overwriting by
- * rumavl_set()
- *--------------------------------------------------------------------------*/
-static int insert_cb(RUMAVL *t, RUMAVL_NODE *n, void *r1, const void *r2,
-					 void *udata)
-{
-	(void)t;
-	(void)r1;
-	(void)r2;
-	(void)udata;
-	(void)n;
-	return RUMAVL_ERR_EXIST;
-}
-
-/*----------------------------------------------------------------------------
- * seq_next - return a pointer to the next node in sequence
- *--------------------------------------------------------------------------*/
-static RUMAVL_NODE *seq_next(RUMAVL_NODE *node, int dir)
-{
-	int ln;
-
-	ln = LINK_NO(dir);
-	if (node->thread[ln] == 2)
-	{
-		return NULL;
-	}
-	else if (node->thread[ln] == 1)
-	{
-		return node->link[ln];
-	}
-	node = node->link[ln];
-	ln = OTHER_LINK(ln);
-	while (node->thread[ln] == 0)
-	{
-		node = node->link[ln];
-	}
-	return node;
-}
-
-/*----------------------------------------------------------------------------
- * node_new - create a new node. MUST update link[] and thread[] after calling
- * this function
- *--------------------------------------------------------------------------*/
-static RUMAVL_NODE *node_new(RUMAVL *tree, const void *record)
-{
-	RUMAVL_NODE *node;
-
-	if ((node = mem_alloc(tree, sizeof(RUMAVL_NODE))) == NULL)
-		return NULL;
-
-	if ((node->rec = mem_alloc(tree, tree->reclen)) == NULL)
-	{
-		mem_free(tree, node);
-		return NULL;
-	}
-
-	memcpy(node->rec, record, tree->reclen);
-	node->balance = 0;
-	node->link[0] = NULL;
-	node->link[1] = NULL;
-	node->thread[0] = 0;
-	node->thread[1] = 0;
-	return node;
-}
-
-/*----------------------------------------------------------------------------
- * node_destroy - cleanly destroy node
- *--------------------------------------------------------------------------*/
-static void node_destroy(RUMAVL *tree, RUMAVL_NODE *node)
-{
-	mem_free(tree, node->rec);
-	mem_free(tree, node);
-}
-
-/*----------------------------------------------------------------------------
- * stack_push - push a node entry onto stack, for rumavl_set() and
- * rumavl_delete(). If this is the first entry, *stack should == NULL
- *--------------------------------------------------------------------------*/
-static int stack_push(RUMAVL *tree, RUMAVL_STACK **stack, RUMAVL_NODE **node,
-					  int dir)
-{
-	RUMAVL_STACK *tmp;
-
-	if ((tmp = mem_alloc(tree, sizeof(RUMAVL_STACK))) == NULL)
-		return -1;
-
-	tmp->next = *stack;
-	*stack = tmp;
-	tmp->node = node;
-	tmp->dir = dir;
-
-	return 0;
-}
-
-/*----------------------------------------------------------------------------
- * stack_destroy - free up a stack
- *--------------------------------------------------------------------------*/
-static void stack_destroy(RUMAVL *tree, RUMAVL_STACK *stack)
-{
-	RUMAVL_STACK *tmp;
-	while (stack != NULL)
-	{
-		tmp = stack;
-		stack = stack->next;
-		mem_free(tree, tmp);
-	}
-}
-
-/*----------------------------------------------------------------------------
- * stack_update - goes up stack readjusting balance as needed. This function
- * serves as a testiment to the philosophy of commenting while you code, 'cos
- * hell if I can remember how I got to this. I think is has something to do
- * with the varying effects on tree height, depending on exactly which sub
- * tree, or sub-sub tree was modified. TODO study and comment
- *--------------------------------------------------------------------------*/
-static void stack_update(RUMAVL *tree, RUMAVL_STACK *stack, signed char diff)
-{
-	RUMAVL_STACK *tmpstack;
-
-	/* if diff becomes 0, we quit, because no further change to ancestors
-	 * can be made */
-	while (stack != NULL && diff != 0)
-	{
-		signed char ob, nb;
-		ob = (*stack->node)->balance;
-		(*stack->node)->balance += diff * (signed char)stack->dir;
-		nb = (*stack->node)->balance;
-		if (diff < 0)
-		{
-			if (stack->dir == -1 && ob < 0)
-			{
-				if (nb > 0)
-					nb = 0;
-				diff = (nb - ob) * -1;
-			}
-			else if (stack->dir == 1 && ob > 0)
-			{
-				if (nb < 0)
-					nb = 0;
-				diff = nb - ob;
-			}
-			else
-			{
-				diff = 0;
-			}
-		}
-		else
-		{
-			if (stack->dir == -1 && nb < 0)
-			{
-				if (ob > 0)
-					ob = 0;
-				diff = (nb - ob) * -1;
-			}
-			else if (stack->dir == 1 && nb > 0)
-			{
-				if (ob < 0)
-					ob = 0;
-				diff = nb - ob;
-			}
-			else
-			{
-				diff = 0;
-			}
-		}
-		while ((*stack->node)->balance > 1)
-		{
-			diff += balance(stack->node, -1);
-		}
-		while ((*stack->node)->balance < -1)
-		{
-			diff += balance(stack->node, 1);
-		}
-		tmpstack = stack;
-		stack = stack->next;
-		mem_free(tree, tmpstack);
-	}
-
-	/* we may exit early if diff becomes 0. We still need to free all stack
-	 * entries */
-	while (stack != NULL)
-	{
-		tmpstack = stack;
-		stack = stack->next;
-		mem_free(tree, tmpstack);
-	}
-}
-
-/*----------------------------------------------------------------------------
- * my_cmp - a wrapper around memcmp() for default record comparison function.
- *--------------------------------------------------------------------------*/
-static int my_cmp(const void *a, const void *b, size_t n, void *udata)
-{
-	(void)udata;
-	return memcmp(a, b, n);
-}
-
-/*----------------------------------------------------------------------------
- * rec_cmp - a wrapper around the record comparison function, that only
- * returns 0, RUMAVL_ASC or RUMAVL_DESC.
- *--------------------------------------------------------------------------*/
-static int rec_cmp(RUMAVL *tree, const void *reca, const void *recb)
-{
-	int retv;
-	retv = tree->cmp(reca, recb, tree->reclen, tree->udata);
-	if (retv < 0)
-		return RUMAVL_DESC;
-	if (retv > 0)
-		return RUMAVL_ASC;
-	return 0;
-}
-
-/*----------------------------------------------------------------------------
- * Balance - rotate or double rotate as needed. Sometimes simply rotating a
- * tree is inefficient, as it leaves the tree as inbalanced as it was before
- * the rotate. To rectify this, we first rotate the heavier child so that the
- * heavier grandchild is on the outside, then rotate as per normal.
- *
- * TODO Check all callers, and make sure that they call this function sanely,
- *	and then remove unnecessary checks.
- *--------------------------------------------------------------------------*/
-static signed char balance(RUMAVL_NODE **node, int dir)
-{
-	int ln;
-	signed char retv;
-
-	if (node == NULL || *node == NULL || (dir * dir) != 1)
-		return 0;
-
-	ln = OTHER_LINK(LINK_NO(dir)); /* link number of new root */
-
-	/* new root must exist */
-	if ((*node)->thread[ln] > 0)
-		return 0;
-
-	retv = 0;
-	if ((*node)->link[ln]->balance == (char)dir &&
-		(*node)->link[ln]->thread[OTHER_LINK(ln)] == 0)
-	{
-		/* double rotate if inner grandchild is heaviest */
-		retv = rotate(&((*node)->link[ln]), OTHER_DIR(dir));
-	}
-
-	return retv + rotate(node, dir);
-}
-
-/*----------------------------------------------------------------------------
- * rotate
- *
- * rotates a tree rooted at *node. dir determines the direction of the rotate,
- * dir < 0 -> left rotate; dir >= 0 -> right rotate
- *
- * TODO How sure are we that all callers pass decent `dir' values?
- * TODO Restudy the tree height modification and balance factor algorithms,
- *	and document them.
- *--------------------------------------------------------------------------*/
-static signed char rotate(RUMAVL_NODE **node, int dir)
-{
-	RUMAVL_NODE *tmp;
-	signed char a, b, ad, bd, retv;
-	int ln;
-
-	/* force |dir| to be either -1 or +1 */
-	if (node == NULL || *node == NULL || (dir * dir) != 1)
-		return 0;
-
-	ln = LINK_NO(dir);
-	ln = OTHER_LINK(ln); /* link number of new root */
-
-	/* new root must exist */
-	if ((*node)->thread[ln] > 0)
-		return 0;
-
-	/* calculate effect on tree height */
-	if ((dir == 1 && (*node)->balance < 0 && (*node)->link[0]->balance >= 0) ||
-		(dir == -1 && (*node)->balance > 0 && (*node)->link[1]->balance <= 0))
-	{
-		retv = 0;
-	}
-	else
-	{
-		if (dir == 1)
-		{
-			if ((*node)->balance < -1)
-				retv = -1;
-			else if ((*node)->balance == -1)
-				retv = 0;
-			else
-				retv = +1;
-		}
-		else
-		{
-			if ((*node)->balance > 1)
-				retv = -1;
-			else if ((*node)->balance == 1)
-				retv = 0;
-			else
-				retv = +1;
-		}
-	}
-
-	/* rotate tree */
-	tmp = *node;
-	*node = tmp->link[ln];
-	if ((*node)->thread[OTHER_LINK(ln)] > 0)
-	{
-		tmp->thread[ln] = 1;
-	}
-	else
-	{
-		tmp->link[ln] = (*node)->link[OTHER_LINK(ln)];
-		tmp->thread[ln] = 0;
-	}
-	(*node)->link[OTHER_LINK(ln)] = tmp;
-	(*node)->thread[OTHER_LINK(ln)] = 0;
-
-	/* rebalance factors after rotate matrix */
-	a = tmp->balance;
-	b = (*node)->balance;
-
-	if (a > 0)
-		ad = 1;
-	else if (a < 0)
-		ad = -1;
-	else
-		ad = 0;
-
-	if (b > 0)
-		bd = 1;
-	else if (b < 0)
-		bd = -1;
-	else
-		bd = 0;
-
-	if (ad == OTHER_DIR(dir))
-	{
-		if (bd == OTHER_DIR(dir))
-		{
-			tmp->balance += (b * -1) + dir;
-			if (tmp->balance * dir > 0)
-				(*node)->balance = (tmp->balance - (b * -1)) + dir;
-			else
-				(*node)->balance += dir;
-		}
-		else
-		{
-			tmp->balance += dir;
-			(*node)->balance += dir;
-		}
-	}
-	else
-	{
-		if (bd == OTHER_DIR(dir))
-		{
-			tmp->balance += (b * -1) + dir;
-			(*node)->balance += dir + tmp->balance;
-		}
-		else
-		{
-			tmp->balance += dir;
-			(*node)->balance += dir + tmp->balance;
-		}
-	}
-
-	return retv;
-}
-
-/*----------------------------------------------------------------------------
- * mem_alloc
- *
- * default memory allocation function (malloc wrapper)
- *--------------------------------------------------------------------------*/
-static void *mem_mgr(RUMAVL *tree, void *ptr, size_t size)
-{
-	if (tree->alloc != NULL)
-		return tree->alloc(ptr, size, tree->udata);
-
-	return realloc(ptr, size);
-}
+/*----------------------------------------------------------------------------
+ * RumAVL - Threaded AVL Tree Implementation
+ *
+ * Copyright (c) 2005-2007 Jesse Long <jpl@unknown.za.net>
+ * All rights reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ *   1. The above copyright notice and this permission notice shall be
+ *	included in all copies or substantial portions of the Software.
+ *   2. The origin of the Software must not be misrepresented; you must not
+ *	claim that you wrote the original Software.
+ *   3. Altered source versions of the Software must be plainly marked as
+ *	such, and must not be misrepresented as being the original Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *--------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+ * Although not required by the license, I would appreciate it if you would
+ * send me a mail notifying me of bugfixes and enhancements you make to this
+ * code. My email address is <jpl@unknown.za.net>
+ *--------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+ *			     DEVELOPEMENT NOTES
+ *
+ * Links
+ *    Each node has two links, link[0] is the left child, and link[1] is the
+ *    right child. When a link points to a node that is actually below it in
+ *    the BST, the respective thread flag is marked 0. When the link is a
+ *    thread, the respective thread flag is marked 1, or 2 if the thread is
+ *    to the opposite edge of the BST.
+ *
+ * Direction
+ *    In RumAVL we use the numbers -1 (RUMAVL_DESC) and +1 (RUMAVL_ASC) to
+ *    indicate direction, where -1 (RUMAVL_DESC) means left or descending in
+ *    value, and +1 (RUMAVL_ASC) means right or ascending in value.
+ *
+ * Threads
+ *    In RumAVL, the threads (non-bst links of leaves) are implemented in a
+ *    sort of circular list. It is important to note that you cannot go
+ *    through the entire list by following the same link, as you would when
+ *    going through a linked list. Draw an example threaded AVL tree on paper
+ *    and see why.
+ *
+ *--------------------------------------------------------------------------*/
+
+#include <stdlib.h>
+#include <string.h>
+
+#include "rumavl.h"
+
+/* For memory allocation debugging
+#ifdef USE_MEMBUG
+  #define MEMBUG_DEFINES
+  #include <membug.h>
+#endif */
+
+/*****************************************************************************
+ *
+ * MACROS - to make readability better
+ *
+ ****************************************************************************/
+
+/* Link numbers */
+#define LEFT (0)
+#define RIGHT (1)
+
+/* Direction to link no, expects RUMAVL_DESC or RUMAVL_ASC */
+#define LINK_NO(i) (((i) + 1) / 2) /* -1 => 0; 1 => 1 */
+/* Get opposite link number, expects LEFT or RIGHT */
+#define OTHER_LINK(i) ((i) ^ 1) /* 1 => 0; 0 => 1 */
+
+/* link no to direction, expects LEFT or RIGHT */
+#define DIR_NO(i) (((i)*2) - 1) /* 0 => -1; 1 => 1 */
+/* opposite direction, expects RUMAVL_DESC or RUMAVL_ASC */
+#define OTHER_DIR(i) ((i) * -1) /* -1 => 1; 1 => -1 */
+
+/* Memory allocation functions */
+#define mem_alloc(tree, bytes) mem_mgr((tree), NULL, (bytes))
+#define mem_free(tree, ptr) mem_mgr((tree), (ptr), 0)
+#define mem_relloc(tree, ptr, bytes) mem_mgr((tree), (ptr), (bytes))
+
+/*****************************************************************************
+ *
+ * DATA TYPES
+ *
+ ****************************************************************************/
+
+/*
+ * RUMAVL - the handle on the tree
+ *
+ * All settings for a tree are in the RUMAVL object, including memory
+ * management, delete and overwrite callback functions, and the record
+ * comparison function pointer.
+ */
+struct rumavl
+{
+	RUMAVL_NODE *root;		 /* root node in tree */
+	size_t reclen;			 /* length of records */
+	int (*cmp)(const void *, /* function to compare records */
+			   const void *,
+			   size_t,
+			   void *);
+	int (*owcb)(RUMAVL *, RUMAVL_NODE *, void *, const void *, void *);
+	int (*delcb)(RUMAVL *, RUMAVL_NODE *, void *, void *);
+	void *(*alloc)(void *, size_t, void *);
+	void *udata; /* user data for callbacks */
+};
+
+/*
+ * RUMAVL_NODE - the node structure
+ *
+ * RUMAVL_NODE's contain all information about a specific node, including
+ * links to the right and left children of the node, and flags (thread)
+ * indicating whether or not the links are threads or not, and the balance
+ * factor of the node.
+ *
+ * The record associated with each node is allocated along with the node,
+ * and can be found directly after the node, by using the NODE_REC() macro.
+ */
+struct rumavl_node
+{
+	RUMAVL_NODE *link[2]; /* links to child nodes */
+	char thread[2];		  /* flags for links, normal link or thread? */
+	signed char balance;  /* balance factor for node */
+	void *rec;
+#define NODE_REC(node) ((node)->rec)
+};
+
+/*
+ * RUMAVL_STACK - a stack of nodes forming a path to a node
+ *
+ * RUMAVL_STACK's are used while deleting and inserting nodes, where effects
+ * could be felt by all parents of the node. RUMAVL_STACK's are implemented
+ * in a singly linked list. This is a change from the method used by most AVL
+ * trees, where a static array node pointers are allocated. Linked lists allow
+ * fo an unlimited height in the AVL tree.
+ *
+ * node is a pointer to the parent node's pointer to the node in question.
+ * dir is the direction of the descent from this node.
+ */
+typedef struct rumavl_stack RUMAVL_STACK;
+struct rumavl_stack
+{
+	RUMAVL_STACK *next;
+	RUMAVL_NODE **node;
+	int dir;
+};
+
+/* various other RumAVL specific structs defined in rumavl.h */
+
+/*****************************************************************************
+ *
+ * FORWARD DECLERATIONS
+ *
+ ****************************************************************************/
+
+static RUMAVL_NODE *seq_next(RUMAVL_NODE *node, int dir);
+static RUMAVL_NODE *node_new(RUMAVL *tree, const void *record);
+static void node_destroy(RUMAVL *tree, RUMAVL_NODE *node);
+static int stack_push(RUMAVL *tree, RUMAVL_STACK **stack, RUMAVL_NODE **node,
+					  int dir);
+static void stack_destroy(RUMAVL *tree, RUMAVL_STACK *stack);
+static void stack_update(RUMAVL *tree, RUMAVL_STACK *stack, signed char diff);
+
+static signed char balance(RUMAVL_NODE **node, int dir);
+static signed char rotate(RUMAVL_NODE **node, int dir);
+
+static void *mem_mgr(RUMAVL *tree, void *ptr, size_t size);
+
+static int rec_cmp(RUMAVL *tree, const void *reca, const void *recb);
+static int my_cmp(const void *a, const void *b, size_t n, void *udata);
+
+static int insert_cb(RUMAVL *t, RUMAVL_NODE *n, void *r1, const void *r2,
+					 void *udata);
+
+/*****************************************************************************
+ *
+ * PUBLIC FUNCTIONS
+ *
+ ****************************************************************************/
+
+/*----------------------------------------------------------------------------
+ * rumavl_new - allocates a new RUMAVL object, and initialises it. This is the
+ * only time the user gets to set the record length and record comparison
+ * function, to avoid data loss.
+ *--------------------------------------------------------------------------*/
+RUMAVL *rumavl_new(size_t reclen,
+				   int (*cmp)(const void *, const void *, size_t, void *),
+				   void *(*alloc)(void *, size_t, void *),
+				   void *udata)
+{
+	RUMAVL *tree;
+
+	if (reclen < 1)
+		return NULL;
+
+	if (alloc == NULL)
+		tree = malloc(sizeof(RUMAVL));
+	else
+		tree = alloc(NULL, sizeof(RUMAVL), udata);
+
+	if (tree == NULL)
+		return NULL;
+
+	tree->root = NULL;
+
+	tree->owcb = NULL;
+	tree->delcb = NULL;
+
+	tree->alloc = alloc;
+
+	tree->reclen = reclen;
+	tree->udata = udata;
+
+	if (cmp == NULL)
+		tree->cmp = my_cmp;
+	else
+		tree->cmp = cmp;
+
+	return tree;
+}
+
+/*----------------------------------------------------------------------------
+ * rumavl_destroy - cleanly frees all memory used by the RUMAVL, as well as
+ * all nodes. All nodes are passed to the delete callback function in case the
+ * user has a special way of destroying nodes. The return value of the delete
+ * callback function is ignored, because once we start destroying we cant
+ * simply undestroy half the nodes.
+ *--------------------------------------------------------------------------*/
+void rumavl_destroy(RUMAVL *tree)
+{
+	RUMAVL_NODE *node, *tmp;
+
+	if (tree->root != NULL)
+	{
+		/* walk through tree deleting all */
+		node = tree->root;
+		while (node->thread[LEFT] == 0) /* move to bottom left most node */
+			node = node->link[LEFT];
+		while (node != NULL)
+		{
+			tmp = seq_next(node, RUMAVL_ASC);
+			if (tree->delcb != NULL)
+			{
+				tree->delcb(tree, node, NODE_REC(node), tree->udata);
+			}
+			node_destroy(tree, node);
+			node = tmp;
+		}
+	}
+
+	if (tree->alloc == NULL)
+		free(tree);
+	else
+		tree->alloc(tree, 0, tree->udata);
+}
+
+/*---------------------------------------------------------------------------
+ * rumavl_udata - get a pointer to the tree's user pointer
+ *-------------------------------------------------------------------------*/
+void **rumavl_udata(RUMAVL *tree)
+{
+	return &tree->udata;
+}
+
+int (**rumavl_owcb(RUMAVL *tree))(RUMAVL *, RUMAVL_NODE *, void *,
+								  const void *, void *)
+{
+	return &tree->owcb;
+}
+
+int (**rumavl_delcb(RUMAVL *tree))(RUMAVL *, RUMAVL_NODE *, void *, void *)
+{
+	return &tree->delcb;
+}
+
+/*----------------------------------------------------------------------------
+ * rumavl_set - set a node, overwriting if necessary, or creating if the node
+ * does not exist
+ *--------------------------------------------------------------------------*/
+int rumavl_set(RUMAVL *tree, const void *record)
+{
+	RUMAVL_NODE **node, *tmp;
+	RUMAVL_STACK *stack;
+	int ln;
+
+	if (tree->root == NULL)
+	{
+		/* This is the first node in the tree */
+		if ((tree->root = node_new(tree, record)) == NULL)
+			return RUMAVL_ERR_NOMEM;
+		tree->root->link[LEFT] = tree->root;
+		tree->root->link[RIGHT] = tree->root;
+		tree->root->thread[LEFT] = 2;
+		tree->root->thread[RIGHT] = 2;
+		return 0;
+	}
+
+	/* Since the tree is not empty, we must descend towards the nodes ideal
+	 * possition, and we may even find an existing node with the same record.
+	 * We keep a list parents for the eventual node position, because these
+	 * parents may become inbalanced by a new insertion. */
+
+	stack = NULL;
+	node = &tree->root;
+	for (;;)
+	{
+		if ((ln = rec_cmp(tree, record, NODE_REC(*node))) == 0)
+		{
+			/* OK, we found the exact node we wish to set, and we now
+			 * overwrite it. No change happens to the tree structure */
+			stack_destroy(tree, stack);
+
+			if (tree->owcb != NULL &&
+				(ln = tree->owcb(tree, *node, NODE_REC(*node),
+								 record, tree->udata)) != 0)
+			{
+				return ln;
+			}
+
+			memcpy(NODE_REC(*node), record, tree->reclen);
+			return 0;
+		}
+
+		/* *node is not the node we seek */
+
+		if (stack_push(tree, &stack, node, ln))
+		{
+			stack_destroy(tree, stack);
+			return RUMAVL_ERR_NOMEM;
+		}
+
+		ln = LINK_NO(ln);
+		if ((*node)->thread[ln] > 0)
+		{
+			/* This is as close to the correct node as we can get. We will
+			 * now break and add the new node as a leaf */
+			break;
+		}
+
+		node = &(*node)->link[ln];
+	}
+
+	/* we have reached a leaf, add new node here */
+	if ((tmp = node_new(tree, record)) == NULL)
+	{
+		stack_destroy(tree, stack);
+		return RUMAVL_ERR_NOMEM;
+	}
+	/* new child inherits parent thread */
+	tmp->link[ln] = (*node)->link[ln];
+	tmp->thread[ln] = (*node)->thread[ln];
+	if (tmp->thread[ln] == 2)
+		tmp->link[ln]->link[OTHER_LINK(ln)] = tmp;
+
+	tmp->link[OTHER_LINK(ln)] = *node;
+	tmp->thread[OTHER_LINK(ln)] = 1;
+	(*node)->link[ln] = tmp;
+	(*node)->thread[ln] = 0;
+
+	/* all parentage is now one level heavier - balance where necessary */
+	stack_update(tree, stack, +1);
+
+	return 0;
+}
+
+/*----------------------------------------------------------------------------
+ * rumavl_insert - like rumavl_set, but only works if the node does not
+ * exist. Temporarily replaces overwrite callback with a function that
+ * always prevents overwrite, and calls rumavl_set()
+ *--------------------------------------------------------------------------*/
+int rumavl_insert(RUMAVL *tree, const void *record)
+{
+	int retv;
+	int (*tmp)(RUMAVL *, RUMAVL_NODE *, void *, const void *, void *);
+
+	tmp = tree->owcb;
+	tree->owcb = insert_cb;
+	retv = rumavl_set(tree, record);
+	tree->owcb = tmp;
+	return retv;
+}
+
+/*----------------------------------------------------------------------------
+ * rumavl_delete - deletes a node. Beware! this function is the worst part of
+ * the library. Think (and draw pictures) when you edit this function.
+ *--------------------------------------------------------------------------*/
+int rumavl_delete(RUMAVL *tree, const void *record)
+{
+	RUMAVL_NODE **node, *tmpnode;
+	RUMAVL_STACK *stack;
+	int dir, ln;
+
+	if (tree->root == NULL) /* tree is empty */
+		return RUMAVL_ERR_NOENT;
+
+	stack = NULL;
+	node = &tree->root;
+
+	/* Find desired node */
+	while ((dir = rec_cmp(tree, record, NODE_REC(*node))) != 0)
+	{
+		if (stack_push(tree, &stack, node, dir) != 0)
+			goto nomemout;
+
+		if ((*node)->thread[LINK_NO(dir)] > 0)
+		{
+			/* desired node does not exist */
+			stack_destroy(tree, stack);
+			return RUMAVL_ERR_NOENT;
+		}
+		node = &(*node)->link[LINK_NO(dir)];
+	}
+
+	/* OK, we got the node to be deleted, now get confirmation from user */
+	if (tree->delcb != NULL &&
+		(ln = tree->delcb(tree, *node, NODE_REC(*node), tree->udata)) != 0)
+	{
+		stack_destroy(tree, stack);
+		return ln;
+	}
+
+	if ((*node)->thread[LEFT] > 0)
+	{
+		if ((*node)->thread[RIGHT] > 0)
+		{
+			/* ooh look, we're a leaf */
+			tmpnode = *node;
+			if (stack != NULL)
+			{
+				/* This node has a parent, which will need to take over a
+				 * thread from the node being deleted. First we work out
+				 * which (left/right) child we are of parent, then give
+				 * parent the respective thread. If the thread destination
+				 * points back to us (edge of tree thread), update it to
+				 * point to our parent. */
+				ln = LINK_NO(stack->dir);
+				(*stack->node)->link[ln] = tmpnode->link[ln];
+				(*stack->node)->thread[ln] = tmpnode->thread[ln];
+				if ((*stack->node)->thread[ln] == 2)
+					(*stack->node)->link[ln]->link[OTHER_LINK(ln)] =
+						*stack->node;
+			}
+			else
+			{
+				/*
+				 * the only time stack will == NULL is when we are
+				 * deleting the root of the tree. We already know that
+				 * this is a leaf, so we will be leaving the tree empty.
+				 */
+				tree->root = NULL;
+			}
+			node_destroy(tree, tmpnode);
+		}
+		else
+		{
+			/* *node has only one child, and can be pruned by replacing
+			 * *node with its only child. This block of code and the next
+			 * should be identical, except that all directions and link
+			 * numbers are opposite.
+			 *
+			 * Let node being deleted = DELNODE for this comment.
+			 * DELNODE only has one child (the right child). The left
+			 * most descendant of DELNODE will have a thread (left thread)
+			 * pointing to DELNODE. This thread must be updated to point
+			 * to the node currently pointed to by DELNODE's left thread.
+			 *
+			 * DELNODE's left thread may point to the opposite edge of the
+			 * BST. In this case, the destination of the thread will have
+			 * a thread back to DELNODE. This will need to be updated to
+			 * point back to the leftmost descendant of DELNODE.
+			 */
+			tmpnode = *node;			  /* node being deleted */
+			*node = (*node)->link[RIGHT]; /* right child */
+			/* find left most descendant */
+			while ((*node)->thread[LEFT] == 0)
+				node = &(*node)->link[LEFT];
+			/* inherit thread from node being deleted */
+			(*node)->link[LEFT] = tmpnode->link[LEFT];
+			(*node)->thread[LEFT] = tmpnode->thread[LEFT];
+			/* update reverse thread if necessary */
+			if ((*node)->thread[LEFT] == 2)
+				(*node)->link[LEFT]->link[RIGHT] = *node;
+			node_destroy(tree, tmpnode);
+		}
+	}
+	else if ((*node)->thread[RIGHT] > 0)
+	{
+		/* see above */
+		tmpnode = *node;
+		*node = (*node)->link[LEFT];
+		while ((*node)->thread[RIGHT] == 0)
+			node = &(*node)->link[RIGHT];
+		(*node)->link[RIGHT] = tmpnode->link[RIGHT];
+		(*node)->thread[RIGHT] = tmpnode->thread[RIGHT];
+		if ((*node)->thread[RIGHT] == 2)
+			(*node)->link[RIGHT]->link[LEFT] = *node;
+		node_destroy(tree, tmpnode);
+	}
+	else
+	{
+		/* Delete a node with children on both sides. We do this by replacing
+		 * the node to be deleted (delnode) with its inner most child
+		 * on the heavier side (repnode). This in place replacement is quicker
+		 * than the previously used method of rotating delnode until it is a
+		 * (semi) leaf.
+		 *
+		 * At this point node points to delnode's parent's link to delnode. */
+		RUMAVL_NODE *repnode, *parent;
+		int outdir, outln;
+
+		/* find heaviest subtree */
+		if ((*node)->balance > 0)
+		{
+			outdir = +1; /* outter direction */
+			dir = -1;	 /* inner direction */
+			outln = 1;	 /* outer link number */
+			ln = 0;		 /* inner link number */
+		}
+		else
+		{
+			outdir = -1; /* same as above, but opposite subtree */
+			dir = +1;
+			outln = 0;
+			ln = 1;
+		}
+
+		/* Add node to be deleted to the list of nodes to be rebalanced.
+		 * Rememer that the replacement node will actually be acted apon,
+		 * and that the replacement node should feel the effect of its own
+		 * move */
+		if (stack_push(tree, &stack, node, outdir) != 0)
+			goto nomemout;
+
+		parent = *node;
+		repnode = parent->link[outln];
+
+		if (repnode->thread[ln] != 0)
+		{
+			/* repnode inherits delnode's lighter tree, and balance, and gets
+			 * balance readjusted below */
+			repnode->link[ln] = (*node)->link[ln];
+			repnode->thread[ln] = (*node)->thread[ln];
+			repnode->balance = (*node)->balance;
+		}
+		else
+		{
+			/* Now we add delnodes direct child to the list of "to update".
+			 * We pass a pointer to delnode's link to its direct child to
+			 * stack_push(), but that pointer is invalid, because when
+			 * stack_update() tries to access the link, delnode would have
+			 * been destroyed. So, we remember the stack position at which
+			 * we passed the faulty pointer to stack_push, and update its
+			 * node pointer when we find repnode to point to repnodes
+			 * link on the same side */
+			RUMAVL_STACK *tmpstack;
+
+			if (stack_push(tree, &stack, &parent->link[outln], dir) != 0)
+				goto nomemout;
+
+			tmpstack = stack;
+
+			parent = repnode;
+			repnode = repnode->link[ln];
+
+			/* move towards the innermost child of delnode */
+			while (repnode->thread[ln] == 0)
+			{
+				if (stack_push(tree, &stack, &parent->link[ln], dir) != 0)
+					goto nomemout;
+				parent = repnode;
+				repnode = repnode->link[ln];
+			}
+
+			if (repnode->thread[outln] == 0)
+			{
+				/* repnode's parent inherits repnodes only child */
+				parent->link[ln] = repnode->link[outln];
+			}
+			else
+			{
+				/* parent already has a link to repnode, but it must now be
+				 * marked as a thread */
+				parent->thread[ln] = 1;
+			}
+
+			repnode->link[0] = (*node)->link[0];
+			repnode->thread[0] = (*node)->thread[0];
+			repnode->link[1] = (*node)->link[1];
+			repnode->thread[1] = (*node)->thread[1];
+			repnode->balance = (*node)->balance;
+
+			/* see comment above */
+			tmpstack->node = &repnode->link[outln];
+		}
+		node_destroy(tree, *node);
+		*node = repnode;
+
+		/* innermost child in lighter tree has an invalid thread to delnode,
+		 * update it to point to repnode */
+		repnode = seq_next(repnode, dir);
+		repnode->link[outln] = *node;
+	}
+
+	/* update parents' balances */
+	stack_update(tree, stack, -1);
+	return 0;
+
+nomemout:
+	stack_destroy(tree, stack);
+	return RUMAVL_ERR_NOMEM;
+}
+
+/*----------------------------------------------------------------------------
+ * rumavl_find
+ *
+ * Returns a pointer to the record that matches "record".
+ *--------------------------------------------------------------------------*/
+void *rumavl_find(RUMAVL *tree, const void *find)
+{
+	void *record;
+	rumavl_node_find(tree, find, &record);
+	return record;
+}
+
+void *(**rumavl_alloc(RUMAVL *tree))(void *ptr, size_t size, void *udata)
+{
+	return &tree->alloc;
+}
+
+/*----------------------------------------------------------------------------
+ * rumavl_record_size - returns size of all records in a tree
+ *--------------------------------------------------------------------------*/
+size_t rumavl_record_size(RUMAVL *tree)
+{
+	return tree->reclen;
+}
+
+/*----------------------------------------------------------------------------
+ * rumavl_node_find
+ *
+ * Returns a pointer to the node that matches "record".
+ *--------------------------------------------------------------------------*/
+RUMAVL_NODE *rumavl_node_find(RUMAVL *tree, const void *find, void **record)
+{
+	RUMAVL_NODE *node;
+	int ln;
+
+	if (find == NULL || tree->root == NULL)
+		goto fail;
+
+	node = tree->root;
+	for (;;)
+	{
+		if ((ln = rec_cmp(tree, find, NODE_REC(node))) == 0)
+		{
+			if (record != NULL)
+				*record = NODE_REC(node);
+			return node;
+		}
+
+		ln = LINK_NO(ln);
+		if (node->thread[ln] > 0)
+			break;
+
+		node = node->link[ln];
+	}
+	/* we didn't find the desired node */
+
+fail:
+	if (record != NULL)
+		*record = NULL;
+
+	return NULL;
+}
+
+/*----------------------------------------------------------------------------
+ * rumavl_node_next - find next node
+ *--------------------------------------------------------------------------*/
+RUMAVL_NODE *rumavl_node_next(RUMAVL *tree, RUMAVL_NODE *node, int dir,
+							  void **record)
+{
+	/* make sure `dir' is either RUMAVL_ASC or RUMAVL_DESC */
+	if (dir == 0)
+		goto fail;
+	else if (dir > 0)
+		dir = RUMAVL_ASC;
+	else
+		dir = RUMAVL_DESC;
+
+	/* if node is uninitialised, start with first possible node in `dir'
+	 * direction */
+	if (node == NULL)
+	{
+		/* unless the tree is empty of course */
+		if (tree->root == NULL)
+			goto fail;
+
+		dir = OTHER_LINK(LINK_NO(dir));
+		node = tree->root;
+		while (node->thread[dir] == 0)
+		{
+			node = node->link[dir];
+		}
+		goto found;
+	}
+
+	if ((node = seq_next(node, dir)) == NULL)
+		goto fail;
+
+	/* fall through */
+
+found:
+	if (record != NULL)
+		*record = NODE_REC(node);
+	return node;
+
+fail:
+	if (record != NULL)
+		*record = NULL;
+	return NULL;
+}
+
+/*----------------------------------------------------------------------------
+ * rumavl_node_record - returns a pointer to the record stored in a node
+ *--------------------------------------------------------------------------*/
+void *rumavl_node_record(RUMAVL_NODE *node)
+{
+	return NODE_REC(node);
+}
+
+/*----------------------------------------------------------------------------
+ * rumavl_foreach - loop through entire tree, using temporary iterator
+ *--------------------------------------------------------------------------*/
+extern int rumavl_foreach(RUMAVL *tree, int dir,
+						  int (*cbfn)(RUMAVL *, void *, void *), void *udata)
+{
+	RUMAVL_NODE *node;
+	int retv;
+	void *record;
+
+	if (cbfn == NULL)
+		return RUMAVL_ERR_INVAL;
+
+	retv = RUMAVL_ERR_NOENT;
+	node = NULL;
+	while ((node = rumavl_node_next(tree, node, dir, &record)) != NULL)
+	{
+		if ((retv = cbfn(tree, record, udata)) != 0)
+			break;
+	}
+
+	return retv;
+}
+
+/*----------------------------------------------------------------------------
+ * rumavl_strerror - return string description of RumAVL error code
+ *--------------------------------------------------------------------------*/
+const char *rumavl_strerror(int errno)
+{
+	switch (errno)
+	{
+	case 0:
+		return "Operation successful";
+	case RUMAVL_ERR_INVAL:
+		return "Invalid argument to function";
+	case RUMAVL_ERR_NOMEM:
+		return "Insufficient memory to complete operation";
+	case RUMAVL_ERR_NOENT:
+		return "Entry does not exist";
+	case RUMAVL_ERR_EORNG:
+		return "No more entries in range";
+	case RUMAVL_ERR_EXIST:
+		return "Entry already exists";
+	}
+	return "UNKNOWN ERROR";
+}
+
+/*****************************************************************************
+ *
+ * PRIVATE FUNCTIONS
+ *
+ ****************************************************************************/
+
+/*----------------------------------------------------------------------------
+ * insert_cb - used by rumavl_insert() to disallow any overwriting by
+ * rumavl_set()
+ *--------------------------------------------------------------------------*/
+static int insert_cb(RUMAVL *t, RUMAVL_NODE *n, void *r1, const void *r2,
+					 void *udata)
+{
+	(void)t;
+	(void)r1;
+	(void)r2;
+	(void)udata;
+	(void)n;
+	return RUMAVL_ERR_EXIST;
+}
+
+/*----------------------------------------------------------------------------
+ * seq_next - return a pointer to the next node in sequence
+ *--------------------------------------------------------------------------*/
+static RUMAVL_NODE *seq_next(RUMAVL_NODE *node, int dir)
+{
+	int ln;
+
+	ln = LINK_NO(dir);
+	if (node->thread[ln] == 2)
+	{
+		return NULL;
+	}
+	else if (node->thread[ln] == 1)
+	{
+		return node->link[ln];
+	}
+	node = node->link[ln];
+	ln = OTHER_LINK(ln);
+	while (node->thread[ln] == 0)
+	{
+		node = node->link[ln];
+	}
+	return node;
+}
+
+/*----------------------------------------------------------------------------
+ * node_new - create a new node. MUST update link[] and thread[] after calling
+ * this function
+ *--------------------------------------------------------------------------*/
+static RUMAVL_NODE *node_new(RUMAVL *tree, const void *record)
+{
+	RUMAVL_NODE *node;
+
+	if ((node = mem_alloc(tree, sizeof(RUMAVL_NODE))) == NULL)
+		return NULL;
+
+	if ((node->rec = mem_alloc(tree, tree->reclen)) == NULL)
+	{
+		mem_free(tree, node);
+		return NULL;
+	}
+
+	memcpy(node->rec, record, tree->reclen);
+	node->balance = 0;
+	node->link[0] = NULL;
+	node->link[1] = NULL;
+	node->thread[0] = 0;
+	node->thread[1] = 0;
+	return node;
+}
+
+/*----------------------------------------------------------------------------
+ * node_destroy - cleanly destroy node
+ *--------------------------------------------------------------------------*/
+static void node_destroy(RUMAVL *tree, RUMAVL_NODE *node)
+{
+	mem_free(tree, node->rec);
+	mem_free(tree, node);
+}
+
+/*----------------------------------------------------------------------------
+ * stack_push - push a node entry onto stack, for rumavl_set() and
+ * rumavl_delete(). If this is the first entry, *stack should == NULL
+ *--------------------------------------------------------------------------*/
+static int stack_push(RUMAVL *tree, RUMAVL_STACK **stack, RUMAVL_NODE **node,
+					  int dir)
+{
+	RUMAVL_STACK *tmp;
+
+	if ((tmp = mem_alloc(tree, sizeof(RUMAVL_STACK))) == NULL)
+		return -1;
+
+	tmp->next = *stack;
+	*stack = tmp;
+	tmp->node = node;
+	tmp->dir = dir;
+
+	return 0;
+}
+
+/*----------------------------------------------------------------------------
+ * stack_destroy - free up a stack
+ *--------------------------------------------------------------------------*/
+static void stack_destroy(RUMAVL *tree, RUMAVL_STACK *stack)
+{
+	RUMAVL_STACK *tmp;
+	while (stack != NULL)
+	{
+		tmp = stack;
+		stack = stack->next;
+		mem_free(tree, tmp);
+	}
+}
+
+/*----------------------------------------------------------------------------
+ * stack_update - goes up stack readjusting balance as needed. This function
+ * serves as a testiment to the philosophy of commenting while you code, 'cos
+ * hell if I can remember how I got to this. I think is has something to do
+ * with the varying effects on tree height, depending on exactly which sub
+ * tree, or sub-sub tree was modified. TODO study and comment
+ *--------------------------------------------------------------------------*/
+static void stack_update(RUMAVL *tree, RUMAVL_STACK *stack, signed char diff)
+{
+	RUMAVL_STACK *tmpstack;
+
+	/* if diff becomes 0, we quit, because no further change to ancestors
+	 * can be made */
+	while (stack != NULL && diff != 0)
+	{
+		signed char ob, nb;
+		ob = (*stack->node)->balance;
+		(*stack->node)->balance += diff * (signed char)stack->dir;
+		nb = (*stack->node)->balance;
+		if (diff < 0)
+		{
+			if (stack->dir == -1 && ob < 0)
+			{
+				if (nb > 0)
+					nb = 0;
+				diff = (nb - ob) * -1;
+			}
+			else if (stack->dir == 1 && ob > 0)
+			{
+				if (nb < 0)
+					nb = 0;
+				diff = nb - ob;
+			}
+			else
+			{
+				diff = 0;
+			}
+		}
+		else
+		{
+			if (stack->dir == -1 && nb < 0)
+			{
+				if (ob > 0)
+					ob = 0;
+				diff = (nb - ob) * -1;
+			}
+			else if (stack->dir == 1 && nb > 0)
+			{
+				if (ob < 0)
+					ob = 0;
+				diff = nb - ob;
+			}
+			else
+			{
+				diff = 0;
+			}
+		}
+		while ((*stack->node)->balance > 1)
+		{
+			diff += balance(stack->node, -1);
+		}
+		while ((*stack->node)->balance < -1)
+		{
+			diff += balance(stack->node, 1);
+		}
+		tmpstack = stack;
+		stack = stack->next;
+		mem_free(tree, tmpstack);
+	}
+
+	/* we may exit early if diff becomes 0. We still need to free all stack
+	 * entries */
+	while (stack != NULL)
+	{
+		tmpstack = stack;
+		stack = stack->next;
+		mem_free(tree, tmpstack);
+	}
+}
+
+/*----------------------------------------------------------------------------
+ * my_cmp - a wrapper around memcmp() for default record comparison function.
+ *--------------------------------------------------------------------------*/
+static int my_cmp(const void *a, const void *b, size_t n, void *udata)
+{
+	(void)udata;
+	return memcmp(a, b, n);
+}
+
+/*----------------------------------------------------------------------------
+ * rec_cmp - a wrapper around the record comparison function, that only
+ * returns 0, RUMAVL_ASC or RUMAVL_DESC.
+ *--------------------------------------------------------------------------*/
+static int rec_cmp(RUMAVL *tree, const void *reca, const void *recb)
+{
+	int retv;
+	retv = tree->cmp(reca, recb, tree->reclen, tree->udata);
+	if (retv < 0)
+		return RUMAVL_DESC;
+	if (retv > 0)
+		return RUMAVL_ASC;
+	return 0;
+}
+
+/*----------------------------------------------------------------------------
+ * Balance - rotate or double rotate as needed. Sometimes simply rotating a
+ * tree is inefficient, as it leaves the tree as inbalanced as it was before
+ * the rotate. To rectify this, we first rotate the heavier child so that the
+ * heavier grandchild is on the outside, then rotate as per normal.
+ *
+ * TODO Check all callers, and make sure that they call this function sanely,
+ *	and then remove unnecessary checks.
+ *--------------------------------------------------------------------------*/
+static signed char balance(RUMAVL_NODE **node, int dir)
+{
+	int ln;
+	signed char retv;
+
+	if (node == NULL || *node == NULL || (dir * dir) != 1)
+		return 0;
+
+	ln = OTHER_LINK(LINK_NO(dir)); /* link number of new root */
+
+	/* new root must exist */
+	if ((*node)->thread[ln] > 0)
+		return 0;
+
+	retv = 0;
+	if ((*node)->link[ln]->balance == (char)dir &&
+		(*node)->link[ln]->thread[OTHER_LINK(ln)] == 0)
+	{
+		/* double rotate if inner grandchild is heaviest */
+		retv = rotate(&((*node)->link[ln]), OTHER_DIR(dir));
+	}
+
+	return retv + rotate(node, dir);
+}
+
+/*----------------------------------------------------------------------------
+ * rotate
+ *
+ * rotates a tree rooted at *node. dir determines the direction of the rotate,
+ * dir < 0 -> left rotate; dir >= 0 -> right rotate
+ *
+ * TODO How sure are we that all callers pass decent `dir' values?
+ * TODO Restudy the tree height modification and balance factor algorithms,
+ *	and document them.
+ *--------------------------------------------------------------------------*/
+static signed char rotate(RUMAVL_NODE **node, int dir)
+{
+	RUMAVL_NODE *tmp;
+	signed char a, b, ad, bd, retv;
+	int ln;
+
+	/* force |dir| to be either -1 or +1 */
+	if (node == NULL || *node == NULL || (dir * dir) != 1)
+		return 0;
+
+	ln = LINK_NO(dir);
+	ln = OTHER_LINK(ln); /* link number of new root */
+
+	/* new root must exist */
+	if ((*node)->thread[ln] > 0)
+		return 0;
+
+	/* calculate effect on tree height */
+	if ((dir == 1 && (*node)->balance < 0 && (*node)->link[0]->balance >= 0) ||
+		(dir == -1 && (*node)->balance > 0 && (*node)->link[1]->balance <= 0))
+	{
+		retv = 0;
+	}
+	else
+	{
+		if (dir == 1)
+		{
+			if ((*node)->balance < -1)
+				retv = -1;
+			else if ((*node)->balance == -1)
+				retv = 0;
+			else
+				retv = +1;
+		}
+		else
+		{
+			if ((*node)->balance > 1)
+				retv = -1;
+			else if ((*node)->balance == 1)
+				retv = 0;
+			else
+				retv = +1;
+		}
+	}
+
+	/* rotate tree */
+	tmp = *node;
+	*node = tmp->link[ln];
+	if ((*node)->thread[OTHER_LINK(ln)] > 0)
+	{
+		tmp->thread[ln] = 1;
+	}
+	else
+	{
+		tmp->link[ln] = (*node)->link[OTHER_LINK(ln)];
+		tmp->thread[ln] = 0;
+	}
+	(*node)->link[OTHER_LINK(ln)] = tmp;
+	(*node)->thread[OTHER_LINK(ln)] = 0;
+
+	/* rebalance factors after rotate matrix */
+	a = tmp->balance;
+	b = (*node)->balance;
+
+	if (a > 0)
+		ad = 1;
+	else if (a < 0)
+		ad = -1;
+	else
+		ad = 0;
+
+	if (b > 0)
+		bd = 1;
+	else if (b < 0)
+		bd = -1;
+	else
+		bd = 0;
+
+	if (ad == OTHER_DIR(dir))
+	{
+		if (bd == OTHER_DIR(dir))
+		{
+			tmp->balance += (b * -1) + dir;
+			if (tmp->balance * dir > 0)
+				(*node)->balance = (tmp->balance - (b * -1)) + dir;
+			else
+				(*node)->balance += dir;
+		}
+		else
+		{
+			tmp->balance += dir;
+			(*node)->balance += dir;
+		}
+	}
+	else
+	{
+		if (bd == OTHER_DIR(dir))
+		{
+			tmp->balance += (b * -1) + dir;
+			(*node)->balance += dir + tmp->balance;
+		}
+		else
+		{
+			tmp->balance += dir;
+			(*node)->balance += dir + tmp->balance;
+		}
+	}
+
+	return retv;
+}
+
+/*----------------------------------------------------------------------------
+ * mem_alloc
+ *
+ * default memory allocation function (malloc wrapper)
+ *--------------------------------------------------------------------------*/
+static void *mem_mgr(RUMAVL *tree, void *ptr, size_t size)
+{
+	if (tree->alloc != NULL)
+		return tree->alloc(ptr, size, tree->udata);
+
+	return realloc(ptr, size);
+}
```

## chaine/_core/crfsuite/lib/crf/src/rumavl.h

 * *Ordering differences only*

```diff
@@ -1,144 +1,144 @@
-/*
- * RumAVL - Threaded AVL Tree Implementation
- *
- * Copyright (c) 2005-2007 Jesse Long <jpl@unknown.za.net>
- * All rights reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- *   1. The above copyright notice and this permission notice shall be
- *	included in all copies or substantial portions of the Software.
- *   2. The origin of the Software must not be misrepresented; you must not
- *	claim that you wrote the original Software.
- *   3. Altered source versions of the Software must be plainly marked as
- *	such, and must not be misrepresented as being the original Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- */
-
-/*
- * Please see the `README' file, the documentation in the `doc' directory and
- * the `rumavl.c' source file for more information.
- */
-
-#ifndef RUMAVL_H
-#define RUMAVL_H 1
-
-#ifdef __cplusplus
-extern "C"
-{
-#endif
-
-#include <stddef.h> /* size_t */
-
-	/*----------------------------------------------------------------------------
-	 * DATA TYPES
-	 *--------------------------------------------------------------------------*/
-
-	/* Opaque context handle for the tree */
-	typedef struct rumavl RUMAVL;
-
-	/* Node type - used for iterating */
-	typedef struct rumavl_node RUMAVL_NODE;
-
-	/*----------------------------------------------------------------------------
-	 * FUNDEMENTAL FUNCTIONS
-	 *--------------------------------------------------------------------------*/
-
-	/* Create a new RumAVL tree */
-	RUMAVL *rumavl_new(size_t reclen,
-					   int (*cmp)(const void *, const void *, size_t, void *),
-					   void *(*alloc)(void *, size_t, void *),
-					   void *udata);
-
-	/* Destroy a RumAVL tree */
-	void rumavl_destroy(RUMAVL *tree);
-
-	/* This function returns the size of each record in a tree */
-	size_t rumavl_record_size(RUMAVL *tree);
-
-	/* Get a pointer to the udata pointer */
-	void **rumavl_udata(RUMAVL *tree);
-
-	/* Insert a record into a tree, overwriting an existing record necessary */
-	int rumavl_set(RUMAVL *tree, const void *record);
-	/* Insert a record into a tree, never overwrites an existing record */
-	int rumavl_insert(RUMAVL *tree, const void *record);
-
-	/* Retrieve record from tree, or NULL */
-	void *rumavl_find(RUMAVL *tree, const void *find);
-
-	/* Remove record from tree */
-	int rumavl_delete(RUMAVL *tree, const void *record);
-
-	/*----------------------------------------------------------------------------
-	 * ITERATOR FUNCTIONS
-	 *--------------------------------------------------------------------------*/
-
-	/* Get a pointer to the node containing a specific record */
-	RUMAVL_NODE *rumavl_node_find(RUMAVL *tree, const void *find, void **record);
-
-	/* Get the next node in sequence after a specific node, in a specific
-	 * direction, or get the first node on either end of a tree */
-	RUMAVL_NODE *rumavl_node_next(RUMAVL *tree, RUMAVL_NODE *node, int dir,
-								  void **record);
-/* Possible directions */
-#define RUMAVL_DESC (-1)
-#define RUMAVL_ASC (+1)
-
-	/* Get a record held by a specific node */
-	void *rumavl_node_record(RUMAVL_NODE *node);
-
-	/* Pass each record in a tree to a user defined callback function */
-	extern int rumavl_foreach(RUMAVL *tree, int dir,
-							  int (*cbfn)(RUMAVL *, void *, void *), void *udata);
-
-	/*----------------------------------------------------------------------------
-	 * CALLBACK FUNCTIONS
-	 *
-	 * Functions giving you more control over the actions of this library.
-	 *--------------------------------------------------------------------------*/
-
-	int (**rumavl_owcb(RUMAVL *tree))(RUMAVL *, RUMAVL_NODE *, void *,
-									  const void *, void *);
-	int (**rumavl_delcb(RUMAVL *tree))(RUMAVL *, RUMAVL_NODE *, void *, void *);
-
-	/*----------------------------------------------------------------------------
-	 * MEMORY MANAGEMENT
-	 *
-	 * The rumavl_mem struct is used to define how a RUMAVL object allocates
-	 * and frees memory.
-	 *--------------------------------------------------------------------------*/
-	void *(**rumavl_alloc(RUMAVL *tree))(void *ptr, size_t size, void *udata);
-
-	/*----------------------------------------------------------------------------
-	 * ERROR CODES
-	 *
-	 * The functions returning int's will return these errors
-	 *--------------------------------------------------------------------------*/
-
-#define RUMAVL_ERR_INVAL (-1) /* Invalid argument */
-#define RUMAVL_ERR_NOMEM (-2) /* Insufficient memory */
-#define RUMAVL_ERR_NOENT (-3) /* Entry does not exist */
-#define RUMAVL_ERR_EORNG (-5) /* No nodes left in range */
-#define RUMAVL_ERR_EXIST (-6) /* Entry already exists */
-
-	/* returns static string describing error number */
-	extern const char *rumavl_strerror(int errno);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* ifndef RUMAVL_H */
+/*
+ * RumAVL - Threaded AVL Tree Implementation
+ *
+ * Copyright (c) 2005-2007 Jesse Long <jpl@unknown.za.net>
+ * All rights reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ *   1. The above copyright notice and this permission notice shall be
+ *	included in all copies or substantial portions of the Software.
+ *   2. The origin of the Software must not be misrepresented; you must not
+ *	claim that you wrote the original Software.
+ *   3. Altered source versions of the Software must be plainly marked as
+ *	such, and must not be misrepresented as being the original Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+/*
+ * Please see the `README' file, the documentation in the `doc' directory and
+ * the `rumavl.c' source file for more information.
+ */
+
+#ifndef RUMAVL_H
+#define RUMAVL_H 1
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+#include <stddef.h> /* size_t */
+
+	/*----------------------------------------------------------------------------
+	 * DATA TYPES
+	 *--------------------------------------------------------------------------*/
+
+	/* Opaque context handle for the tree */
+	typedef struct rumavl RUMAVL;
+
+	/* Node type - used for iterating */
+	typedef struct rumavl_node RUMAVL_NODE;
+
+	/*----------------------------------------------------------------------------
+	 * FUNDEMENTAL FUNCTIONS
+	 *--------------------------------------------------------------------------*/
+
+	/* Create a new RumAVL tree */
+	RUMAVL *rumavl_new(size_t reclen,
+					   int (*cmp)(const void *, const void *, size_t, void *),
+					   void *(*alloc)(void *, size_t, void *),
+					   void *udata);
+
+	/* Destroy a RumAVL tree */
+	void rumavl_destroy(RUMAVL *tree);
+
+	/* This function returns the size of each record in a tree */
+	size_t rumavl_record_size(RUMAVL *tree);
+
+	/* Get a pointer to the udata pointer */
+	void **rumavl_udata(RUMAVL *tree);
+
+	/* Insert a record into a tree, overwriting an existing record necessary */
+	int rumavl_set(RUMAVL *tree, const void *record);
+	/* Insert a record into a tree, never overwrites an existing record */
+	int rumavl_insert(RUMAVL *tree, const void *record);
+
+	/* Retrieve record from tree, or NULL */
+	void *rumavl_find(RUMAVL *tree, const void *find);
+
+	/* Remove record from tree */
+	int rumavl_delete(RUMAVL *tree, const void *record);
+
+	/*----------------------------------------------------------------------------
+	 * ITERATOR FUNCTIONS
+	 *--------------------------------------------------------------------------*/
+
+	/* Get a pointer to the node containing a specific record */
+	RUMAVL_NODE *rumavl_node_find(RUMAVL *tree, const void *find, void **record);
+
+	/* Get the next node in sequence after a specific node, in a specific
+	 * direction, or get the first node on either end of a tree */
+	RUMAVL_NODE *rumavl_node_next(RUMAVL *tree, RUMAVL_NODE *node, int dir,
+								  void **record);
+/* Possible directions */
+#define RUMAVL_DESC (-1)
+#define RUMAVL_ASC (+1)
+
+	/* Get a record held by a specific node */
+	void *rumavl_node_record(RUMAVL_NODE *node);
+
+	/* Pass each record in a tree to a user defined callback function */
+	extern int rumavl_foreach(RUMAVL *tree, int dir,
+							  int (*cbfn)(RUMAVL *, void *, void *), void *udata);
+
+	/*----------------------------------------------------------------------------
+	 * CALLBACK FUNCTIONS
+	 *
+	 * Functions giving you more control over the actions of this library.
+	 *--------------------------------------------------------------------------*/
+
+	int (**rumavl_owcb(RUMAVL *tree))(RUMAVL *, RUMAVL_NODE *, void *,
+									  const void *, void *);
+	int (**rumavl_delcb(RUMAVL *tree))(RUMAVL *, RUMAVL_NODE *, void *, void *);
+
+	/*----------------------------------------------------------------------------
+	 * MEMORY MANAGEMENT
+	 *
+	 * The rumavl_mem struct is used to define how a RUMAVL object allocates
+	 * and frees memory.
+	 *--------------------------------------------------------------------------*/
+	void *(**rumavl_alloc(RUMAVL *tree))(void *ptr, size_t size, void *udata);
+
+	/*----------------------------------------------------------------------------
+	 * ERROR CODES
+	 *
+	 * The functions returning int's will return these errors
+	 *--------------------------------------------------------------------------*/
+
+#define RUMAVL_ERR_INVAL (-1) /* Invalid argument */
+#define RUMAVL_ERR_NOMEM (-2) /* Insufficient memory */
+#define RUMAVL_ERR_NOENT (-3) /* Entry does not exist */
+#define RUMAVL_ERR_EORNG (-5) /* No nodes left in range */
+#define RUMAVL_ERR_EXIST (-6) /* Entry already exists */
+
+	/* returns static string describing error number */
+	extern const char *rumavl_strerror(int errno);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* ifndef RUMAVL_H */
```

## chaine/_core/crfsuite/lib/crf/src/train_arow.c

 * *Ordering differences only*

```diff
@@ -1,409 +1,409 @@
-/*
- *      Online training with Adaptive Regularization of Weights (AROW).
- *
- * Copyright (c) 2007-2010, Naoaki Okazaki
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the names of the authors nor the names of its contributors
- *       may be used to endorse or promote products derived from this
- *       software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
- * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-/* $Id$ */
-
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif /*HAVE_CONFIG_H*/
-
-#include <os.h>
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <time.h>
-
-#include <crfsuite.h>
-#include "crfsuite_internal.h"
-#include "logging.h"
-#include "params.h"
-#include "vecmath.h"
-
-#define MIN(a, b) ((a) < (b) ? (a) : (b))
-
-/**
- * Training parameters (configurable with crfsuite_params_t interface).
- */
-typedef struct
-{
-    floatval_t variance;
-    floatval_t gamma;
-    int max_iterations;
-    floatval_t epsilon;
-} training_option_t;
-
-/**
- * Internal data structure for computing the sparse vector F(x, y) - F(x, y').
- */
-typedef struct
-{
-    /* An array of feature indices relevant to the instance. */
-    int *actives;
-    int num_actives;
-    int cap_actives;
-    char *used;
-
-    /* Coefficient for collecting feature weights. */
-    floatval_t c;
-    /* The difference vector [K]. */
-    floatval_t *delta;
-    /* The number of features. */
-    int K;
-} delta_t;
-
-static int delta_init(delta_t *dc, const int K)
-{
-    memset(dc, 0, sizeof(*dc));
-    dc->used = (char *)calloc(K, sizeof(char));
-    dc->delta = (floatval_t *)calloc(K, sizeof(floatval_t));
-    dc->K = K;
-    if (dc->delta == NULL || dc->used == NULL)
-    {
-        return 1;
-    }
-    return 0;
-}
-
-static void delta_finish(delta_t *dc)
-{
-    free(dc->actives);
-    free(dc->used);
-    free(dc->delta);
-    memset(dc, 0, sizeof(*dc));
-}
-
-static void delta_reset(delta_t *dc)
-{
-    int i;
-    for (i = 0; i < dc->num_actives; ++i)
-    {
-        int k = dc->actives[i];
-        dc->delta[k] = 0;
-    }
-    dc->num_actives = 0;
-}
-
-static void delta_collect(void *instance, int fid, floatval_t value)
-{
-    delta_t *dc = (delta_t *)instance;
-
-    /* Expand the active feature list if necessary. */
-    if (dc->cap_actives <= dc->num_actives)
-    {
-        ++dc->cap_actives;
-        dc->cap_actives *= 2;
-        dc->actives = (int *)realloc(dc->actives, sizeof(int) * dc->cap_actives);
-    }
-
-    dc->actives[dc->num_actives++] = fid;
-    dc->delta[fid] += dc->c * value;
-}
-
-static void delta_finalize(delta_t *dc)
-{
-    int i, j = 0, k;
-
-    /* Collapse the duplicated indices. */
-    for (i = 0; i < dc->num_actives; ++i)
-    {
-        k = dc->actives[i];
-        if (!dc->used[k])
-        {
-            dc->actives[j++] = k;
-            dc->used[k] = 1;
-        }
-    }
-    dc->num_actives = j; /* This is the distinct number of indices. */
-
-    /* Reset the used flag. */
-    for (i = 0; i < dc->num_actives; ++i)
-    {
-        k = dc->actives[i];
-        dc->used[k] = 0;
-    }
-}
-
-static floatval_t delta_norm2(delta_t *dc)
-{
-    int i;
-    floatval_t norm2 = 0.;
-
-    for (i = 0; i < dc->num_actives; ++i)
-    {
-        int k = dc->actives[i];
-        norm2 += dc->delta[k] * dc->delta[k];
-    }
-    return norm2;
-}
-
-static void delta_add(delta_t *dc, floatval_t *w, floatval_t *ws, const floatval_t tau, const floatval_t u)
-{
-    int i;
-    const floatval_t tauu = tau * u;
-
-    for (i = 0; i < dc->num_actives; ++i)
-    {
-        int k = dc->actives[i];
-        w[k] += tau * dc->delta[k];
-        ws[k] += tauu * dc->delta[k];
-    }
-}
-
-static int diff(int *x, int *y, int n)
-{
-    int i, d = 0;
-    for (i = 0; i < n; ++i)
-    {
-        if (x[i] != y[i])
-        {
-            ++d;
-        }
-    }
-    return d;
-}
-
-static floatval_t cost_insensitive(floatval_t err, floatval_t d)
-{
-    return err + 1.;
-}
-
-static floatval_t cost_sensitive(floatval_t err, floatval_t d)
-{
-    return err + sqrt(d);
-}
-
-static floatval_t tau0(floatval_t cost, floatval_t norm, floatval_t c)
-{
-    return cost / norm;
-}
-
-static floatval_t tau1(floatval_t cost, floatval_t norm, floatval_t c)
-{
-    return MIN(c, cost / norm);
-}
-
-static floatval_t tau2(floatval_t cost, floatval_t norm, floatval_t c)
-{
-    return cost / (norm + 0.5 / c);
-}
-
-static int exchange_options(crfsuite_params_t *params, training_option_t *opt, int mode)
-{
-    BEGIN_PARAM_MAP(params, mode)
-    DDX_PARAM_FLOAT(
-        "variance", opt->variance, 1.,
-        "The initial variance of every feature weight.")
-    DDX_PARAM_FLOAT(
-        "gamma", opt->gamma, 1.,
-        "Tradeoff parameter.")
-    DDX_PARAM_INT(
-        "max_iterations", opt->max_iterations, 100,
-        "The maximum number of iterations.")
-    DDX_PARAM_FLOAT(
-        "epsilon", opt->epsilon, 0.,
-        "The stopping criterion (the mean loss).")
-    END_PARAM_MAP()
-
-    return 0;
-}
-
-void crfsuite_train_arow_init(crfsuite_params_t *params)
-{
-    exchange_options(params, NULL, 0);
-}
-
-int crfsuite_train_arow(
-    encoder_t *gm,
-    dataset_t *trainset,
-    dataset_t *testset,
-    crfsuite_params_t *params,
-    logging_t *lg,
-    floatval_t **ptr_w)
-{
-    int n, i, j, k, ret = 0;
-    int *viterbi = NULL;
-    floatval_t beta;
-    floatval_t *mean = NULL, *cov = NULL, *prod = NULL;
-    const int N = trainset->num_instances;
-    const int K = gm->num_features;
-    const int T = gm->cap_items;
-    training_option_t opt;
-    delta_t dc;
-    clock_t begin = clock();
-
-    /* Initialize the variable. */
-    if (delta_init(&dc, K) != 0)
-    {
-        ret = CRFSUITEERR_OUTOFMEMORY;
-        goto error_exit;
-    }
-
-    /* Obtain parameter values. */
-    exchange_options(params, &opt, -1);
-
-    /* Allocate arrays. */
-    mean = (floatval_t *)calloc(sizeof(floatval_t), K);
-    cov = (floatval_t *)calloc(sizeof(floatval_t), K);
-    prod = (floatval_t *)calloc(sizeof(floatval_t), K);
-    viterbi = (int *)calloc(sizeof(int), T);
-    if (mean == NULL || cov == NULL || prod == NULL || viterbi == NULL)
-    {
-        ret = CRFSUITEERR_OUTOFMEMORY;
-        goto error_exit;
-    }
-
-    /* Initialize the covariance vector (diagnal matrix). */
-    vecset(cov, opt.variance, K);
-
-    logging(lg, "Start training with AROW");
-    beta = 1.0 / opt.gamma;
-
-    /* Loop for epoch. */
-    for (i = 0; i < opt.max_iterations; ++i)
-    {
-        floatval_t norm = 0., sum_loss = 0.;
-        clock_t iteration_begin = clock();
-
-        /* Shuffle the instances. */
-        dataset_shuffle(trainset);
-
-        /* Loop for each instance. */
-        for (n = 0; n < N; ++n)
-        {
-            int d = 0;
-            floatval_t sv;
-            const crfsuite_instance_t *inst = dataset_get(trainset, n);
-
-            /* Set the feature weights to the encoder. */
-            gm->set_weights(gm, mean, 1.);
-            gm->set_instance(gm, inst);
-
-            /* Tag the sequence with the current model. */
-            gm->viterbi(gm, viterbi, &sv);
-
-            /* Compute the number of different labels. */
-            d = diff(inst->labels, viterbi, inst->num_items);
-            if (0 < d)
-            {
-                floatval_t alpha, frac;
-                floatval_t sc;
-                floatval_t cost;
-
-                /*
-                    Compute the cost of this instance.
-                 */
-                gm->score(gm, inst->labels, &sc);
-                cost = sv - sc + (double)d;
-
-                /* Initialize delta[k] = 0. */
-                delta_reset(&dc);
-
-                /*
-                    For every feature k on the correct path:
-                        delta[k] += 1;
-                 */
-                dc.c = inst->weight;
-                gm->features_on_path(gm, inst, inst->labels, delta_collect, &dc);
-
-                /*
-                    For every feature k on the Viterbi path:
-                        delta[k] -= 1;
-                 */
-                dc.c = -inst->weight;
-                gm->features_on_path(gm, inst, viterbi, delta_collect, &dc);
-
-                delta_finalize(&dc);
-
-                /* Compute prod[k] = delta[k] * delta[k]. */
-                for (j = 0; j < dc.num_actives; ++j)
-                {
-                    k = dc.actives[j];
-                    prod[k] = dc.delta[k] * dc.delta[k];
-                }
-
-                /*
-                    Compute alpha.
-                 */
-                frac = opt.gamma;
-                for (j = 0; j < dc.num_actives; ++j)
-                {
-                    k = dc.actives[j];
-                    frac += prod[k] * cov[k];
-                }
-                alpha = cost / frac;
-
-                /*
-                    Update.
-                 */
-                for (j = 0; j < dc.num_actives; ++j)
-                {
-                    k = dc.actives[j];
-                    mean[k] += alpha * cov[k] * dc.delta[k];
-                    cov[k] = 1.0 / ((1.0 / cov[k]) + prod[k] / opt.gamma);
-                }
-
-                sum_loss += cost * inst->weight;
-            }
-        }
-
-        /* Output the progress. */
-        logging(lg, "Iteration %d, training loss: %f", i + 1, sum_loss);
-
-        /* Holdout evaluation if necessary. */
-        if (testset != NULL)
-        {
-            holdout_evaluation(gm, testset, mean, lg);
-        }
-
-        /* Convergence test. */
-        if (sum_loss / N <= opt.epsilon)
-        {
-            logging(lg, "Loss has converged, terminating training");
-            break;
-        }
-    }
-
-    free(viterbi);
-    free(prod);
-    free(cov);
-    *ptr_w = mean;
-    delta_finish(&dc);
-    return ret;
-
-error_exit:
-    free(viterbi);
-    free(prod);
-    free(cov);
-    free(mean);
-    *ptr_w = NULL;
-    delta_finish(&dc);
-
-    return ret;
-}
+/*
+ *      Online training with Adaptive Regularization of Weights (AROW).
+ *
+ * Copyright (c) 2007-2010, Naoaki Okazaki
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the names of the authors nor the names of its contributors
+ *       may be used to endorse or promote products derived from this
+ *       software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+ * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/* $Id$ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif /*HAVE_CONFIG_H*/
+
+#include <os.h>
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <time.h>
+
+#include <crfsuite.h>
+#include "crfsuite_internal.h"
+#include "logging.h"
+#include "params.h"
+#include "vecmath.h"
+
+#define MIN(a, b) ((a) < (b) ? (a) : (b))
+
+/**
+ * Training parameters (configurable with crfsuite_params_t interface).
+ */
+typedef struct
+{
+    floatval_t variance;
+    floatval_t gamma;
+    int max_iterations;
+    floatval_t epsilon;
+} training_option_t;
+
+/**
+ * Internal data structure for computing the sparse vector F(x, y) - F(x, y').
+ */
+typedef struct
+{
+    /* An array of feature indices relevant to the instance. */
+    int *actives;
+    int num_actives;
+    int cap_actives;
+    char *used;
+
+    /* Coefficient for collecting feature weights. */
+    floatval_t c;
+    /* The difference vector [K]. */
+    floatval_t *delta;
+    /* The number of features. */
+    int K;
+} delta_t;
+
+static int delta_init(delta_t *dc, const int K)
+{
+    memset(dc, 0, sizeof(*dc));
+    dc->used = (char *)calloc(K, sizeof(char));
+    dc->delta = (floatval_t *)calloc(K, sizeof(floatval_t));
+    dc->K = K;
+    if (dc->delta == NULL || dc->used == NULL)
+    {
+        return 1;
+    }
+    return 0;
+}
+
+static void delta_finish(delta_t *dc)
+{
+    free(dc->actives);
+    free(dc->used);
+    free(dc->delta);
+    memset(dc, 0, sizeof(*dc));
+}
+
+static void delta_reset(delta_t *dc)
+{
+    int i;
+    for (i = 0; i < dc->num_actives; ++i)
+    {
+        int k = dc->actives[i];
+        dc->delta[k] = 0;
+    }
+    dc->num_actives = 0;
+}
+
+static void delta_collect(void *instance, int fid, floatval_t value)
+{
+    delta_t *dc = (delta_t *)instance;
+
+    /* Expand the active feature list if necessary. */
+    if (dc->cap_actives <= dc->num_actives)
+    {
+        ++dc->cap_actives;
+        dc->cap_actives *= 2;
+        dc->actives = (int *)realloc(dc->actives, sizeof(int) * dc->cap_actives);
+    }
+
+    dc->actives[dc->num_actives++] = fid;
+    dc->delta[fid] += dc->c * value;
+}
+
+static void delta_finalize(delta_t *dc)
+{
+    int i, j = 0, k;
+
+    /* Collapse the duplicated indices. */
+    for (i = 0; i < dc->num_actives; ++i)
+    {
+        k = dc->actives[i];
+        if (!dc->used[k])
+        {
+            dc->actives[j++] = k;
+            dc->used[k] = 1;
+        }
+    }
+    dc->num_actives = j; /* This is the distinct number of indices. */
+
+    /* Reset the used flag. */
+    for (i = 0; i < dc->num_actives; ++i)
+    {
+        k = dc->actives[i];
+        dc->used[k] = 0;
+    }
+}
+
+static floatval_t delta_norm2(delta_t *dc)
+{
+    int i;
+    floatval_t norm2 = 0.;
+
+    for (i = 0; i < dc->num_actives; ++i)
+    {
+        int k = dc->actives[i];
+        norm2 += dc->delta[k] * dc->delta[k];
+    }
+    return norm2;
+}
+
+static void delta_add(delta_t *dc, floatval_t *w, floatval_t *ws, const floatval_t tau, const floatval_t u)
+{
+    int i;
+    const floatval_t tauu = tau * u;
+
+    for (i = 0; i < dc->num_actives; ++i)
+    {
+        int k = dc->actives[i];
+        w[k] += tau * dc->delta[k];
+        ws[k] += tauu * dc->delta[k];
+    }
+}
+
+static int diff(int *x, int *y, int n)
+{
+    int i, d = 0;
+    for (i = 0; i < n; ++i)
+    {
+        if (x[i] != y[i])
+        {
+            ++d;
+        }
+    }
+    return d;
+}
+
+static floatval_t cost_insensitive(floatval_t err, floatval_t d)
+{
+    return err + 1.;
+}
+
+static floatval_t cost_sensitive(floatval_t err, floatval_t d)
+{
+    return err + sqrt(d);
+}
+
+static floatval_t tau0(floatval_t cost, floatval_t norm, floatval_t c)
+{
+    return cost / norm;
+}
+
+static floatval_t tau1(floatval_t cost, floatval_t norm, floatval_t c)
+{
+    return MIN(c, cost / norm);
+}
+
+static floatval_t tau2(floatval_t cost, floatval_t norm, floatval_t c)
+{
+    return cost / (norm + 0.5 / c);
+}
+
+static int exchange_options(crfsuite_params_t *params, training_option_t *opt, int mode)
+{
+    BEGIN_PARAM_MAP(params, mode)
+    DDX_PARAM_FLOAT(
+        "variance", opt->variance, 1.,
+        "The initial variance of every feature weight.")
+    DDX_PARAM_FLOAT(
+        "gamma", opt->gamma, 1.,
+        "Tradeoff parameter.")
+    DDX_PARAM_INT(
+        "max_iterations", opt->max_iterations, 100,
+        "The maximum number of iterations.")
+    DDX_PARAM_FLOAT(
+        "epsilon", opt->epsilon, 0.,
+        "The stopping criterion (the mean loss).")
+    END_PARAM_MAP()
+
+    return 0;
+}
+
+void crfsuite_train_arow_init(crfsuite_params_t *params)
+{
+    exchange_options(params, NULL, 0);
+}
+
+int crfsuite_train_arow(
+    encoder_t *gm,
+    dataset_t *trainset,
+    dataset_t *testset,
+    crfsuite_params_t *params,
+    logging_t *lg,
+    floatval_t **ptr_w)
+{
+    int n, i, j, k, ret = 0;
+    int *viterbi = NULL;
+    floatval_t beta;
+    floatval_t *mean = NULL, *cov = NULL, *prod = NULL;
+    const int N = trainset->num_instances;
+    const int K = gm->num_features;
+    const int T = gm->cap_items;
+    training_option_t opt;
+    delta_t dc;
+    clock_t begin = clock();
+
+    /* Initialize the variable. */
+    if (delta_init(&dc, K) != 0)
+    {
+        ret = CRFSUITEERR_OUTOFMEMORY;
+        goto error_exit;
+    }
+
+    /* Obtain parameter values. */
+    exchange_options(params, &opt, -1);
+
+    /* Allocate arrays. */
+    mean = (floatval_t *)calloc(sizeof(floatval_t), K);
+    cov = (floatval_t *)calloc(sizeof(floatval_t), K);
+    prod = (floatval_t *)calloc(sizeof(floatval_t), K);
+    viterbi = (int *)calloc(sizeof(int), T);
+    if (mean == NULL || cov == NULL || prod == NULL || viterbi == NULL)
+    {
+        ret = CRFSUITEERR_OUTOFMEMORY;
+        goto error_exit;
+    }
+
+    /* Initialize the covariance vector (diagnal matrix). */
+    vecset(cov, opt.variance, K);
+
+    logging(lg, "Start training with AROW");
+    beta = 1.0 / opt.gamma;
+
+    /* Loop for epoch. */
+    for (i = 0; i < opt.max_iterations; ++i)
+    {
+        floatval_t norm = 0., sum_loss = 0.;
+        clock_t iteration_begin = clock();
+
+        /* Shuffle the instances. */
+        dataset_shuffle(trainset);
+
+        /* Loop for each instance. */
+        for (n = 0; n < N; ++n)
+        {
+            int d = 0;
+            floatval_t sv;
+            const crfsuite_instance_t *inst = dataset_get(trainset, n);
+
+            /* Set the feature weights to the encoder. */
+            gm->set_weights(gm, mean, 1.);
+            gm->set_instance(gm, inst);
+
+            /* Tag the sequence with the current model. */
+            gm->viterbi(gm, viterbi, &sv);
+
+            /* Compute the number of different labels. */
+            d = diff(inst->labels, viterbi, inst->num_items);
+            if (0 < d)
+            {
+                floatval_t alpha, frac;
+                floatval_t sc;
+                floatval_t cost;
+
+                /*
+                    Compute the cost of this instance.
+                 */
+                gm->score(gm, inst->labels, &sc);
+                cost = sv - sc + (double)d;
+
+                /* Initialize delta[k] = 0. */
+                delta_reset(&dc);
+
+                /*
+                    For every feature k on the correct path:
+                        delta[k] += 1;
+                 */
+                dc.c = inst->weight;
+                gm->features_on_path(gm, inst, inst->labels, delta_collect, &dc);
+
+                /*
+                    For every feature k on the Viterbi path:
+                        delta[k] -= 1;
+                 */
+                dc.c = -inst->weight;
+                gm->features_on_path(gm, inst, viterbi, delta_collect, &dc);
+
+                delta_finalize(&dc);
+
+                /* Compute prod[k] = delta[k] * delta[k]. */
+                for (j = 0; j < dc.num_actives; ++j)
+                {
+                    k = dc.actives[j];
+                    prod[k] = dc.delta[k] * dc.delta[k];
+                }
+
+                /*
+                    Compute alpha.
+                 */
+                frac = opt.gamma;
+                for (j = 0; j < dc.num_actives; ++j)
+                {
+                    k = dc.actives[j];
+                    frac += prod[k] * cov[k];
+                }
+                alpha = cost / frac;
+
+                /*
+                    Update.
+                 */
+                for (j = 0; j < dc.num_actives; ++j)
+                {
+                    k = dc.actives[j];
+                    mean[k] += alpha * cov[k] * dc.delta[k];
+                    cov[k] = 1.0 / ((1.0 / cov[k]) + prod[k] / opt.gamma);
+                }
+
+                sum_loss += cost * inst->weight;
+            }
+        }
+
+        /* Output the progress. */
+        logging(lg, "Iteration %d, training loss: %f", i + 1, sum_loss);
+
+        /* Holdout evaluation if necessary. */
+        if (testset != NULL)
+        {
+            holdout_evaluation(gm, testset, mean, lg);
+        }
+
+        /* Convergence test. */
+        if (sum_loss / N <= opt.epsilon)
+        {
+            logging(lg, "Loss has converged, terminating training");
+            break;
+        }
+    }
+
+    free(viterbi);
+    free(prod);
+    free(cov);
+    *ptr_w = mean;
+    delta_finish(&dc);
+    return ret;
+
+error_exit:
+    free(viterbi);
+    free(prod);
+    free(cov);
+    free(mean);
+    *ptr_w = NULL;
+    delta_finish(&dc);
+
+    return ret;
+}
```

## chaine/_core/crfsuite/lib/crf/src/train_averaged_perceptron.c

 * *Ordering differences only*

```diff
@@ -1,237 +1,237 @@
-/*
- *      Online training with averaged perceptron.
- *
- * Copyright (c) 2007-2010, Naoaki Okazaki
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the names of the authors nor the names of its contributors
- *       may be used to endorse or promote products derived from this
- *       software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
- * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-/* $Id$ */
-
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif /*HAVE_CONFIG_H*/
-
-#include <os.h>
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <time.h>
-
-#include <crfsuite.h>
-#include "crfsuite_internal.h"
-#include "logging.h"
-#include "params.h"
-#include "vecmath.h"
-
-/**
- * Training parameters (configurable with crfsuite_params_t interface).
- */
-typedef struct
-{
-    int max_iterations;
-    floatval_t epsilon;
-} training_option_t;
-
-/**
- * Internal data structure for updating (averaging) feature weights.
- */
-typedef struct
-{
-    floatval_t *w;
-    floatval_t *ws;
-    floatval_t c;
-    floatval_t cs;
-} update_data;
-
-static void update_weights(void *instance, int fid, floatval_t value)
-{
-    update_data *ud = (update_data *)instance;
-    ud->w[fid] += ud->c * value;
-    ud->ws[fid] += ud->cs * value;
-}
-
-static int diff(int *x, int *y, int n)
-{
-    int i, d = 0;
-    for (i = 0; i < n; ++i)
-    {
-        if (x[i] != y[i])
-        {
-            ++d;
-        }
-    }
-    return d;
-}
-
-static int exchange_options(crfsuite_params_t *params, training_option_t *opt, int mode)
-{
-    BEGIN_PARAM_MAP(params, mode)
-    DDX_PARAM_INT(
-        "max_iterations", opt->max_iterations, 100,
-        "The maximum number of iterations.")
-    DDX_PARAM_FLOAT(
-        "epsilon", opt->epsilon, 0.,
-        "The stopping criterion (the ratio of incorrect label predictions).")
-    END_PARAM_MAP()
-
-    return 0;
-}
-
-void crfsuite_train_averaged_perceptron_init(crfsuite_params_t *params)
-{
-    exchange_options(params, NULL, 0);
-}
-
-int crfsuite_train_averaged_perceptron(
-    encoder_t *gm,
-    dataset_t *trainset,
-    dataset_t *testset,
-    crfsuite_params_t *params,
-    logging_t *lg,
-    floatval_t **ptr_w)
-{
-    int n, i, c, ret = 0;
-    int *viterbi = NULL;
-    floatval_t *w = NULL;
-    floatval_t *ws = NULL;
-    floatval_t *wa = NULL;
-    const int N = trainset->num_instances;
-    const int K = gm->num_features;
-    const int T = gm->cap_items;
-    training_option_t opt;
-    update_data ud;
-    clock_t begin = clock();
-
-    /* Initialize the variable. */
-    memset(&ud, 0, sizeof(ud));
-
-    /* Obtain parameter values. */
-    exchange_options(params, &opt, -1);
-
-    /* Allocate arrays. */
-    w = (floatval_t *)calloc(sizeof(floatval_t), K);
-    ws = (floatval_t *)calloc(sizeof(floatval_t), K);
-    wa = (floatval_t *)calloc(sizeof(floatval_t), K);
-    viterbi = (int *)calloc(sizeof(int), T);
-    if (w == NULL || ws == NULL || wa == NULL || viterbi == NULL)
-    {
-        ret = CRFSUITEERR_OUTOFMEMORY;
-        goto error_exit;
-    }
-
-    /* Show the parameters. */
-    logging(lg, "Start training with AP");
-
-    c = 1;
-    ud.w = w;
-    ud.ws = ws;
-
-    /* Loop for epoch. */
-    for (i = 0; i < opt.max_iterations; ++i)
-    {
-        floatval_t norm = 0., loss = 0.;
-        clock_t iteration_begin = clock();
-
-        /* Shuffle the instances. */
-        dataset_shuffle(trainset);
-
-        /* Loop for each instance. */
-        for (n = 0; n < N; ++n)
-        {
-            int d = 0;
-            floatval_t score;
-            const crfsuite_instance_t *inst = dataset_get(trainset, n);
-
-            /* Set the feature weights to the encoder. */
-            gm->set_weights(gm, w, 1.);
-            gm->set_instance(gm, inst);
-
-            /* Tag the sequence with the current model. */
-            gm->viterbi(gm, viterbi, &score);
-
-            /* Compute the number of different labels. */
-            d = diff(inst->labels, viterbi, inst->num_items);
-            if (0 < d)
-            {
-                /*
-                    For every feature k on the correct path:
-                        w[k] += 1; ws[k] += c;
-                 */
-                ud.c = inst->weight;
-                ud.cs = c * inst->weight;
-                gm->features_on_path(gm, inst, inst->labels, update_weights, &ud);
-
-                /*
-                    For every feature k on the Viterbi path:
-                        w[k] -= 1; ws[k] -= c;
-                 */
-                ud.c = -inst->weight;
-                ud.cs = -c * inst->weight;
-                gm->features_on_path(gm, inst, viterbi, update_weights, &ud);
-
-                /* We define the loss as the ratio of wrongly predicted labels. */
-                loss += d / (floatval_t)inst->num_items * inst->weight;
-            }
-
-            ++c;
-        }
-
-        /* Perform averaging to wa. */
-        veccopy(wa, w, K);
-        vecasub(wa, 1. / c, ws, K);
-
-        /* Output the progress. */
-        logging(lg, "Iteration %d, training loss: %f", i + 1, loss);
-
-        /* Holdout evaluation if necessary. */
-        if (testset != NULL)
-        {
-            holdout_evaluation(gm, testset, wa, lg);
-        }
-
-        /* Convergence test. */
-        if (loss / N < opt.epsilon)
-        {
-            logging(lg, "Loss has converged, terminating training");
-            break;
-        }
-    }
-
-    free(viterbi);
-    free(ws);
-    free(w);
-    *ptr_w = wa;
-    return ret;
-
-error_exit:
-    free(viterbi);
-    free(wa);
-    free(ws);
-    free(w);
-    *ptr_w = NULL;
-
-    return ret;
-}
+/*
+ *      Online training with averaged perceptron.
+ *
+ * Copyright (c) 2007-2010, Naoaki Okazaki
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the names of the authors nor the names of its contributors
+ *       may be used to endorse or promote products derived from this
+ *       software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+ * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/* $Id$ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif /*HAVE_CONFIG_H*/
+
+#include <os.h>
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <time.h>
+
+#include <crfsuite.h>
+#include "crfsuite_internal.h"
+#include "logging.h"
+#include "params.h"
+#include "vecmath.h"
+
+/**
+ * Training parameters (configurable with crfsuite_params_t interface).
+ */
+typedef struct
+{
+    int max_iterations;
+    floatval_t epsilon;
+} training_option_t;
+
+/**
+ * Internal data structure for updating (averaging) feature weights.
+ */
+typedef struct
+{
+    floatval_t *w;
+    floatval_t *ws;
+    floatval_t c;
+    floatval_t cs;
+} update_data;
+
+static void update_weights(void *instance, int fid, floatval_t value)
+{
+    update_data *ud = (update_data *)instance;
+    ud->w[fid] += ud->c * value;
+    ud->ws[fid] += ud->cs * value;
+}
+
+static int diff(int *x, int *y, int n)
+{
+    int i, d = 0;
+    for (i = 0; i < n; ++i)
+    {
+        if (x[i] != y[i])
+        {
+            ++d;
+        }
+    }
+    return d;
+}
+
+static int exchange_options(crfsuite_params_t *params, training_option_t *opt, int mode)
+{
+    BEGIN_PARAM_MAP(params, mode)
+    DDX_PARAM_INT(
+        "max_iterations", opt->max_iterations, 100,
+        "The maximum number of iterations.")
+    DDX_PARAM_FLOAT(
+        "epsilon", opt->epsilon, 0.,
+        "The stopping criterion (the ratio of incorrect label predictions).")
+    END_PARAM_MAP()
+
+    return 0;
+}
+
+void crfsuite_train_averaged_perceptron_init(crfsuite_params_t *params)
+{
+    exchange_options(params, NULL, 0);
+}
+
+int crfsuite_train_averaged_perceptron(
+    encoder_t *gm,
+    dataset_t *trainset,
+    dataset_t *testset,
+    crfsuite_params_t *params,
+    logging_t *lg,
+    floatval_t **ptr_w)
+{
+    int n, i, c, ret = 0;
+    int *viterbi = NULL;
+    floatval_t *w = NULL;
+    floatval_t *ws = NULL;
+    floatval_t *wa = NULL;
+    const int N = trainset->num_instances;
+    const int K = gm->num_features;
+    const int T = gm->cap_items;
+    training_option_t opt;
+    update_data ud;
+    clock_t begin = clock();
+
+    /* Initialize the variable. */
+    memset(&ud, 0, sizeof(ud));
+
+    /* Obtain parameter values. */
+    exchange_options(params, &opt, -1);
+
+    /* Allocate arrays. */
+    w = (floatval_t *)calloc(sizeof(floatval_t), K);
+    ws = (floatval_t *)calloc(sizeof(floatval_t), K);
+    wa = (floatval_t *)calloc(sizeof(floatval_t), K);
+    viterbi = (int *)calloc(sizeof(int), T);
+    if (w == NULL || ws == NULL || wa == NULL || viterbi == NULL)
+    {
+        ret = CRFSUITEERR_OUTOFMEMORY;
+        goto error_exit;
+    }
+
+    /* Show the parameters. */
+    logging(lg, "Start training with AP");
+
+    c = 1;
+    ud.w = w;
+    ud.ws = ws;
+
+    /* Loop for epoch. */
+    for (i = 0; i < opt.max_iterations; ++i)
+    {
+        floatval_t norm = 0., loss = 0.;
+        clock_t iteration_begin = clock();
+
+        /* Shuffle the instances. */
+        dataset_shuffle(trainset);
+
+        /* Loop for each instance. */
+        for (n = 0; n < N; ++n)
+        {
+            int d = 0;
+            floatval_t score;
+            const crfsuite_instance_t *inst = dataset_get(trainset, n);
+
+            /* Set the feature weights to the encoder. */
+            gm->set_weights(gm, w, 1.);
+            gm->set_instance(gm, inst);
+
+            /* Tag the sequence with the current model. */
+            gm->viterbi(gm, viterbi, &score);
+
+            /* Compute the number of different labels. */
+            d = diff(inst->labels, viterbi, inst->num_items);
+            if (0 < d)
+            {
+                /*
+                    For every feature k on the correct path:
+                        w[k] += 1; ws[k] += c;
+                 */
+                ud.c = inst->weight;
+                ud.cs = c * inst->weight;
+                gm->features_on_path(gm, inst, inst->labels, update_weights, &ud);
+
+                /*
+                    For every feature k on the Viterbi path:
+                        w[k] -= 1; ws[k] -= c;
+                 */
+                ud.c = -inst->weight;
+                ud.cs = -c * inst->weight;
+                gm->features_on_path(gm, inst, viterbi, update_weights, &ud);
+
+                /* We define the loss as the ratio of wrongly predicted labels. */
+                loss += d / (floatval_t)inst->num_items * inst->weight;
+            }
+
+            ++c;
+        }
+
+        /* Perform averaging to wa. */
+        veccopy(wa, w, K);
+        vecasub(wa, 1. / c, ws, K);
+
+        /* Output the progress. */
+        logging(lg, "Iteration %d, training loss: %f", i + 1, loss);
+
+        /* Holdout evaluation if necessary. */
+        if (testset != NULL)
+        {
+            holdout_evaluation(gm, testset, wa, lg);
+        }
+
+        /* Convergence test. */
+        if (loss / N < opt.epsilon)
+        {
+            logging(lg, "Loss has converged, terminating training");
+            break;
+        }
+    }
+
+    free(viterbi);
+    free(ws);
+    free(w);
+    *ptr_w = wa;
+    return ret;
+
+error_exit:
+    free(viterbi);
+    free(wa);
+    free(ws);
+    free(w);
+    *ptr_w = NULL;
+
+    return ret;
+}
```

## chaine/_core/crfsuite/lib/crf/src/train_l2sgd.c

 * *Ordering differences only*

```diff
@@ -1,491 +1,491 @@
-/*
- *      Online training with L2-regularized Stochastic Gradient Descent (SGD).
- *
- * Copyright (c) 2007-2010, Naoaki Okazaki
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the names of the authors nor the names of its contributors
- *       may be used to endorse or promote products derived from this
- *       software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
- * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-/* $Id$ */
-
-/*
-    SGD for L2-regularized MAP estimation.
-
-    The iterative algorithm is inspired by Pegasos:
-
-    Shai Shalev-Shwartz, Yoram Singer, and Nathan Srebro.
-    Pegasos: Primal Estimated sub-GrAdient SOlver for SVM.
-    In Proc. of ICML 2007, pp 807-814, 2007.
-
-    The calibration strategy is inspired by the implementation of sgd:
-    http://leon.bottou.org/projects/sgd
-    written by Lon Bottou.
-
-    The objective function to minimize is:
-
-        f(w) = (lambda/2) * ||w||^2 + (1/N) * \sum_i^N log P^i(y|x)
-        lambda = 2 * C / N
-
-    The original version of the Pegasos algorithm.
-
-    0) Initialization
-        t = t0
-        k = [the batch size]
-    1) Computing the learning rate (eta).
-        eta = 1 / (lambda * t)
-    2) Updating feature weights.
-        w = (1 - eta * lambda) w - (eta / k) \sum_i (oexp - mexp)
-    3) Projecting feature weights within an L2-ball.
-        w = min{1, (1/sqrt(lambda))/||w||} * w
-    4) Goto 1 until convergence.
-
-    This implementation omit the step 3) because it makes the source code
-    tricky (in order to maintain L2-norm of feature weights at any time) and
-    because the project step does not have a strong impact to the quality of
-    solution.
-
-    A naive implementation requires O(K) computations for steps 2,
-    where K is the total number of features. This code implements the procedure
-    in an efficient way:
-
-    0) Initialization
-        decay = 1
-    1) Computing various factors
-        eta = 1 / (lambda * t)
-        decay *= (1 - eta * lambda)
-        gain = (eta / k) / decay
-    2) Updating feature weights
-        Updating feature weights from observation expectation:
-            delta = gain * (1.0) * f(x,y)
-            w += delta
-        Updating feature weights from model expectation:
-            delta = gain * (-P(y|x)) * f(x,y)
-            w += delta
-    4) Goto 1 until convergence.
-*/
-
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif /*HAVE_CONFIG_H*/
-
-#include <os.h>
-
-#include <float.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <time.h>
-#include <math.h>
-
-#include <crfsuite.h>
-#include "crfsuite_internal.h"
-
-#include "logging.h"
-#include "params.h"
-#include "crf1d.h"
-#include "vecmath.h"
-
-#define MIN(a, b) ((a) < (b) ? (a) : (b))
-
-typedef struct
-{
-    floatval_t c2;
-    floatval_t lambda;
-    floatval_t t0;
-    int max_iterations;
-    int period;
-    floatval_t delta;
-    floatval_t calibration_eta;
-    floatval_t calibration_rate;
-    int calibration_samples;
-    int calibration_candidates;
-    int calibration_max_trials;
-} training_option_t;
-
-static int l2sgd(
-    encoder_t *gm,
-    dataset_t *trainset,
-    dataset_t *testset,
-    floatval_t *w,
-    logging_t *lg,
-    const int N,
-    const floatval_t t0,
-    const floatval_t lambda,
-    const int num_epochs,
-    int calibration,
-    int period,
-    const floatval_t epsilon,
-    floatval_t *ptr_loss)
-{
-    int i, epoch, ret = 0;
-    floatval_t t = 0;
-    floatval_t loss = 0, sum_loss = 0;
-    floatval_t best_sum_loss = DBL_MAX;
-    floatval_t eta, gain, decay = 1.;
-    floatval_t improvement = 0.;
-    floatval_t norm2 = 0.;
-    floatval_t *pf = NULL;
-    floatval_t *best_w = NULL;
-    clock_t clk_prev, clk_begin = clock();
-    const int K = gm->num_features;
-
-    if (!calibration)
-    {
-        pf = (floatval_t *)malloc(sizeof(floatval_t) * period);
-        best_w = (floatval_t *)calloc(K, sizeof(floatval_t));
-        if (pf == NULL || best_w == NULL)
-        {
-            ret = CRFSUITEERR_OUTOFMEMORY;
-            goto error_exit;
-        }
-    }
-
-    /* Initialize the feature weights. */
-    vecset(w, 0, K);
-
-    /* Loop for epochs. */
-    for (epoch = 1; epoch <= num_epochs; ++epoch)
-    {
-        clk_prev = clock();
-
-        if (!calibration)
-        {
-            /* Shuffle the training instances. */
-            dataset_shuffle(trainset);
-        }
-
-        /* Loop for instances. */
-        sum_loss = 0.;
-        for (i = 0; i < N; ++i)
-        {
-            const crfsuite_instance_t *inst = dataset_get(trainset, i);
-
-            /* Update various factors. */
-            eta = 1 / (lambda * (t0 + t));
-            decay *= (1.0 - eta * lambda);
-            gain = eta / decay;
-
-            /* Compute the loss and gradients for the instance. */
-            gm->set_weights(gm, w, decay);
-            gm->set_instance(gm, inst);
-            gm->objective_and_gradients(gm, &loss, w, gain, inst->weight);
-
-            sum_loss += loss;
-            ++t;
-        }
-
-        /* Terminate when the loss is abnormal (NaN, -Inf, +Inf). */
-        if (!isfinite(loss))
-        {
-            logging(lg, "Loss is abnormal");
-            ret = CRFSUITEERR_OVERFLOW;
-            sum_loss = loss;
-            goto error_exit;
-        }
-
-        /* Scale the feature weights. */
-        vecscale(w, decay, K);
-        decay = 1.;
-
-        /* Include the L2 norm of feature weights to the objective. */
-        /* The factor N is necessary because lambda = 2 * C / N. */
-        norm2 = vecdot(w, w, K);
-        sum_loss += 0.5 * lambda * norm2 * N;
-
-        /* One epoch finished. */
-        if (!calibration)
-        {
-            /* Check if the current epoch is the best. */
-            if (sum_loss < best_sum_loss)
-            {
-                /* Store the feature weights to best_w. */
-                best_sum_loss = sum_loss;
-                veccopy(best_w, w, K);
-            }
-
-            /* We don't test the stopping criterion while period < epoch. */
-            if (period < epoch)
-            {
-                improvement = (pf[(epoch - 1) % period] - sum_loss) / sum_loss;
-            }
-            else
-            {
-                improvement = epsilon;
-            }
-
-            /* Store the current value of the objective function. */
-            pf[(epoch - 1) % period] = sum_loss;
-
-            logging(lg, "Epoch %d, learning rate: %f, training loss: %f", epoch, eta, sum_loss);
-
-            /* Check for the stopping criterion. */
-            if (improvement < epsilon)
-            {
-                ret = 0;
-                break;
-            }
-        }
-    }
-
-    /* Output the optimization result. */
-    if (!calibration)
-    {
-        if (ret == 0)
-        {
-            if (epoch < num_epochs)
-            {
-                logging(lg, "Loss has converged, terminating training");
-            }
-            else
-            {
-                logging(lg, "Reached maximum number of iterations, terminating training");
-            }
-        }
-    }
-
-    /* Restore the best weights. */
-    if (best_w != NULL)
-    {
-        sum_loss = best_sum_loss;
-        veccopy(w, best_w, K);
-    }
-
-error_exit:
-    free(best_w);
-    free(pf);
-    if (ptr_loss != NULL)
-    {
-        *ptr_loss = sum_loss;
-    }
-    return ret;
-}
-
-static floatval_t
-l2sgd_calibration(
-    encoder_t *gm,
-    dataset_t *ds,
-    floatval_t *w,
-    logging_t *lg,
-    const training_option_t *opt)
-{
-    int i;
-    int dec = 0, ok, trials = 1;
-    int num = opt->calibration_candidates;
-    clock_t clk_begin = clock();
-    floatval_t loss = 0.;
-    floatval_t init_loss = 0.;
-    floatval_t best_loss = DBL_MAX;
-    floatval_t eta = opt->calibration_eta;
-    floatval_t best_eta = opt->calibration_eta;
-    const int N = ds->num_instances;
-    const int S = MIN(N, opt->calibration_samples);
-    const int K = gm->num_features;
-    const floatval_t init_eta = opt->calibration_eta;
-    const floatval_t rate = opt->calibration_rate;
-    const floatval_t lambda = opt->lambda;
-
-    logging(lg, "Calibrating learning rate");
-
-    /* Initialize a permutation that shuffles the instances. */
-    dataset_shuffle(ds);
-
-    /* Initialize feature weights as zero. */
-    vecset(w, 0, K);
-
-    /* Compute the initial loss. */
-    gm->set_weights(gm, w, 1.);
-    init_loss = 0;
-    for (i = 0; i < S; ++i)
-    {
-        floatval_t score;
-        const crfsuite_instance_t *inst = dataset_get(ds, i);
-        gm->set_instance(gm, inst);
-        gm->score(gm, inst->labels, &score);
-        init_loss -= score;
-        gm->partition_factor(gm, &score);
-        init_loss += score;
-    }
-    init_loss += 0.5 * lambda * vecdot(w, w, K) * N;
-    logging(lg, "Initial training loss: %f", init_loss);
-
-    while (num > 0 || !dec)
-    {
-        /* Perform SGD for one epoch. */
-        l2sgd(
-            gm,
-            ds,
-            NULL,
-            w,
-            lg,
-            S, 1.0 / (lambda * eta), lambda, 1, 1, 1, 0., &loss);
-
-        /* Make sure that the learning rate decreases the log-likelihood. */
-        ok = isfinite(loss) && (loss < init_loss);
-
-        logging(lg, "Trial %d, learning rate %f, training loss: %f", trials, eta, loss);
-
-        if (ok)
-        {
-            --num;
-        }
-
-        if (isfinite(loss) && loss < best_loss)
-        {
-            best_loss = loss;
-            best_eta = eta;
-        }
-
-        if (!dec)
-        {
-            if (ok && 0 < num)
-            {
-                eta *= rate;
-            }
-            else
-            {
-                dec = 1;
-                num = opt->calibration_candidates;
-                eta = init_eta / rate;
-            }
-        }
-        else
-        {
-            eta /= rate;
-        }
-
-        ++trials;
-        if (opt->calibration_max_trials <= trials)
-        {
-            break;
-        }
-    }
-
-    eta = best_eta;
-    logging(lg, "Best learning rate: %f", eta);
-
-    return 1.0 / (lambda * eta);
-}
-
-int exchange_options(crfsuite_params_t *params, training_option_t *opt, int mode)
-{
-    BEGIN_PARAM_MAP(params, mode)
-    DDX_PARAM_FLOAT(
-        "c2", opt->c2, 1.,
-        "Coefficient for L2 regularization.")
-    DDX_PARAM_INT(
-        "max_iterations", opt->max_iterations, 1000,
-        "The maximum number of iterations (epochs) for SGD optimization.")
-    DDX_PARAM_INT(
-        "period", opt->period, 10,
-        "The duration of iterations to test the stopping criterion.")
-    DDX_PARAM_FLOAT(
-        "delta", opt->delta, 1e-6,
-        "The threshold for the stopping criterion; an optimization process stops when\n"
-        "the improvement of the log likelihood over the last ${period} iterations is no\n"
-        "greater than this threshold.")
-    DDX_PARAM_FLOAT(
-        "calibration.eta", opt->calibration_eta, 0.1,
-        "The initial value of learning rate (eta) used for calibration.")
-    DDX_PARAM_FLOAT(
-        "calibration.rate", opt->calibration_rate, 2.,
-        "The rate of increase/decrease of learning rate for calibration.")
-    DDX_PARAM_INT(
-        "calibration.samples", opt->calibration_samples, 1000,
-        "The number of instances used for calibration.")
-    DDX_PARAM_INT(
-        "calibration.candidates", opt->calibration_candidates, 10,
-        "The number of candidates of learning rate.")
-    DDX_PARAM_INT(
-        "calibration.max_trials", opt->calibration_max_trials, 20,
-        "The maximum number of trials of learning rates for calibration.")
-    END_PARAM_MAP()
-
-    return 0;
-}
-
-void crfsuite_train_l2sgd_init(crfsuite_params_t *params)
-{
-    exchange_options(params, NULL, 0);
-}
-
-int crfsuite_train_l2sgd(
-    encoder_t *gm,
-    dataset_t *trainset,
-    dataset_t *testset,
-    crfsuite_params_t *params,
-    logging_t *lg,
-    floatval_t **ptr_w)
-{
-    int ret = 0;
-    floatval_t *w = NULL;
-    clock_t clk_begin;
-    floatval_t loss = 0;
-    const int N = trainset->num_instances;
-    const int K = gm->num_features;
-    const int T = gm->cap_items;
-    training_option_t opt;
-
-    /* Obtain parameter values. */
-    exchange_options(params, &opt, -1);
-
-    /* Allocate arrays. */
-    w = (floatval_t *)calloc(sizeof(floatval_t), K);
-    if (w == NULL)
-    {
-        ret = CRFSUITEERR_OUTOFMEMORY;
-        goto error_exit;
-    }
-
-    opt.lambda = 2. * opt.c2 / N;
-
-    logging(lg, "Start training with SGD");
-    clk_begin = clock();
-
-    /* Calibrate the training rate (eta). */
-    opt.t0 = l2sgd_calibration(gm, trainset, w, lg, &opt);
-
-    /* Perform stochastic gradient descent. */
-    ret = l2sgd(
-        gm,
-        trainset,
-        testset,
-        w,
-        lg,
-        N,
-        opt.t0,
-        opt.lambda,
-        opt.max_iterations,
-        0,
-        opt.period,
-        opt.delta,
-        &loss);
-
-    *ptr_w = w;
-    return ret;
-
-error_exit:
-    free(w);
-    return ret;
-}
+/*
+ *      Online training with L2-regularized Stochastic Gradient Descent (SGD).
+ *
+ * Copyright (c) 2007-2010, Naoaki Okazaki
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the names of the authors nor the names of its contributors
+ *       may be used to endorse or promote products derived from this
+ *       software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+ * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/* $Id$ */
+
+/*
+    SGD for L2-regularized MAP estimation.
+
+    The iterative algorithm is inspired by Pegasos:
+
+    Shai Shalev-Shwartz, Yoram Singer, and Nathan Srebro.
+    Pegasos: Primal Estimated sub-GrAdient SOlver for SVM.
+    In Proc. of ICML 2007, pp 807-814, 2007.
+
+    The calibration strategy is inspired by the implementation of sgd:
+    http://leon.bottou.org/projects/sgd
+    written by Lon Bottou.
+
+    The objective function to minimize is:
+
+        f(w) = (lambda/2) * ||w||^2 + (1/N) * \sum_i^N log P^i(y|x)
+        lambda = 2 * C / N
+
+    The original version of the Pegasos algorithm.
+
+    0) Initialization
+        t = t0
+        k = [the batch size]
+    1) Computing the learning rate (eta).
+        eta = 1 / (lambda * t)
+    2) Updating feature weights.
+        w = (1 - eta * lambda) w - (eta / k) \sum_i (oexp - mexp)
+    3) Projecting feature weights within an L2-ball.
+        w = min{1, (1/sqrt(lambda))/||w||} * w
+    4) Goto 1 until convergence.
+
+    This implementation omit the step 3) because it makes the source code
+    tricky (in order to maintain L2-norm of feature weights at any time) and
+    because the project step does not have a strong impact to the quality of
+    solution.
+
+    A naive implementation requires O(K) computations for steps 2,
+    where K is the total number of features. This code implements the procedure
+    in an efficient way:
+
+    0) Initialization
+        decay = 1
+    1) Computing various factors
+        eta = 1 / (lambda * t)
+        decay *= (1 - eta * lambda)
+        gain = (eta / k) / decay
+    2) Updating feature weights
+        Updating feature weights from observation expectation:
+            delta = gain * (1.0) * f(x,y)
+            w += delta
+        Updating feature weights from model expectation:
+            delta = gain * (-P(y|x)) * f(x,y)
+            w += delta
+    4) Goto 1 until convergence.
+*/
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif /*HAVE_CONFIG_H*/
+
+#include <os.h>
+
+#include <float.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <time.h>
+#include <math.h>
+
+#include <crfsuite.h>
+#include "crfsuite_internal.h"
+
+#include "logging.h"
+#include "params.h"
+#include "crf1d.h"
+#include "vecmath.h"
+
+#define MIN(a, b) ((a) < (b) ? (a) : (b))
+
+typedef struct
+{
+    floatval_t c2;
+    floatval_t lambda;
+    floatval_t t0;
+    int max_iterations;
+    int period;
+    floatval_t delta;
+    floatval_t calibration_eta;
+    floatval_t calibration_rate;
+    int calibration_samples;
+    int calibration_candidates;
+    int calibration_max_trials;
+} training_option_t;
+
+static int l2sgd(
+    encoder_t *gm,
+    dataset_t *trainset,
+    dataset_t *testset,
+    floatval_t *w,
+    logging_t *lg,
+    const int N,
+    const floatval_t t0,
+    const floatval_t lambda,
+    const int num_epochs,
+    int calibration,
+    int period,
+    const floatval_t epsilon,
+    floatval_t *ptr_loss)
+{
+    int i, epoch, ret = 0;
+    floatval_t t = 0;
+    floatval_t loss = 0, sum_loss = 0;
+    floatval_t best_sum_loss = DBL_MAX;
+    floatval_t eta, gain, decay = 1.;
+    floatval_t improvement = 0.;
+    floatval_t norm2 = 0.;
+    floatval_t *pf = NULL;
+    floatval_t *best_w = NULL;
+    clock_t clk_prev, clk_begin = clock();
+    const int K = gm->num_features;
+
+    if (!calibration)
+    {
+        pf = (floatval_t *)malloc(sizeof(floatval_t) * period);
+        best_w = (floatval_t *)calloc(K, sizeof(floatval_t));
+        if (pf == NULL || best_w == NULL)
+        {
+            ret = CRFSUITEERR_OUTOFMEMORY;
+            goto error_exit;
+        }
+    }
+
+    /* Initialize the feature weights. */
+    vecset(w, 0, K);
+
+    /* Loop for epochs. */
+    for (epoch = 1; epoch <= num_epochs; ++epoch)
+    {
+        clk_prev = clock();
+
+        if (!calibration)
+        {
+            /* Shuffle the training instances. */
+            dataset_shuffle(trainset);
+        }
+
+        /* Loop for instances. */
+        sum_loss = 0.;
+        for (i = 0; i < N; ++i)
+        {
+            const crfsuite_instance_t *inst = dataset_get(trainset, i);
+
+            /* Update various factors. */
+            eta = 1 / (lambda * (t0 + t));
+            decay *= (1.0 - eta * lambda);
+            gain = eta / decay;
+
+            /* Compute the loss and gradients for the instance. */
+            gm->set_weights(gm, w, decay);
+            gm->set_instance(gm, inst);
+            gm->objective_and_gradients(gm, &loss, w, gain, inst->weight);
+
+            sum_loss += loss;
+            ++t;
+        }
+
+        /* Terminate when the loss is abnormal (NaN, -Inf, +Inf). */
+        if (!isfinite(loss))
+        {
+            logging(lg, "Loss is abnormal");
+            ret = CRFSUITEERR_OVERFLOW;
+            sum_loss = loss;
+            goto error_exit;
+        }
+
+        /* Scale the feature weights. */
+        vecscale(w, decay, K);
+        decay = 1.;
+
+        /* Include the L2 norm of feature weights to the objective. */
+        /* The factor N is necessary because lambda = 2 * C / N. */
+        norm2 = vecdot(w, w, K);
+        sum_loss += 0.5 * lambda * norm2 * N;
+
+        /* One epoch finished. */
+        if (!calibration)
+        {
+            /* Check if the current epoch is the best. */
+            if (sum_loss < best_sum_loss)
+            {
+                /* Store the feature weights to best_w. */
+                best_sum_loss = sum_loss;
+                veccopy(best_w, w, K);
+            }
+
+            /* We don't test the stopping criterion while period < epoch. */
+            if (period < epoch)
+            {
+                improvement = (pf[(epoch - 1) % period] - sum_loss) / sum_loss;
+            }
+            else
+            {
+                improvement = epsilon;
+            }
+
+            /* Store the current value of the objective function. */
+            pf[(epoch - 1) % period] = sum_loss;
+
+            logging(lg, "Epoch %d, learning rate: %f, training loss: %f", epoch, eta, sum_loss);
+
+            /* Check for the stopping criterion. */
+            if (improvement < epsilon)
+            {
+                ret = 0;
+                break;
+            }
+        }
+    }
+
+    /* Output the optimization result. */
+    if (!calibration)
+    {
+        if (ret == 0)
+        {
+            if (epoch < num_epochs)
+            {
+                logging(lg, "Loss has converged, terminating training");
+            }
+            else
+            {
+                logging(lg, "Reached maximum number of iterations, terminating training");
+            }
+        }
+    }
+
+    /* Restore the best weights. */
+    if (best_w != NULL)
+    {
+        sum_loss = best_sum_loss;
+        veccopy(w, best_w, K);
+    }
+
+error_exit:
+    free(best_w);
+    free(pf);
+    if (ptr_loss != NULL)
+    {
+        *ptr_loss = sum_loss;
+    }
+    return ret;
+}
+
+static floatval_t
+l2sgd_calibration(
+    encoder_t *gm,
+    dataset_t *ds,
+    floatval_t *w,
+    logging_t *lg,
+    const training_option_t *opt)
+{
+    int i;
+    int dec = 0, ok, trials = 1;
+    int num = opt->calibration_candidates;
+    clock_t clk_begin = clock();
+    floatval_t loss = 0.;
+    floatval_t init_loss = 0.;
+    floatval_t best_loss = DBL_MAX;
+    floatval_t eta = opt->calibration_eta;
+    floatval_t best_eta = opt->calibration_eta;
+    const int N = ds->num_instances;
+    const int S = MIN(N, opt->calibration_samples);
+    const int K = gm->num_features;
+    const floatval_t init_eta = opt->calibration_eta;
+    const floatval_t rate = opt->calibration_rate;
+    const floatval_t lambda = opt->lambda;
+
+    logging(lg, "Calibrating learning rate");
+
+    /* Initialize a permutation that shuffles the instances. */
+    dataset_shuffle(ds);
+
+    /* Initialize feature weights as zero. */
+    vecset(w, 0, K);
+
+    /* Compute the initial loss. */
+    gm->set_weights(gm, w, 1.);
+    init_loss = 0;
+    for (i = 0; i < S; ++i)
+    {
+        floatval_t score;
+        const crfsuite_instance_t *inst = dataset_get(ds, i);
+        gm->set_instance(gm, inst);
+        gm->score(gm, inst->labels, &score);
+        init_loss -= score;
+        gm->partition_factor(gm, &score);
+        init_loss += score;
+    }
+    init_loss += 0.5 * lambda * vecdot(w, w, K) * N;
+    logging(lg, "Initial training loss: %f", init_loss);
+
+    while (num > 0 || !dec)
+    {
+        /* Perform SGD for one epoch. */
+        l2sgd(
+            gm,
+            ds,
+            NULL,
+            w,
+            lg,
+            S, 1.0 / (lambda * eta), lambda, 1, 1, 1, 0., &loss);
+
+        /* Make sure that the learning rate decreases the log-likelihood. */
+        ok = isfinite(loss) && (loss < init_loss);
+
+        logging(lg, "Trial %d, learning rate %f, training loss: %f", trials, eta, loss);
+
+        if (ok)
+        {
+            --num;
+        }
+
+        if (isfinite(loss) && loss < best_loss)
+        {
+            best_loss = loss;
+            best_eta = eta;
+        }
+
+        if (!dec)
+        {
+            if (ok && 0 < num)
+            {
+                eta *= rate;
+            }
+            else
+            {
+                dec = 1;
+                num = opt->calibration_candidates;
+                eta = init_eta / rate;
+            }
+        }
+        else
+        {
+            eta /= rate;
+        }
+
+        ++trials;
+        if (opt->calibration_max_trials <= trials)
+        {
+            break;
+        }
+    }
+
+    eta = best_eta;
+    logging(lg, "Best learning rate: %f", eta);
+
+    return 1.0 / (lambda * eta);
+}
+
+int exchange_options(crfsuite_params_t *params, training_option_t *opt, int mode)
+{
+    BEGIN_PARAM_MAP(params, mode)
+    DDX_PARAM_FLOAT(
+        "c2", opt->c2, 1.,
+        "Coefficient for L2 regularization.")
+    DDX_PARAM_INT(
+        "max_iterations", opt->max_iterations, 1000,
+        "The maximum number of iterations (epochs) for SGD optimization.")
+    DDX_PARAM_INT(
+        "period", opt->period, 10,
+        "The duration of iterations to test the stopping criterion.")
+    DDX_PARAM_FLOAT(
+        "delta", opt->delta, 1e-6,
+        "The threshold for the stopping criterion; an optimization process stops when\n"
+        "the improvement of the log likelihood over the last ${period} iterations is no\n"
+        "greater than this threshold.")
+    DDX_PARAM_FLOAT(
+        "calibration.eta", opt->calibration_eta, 0.1,
+        "The initial value of learning rate (eta) used for calibration.")
+    DDX_PARAM_FLOAT(
+        "calibration.rate", opt->calibration_rate, 2.,
+        "The rate of increase/decrease of learning rate for calibration.")
+    DDX_PARAM_INT(
+        "calibration.samples", opt->calibration_samples, 1000,
+        "The number of instances used for calibration.")
+    DDX_PARAM_INT(
+        "calibration.candidates", opt->calibration_candidates, 10,
+        "The number of candidates of learning rate.")
+    DDX_PARAM_INT(
+        "calibration.max_trials", opt->calibration_max_trials, 20,
+        "The maximum number of trials of learning rates for calibration.")
+    END_PARAM_MAP()
+
+    return 0;
+}
+
+void crfsuite_train_l2sgd_init(crfsuite_params_t *params)
+{
+    exchange_options(params, NULL, 0);
+}
+
+int crfsuite_train_l2sgd(
+    encoder_t *gm,
+    dataset_t *trainset,
+    dataset_t *testset,
+    crfsuite_params_t *params,
+    logging_t *lg,
+    floatval_t **ptr_w)
+{
+    int ret = 0;
+    floatval_t *w = NULL;
+    clock_t clk_begin;
+    floatval_t loss = 0;
+    const int N = trainset->num_instances;
+    const int K = gm->num_features;
+    const int T = gm->cap_items;
+    training_option_t opt;
+
+    /* Obtain parameter values. */
+    exchange_options(params, &opt, -1);
+
+    /* Allocate arrays. */
+    w = (floatval_t *)calloc(sizeof(floatval_t), K);
+    if (w == NULL)
+    {
+        ret = CRFSUITEERR_OUTOFMEMORY;
+        goto error_exit;
+    }
+
+    opt.lambda = 2. * opt.c2 / N;
+
+    logging(lg, "Start training with SGD");
+    clk_begin = clock();
+
+    /* Calibrate the training rate (eta). */
+    opt.t0 = l2sgd_calibration(gm, trainset, w, lg, &opt);
+
+    /* Perform stochastic gradient descent. */
+    ret = l2sgd(
+        gm,
+        trainset,
+        testset,
+        w,
+        lg,
+        N,
+        opt.t0,
+        opt.lambda,
+        opt.max_iterations,
+        0,
+        opt.period,
+        opt.delta,
+        &loss);
+
+    *ptr_w = w;
+    return ret;
+
+error_exit:
+    free(w);
+    return ret;
+}
```

## chaine/_core/crfsuite/lib/crf/src/train_lbfgs.c

 * *Ordering differences only*

```diff
@@ -1,323 +1,323 @@
-/*
- *      Batch training with L-BFGS.
- *
- * Copyright (c) 2007-2010, Naoaki Okazaki
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the names of the authors nor the names of its contributors
- *       may be used to endorse or promote products derived from this
- *       software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
- * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-/* $Id$ */
-
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif /*HAVE_CONFIG_H*/
-
-#include <os.h>
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <limits.h>
-#include <time.h>
-
-#include <crfsuite.h>
-#include "crfsuite_internal.h"
-
-#include "logging.h"
-#include "params.h"
-#include "vecmath.h"
-#include <lbfgs.h>
-
-/**
- * Training parameters (configurable with crfsuite_params_t interface).
- */
-typedef struct
-{
-    floatval_t c1;
-    floatval_t c2;
-    int memory;
-    floatval_t epsilon;
-    int stop;
-    floatval_t delta;
-    int max_iterations;
-    char *linesearch;
-    int linesearch_max_iterations;
-} training_option_t;
-
-/**
- * Internal data structure for the callback function of lbfgs().
- */
-typedef struct
-{
-    encoder_t *gm;
-    dataset_t *trainset;
-    dataset_t *testset;
-    logging_t *lg;
-    floatval_t c2;
-    floatval_t *best_w;
-    clock_t begin;
-} lbfgs_internal_t;
-
-static lbfgsfloatval_t lbfgs_evaluate(
-    void *instance,
-    const lbfgsfloatval_t *x,
-    lbfgsfloatval_t *g,
-    const int n,
-    const lbfgsfloatval_t step)
-{
-    int i;
-    floatval_t f, norm = 0.;
-    lbfgs_internal_t *lbfgsi = (lbfgs_internal_t *)instance;
-    encoder_t *gm = lbfgsi->gm;
-    dataset_t *trainset = lbfgsi->trainset;
-
-    /* Compute the objective value and gradients. */
-    gm->objective_and_gradients_batch(gm, trainset, x, &f, g);
-
-    /* L2 regularization. */
-    if (0 < lbfgsi->c2)
-    {
-        const floatval_t c22 = lbfgsi->c2 * 2.;
-        for (i = 0; i < n; ++i)
-        {
-            g[i] += (c22 * x[i]);
-            norm += x[i] * x[i];
-        }
-        f += (lbfgsi->c2 * norm);
-    }
-
-    return f;
-}
-
-static int lbfgs_progress(
-    void *instance,
-    const lbfgsfloatval_t *x,
-    const lbfgsfloatval_t *g,
-    const lbfgsfloatval_t fx,
-    const lbfgsfloatval_t xnorm,
-    const lbfgsfloatval_t gnorm,
-    const lbfgsfloatval_t step,
-    int n,
-    int k,
-    int ls)
-{
-    int i, num_active_features = 0;
-    clock_t duration, clk = clock();
-    lbfgs_internal_t *lbfgsi = (lbfgs_internal_t *)instance;
-    dataset_t *testset = lbfgsi->testset;
-    encoder_t *gm = lbfgsi->gm;
-    logging_t *lg = lbfgsi->lg;
-
-    /* Compute the duration required for this iteration. */
-    duration = clk - lbfgsi->begin;
-    lbfgsi->begin = clk;
-
-    /* Store the feature weight in case L-BFGS terminates with an error. */
-    for (i = 0; i < n; ++i)
-    {
-        lbfgsi->best_w[i] = x[i];
-        if (x[i] != 0.)
-            ++num_active_features;
-    }
-
-    /* Report the progress. */
-    logging(lg, "Iteration %d, training loss: %f", k, fx);
-
-    /* Send the tagger with the current parameters. */
-    if (testset != NULL)
-    {
-        holdout_evaluation(gm, testset, x, lg);
-    }
-
-    /* Continue. */
-    return 0;
-}
-
-static int exchange_options(crfsuite_params_t *params, training_option_t *opt, int mode)
-{
-    BEGIN_PARAM_MAP(params, mode)
-    DDX_PARAM_FLOAT(
-        "c1", opt->c1, 0,
-        "Coefficient for L1 regularization.")
-    DDX_PARAM_FLOAT(
-        "c2", opt->c2, 1.0,
-        "Coefficient for L2 regularization.")
-    DDX_PARAM_INT(
-        "max_iterations", opt->max_iterations, INT_MAX,
-        "The maximum number of iterations for L-BFGS optimization.")
-    DDX_PARAM_INT(
-        "num_memories", opt->memory, 6,
-        "The number of limited memories for approximating the inverse hessian matrix.")
-    DDX_PARAM_FLOAT(
-        "epsilon", opt->epsilon, 1e-5,
-        "Epsilon for testing the convergence of the objective.")
-    DDX_PARAM_INT(
-        "period", opt->stop, 10,
-        "The duration of iterations to test the stopping criterion.")
-    DDX_PARAM_FLOAT(
-        "delta", opt->delta, 1e-5,
-        "The threshold for the stopping criterion; an L-BFGS iteration stops when the\n"
-        "improvement of the log likelihood over the last ${period} iterations is no\n"
-        "greater than this threshold.")
-    DDX_PARAM_STRING(
-        "linesearch", opt->linesearch, "MoreThuente",
-        "The line search algorithm used in L-BFGS updates:\n"
-        "{   'MoreThuente': More and Thuente's method,\n"
-        "    'Backtracking': Backtracking method with regular Wolfe condition,\n"
-        "    'StrongBacktracking': Backtracking method with strong Wolfe condition\n"
-        "}\n")
-    DDX_PARAM_INT(
-        "max_linesearch", opt->linesearch_max_iterations, 20,
-        "The maximum number of trials for the line search algorithm.")
-    END_PARAM_MAP()
-
-    return 0;
-}
-
-void crfsuite_train_lbfgs_init(crfsuite_params_t *params)
-{
-    exchange_options(params, NULL, 0);
-}
-
-int crfsuite_train_lbfgs(
-    encoder_t *gm,
-    dataset_t *trainset,
-    dataset_t *testset,
-    crfsuite_params_t *params,
-    logging_t *lg,
-    floatval_t **ptr_w)
-{
-    int ret = 0, lbret;
-    floatval_t *w = NULL;
-    clock_t begin = clock();
-    const int N = trainset->num_instances;
-    const int L = trainset->data->labels->num(trainset->data->labels);
-    const int A = trainset->data->attrs->num(trainset->data->attrs);
-    const int K = gm->num_features;
-    lbfgs_internal_t lbfgsi;
-    lbfgs_parameter_t lbfgsparam;
-    training_option_t opt;
-
-    /* Initialize the variables. */
-    memset(&lbfgsi, 0, sizeof(lbfgsi));
-    memset(&opt, 0, sizeof(opt));
-    lbfgs_parameter_init(&lbfgsparam);
-
-    /* Allocate an array that stores the current weights. As per the liblbfgs
-     * documentation, this needs to be allocated with lbfgs_malloc. */
-    w = lbfgs_malloc(K);
-    if (w == NULL)
-    {
-        ret = CRFSUITEERR_OUTOFMEMORY;
-        goto error_exit;
-    }
-
-    /* Allocate an array that stores the best weights. */
-    lbfgsi.best_w = (floatval_t *)calloc(sizeof(floatval_t), K);
-    if (lbfgsi.best_w == NULL)
-    {
-        ret = CRFSUITEERR_OUTOFMEMORY;
-        goto error_exit;
-    }
-
-    /* Read the L-BFGS parameters. */
-    exchange_options(params, &opt, -1);
-    logging(lg, "Start training with L-BFGS");
-
-    /* Set parameters for L-BFGS. */
-    lbfgsparam.m = opt.memory;
-    lbfgsparam.epsilon = opt.epsilon;
-    lbfgsparam.past = opt.stop;
-    lbfgsparam.delta = opt.delta;
-    lbfgsparam.max_iterations = opt.max_iterations;
-    if (strcmp(opt.linesearch, "Backtracking") == 0)
-    {
-        lbfgsparam.linesearch = LBFGS_LINESEARCH_BACKTRACKING;
-    }
-    else if (strcmp(opt.linesearch, "StrongBacktracking") == 0)
-    {
-        lbfgsparam.linesearch = LBFGS_LINESEARCH_BACKTRACKING_STRONG_WOLFE;
-    }
-    else
-    {
-        lbfgsparam.linesearch = LBFGS_LINESEARCH_MORETHUENTE;
-    }
-    lbfgsparam.max_linesearch = opt.linesearch_max_iterations;
-
-    /* Set regularization parameters. */
-    if (0 < opt.c1)
-    {
-        lbfgsparam.orthantwise_c = opt.c1;
-        lbfgsparam.linesearch = LBFGS_LINESEARCH_BACKTRACKING;
-    }
-    else
-    {
-        lbfgsparam.orthantwise_c = 0;
-    }
-
-    /* Set other callback data. */
-    lbfgsi.gm = gm;
-    lbfgsi.trainset = trainset;
-    lbfgsi.testset = testset;
-    lbfgsi.c2 = opt.c2;
-    lbfgsi.lg = lg;
-
-    /* Call the L-BFGS solver. */
-    lbfgsi.begin = clock();
-    lbret = lbfgs(
-        K,
-        w,
-        NULL,
-        lbfgs_evaluate,
-        lbfgs_progress,
-        &lbfgsi,
-        &lbfgsparam);
-    if (lbret == LBFGS_CONVERGENCE)
-    {
-        logging(lg, "Loss has converged, terminating training");
-    }
-    else if (lbret == LBFGS_STOP)
-    {
-        logging(lg, "Terminated with the stopping criteria");
-    }
-    else if (lbret == LBFGSERR_MAXIMUMITERATION)
-    {
-        logging(lg, "Reached maximum number of iterations. terminating training");
-    }
-
-    /* Set the best_w array (allocated by us) as the result array, which the
-     * callee can safely `free`. */
-    *ptr_w = lbfgsi.best_w;
-
-    /* Exit with success. */
-    lbfgs_free(w);
-    return 0;
-
-error_exit:
-    free(lbfgsi.best_w);
-    lbfgs_free(w);
-    *ptr_w = NULL;
-    return ret;
-}
+/*
+ *      Batch training with L-BFGS.
+ *
+ * Copyright (c) 2007-2010, Naoaki Okazaki
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the names of the authors nor the names of its contributors
+ *       may be used to endorse or promote products derived from this
+ *       software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+ * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/* $Id$ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif /*HAVE_CONFIG_H*/
+
+#include <os.h>
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <limits.h>
+#include <time.h>
+
+#include <crfsuite.h>
+#include "crfsuite_internal.h"
+
+#include "logging.h"
+#include "params.h"
+#include "vecmath.h"
+#include <lbfgs.h>
+
+/**
+ * Training parameters (configurable with crfsuite_params_t interface).
+ */
+typedef struct
+{
+    floatval_t c1;
+    floatval_t c2;
+    int memory;
+    floatval_t epsilon;
+    int stop;
+    floatval_t delta;
+    int max_iterations;
+    char *linesearch;
+    int linesearch_max_iterations;
+} training_option_t;
+
+/**
+ * Internal data structure for the callback function of lbfgs().
+ */
+typedef struct
+{
+    encoder_t *gm;
+    dataset_t *trainset;
+    dataset_t *testset;
+    logging_t *lg;
+    floatval_t c2;
+    floatval_t *best_w;
+    clock_t begin;
+} lbfgs_internal_t;
+
+static lbfgsfloatval_t lbfgs_evaluate(
+    void *instance,
+    const lbfgsfloatval_t *x,
+    lbfgsfloatval_t *g,
+    const int n,
+    const lbfgsfloatval_t step)
+{
+    int i;
+    floatval_t f, norm = 0.;
+    lbfgs_internal_t *lbfgsi = (lbfgs_internal_t *)instance;
+    encoder_t *gm = lbfgsi->gm;
+    dataset_t *trainset = lbfgsi->trainset;
+
+    /* Compute the objective value and gradients. */
+    gm->objective_and_gradients_batch(gm, trainset, x, &f, g);
+
+    /* L2 regularization. */
+    if (0 < lbfgsi->c2)
+    {
+        const floatval_t c22 = lbfgsi->c2 * 2.;
+        for (i = 0; i < n; ++i)
+        {
+            g[i] += (c22 * x[i]);
+            norm += x[i] * x[i];
+        }
+        f += (lbfgsi->c2 * norm);
+    }
+
+    return f;
+}
+
+static int lbfgs_progress(
+    void *instance,
+    const lbfgsfloatval_t *x,
+    const lbfgsfloatval_t *g,
+    const lbfgsfloatval_t fx,
+    const lbfgsfloatval_t xnorm,
+    const lbfgsfloatval_t gnorm,
+    const lbfgsfloatval_t step,
+    int n,
+    int k,
+    int ls)
+{
+    int i, num_active_features = 0;
+    clock_t duration, clk = clock();
+    lbfgs_internal_t *lbfgsi = (lbfgs_internal_t *)instance;
+    dataset_t *testset = lbfgsi->testset;
+    encoder_t *gm = lbfgsi->gm;
+    logging_t *lg = lbfgsi->lg;
+
+    /* Compute the duration required for this iteration. */
+    duration = clk - lbfgsi->begin;
+    lbfgsi->begin = clk;
+
+    /* Store the feature weight in case L-BFGS terminates with an error. */
+    for (i = 0; i < n; ++i)
+    {
+        lbfgsi->best_w[i] = x[i];
+        if (x[i] != 0.)
+            ++num_active_features;
+    }
+
+    /* Report the progress. */
+    logging(lg, "Iteration %d, training loss: %f", k, fx);
+
+    /* Send the tagger with the current parameters. */
+    if (testset != NULL)
+    {
+        holdout_evaluation(gm, testset, x, lg);
+    }
+
+    /* Continue. */
+    return 0;
+}
+
+static int exchange_options(crfsuite_params_t *params, training_option_t *opt, int mode)
+{
+    BEGIN_PARAM_MAP(params, mode)
+    DDX_PARAM_FLOAT(
+        "c1", opt->c1, 0,
+        "Coefficient for L1 regularization.")
+    DDX_PARAM_FLOAT(
+        "c2", opt->c2, 1.0,
+        "Coefficient for L2 regularization.")
+    DDX_PARAM_INT(
+        "max_iterations", opt->max_iterations, INT_MAX,
+        "The maximum number of iterations for L-BFGS optimization.")
+    DDX_PARAM_INT(
+        "num_memories", opt->memory, 6,
+        "The number of limited memories for approximating the inverse hessian matrix.")
+    DDX_PARAM_FLOAT(
+        "epsilon", opt->epsilon, 1e-5,
+        "Epsilon for testing the convergence of the objective.")
+    DDX_PARAM_INT(
+        "period", opt->stop, 10,
+        "The duration of iterations to test the stopping criterion.")
+    DDX_PARAM_FLOAT(
+        "delta", opt->delta, 1e-5,
+        "The threshold for the stopping criterion; an L-BFGS iteration stops when the\n"
+        "improvement of the log likelihood over the last ${period} iterations is no\n"
+        "greater than this threshold.")
+    DDX_PARAM_STRING(
+        "linesearch", opt->linesearch, "MoreThuente",
+        "The line search algorithm used in L-BFGS updates:\n"
+        "{   'MoreThuente': More and Thuente's method,\n"
+        "    'Backtracking': Backtracking method with regular Wolfe condition,\n"
+        "    'StrongBacktracking': Backtracking method with strong Wolfe condition\n"
+        "}\n")
+    DDX_PARAM_INT(
+        "max_linesearch", opt->linesearch_max_iterations, 20,
+        "The maximum number of trials for the line search algorithm.")
+    END_PARAM_MAP()
+
+    return 0;
+}
+
+void crfsuite_train_lbfgs_init(crfsuite_params_t *params)
+{
+    exchange_options(params, NULL, 0);
+}
+
+int crfsuite_train_lbfgs(
+    encoder_t *gm,
+    dataset_t *trainset,
+    dataset_t *testset,
+    crfsuite_params_t *params,
+    logging_t *lg,
+    floatval_t **ptr_w)
+{
+    int ret = 0, lbret;
+    floatval_t *w = NULL;
+    clock_t begin = clock();
+    const int N = trainset->num_instances;
+    const int L = trainset->data->labels->num(trainset->data->labels);
+    const int A = trainset->data->attrs->num(trainset->data->attrs);
+    const int K = gm->num_features;
+    lbfgs_internal_t lbfgsi;
+    lbfgs_parameter_t lbfgsparam;
+    training_option_t opt;
+
+    /* Initialize the variables. */
+    memset(&lbfgsi, 0, sizeof(lbfgsi));
+    memset(&opt, 0, sizeof(opt));
+    lbfgs_parameter_init(&lbfgsparam);
+
+    /* Allocate an array that stores the current weights. As per the liblbfgs
+     * documentation, this needs to be allocated with lbfgs_malloc. */
+    w = lbfgs_malloc(K);
+    if (w == NULL)
+    {
+        ret = CRFSUITEERR_OUTOFMEMORY;
+        goto error_exit;
+    }
+
+    /* Allocate an array that stores the best weights. */
+    lbfgsi.best_w = (floatval_t *)calloc(sizeof(floatval_t), K);
+    if (lbfgsi.best_w == NULL)
+    {
+        ret = CRFSUITEERR_OUTOFMEMORY;
+        goto error_exit;
+    }
+
+    /* Read the L-BFGS parameters. */
+    exchange_options(params, &opt, -1);
+    logging(lg, "Start training with L-BFGS");
+
+    /* Set parameters for L-BFGS. */
+    lbfgsparam.m = opt.memory;
+    lbfgsparam.epsilon = opt.epsilon;
+    lbfgsparam.past = opt.stop;
+    lbfgsparam.delta = opt.delta;
+    lbfgsparam.max_iterations = opt.max_iterations;
+    if (strcmp(opt.linesearch, "Backtracking") == 0)
+    {
+        lbfgsparam.linesearch = LBFGS_LINESEARCH_BACKTRACKING;
+    }
+    else if (strcmp(opt.linesearch, "StrongBacktracking") == 0)
+    {
+        lbfgsparam.linesearch = LBFGS_LINESEARCH_BACKTRACKING_STRONG_WOLFE;
+    }
+    else
+    {
+        lbfgsparam.linesearch = LBFGS_LINESEARCH_MORETHUENTE;
+    }
+    lbfgsparam.max_linesearch = opt.linesearch_max_iterations;
+
+    /* Set regularization parameters. */
+    if (0 < opt.c1)
+    {
+        lbfgsparam.orthantwise_c = opt.c1;
+        lbfgsparam.linesearch = LBFGS_LINESEARCH_BACKTRACKING;
+    }
+    else
+    {
+        lbfgsparam.orthantwise_c = 0;
+    }
+
+    /* Set other callback data. */
+    lbfgsi.gm = gm;
+    lbfgsi.trainset = trainset;
+    lbfgsi.testset = testset;
+    lbfgsi.c2 = opt.c2;
+    lbfgsi.lg = lg;
+
+    /* Call the L-BFGS solver. */
+    lbfgsi.begin = clock();
+    lbret = lbfgs(
+        K,
+        w,
+        NULL,
+        lbfgs_evaluate,
+        lbfgs_progress,
+        &lbfgsi,
+        &lbfgsparam);
+    if (lbret == LBFGS_CONVERGENCE)
+    {
+        logging(lg, "Loss has converged, terminating training");
+    }
+    else if (lbret == LBFGS_STOP)
+    {
+        logging(lg, "Terminated with the stopping criteria");
+    }
+    else if (lbret == LBFGSERR_MAXIMUMITERATION)
+    {
+        logging(lg, "Reached maximum number of iterations. terminating training");
+    }
+
+    /* Set the best_w array (allocated by us) as the result array, which the
+     * callee can safely `free`. */
+    *ptr_w = lbfgsi.best_w;
+
+    /* Exit with success. */
+    lbfgs_free(w);
+    return 0;
+
+error_exit:
+    free(lbfgsi.best_w);
+    lbfgs_free(w);
+    *ptr_w = NULL;
+    return ret;
+}
```

## chaine/_core/crfsuite/lib/crf/src/train_passive_aggressive.c

 * *Ordering differences only*

```diff
@@ -1,442 +1,442 @@
-/*
- *      Online training with Passive Aggressive.
- *
- * Copyright (c) 2007-2010, Naoaki Okazaki
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the names of the authors nor the names of its contributors
- *       may be used to endorse or promote products derived from this
- *       software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
- * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-/* $Id$ */
-
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif /*HAVE_CONFIG_H*/
-
-#include <os.h>
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <time.h>
-
-#include <crfsuite.h>
-#include "crfsuite_internal.h"
-#include "logging.h"
-#include "params.h"
-#include "vecmath.h"
-
-#define MIN(a, b) ((a) < (b) ? (a) : (b))
-
-/**
- * Training parameters (configurable with crfsuite_params_t interface).
- */
-typedef struct
-{
-    int type;
-    floatval_t c;
-    int error_sensitive;
-    int averaging;
-    int max_iterations;
-    floatval_t epsilon;
-} training_option_t;
-
-/**
- * Internal data structure for computing the sparse vector F(x, y) - F(x, y').
- */
-typedef struct
-{
-    /* An array of feature indices relevant to the instance. */
-    int *actives;
-    int num_actives;
-    int cap_actives;
-    char *used;
-
-    /* Coefficient for collecting feature weights. */
-    floatval_t c;
-    /* The difference vector [K]. */
-    floatval_t *delta;
-    /* The number of features. */
-    int K;
-} delta_t;
-
-static int delta_init(delta_t *dc, const int K)
-{
-    memset(dc, 0, sizeof(*dc));
-    dc->used = (char *)calloc(K, sizeof(char));
-    dc->delta = (floatval_t *)calloc(K, sizeof(floatval_t));
-    dc->K = K;
-    if (dc->delta == NULL || dc->used == NULL)
-    {
-        return 1;
-    }
-    return 0;
-}
-
-static void delta_finish(delta_t *dc)
-{
-    free(dc->actives);
-    free(dc->used);
-    free(dc->delta);
-    memset(dc, 0, sizeof(*dc));
-}
-
-static void delta_reset(delta_t *dc)
-{
-    int i;
-    for (i = 0; i < dc->num_actives; ++i)
-    {
-        int k = dc->actives[i];
-        dc->delta[k] = 0;
-    }
-    dc->num_actives = 0;
-}
-
-static void delta_collect(void *instance, int fid, floatval_t value)
-{
-    delta_t *dc = (delta_t *)instance;
-
-    /* Expand the active feature list if necessary. */
-    if (dc->cap_actives <= dc->num_actives)
-    {
-        ++dc->cap_actives;
-        dc->cap_actives *= 2;
-        dc->actives = (int *)realloc(dc->actives, sizeof(int) * dc->cap_actives);
-    }
-
-    dc->actives[dc->num_actives++] = fid;
-    dc->delta[fid] += dc->c * value;
-}
-
-static void delta_finalize(delta_t *dc)
-{
-    int i, j = 0, k;
-
-    /* Collapse the duplicated indices. */
-    for (i = 0; i < dc->num_actives; ++i)
-    {
-        k = dc->actives[i];
-        if (!dc->used[k])
-        {
-            dc->actives[j++] = k;
-            dc->used[k] = 1;
-        }
-    }
-    dc->num_actives = j; /* This is the distinct number of indices. */
-
-    /* Reset the used flag. */
-    for (i = 0; i < dc->num_actives; ++i)
-    {
-        k = dc->actives[i];
-        dc->used[k] = 0;
-    }
-}
-
-static floatval_t delta_norm2(delta_t *dc)
-{
-    int i;
-    floatval_t norm2 = 0.;
-
-    for (i = 0; i < dc->num_actives; ++i)
-    {
-        int k = dc->actives[i];
-        norm2 += dc->delta[k] * dc->delta[k];
-    }
-    return norm2;
-}
-
-static void delta_add(delta_t *dc, floatval_t *w, floatval_t *ws, const floatval_t tau, const floatval_t u)
-{
-    int i;
-    const floatval_t tauu = tau * u;
-
-    for (i = 0; i < dc->num_actives; ++i)
-    {
-        int k = dc->actives[i];
-        w[k] += tau * dc->delta[k];
-        ws[k] += tauu * dc->delta[k];
-    }
-}
-
-static int diff(int *x, int *y, int n)
-{
-    int i, d = 0;
-    for (i = 0; i < n; ++i)
-    {
-        if (x[i] != y[i])
-        {
-            ++d;
-        }
-    }
-    return d;
-}
-
-static floatval_t cost_insensitive(floatval_t err, floatval_t d)
-{
-    return err + 1.;
-}
-
-static floatval_t cost_sensitive(floatval_t err, floatval_t d)
-{
-    return err + sqrt(d);
-}
-
-static floatval_t tau0(floatval_t cost, floatval_t norm, floatval_t c)
-{
-    return cost / norm;
-}
-
-static floatval_t tau1(floatval_t cost, floatval_t norm, floatval_t c)
-{
-    return MIN(c, cost / norm);
-}
-
-static floatval_t tau2(floatval_t cost, floatval_t norm, floatval_t c)
-{
-    return cost / (norm + 0.5 / c);
-}
-
-static int exchange_options(crfsuite_params_t *params, training_option_t *opt, int mode)
-{
-    BEGIN_PARAM_MAP(params, mode)
-    DDX_PARAM_INT(
-        "type", opt->type, 1,
-        "The strategy for updating feature weights: {\n"
-        "    0: PA without slack variables,\n"
-        "    1: PA type I,\n"
-        "    2: PA type II\n"
-        "}.\n")
-    DDX_PARAM_FLOAT(
-        "c", opt->c, 1.,
-        "The aggressiveness parameter.")
-    DDX_PARAM_INT(
-        "error_sensitive", opt->error_sensitive, 1,
-        "Consider the number of incorrect labels to the cost function.")
-    DDX_PARAM_INT(
-        "averaging", opt->averaging, 1,
-        "Compute the average of feature weights (similarly to Averaged Perceptron).")
-    DDX_PARAM_INT(
-        "max_iterations", opt->max_iterations, 100,
-        "The maximum number of iterations.")
-    DDX_PARAM_FLOAT(
-        "epsilon", opt->epsilon, 0.,
-        "The stopping criterion (the mean loss).")
-    END_PARAM_MAP()
-
-    return 0;
-}
-
-void crfsuite_train_passive_aggressive_init(crfsuite_params_t *params)
-{
-    exchange_options(params, NULL, 0);
-}
-
-int crfsuite_train_passive_aggressive(
-    encoder_t *gm,
-    dataset_t *trainset,
-    dataset_t *testset,
-    crfsuite_params_t *params,
-    logging_t *lg,
-    floatval_t **ptr_w)
-{
-    int n, i, u, ret = 0;
-    int *viterbi = NULL;
-    floatval_t *w = NULL, *ws = NULL, *wa = NULL;
-    const int N = trainset->num_instances;
-    const int K = gm->num_features;
-    const int T = gm->cap_items;
-    training_option_t opt;
-    delta_t dc;
-    clock_t begin = clock();
-    floatval_t (*cost_function)(floatval_t err, floatval_t d) = NULL;
-    floatval_t (*tau_function)(floatval_t cost, floatval_t norm, floatval_t c) = NULL;
-
-    /* Initialize the variable. */
-    if (delta_init(&dc, K) != 0)
-    {
-        ret = CRFSUITEERR_OUTOFMEMORY;
-        goto error_exit;
-    }
-
-    /* Obtain parameter values. */
-    exchange_options(params, &opt, -1);
-
-    /* Allocate arrays. */
-    w = (floatval_t *)calloc(sizeof(floatval_t), K);
-    ws = (floatval_t *)calloc(sizeof(floatval_t), K);
-    wa = (floatval_t *)calloc(sizeof(floatval_t), K);
-    viterbi = (int *)calloc(sizeof(int), T);
-    if (w == NULL || ws == NULL || wa == NULL || viterbi == NULL)
-    {
-        ret = CRFSUITEERR_OUTOFMEMORY;
-        goto error_exit;
-    }
-
-    /* Set the cost function for instances. */
-    if (opt.error_sensitive)
-    {
-        cost_function = cost_sensitive;
-    }
-    else
-    {
-        cost_function = cost_insensitive;
-    }
-
-    /* Set the routine for computing tau (i.e., PA, PA-I, PA-II). */
-    if (opt.type == 1)
-    {
-        tau_function = tau1;
-    }
-    else if (opt.type == 2)
-    {
-        tau_function = tau2;
-    }
-    else
-    {
-        tau_function = tau0;
-    }
-
-    /* Show the parameters. */
-    logging(lg, "Start training with PA");
-
-    u = 1;
-
-    /* Loop for epoch. */
-    for (i = 0; i < opt.max_iterations; ++i)
-    {
-        floatval_t norm = 0., sum_loss = 0.;
-        clock_t iteration_begin = clock();
-
-        /* Shuffle the instances. */
-        dataset_shuffle(trainset);
-
-        /* Loop for each instance. */
-        for (n = 0; n < N; ++n)
-        {
-            int d = 0;
-            floatval_t sv;
-            const crfsuite_instance_t *inst = dataset_get(trainset, n);
-
-            /* Set the feature weights to the encoder. */
-            gm->set_weights(gm, w, 1.);
-            gm->set_instance(gm, inst);
-
-            /* Tag the sequence with the current model. */
-            gm->viterbi(gm, viterbi, &sv);
-
-            /* Compute the number of different labels. */
-            d = diff(inst->labels, viterbi, inst->num_items);
-            if (0 < d)
-            {
-                floatval_t sc, norm2;
-                floatval_t tau, cost;
-
-                /*
-                    Compute the cost of this instance.
-                 */
-                gm->score(gm, inst->labels, &sc);
-                cost = cost_function(sv - sc, (double)d);
-
-                /* Initialize delta[k] = 0. */
-                delta_reset(&dc);
-
-                /*
-                    For every feature k on the correct path:
-                        delta[k] += 1;
-                 */
-                dc.c = 1;
-                gm->features_on_path(gm, inst, inst->labels, delta_collect, &dc);
-
-                /*
-                    For every feature k on the Viterbi path:
-                        delta[k] -= 1;
-                 */
-                dc.c = -1;
-                gm->features_on_path(gm, inst, viterbi, delta_collect, &dc);
-
-                delta_finalize(&dc);
-
-                /*
-                    Compute tau (dpending on PA, PA-I, and PA-II).
-                 */
-                norm2 = delta_norm2(&dc);
-                tau = tau_function(cost, norm2, opt.c);
-
-                /*
-                    Update the feature weights:
-                        w[k] += tau * delta[k]
-                        ws[k] += tau * u * delta[k]
-                 */
-                delta_add(&dc, w, ws, tau * inst->weight, u);
-
-                sum_loss += cost * inst->weight;
-            }
-            ++u;
-        }
-
-        if (opt.averaging)
-        {
-            /* Perform averaging to wa. */
-            veccopy(wa, w, K);
-            vecasub(wa, 1. / u, ws, K);
-        }
-        else
-        {
-            /* Simply copy the weights to wa. */
-            veccopy(wa, w, K);
-        }
-
-        /* Output the progress. */
-        logging(lg, "Iteration %d, training loss: %f", i + 1, sum_loss);
-
-        /* Holdout evaluation if necessary. */
-        if (testset != NULL)
-        {
-            holdout_evaluation(gm, testset, wa, lg);
-        }
-
-        /* Convergence test. */
-        if (sum_loss / N < opt.epsilon)
-        {
-            logging(lg, "Loss has converged, terminating training");
-            break;
-        }
-    }
-
-    free(viterbi);
-    free(ws);
-    free(w);
-    *ptr_w = wa;
-    delta_finish(&dc);
-    return ret;
-
-error_exit:
-    free(viterbi);
-    free(wa);
-    free(ws);
-    free(w);
-    *ptr_w = NULL;
-    delta_finish(&dc);
-
-    return ret;
-}
+/*
+ *      Online training with Passive Aggressive.
+ *
+ * Copyright (c) 2007-2010, Naoaki Okazaki
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the names of the authors nor the names of its contributors
+ *       may be used to endorse or promote products derived from this
+ *       software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+ * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/* $Id$ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif /*HAVE_CONFIG_H*/
+
+#include <os.h>
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <time.h>
+
+#include <crfsuite.h>
+#include "crfsuite_internal.h"
+#include "logging.h"
+#include "params.h"
+#include "vecmath.h"
+
+#define MIN(a, b) ((a) < (b) ? (a) : (b))
+
+/**
+ * Training parameters (configurable with crfsuite_params_t interface).
+ */
+typedef struct
+{
+    int type;
+    floatval_t c;
+    int error_sensitive;
+    int averaging;
+    int max_iterations;
+    floatval_t epsilon;
+} training_option_t;
+
+/**
+ * Internal data structure for computing the sparse vector F(x, y) - F(x, y').
+ */
+typedef struct
+{
+    /* An array of feature indices relevant to the instance. */
+    int *actives;
+    int num_actives;
+    int cap_actives;
+    char *used;
+
+    /* Coefficient for collecting feature weights. */
+    floatval_t c;
+    /* The difference vector [K]. */
+    floatval_t *delta;
+    /* The number of features. */
+    int K;
+} delta_t;
+
+static int delta_init(delta_t *dc, const int K)
+{
+    memset(dc, 0, sizeof(*dc));
+    dc->used = (char *)calloc(K, sizeof(char));
+    dc->delta = (floatval_t *)calloc(K, sizeof(floatval_t));
+    dc->K = K;
+    if (dc->delta == NULL || dc->used == NULL)
+    {
+        return 1;
+    }
+    return 0;
+}
+
+static void delta_finish(delta_t *dc)
+{
+    free(dc->actives);
+    free(dc->used);
+    free(dc->delta);
+    memset(dc, 0, sizeof(*dc));
+}
+
+static void delta_reset(delta_t *dc)
+{
+    int i;
+    for (i = 0; i < dc->num_actives; ++i)
+    {
+        int k = dc->actives[i];
+        dc->delta[k] = 0;
+    }
+    dc->num_actives = 0;
+}
+
+static void delta_collect(void *instance, int fid, floatval_t value)
+{
+    delta_t *dc = (delta_t *)instance;
+
+    /* Expand the active feature list if necessary. */
+    if (dc->cap_actives <= dc->num_actives)
+    {
+        ++dc->cap_actives;
+        dc->cap_actives *= 2;
+        dc->actives = (int *)realloc(dc->actives, sizeof(int) * dc->cap_actives);
+    }
+
+    dc->actives[dc->num_actives++] = fid;
+    dc->delta[fid] += dc->c * value;
+}
+
+static void delta_finalize(delta_t *dc)
+{
+    int i, j = 0, k;
+
+    /* Collapse the duplicated indices. */
+    for (i = 0; i < dc->num_actives; ++i)
+    {
+        k = dc->actives[i];
+        if (!dc->used[k])
+        {
+            dc->actives[j++] = k;
+            dc->used[k] = 1;
+        }
+    }
+    dc->num_actives = j; /* This is the distinct number of indices. */
+
+    /* Reset the used flag. */
+    for (i = 0; i < dc->num_actives; ++i)
+    {
+        k = dc->actives[i];
+        dc->used[k] = 0;
+    }
+}
+
+static floatval_t delta_norm2(delta_t *dc)
+{
+    int i;
+    floatval_t norm2 = 0.;
+
+    for (i = 0; i < dc->num_actives; ++i)
+    {
+        int k = dc->actives[i];
+        norm2 += dc->delta[k] * dc->delta[k];
+    }
+    return norm2;
+}
+
+static void delta_add(delta_t *dc, floatval_t *w, floatval_t *ws, const floatval_t tau, const floatval_t u)
+{
+    int i;
+    const floatval_t tauu = tau * u;
+
+    for (i = 0; i < dc->num_actives; ++i)
+    {
+        int k = dc->actives[i];
+        w[k] += tau * dc->delta[k];
+        ws[k] += tauu * dc->delta[k];
+    }
+}
+
+static int diff(int *x, int *y, int n)
+{
+    int i, d = 0;
+    for (i = 0; i < n; ++i)
+    {
+        if (x[i] != y[i])
+        {
+            ++d;
+        }
+    }
+    return d;
+}
+
+static floatval_t cost_insensitive(floatval_t err, floatval_t d)
+{
+    return err + 1.;
+}
+
+static floatval_t cost_sensitive(floatval_t err, floatval_t d)
+{
+    return err + sqrt(d);
+}
+
+static floatval_t tau0(floatval_t cost, floatval_t norm, floatval_t c)
+{
+    return cost / norm;
+}
+
+static floatval_t tau1(floatval_t cost, floatval_t norm, floatval_t c)
+{
+    return MIN(c, cost / norm);
+}
+
+static floatval_t tau2(floatval_t cost, floatval_t norm, floatval_t c)
+{
+    return cost / (norm + 0.5 / c);
+}
+
+static int exchange_options(crfsuite_params_t *params, training_option_t *opt, int mode)
+{
+    BEGIN_PARAM_MAP(params, mode)
+    DDX_PARAM_INT(
+        "type", opt->type, 1,
+        "The strategy for updating feature weights: {\n"
+        "    0: PA without slack variables,\n"
+        "    1: PA type I,\n"
+        "    2: PA type II\n"
+        "}.\n")
+    DDX_PARAM_FLOAT(
+        "c", opt->c, 1.,
+        "The aggressiveness parameter.")
+    DDX_PARAM_INT(
+        "error_sensitive", opt->error_sensitive, 1,
+        "Consider the number of incorrect labels to the cost function.")
+    DDX_PARAM_INT(
+        "averaging", opt->averaging, 1,
+        "Compute the average of feature weights (similarly to Averaged Perceptron).")
+    DDX_PARAM_INT(
+        "max_iterations", opt->max_iterations, 100,
+        "The maximum number of iterations.")
+    DDX_PARAM_FLOAT(
+        "epsilon", opt->epsilon, 0.,
+        "The stopping criterion (the mean loss).")
+    END_PARAM_MAP()
+
+    return 0;
+}
+
+void crfsuite_train_passive_aggressive_init(crfsuite_params_t *params)
+{
+    exchange_options(params, NULL, 0);
+}
+
+int crfsuite_train_passive_aggressive(
+    encoder_t *gm,
+    dataset_t *trainset,
+    dataset_t *testset,
+    crfsuite_params_t *params,
+    logging_t *lg,
+    floatval_t **ptr_w)
+{
+    int n, i, u, ret = 0;
+    int *viterbi = NULL;
+    floatval_t *w = NULL, *ws = NULL, *wa = NULL;
+    const int N = trainset->num_instances;
+    const int K = gm->num_features;
+    const int T = gm->cap_items;
+    training_option_t opt;
+    delta_t dc;
+    clock_t begin = clock();
+    floatval_t (*cost_function)(floatval_t err, floatval_t d) = NULL;
+    floatval_t (*tau_function)(floatval_t cost, floatval_t norm, floatval_t c) = NULL;
+
+    /* Initialize the variable. */
+    if (delta_init(&dc, K) != 0)
+    {
+        ret = CRFSUITEERR_OUTOFMEMORY;
+        goto error_exit;
+    }
+
+    /* Obtain parameter values. */
+    exchange_options(params, &opt, -1);
+
+    /* Allocate arrays. */
+    w = (floatval_t *)calloc(sizeof(floatval_t), K);
+    ws = (floatval_t *)calloc(sizeof(floatval_t), K);
+    wa = (floatval_t *)calloc(sizeof(floatval_t), K);
+    viterbi = (int *)calloc(sizeof(int), T);
+    if (w == NULL || ws == NULL || wa == NULL || viterbi == NULL)
+    {
+        ret = CRFSUITEERR_OUTOFMEMORY;
+        goto error_exit;
+    }
+
+    /* Set the cost function for instances. */
+    if (opt.error_sensitive)
+    {
+        cost_function = cost_sensitive;
+    }
+    else
+    {
+        cost_function = cost_insensitive;
+    }
+
+    /* Set the routine for computing tau (i.e., PA, PA-I, PA-II). */
+    if (opt.type == 1)
+    {
+        tau_function = tau1;
+    }
+    else if (opt.type == 2)
+    {
+        tau_function = tau2;
+    }
+    else
+    {
+        tau_function = tau0;
+    }
+
+    /* Show the parameters. */
+    logging(lg, "Start training with PA");
+
+    u = 1;
+
+    /* Loop for epoch. */
+    for (i = 0; i < opt.max_iterations; ++i)
+    {
+        floatval_t norm = 0., sum_loss = 0.;
+        clock_t iteration_begin = clock();
+
+        /* Shuffle the instances. */
+        dataset_shuffle(trainset);
+
+        /* Loop for each instance. */
+        for (n = 0; n < N; ++n)
+        {
+            int d = 0;
+            floatval_t sv;
+            const crfsuite_instance_t *inst = dataset_get(trainset, n);
+
+            /* Set the feature weights to the encoder. */
+            gm->set_weights(gm, w, 1.);
+            gm->set_instance(gm, inst);
+
+            /* Tag the sequence with the current model. */
+            gm->viterbi(gm, viterbi, &sv);
+
+            /* Compute the number of different labels. */
+            d = diff(inst->labels, viterbi, inst->num_items);
+            if (0 < d)
+            {
+                floatval_t sc, norm2;
+                floatval_t tau, cost;
+
+                /*
+                    Compute the cost of this instance.
+                 */
+                gm->score(gm, inst->labels, &sc);
+                cost = cost_function(sv - sc, (double)d);
+
+                /* Initialize delta[k] = 0. */
+                delta_reset(&dc);
+
+                /*
+                    For every feature k on the correct path:
+                        delta[k] += 1;
+                 */
+                dc.c = 1;
+                gm->features_on_path(gm, inst, inst->labels, delta_collect, &dc);
+
+                /*
+                    For every feature k on the Viterbi path:
+                        delta[k] -= 1;
+                 */
+                dc.c = -1;
+                gm->features_on_path(gm, inst, viterbi, delta_collect, &dc);
+
+                delta_finalize(&dc);
+
+                /*
+                    Compute tau (dpending on PA, PA-I, and PA-II).
+                 */
+                norm2 = delta_norm2(&dc);
+                tau = tau_function(cost, norm2, opt.c);
+
+                /*
+                    Update the feature weights:
+                        w[k] += tau * delta[k]
+                        ws[k] += tau * u * delta[k]
+                 */
+                delta_add(&dc, w, ws, tau * inst->weight, u);
+
+                sum_loss += cost * inst->weight;
+            }
+            ++u;
+        }
+
+        if (opt.averaging)
+        {
+            /* Perform averaging to wa. */
+            veccopy(wa, w, K);
+            vecasub(wa, 1. / u, ws, K);
+        }
+        else
+        {
+            /* Simply copy the weights to wa. */
+            veccopy(wa, w, K);
+        }
+
+        /* Output the progress. */
+        logging(lg, "Iteration %d, training loss: %f", i + 1, sum_loss);
+
+        /* Holdout evaluation if necessary. */
+        if (testset != NULL)
+        {
+            holdout_evaluation(gm, testset, wa, lg);
+        }
+
+        /* Convergence test. */
+        if (sum_loss / N < opt.epsilon)
+        {
+            logging(lg, "Loss has converged, terminating training");
+            break;
+        }
+    }
+
+    free(viterbi);
+    free(ws);
+    free(w);
+    *ptr_w = wa;
+    delta_finish(&dc);
+    return ret;
+
+error_exit:
+    free(viterbi);
+    free(wa);
+    free(ws);
+    free(w);
+    *ptr_w = NULL;
+    delta_finish(&dc);
+
+    return ret;
+}
```

## chaine/_core/crfsuite/lib/crf/src/vecmath.h

 * *Ordering differences only*

```diff
@@ -1,360 +1,360 @@
-/*
- *      Mathematical operations for vectors.
- *
- * Copyright (c) 2007-2010, Naoaki Okazaki
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the names of the authors nor the names of its contributors
- *       may be used to endorse or promote products derived from this
- *       software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
- * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-/* $Id$ */
-
-#ifndef __VECMATH_H__
-#define __VECMATH_H__
-
-#include <math.h>
-#include <memory.h>
-
-#ifdef USE_SSE
-#include <emmintrin.h>
-#endif /*USE_SSE*/
-
-#if defined(_MSC_VER) || defined(__MINGW32__) || defined(__MINGW64__)
-#include <malloc.h>
-#else
-#include <stdlib.h>
-static inline void *_aligned_malloc(size_t size, size_t alignment)
-{
-    void *p;
-    int ret = posix_memalign(&p, alignment, size);
-    return (ret == 0) ? p : 0;
-}
-static inline void _aligned_free(void *p)
-{
-    free(p);
-}
-#endif
-
-#ifdef _MSC_VER
-#define MIE_ALIGN(x) __declspec(align(x))
-#else
-#define MIE_ALIGN(x) __attribute__((aligned(x)))
-#endif
-
-#define CONST_128D(var, val) \
-    MIE_ALIGN(16)            \
-    static const double var[2] = {(val), (val)}
-
-inline static void veczero(floatval_t *x, const int n)
-{
-    if (n)
-    {
-        memset(x, 0, sizeof(floatval_t) * n);
-    }
-}
-
-inline static void vecset(floatval_t *x, const floatval_t a, const int n)
-{
-    int i;
-    for (i = 0; i < n; ++i)
-    {
-        x[i] = a;
-    }
-}
-
-inline static void veccopy(floatval_t *y, const floatval_t *x, const int n)
-{
-    if (n)
-    {
-        memcpy(y, x, sizeof(floatval_t) * n);
-    }
-}
-
-inline static void vecadd(floatval_t *y, const floatval_t *x, const int n)
-{
-    int i;
-    for (i = 0; i < n; ++i)
-    {
-        y[i] += x[i];
-    }
-}
-
-inline static void vecaadd(floatval_t *y, const floatval_t a, const floatval_t *x, const int n)
-{
-    int i;
-    for (i = 0; i < n; ++i)
-    {
-        y[i] += a * x[i];
-    }
-}
-
-inline static void vecsub(floatval_t *y, const floatval_t *x, const int n)
-{
-    int i;
-    for (i = 0; i < n; ++i)
-    {
-        y[i] -= x[i];
-    }
-}
-
-inline static void vecasub(floatval_t *y, const floatval_t a, const floatval_t *x, const int n)
-{
-    int i;
-    for (i = 0; i < n; ++i)
-    {
-        y[i] -= a * x[i];
-    }
-}
-
-inline static void vecmul(floatval_t *y, const floatval_t *x, const int n)
-{
-    int i;
-    for (i = 0; i < n; ++i)
-    {
-        y[i] *= x[i];
-    }
-}
-
-inline static void vecinv(floatval_t *y, const int n)
-{
-    int i;
-    for (i = 0; i < n; ++i)
-    {
-        y[i] = 1. / y[i];
-    }
-}
-
-inline static void vecscale(floatval_t *y, const floatval_t a, const int n)
-{
-    int i;
-    for (i = 0; i < n; ++i)
-    {
-        y[i] *= a;
-    }
-}
-
-inline static floatval_t vecdot(const floatval_t *x, const floatval_t *y, const int n)
-{
-    int i;
-    floatval_t s = 0;
-    for (i = 0; i < n; ++i)
-    {
-        s += x[i] * y[i];
-    }
-    return s;
-}
-
-inline static floatval_t vecsum(floatval_t *x, const int n)
-{
-    int i;
-    floatval_t s = 0.;
-
-    for (i = 0; i < n; ++i)
-    {
-        s += x[i];
-    }
-    return s;
-}
-
-inline static floatval_t vecsumlog(floatval_t *x, const int n)
-{
-    int i;
-    floatval_t s = 0.;
-    for (i = 0; i < n; ++i)
-    {
-        s += log(x[i]);
-    }
-    return s;
-}
-
-#ifdef USE_SSE
-
-inline static void vecexp(double *values, const int n)
-{
-    int i;
-    CONST_128D(one, 1.);
-    CONST_128D(log2e, 1.4426950408889634073599);
-    CONST_128D(maxlog, 7.09782712893383996843e2);  // log(2**1024)
-    CONST_128D(minlog, -7.08396418532264106224e2); // log(2**-1022)
-    CONST_128D(c1, 6.93145751953125E-1);
-    CONST_128D(c2, 1.42860682030941723212E-6);
-    CONST_128D(w11, 3.5524625185478232665958141148891055719216674475023e-8);
-    CONST_128D(w10, 2.5535368519306500343384723775435166753084614063349e-7);
-    CONST_128D(w9, 2.77750562801295315877005242757916081614772210463065e-6);
-    CONST_128D(w8, 2.47868893393199945541176652007657202642495832996107e-5);
-    CONST_128D(w7, 1.98419213985637881240770890090795533564573406893163e-4);
-    CONST_128D(w6, 1.3888869684178659239014256260881685824525255547326e-3);
-    CONST_128D(w5, 8.3333337052009872221152811550156335074160546333973e-3);
-    CONST_128D(w4, 4.1666666621080810610346717440523105184720007971655e-2);
-    CONST_128D(w3, 0.166666666669960803484477734308515404418108830469798);
-    CONST_128D(w2, 0.499999999999877094481580370323249951329122224389189);
-    CONST_128D(w1, 1.0000000000000017952745258419615282194236357388884);
-    CONST_128D(w0, 0.99999999999999999566016490920259318691496540598896);
-    const __m128i offset = _mm_setr_epi32(1023, 1023, 0, 0);
-
-    for (i = 0; i < n; i += 4)
-    {
-        __m128i k1, k2;
-        __m128d p1, p2;
-        __m128d a1, a2;
-        __m128d xmm0, xmm1;
-        __m128d x1, x2;
-
-        /* Load four double values. */
-        xmm0 = _mm_load_pd(maxlog);
-        xmm1 = _mm_load_pd(minlog);
-        x1 = _mm_load_pd(values + i);
-        x2 = _mm_load_pd(values + i + 2);
-        x1 = _mm_min_pd(x1, xmm0);
-        x2 = _mm_min_pd(x2, xmm0);
-        x1 = _mm_max_pd(x1, xmm1);
-        x2 = _mm_max_pd(x2, xmm1);
-
-        /* a = x / log2; */
-        xmm0 = _mm_load_pd(log2e);
-        xmm1 = _mm_setzero_pd();
-        a1 = _mm_mul_pd(x1, xmm0);
-        a2 = _mm_mul_pd(x2, xmm0);
-
-        /* k = (int)floor(a); p = (float)k; */
-        p1 = _mm_cmplt_pd(a1, xmm1);
-        p2 = _mm_cmplt_pd(a2, xmm1);
-        xmm0 = _mm_load_pd(one);
-        p1 = _mm_and_pd(p1, xmm0);
-        p2 = _mm_and_pd(p2, xmm0);
-        a1 = _mm_sub_pd(a1, p1);
-        a2 = _mm_sub_pd(a2, p2);
-        k1 = _mm_cvttpd_epi32(a1);
-        k2 = _mm_cvttpd_epi32(a2);
-        p1 = _mm_cvtepi32_pd(k1);
-        p2 = _mm_cvtepi32_pd(k2);
-
-        /* x -= p * log2; */
-        xmm0 = _mm_load_pd(c1);
-        xmm1 = _mm_load_pd(c2);
-        a1 = _mm_mul_pd(p1, xmm0);
-        a2 = _mm_mul_pd(p2, xmm0);
-        x1 = _mm_sub_pd(x1, a1);
-        x2 = _mm_sub_pd(x2, a2);
-        a1 = _mm_mul_pd(p1, xmm1);
-        a2 = _mm_mul_pd(p2, xmm1);
-        x1 = _mm_sub_pd(x1, a1);
-        x2 = _mm_sub_pd(x2, a2);
-
-        xmm0 = _mm_load_pd(w11);
-        xmm1 = _mm_load_pd(w10);
-        a1 = _mm_mul_pd(x1, xmm0);
-        a2 = _mm_mul_pd(x2, xmm0);
-        a1 = _mm_add_pd(a1, xmm1);
-        a2 = _mm_add_pd(a2, xmm1);
-
-        xmm0 = _mm_load_pd(w9);
-        xmm1 = _mm_load_pd(w8);
-        a1 = _mm_mul_pd(a1, x1);
-        a2 = _mm_mul_pd(a2, x2);
-        a1 = _mm_add_pd(a1, xmm0);
-        a2 = _mm_add_pd(a2, xmm0);
-        a1 = _mm_mul_pd(a1, x1);
-        a2 = _mm_mul_pd(a2, x2);
-        a1 = _mm_add_pd(a1, xmm1);
-        a2 = _mm_add_pd(a2, xmm1);
-
-        xmm0 = _mm_load_pd(w7);
-        xmm1 = _mm_load_pd(w6);
-        a1 = _mm_mul_pd(a1, x1);
-        a2 = _mm_mul_pd(a2, x2);
-        a1 = _mm_add_pd(a1, xmm0);
-        a2 = _mm_add_pd(a2, xmm0);
-        a1 = _mm_mul_pd(a1, x1);
-        a2 = _mm_mul_pd(a2, x2);
-        a1 = _mm_add_pd(a1, xmm1);
-        a2 = _mm_add_pd(a2, xmm1);
-
-        xmm0 = _mm_load_pd(w5);
-        xmm1 = _mm_load_pd(w4);
-        a1 = _mm_mul_pd(a1, x1);
-        a2 = _mm_mul_pd(a2, x2);
-        a1 = _mm_add_pd(a1, xmm0);
-        a2 = _mm_add_pd(a2, xmm0);
-        a1 = _mm_mul_pd(a1, x1);
-        a2 = _mm_mul_pd(a2, x2);
-        a1 = _mm_add_pd(a1, xmm1);
-        a2 = _mm_add_pd(a2, xmm1);
-
-        xmm0 = _mm_load_pd(w3);
-        xmm1 = _mm_load_pd(w2);
-        a1 = _mm_mul_pd(a1, x1);
-        a2 = _mm_mul_pd(a2, x2);
-        a1 = _mm_add_pd(a1, xmm0);
-        a2 = _mm_add_pd(a2, xmm0);
-        a1 = _mm_mul_pd(a1, x1);
-        a2 = _mm_mul_pd(a2, x2);
-        a1 = _mm_add_pd(a1, xmm1);
-        a2 = _mm_add_pd(a2, xmm1);
-
-        xmm0 = _mm_load_pd(w1);
-        xmm1 = _mm_load_pd(w0);
-        a1 = _mm_mul_pd(a1, x1);
-        a2 = _mm_mul_pd(a2, x2);
-        a1 = _mm_add_pd(a1, xmm0);
-        a2 = _mm_add_pd(a2, xmm0);
-        a1 = _mm_mul_pd(a1, x1);
-        a2 = _mm_mul_pd(a2, x2);
-        a1 = _mm_add_pd(a1, xmm1);
-        a2 = _mm_add_pd(a2, xmm1);
-
-        /* p = 2^k; */
-        k1 = _mm_add_epi32(k1, offset);
-        k2 = _mm_add_epi32(k2, offset);
-        k1 = _mm_slli_epi32(k1, 20);
-        k2 = _mm_slli_epi32(k2, 20);
-        k1 = _mm_shuffle_epi32(k1, 0x72);
-        k2 = _mm_shuffle_epi32(k2, 0x72);
-        p1 = _mm_castsi128_pd(k1);
-        p2 = _mm_castsi128_pd(k2);
-
-        /* a *= 2^k. */
-        a1 = _mm_mul_pd(a1, p1);
-        a2 = _mm_mul_pd(a2, p2);
-
-        /* Store the results. */
-        _mm_store_pd(values + i, a1);
-        _mm_store_pd(values + i + 2, a2);
-    }
-}
-
-#else
-
-inline static void vecexp(double *values, const int n)
-{
-    int i;
-    for (i = 0; i < n; ++i)
-    {
-        values[i] = exp(values[i]);
-    }
-}
-
-#endif /*USE_SSE*/
-
-#endif /*__VECMATH_H__*/
+/*
+ *      Mathematical operations for vectors.
+ *
+ * Copyright (c) 2007-2010, Naoaki Okazaki
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the names of the authors nor the names of its contributors
+ *       may be used to endorse or promote products derived from this
+ *       software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+ * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/* $Id$ */
+
+#ifndef __VECMATH_H__
+#define __VECMATH_H__
+
+#include <math.h>
+#include <memory.h>
+
+#ifdef USE_SSE
+#include <emmintrin.h>
+#endif /*USE_SSE*/
+
+#if defined(_MSC_VER) || defined(__MINGW32__) || defined(__MINGW64__)
+#include <malloc.h>
+#else
+#include <stdlib.h>
+static inline void *_aligned_malloc(size_t size, size_t alignment)
+{
+    void *p;
+    int ret = posix_memalign(&p, alignment, size);
+    return (ret == 0) ? p : 0;
+}
+static inline void _aligned_free(void *p)
+{
+    free(p);
+}
+#endif
+
+#ifdef _MSC_VER
+#define MIE_ALIGN(x) __declspec(align(x))
+#else
+#define MIE_ALIGN(x) __attribute__((aligned(x)))
+#endif
+
+#define CONST_128D(var, val) \
+    MIE_ALIGN(16)            \
+    static const double var[2] = {(val), (val)}
+
+inline static void veczero(floatval_t *x, const int n)
+{
+    if (n)
+    {
+        memset(x, 0, sizeof(floatval_t) * n);
+    }
+}
+
+inline static void vecset(floatval_t *x, const floatval_t a, const int n)
+{
+    int i;
+    for (i = 0; i < n; ++i)
+    {
+        x[i] = a;
+    }
+}
+
+inline static void veccopy(floatval_t *y, const floatval_t *x, const int n)
+{
+    if (n)
+    {
+        memcpy(y, x, sizeof(floatval_t) * n);
+    }
+}
+
+inline static void vecadd(floatval_t *y, const floatval_t *x, const int n)
+{
+    int i;
+    for (i = 0; i < n; ++i)
+    {
+        y[i] += x[i];
+    }
+}
+
+inline static void vecaadd(floatval_t *y, const floatval_t a, const floatval_t *x, const int n)
+{
+    int i;
+    for (i = 0; i < n; ++i)
+    {
+        y[i] += a * x[i];
+    }
+}
+
+inline static void vecsub(floatval_t *y, const floatval_t *x, const int n)
+{
+    int i;
+    for (i = 0; i < n; ++i)
+    {
+        y[i] -= x[i];
+    }
+}
+
+inline static void vecasub(floatval_t *y, const floatval_t a, const floatval_t *x, const int n)
+{
+    int i;
+    for (i = 0; i < n; ++i)
+    {
+        y[i] -= a * x[i];
+    }
+}
+
+inline static void vecmul(floatval_t *y, const floatval_t *x, const int n)
+{
+    int i;
+    for (i = 0; i < n; ++i)
+    {
+        y[i] *= x[i];
+    }
+}
+
+inline static void vecinv(floatval_t *y, const int n)
+{
+    int i;
+    for (i = 0; i < n; ++i)
+    {
+        y[i] = 1. / y[i];
+    }
+}
+
+inline static void vecscale(floatval_t *y, const floatval_t a, const int n)
+{
+    int i;
+    for (i = 0; i < n; ++i)
+    {
+        y[i] *= a;
+    }
+}
+
+inline static floatval_t vecdot(const floatval_t *x, const floatval_t *y, const int n)
+{
+    int i;
+    floatval_t s = 0;
+    for (i = 0; i < n; ++i)
+    {
+        s += x[i] * y[i];
+    }
+    return s;
+}
+
+inline static floatval_t vecsum(floatval_t *x, const int n)
+{
+    int i;
+    floatval_t s = 0.;
+
+    for (i = 0; i < n; ++i)
+    {
+        s += x[i];
+    }
+    return s;
+}
+
+inline static floatval_t vecsumlog(floatval_t *x, const int n)
+{
+    int i;
+    floatval_t s = 0.;
+    for (i = 0; i < n; ++i)
+    {
+        s += log(x[i]);
+    }
+    return s;
+}
+
+#ifdef USE_SSE
+
+inline static void vecexp(double *values, const int n)
+{
+    int i;
+    CONST_128D(one, 1.);
+    CONST_128D(log2e, 1.4426950408889634073599);
+    CONST_128D(maxlog, 7.09782712893383996843e2);  // log(2**1024)
+    CONST_128D(minlog, -7.08396418532264106224e2); // log(2**-1022)
+    CONST_128D(c1, 6.93145751953125E-1);
+    CONST_128D(c2, 1.42860682030941723212E-6);
+    CONST_128D(w11, 3.5524625185478232665958141148891055719216674475023e-8);
+    CONST_128D(w10, 2.5535368519306500343384723775435166753084614063349e-7);
+    CONST_128D(w9, 2.77750562801295315877005242757916081614772210463065e-6);
+    CONST_128D(w8, 2.47868893393199945541176652007657202642495832996107e-5);
+    CONST_128D(w7, 1.98419213985637881240770890090795533564573406893163e-4);
+    CONST_128D(w6, 1.3888869684178659239014256260881685824525255547326e-3);
+    CONST_128D(w5, 8.3333337052009872221152811550156335074160546333973e-3);
+    CONST_128D(w4, 4.1666666621080810610346717440523105184720007971655e-2);
+    CONST_128D(w3, 0.166666666669960803484477734308515404418108830469798);
+    CONST_128D(w2, 0.499999999999877094481580370323249951329122224389189);
+    CONST_128D(w1, 1.0000000000000017952745258419615282194236357388884);
+    CONST_128D(w0, 0.99999999999999999566016490920259318691496540598896);
+    const __m128i offset = _mm_setr_epi32(1023, 1023, 0, 0);
+
+    for (i = 0; i < n; i += 4)
+    {
+        __m128i k1, k2;
+        __m128d p1, p2;
+        __m128d a1, a2;
+        __m128d xmm0, xmm1;
+        __m128d x1, x2;
+
+        /* Load four double values. */
+        xmm0 = _mm_load_pd(maxlog);
+        xmm1 = _mm_load_pd(minlog);
+        x1 = _mm_load_pd(values + i);
+        x2 = _mm_load_pd(values + i + 2);
+        x1 = _mm_min_pd(x1, xmm0);
+        x2 = _mm_min_pd(x2, xmm0);
+        x1 = _mm_max_pd(x1, xmm1);
+        x2 = _mm_max_pd(x2, xmm1);
+
+        /* a = x / log2; */
+        xmm0 = _mm_load_pd(log2e);
+        xmm1 = _mm_setzero_pd();
+        a1 = _mm_mul_pd(x1, xmm0);
+        a2 = _mm_mul_pd(x2, xmm0);
+
+        /* k = (int)floor(a); p = (float)k; */
+        p1 = _mm_cmplt_pd(a1, xmm1);
+        p2 = _mm_cmplt_pd(a2, xmm1);
+        xmm0 = _mm_load_pd(one);
+        p1 = _mm_and_pd(p1, xmm0);
+        p2 = _mm_and_pd(p2, xmm0);
+        a1 = _mm_sub_pd(a1, p1);
+        a2 = _mm_sub_pd(a2, p2);
+        k1 = _mm_cvttpd_epi32(a1);
+        k2 = _mm_cvttpd_epi32(a2);
+        p1 = _mm_cvtepi32_pd(k1);
+        p2 = _mm_cvtepi32_pd(k2);
+
+        /* x -= p * log2; */
+        xmm0 = _mm_load_pd(c1);
+        xmm1 = _mm_load_pd(c2);
+        a1 = _mm_mul_pd(p1, xmm0);
+        a2 = _mm_mul_pd(p2, xmm0);
+        x1 = _mm_sub_pd(x1, a1);
+        x2 = _mm_sub_pd(x2, a2);
+        a1 = _mm_mul_pd(p1, xmm1);
+        a2 = _mm_mul_pd(p2, xmm1);
+        x1 = _mm_sub_pd(x1, a1);
+        x2 = _mm_sub_pd(x2, a2);
+
+        xmm0 = _mm_load_pd(w11);
+        xmm1 = _mm_load_pd(w10);
+        a1 = _mm_mul_pd(x1, xmm0);
+        a2 = _mm_mul_pd(x2, xmm0);
+        a1 = _mm_add_pd(a1, xmm1);
+        a2 = _mm_add_pd(a2, xmm1);
+
+        xmm0 = _mm_load_pd(w9);
+        xmm1 = _mm_load_pd(w8);
+        a1 = _mm_mul_pd(a1, x1);
+        a2 = _mm_mul_pd(a2, x2);
+        a1 = _mm_add_pd(a1, xmm0);
+        a2 = _mm_add_pd(a2, xmm0);
+        a1 = _mm_mul_pd(a1, x1);
+        a2 = _mm_mul_pd(a2, x2);
+        a1 = _mm_add_pd(a1, xmm1);
+        a2 = _mm_add_pd(a2, xmm1);
+
+        xmm0 = _mm_load_pd(w7);
+        xmm1 = _mm_load_pd(w6);
+        a1 = _mm_mul_pd(a1, x1);
+        a2 = _mm_mul_pd(a2, x2);
+        a1 = _mm_add_pd(a1, xmm0);
+        a2 = _mm_add_pd(a2, xmm0);
+        a1 = _mm_mul_pd(a1, x1);
+        a2 = _mm_mul_pd(a2, x2);
+        a1 = _mm_add_pd(a1, xmm1);
+        a2 = _mm_add_pd(a2, xmm1);
+
+        xmm0 = _mm_load_pd(w5);
+        xmm1 = _mm_load_pd(w4);
+        a1 = _mm_mul_pd(a1, x1);
+        a2 = _mm_mul_pd(a2, x2);
+        a1 = _mm_add_pd(a1, xmm0);
+        a2 = _mm_add_pd(a2, xmm0);
+        a1 = _mm_mul_pd(a1, x1);
+        a2 = _mm_mul_pd(a2, x2);
+        a1 = _mm_add_pd(a1, xmm1);
+        a2 = _mm_add_pd(a2, xmm1);
+
+        xmm0 = _mm_load_pd(w3);
+        xmm1 = _mm_load_pd(w2);
+        a1 = _mm_mul_pd(a1, x1);
+        a2 = _mm_mul_pd(a2, x2);
+        a1 = _mm_add_pd(a1, xmm0);
+        a2 = _mm_add_pd(a2, xmm0);
+        a1 = _mm_mul_pd(a1, x1);
+        a2 = _mm_mul_pd(a2, x2);
+        a1 = _mm_add_pd(a1, xmm1);
+        a2 = _mm_add_pd(a2, xmm1);
+
+        xmm0 = _mm_load_pd(w1);
+        xmm1 = _mm_load_pd(w0);
+        a1 = _mm_mul_pd(a1, x1);
+        a2 = _mm_mul_pd(a2, x2);
+        a1 = _mm_add_pd(a1, xmm0);
+        a2 = _mm_add_pd(a2, xmm0);
+        a1 = _mm_mul_pd(a1, x1);
+        a2 = _mm_mul_pd(a2, x2);
+        a1 = _mm_add_pd(a1, xmm1);
+        a2 = _mm_add_pd(a2, xmm1);
+
+        /* p = 2^k; */
+        k1 = _mm_add_epi32(k1, offset);
+        k2 = _mm_add_epi32(k2, offset);
+        k1 = _mm_slli_epi32(k1, 20);
+        k2 = _mm_slli_epi32(k2, 20);
+        k1 = _mm_shuffle_epi32(k1, 0x72);
+        k2 = _mm_shuffle_epi32(k2, 0x72);
+        p1 = _mm_castsi128_pd(k1);
+        p2 = _mm_castsi128_pd(k2);
+
+        /* a *= 2^k. */
+        a1 = _mm_mul_pd(a1, p1);
+        a2 = _mm_mul_pd(a2, p2);
+
+        /* Store the results. */
+        _mm_store_pd(values + i, a1);
+        _mm_store_pd(values + i + 2, a2);
+    }
+}
+
+#else
+
+inline static void vecexp(double *values, const int n)
+{
+    int i;
+    for (i = 0; i < n; ++i)
+    {
+        values[i] = exp(values[i]);
+    }
+}
+
+#endif /*USE_SSE*/
+
+#endif /*__VECMATH_H__*/
```

## chaine/_core/crfsuite/README

 * *Ordering differences only*

```diff
@@ -1,183 +1,183 @@
-                               CRFsuite
-                              Version 0.12
-                 http://www.chokkan.org/software/crfsuite/
-
-
-
-* INTRODUCTION
-CRFSuite is an implementation of Conditional Random Fields (CRFs) for
-labeling sequential data. Please refer to the web site for more
-information about this software.
-
-
-
-* COPYRIGHT AND LICENSING INFORMATION
-
-This program is distributed under the modified BSD license. Refer to
-COPYING file for the precise description of the license.
-
-
-Portions of this software are based on libLBFGS.
-
-The MIT License
-
-Copyright (c) 1990 Jorge Nocedal
-Copyright (c) 2007 Naoaki Okazaki
-
-Permission is hereby granted, free of charge, to any person obtaining a
-copy of this software and associated documentation files (the "Software"),
-to deal in the Software without restriction, including without limitation
-the rights to use, copy, modify, merge, publish, distribute, sublicense,
-and/or sell copies of the Software, and to permit persons to whom the
-Software is furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in
-all copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
-THE SOFTWARE.
-
-
-Portions of this software are based on Constant Quark Database (CQDB).
-
-The BSD license.
-
-Copyright (c) 2007, Naoaki Okazaki
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in the
-      documentation and/or other materials provided with the distribution.
-    * Neither the name of the Northwestern University, University of Tokyo,
-      nor the names of its contributors may be used to endorse or promote
-      products derived from this software without specific prior written
-      permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
-OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
-EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
-PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-
-Portions of this software are based on RumAVL.
-
-MIT/X Consortium License.
-
-Copyright (c) 2005-2007 Jesse Long <jpl@unknown.za.net>
-All rights reserved.
-
-Permission is hereby granted, free of charge, to any person obtaining a
-copy of this software and associated documentation files (the "Software"),
-to deal in the Software without restriction, including without limitation
-the rights to use, copy, modify, merge, publish, distribute, sublicense,
-and/or sell copies of the Software, and to permit persons to whom the
-Software is furnished to do so, subject to the following conditions:
-
-   1. The above copyright notice and this permission notice shall be
-      included in all copies or substantial portions of the Software.
-   2. The origin of the Software must not be misrepresented; you must not
-      claim that you wrote the original Software.
-   3. Altered source versions of the Software must be plainly marked as
-      such, and must not be misrepresented as being the original Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
-DEALINGS IN THE SOFTWARE.
-
-
-Portions of this software are based on a portable stdint.h (for MSVC).
-
-Copyright (c) 2005-2007 Paul Hsieh
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions
-are met:
-
-    Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
-
-    Redistributions in binary form must not misrepresent the orignal
-    source in the documentation and/or other materials provided
-    with the distribution.
-
-    The names of the authors nor its contributors may be used to
-    endorse or promote products derived from this software without
-    specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
-FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
-COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
-INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
-SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
-HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
-STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
-OF THE POSSIBILITY OF SUCH DAMAGE.
-
-
-Portions of this software are based on Mersenne Twister.
-
-Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,
-All rights reserved.                          
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions
-are met:
-
-  1. Redistributions of source code must retain the above copyright
-     notice, this list of conditions and the following disclaimer.
-
-  2. Redistributions in binary form must reproduce the above copyright
-     notice, this list of conditions and the following disclaimer in the
-     documentation and/or other materials provided with the distribution.
-
-  3. The names of its contributors may not be used to endorse or promote 
-     products derived from this software without specific prior written 
-     permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
-CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
-EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
-PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-
-
-* SPECIAL THANKS GOES TO...
-Olivier Grisel
-Andreas Holzbach
-Baoli Li
-Yoshimasa Tsuruoka
-Hiroshi Manabe
-Riza Theresa B. Batista-Navarro
-
-
+                               CRFsuite
+                              Version 0.12
+                 http://www.chokkan.org/software/crfsuite/
+
+
+
+* INTRODUCTION
+CRFSuite is an implementation of Conditional Random Fields (CRFs) for
+labeling sequential data. Please refer to the web site for more
+information about this software.
+
+
+
+* COPYRIGHT AND LICENSING INFORMATION
+
+This program is distributed under the modified BSD license. Refer to
+COPYING file for the precise description of the license.
+
+
+Portions of this software are based on libLBFGS.
+
+The MIT License
+
+Copyright (c) 1990 Jorge Nocedal
+Copyright (c) 2007 Naoaki Okazaki
+
+Permission is hereby granted, free of charge, to any person obtaining a
+copy of this software and associated documentation files (the "Software"),
+to deal in the Software without restriction, including without limitation
+the rights to use, copy, modify, merge, publish, distribute, sublicense,
+and/or sell copies of the Software, and to permit persons to whom the
+Software is furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+THE SOFTWARE.
+
+
+Portions of this software are based on Constant Quark Database (CQDB).
+
+The BSD license.
+
+Copyright (c) 2007, Naoaki Okazaki
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+    * Neither the name of the Northwestern University, University of Tokyo,
+      nor the names of its contributors may be used to endorse or promote
+      products derived from this software without specific prior written
+      permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+
+Portions of this software are based on RumAVL.
+
+MIT/X Consortium License.
+
+Copyright (c) 2005-2007 Jesse Long <jpl@unknown.za.net>
+All rights reserved.
+
+Permission is hereby granted, free of charge, to any person obtaining a
+copy of this software and associated documentation files (the "Software"),
+to deal in the Software without restriction, including without limitation
+the rights to use, copy, modify, merge, publish, distribute, sublicense,
+and/or sell copies of the Software, and to permit persons to whom the
+Software is furnished to do so, subject to the following conditions:
+
+   1. The above copyright notice and this permission notice shall be
+      included in all copies or substantial portions of the Software.
+   2. The origin of the Software must not be misrepresented; you must not
+      claim that you wrote the original Software.
+   3. Altered source versions of the Software must be plainly marked as
+      such, and must not be misrepresented as being the original Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+DEALINGS IN THE SOFTWARE.
+
+
+Portions of this software are based on a portable stdint.h (for MSVC).
+
+Copyright (c) 2005-2007 Paul Hsieh
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions
+are met:
+
+    Redistributions of source code must retain the above copyright
+    notice, this list of conditions and the following disclaimer.
+
+    Redistributions in binary form must not misrepresent the orignal
+    source in the documentation and/or other materials provided
+    with the distribution.
+
+    The names of the authors nor its contributors may be used to
+    endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+OF THE POSSIBILITY OF SUCH DAMAGE.
+
+
+Portions of this software are based on Mersenne Twister.
+
+Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,
+All rights reserved.                          
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions
+are met:
+
+  1. Redistributions of source code must retain the above copyright
+     notice, this list of conditions and the following disclaimer.
+
+  2. Redistributions in binary form must reproduce the above copyright
+     notice, this list of conditions and the following disclaimer in the
+     documentation and/or other materials provided with the distribution.
+
+  3. The names of its contributors may not be used to endorse or promote 
+     products derived from this software without specific prior written 
+     permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+
+
+* SPECIAL THANKS GOES TO...
+Olivier Grisel
+Andreas Holzbach
+Baoli Li
+Yoshimasa Tsuruoka
+Hiroshi Manabe
+Riza Theresa B. Batista-Navarro
+
+
```

## chaine/_core/crfsuite/swig/crfsuite.cpp

 * *Ordering differences only*

```diff
@@ -1 +1 @@
-#include <crfsuite.hpp>
+#include <crfsuite.hpp>
```

## chaine/_core/crfsuite_api.pxd

 * *Ordering differences only*

```diff
@@ -1,67 +1,67 @@
-from libcpp.string cimport string
-from libcpp.vector cimport vector
-
-
-cdef extern from "crfsuite/include/crfsuite.h":
-    ctypedef enum:
-        CRFSUITE_SUCCESS
-        CRFSUITEERR_UNKNOWN
-        CRFSUITEERR_OUTOFMEMORY
-        CRFSUITEERR_NOTSUPPORTED
-        CRFSUITEERR_INCOMPATIBLE
-        CRFSUITEERR_INTERNAL_LOGIC
-        CRFSUITEERR_OVERFLOW
-        CRFSUITEERR_NOTIMPLEMENTED
-
-
-cdef extern from "crfsuite/include/crfsuite_api.hpp" namespace "CRFSuite":
-    cdef cppclass Attribute:
-        string attr
-        double value
-
-        Attribute()
-        Attribute(string)
-        Attribute(string, double)
-
-    ctypedef vector[Attribute] Item
-    ctypedef vector[Item] ItemSequence
-    ctypedef vector[string] StringList
-
-    cdef string version()
-
-
-cdef extern from "trainer_wrapper.hpp" namespace "CRFSuiteWrapper":
-
-    ctypedef object (*messagefunc)(object self, string message)
-
-    cdef cppclass Trainer:
-        Trainer() except +
-        void set_handler(object, messagefunc) except +
-        void clear() except +
-        void append(ItemSequence, StringList, int) except +
-        bint select(string, string) except +
-        int train(string, int) except +
-        StringList params() except +
-        void set(string, string) except +
-        string get(string) except +
-        string help(string) except +
-        void _init_trainer() except +
-
-
-cdef extern from "tagger_wrapper.hpp" namespace "CRFSuiteWrapper":
-
-    ctypedef object (*messagefunc)(object self, string message)
-
-    cdef cppclass Tagger:
-        Tagger() except +
-        int open(string) except +
-        int open(const void*, size_t) except +
-        void close() except +
-        StringList labels() except +
-        StringList tag(ItemSequence) except +
-        void set(ItemSequence) except +
-        StringList viterbi() except +
-        double probability(StringList) except +
-        double marginal(string, int) except +
-        void dump_transitions(int) except +
-        void dump_states(int) except +
+from libcpp.string cimport string
+from libcpp.vector cimport vector
+
+
+cdef extern from "crfsuite/include/crfsuite.h":
+    ctypedef enum:
+        CRFSUITE_SUCCESS
+        CRFSUITEERR_UNKNOWN
+        CRFSUITEERR_OUTOFMEMORY
+        CRFSUITEERR_NOTSUPPORTED
+        CRFSUITEERR_INCOMPATIBLE
+        CRFSUITEERR_INTERNAL_LOGIC
+        CRFSUITEERR_OVERFLOW
+        CRFSUITEERR_NOTIMPLEMENTED
+
+
+cdef extern from "crfsuite/include/crfsuite_api.hpp" namespace "CRFSuite":
+    cdef cppclass Attribute:
+        string attr
+        double value
+
+        Attribute()
+        Attribute(string)
+        Attribute(string, double)
+
+    ctypedef vector[Attribute] Item
+    ctypedef vector[Item] ItemSequence
+    ctypedef vector[string] StringList
+
+    cdef string version()
+
+
+cdef extern from "trainer_wrapper.hpp" namespace "CRFSuiteWrapper":
+
+    ctypedef object (*messagefunc)(object self, string message)
+
+    cdef cppclass Trainer:
+        Trainer() except +
+        void set_handler(object, messagefunc) except +
+        void clear() except +
+        void append(ItemSequence, StringList, int) except +
+        bint select(string, string) except +
+        int train(string, int) except +
+        StringList params() except +
+        void set(string, string) except +
+        string get(string) except +
+        string help(string) except +
+        void _init_trainer() except +
+
+
+cdef extern from "tagger_wrapper.hpp" namespace "CRFSuiteWrapper":
+
+    ctypedef object (*messagefunc)(object self, string message)
+
+    cdef cppclass Tagger:
+        Tagger() except +
+        int open(string) except +
+        int open(const void*, size_t) except +
+        void close() except +
+        StringList labels() except +
+        StringList tag(ItemSequence) except +
+        void set(ItemSequence) except +
+        StringList viterbi() except +
+        double probability(StringList) except +
+        double marginal(string, int) except +
+        void dump_transitions(int) except +
+        void dump_states(int) except +
```

## chaine/_core/liblbfgs/COPYING

 * *Ordering differences only*

```diff
@@ -1,22 +1,22 @@
-The MIT License
-
-Copyright (c) 1990 Jorge Nocedal
-Copyright (c) 2007-2010 Naoaki Okazaki
-
-Permission is hereby granted, free of charge, to any person obtaining a
-copy of this software and associated documentation files (the "Software"),
-to deal in the Software without restriction, including without limitation
-the rights to use, copy, modify, merge, publish, distribute, sublicense,
-and/or sell copies of the Software, and to permit persons to whom the
-Software is furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in
-all copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
-THE SOFTWARE.
+The MIT License
+
+Copyright (c) 1990 Jorge Nocedal
+Copyright (c) 2007-2010 Naoaki Okazaki
+
+Permission is hereby granted, free of charge, to any person obtaining a
+copy of this software and associated documentation files (the "Software"),
+to deal in the Software without restriction, including without limitation
+the rights to use, copy, modify, merge, publish, distribute, sublicense,
+and/or sell copies of the Software, and to permit persons to whom the
+Software is furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+THE SOFTWARE.
```

## chaine/_core/liblbfgs/include/lbfgs.h

 * *Ordering differences only*

```diff
@@ -1,745 +1,745 @@
-/*
- *      C library of Limited memory BFGS (L-BFGS).
- *
- * Copyright (c) 1990, Jorge Nocedal
- * Copyright (c) 2007-2010 Naoaki Okazaki
- * All rights reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to deal
- * in the Software without restriction, including without limitation the rights
- * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
- * copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
- * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
- * THE SOFTWARE.
- */
-
-/* $Id$ */
-
-#ifndef __LBFGS_H__
-#define __LBFGS_H__
-
-#ifdef __cplusplus
-extern "C"
-{
-#endif /*__cplusplus*/
-
-/*
- * The default precision of floating point values is 64bit (double).
- */
-#ifndef LBFGS_FLOAT
-#define LBFGS_FLOAT 64
-#endif /*LBFGS_FLOAT*/
-
-/*
- * Activate optimization routines for IEEE754 floating point values.
- */
-#ifndef LBFGS_IEEE_FLOAT
-#define LBFGS_IEEE_FLOAT 1
-#endif /*LBFGS_IEEE_FLOAT*/
-
-#if LBFGS_FLOAT == 32
-  typedef float lbfgsfloatval_t;
-
-#elif LBFGS_FLOAT == 64
-typedef double lbfgsfloatval_t;
-
-#else
-#error "libLBFGS supports single (float; LBFGS_FLOAT = 32) or double (double; LBFGS_FLOAT=64) precision only."
-
-#endif
-
-  /**
-   * \addtogroup liblbfgs_api libLBFGS API
-   * @{
-   *
-   *  The libLBFGS API.
-   */
-
-  /**
-   * Return values of lbfgs().
-   *
-   *  Roughly speaking, a negative value indicates an error.
-   */
-  enum
-  {
-    /** L-BFGS reaches convergence. */
-    LBFGS_SUCCESS = 0,
-    LBFGS_CONVERGENCE = 0,
-    LBFGS_STOP,
-    /** The initial variables already minimize the objective function. */
-    LBFGS_ALREADY_MINIMIZED,
-
-    /** Unknown error. */
-    LBFGSERR_UNKNOWNERROR = -1024,
-    /** Logic error. */
-    LBFGSERR_LOGICERROR,
-    /** Insufficient memory. */
-    LBFGSERR_OUTOFMEMORY,
-    /** The minimization process has been canceled. */
-    LBFGSERR_CANCELED,
-    /** Invalid number of variables specified. */
-    LBFGSERR_INVALID_N,
-    /** Invalid number of variables (for SSE) specified. */
-    LBFGSERR_INVALID_N_SSE,
-    /** The array x must be aligned to 16 (for SSE). */
-    LBFGSERR_INVALID_X_SSE,
-    /** Invalid parameter lbfgs_parameter_t::epsilon specified. */
-    LBFGSERR_INVALID_EPSILON,
-    /** Invalid parameter lbfgs_parameter_t::past specified. */
-    LBFGSERR_INVALID_TESTPERIOD,
-    /** Invalid parameter lbfgs_parameter_t::delta specified. */
-    LBFGSERR_INVALID_DELTA,
-    /** Invalid parameter lbfgs_parameter_t::linesearch specified. */
-    LBFGSERR_INVALID_LINESEARCH,
-    /** Invalid parameter lbfgs_parameter_t::max_step specified. */
-    LBFGSERR_INVALID_MINSTEP,
-    /** Invalid parameter lbfgs_parameter_t::max_step specified. */
-    LBFGSERR_INVALID_MAXSTEP,
-    /** Invalid parameter lbfgs_parameter_t::ftol specified. */
-    LBFGSERR_INVALID_FTOL,
-    /** Invalid parameter lbfgs_parameter_t::wolfe specified. */
-    LBFGSERR_INVALID_WOLFE,
-    /** Invalid parameter lbfgs_parameter_t::gtol specified. */
-    LBFGSERR_INVALID_GTOL,
-    /** Invalid parameter lbfgs_parameter_t::xtol specified. */
-    LBFGSERR_INVALID_XTOL,
-    /** Invalid parameter lbfgs_parameter_t::max_linesearch specified. */
-    LBFGSERR_INVALID_MAXLINESEARCH,
-    /** Invalid parameter lbfgs_parameter_t::orthantwise_c specified. */
-    LBFGSERR_INVALID_ORTHANTWISE,
-    /** Invalid parameter lbfgs_parameter_t::orthantwise_start specified. */
-    LBFGSERR_INVALID_ORTHANTWISE_START,
-    /** Invalid parameter lbfgs_parameter_t::orthantwise_end specified. */
-    LBFGSERR_INVALID_ORTHANTWISE_END,
-    /** The line-search step went out of the interval of uncertainty. */
-    LBFGSERR_OUTOFINTERVAL,
-    /** A logic error occurred; alternatively, the interval of uncertainty
-        became too small. */
-    LBFGSERR_INCORRECT_TMINMAX,
-    /** A rounding error occurred; alternatively, no line-search step
-        satisfies the sufficient decrease and curvature conditions. */
-    LBFGSERR_ROUNDING_ERROR,
-    /** The line-search step became smaller than lbfgs_parameter_t::min_step. */
-    LBFGSERR_MINIMUMSTEP,
-    /** The line-search step became larger than lbfgs_parameter_t::max_step. */
-    LBFGSERR_MAXIMUMSTEP,
-    /** The line-search routine reaches the maximum number of evaluations. */
-    LBFGSERR_MAXIMUMLINESEARCH,
-    /** The algorithm routine reaches the maximum number of iterations. */
-    LBFGSERR_MAXIMUMITERATION,
-    /** Relative width of the interval of uncertainty is at most
-        lbfgs_parameter_t::xtol. */
-    LBFGSERR_WIDTHTOOSMALL,
-    /** A logic error (negative line-search step) occurred. */
-    LBFGSERR_INVALIDPARAMETERS,
-    /** The current search direction increases the objective function value. */
-    LBFGSERR_INCREASEGRADIENT,
-  };
-
-  /**
-   * Line search algorithms.
-   */
-  enum
-  {
-    /** The default algorithm (MoreThuente method). */
-    LBFGS_LINESEARCH_DEFAULT = 0,
-    /** MoreThuente method proposd by More and Thuente. */
-    LBFGS_LINESEARCH_MORETHUENTE = 0,
-    /**
-     * Backtracking method with the Armijo condition.
-     *  The backtracking method finds the step length such that it satisfies
-     *  the sufficient decrease (Armijo) condition,
-     *    - f(x + a * d) <= f(x) + lbfgs_parameter_t::ftol * a * g(x)^T d,
-     *
-     *  where x is the current point, d is the current search direction, and
-     *  a is the step length.
-     */
-    LBFGS_LINESEARCH_BACKTRACKING_ARMIJO = 1,
-    /** The backtracking method with the defualt (regular Wolfe) condition. */
-    LBFGS_LINESEARCH_BACKTRACKING = 2,
-    /**
-     * Backtracking method with regular Wolfe condition.
-     *  The backtracking method finds the step length such that it satisfies
-     *  both the Armijo condition (LBFGS_LINESEARCH_BACKTRACKING_ARMIJO)
-     *  and the curvature condition,
-     *    - g(x + a * d)^T d >= lbfgs_parameter_t::wolfe * g(x)^T d,
-     *
-     *  where x is the current point, d is the current search direction, and
-     *  a is the step length.
-     */
-    LBFGS_LINESEARCH_BACKTRACKING_WOLFE = 2,
-    /**
-     * Backtracking method with strong Wolfe condition.
-     *  The backtracking method finds the step length such that it satisfies
-     *  both the Armijo condition (LBFGS_LINESEARCH_BACKTRACKING_ARMIJO)
-     *  and the following condition,
-     *    - |g(x + a * d)^T d| <= lbfgs_parameter_t::wolfe * |g(x)^T d|,
-     *
-     *  where x is the current point, d is the current search direction, and
-     *  a is the step length.
-     */
-    LBFGS_LINESEARCH_BACKTRACKING_STRONG_WOLFE = 3,
-  };
-
-  /**
-   * L-BFGS optimization parameters.
-   *  Call lbfgs_parameter_init() function to initialize parameters to the
-   *  default values.
-   */
-  typedef struct
-  {
-    /**
-     * The number of corrections to approximate the inverse hessian matrix.
-     *  The L-BFGS routine stores the computation results of previous \ref m
-     *  iterations to approximate the inverse hessian matrix of the current
-     *  iteration. This parameter controls the size of the limited memories
-     *  (corrections). The default value is \c 6. Values less than \c 3 are
-     *  not recommended. Large values will result in excessive computing time.
-     */
-    int m;
-
-    /**
-     * Epsilon for convergence test.
-     *  This parameter determines the accuracy with which the solution is to
-     *  be found. A minimization terminates when
-     *      ||g|| < \ref epsilon * max(1, ||x||),
-     *  where ||.|| denotes the Euclidean (L2) norm. The default value is
-     *  \c 1e-5.
-     */
-    lbfgsfloatval_t epsilon;
-
-    /**
-     * Distance for delta-based convergence test.
-     *  This parameter determines the distance, in iterations, to compute
-     *  the rate of decrease of the objective function. If the value of this
-     *  parameter is zero, the library does not perform the delta-based
-     *  convergence test. The default value is \c 0.
-     */
-    int past;
-
-    /**
-     * Delta for convergence test.
-     *  This parameter determines the minimum rate of decrease of the
-     *  objective function. The library stops iterations when the
-     *  following condition is met:
-     *      (f' - f) / f < \ref delta,
-     *  where f' is the objective value of \ref past iterations ago, and f is
-     *  the objective value of the current iteration.
-     *  The default value is \c 0.
-     */
-    lbfgsfloatval_t delta;
-
-    /**
-     * The maximum number of iterations.
-     *  The lbfgs() function terminates an optimization process with
-     *  ::LBFGSERR_MAXIMUMITERATION status code when the iteration count
-     *  exceedes this parameter. Setting this parameter to zero continues an
-     *  optimization process until a convergence or error. The default value
-     *  is \c 0.
-     */
-    int max_iterations;
-
-    /**
-     * The line search algorithm.
-     *  This parameter specifies a line search algorithm to be used by the
-     *  L-BFGS routine.
-     */
-    int linesearch;
-
-    /**
-     * The maximum number of trials for the line search.
-     *  This parameter controls the number of function and gradients evaluations
-     *  per iteration for the line search routine. The default value is \c 20.
-     */
-    int max_linesearch;
-
-    /**
-     * The minimum step of the line search routine.
-     *  The default value is \c 1e-20. This value need not be modified unless
-     *  the exponents are too large for the machine being used, or unless the
-     *  problem is extremely badly scaled (in which case the exponents should
-     *  be increased).
-     */
-    lbfgsfloatval_t min_step;
-
-    /**
-     * The maximum step of the line search.
-     *  The default value is \c 1e+20. This value need not be modified unless
-     *  the exponents are too large for the machine being used, or unless the
-     *  problem is extremely badly scaled (in which case the exponents should
-     *  be increased).
-     */
-    lbfgsfloatval_t max_step;
-
-    /**
-     * A parameter to control the accuracy of the line search routine.
-     *  The default value is \c 1e-4. This parameter should be greater
-     *  than zero and smaller than \c 0.5.
-     */
-    lbfgsfloatval_t ftol;
-
-    /**
-     * A coefficient for the Wolfe condition.
-     *  This parameter is valid only when the backtracking line-search
-     *  algorithm is used with the Wolfe condition,
-     *  ::LBFGS_LINESEARCH_BACKTRACKING_STRONG_WOLFE or
-     *  ::LBFGS_LINESEARCH_BACKTRACKING_WOLFE .
-     *  The default value is \c 0.9. This parameter should be greater
-     *  the \ref ftol parameter and smaller than \c 1.0.
-     */
-    lbfgsfloatval_t wolfe;
-
-    /**
-     * A parameter to control the accuracy of the line search routine.
-     *  The default value is \c 0.9. If the function and gradient
-     *  evaluations are inexpensive with respect to the cost of the
-     *  iteration (which is sometimes the case when solving very large
-     *  problems) it may be advantageous to set this parameter to a small
-     *  value. A typical small value is \c 0.1. This parameter shuold be
-     *  greater than the \ref ftol parameter (\c 1e-4) and smaller than
-     *  \c 1.0.
-     */
-    lbfgsfloatval_t gtol;
-
-    /**
-     * The machine precision for floating-point values.
-     *  This parameter must be a positive value set by a client program to
-     *  estimate the machine precision. The line search routine will terminate
-     *  with the status code (::LBFGSERR_ROUNDING_ERROR) if the relative width
-     *  of the interval of uncertainty is less than this parameter.
-     */
-    lbfgsfloatval_t xtol;
-
-    /**
-     * Coeefficient for the L1 norm of variables.
-     *  This parameter should be set to zero for standard minimization
-     *  problems. Setting this parameter to a positive value activates
-     *  Orthant-Wise Limited-memory Quasi-Newton (OWL-QN) method, which
-     *  minimizes the objective function F(x) combined with the L1 norm |x|
-     *  of the variables, {F(x) + C |x|}. This parameter is the coeefficient
-     *  for the |x|, i.e., C. As the L1 norm |x| is not differentiable at
-     *  zero, the library modifies function and gradient evaluations from
-     *  a client program suitably; a client program thus have only to return
-     *  the function value F(x) and gradients G(x) as usual. The default value
-     *  is zero.
-     */
-    lbfgsfloatval_t orthantwise_c;
-
-    /**
-     * Start index for computing L1 norm of the variables.
-     *  This parameter is valid only for OWL-QN method
-     *  (i.e., \ref orthantwise_c != 0). This parameter b (0 <= b < N)
-     *  specifies the index number from which the library computes the
-     *  L1 norm of the variables x,
-     *      |x| := |x_{b}| + |x_{b+1}| + ... + |x_{N}| .
-     *  In other words, variables x_1, ..., x_{b-1} are not used for
-     *  computing the L1 norm. Setting b (0 < b < N), one can protect
-     *  variables, x_1, ..., x_{b-1} (e.g., a bias term of logistic
-     *  regression) from being regularized. The default value is zero.
-     */
-    int orthantwise_start;
-
-    /**
-     * End index for computing L1 norm of the variables.
-     *  This parameter is valid only for OWL-QN method
-     *  (i.e., \ref orthantwise_c != 0). This parameter e (0 < e <= N)
-     *  specifies the index number at which the library stops computing the
-     *  L1 norm of the variables x,
-     */
-    int orthantwise_end;
-  } lbfgs_parameter_t;
-
-  /**
-   * Callback interface to provide objective function and gradient evaluations.
-   *
-   *  The lbfgs() function call this function to obtain the values of objective
-   *  function and its gradients when needed. A client program must implement
-   *  this function to evaluate the values of the objective function and its
-   *  gradients, given current values of variables.
-   *
-   *  @param  instance    The user data sent for lbfgs() function by the client.
-   *  @param  x           The current values of variables.
-   *  @param  g           The gradient vector. The callback function must compute
-   *                      the gradient values for the current variables.
-   *  @param  n           The number of variables.
-   *  @param  step        The current step of the line search routine.
-   *  @retval lbfgsfloatval_t The value of the objective function for the current
-   *                          variables.
-   */
-  typedef lbfgsfloatval_t (*lbfgs_evaluate_t)(
-      void *instance,
-      const lbfgsfloatval_t *x,
-      lbfgsfloatval_t *g,
-      const int n,
-      const lbfgsfloatval_t step);
-
-  /**
-   * Callback interface to receive the progress of the optimization process.
-   *
-   *  The lbfgs() function call this function for each iteration. Implementing
-   *  this function, a client program can store or display the current progress
-   *  of the optimization process.
-   *
-   *  @param  instance    The user data sent for lbfgs() function by the client.
-   *  @param  x           The current values of variables.
-   *  @param  g           The current gradient values of variables.
-   *  @param  fx          The current value of the objective function.
-   *  @param  xnorm       The Euclidean norm of the variables.
-   *  @param  gnorm       The Euclidean norm of the gradients.
-   *  @param  step        The line-search step used for this iteration.
-   *  @param  n           The number of variables.
-   *  @param  k           The iteration count.
-   *  @param  ls          The number of evaluations called for this iteration.
-   *  @retval int         Zero to continue the optimization process. Returning a
-   *                      non-zero value will cancel the optimization process.
-   */
-  typedef int (*lbfgs_progress_t)(
-      void *instance,
-      const lbfgsfloatval_t *x,
-      const lbfgsfloatval_t *g,
-      const lbfgsfloatval_t fx,
-      const lbfgsfloatval_t xnorm,
-      const lbfgsfloatval_t gnorm,
-      const lbfgsfloatval_t step,
-      int n,
-      int k,
-      int ls);
-
-  /*
-A user must implement a function compatible with ::lbfgs_evaluate_t (evaluation
-callback) and pass the pointer to the callback function to lbfgs() arguments.
-Similarly, a user can implement a function compatible with ::lbfgs_progress_t
-(progress callback) to obtain the current progress (e.g., variables, function
-value, ||G||, etc) and to cancel the iteration process if necessary.
-Implementation of a progress callback is optional: a user can pass \c NULL if
-progress notification is not necessary.
-
-In addition, a user must preserve two requirements:
-    - The number of variables must be multiples of 16 (this is not 4).
-    - The memory block of variable array ::x must be aligned to 16.
-
-This algorithm terminates an optimization
-when:
-
-    ||G|| < \epsilon \cdot \max(1, ||x||) .
-
-In this formula, ||.|| denotes the Euclidean norm.
-*/
-
-  /**
-   * Start a L-BFGS optimization.
-   *
-   *  @param  n           The number of variables.
-   *  @param  x           The array of variables. A client program can set
-   *                      default values for the optimization and receive the
-   *                      optimization result through this array. This array
-   *                      must be allocated by ::lbfgs_malloc function
-   *                      for libLBFGS built with SSE/SSE2 optimization routine
-   *                      enabled. The library built without SSE/SSE2
-   *                      optimization does not have such a requirement.
-   *  @param  ptr_fx      The pointer to the variable that receives the final
-   *                      value of the objective function for the variables.
-   *                      This argument can be set to \c NULL if the final
-   *                      value of the objective function is unnecessary.
-   *  @param  proc_evaluate   The callback function to provide function and
-   *                          gradient evaluations given a current values of
-   *                          variables. A client program must implement a
-   *                          callback function compatible with \ref
-   *                          lbfgs_evaluate_t and pass the pointer to the
-   *                          callback function.
-   *  @param  proc_progress   The callback function to receive the progress
-   *                          (the number of iterations, the current value of
-   *                          the objective function) of the minimization
-   *                          process. This argument can be set to \c NULL if
-   *                          a progress report is unnecessary.
-   *  @param  instance    A user data for the client program. The callback
-   *                      functions will receive the value of this argument.
-   *  @param  param       The pointer to a structure representing parameters for
-   *                      L-BFGS optimization. A client program can set this
-   *                      parameter to \c NULL to use the default parameters.
-   *                      Call lbfgs_parameter_init() function to fill a
-   *                      structure with the default values.
-   *  @retval int         The status code. This function returns zero if the
-   *                      minimization process terminates without an error. A
-   *                      non-zero value indicates an error.
-   */
-  int lbfgs(
-      int n,
-      lbfgsfloatval_t *x,
-      lbfgsfloatval_t *ptr_fx,
-      lbfgs_evaluate_t proc_evaluate,
-      lbfgs_progress_t proc_progress,
-      void *instance,
-      lbfgs_parameter_t *param);
-
-  /**
-   * Initialize L-BFGS parameters to the default values.
-   *
-   *  Call this function to fill a parameter structure with the default values
-   *  and overwrite parameter values if necessary.
-   *
-   *  @param  param       The pointer to the parameter structure.
-   */
-  void lbfgs_parameter_init(lbfgs_parameter_t *param);
-
-  /**
-   * Allocate an array for variables.
-   *
-   *  This function allocates an array of variables for the convenience of
-   *  ::lbfgs function; the function has a requreiemt for a variable array
-   *  when libLBFGS is built with SSE/SSE2 optimization routines. A user does
-   *  not have to use this function for libLBFGS built without SSE/SSE2
-   *  optimization.
-   *
-   *  @param  n           The number of variables.
-   */
-  lbfgsfloatval_t *lbfgs_malloc(int n);
-
-  /**
-   * Free an array of variables.
-   *
-   *  @param  x           The array of variables allocated by ::lbfgs_malloc
-   *                      function.
-   */
-  void lbfgs_free(lbfgsfloatval_t *x);
-
-  /** @} */
-
-#ifdef __cplusplus
-}
-#endif /*__cplusplus*/
-
-/**
-@mainpage libLBFGS: a library of Limited-memory Broyden-Fletcher-Goldfarb-Shanno (L-BFGS)
-
-@section intro Introduction
-
-This library is a C port of the implementation of Limited-memory
-Broyden-Fletcher-Goldfarb-Shanno (L-BFGS) method written by Jorge Nocedal.
-The original FORTRAN source code is available at:
-http://www.ece.northwestern.edu/~nocedal/lbfgs.html
-
-The L-BFGS method solves the unconstrainted minimization problem,
-
-<pre>
-    minimize F(x), x = (x1, x2, ..., xN),
-</pre>
-
-only if the objective function F(x) and its gradient G(x) are computable. The
-well-known Newton's method requires computation of the inverse of the hessian
-matrix of the objective function. However, the computational cost for the
-inverse hessian matrix is expensive especially when the objective function
-takes a large number of variables. The L-BFGS method iteratively finds a
-minimizer by approximating the inverse hessian matrix by information from last
-m iterations. This innovation saves the memory storage and computational time
-drastically for large-scaled problems.
-
-Among the various ports of L-BFGS, this library provides several features:
-- <b>Optimization with L1-norm (Orthant-Wise Limited-memory Quasi-Newton
-  (OWL-QN) method)</b>:
-  In addition to standard minimization problems, the library can minimize
-  a function F(x) combined with L1-norm |x| of the variables,
-  {F(x) + C |x|}, where C is a constant scalar parameter. This feature is
-  useful for estimating parameters of sparse log-linear models (e.g.,
-  logistic regression and maximum entropy) with L1-regularization (or
-  Laplacian prior).
-- <b>Clean C code</b>:
-  Unlike C codes generated automatically by f2c (Fortran 77 into C converter),
-  this port includes changes based on my interpretations, improvements,
-  optimizations, and clean-ups so that the ported code would be well-suited
-  for a C code. In addition to comments inherited from the original code,
-  a number of comments were added through my interpretations.
-- <b>Callback interface</b>:
-  The library receives function and gradient values via a callback interface.
-  The library also notifies the progress of the optimization by invoking a
-  callback function. In the original implementation, a user had to set
-  function and gradient values every time the function returns for obtaining
-  updated values.
-- <b>Thread safe</b>:
-  The library is thread-safe, which is the secondary gain from the callback
-  interface.
-- <b>Cross platform.</b> The source code can be compiled on Microsoft Visual
-  Studio 2010, GNU C Compiler (gcc), etc.
-- <b>Configurable precision</b>: A user can choose single-precision (float)
-  or double-precision (double) accuracy by changing ::LBFGS_FLOAT macro.
-- <b>SSE/SSE2 optimization</b>:
-  This library includes SSE/SSE2 optimization (written in compiler intrinsics)
-  for vector arithmetic operations on Intel/AMD processors. The library uses
-  SSE for float values and SSE2 for double values. The SSE/SSE2 optimization
-  routine is disabled by default.
-
-This library is used by:
-- <a href="http://www.chokkan.org/software/crfsuite/">CRFsuite: A fast implementation of Conditional Random Fields (CRFs)</a>
-- <a href="http://www.chokkan.org/software/classias/">Classias: A collection of machine-learning algorithms for classification</a>
-- <a href="http://www.public.iastate.edu/~gdancik/mlegp/">mlegp: an R package for maximum likelihood estimates for Gaussian processes</a>
-- <a href="http://infmath.uibk.ac.at/~matthiasf/imaging2/">imaging2: the imaging2 class library</a>
-
-@section download Download
-
-- <a href="https://github.com/downloads/chokkan/liblbfgs/liblbfgs-1.10.tar.gz">Source code</a>
-- <a href="https://github.com/chokkan/liblbfgs">GitHub repository</a>
-
-libLBFGS is distributed under the term of the
-<a href="http://opensource.org/licenses/mit-license.php">MIT license</a>.
-
-@section modules Third-party modules
-- <a href="http://cran.r-project.org/web/packages/lbfgs/index.html">lbfgs: Limited-memory BFGS Optimization (a wrapper for R)</a> maintained by Antonio Coppola.
-- <a href="http://search.cpan.org/~laye/Algorithm-LBFGS-0.16/">Algorithm::LBFGS - Perl extension for L-BFGS</a> maintained by Lei Sun.
-- <a href="http://www.cs.kuleuven.be/~bernd/yap-lbfgs/">YAP-LBFGS (an interface to call libLBFGS from YAP Prolog)</a> maintained by Bernd Gutmann.
-
-@section changelog History
-- Version 1.10 (2010-12-22):
-    - Fixed compiling errors on Mac OS X; this patch was kindly submitted by
-      Nic Schraudolph.
-    - Reduced compiling warnings on Mac OS X; this patch was kindly submitted
-      by Tamas Nepusz.
-    - Replaced memalign() with posix_memalign().
-    - Updated solution and project files for Microsoft Visual Studio 2010.
-- Version 1.9 (2010-01-29):
-    - Fixed a mistake in checking the validity of the parameters "ftol" and
-      "wolfe"; this was discovered by Kevin S. Van Horn.
-- Version 1.8 (2009-07-13):
-    - Accepted the patch submitted by Takashi Imamichi;
-      the backtracking method now has three criteria for choosing the step
-      length:
-        - ::LBFGS_LINESEARCH_BACKTRACKING_ARMIJO: sufficient decrease (Armijo)
-          condition only
-        - ::LBFGS_LINESEARCH_BACKTRACKING_WOLFE: regular Wolfe condition
-          (sufficient decrease condition + curvature condition)
-        - ::LBFGS_LINESEARCH_BACKTRACKING_STRONG_WOLFE: strong Wolfe condition
-    - Updated the documentation to explain the above three criteria.
-- Version 1.7 (2009-02-28):
-    - Improved OWL-QN routines for stability.
-    - Removed the support of OWL-QN method in MoreThuente algorithm because
-      it accidentally fails in early stages of iterations for some objectives.
-      Because of this change, <b>the OW-LQN method must be used with the
-      backtracking algorithm (::LBFGS_LINESEARCH_BACKTRACKING)</b>, or the
-      library returns ::LBFGSERR_INVALID_LINESEARCH.
-    - Renamed line search algorithms as follows:
-        - ::LBFGS_LINESEARCH_BACKTRACKING: regular Wolfe condition.
-        - ::LBFGS_LINESEARCH_BACKTRACKING_LOOSE: regular Wolfe condition.
-        - ::LBFGS_LINESEARCH_BACKTRACKING_STRONG: strong Wolfe condition.
-    - Source code clean-up.
-- Version 1.6 (2008-11-02):
-    - Improved line-search algorithm with strong Wolfe condition, which was
-      contributed by Takashi Imamichi. This routine is now default for
-      ::LBFGS_LINESEARCH_BACKTRACKING. The previous line search algorithm
-      with regular Wolfe condition is still available as
-      ::LBFGS_LINESEARCH_BACKTRACKING_LOOSE.
-    - Configurable stop index for L1-norm computation. A member variable
-      ::lbfgs_parameter_t::orthantwise_end was added to specify the index
-      number at which the library stops computing the L1 norm of the
-      variables. This is useful to prevent some variables from being
-      regularized by the OW-LQN method.
-    - A sample program written in C++ (sample/sample.cpp).
-- Version 1.5 (2008-07-10):
-    - Configurable starting index for L1-norm computation. A member variable
-      ::lbfgs_parameter_t::orthantwise_start was added to specify the index
-      number from which the library computes the L1 norm of the variables.
-      This is useful to prevent some variables from being regularized by the
-      OWL-QN method.
-    - Fixed a zero-division error when the initial variables have already
-      been a minimizer (reported by Takashi Imamichi). In this case, the
-      library returns ::LBFGS_ALREADY_MINIMIZED status code.
-    - Defined ::LBFGS_SUCCESS status code as zero; removed unused constants,
-      LBFGSFALSE and LBFGSTRUE.
-    - Fixed a compile error in an implicit down-cast.
-- Version 1.4 (2008-04-25):
-    - Configurable line search algorithms. A member variable
-      ::lbfgs_parameter_t::linesearch was added to choose either MoreThuente
-      method (::LBFGS_LINESEARCH_MORETHUENTE) or backtracking algorithm
-      (::LBFGS_LINESEARCH_BACKTRACKING).
-    - Fixed a bug: the previous version did not compute psuedo-gradients
-      properly in the line search routines for OWL-QN. This bug might quit
-      an iteration process too early when the OWL-QN routine was activated
-      (0 < ::lbfgs_parameter_t::orthantwise_c).
-    - Configure script for POSIX environments.
-    - SSE/SSE2 optimizations with GCC.
-    - New functions ::lbfgs_malloc and ::lbfgs_free to use SSE/SSE2 routines
-      transparently. It is uncessary to use these functions for libLBFGS built
-      without SSE/SSE2 routines; you can still use any memory allocators if
-      SSE/SSE2 routines are disabled in libLBFGS.
-- Version 1.3 (2007-12-16):
-    - An API change. An argument was added to lbfgs() function to receive the
-      final value of the objective function. This argument can be set to
-      \c NULL if the final value is unnecessary.
-    - Fixed a null-pointer bug in the sample code (reported by Takashi Imamichi).
-    - Added build scripts for Microsoft Visual Studio 2005 and GCC.
-    - Added README file.
-- Version 1.2 (2007-12-13):
-    - Fixed a serious bug in orthant-wise L-BFGS.
-      An important variable was used without initialization.
-- Version 1.1 (2007-12-01):
-    - Implemented orthant-wise L-BFGS.
-    - Implemented lbfgs_parameter_init() function.
-    - Fixed several bugs.
-    - API documentation.
-- Version 1.0 (2007-09-20):
-    - Initial release.
-
-@section api Documentation
-
-- @ref liblbfgs_api "libLBFGS API"
-
-@section sample Sample code
-
-@include sample.c
-
-@section ack Acknowledgements
-
-The L-BFGS algorithm is described in:
-    - Jorge Nocedal.
-      Updating Quasi-Newton Matrices with Limited Storage.
-      <i>Mathematics of Computation</i>, Vol. 35, No. 151, pp. 773--782, 1980.
-    - Dong C. Liu and Jorge Nocedal.
-      On the limited memory BFGS method for large scale optimization.
-      <i>Mathematical Programming</i> B, Vol. 45, No. 3, pp. 503-528, 1989.
-
-The line search algorithms used in this implementation are described in:
-    - John E. Dennis and Robert B. Schnabel.
-      <i>Numerical Methods for Unconstrained Optimization and Nonlinear
-      Equations</i>, Englewood Cliffs, 1983.
-    - Jorge J. More and David J. Thuente.
-      Line search algorithm with guaranteed sufficient decrease.
-      <i>ACM Transactions on Mathematical Software (TOMS)</i>, Vol. 20, No. 3,
-      pp. 286-307, 1994.
-
-This library also implements Orthant-Wise Limited-memory Quasi-Newton (OWL-QN)
-method presented in:
-    - Galen Andrew and Jianfeng Gao.
-      Scalable training of L1-regularized log-linear models.
-      In <i>Proceedings of the 24th International Conference on Machine
-      Learning (ICML 2007)</i>, pp. 33-40, 2007.
-
-Special thanks go to:
-    - Yoshimasa Tsuruoka and Daisuke Okanohara for technical information about
-      OWL-QN
-    - Takashi Imamichi for the useful enhancements of the backtracking method
-    - Kevin S. Van Horn, Nic Schraudolph, and Tamas Nepusz for bug fixes
-
-Finally I would like to thank the original author, Jorge Nocedal, who has been
-distributing the effieicnt and explanatory implementation in an open source
-licence.
-
-@section reference Reference
-
-- <a href="http://www.ece.northwestern.edu/~nocedal/lbfgs.html">L-BFGS</a> by Jorge Nocedal.
-- <a href="http://research.microsoft.com/en-us/downloads/b1eb1016-1738-4bd5-83a9-370c9d498a03/default.aspx">Orthant-Wise Limited-memory Quasi-Newton Optimizer for L1-regularized Objectives</a> by Galen Andrew.
-- <a href="http://chasen.org/~taku/software/misc/lbfgs/">C port (via f2c)</a> by Taku Kudo.
-- <a href="http://www.alglib.net/optimization/lbfgs.php">C#/C++/Delphi/VisualBasic6 port</a> in ALGLIB.
-- <a href="http://cctbx.sourceforge.net/">Computational Crystallography Toolbox</a> includes
-  <a href="http://cctbx.sourceforge.net/current_cvs/c_plus_plus/namespacescitbx_1_1lbfgs.html">scitbx::lbfgs</a>.
-*/
-
-#endif /*__LBFGS_H__*/
+/*
+ *      C library of Limited memory BFGS (L-BFGS).
+ *
+ * Copyright (c) 1990, Jorge Nocedal
+ * Copyright (c) 2007-2010 Naoaki Okazaki
+ * All rights reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+
+/* $Id$ */
+
+#ifndef __LBFGS_H__
+#define __LBFGS_H__
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif /*__cplusplus*/
+
+/*
+ * The default precision of floating point values is 64bit (double).
+ */
+#ifndef LBFGS_FLOAT
+#define LBFGS_FLOAT 64
+#endif /*LBFGS_FLOAT*/
+
+/*
+ * Activate optimization routines for IEEE754 floating point values.
+ */
+#ifndef LBFGS_IEEE_FLOAT
+#define LBFGS_IEEE_FLOAT 1
+#endif /*LBFGS_IEEE_FLOAT*/
+
+#if LBFGS_FLOAT == 32
+  typedef float lbfgsfloatval_t;
+
+#elif LBFGS_FLOAT == 64
+typedef double lbfgsfloatval_t;
+
+#else
+#error "libLBFGS supports single (float; LBFGS_FLOAT = 32) or double (double; LBFGS_FLOAT=64) precision only."
+
+#endif
+
+  /**
+   * \addtogroup liblbfgs_api libLBFGS API
+   * @{
+   *
+   *  The libLBFGS API.
+   */
+
+  /**
+   * Return values of lbfgs().
+   *
+   *  Roughly speaking, a negative value indicates an error.
+   */
+  enum
+  {
+    /** L-BFGS reaches convergence. */
+    LBFGS_SUCCESS = 0,
+    LBFGS_CONVERGENCE = 0,
+    LBFGS_STOP,
+    /** The initial variables already minimize the objective function. */
+    LBFGS_ALREADY_MINIMIZED,
+
+    /** Unknown error. */
+    LBFGSERR_UNKNOWNERROR = -1024,
+    /** Logic error. */
+    LBFGSERR_LOGICERROR,
+    /** Insufficient memory. */
+    LBFGSERR_OUTOFMEMORY,
+    /** The minimization process has been canceled. */
+    LBFGSERR_CANCELED,
+    /** Invalid number of variables specified. */
+    LBFGSERR_INVALID_N,
+    /** Invalid number of variables (for SSE) specified. */
+    LBFGSERR_INVALID_N_SSE,
+    /** The array x must be aligned to 16 (for SSE). */
+    LBFGSERR_INVALID_X_SSE,
+    /** Invalid parameter lbfgs_parameter_t::epsilon specified. */
+    LBFGSERR_INVALID_EPSILON,
+    /** Invalid parameter lbfgs_parameter_t::past specified. */
+    LBFGSERR_INVALID_TESTPERIOD,
+    /** Invalid parameter lbfgs_parameter_t::delta specified. */
+    LBFGSERR_INVALID_DELTA,
+    /** Invalid parameter lbfgs_parameter_t::linesearch specified. */
+    LBFGSERR_INVALID_LINESEARCH,
+    /** Invalid parameter lbfgs_parameter_t::max_step specified. */
+    LBFGSERR_INVALID_MINSTEP,
+    /** Invalid parameter lbfgs_parameter_t::max_step specified. */
+    LBFGSERR_INVALID_MAXSTEP,
+    /** Invalid parameter lbfgs_parameter_t::ftol specified. */
+    LBFGSERR_INVALID_FTOL,
+    /** Invalid parameter lbfgs_parameter_t::wolfe specified. */
+    LBFGSERR_INVALID_WOLFE,
+    /** Invalid parameter lbfgs_parameter_t::gtol specified. */
+    LBFGSERR_INVALID_GTOL,
+    /** Invalid parameter lbfgs_parameter_t::xtol specified. */
+    LBFGSERR_INVALID_XTOL,
+    /** Invalid parameter lbfgs_parameter_t::max_linesearch specified. */
+    LBFGSERR_INVALID_MAXLINESEARCH,
+    /** Invalid parameter lbfgs_parameter_t::orthantwise_c specified. */
+    LBFGSERR_INVALID_ORTHANTWISE,
+    /** Invalid parameter lbfgs_parameter_t::orthantwise_start specified. */
+    LBFGSERR_INVALID_ORTHANTWISE_START,
+    /** Invalid parameter lbfgs_parameter_t::orthantwise_end specified. */
+    LBFGSERR_INVALID_ORTHANTWISE_END,
+    /** The line-search step went out of the interval of uncertainty. */
+    LBFGSERR_OUTOFINTERVAL,
+    /** A logic error occurred; alternatively, the interval of uncertainty
+        became too small. */
+    LBFGSERR_INCORRECT_TMINMAX,
+    /** A rounding error occurred; alternatively, no line-search step
+        satisfies the sufficient decrease and curvature conditions. */
+    LBFGSERR_ROUNDING_ERROR,
+    /** The line-search step became smaller than lbfgs_parameter_t::min_step. */
+    LBFGSERR_MINIMUMSTEP,
+    /** The line-search step became larger than lbfgs_parameter_t::max_step. */
+    LBFGSERR_MAXIMUMSTEP,
+    /** The line-search routine reaches the maximum number of evaluations. */
+    LBFGSERR_MAXIMUMLINESEARCH,
+    /** The algorithm routine reaches the maximum number of iterations. */
+    LBFGSERR_MAXIMUMITERATION,
+    /** Relative width of the interval of uncertainty is at most
+        lbfgs_parameter_t::xtol. */
+    LBFGSERR_WIDTHTOOSMALL,
+    /** A logic error (negative line-search step) occurred. */
+    LBFGSERR_INVALIDPARAMETERS,
+    /** The current search direction increases the objective function value. */
+    LBFGSERR_INCREASEGRADIENT,
+  };
+
+  /**
+   * Line search algorithms.
+   */
+  enum
+  {
+    /** The default algorithm (MoreThuente method). */
+    LBFGS_LINESEARCH_DEFAULT = 0,
+    /** MoreThuente method proposd by More and Thuente. */
+    LBFGS_LINESEARCH_MORETHUENTE = 0,
+    /**
+     * Backtracking method with the Armijo condition.
+     *  The backtracking method finds the step length such that it satisfies
+     *  the sufficient decrease (Armijo) condition,
+     *    - f(x + a * d) <= f(x) + lbfgs_parameter_t::ftol * a * g(x)^T d,
+     *
+     *  where x is the current point, d is the current search direction, and
+     *  a is the step length.
+     */
+    LBFGS_LINESEARCH_BACKTRACKING_ARMIJO = 1,
+    /** The backtracking method with the defualt (regular Wolfe) condition. */
+    LBFGS_LINESEARCH_BACKTRACKING = 2,
+    /**
+     * Backtracking method with regular Wolfe condition.
+     *  The backtracking method finds the step length such that it satisfies
+     *  both the Armijo condition (LBFGS_LINESEARCH_BACKTRACKING_ARMIJO)
+     *  and the curvature condition,
+     *    - g(x + a * d)^T d >= lbfgs_parameter_t::wolfe * g(x)^T d,
+     *
+     *  where x is the current point, d is the current search direction, and
+     *  a is the step length.
+     */
+    LBFGS_LINESEARCH_BACKTRACKING_WOLFE = 2,
+    /**
+     * Backtracking method with strong Wolfe condition.
+     *  The backtracking method finds the step length such that it satisfies
+     *  both the Armijo condition (LBFGS_LINESEARCH_BACKTRACKING_ARMIJO)
+     *  and the following condition,
+     *    - |g(x + a * d)^T d| <= lbfgs_parameter_t::wolfe * |g(x)^T d|,
+     *
+     *  where x is the current point, d is the current search direction, and
+     *  a is the step length.
+     */
+    LBFGS_LINESEARCH_BACKTRACKING_STRONG_WOLFE = 3,
+  };
+
+  /**
+   * L-BFGS optimization parameters.
+   *  Call lbfgs_parameter_init() function to initialize parameters to the
+   *  default values.
+   */
+  typedef struct
+  {
+    /**
+     * The number of corrections to approximate the inverse hessian matrix.
+     *  The L-BFGS routine stores the computation results of previous \ref m
+     *  iterations to approximate the inverse hessian matrix of the current
+     *  iteration. This parameter controls the size of the limited memories
+     *  (corrections). The default value is \c 6. Values less than \c 3 are
+     *  not recommended. Large values will result in excessive computing time.
+     */
+    int m;
+
+    /**
+     * Epsilon for convergence test.
+     *  This parameter determines the accuracy with which the solution is to
+     *  be found. A minimization terminates when
+     *      ||g|| < \ref epsilon * max(1, ||x||),
+     *  where ||.|| denotes the Euclidean (L2) norm. The default value is
+     *  \c 1e-5.
+     */
+    lbfgsfloatval_t epsilon;
+
+    /**
+     * Distance for delta-based convergence test.
+     *  This parameter determines the distance, in iterations, to compute
+     *  the rate of decrease of the objective function. If the value of this
+     *  parameter is zero, the library does not perform the delta-based
+     *  convergence test. The default value is \c 0.
+     */
+    int past;
+
+    /**
+     * Delta for convergence test.
+     *  This parameter determines the minimum rate of decrease of the
+     *  objective function. The library stops iterations when the
+     *  following condition is met:
+     *      (f' - f) / f < \ref delta,
+     *  where f' is the objective value of \ref past iterations ago, and f is
+     *  the objective value of the current iteration.
+     *  The default value is \c 0.
+     */
+    lbfgsfloatval_t delta;
+
+    /**
+     * The maximum number of iterations.
+     *  The lbfgs() function terminates an optimization process with
+     *  ::LBFGSERR_MAXIMUMITERATION status code when the iteration count
+     *  exceedes this parameter. Setting this parameter to zero continues an
+     *  optimization process until a convergence or error. The default value
+     *  is \c 0.
+     */
+    int max_iterations;
+
+    /**
+     * The line search algorithm.
+     *  This parameter specifies a line search algorithm to be used by the
+     *  L-BFGS routine.
+     */
+    int linesearch;
+
+    /**
+     * The maximum number of trials for the line search.
+     *  This parameter controls the number of function and gradients evaluations
+     *  per iteration for the line search routine. The default value is \c 20.
+     */
+    int max_linesearch;
+
+    /**
+     * The minimum step of the line search routine.
+     *  The default value is \c 1e-20. This value need not be modified unless
+     *  the exponents are too large for the machine being used, or unless the
+     *  problem is extremely badly scaled (in which case the exponents should
+     *  be increased).
+     */
+    lbfgsfloatval_t min_step;
+
+    /**
+     * The maximum step of the line search.
+     *  The default value is \c 1e+20. This value need not be modified unless
+     *  the exponents are too large for the machine being used, or unless the
+     *  problem is extremely badly scaled (in which case the exponents should
+     *  be increased).
+     */
+    lbfgsfloatval_t max_step;
+
+    /**
+     * A parameter to control the accuracy of the line search routine.
+     *  The default value is \c 1e-4. This parameter should be greater
+     *  than zero and smaller than \c 0.5.
+     */
+    lbfgsfloatval_t ftol;
+
+    /**
+     * A coefficient for the Wolfe condition.
+     *  This parameter is valid only when the backtracking line-search
+     *  algorithm is used with the Wolfe condition,
+     *  ::LBFGS_LINESEARCH_BACKTRACKING_STRONG_WOLFE or
+     *  ::LBFGS_LINESEARCH_BACKTRACKING_WOLFE .
+     *  The default value is \c 0.9. This parameter should be greater
+     *  the \ref ftol parameter and smaller than \c 1.0.
+     */
+    lbfgsfloatval_t wolfe;
+
+    /**
+     * A parameter to control the accuracy of the line search routine.
+     *  The default value is \c 0.9. If the function and gradient
+     *  evaluations are inexpensive with respect to the cost of the
+     *  iteration (which is sometimes the case when solving very large
+     *  problems) it may be advantageous to set this parameter to a small
+     *  value. A typical small value is \c 0.1. This parameter shuold be
+     *  greater than the \ref ftol parameter (\c 1e-4) and smaller than
+     *  \c 1.0.
+     */
+    lbfgsfloatval_t gtol;
+
+    /**
+     * The machine precision for floating-point values.
+     *  This parameter must be a positive value set by a client program to
+     *  estimate the machine precision. The line search routine will terminate
+     *  with the status code (::LBFGSERR_ROUNDING_ERROR) if the relative width
+     *  of the interval of uncertainty is less than this parameter.
+     */
+    lbfgsfloatval_t xtol;
+
+    /**
+     * Coeefficient for the L1 norm of variables.
+     *  This parameter should be set to zero for standard minimization
+     *  problems. Setting this parameter to a positive value activates
+     *  Orthant-Wise Limited-memory Quasi-Newton (OWL-QN) method, which
+     *  minimizes the objective function F(x) combined with the L1 norm |x|
+     *  of the variables, {F(x) + C |x|}. This parameter is the coeefficient
+     *  for the |x|, i.e., C. As the L1 norm |x| is not differentiable at
+     *  zero, the library modifies function and gradient evaluations from
+     *  a client program suitably; a client program thus have only to return
+     *  the function value F(x) and gradients G(x) as usual. The default value
+     *  is zero.
+     */
+    lbfgsfloatval_t orthantwise_c;
+
+    /**
+     * Start index for computing L1 norm of the variables.
+     *  This parameter is valid only for OWL-QN method
+     *  (i.e., \ref orthantwise_c != 0). This parameter b (0 <= b < N)
+     *  specifies the index number from which the library computes the
+     *  L1 norm of the variables x,
+     *      |x| := |x_{b}| + |x_{b+1}| + ... + |x_{N}| .
+     *  In other words, variables x_1, ..., x_{b-1} are not used for
+     *  computing the L1 norm. Setting b (0 < b < N), one can protect
+     *  variables, x_1, ..., x_{b-1} (e.g., a bias term of logistic
+     *  regression) from being regularized. The default value is zero.
+     */
+    int orthantwise_start;
+
+    /**
+     * End index for computing L1 norm of the variables.
+     *  This parameter is valid only for OWL-QN method
+     *  (i.e., \ref orthantwise_c != 0). This parameter e (0 < e <= N)
+     *  specifies the index number at which the library stops computing the
+     *  L1 norm of the variables x,
+     */
+    int orthantwise_end;
+  } lbfgs_parameter_t;
+
+  /**
+   * Callback interface to provide objective function and gradient evaluations.
+   *
+   *  The lbfgs() function call this function to obtain the values of objective
+   *  function and its gradients when needed. A client program must implement
+   *  this function to evaluate the values of the objective function and its
+   *  gradients, given current values of variables.
+   *
+   *  @param  instance    The user data sent for lbfgs() function by the client.
+   *  @param  x           The current values of variables.
+   *  @param  g           The gradient vector. The callback function must compute
+   *                      the gradient values for the current variables.
+   *  @param  n           The number of variables.
+   *  @param  step        The current step of the line search routine.
+   *  @retval lbfgsfloatval_t The value of the objective function for the current
+   *                          variables.
+   */
+  typedef lbfgsfloatval_t (*lbfgs_evaluate_t)(
+      void *instance,
+      const lbfgsfloatval_t *x,
+      lbfgsfloatval_t *g,
+      const int n,
+      const lbfgsfloatval_t step);
+
+  /**
+   * Callback interface to receive the progress of the optimization process.
+   *
+   *  The lbfgs() function call this function for each iteration. Implementing
+   *  this function, a client program can store or display the current progress
+   *  of the optimization process.
+   *
+   *  @param  instance    The user data sent for lbfgs() function by the client.
+   *  @param  x           The current values of variables.
+   *  @param  g           The current gradient values of variables.
+   *  @param  fx          The current value of the objective function.
+   *  @param  xnorm       The Euclidean norm of the variables.
+   *  @param  gnorm       The Euclidean norm of the gradients.
+   *  @param  step        The line-search step used for this iteration.
+   *  @param  n           The number of variables.
+   *  @param  k           The iteration count.
+   *  @param  ls          The number of evaluations called for this iteration.
+   *  @retval int         Zero to continue the optimization process. Returning a
+   *                      non-zero value will cancel the optimization process.
+   */
+  typedef int (*lbfgs_progress_t)(
+      void *instance,
+      const lbfgsfloatval_t *x,
+      const lbfgsfloatval_t *g,
+      const lbfgsfloatval_t fx,
+      const lbfgsfloatval_t xnorm,
+      const lbfgsfloatval_t gnorm,
+      const lbfgsfloatval_t step,
+      int n,
+      int k,
+      int ls);
+
+  /*
+A user must implement a function compatible with ::lbfgs_evaluate_t (evaluation
+callback) and pass the pointer to the callback function to lbfgs() arguments.
+Similarly, a user can implement a function compatible with ::lbfgs_progress_t
+(progress callback) to obtain the current progress (e.g., variables, function
+value, ||G||, etc) and to cancel the iteration process if necessary.
+Implementation of a progress callback is optional: a user can pass \c NULL if
+progress notification is not necessary.
+
+In addition, a user must preserve two requirements:
+    - The number of variables must be multiples of 16 (this is not 4).
+    - The memory block of variable array ::x must be aligned to 16.
+
+This algorithm terminates an optimization
+when:
+
+    ||G|| < \epsilon \cdot \max(1, ||x||) .
+
+In this formula, ||.|| denotes the Euclidean norm.
+*/
+
+  /**
+   * Start a L-BFGS optimization.
+   *
+   *  @param  n           The number of variables.
+   *  @param  x           The array of variables. A client program can set
+   *                      default values for the optimization and receive the
+   *                      optimization result through this array. This array
+   *                      must be allocated by ::lbfgs_malloc function
+   *                      for libLBFGS built with SSE/SSE2 optimization routine
+   *                      enabled. The library built without SSE/SSE2
+   *                      optimization does not have such a requirement.
+   *  @param  ptr_fx      The pointer to the variable that receives the final
+   *                      value of the objective function for the variables.
+   *                      This argument can be set to \c NULL if the final
+   *                      value of the objective function is unnecessary.
+   *  @param  proc_evaluate   The callback function to provide function and
+   *                          gradient evaluations given a current values of
+   *                          variables. A client program must implement a
+   *                          callback function compatible with \ref
+   *                          lbfgs_evaluate_t and pass the pointer to the
+   *                          callback function.
+   *  @param  proc_progress   The callback function to receive the progress
+   *                          (the number of iterations, the current value of
+   *                          the objective function) of the minimization
+   *                          process. This argument can be set to \c NULL if
+   *                          a progress report is unnecessary.
+   *  @param  instance    A user data for the client program. The callback
+   *                      functions will receive the value of this argument.
+   *  @param  param       The pointer to a structure representing parameters for
+   *                      L-BFGS optimization. A client program can set this
+   *                      parameter to \c NULL to use the default parameters.
+   *                      Call lbfgs_parameter_init() function to fill a
+   *                      structure with the default values.
+   *  @retval int         The status code. This function returns zero if the
+   *                      minimization process terminates without an error. A
+   *                      non-zero value indicates an error.
+   */
+  int lbfgs(
+      int n,
+      lbfgsfloatval_t *x,
+      lbfgsfloatval_t *ptr_fx,
+      lbfgs_evaluate_t proc_evaluate,
+      lbfgs_progress_t proc_progress,
+      void *instance,
+      lbfgs_parameter_t *param);
+
+  /**
+   * Initialize L-BFGS parameters to the default values.
+   *
+   *  Call this function to fill a parameter structure with the default values
+   *  and overwrite parameter values if necessary.
+   *
+   *  @param  param       The pointer to the parameter structure.
+   */
+  void lbfgs_parameter_init(lbfgs_parameter_t *param);
+
+  /**
+   * Allocate an array for variables.
+   *
+   *  This function allocates an array of variables for the convenience of
+   *  ::lbfgs function; the function has a requreiemt for a variable array
+   *  when libLBFGS is built with SSE/SSE2 optimization routines. A user does
+   *  not have to use this function for libLBFGS built without SSE/SSE2
+   *  optimization.
+   *
+   *  @param  n           The number of variables.
+   */
+  lbfgsfloatval_t *lbfgs_malloc(int n);
+
+  /**
+   * Free an array of variables.
+   *
+   *  @param  x           The array of variables allocated by ::lbfgs_malloc
+   *                      function.
+   */
+  void lbfgs_free(lbfgsfloatval_t *x);
+
+  /** @} */
+
+#ifdef __cplusplus
+}
+#endif /*__cplusplus*/
+
+/**
+@mainpage libLBFGS: a library of Limited-memory Broyden-Fletcher-Goldfarb-Shanno (L-BFGS)
+
+@section intro Introduction
+
+This library is a C port of the implementation of Limited-memory
+Broyden-Fletcher-Goldfarb-Shanno (L-BFGS) method written by Jorge Nocedal.
+The original FORTRAN source code is available at:
+http://www.ece.northwestern.edu/~nocedal/lbfgs.html
+
+The L-BFGS method solves the unconstrainted minimization problem,
+
+<pre>
+    minimize F(x), x = (x1, x2, ..., xN),
+</pre>
+
+only if the objective function F(x) and its gradient G(x) are computable. The
+well-known Newton's method requires computation of the inverse of the hessian
+matrix of the objective function. However, the computational cost for the
+inverse hessian matrix is expensive especially when the objective function
+takes a large number of variables. The L-BFGS method iteratively finds a
+minimizer by approximating the inverse hessian matrix by information from last
+m iterations. This innovation saves the memory storage and computational time
+drastically for large-scaled problems.
+
+Among the various ports of L-BFGS, this library provides several features:
+- <b>Optimization with L1-norm (Orthant-Wise Limited-memory Quasi-Newton
+  (OWL-QN) method)</b>:
+  In addition to standard minimization problems, the library can minimize
+  a function F(x) combined with L1-norm |x| of the variables,
+  {F(x) + C |x|}, where C is a constant scalar parameter. This feature is
+  useful for estimating parameters of sparse log-linear models (e.g.,
+  logistic regression and maximum entropy) with L1-regularization (or
+  Laplacian prior).
+- <b>Clean C code</b>:
+  Unlike C codes generated automatically by f2c (Fortran 77 into C converter),
+  this port includes changes based on my interpretations, improvements,
+  optimizations, and clean-ups so that the ported code would be well-suited
+  for a C code. In addition to comments inherited from the original code,
+  a number of comments were added through my interpretations.
+- <b>Callback interface</b>:
+  The library receives function and gradient values via a callback interface.
+  The library also notifies the progress of the optimization by invoking a
+  callback function. In the original implementation, a user had to set
+  function and gradient values every time the function returns for obtaining
+  updated values.
+- <b>Thread safe</b>:
+  The library is thread-safe, which is the secondary gain from the callback
+  interface.
+- <b>Cross platform.</b> The source code can be compiled on Microsoft Visual
+  Studio 2010, GNU C Compiler (gcc), etc.
+- <b>Configurable precision</b>: A user can choose single-precision (float)
+  or double-precision (double) accuracy by changing ::LBFGS_FLOAT macro.
+- <b>SSE/SSE2 optimization</b>:
+  This library includes SSE/SSE2 optimization (written in compiler intrinsics)
+  for vector arithmetic operations on Intel/AMD processors. The library uses
+  SSE for float values and SSE2 for double values. The SSE/SSE2 optimization
+  routine is disabled by default.
+
+This library is used by:
+- <a href="http://www.chokkan.org/software/crfsuite/">CRFsuite: A fast implementation of Conditional Random Fields (CRFs)</a>
+- <a href="http://www.chokkan.org/software/classias/">Classias: A collection of machine-learning algorithms for classification</a>
+- <a href="http://www.public.iastate.edu/~gdancik/mlegp/">mlegp: an R package for maximum likelihood estimates for Gaussian processes</a>
+- <a href="http://infmath.uibk.ac.at/~matthiasf/imaging2/">imaging2: the imaging2 class library</a>
+
+@section download Download
+
+- <a href="https://github.com/downloads/chokkan/liblbfgs/liblbfgs-1.10.tar.gz">Source code</a>
+- <a href="https://github.com/chokkan/liblbfgs">GitHub repository</a>
+
+libLBFGS is distributed under the term of the
+<a href="http://opensource.org/licenses/mit-license.php">MIT license</a>.
+
+@section modules Third-party modules
+- <a href="http://cran.r-project.org/web/packages/lbfgs/index.html">lbfgs: Limited-memory BFGS Optimization (a wrapper for R)</a> maintained by Antonio Coppola.
+- <a href="http://search.cpan.org/~laye/Algorithm-LBFGS-0.16/">Algorithm::LBFGS - Perl extension for L-BFGS</a> maintained by Lei Sun.
+- <a href="http://www.cs.kuleuven.be/~bernd/yap-lbfgs/">YAP-LBFGS (an interface to call libLBFGS from YAP Prolog)</a> maintained by Bernd Gutmann.
+
+@section changelog History
+- Version 1.10 (2010-12-22):
+    - Fixed compiling errors on Mac OS X; this patch was kindly submitted by
+      Nic Schraudolph.
+    - Reduced compiling warnings on Mac OS X; this patch was kindly submitted
+      by Tamas Nepusz.
+    - Replaced memalign() with posix_memalign().
+    - Updated solution and project files for Microsoft Visual Studio 2010.
+- Version 1.9 (2010-01-29):
+    - Fixed a mistake in checking the validity of the parameters "ftol" and
+      "wolfe"; this was discovered by Kevin S. Van Horn.
+- Version 1.8 (2009-07-13):
+    - Accepted the patch submitted by Takashi Imamichi;
+      the backtracking method now has three criteria for choosing the step
+      length:
+        - ::LBFGS_LINESEARCH_BACKTRACKING_ARMIJO: sufficient decrease (Armijo)
+          condition only
+        - ::LBFGS_LINESEARCH_BACKTRACKING_WOLFE: regular Wolfe condition
+          (sufficient decrease condition + curvature condition)
+        - ::LBFGS_LINESEARCH_BACKTRACKING_STRONG_WOLFE: strong Wolfe condition
+    - Updated the documentation to explain the above three criteria.
+- Version 1.7 (2009-02-28):
+    - Improved OWL-QN routines for stability.
+    - Removed the support of OWL-QN method in MoreThuente algorithm because
+      it accidentally fails in early stages of iterations for some objectives.
+      Because of this change, <b>the OW-LQN method must be used with the
+      backtracking algorithm (::LBFGS_LINESEARCH_BACKTRACKING)</b>, or the
+      library returns ::LBFGSERR_INVALID_LINESEARCH.
+    - Renamed line search algorithms as follows:
+        - ::LBFGS_LINESEARCH_BACKTRACKING: regular Wolfe condition.
+        - ::LBFGS_LINESEARCH_BACKTRACKING_LOOSE: regular Wolfe condition.
+        - ::LBFGS_LINESEARCH_BACKTRACKING_STRONG: strong Wolfe condition.
+    - Source code clean-up.
+- Version 1.6 (2008-11-02):
+    - Improved line-search algorithm with strong Wolfe condition, which was
+      contributed by Takashi Imamichi. This routine is now default for
+      ::LBFGS_LINESEARCH_BACKTRACKING. The previous line search algorithm
+      with regular Wolfe condition is still available as
+      ::LBFGS_LINESEARCH_BACKTRACKING_LOOSE.
+    - Configurable stop index for L1-norm computation. A member variable
+      ::lbfgs_parameter_t::orthantwise_end was added to specify the index
+      number at which the library stops computing the L1 norm of the
+      variables. This is useful to prevent some variables from being
+      regularized by the OW-LQN method.
+    - A sample program written in C++ (sample/sample.cpp).
+- Version 1.5 (2008-07-10):
+    - Configurable starting index for L1-norm computation. A member variable
+      ::lbfgs_parameter_t::orthantwise_start was added to specify the index
+      number from which the library computes the L1 norm of the variables.
+      This is useful to prevent some variables from being regularized by the
+      OWL-QN method.
+    - Fixed a zero-division error when the initial variables have already
+      been a minimizer (reported by Takashi Imamichi). In this case, the
+      library returns ::LBFGS_ALREADY_MINIMIZED status code.
+    - Defined ::LBFGS_SUCCESS status code as zero; removed unused constants,
+      LBFGSFALSE and LBFGSTRUE.
+    - Fixed a compile error in an implicit down-cast.
+- Version 1.4 (2008-04-25):
+    - Configurable line search algorithms. A member variable
+      ::lbfgs_parameter_t::linesearch was added to choose either MoreThuente
+      method (::LBFGS_LINESEARCH_MORETHUENTE) or backtracking algorithm
+      (::LBFGS_LINESEARCH_BACKTRACKING).
+    - Fixed a bug: the previous version did not compute psuedo-gradients
+      properly in the line search routines for OWL-QN. This bug might quit
+      an iteration process too early when the OWL-QN routine was activated
+      (0 < ::lbfgs_parameter_t::orthantwise_c).
+    - Configure script for POSIX environments.
+    - SSE/SSE2 optimizations with GCC.
+    - New functions ::lbfgs_malloc and ::lbfgs_free to use SSE/SSE2 routines
+      transparently. It is uncessary to use these functions for libLBFGS built
+      without SSE/SSE2 routines; you can still use any memory allocators if
+      SSE/SSE2 routines are disabled in libLBFGS.
+- Version 1.3 (2007-12-16):
+    - An API change. An argument was added to lbfgs() function to receive the
+      final value of the objective function. This argument can be set to
+      \c NULL if the final value is unnecessary.
+    - Fixed a null-pointer bug in the sample code (reported by Takashi Imamichi).
+    - Added build scripts for Microsoft Visual Studio 2005 and GCC.
+    - Added README file.
+- Version 1.2 (2007-12-13):
+    - Fixed a serious bug in orthant-wise L-BFGS.
+      An important variable was used without initialization.
+- Version 1.1 (2007-12-01):
+    - Implemented orthant-wise L-BFGS.
+    - Implemented lbfgs_parameter_init() function.
+    - Fixed several bugs.
+    - API documentation.
+- Version 1.0 (2007-09-20):
+    - Initial release.
+
+@section api Documentation
+
+- @ref liblbfgs_api "libLBFGS API"
+
+@section sample Sample code
+
+@include sample.c
+
+@section ack Acknowledgements
+
+The L-BFGS algorithm is described in:
+    - Jorge Nocedal.
+      Updating Quasi-Newton Matrices with Limited Storage.
+      <i>Mathematics of Computation</i>, Vol. 35, No. 151, pp. 773--782, 1980.
+    - Dong C. Liu and Jorge Nocedal.
+      On the limited memory BFGS method for large scale optimization.
+      <i>Mathematical Programming</i> B, Vol. 45, No. 3, pp. 503-528, 1989.
+
+The line search algorithms used in this implementation are described in:
+    - John E. Dennis and Robert B. Schnabel.
+      <i>Numerical Methods for Unconstrained Optimization and Nonlinear
+      Equations</i>, Englewood Cliffs, 1983.
+    - Jorge J. More and David J. Thuente.
+      Line search algorithm with guaranteed sufficient decrease.
+      <i>ACM Transactions on Mathematical Software (TOMS)</i>, Vol. 20, No. 3,
+      pp. 286-307, 1994.
+
+This library also implements Orthant-Wise Limited-memory Quasi-Newton (OWL-QN)
+method presented in:
+    - Galen Andrew and Jianfeng Gao.
+      Scalable training of L1-regularized log-linear models.
+      In <i>Proceedings of the 24th International Conference on Machine
+      Learning (ICML 2007)</i>, pp. 33-40, 2007.
+
+Special thanks go to:
+    - Yoshimasa Tsuruoka and Daisuke Okanohara for technical information about
+      OWL-QN
+    - Takashi Imamichi for the useful enhancements of the backtracking method
+    - Kevin S. Van Horn, Nic Schraudolph, and Tamas Nepusz for bug fixes
+
+Finally I would like to thank the original author, Jorge Nocedal, who has been
+distributing the effieicnt and explanatory implementation in an open source
+licence.
+
+@section reference Reference
+
+- <a href="http://www.ece.northwestern.edu/~nocedal/lbfgs.html">L-BFGS</a> by Jorge Nocedal.
+- <a href="http://research.microsoft.com/en-us/downloads/b1eb1016-1738-4bd5-83a9-370c9d498a03/default.aspx">Orthant-Wise Limited-memory Quasi-Newton Optimizer for L1-regularized Objectives</a> by Galen Andrew.
+- <a href="http://chasen.org/~taku/software/misc/lbfgs/">C port (via f2c)</a> by Taku Kudo.
+- <a href="http://www.alglib.net/optimization/lbfgs.php">C#/C++/Delphi/VisualBasic6 port</a> in ALGLIB.
+- <a href="http://cctbx.sourceforge.net/">Computational Crystallography Toolbox</a> includes
+  <a href="http://cctbx.sourceforge.net/current_cvs/c_plus_plus/namespacescitbx_1_1lbfgs.html">scitbx::lbfgs</a>.
+*/
+
+#endif /*__LBFGS_H__*/
```

## chaine/_core/liblbfgs/lib/arithmetic_ansi.h

 * *Ordering differences only*

```diff
@@ -1,142 +1,142 @@
-/*
- *      ANSI C implementation of vector operations.
- *
- * Copyright (c) 2007-2010 Naoaki Okazaki
- * All rights reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to deal
- * in the Software without restriction, including without limitation the rights
- * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
- * copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
- * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
- * THE SOFTWARE.
- */
-
-/* $Id$ */
-
-#include <stdlib.h>
-#include <memory.h>
-
-#if LBFGS_FLOAT == 32 && LBFGS_IEEE_FLOAT
-#define fsigndiff(x, y) (((*(uint32_t *)(x)) ^ (*(uint32_t *)(y))) & 0x80000000U)
-#else
-#define fsigndiff(x, y) (*(x) * (*(y) / fabs(*(y))) < 0.)
-#endif /*LBFGS_IEEE_FLOAT*/
-
-inline static void *vecalloc(size_t size)
-{
-    void *memblock = malloc(size);
-    if (memblock)
-    {
-        memset(memblock, 0, size);
-    }
-    return memblock;
-}
-
-inline static void vecfree(void *memblock)
-{
-    free(memblock);
-}
-
-inline static void vecset(lbfgsfloatval_t *x, const lbfgsfloatval_t c, const int n)
-{
-    int i;
-
-    for (i = 0; i < n; ++i)
-    {
-        x[i] = c;
-    }
-}
-
-inline static void veccpy(lbfgsfloatval_t *y, const lbfgsfloatval_t *x, const int n)
-{
-    int i;
-
-    for (i = 0; i < n; ++i)
-    {
-        y[i] = x[i];
-    }
-}
-
-inline static void vecncpy(lbfgsfloatval_t *y, const lbfgsfloatval_t *x, const int n)
-{
-    int i;
-
-    for (i = 0; i < n; ++i)
-    {
-        y[i] = -x[i];
-    }
-}
-
-inline static void vecadd(lbfgsfloatval_t *y, const lbfgsfloatval_t *x, const lbfgsfloatval_t c, const int n)
-{
-    int i;
-
-    for (i = 0; i < n; ++i)
-    {
-        y[i] += c * x[i];
-    }
-}
-
-inline static void vecdiff(lbfgsfloatval_t *z, const lbfgsfloatval_t *x, const lbfgsfloatval_t *y, const int n)
-{
-    int i;
-
-    for (i = 0; i < n; ++i)
-    {
-        z[i] = x[i] - y[i];
-    }
-}
-
-inline static void vecscale(lbfgsfloatval_t *y, const lbfgsfloatval_t c, const int n)
-{
-    int i;
-
-    for (i = 0; i < n; ++i)
-    {
-        y[i] *= c;
-    }
-}
-
-inline static void vecmul(lbfgsfloatval_t *y, const lbfgsfloatval_t *x, const int n)
-{
-    int i;
-
-    for (i = 0; i < n; ++i)
-    {
-        y[i] *= x[i];
-    }
-}
-
-inline static void vecdot(lbfgsfloatval_t *s, const lbfgsfloatval_t *x, const lbfgsfloatval_t *y, const int n)
-{
-    int i;
-    *s = 0.;
-    for (i = 0; i < n; ++i)
-    {
-        *s += x[i] * y[i];
-    }
-}
-
-inline static void vec2norm(lbfgsfloatval_t *s, const lbfgsfloatval_t *x, const int n)
-{
-    vecdot(s, x, x, n);
-    *s = (lbfgsfloatval_t)sqrt(*s);
-}
-
-inline static void vec2norminv(lbfgsfloatval_t *s, const lbfgsfloatval_t *x, const int n)
-{
-    vec2norm(s, x, n);
-    *s = (lbfgsfloatval_t)(1.0 / *s);
-}
+/*
+ *      ANSI C implementation of vector operations.
+ *
+ * Copyright (c) 2007-2010 Naoaki Okazaki
+ * All rights reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+
+/* $Id$ */
+
+#include <stdlib.h>
+#include <memory.h>
+
+#if LBFGS_FLOAT == 32 && LBFGS_IEEE_FLOAT
+#define fsigndiff(x, y) (((*(uint32_t *)(x)) ^ (*(uint32_t *)(y))) & 0x80000000U)
+#else
+#define fsigndiff(x, y) (*(x) * (*(y) / fabs(*(y))) < 0.)
+#endif /*LBFGS_IEEE_FLOAT*/
+
+inline static void *vecalloc(size_t size)
+{
+    void *memblock = malloc(size);
+    if (memblock)
+    {
+        memset(memblock, 0, size);
+    }
+    return memblock;
+}
+
+inline static void vecfree(void *memblock)
+{
+    free(memblock);
+}
+
+inline static void vecset(lbfgsfloatval_t *x, const lbfgsfloatval_t c, const int n)
+{
+    int i;
+
+    for (i = 0; i < n; ++i)
+    {
+        x[i] = c;
+    }
+}
+
+inline static void veccpy(lbfgsfloatval_t *y, const lbfgsfloatval_t *x, const int n)
+{
+    int i;
+
+    for (i = 0; i < n; ++i)
+    {
+        y[i] = x[i];
+    }
+}
+
+inline static void vecncpy(lbfgsfloatval_t *y, const lbfgsfloatval_t *x, const int n)
+{
+    int i;
+
+    for (i = 0; i < n; ++i)
+    {
+        y[i] = -x[i];
+    }
+}
+
+inline static void vecadd(lbfgsfloatval_t *y, const lbfgsfloatval_t *x, const lbfgsfloatval_t c, const int n)
+{
+    int i;
+
+    for (i = 0; i < n; ++i)
+    {
+        y[i] += c * x[i];
+    }
+}
+
+inline static void vecdiff(lbfgsfloatval_t *z, const lbfgsfloatval_t *x, const lbfgsfloatval_t *y, const int n)
+{
+    int i;
+
+    for (i = 0; i < n; ++i)
+    {
+        z[i] = x[i] - y[i];
+    }
+}
+
+inline static void vecscale(lbfgsfloatval_t *y, const lbfgsfloatval_t c, const int n)
+{
+    int i;
+
+    for (i = 0; i < n; ++i)
+    {
+        y[i] *= c;
+    }
+}
+
+inline static void vecmul(lbfgsfloatval_t *y, const lbfgsfloatval_t *x, const int n)
+{
+    int i;
+
+    for (i = 0; i < n; ++i)
+    {
+        y[i] *= x[i];
+    }
+}
+
+inline static void vecdot(lbfgsfloatval_t *s, const lbfgsfloatval_t *x, const lbfgsfloatval_t *y, const int n)
+{
+    int i;
+    *s = 0.;
+    for (i = 0; i < n; ++i)
+    {
+        *s += x[i] * y[i];
+    }
+}
+
+inline static void vec2norm(lbfgsfloatval_t *s, const lbfgsfloatval_t *x, const int n)
+{
+    vecdot(s, x, x, n);
+    *s = (lbfgsfloatval_t)sqrt(*s);
+}
+
+inline static void vec2norminv(lbfgsfloatval_t *s, const lbfgsfloatval_t *x, const int n)
+{
+    vec2norm(s, x, n);
+    *s = (lbfgsfloatval_t)(1.0 / *s);
+}
```

## chaine/_core/liblbfgs/lib/arithmetic_sse_double.h

 * *Ordering differences only*

```diff
@@ -1,303 +1,303 @@
-/*
- *      SSE2 implementation of vector oprations (64bit double).
- *
- * Copyright (c) 2007-2010 Naoaki Okazaki
- * All rights reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to deal
- * in the Software without restriction, including without limitation the rights
- * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
- * copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
- * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
- * THE SOFTWARE.
- */
-
-/* $Id$ */
-
-#include <stdlib.h>
-#ifndef __APPLE__
-#include <malloc.h>
-#endif
-#include <memory.h>
-
-#if 1400 <= _MSC_VER
-#include <intrin.h>
-#endif /*1400 <= _MSC_VER*/
-
-#if HAVE_EMMINTRIN_H
-#include <emmintrin.h>
-#endif /*HAVE_EMMINTRIN_H*/
-
-inline static void *vecalloc(size_t size)
-{
-#if defined(_MSC_VER)
-    void *memblock = _aligned_malloc(size, 16);
-#elif defined(__APPLE__) /* OS X always aligns on 16-byte boundaries */
-    void *memblock = malloc(size);
-#else
-    void *memblock = NULL, *p = NULL;
-    if (posix_memalign(&p, 16, size) == 0)
-    {
-        memblock = p;
-    }
-#endif
-    if (memblock != NULL)
-    {
-        memset(memblock, 0, size);
-    }
-    return memblock;
-}
-
-inline static void vecfree(void *memblock)
-{
-#ifdef _MSC_VER
-    _aligned_free(memblock);
-#else
-    free(memblock);
-#endif
-}
-
-#define fsigndiff(x, y) \
-    ((_mm_movemask_pd(_mm_set_pd(*(x), *(y))) + 1) & 0x002)
-
-#define vecset(x, c, n)                      \
-    {                                        \
-        int i;                               \
-        __m128d XMM0 = _mm_set1_pd(c);       \
-        for (i = 0; i < (n); i += 8)         \
-        {                                    \
-            _mm_store_pd((x) + i, XMM0);     \
-            _mm_store_pd((x) + i + 2, XMM0); \
-            _mm_store_pd((x) + i + 4, XMM0); \
-            _mm_store_pd((x) + i + 6, XMM0); \
-        }                                    \
-    }
-
-#define veccpy(y, x, n)                              \
-    {                                                \
-        int i;                                       \
-        for (i = 0; i < (n); i += 8)                 \
-        {                                            \
-            __m128d XMM0 = _mm_load_pd((x) + i);     \
-            __m128d XMM1 = _mm_load_pd((x) + i + 2); \
-            __m128d XMM2 = _mm_load_pd((x) + i + 4); \
-            __m128d XMM3 = _mm_load_pd((x) + i + 6); \
-            _mm_store_pd((y) + i, XMM0);             \
-            _mm_store_pd((y) + i + 2, XMM1);         \
-            _mm_store_pd((y) + i + 4, XMM2);         \
-            _mm_store_pd((y) + i + 6, XMM3);         \
-        }                                            \
-    }
-
-#define vecncpy(y, x, n)                             \
-    {                                                \
-        int i;                                       \
-        for (i = 0; i < (n); i += 8)                 \
-        {                                            \
-            __m128d XMM0 = _mm_setzero_pd();         \
-            __m128d XMM1 = _mm_setzero_pd();         \
-            __m128d XMM2 = _mm_setzero_pd();         \
-            __m128d XMM3 = _mm_setzero_pd();         \
-            __m128d XMM4 = _mm_load_pd((x) + i);     \
-            __m128d XMM5 = _mm_load_pd((x) + i + 2); \
-            __m128d XMM6 = _mm_load_pd((x) + i + 4); \
-            __m128d XMM7 = _mm_load_pd((x) + i + 6); \
-            XMM0 = _mm_sub_pd(XMM0, XMM4);           \
-            XMM1 = _mm_sub_pd(XMM1, XMM5);           \
-            XMM2 = _mm_sub_pd(XMM2, XMM6);           \
-            XMM3 = _mm_sub_pd(XMM3, XMM7);           \
-            _mm_store_pd((y) + i, XMM0);             \
-            _mm_store_pd((y) + i + 2, XMM1);         \
-            _mm_store_pd((y) + i + 4, XMM2);         \
-            _mm_store_pd((y) + i + 6, XMM3);         \
-        }                                            \
-    }
-
-#define vecadd(y, x, c, n)                           \
-    {                                                \
-        int i;                                       \
-        __m128d XMM7 = _mm_set1_pd(c);               \
-        for (i = 0; i < (n); i += 4)                 \
-        {                                            \
-            __m128d XMM0 = _mm_load_pd((x) + i);     \
-            __m128d XMM1 = _mm_load_pd((x) + i + 2); \
-            __m128d XMM2 = _mm_load_pd((y) + i);     \
-            __m128d XMM3 = _mm_load_pd((y) + i + 2); \
-            XMM0 = _mm_mul_pd(XMM0, XMM7);           \
-            XMM1 = _mm_mul_pd(XMM1, XMM7);           \
-            XMM2 = _mm_add_pd(XMM2, XMM0);           \
-            XMM3 = _mm_add_pd(XMM3, XMM1);           \
-            _mm_store_pd((y) + i, XMM2);             \
-            _mm_store_pd((y) + i + 2, XMM3);         \
-        }                                            \
-    }
-
-#define vecdiff(z, x, y, n)                          \
-    {                                                \
-        int i;                                       \
-        for (i = 0; i < (n); i += 8)                 \
-        {                                            \
-            __m128d XMM0 = _mm_load_pd((x) + i);     \
-            __m128d XMM1 = _mm_load_pd((x) + i + 2); \
-            __m128d XMM2 = _mm_load_pd((x) + i + 4); \
-            __m128d XMM3 = _mm_load_pd((x) + i + 6); \
-            __m128d XMM4 = _mm_load_pd((y) + i);     \
-            __m128d XMM5 = _mm_load_pd((y) + i + 2); \
-            __m128d XMM6 = _mm_load_pd((y) + i + 4); \
-            __m128d XMM7 = _mm_load_pd((y) + i + 6); \
-            XMM0 = _mm_sub_pd(XMM0, XMM4);           \
-            XMM1 = _mm_sub_pd(XMM1, XMM5);           \
-            XMM2 = _mm_sub_pd(XMM2, XMM6);           \
-            XMM3 = _mm_sub_pd(XMM3, XMM7);           \
-            _mm_store_pd((z) + i, XMM0);             \
-            _mm_store_pd((z) + i + 2, XMM1);         \
-            _mm_store_pd((z) + i + 4, XMM2);         \
-            _mm_store_pd((z) + i + 6, XMM3);         \
-        }                                            \
-    }
-
-#define vecscale(y, c, n)                            \
-    {                                                \
-        int i;                                       \
-        __m128d XMM7 = _mm_set1_pd(c);               \
-        for (i = 0; i < (n); i += 4)                 \
-        {                                            \
-            __m128d XMM0 = _mm_load_pd((y) + i);     \
-            __m128d XMM1 = _mm_load_pd((y) + i + 2); \
-            XMM0 = _mm_mul_pd(XMM0, XMM7);           \
-            XMM1 = _mm_mul_pd(XMM1, XMM7);           \
-            _mm_store_pd((y) + i, XMM0);             \
-            _mm_store_pd((y) + i + 2, XMM1);         \
-        }                                            \
-    }
-
-#define vecmul(y, x, n)                              \
-    {                                                \
-        int i;                                       \
-        for (i = 0; i < (n); i += 8)                 \
-        {                                            \
-            __m128d XMM0 = _mm_load_pd((x) + i);     \
-            __m128d XMM1 = _mm_load_pd((x) + i + 2); \
-            __m128d XMM2 = _mm_load_pd((x) + i + 4); \
-            __m128d XMM3 = _mm_load_pd((x) + i + 6); \
-            __m128d XMM4 = _mm_load_pd((y) + i);     \
-            __m128d XMM5 = _mm_load_pd((y) + i + 2); \
-            __m128d XMM6 = _mm_load_pd((y) + i + 4); \
-            __m128d XMM7 = _mm_load_pd((y) + i + 6); \
-            XMM4 = _mm_mul_pd(XMM4, XMM0);           \
-            XMM5 = _mm_mul_pd(XMM5, XMM1);           \
-            XMM6 = _mm_mul_pd(XMM6, XMM2);           \
-            XMM7 = _mm_mul_pd(XMM7, XMM3);           \
-            _mm_store_pd((y) + i, XMM4);             \
-            _mm_store_pd((y) + i + 2, XMM5);         \
-            _mm_store_pd((y) + i + 4, XMM6);         \
-            _mm_store_pd((y) + i + 6, XMM7);         \
-        }                                            \
-    }
-
-#if 3 <= __SSE__ || defined(__SSE3__)
-/*
-    Horizontal add with haddps SSE3 instruction. The work register (rw)
-    is unused.
- */
-#define __horizontal_sum(r, rw) \
-    r = _mm_hadd_ps(r, r);      \
-    r = _mm_hadd_ps(r, r);
-
-#else
-/*
-    Horizontal add with SSE instruction. The work register (rw) is used.
- */
-#define __horizontal_sum(r, rw)                         \
-    rw = r;                                             \
-    r = _mm_shuffle_ps(r, rw, _MM_SHUFFLE(1, 0, 3, 2)); \
-    r = _mm_add_ps(r, rw);                              \
-    rw = r;                                             \
-    r = _mm_shuffle_ps(r, rw, _MM_SHUFFLE(2, 3, 0, 1)); \
-    r = _mm_add_ps(r, rw);
-
-#endif
-
-#define vecdot(s, x, y, n)                                     \
-    {                                                          \
-        int i;                                                 \
-        __m128d XMM0 = _mm_setzero_pd();                       \
-        __m128d XMM1 = _mm_setzero_pd();                       \
-        __m128d XMM2, XMM3, XMM4, XMM5;                        \
-        for (i = 0; i < (n); i += 4)                           \
-        {                                                      \
-            XMM2 = _mm_load_pd((x) + i);                       \
-            XMM3 = _mm_load_pd((x) + i + 2);                   \
-            XMM4 = _mm_load_pd((y) + i);                       \
-            XMM5 = _mm_load_pd((y) + i + 2);                   \
-            XMM2 = _mm_mul_pd(XMM2, XMM4);                     \
-            XMM3 = _mm_mul_pd(XMM3, XMM5);                     \
-            XMM0 = _mm_add_pd(XMM0, XMM2);                     \
-            XMM1 = _mm_add_pd(XMM1, XMM3);                     \
-        }                                                      \
-        XMM0 = _mm_add_pd(XMM0, XMM1);                         \
-        XMM1 = _mm_shuffle_pd(XMM0, XMM0, _MM_SHUFFLE2(1, 1)); \
-        XMM0 = _mm_add_pd(XMM0, XMM1);                         \
-        _mm_store_sd((s), XMM0);                               \
-    }
-
-#define vec2norm(s, x, n)                                      \
-    {                                                          \
-        int i;                                                 \
-        __m128d XMM0 = _mm_setzero_pd();                       \
-        __m128d XMM1 = _mm_setzero_pd();                       \
-        __m128d XMM2, XMM3, XMM4, XMM5;                        \
-        for (i = 0; i < (n); i += 4)                           \
-        {                                                      \
-            XMM2 = _mm_load_pd((x) + i);                       \
-            XMM3 = _mm_load_pd((x) + i + 2);                   \
-            XMM4 = XMM2;                                       \
-            XMM5 = XMM3;                                       \
-            XMM2 = _mm_mul_pd(XMM2, XMM4);                     \
-            XMM3 = _mm_mul_pd(XMM3, XMM5);                     \
-            XMM0 = _mm_add_pd(XMM0, XMM2);                     \
-            XMM1 = _mm_add_pd(XMM1, XMM3);                     \
-        }                                                      \
-        XMM0 = _mm_add_pd(XMM0, XMM1);                         \
-        XMM1 = _mm_shuffle_pd(XMM0, XMM0, _MM_SHUFFLE2(1, 1)); \
-        XMM0 = _mm_add_pd(XMM0, XMM1);                         \
-        XMM0 = _mm_sqrt_pd(XMM0);                              \
-        _mm_store_sd((s), XMM0);                               \
-    }
-
-#define vec2norminv(s, x, n)                                   \
-    {                                                          \
-        int i;                                                 \
-        __m128d XMM0 = _mm_setzero_pd();                       \
-        __m128d XMM1 = _mm_setzero_pd();                       \
-        __m128d XMM2, XMM3, XMM4, XMM5;                        \
-        for (i = 0; i < (n); i += 4)                           \
-        {                                                      \
-            XMM2 = _mm_load_pd((x) + i);                       \
-            XMM3 = _mm_load_pd((x) + i + 2);                   \
-            XMM4 = XMM2;                                       \
-            XMM5 = XMM3;                                       \
-            XMM2 = _mm_mul_pd(XMM2, XMM4);                     \
-            XMM3 = _mm_mul_pd(XMM3, XMM5);                     \
-            XMM0 = _mm_add_pd(XMM0, XMM2);                     \
-            XMM1 = _mm_add_pd(XMM1, XMM3);                     \
-        }                                                      \
-        XMM2 = _mm_set1_pd(1.0);                               \
-        XMM0 = _mm_add_pd(XMM0, XMM1);                         \
-        XMM1 = _mm_shuffle_pd(XMM0, XMM0, _MM_SHUFFLE2(1, 1)); \
-        XMM0 = _mm_add_pd(XMM0, XMM1);                         \
-        XMM0 = _mm_sqrt_pd(XMM0);                              \
-        XMM2 = _mm_div_pd(XMM2, XMM0);                         \
-        _mm_store_sd((s), XMM2);                               \
-    }
+/*
+ *      SSE2 implementation of vector oprations (64bit double).
+ *
+ * Copyright (c) 2007-2010 Naoaki Okazaki
+ * All rights reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+
+/* $Id$ */
+
+#include <stdlib.h>
+#ifndef __APPLE__
+#include <malloc.h>
+#endif
+#include <memory.h>
+
+#if 1400 <= _MSC_VER
+#include <intrin.h>
+#endif /*1400 <= _MSC_VER*/
+
+#if HAVE_EMMINTRIN_H
+#include <emmintrin.h>
+#endif /*HAVE_EMMINTRIN_H*/
+
+inline static void *vecalloc(size_t size)
+{
+#if defined(_MSC_VER)
+    void *memblock = _aligned_malloc(size, 16);
+#elif defined(__APPLE__) /* OS X always aligns on 16-byte boundaries */
+    void *memblock = malloc(size);
+#else
+    void *memblock = NULL, *p = NULL;
+    if (posix_memalign(&p, 16, size) == 0)
+    {
+        memblock = p;
+    }
+#endif
+    if (memblock != NULL)
+    {
+        memset(memblock, 0, size);
+    }
+    return memblock;
+}
+
+inline static void vecfree(void *memblock)
+{
+#ifdef _MSC_VER
+    _aligned_free(memblock);
+#else
+    free(memblock);
+#endif
+}
+
+#define fsigndiff(x, y) \
+    ((_mm_movemask_pd(_mm_set_pd(*(x), *(y))) + 1) & 0x002)
+
+#define vecset(x, c, n)                      \
+    {                                        \
+        int i;                               \
+        __m128d XMM0 = _mm_set1_pd(c);       \
+        for (i = 0; i < (n); i += 8)         \
+        {                                    \
+            _mm_store_pd((x) + i, XMM0);     \
+            _mm_store_pd((x) + i + 2, XMM0); \
+            _mm_store_pd((x) + i + 4, XMM0); \
+            _mm_store_pd((x) + i + 6, XMM0); \
+        }                                    \
+    }
+
+#define veccpy(y, x, n)                              \
+    {                                                \
+        int i;                                       \
+        for (i = 0; i < (n); i += 8)                 \
+        {                                            \
+            __m128d XMM0 = _mm_load_pd((x) + i);     \
+            __m128d XMM1 = _mm_load_pd((x) + i + 2); \
+            __m128d XMM2 = _mm_load_pd((x) + i + 4); \
+            __m128d XMM3 = _mm_load_pd((x) + i + 6); \
+            _mm_store_pd((y) + i, XMM0);             \
+            _mm_store_pd((y) + i + 2, XMM1);         \
+            _mm_store_pd((y) + i + 4, XMM2);         \
+            _mm_store_pd((y) + i + 6, XMM3);         \
+        }                                            \
+    }
+
+#define vecncpy(y, x, n)                             \
+    {                                                \
+        int i;                                       \
+        for (i = 0; i < (n); i += 8)                 \
+        {                                            \
+            __m128d XMM0 = _mm_setzero_pd();         \
+            __m128d XMM1 = _mm_setzero_pd();         \
+            __m128d XMM2 = _mm_setzero_pd();         \
+            __m128d XMM3 = _mm_setzero_pd();         \
+            __m128d XMM4 = _mm_load_pd((x) + i);     \
+            __m128d XMM5 = _mm_load_pd((x) + i + 2); \
+            __m128d XMM6 = _mm_load_pd((x) + i + 4); \
+            __m128d XMM7 = _mm_load_pd((x) + i + 6); \
+            XMM0 = _mm_sub_pd(XMM0, XMM4);           \
+            XMM1 = _mm_sub_pd(XMM1, XMM5);           \
+            XMM2 = _mm_sub_pd(XMM2, XMM6);           \
+            XMM3 = _mm_sub_pd(XMM3, XMM7);           \
+            _mm_store_pd((y) + i, XMM0);             \
+            _mm_store_pd((y) + i + 2, XMM1);         \
+            _mm_store_pd((y) + i + 4, XMM2);         \
+            _mm_store_pd((y) + i + 6, XMM3);         \
+        }                                            \
+    }
+
+#define vecadd(y, x, c, n)                           \
+    {                                                \
+        int i;                                       \
+        __m128d XMM7 = _mm_set1_pd(c);               \
+        for (i = 0; i < (n); i += 4)                 \
+        {                                            \
+            __m128d XMM0 = _mm_load_pd((x) + i);     \
+            __m128d XMM1 = _mm_load_pd((x) + i + 2); \
+            __m128d XMM2 = _mm_load_pd((y) + i);     \
+            __m128d XMM3 = _mm_load_pd((y) + i + 2); \
+            XMM0 = _mm_mul_pd(XMM0, XMM7);           \
+            XMM1 = _mm_mul_pd(XMM1, XMM7);           \
+            XMM2 = _mm_add_pd(XMM2, XMM0);           \
+            XMM3 = _mm_add_pd(XMM3, XMM1);           \
+            _mm_store_pd((y) + i, XMM2);             \
+            _mm_store_pd((y) + i + 2, XMM3);         \
+        }                                            \
+    }
+
+#define vecdiff(z, x, y, n)                          \
+    {                                                \
+        int i;                                       \
+        for (i = 0; i < (n); i += 8)                 \
+        {                                            \
+            __m128d XMM0 = _mm_load_pd((x) + i);     \
+            __m128d XMM1 = _mm_load_pd((x) + i + 2); \
+            __m128d XMM2 = _mm_load_pd((x) + i + 4); \
+            __m128d XMM3 = _mm_load_pd((x) + i + 6); \
+            __m128d XMM4 = _mm_load_pd((y) + i);     \
+            __m128d XMM5 = _mm_load_pd((y) + i + 2); \
+            __m128d XMM6 = _mm_load_pd((y) + i + 4); \
+            __m128d XMM7 = _mm_load_pd((y) + i + 6); \
+            XMM0 = _mm_sub_pd(XMM0, XMM4);           \
+            XMM1 = _mm_sub_pd(XMM1, XMM5);           \
+            XMM2 = _mm_sub_pd(XMM2, XMM6);           \
+            XMM3 = _mm_sub_pd(XMM3, XMM7);           \
+            _mm_store_pd((z) + i, XMM0);             \
+            _mm_store_pd((z) + i + 2, XMM1);         \
+            _mm_store_pd((z) + i + 4, XMM2);         \
+            _mm_store_pd((z) + i + 6, XMM3);         \
+        }                                            \
+    }
+
+#define vecscale(y, c, n)                            \
+    {                                                \
+        int i;                                       \
+        __m128d XMM7 = _mm_set1_pd(c);               \
+        for (i = 0; i < (n); i += 4)                 \
+        {                                            \
+            __m128d XMM0 = _mm_load_pd((y) + i);     \
+            __m128d XMM1 = _mm_load_pd((y) + i + 2); \
+            XMM0 = _mm_mul_pd(XMM0, XMM7);           \
+            XMM1 = _mm_mul_pd(XMM1, XMM7);           \
+            _mm_store_pd((y) + i, XMM0);             \
+            _mm_store_pd((y) + i + 2, XMM1);         \
+        }                                            \
+    }
+
+#define vecmul(y, x, n)                              \
+    {                                                \
+        int i;                                       \
+        for (i = 0; i < (n); i += 8)                 \
+        {                                            \
+            __m128d XMM0 = _mm_load_pd((x) + i);     \
+            __m128d XMM1 = _mm_load_pd((x) + i + 2); \
+            __m128d XMM2 = _mm_load_pd((x) + i + 4); \
+            __m128d XMM3 = _mm_load_pd((x) + i + 6); \
+            __m128d XMM4 = _mm_load_pd((y) + i);     \
+            __m128d XMM5 = _mm_load_pd((y) + i + 2); \
+            __m128d XMM6 = _mm_load_pd((y) + i + 4); \
+            __m128d XMM7 = _mm_load_pd((y) + i + 6); \
+            XMM4 = _mm_mul_pd(XMM4, XMM0);           \
+            XMM5 = _mm_mul_pd(XMM5, XMM1);           \
+            XMM6 = _mm_mul_pd(XMM6, XMM2);           \
+            XMM7 = _mm_mul_pd(XMM7, XMM3);           \
+            _mm_store_pd((y) + i, XMM4);             \
+            _mm_store_pd((y) + i + 2, XMM5);         \
+            _mm_store_pd((y) + i + 4, XMM6);         \
+            _mm_store_pd((y) + i + 6, XMM7);         \
+        }                                            \
+    }
+
+#if 3 <= __SSE__ || defined(__SSE3__)
+/*
+    Horizontal add with haddps SSE3 instruction. The work register (rw)
+    is unused.
+ */
+#define __horizontal_sum(r, rw) \
+    r = _mm_hadd_ps(r, r);      \
+    r = _mm_hadd_ps(r, r);
+
+#else
+/*
+    Horizontal add with SSE instruction. The work register (rw) is used.
+ */
+#define __horizontal_sum(r, rw)                         \
+    rw = r;                                             \
+    r = _mm_shuffle_ps(r, rw, _MM_SHUFFLE(1, 0, 3, 2)); \
+    r = _mm_add_ps(r, rw);                              \
+    rw = r;                                             \
+    r = _mm_shuffle_ps(r, rw, _MM_SHUFFLE(2, 3, 0, 1)); \
+    r = _mm_add_ps(r, rw);
+
+#endif
+
+#define vecdot(s, x, y, n)                                     \
+    {                                                          \
+        int i;                                                 \
+        __m128d XMM0 = _mm_setzero_pd();                       \
+        __m128d XMM1 = _mm_setzero_pd();                       \
+        __m128d XMM2, XMM3, XMM4, XMM5;                        \
+        for (i = 0; i < (n); i += 4)                           \
+        {                                                      \
+            XMM2 = _mm_load_pd((x) + i);                       \
+            XMM3 = _mm_load_pd((x) + i + 2);                   \
+            XMM4 = _mm_load_pd((y) + i);                       \
+            XMM5 = _mm_load_pd((y) + i + 2);                   \
+            XMM2 = _mm_mul_pd(XMM2, XMM4);                     \
+            XMM3 = _mm_mul_pd(XMM3, XMM5);                     \
+            XMM0 = _mm_add_pd(XMM0, XMM2);                     \
+            XMM1 = _mm_add_pd(XMM1, XMM3);                     \
+        }                                                      \
+        XMM0 = _mm_add_pd(XMM0, XMM1);                         \
+        XMM1 = _mm_shuffle_pd(XMM0, XMM0, _MM_SHUFFLE2(1, 1)); \
+        XMM0 = _mm_add_pd(XMM0, XMM1);                         \
+        _mm_store_sd((s), XMM0);                               \
+    }
+
+#define vec2norm(s, x, n)                                      \
+    {                                                          \
+        int i;                                                 \
+        __m128d XMM0 = _mm_setzero_pd();                       \
+        __m128d XMM1 = _mm_setzero_pd();                       \
+        __m128d XMM2, XMM3, XMM4, XMM5;                        \
+        for (i = 0; i < (n); i += 4)                           \
+        {                                                      \
+            XMM2 = _mm_load_pd((x) + i);                       \
+            XMM3 = _mm_load_pd((x) + i + 2);                   \
+            XMM4 = XMM2;                                       \
+            XMM5 = XMM3;                                       \
+            XMM2 = _mm_mul_pd(XMM2, XMM4);                     \
+            XMM3 = _mm_mul_pd(XMM3, XMM5);                     \
+            XMM0 = _mm_add_pd(XMM0, XMM2);                     \
+            XMM1 = _mm_add_pd(XMM1, XMM3);                     \
+        }                                                      \
+        XMM0 = _mm_add_pd(XMM0, XMM1);                         \
+        XMM1 = _mm_shuffle_pd(XMM0, XMM0, _MM_SHUFFLE2(1, 1)); \
+        XMM0 = _mm_add_pd(XMM0, XMM1);                         \
+        XMM0 = _mm_sqrt_pd(XMM0);                              \
+        _mm_store_sd((s), XMM0);                               \
+    }
+
+#define vec2norminv(s, x, n)                                   \
+    {                                                          \
+        int i;                                                 \
+        __m128d XMM0 = _mm_setzero_pd();                       \
+        __m128d XMM1 = _mm_setzero_pd();                       \
+        __m128d XMM2, XMM3, XMM4, XMM5;                        \
+        for (i = 0; i < (n); i += 4)                           \
+        {                                                      \
+            XMM2 = _mm_load_pd((x) + i);                       \
+            XMM3 = _mm_load_pd((x) + i + 2);                   \
+            XMM4 = XMM2;                                       \
+            XMM5 = XMM3;                                       \
+            XMM2 = _mm_mul_pd(XMM2, XMM4);                     \
+            XMM3 = _mm_mul_pd(XMM3, XMM5);                     \
+            XMM0 = _mm_add_pd(XMM0, XMM2);                     \
+            XMM1 = _mm_add_pd(XMM1, XMM3);                     \
+        }                                                      \
+        XMM2 = _mm_set1_pd(1.0);                               \
+        XMM0 = _mm_add_pd(XMM0, XMM1);                         \
+        XMM1 = _mm_shuffle_pd(XMM0, XMM0, _MM_SHUFFLE2(1, 1)); \
+        XMM0 = _mm_add_pd(XMM0, XMM1);                         \
+        XMM0 = _mm_sqrt_pd(XMM0);                              \
+        XMM2 = _mm_div_pd(XMM2, XMM0);                         \
+        _mm_store_sd((s), XMM2);                               \
+    }
```

## chaine/_core/liblbfgs/lib/arithmetic_sse_float.h

 * *Ordering differences only*

```diff
@@ -1,312 +1,312 @@
-/*
- *      SSE/SSE3 implementation of vector oprations (32bit float).
- *
- * Copyright (c) 2007-2010 Naoaki Okazaki
- * All rights reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to deal
- * in the Software without restriction, including without limitation the rights
- * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
- * copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
- * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
- * THE SOFTWARE.
- */
-
-/* $Id$ */
-
-#include <stdlib.h>
-#ifndef __APPLE__
-#include <malloc.h>
-#endif
-#include <memory.h>
-
-#if 1400 <= _MSC_VER
-#include <intrin.h>
-#endif /*_MSC_VER*/
-
-#if HAVE_XMMINTRIN_H
-#include <xmmintrin.h>
-#endif /*HAVE_XMMINTRIN_H*/
-
-#if LBFGS_FLOAT == 32 && LBFGS_IEEE_FLOAT
-#define fsigndiff(x, y) (((*(uint32_t *)(x)) ^ (*(uint32_t *)(y))) & 0x80000000U)
-#else
-#define fsigndiff(x, y) (*(x) * (*(y) / fabs(*(y))) < 0.)
-#endif /*LBFGS_IEEE_FLOAT*/
-
-inline static void *vecalloc(size_t size)
-{
-#if defined(_MSC_VER)
-    void *memblock = _aligned_malloc(size, 16);
-#elif defined(__APPLE__) /* OS X always aligns on 16-byte boundaries */
-    void *memblock = malloc(size);
-#else
-    void *memblock = NULL, *p = NULL;
-    if (posix_memalign(&p, 16, size) == 0)
-    {
-        memblock = p;
-    }
-#endif
-    if (memblock != NULL)
-    {
-        memset(memblock, 0, size);
-    }
-    return memblock;
-}
-
-inline static void vecfree(void *memblock)
-{
-#ifdef _MSC_VER
-    _aligned_free(memblock);
-#else
-    free(memblock);
-#endif
-}
-
-#define vecset(x, c, n)                       \
-    {                                         \
-        int i;                                \
-        __m128 XMM0 = _mm_set_ps1(c);         \
-        for (i = 0; i < (n); i += 16)         \
-        {                                     \
-            _mm_store_ps((x) + i, XMM0);      \
-            _mm_store_ps((x) + i + 4, XMM0);  \
-            _mm_store_ps((x) + i + 8, XMM0);  \
-            _mm_store_ps((x) + i + 12, XMM0); \
-        }                                     \
-    }
-
-#define veccpy(y, x, n)                              \
-    {                                                \
-        int i;                                       \
-        for (i = 0; i < (n); i += 16)                \
-        {                                            \
-            __m128 XMM0 = _mm_load_ps((x) + i);      \
-            __m128 XMM1 = _mm_load_ps((x) + i + 4);  \
-            __m128 XMM2 = _mm_load_ps((x) + i + 8);  \
-            __m128 XMM3 = _mm_load_ps((x) + i + 12); \
-            _mm_store_ps((y) + i, XMM0);             \
-            _mm_store_ps((y) + i + 4, XMM1);         \
-            _mm_store_ps((y) + i + 8, XMM2);         \
-            _mm_store_ps((y) + i + 12, XMM3);        \
-        }                                            \
-    }
-
-#define vecncpy(y, x, n)                             \
-    {                                                \
-        int i;                                       \
-        const uint32_t mask = 0x80000000;            \
-        __m128 XMM4 = _mm_load_ps1((float *)&mask);  \
-        for (i = 0; i < (n); i += 16)                \
-        {                                            \
-            __m128 XMM0 = _mm_load_ps((x) + i);      \
-            __m128 XMM1 = _mm_load_ps((x) + i + 4);  \
-            __m128 XMM2 = _mm_load_ps((x) + i + 8);  \
-            __m128 XMM3 = _mm_load_ps((x) + i + 12); \
-            XMM0 = _mm_xor_ps(XMM0, XMM4);           \
-            XMM1 = _mm_xor_ps(XMM1, XMM4);           \
-            XMM2 = _mm_xor_ps(XMM2, XMM4);           \
-            XMM3 = _mm_xor_ps(XMM3, XMM4);           \
-            _mm_store_ps((y) + i, XMM0);             \
-            _mm_store_ps((y) + i + 4, XMM1);         \
-            _mm_store_ps((y) + i + 8, XMM2);         \
-            _mm_store_ps((y) + i + 12, XMM3);        \
-        }                                            \
-    }
-
-#define vecadd(y, x, c, n)                          \
-    {                                               \
-        int i;                                      \
-        __m128 XMM7 = _mm_set_ps1(c);               \
-        for (i = 0; i < (n); i += 8)                \
-        {                                           \
-            __m128 XMM0 = _mm_load_ps((x) + i);     \
-            __m128 XMM1 = _mm_load_ps((x) + i + 4); \
-            __m128 XMM2 = _mm_load_ps((y) + i);     \
-            __m128 XMM3 = _mm_load_ps((y) + i + 4); \
-            XMM0 = _mm_mul_ps(XMM0, XMM7);          \
-            XMM1 = _mm_mul_ps(XMM1, XMM7);          \
-            XMM2 = _mm_add_ps(XMM2, XMM0);          \
-            XMM3 = _mm_add_ps(XMM3, XMM1);          \
-            _mm_store_ps((y) + i, XMM2);            \
-            _mm_store_ps((y) + i + 4, XMM3);        \
-        }                                           \
-    }
-
-#define vecdiff(z, x, y, n)                          \
-    {                                                \
-        int i;                                       \
-        for (i = 0; i < (n); i += 16)                \
-        {                                            \
-            __m128 XMM0 = _mm_load_ps((x) + i);      \
-            __m128 XMM1 = _mm_load_ps((x) + i + 4);  \
-            __m128 XMM2 = _mm_load_ps((x) + i + 8);  \
-            __m128 XMM3 = _mm_load_ps((x) + i + 12); \
-            __m128 XMM4 = _mm_load_ps((y) + i);      \
-            __m128 XMM5 = _mm_load_ps((y) + i + 4);  \
-            __m128 XMM6 = _mm_load_ps((y) + i + 8);  \
-            __m128 XMM7 = _mm_load_ps((y) + i + 12); \
-            XMM0 = _mm_sub_ps(XMM0, XMM4);           \
-            XMM1 = _mm_sub_ps(XMM1, XMM5);           \
-            XMM2 = _mm_sub_ps(XMM2, XMM6);           \
-            XMM3 = _mm_sub_ps(XMM3, XMM7);           \
-            _mm_store_ps((z) + i, XMM0);             \
-            _mm_store_ps((z) + i + 4, XMM1);         \
-            _mm_store_ps((z) + i + 8, XMM2);         \
-            _mm_store_ps((z) + i + 12, XMM3);        \
-        }                                            \
-    }
-
-#define vecscale(y, c, n)                           \
-    {                                               \
-        int i;                                      \
-        __m128 XMM7 = _mm_set_ps1(c);               \
-        for (i = 0; i < (n); i += 8)                \
-        {                                           \
-            __m128 XMM0 = _mm_load_ps((y) + i);     \
-            __m128 XMM1 = _mm_load_ps((y) + i + 4); \
-            XMM0 = _mm_mul_ps(XMM0, XMM7);          \
-            XMM1 = _mm_mul_ps(XMM1, XMM7);          \
-            _mm_store_ps((y) + i, XMM0);            \
-            _mm_store_ps((y) + i + 4, XMM1);        \
-        }                                           \
-    }
-
-#define vecmul(y, x, n)                              \
-    {                                                \
-        int i;                                       \
-        for (i = 0; i < (n); i += 16)                \
-        {                                            \
-            __m128 XMM0 = _mm_load_ps((x) + i);      \
-            __m128 XMM1 = _mm_load_ps((x) + i + 4);  \
-            __m128 XMM2 = _mm_load_ps((x) + i + 8);  \
-            __m128 XMM3 = _mm_load_ps((x) + i + 12); \
-            __m128 XMM4 = _mm_load_ps((y) + i);      \
-            __m128 XMM5 = _mm_load_ps((y) + i + 4);  \
-            __m128 XMM6 = _mm_load_ps((y) + i + 8);  \
-            __m128 XMM7 = _mm_load_ps((y) + i + 12); \
-            XMM4 = _mm_mul_ps(XMM4, XMM0);           \
-            XMM5 = _mm_mul_ps(XMM5, XMM1);           \
-            XMM6 = _mm_mul_ps(XMM6, XMM2);           \
-            XMM7 = _mm_mul_ps(XMM7, XMM3);           \
-            _mm_store_ps((y) + i, XMM4);             \
-            _mm_store_ps((y) + i + 4, XMM5);         \
-            _mm_store_ps((y) + i + 8, XMM6);         \
-            _mm_store_ps((y) + i + 12, XMM7);        \
-        }                                            \
-    }
-
-#if 3 <= __SSE__ || defined(__SSE3__)
-/*
-    Horizontal add with haddps SSE3 instruction. The work register (rw)
-    is unused.
- */
-#define __horizontal_sum(r, rw) \
-    r = _mm_hadd_ps(r, r);      \
-    r = _mm_hadd_ps(r, r);
-
-#else
-/*
-    Horizontal add with SSE instruction. The work register (rw) is used.
- */
-#define __horizontal_sum(r, rw)                         \
-    rw = r;                                             \
-    r = _mm_shuffle_ps(r, rw, _MM_SHUFFLE(1, 0, 3, 2)); \
-    r = _mm_add_ps(r, rw);                              \
-    rw = r;                                             \
-    r = _mm_shuffle_ps(r, rw, _MM_SHUFFLE(2, 3, 0, 1)); \
-    r = _mm_add_ps(r, rw);
-
-#endif
-
-#define vecdot(s, x, y, n)                   \
-    {                                        \
-        int i;                               \
-        __m128 XMM0 = _mm_setzero_ps();      \
-        __m128 XMM1 = _mm_setzero_ps();      \
-        __m128 XMM2, XMM3, XMM4, XMM5;       \
-        for (i = 0; i < (n); i += 8)         \
-        {                                    \
-            XMM2 = _mm_load_ps((x) + i);     \
-            XMM3 = _mm_load_ps((x) + i + 4); \
-            XMM4 = _mm_load_ps((y) + i);     \
-            XMM5 = _mm_load_ps((y) + i + 4); \
-            XMM2 = _mm_mul_ps(XMM2, XMM4);   \
-            XMM3 = _mm_mul_ps(XMM3, XMM5);   \
-            XMM0 = _mm_add_ps(XMM0, XMM2);   \
-            XMM1 = _mm_add_ps(XMM1, XMM3);   \
-        }                                    \
-        XMM0 = _mm_add_ps(XMM0, XMM1);       \
-        __horizontal_sum(XMM0, XMM1);        \
-        _mm_store_ss((s), XMM0);             \
-    }
-
-#define vec2norm(s, x, n)                           \
-    {                                               \
-        int i;                                      \
-        __m128 XMM0 = _mm_setzero_ps();             \
-        __m128 XMM1 = _mm_setzero_ps();             \
-        __m128 XMM2, XMM3;                          \
-        for (i = 0; i < (n); i += 8)                \
-        {                                           \
-            XMM2 = _mm_load_ps((x) + i);            \
-            XMM3 = _mm_load_ps((x) + i + 4);        \
-            XMM2 = _mm_mul_ps(XMM2, XMM2);          \
-            XMM3 = _mm_mul_ps(XMM3, XMM3);          \
-            XMM0 = _mm_add_ps(XMM0, XMM2);          \
-            XMM1 = _mm_add_ps(XMM1, XMM3);          \
-        }                                           \
-        XMM0 = _mm_add_ps(XMM0, XMM1);              \
-        __horizontal_sum(XMM0, XMM1);               \
-        XMM2 = XMM0;                                \
-        XMM1 = _mm_rsqrt_ss(XMM0);                  \
-        XMM3 = XMM1;                                \
-        XMM1 = _mm_mul_ss(XMM1, XMM1);              \
-        XMM1 = _mm_mul_ss(XMM1, XMM3);              \
-        XMM1 = _mm_mul_ss(XMM1, XMM0);              \
-        XMM1 = _mm_mul_ss(XMM1, _mm_set_ss(-0.5f)); \
-        XMM3 = _mm_mul_ss(XMM3, _mm_set_ss(1.5f));  \
-        XMM3 = _mm_add_ss(XMM3, XMM1);              \
-        XMM3 = _mm_mul_ss(XMM3, XMM2);              \
-        _mm_store_ss((s), XMM3);                    \
-    }
-
-#define vec2norminv(s, x, n)                        \
-    {                                               \
-        int i;                                      \
-        __m128 XMM0 = _mm_setzero_ps();             \
-        __m128 XMM1 = _mm_setzero_ps();             \
-        __m128 XMM2, XMM3;                          \
-        for (i = 0; i < (n); i += 16)               \
-        {                                           \
-            XMM2 = _mm_load_ps((x) + i);            \
-            XMM3 = _mm_load_ps((x) + i + 4);        \
-            XMM2 = _mm_mul_ps(XMM2, XMM2);          \
-            XMM3 = _mm_mul_ps(XMM3, XMM3);          \
-            XMM0 = _mm_add_ps(XMM0, XMM2);          \
-            XMM1 = _mm_add_ps(XMM1, XMM3);          \
-        }                                           \
-        XMM0 = _mm_add_ps(XMM0, XMM1);              \
-        __horizontal_sum(XMM0, XMM1);               \
-        XMM2 = XMM0;                                \
-        XMM1 = _mm_rsqrt_ss(XMM0);                  \
-        XMM3 = XMM1;                                \
-        XMM1 = _mm_mul_ss(XMM1, XMM1);              \
-        XMM1 = _mm_mul_ss(XMM1, XMM3);              \
-        XMM1 = _mm_mul_ss(XMM1, XMM0);              \
-        XMM1 = _mm_mul_ss(XMM1, _mm_set_ss(-0.5f)); \
-        XMM3 = _mm_mul_ss(XMM3, _mm_set_ss(1.5f));  \
-        XMM3 = _mm_add_ss(XMM3, XMM1);              \
-        _mm_store_ss((s), XMM3);                    \
-    }
+/*
+ *      SSE/SSE3 implementation of vector oprations (32bit float).
+ *
+ * Copyright (c) 2007-2010 Naoaki Okazaki
+ * All rights reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+
+/* $Id$ */
+
+#include <stdlib.h>
+#ifndef __APPLE__
+#include <malloc.h>
+#endif
+#include <memory.h>
+
+#if 1400 <= _MSC_VER
+#include <intrin.h>
+#endif /*_MSC_VER*/
+
+#if HAVE_XMMINTRIN_H
+#include <xmmintrin.h>
+#endif /*HAVE_XMMINTRIN_H*/
+
+#if LBFGS_FLOAT == 32 && LBFGS_IEEE_FLOAT
+#define fsigndiff(x, y) (((*(uint32_t *)(x)) ^ (*(uint32_t *)(y))) & 0x80000000U)
+#else
+#define fsigndiff(x, y) (*(x) * (*(y) / fabs(*(y))) < 0.)
+#endif /*LBFGS_IEEE_FLOAT*/
+
+inline static void *vecalloc(size_t size)
+{
+#if defined(_MSC_VER)
+    void *memblock = _aligned_malloc(size, 16);
+#elif defined(__APPLE__) /* OS X always aligns on 16-byte boundaries */
+    void *memblock = malloc(size);
+#else
+    void *memblock = NULL, *p = NULL;
+    if (posix_memalign(&p, 16, size) == 0)
+    {
+        memblock = p;
+    }
+#endif
+    if (memblock != NULL)
+    {
+        memset(memblock, 0, size);
+    }
+    return memblock;
+}
+
+inline static void vecfree(void *memblock)
+{
+#ifdef _MSC_VER
+    _aligned_free(memblock);
+#else
+    free(memblock);
+#endif
+}
+
+#define vecset(x, c, n)                       \
+    {                                         \
+        int i;                                \
+        __m128 XMM0 = _mm_set_ps1(c);         \
+        for (i = 0; i < (n); i += 16)         \
+        {                                     \
+            _mm_store_ps((x) + i, XMM0);      \
+            _mm_store_ps((x) + i + 4, XMM0);  \
+            _mm_store_ps((x) + i + 8, XMM0);  \
+            _mm_store_ps((x) + i + 12, XMM0); \
+        }                                     \
+    }
+
+#define veccpy(y, x, n)                              \
+    {                                                \
+        int i;                                       \
+        for (i = 0; i < (n); i += 16)                \
+        {                                            \
+            __m128 XMM0 = _mm_load_ps((x) + i);      \
+            __m128 XMM1 = _mm_load_ps((x) + i + 4);  \
+            __m128 XMM2 = _mm_load_ps((x) + i + 8);  \
+            __m128 XMM3 = _mm_load_ps((x) + i + 12); \
+            _mm_store_ps((y) + i, XMM0);             \
+            _mm_store_ps((y) + i + 4, XMM1);         \
+            _mm_store_ps((y) + i + 8, XMM2);         \
+            _mm_store_ps((y) + i + 12, XMM3);        \
+        }                                            \
+    }
+
+#define vecncpy(y, x, n)                             \
+    {                                                \
+        int i;                                       \
+        const uint32_t mask = 0x80000000;            \
+        __m128 XMM4 = _mm_load_ps1((float *)&mask);  \
+        for (i = 0; i < (n); i += 16)                \
+        {                                            \
+            __m128 XMM0 = _mm_load_ps((x) + i);      \
+            __m128 XMM1 = _mm_load_ps((x) + i + 4);  \
+            __m128 XMM2 = _mm_load_ps((x) + i + 8);  \
+            __m128 XMM3 = _mm_load_ps((x) + i + 12); \
+            XMM0 = _mm_xor_ps(XMM0, XMM4);           \
+            XMM1 = _mm_xor_ps(XMM1, XMM4);           \
+            XMM2 = _mm_xor_ps(XMM2, XMM4);           \
+            XMM3 = _mm_xor_ps(XMM3, XMM4);           \
+            _mm_store_ps((y) + i, XMM0);             \
+            _mm_store_ps((y) + i + 4, XMM1);         \
+            _mm_store_ps((y) + i + 8, XMM2);         \
+            _mm_store_ps((y) + i + 12, XMM3);        \
+        }                                            \
+    }
+
+#define vecadd(y, x, c, n)                          \
+    {                                               \
+        int i;                                      \
+        __m128 XMM7 = _mm_set_ps1(c);               \
+        for (i = 0; i < (n); i += 8)                \
+        {                                           \
+            __m128 XMM0 = _mm_load_ps((x) + i);     \
+            __m128 XMM1 = _mm_load_ps((x) + i + 4); \
+            __m128 XMM2 = _mm_load_ps((y) + i);     \
+            __m128 XMM3 = _mm_load_ps((y) + i + 4); \
+            XMM0 = _mm_mul_ps(XMM0, XMM7);          \
+            XMM1 = _mm_mul_ps(XMM1, XMM7);          \
+            XMM2 = _mm_add_ps(XMM2, XMM0);          \
+            XMM3 = _mm_add_ps(XMM3, XMM1);          \
+            _mm_store_ps((y) + i, XMM2);            \
+            _mm_store_ps((y) + i + 4, XMM3);        \
+        }                                           \
+    }
+
+#define vecdiff(z, x, y, n)                          \
+    {                                                \
+        int i;                                       \
+        for (i = 0; i < (n); i += 16)                \
+        {                                            \
+            __m128 XMM0 = _mm_load_ps((x) + i);      \
+            __m128 XMM1 = _mm_load_ps((x) + i + 4);  \
+            __m128 XMM2 = _mm_load_ps((x) + i + 8);  \
+            __m128 XMM3 = _mm_load_ps((x) + i + 12); \
+            __m128 XMM4 = _mm_load_ps((y) + i);      \
+            __m128 XMM5 = _mm_load_ps((y) + i + 4);  \
+            __m128 XMM6 = _mm_load_ps((y) + i + 8);  \
+            __m128 XMM7 = _mm_load_ps((y) + i + 12); \
+            XMM0 = _mm_sub_ps(XMM0, XMM4);           \
+            XMM1 = _mm_sub_ps(XMM1, XMM5);           \
+            XMM2 = _mm_sub_ps(XMM2, XMM6);           \
+            XMM3 = _mm_sub_ps(XMM3, XMM7);           \
+            _mm_store_ps((z) + i, XMM0);             \
+            _mm_store_ps((z) + i + 4, XMM1);         \
+            _mm_store_ps((z) + i + 8, XMM2);         \
+            _mm_store_ps((z) + i + 12, XMM3);        \
+        }                                            \
+    }
+
+#define vecscale(y, c, n)                           \
+    {                                               \
+        int i;                                      \
+        __m128 XMM7 = _mm_set_ps1(c);               \
+        for (i = 0; i < (n); i += 8)                \
+        {                                           \
+            __m128 XMM0 = _mm_load_ps((y) + i);     \
+            __m128 XMM1 = _mm_load_ps((y) + i + 4); \
+            XMM0 = _mm_mul_ps(XMM0, XMM7);          \
+            XMM1 = _mm_mul_ps(XMM1, XMM7);          \
+            _mm_store_ps((y) + i, XMM0);            \
+            _mm_store_ps((y) + i + 4, XMM1);        \
+        }                                           \
+    }
+
+#define vecmul(y, x, n)                              \
+    {                                                \
+        int i;                                       \
+        for (i = 0; i < (n); i += 16)                \
+        {                                            \
+            __m128 XMM0 = _mm_load_ps((x) + i);      \
+            __m128 XMM1 = _mm_load_ps((x) + i + 4);  \
+            __m128 XMM2 = _mm_load_ps((x) + i + 8);  \
+            __m128 XMM3 = _mm_load_ps((x) + i + 12); \
+            __m128 XMM4 = _mm_load_ps((y) + i);      \
+            __m128 XMM5 = _mm_load_ps((y) + i + 4);  \
+            __m128 XMM6 = _mm_load_ps((y) + i + 8);  \
+            __m128 XMM7 = _mm_load_ps((y) + i + 12); \
+            XMM4 = _mm_mul_ps(XMM4, XMM0);           \
+            XMM5 = _mm_mul_ps(XMM5, XMM1);           \
+            XMM6 = _mm_mul_ps(XMM6, XMM2);           \
+            XMM7 = _mm_mul_ps(XMM7, XMM3);           \
+            _mm_store_ps((y) + i, XMM4);             \
+            _mm_store_ps((y) + i + 4, XMM5);         \
+            _mm_store_ps((y) + i + 8, XMM6);         \
+            _mm_store_ps((y) + i + 12, XMM7);        \
+        }                                            \
+    }
+
+#if 3 <= __SSE__ || defined(__SSE3__)
+/*
+    Horizontal add with haddps SSE3 instruction. The work register (rw)
+    is unused.
+ */
+#define __horizontal_sum(r, rw) \
+    r = _mm_hadd_ps(r, r);      \
+    r = _mm_hadd_ps(r, r);
+
+#else
+/*
+    Horizontal add with SSE instruction. The work register (rw) is used.
+ */
+#define __horizontal_sum(r, rw)                         \
+    rw = r;                                             \
+    r = _mm_shuffle_ps(r, rw, _MM_SHUFFLE(1, 0, 3, 2)); \
+    r = _mm_add_ps(r, rw);                              \
+    rw = r;                                             \
+    r = _mm_shuffle_ps(r, rw, _MM_SHUFFLE(2, 3, 0, 1)); \
+    r = _mm_add_ps(r, rw);
+
+#endif
+
+#define vecdot(s, x, y, n)                   \
+    {                                        \
+        int i;                               \
+        __m128 XMM0 = _mm_setzero_ps();      \
+        __m128 XMM1 = _mm_setzero_ps();      \
+        __m128 XMM2, XMM3, XMM4, XMM5;       \
+        for (i = 0; i < (n); i += 8)         \
+        {                                    \
+            XMM2 = _mm_load_ps((x) + i);     \
+            XMM3 = _mm_load_ps((x) + i + 4); \
+            XMM4 = _mm_load_ps((y) + i);     \
+            XMM5 = _mm_load_ps((y) + i + 4); \
+            XMM2 = _mm_mul_ps(XMM2, XMM4);   \
+            XMM3 = _mm_mul_ps(XMM3, XMM5);   \
+            XMM0 = _mm_add_ps(XMM0, XMM2);   \
+            XMM1 = _mm_add_ps(XMM1, XMM3);   \
+        }                                    \
+        XMM0 = _mm_add_ps(XMM0, XMM1);       \
+        __horizontal_sum(XMM0, XMM1);        \
+        _mm_store_ss((s), XMM0);             \
+    }
+
+#define vec2norm(s, x, n)                           \
+    {                                               \
+        int i;                                      \
+        __m128 XMM0 = _mm_setzero_ps();             \
+        __m128 XMM1 = _mm_setzero_ps();             \
+        __m128 XMM2, XMM3;                          \
+        for (i = 0; i < (n); i += 8)                \
+        {                                           \
+            XMM2 = _mm_load_ps((x) + i);            \
+            XMM3 = _mm_load_ps((x) + i + 4);        \
+            XMM2 = _mm_mul_ps(XMM2, XMM2);          \
+            XMM3 = _mm_mul_ps(XMM3, XMM3);          \
+            XMM0 = _mm_add_ps(XMM0, XMM2);          \
+            XMM1 = _mm_add_ps(XMM1, XMM3);          \
+        }                                           \
+        XMM0 = _mm_add_ps(XMM0, XMM1);              \
+        __horizontal_sum(XMM0, XMM1);               \
+        XMM2 = XMM0;                                \
+        XMM1 = _mm_rsqrt_ss(XMM0);                  \
+        XMM3 = XMM1;                                \
+        XMM1 = _mm_mul_ss(XMM1, XMM1);              \
+        XMM1 = _mm_mul_ss(XMM1, XMM3);              \
+        XMM1 = _mm_mul_ss(XMM1, XMM0);              \
+        XMM1 = _mm_mul_ss(XMM1, _mm_set_ss(-0.5f)); \
+        XMM3 = _mm_mul_ss(XMM3, _mm_set_ss(1.5f));  \
+        XMM3 = _mm_add_ss(XMM3, XMM1);              \
+        XMM3 = _mm_mul_ss(XMM3, XMM2);              \
+        _mm_store_ss((s), XMM3);                    \
+    }
+
+#define vec2norminv(s, x, n)                        \
+    {                                               \
+        int i;                                      \
+        __m128 XMM0 = _mm_setzero_ps();             \
+        __m128 XMM1 = _mm_setzero_ps();             \
+        __m128 XMM2, XMM3;                          \
+        for (i = 0; i < (n); i += 16)               \
+        {                                           \
+            XMM2 = _mm_load_ps((x) + i);            \
+            XMM3 = _mm_load_ps((x) + i + 4);        \
+            XMM2 = _mm_mul_ps(XMM2, XMM2);          \
+            XMM3 = _mm_mul_ps(XMM3, XMM3);          \
+            XMM0 = _mm_add_ps(XMM0, XMM2);          \
+            XMM1 = _mm_add_ps(XMM1, XMM3);          \
+        }                                           \
+        XMM0 = _mm_add_ps(XMM0, XMM1);              \
+        __horizontal_sum(XMM0, XMM1);               \
+        XMM2 = XMM0;                                \
+        XMM1 = _mm_rsqrt_ss(XMM0);                  \
+        XMM3 = XMM1;                                \
+        XMM1 = _mm_mul_ss(XMM1, XMM1);              \
+        XMM1 = _mm_mul_ss(XMM1, XMM3);              \
+        XMM1 = _mm_mul_ss(XMM1, XMM0);              \
+        XMM1 = _mm_mul_ss(XMM1, _mm_set_ss(-0.5f)); \
+        XMM3 = _mm_mul_ss(XMM3, _mm_set_ss(1.5f));  \
+        XMM3 = _mm_add_ss(XMM3, XMM1);              \
+        _mm_store_ss((s), XMM3);                    \
+    }
```

## chaine/_core/liblbfgs/lib/lbfgs.c

 * *Ordering differences only*

```diff
@@ -1,1531 +1,1531 @@
-/*
- *      Limited memory BFGS (L-BFGS).
- *
- * Copyright (c) 1990, Jorge Nocedal
- * Copyright (c) 2007-2010 Naoaki Okazaki
- * All rights reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to deal
- * in the Software without restriction, including without limitation the rights
- * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
- * copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
- * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
- * THE SOFTWARE.
- */
-
-/* $Id$ */
-
-/*
-This library is a C port of the FORTRAN implementation of Limited-memory
-Broyden-Fletcher-Goldfarb-Shanno (L-BFGS) method written by Jorge Nocedal.
-The original FORTRAN source code is available at:
-http://www.ece.northwestern.edu/~nocedal/lbfgs.html
-
-The L-BFGS algorithm is described in:
-    - Jorge Nocedal.
-      Updating Quasi-Newton Matrices with Limited Storage.
-      <i>Mathematics of Computation</i>, Vol. 35, No. 151, pp. 773--782, 1980.
-    - Dong C. Liu and Jorge Nocedal.
-      On the limited memory BFGS method for large scale optimization.
-      <i>Mathematical Programming</i> B, Vol. 45, No. 3, pp. 503-528, 1989.
-
-The line search algorithms used in this implementation are described in:
-    - John E. Dennis and Robert B. Schnabel.
-      <i>Numerical Methods for Unconstrained Optimization and Nonlinear
-      Equations</i>, Englewood Cliffs, 1983.
-    - Jorge J. More and David J. Thuente.
-      Line search algorithm with guaranteed sufficient decrease.
-      <i>ACM Transactions on Mathematical Software (TOMS)</i>, Vol. 20, No. 3,
-      pp. 286-307, 1994.
-
-This library also implements Orthant-Wise Limited-memory Quasi-Newton (OWL-QN)
-method presented in:
-    - Galen Andrew and Jianfeng Gao.
-      Scalable training of L1-regularized log-linear models.
-      In <i>Proceedings of the 24th International Conference on Machine
-      Learning (ICML 2007)</i>, pp. 33-40, 2007.
-
-I would like to thank the original author, Jorge Nocedal, who has been
-distributing the effieicnt and explanatory implementation in an open source
-licence.
-*/
-
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif /*HAVE_CONFIG_H*/
-
-#include <stdint.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <math.h>
-
-#include <lbfgs.h>
-
-#ifdef _MSC_VER
-#define inline __inline
-#endif /*_MSC_VER*/
-
-#if defined(USE_SSE) && defined(__SSE2__) && LBFGS_FLOAT == 64
-/* Use SSE2 optimization for 64bit double precision. */
-#include "arithmetic_sse_double.h"
-
-#elif defined(USE_SSE) && defined(__SSE__) && LBFGS_FLOAT == 32
-/* Use SSE optimization for 32bit float precision. */
-#include "arithmetic_sse_float.h"
-
-#else
-/* No CPU specific optimization. */
-#include "arithmetic_ansi.h"
-
-#endif
-
-#define min2(a, b) ((a) <= (b) ? (a) : (b))
-#define max2(a, b) ((a) >= (b) ? (a) : (b))
-#define max3(a, b, c) max2(max2((a), (b)), (c));
-
-struct tag_callback_data
-{
-    int n;
-    void *instance;
-    lbfgs_evaluate_t proc_evaluate;
-    lbfgs_progress_t proc_progress;
-};
-typedef struct tag_callback_data callback_data_t;
-
-struct tag_iteration_data
-{
-    lbfgsfloatval_t alpha;
-    lbfgsfloatval_t *s; /* [n] */
-    lbfgsfloatval_t *y; /* [n] */
-    lbfgsfloatval_t ys; /* vecdot(y, s) */
-};
-typedef struct tag_iteration_data iteration_data_t;
-
-static const lbfgs_parameter_t _defparam = {
-    6,
-    1e-5,
-    0,
-    1e-5,
-    0,
-    LBFGS_LINESEARCH_DEFAULT,
-    40,
-    1e-20,
-    1e20,
-    1e-4,
-    0.9,
-    0.9,
-    1.0e-16,
-    0.0,
-    0,
-    -1,
-};
-
-/* Forward function declarations. */
-
-typedef int (*line_search_proc)(
-    int n,
-    lbfgsfloatval_t *x,
-    lbfgsfloatval_t *f,
-    lbfgsfloatval_t *g,
-    lbfgsfloatval_t *s,
-    lbfgsfloatval_t *stp,
-    const lbfgsfloatval_t *xp,
-    const lbfgsfloatval_t *gp,
-    lbfgsfloatval_t *wa,
-    callback_data_t *cd,
-    const lbfgs_parameter_t *param);
-
-static int line_search_backtracking(
-    int n,
-    lbfgsfloatval_t *x,
-    lbfgsfloatval_t *f,
-    lbfgsfloatval_t *g,
-    lbfgsfloatval_t *s,
-    lbfgsfloatval_t *stp,
-    const lbfgsfloatval_t *xp,
-    const lbfgsfloatval_t *gp,
-    lbfgsfloatval_t *wa,
-    callback_data_t *cd,
-    const lbfgs_parameter_t *param);
-
-static int line_search_backtracking_owlqn(
-    int n,
-    lbfgsfloatval_t *x,
-    lbfgsfloatval_t *f,
-    lbfgsfloatval_t *g,
-    lbfgsfloatval_t *s,
-    lbfgsfloatval_t *stp,
-    const lbfgsfloatval_t *xp,
-    const lbfgsfloatval_t *gp,
-    lbfgsfloatval_t *wp,
-    callback_data_t *cd,
-    const lbfgs_parameter_t *param);
-
-static int line_search_morethuente(
-    int n,
-    lbfgsfloatval_t *x,
-    lbfgsfloatval_t *f,
-    lbfgsfloatval_t *g,
-    lbfgsfloatval_t *s,
-    lbfgsfloatval_t *stp,
-    const lbfgsfloatval_t *xp,
-    const lbfgsfloatval_t *gp,
-    lbfgsfloatval_t *wa,
-    callback_data_t *cd,
-    const lbfgs_parameter_t *param);
-
-static int update_trial_interval(
-    lbfgsfloatval_t *x,
-    lbfgsfloatval_t *fx,
-    lbfgsfloatval_t *dx,
-    lbfgsfloatval_t *y,
-    lbfgsfloatval_t *fy,
-    lbfgsfloatval_t *dy,
-    lbfgsfloatval_t *t,
-    lbfgsfloatval_t *ft,
-    lbfgsfloatval_t *dt,
-    const lbfgsfloatval_t tmin,
-    const lbfgsfloatval_t tmax,
-    int *brackt);
-
-static lbfgsfloatval_t owlqn_x1norm(
-    const lbfgsfloatval_t *x,
-    const int start,
-    const int n);
-
-static void owlqn_pseudo_gradient(
-    lbfgsfloatval_t *pg,
-    const lbfgsfloatval_t *x,
-    const lbfgsfloatval_t *g,
-    const int n,
-    const lbfgsfloatval_t c,
-    const int start,
-    const int end);
-
-static void owlqn_project(
-    lbfgsfloatval_t *d,
-    const lbfgsfloatval_t *sign,
-    const int start,
-    const int end);
-
-#if defined(USE_SSE) && (defined(__SSE__) || defined(__SSE2__))
-static int round_out_variables(int n)
-{
-    n += 7;
-    n /= 8;
-    n *= 8;
-    return n;
-}
-#endif /*defined(USE_SSE)*/
-
-lbfgsfloatval_t *lbfgs_malloc(int n)
-{
-#if defined(USE_SSE) && (defined(__SSE__) || defined(__SSE2__))
-    n = round_out_variables(n);
-#endif /*defined(USE_SSE)*/
-    return (lbfgsfloatval_t *)vecalloc(sizeof(lbfgsfloatval_t) * n);
-}
-
-void lbfgs_free(lbfgsfloatval_t *x)
-{
-    vecfree(x);
-}
-
-void lbfgs_parameter_init(lbfgs_parameter_t *param)
-{
-    memcpy(param, &_defparam, sizeof(*param));
-}
-
-int lbfgs(
-    int n,
-    lbfgsfloatval_t *x,
-    lbfgsfloatval_t *ptr_fx,
-    lbfgs_evaluate_t proc_evaluate,
-    lbfgs_progress_t proc_progress,
-    void *instance,
-    lbfgs_parameter_t *_param)
-{
-    int ret;
-    int i, j, k, ls, end, bound;
-    lbfgsfloatval_t step;
-
-    /* Constant parameters and their default values. */
-    lbfgs_parameter_t param = (_param != NULL) ? (*_param) : _defparam;
-    const int m = param.m;
-
-    lbfgsfloatval_t *xp = NULL;
-    lbfgsfloatval_t *g = NULL, *gp = NULL, *pg = NULL;
-    lbfgsfloatval_t *d = NULL, *w = NULL, *pf = NULL;
-    iteration_data_t *lm = NULL, *it = NULL;
-    lbfgsfloatval_t ys, yy;
-    lbfgsfloatval_t xnorm, gnorm, beta;
-    lbfgsfloatval_t fx = 0.;
-    lbfgsfloatval_t rate = 0.;
-    line_search_proc linesearch = line_search_morethuente;
-
-    /* Construct a callback data. */
-    callback_data_t cd;
-    cd.n = n;
-    cd.instance = instance;
-    cd.proc_evaluate = proc_evaluate;
-    cd.proc_progress = proc_progress;
-
-#if defined(USE_SSE) && (defined(__SSE__) || defined(__SSE2__))
-    /* Round out the number of variables. */
-    n = round_out_variables(n);
-#endif /*defined(USE_SSE)*/
-
-    /* Check the input parameters for errors. */
-    if (n <= 0)
-    {
-        return LBFGSERR_INVALID_N;
-    }
-#if defined(USE_SSE) && (defined(__SSE__) || defined(__SSE2__))
-    if (n % 8 != 0)
-    {
-        return LBFGSERR_INVALID_N_SSE;
-    }
-    if ((uintptr_t)(const void *)x % 16 != 0)
-    {
-        return LBFGSERR_INVALID_X_SSE;
-    }
-#endif /*defined(USE_SSE)*/
-    if (param.epsilon < 0.)
-    {
-        return LBFGSERR_INVALID_EPSILON;
-    }
-    if (param.past < 0)
-    {
-        return LBFGSERR_INVALID_TESTPERIOD;
-    }
-    if (param.delta < 0.)
-    {
-        return LBFGSERR_INVALID_DELTA;
-    }
-    if (param.min_step < 0.)
-    {
-        return LBFGSERR_INVALID_MINSTEP;
-    }
-    if (param.max_step < param.min_step)
-    {
-        return LBFGSERR_INVALID_MAXSTEP;
-    }
-    if (param.ftol < 0.)
-    {
-        return LBFGSERR_INVALID_FTOL;
-    }
-    if (param.linesearch == LBFGS_LINESEARCH_BACKTRACKING_WOLFE ||
-        param.linesearch == LBFGS_LINESEARCH_BACKTRACKING_STRONG_WOLFE)
-    {
-        if (param.wolfe <= param.ftol || 1. <= param.wolfe)
-        {
-            return LBFGSERR_INVALID_WOLFE;
-        }
-    }
-    if (param.gtol < 0.)
-    {
-        return LBFGSERR_INVALID_GTOL;
-    }
-    if (param.xtol < 0.)
-    {
-        return LBFGSERR_INVALID_XTOL;
-    }
-    if (param.max_linesearch <= 0)
-    {
-        return LBFGSERR_INVALID_MAXLINESEARCH;
-    }
-    if (param.orthantwise_c < 0.)
-    {
-        return LBFGSERR_INVALID_ORTHANTWISE;
-    }
-    if (param.orthantwise_start < 0 || n < param.orthantwise_start)
-    {
-        return LBFGSERR_INVALID_ORTHANTWISE_START;
-    }
-    if (param.orthantwise_end < 0)
-    {
-        param.orthantwise_end = n;
-    }
-    if (n < param.orthantwise_end)
-    {
-        return LBFGSERR_INVALID_ORTHANTWISE_END;
-    }
-    if (param.orthantwise_c != 0.)
-    {
-        switch (param.linesearch)
-        {
-        case LBFGS_LINESEARCH_BACKTRACKING:
-            linesearch = line_search_backtracking_owlqn;
-            break;
-        default:
-            /* Only the backtracking method is available. */
-            return LBFGSERR_INVALID_LINESEARCH;
-        }
-    }
-    else
-    {
-        switch (param.linesearch)
-        {
-        case LBFGS_LINESEARCH_MORETHUENTE:
-            linesearch = line_search_morethuente;
-            break;
-        case LBFGS_LINESEARCH_BACKTRACKING_ARMIJO:
-        case LBFGS_LINESEARCH_BACKTRACKING_WOLFE:
-        case LBFGS_LINESEARCH_BACKTRACKING_STRONG_WOLFE:
-            linesearch = line_search_backtracking;
-            break;
-        default:
-            return LBFGSERR_INVALID_LINESEARCH;
-        }
-    }
-
-    /* Allocate working space. */
-    xp = (lbfgsfloatval_t *)vecalloc(n * sizeof(lbfgsfloatval_t));
-    g = (lbfgsfloatval_t *)vecalloc(n * sizeof(lbfgsfloatval_t));
-    gp = (lbfgsfloatval_t *)vecalloc(n * sizeof(lbfgsfloatval_t));
-    d = (lbfgsfloatval_t *)vecalloc(n * sizeof(lbfgsfloatval_t));
-    w = (lbfgsfloatval_t *)vecalloc(n * sizeof(lbfgsfloatval_t));
-    if (xp == NULL || g == NULL || gp == NULL || d == NULL || w == NULL)
-    {
-        ret = LBFGSERR_OUTOFMEMORY;
-        goto lbfgs_exit;
-    }
-
-    if (param.orthantwise_c != 0.)
-    {
-        /* Allocate working space for OW-LQN. */
-        pg = (lbfgsfloatval_t *)vecalloc(n * sizeof(lbfgsfloatval_t));
-        if (pg == NULL)
-        {
-            ret = LBFGSERR_OUTOFMEMORY;
-            goto lbfgs_exit;
-        }
-    }
-
-    /* Allocate limited memory storage. */
-    lm = (iteration_data_t *)vecalloc(m * sizeof(iteration_data_t));
-    if (lm == NULL)
-    {
-        ret = LBFGSERR_OUTOFMEMORY;
-        goto lbfgs_exit;
-    }
-
-    /* Initialize the limited memory. */
-    for (i = 0; i < m; ++i)
-    {
-        it = &lm[i];
-        it->alpha = 0;
-        it->ys = 0;
-        it->s = (lbfgsfloatval_t *)vecalloc(n * sizeof(lbfgsfloatval_t));
-        it->y = (lbfgsfloatval_t *)vecalloc(n * sizeof(lbfgsfloatval_t));
-        if (it->s == NULL || it->y == NULL)
-        {
-            ret = LBFGSERR_OUTOFMEMORY;
-            goto lbfgs_exit;
-        }
-    }
-
-    /* Allocate an array for storing previous values of the objective function. */
-    if (0 < param.past)
-    {
-        pf = (lbfgsfloatval_t *)vecalloc(param.past * sizeof(lbfgsfloatval_t));
-    }
-
-    /* Evaluate the function value and its gradient. */
-    fx = cd.proc_evaluate(cd.instance, x, g, cd.n, 0);
-    if (0. != param.orthantwise_c)
-    {
-        /* Compute the L1 norm of the variable and add it to the object value. */
-        xnorm = owlqn_x1norm(x, param.orthantwise_start, param.orthantwise_end);
-        fx += xnorm * param.orthantwise_c;
-        owlqn_pseudo_gradient(
-            pg, x, g, n,
-            param.orthantwise_c, param.orthantwise_start, param.orthantwise_end);
-    }
-
-    /* Store the initial value of the objective function. */
-    if (pf != NULL)
-    {
-        pf[0] = fx;
-    }
-
-    /*
-        Compute the direction;
-        we assume the initial hessian matrix H_0 as the identity matrix.
-     */
-    if (param.orthantwise_c == 0.)
-    {
-        vecncpy(d, g, n);
-    }
-    else
-    {
-        vecncpy(d, pg, n);
-    }
-
-    /*
-       Make sure that the initial variables are not a minimizer.
-     */
-    vec2norm(&xnorm, x, n);
-    if (param.orthantwise_c == 0.)
-    {
-        vec2norm(&gnorm, g, n);
-    }
-    else
-    {
-        vec2norm(&gnorm, pg, n);
-    }
-    if (xnorm < 1.0)
-        xnorm = 1.0;
-    if (gnorm / xnorm <= param.epsilon)
-    {
-        ret = LBFGS_ALREADY_MINIMIZED;
-        goto lbfgs_exit;
-    }
-
-    /* Compute the initial step:
-        step = 1.0 / sqrt(vecdot(d, d, n))
-     */
-    vec2norminv(&step, d, n);
-
-    k = 1;
-    end = 0;
-    for (;;)
-    {
-        /* Store the current position and gradient vectors. */
-        veccpy(xp, x, n);
-        veccpy(gp, g, n);
-
-        /* Search for an optimal step. */
-        if (param.orthantwise_c == 0.)
-        {
-            ls = linesearch(n, x, &fx, g, d, &step, xp, gp, w, &cd, &param);
-        }
-        else
-        {
-            ls = linesearch(n, x, &fx, g, d, &step, xp, pg, w, &cd, &param);
-            owlqn_pseudo_gradient(
-                pg, x, g, n,
-                param.orthantwise_c, param.orthantwise_start, param.orthantwise_end);
-        }
-        if (ls < 0)
-        {
-            /* Revert to the previous point. */
-            veccpy(x, xp, n);
-            veccpy(g, gp, n);
-            ret = ls;
-            goto lbfgs_exit;
-        }
-
-        /* Compute x and g norms. */
-        vec2norm(&xnorm, x, n);
-        if (param.orthantwise_c == 0.)
-        {
-            vec2norm(&gnorm, g, n);
-        }
-        else
-        {
-            vec2norm(&gnorm, pg, n);
-        }
-
-        /* Report the progress. */
-        if (cd.proc_progress)
-        {
-            if ((ret = cd.proc_progress(cd.instance, x, g, fx, xnorm, gnorm, step, cd.n, k, ls)))
-            {
-                goto lbfgs_exit;
-            }
-        }
-
-        /*
-            Convergence test.
-            The criterion is given by the following formula:
-                |g(x)| / \max(1, |x|) < \epsilon
-         */
-        if (xnorm < 1.0)
-            xnorm = 1.0;
-        if (gnorm / xnorm <= param.epsilon)
-        {
-            /* Convergence. */
-            ret = LBFGS_SUCCESS;
-            break;
-        }
-
-        /*
-            Test for stopping criterion.
-            The criterion is given by the following formula:
-                (f(past_x) - f(x)) / f(x) < \delta
-         */
-        if (pf != NULL)
-        {
-            /* We don't test the stopping criterion while k < past. */
-            if (param.past <= k)
-            {
-                /* Compute the relative improvement from the past. */
-                rate = (pf[k % param.past] - fx) / fx;
-
-                /* The stopping criterion. */
-                if (rate < param.delta)
-                {
-                    ret = LBFGS_STOP;
-                    break;
-                }
-            }
-
-            /* Store the current value of the objective function. */
-            pf[k % param.past] = fx;
-        }
-
-        if (param.max_iterations != 0 && param.max_iterations < k + 1)
-        {
-            /* Maximum number of iterations. */
-            ret = LBFGSERR_MAXIMUMITERATION;
-            break;
-        }
-
-        /*
-            Update vectors s and y:
-                s_{k+1} = x_{k+1} - x_{k} = \step * d_{k}.
-                y_{k+1} = g_{k+1} - g_{k}.
-         */
-        it = &lm[end];
-        vecdiff(it->s, x, xp, n);
-        vecdiff(it->y, g, gp, n);
-
-        /*
-            Compute scalars ys and yy:
-                ys = y^t \cdot s = 1 / \rho.
-                yy = y^t \cdot y.
-            Notice that yy is used for scaling the hessian matrix H_0 (Cholesky factor).
-         */
-        vecdot(&ys, it->y, it->s, n);
-        vecdot(&yy, it->y, it->y, n);
-        it->ys = ys;
-
-        /*
-            Recursive formula to compute dir = -(H \cdot g).
-                This is described in page 779 of:
-                Jorge Nocedal.
-                Updating Quasi-Newton Matrices with Limited Storage.
-                Mathematics of Computation, Vol. 35, No. 151,
-                pp. 773--782, 1980.
-         */
-        bound = (m <= k) ? m : k;
-        ++k;
-        end = (end + 1) % m;
-
-        /* Compute the steepest direction. */
-        if (param.orthantwise_c == 0.)
-        {
-            /* Compute the negative of gradients. */
-            vecncpy(d, g, n);
-        }
-        else
-        {
-            vecncpy(d, pg, n);
-        }
-
-        j = end;
-        for (i = 0; i < bound; ++i)
-        {
-            j = (j + m - 1) % m; /* if (--j == -1) j = m-1; */
-            it = &lm[j];
-            /* \alpha_{j} = \rho_{j} s^{t}_{j} \cdot q_{k+1}. */
-            vecdot(&it->alpha, it->s, d, n);
-            it->alpha /= it->ys;
-            /* q_{i} = q_{i+1} - \alpha_{i} y_{i}. */
-            vecadd(d, it->y, -it->alpha, n);
-        }
-
-        vecscale(d, ys / yy, n);
-
-        for (i = 0; i < bound; ++i)
-        {
-            it = &lm[j];
-            /* \beta_{j} = \rho_{j} y^t_{j} \cdot \gamma_{i}. */
-            vecdot(&beta, it->y, d, n);
-            beta /= it->ys;
-            /* \gamma_{i+1} = \gamma_{i} + (\alpha_{j} - \beta_{j}) s_{j}. */
-            vecadd(d, it->s, it->alpha - beta, n);
-            j = (j + 1) % m; /* if (++j == m) j = 0; */
-        }
-
-        /*
-            Constrain the search direction for orthant-wise updates.
-         */
-        if (param.orthantwise_c != 0.)
-        {
-            for (i = param.orthantwise_start; i < param.orthantwise_end; ++i)
-            {
-                if (d[i] * pg[i] >= 0)
-                {
-                    d[i] = 0;
-                }
-            }
-        }
-
-        /*
-            Now the search direction d is ready. We try step = 1 first.
-         */
-        step = 1.0;
-    }
-
-lbfgs_exit:
-    /* Return the final value of the objective function. */
-    if (ptr_fx != NULL)
-    {
-        *ptr_fx = fx;
-    }
-
-    vecfree(pf);
-
-    /* Free memory blocks used by this function. */
-    if (lm != NULL)
-    {
-        for (i = 0; i < m; ++i)
-        {
-            vecfree(lm[i].s);
-            vecfree(lm[i].y);
-        }
-        vecfree(lm);
-    }
-    vecfree(pg);
-    vecfree(w);
-    vecfree(d);
-    vecfree(gp);
-    vecfree(g);
-    vecfree(xp);
-
-    return ret;
-}
-
-static int line_search_backtracking(
-    int n,
-    lbfgsfloatval_t *x,
-    lbfgsfloatval_t *f,
-    lbfgsfloatval_t *g,
-    lbfgsfloatval_t *s,
-    lbfgsfloatval_t *stp,
-    const lbfgsfloatval_t *xp,
-    const lbfgsfloatval_t *gp,
-    lbfgsfloatval_t *wp,
-    callback_data_t *cd,
-    const lbfgs_parameter_t *param)
-{
-    int count = 0;
-    lbfgsfloatval_t width, dg;
-    lbfgsfloatval_t finit, dginit = 0., dgtest;
-    const lbfgsfloatval_t dec = 0.5, inc = 2.1;
-
-    /* Check the input parameters for errors. */
-    if (*stp <= 0.)
-    {
-        return LBFGSERR_INVALIDPARAMETERS;
-    }
-
-    /* Compute the initial gradient in the search direction. */
-    vecdot(&dginit, g, s, n);
-
-    /* Make sure that s points to a descent direction. */
-    if (0 < dginit)
-    {
-        return LBFGSERR_INCREASEGRADIENT;
-    }
-
-    /* The initial value of the objective function. */
-    finit = *f;
-    dgtest = param->ftol * dginit;
-
-    for (;;)
-    {
-        veccpy(x, xp, n);
-        vecadd(x, s, *stp, n);
-
-        /* Evaluate the function and gradient values. */
-        *f = cd->proc_evaluate(cd->instance, x, g, cd->n, *stp);
-
-        ++count;
-
-        if (*f > finit + *stp * dgtest)
-        {
-            width = dec;
-        }
-        else
-        {
-            /* The sufficient decrease condition (Armijo condition). */
-            if (param->linesearch == LBFGS_LINESEARCH_BACKTRACKING_ARMIJO)
-            {
-                /* Exit with the Armijo condition. */
-                return count;
-            }
-
-            /* Check the Wolfe condition. */
-            vecdot(&dg, g, s, n);
-            if (dg < param->wolfe * dginit)
-            {
-                width = inc;
-            }
-            else
-            {
-                if (param->linesearch == LBFGS_LINESEARCH_BACKTRACKING_WOLFE)
-                {
-                    /* Exit with the regular Wolfe condition. */
-                    return count;
-                }
-
-                /* Check the strong Wolfe condition. */
-                if (dg > -param->wolfe * dginit)
-                {
-                    width = dec;
-                }
-                else
-                {
-                    /* Exit with the strong Wolfe condition. */
-                    return count;
-                }
-            }
-        }
-
-        if (*stp < param->min_step)
-        {
-            /* The step is the minimum value. */
-            return LBFGSERR_MINIMUMSTEP;
-        }
-        if (*stp > param->max_step)
-        {
-            /* The step is the maximum value. */
-            return LBFGSERR_MAXIMUMSTEP;
-        }
-        if (param->max_linesearch <= count)
-        {
-            /* Maximum number of iteration. */
-            return LBFGSERR_MAXIMUMLINESEARCH;
-        }
-
-        (*stp) *= width;
-    }
-}
-
-static int line_search_backtracking_owlqn(
-    int n,
-    lbfgsfloatval_t *x,
-    lbfgsfloatval_t *f,
-    lbfgsfloatval_t *g,
-    lbfgsfloatval_t *s,
-    lbfgsfloatval_t *stp,
-    const lbfgsfloatval_t *xp,
-    const lbfgsfloatval_t *gp,
-    lbfgsfloatval_t *wp,
-    callback_data_t *cd,
-    const lbfgs_parameter_t *param)
-{
-    int i, count = 0;
-    lbfgsfloatval_t width = 0.5, norm = 0.;
-    lbfgsfloatval_t finit = *f, dgtest;
-
-    /* Check the input parameters for errors. */
-    if (*stp <= 0.)
-    {
-        return LBFGSERR_INVALIDPARAMETERS;
-    }
-
-    /* Choose the orthant for the new point. */
-    for (i = 0; i < n; ++i)
-    {
-        wp[i] = (xp[i] == 0.) ? -gp[i] : xp[i];
-    }
-
-    for (;;)
-    {
-        /* Update the current point. */
-        veccpy(x, xp, n);
-        vecadd(x, s, *stp, n);
-
-        /* The current point is projected onto the orthant. */
-        owlqn_project(x, wp, param->orthantwise_start, param->orthantwise_end);
-
-        /* Evaluate the function and gradient values. */
-        *f = cd->proc_evaluate(cd->instance, x, g, cd->n, *stp);
-
-        /* Compute the L1 norm of the variables and add it to the object value. */
-        norm = owlqn_x1norm(x, param->orthantwise_start, param->orthantwise_end);
-        *f += norm * param->orthantwise_c;
-
-        ++count;
-
-        dgtest = 0.;
-        for (i = 0; i < n; ++i)
-        {
-            dgtest += (x[i] - xp[i]) * gp[i];
-        }
-
-        if (*f <= finit + param->ftol * dgtest)
-        {
-            /* The sufficient decrease condition. */
-            return count;
-        }
-
-        if (*stp < param->min_step)
-        {
-            /* The step is the minimum value. */
-            return LBFGSERR_MINIMUMSTEP;
-        }
-        if (*stp > param->max_step)
-        {
-            /* The step is the maximum value. */
-            return LBFGSERR_MAXIMUMSTEP;
-        }
-        if (param->max_linesearch <= count)
-        {
-            /* Maximum number of iteration. */
-            return LBFGSERR_MAXIMUMLINESEARCH;
-        }
-
-        (*stp) *= width;
-    }
-}
-
-static int line_search_morethuente(
-    int n,
-    lbfgsfloatval_t *x,
-    lbfgsfloatval_t *f,
-    lbfgsfloatval_t *g,
-    lbfgsfloatval_t *s,
-    lbfgsfloatval_t *stp,
-    const lbfgsfloatval_t *xp,
-    const lbfgsfloatval_t *gp,
-    lbfgsfloatval_t *wa,
-    callback_data_t *cd,
-    const lbfgs_parameter_t *param)
-{
-    int count = 0;
-    int brackt, stage1, uinfo = 0;
-    lbfgsfloatval_t dg;
-    lbfgsfloatval_t stx, fx, dgx;
-    lbfgsfloatval_t sty, fy, dgy;
-    lbfgsfloatval_t fxm, dgxm, fym, dgym, fm, dgm;
-    lbfgsfloatval_t finit, ftest1, dginit, dgtest;
-    lbfgsfloatval_t width, prev_width;
-    lbfgsfloatval_t stmin, stmax;
-
-    /* Check the input parameters for errors. */
-    if (*stp <= 0.)
-    {
-        return LBFGSERR_INVALIDPARAMETERS;
-    }
-
-    /* Compute the initial gradient in the search direction. */
-    vecdot(&dginit, g, s, n);
-
-    /* Make sure that s points to a descent direction. */
-    if (0 < dginit)
-    {
-        return LBFGSERR_INCREASEGRADIENT;
-    }
-
-    /* Initialize local variables. */
-    brackt = 0;
-    stage1 = 1;
-    finit = *f;
-    dgtest = param->ftol * dginit;
-    width = param->max_step - param->min_step;
-    prev_width = 2.0 * width;
-
-    /*
-        The variables stx, fx, dgx contain the values of the step,
-        function, and directional derivative at the best step.
-        The variables sty, fy, dgy contain the value of the step,
-        function, and derivative at the other endpoint of
-        the interval of uncertainty.
-        The variables stp, f, dg contain the values of the step,
-        function, and derivative at the current step.
-    */
-    stx = sty = 0.;
-    fx = fy = finit;
-    dgx = dgy = dginit;
-
-    for (;;)
-    {
-        /*
-            Set the minimum and maximum steps to correspond to the
-            present interval of uncertainty.
-         */
-        if (brackt)
-        {
-            stmin = min2(stx, sty);
-            stmax = max2(stx, sty);
-        }
-        else
-        {
-            stmin = stx;
-            stmax = *stp + 4.0 * (*stp - stx);
-        }
-
-        /* Clip the step in the range of [stpmin, stpmax]. */
-        if (*stp < param->min_step)
-            *stp = param->min_step;
-        if (param->max_step < *stp)
-            *stp = param->max_step;
-
-        /*
-            If an unusual termination is to occur then let
-            stp be the lowest point obtained so far.
-         */
-        if ((brackt && ((*stp <= stmin || stmax <= *stp) || param->max_linesearch <= count + 1 || uinfo != 0)) || (brackt && (stmax - stmin <= param->xtol * stmax)))
-        {
-            *stp = stx;
-        }
-
-        /*
-            Compute the current value of x:
-                x <- x + (*stp) * s.
-         */
-        veccpy(x, xp, n);
-        vecadd(x, s, *stp, n);
-
-        /* Evaluate the function and gradient values. */
-        *f = cd->proc_evaluate(cd->instance, x, g, cd->n, *stp);
-        vecdot(&dg, g, s, n);
-
-        ftest1 = finit + *stp * dgtest;
-        ++count;
-
-        /* Test for errors and convergence. */
-        if (brackt && ((*stp <= stmin || stmax <= *stp) || uinfo != 0))
-        {
-            /* Rounding errors prevent further progress. */
-            return LBFGSERR_ROUNDING_ERROR;
-        }
-        if (*stp == param->max_step && *f <= ftest1 && dg <= dgtest)
-        {
-            /* The step is the maximum value. */
-            return LBFGSERR_MAXIMUMSTEP;
-        }
-        if (*stp == param->min_step && (ftest1 < *f || dgtest <= dg))
-        {
-            /* The step is the minimum value. */
-            return LBFGSERR_MINIMUMSTEP;
-        }
-        if (brackt && (stmax - stmin) <= param->xtol * stmax)
-        {
-            /* Relative width of the interval of uncertainty is at most xtol. */
-            return LBFGSERR_WIDTHTOOSMALL;
-        }
-        if (param->max_linesearch <= count)
-        {
-            /* Maximum number of iteration. */
-            return LBFGSERR_MAXIMUMLINESEARCH;
-        }
-        if (*f <= ftest1 && fabs(dg) <= param->gtol * (-dginit))
-        {
-            /* The sufficient decrease condition and the directional derivative condition hold. */
-            return count;
-        }
-
-        /*
-            In the first stage we seek a step for which the modified
-            function has a nonpositive value and nonnegative derivative.
-         */
-        if (stage1 && *f <= ftest1 && min2(param->ftol, param->gtol) * dginit <= dg)
-        {
-            stage1 = 0;
-        }
-
-        /*
-            A modified function is used to predict the step only if
-            we have not obtained a step for which the modified
-            function has a nonpositive function value and nonnegative
-            derivative, and if a lower function value has been
-            obtained but the decrease is not sufficient.
-         */
-        if (stage1 && ftest1 < *f && *f <= fx)
-        {
-            /* Define the modified function and derivative values. */
-            fm = *f - *stp * dgtest;
-            fxm = fx - stx * dgtest;
-            fym = fy - sty * dgtest;
-            dgm = dg - dgtest;
-            dgxm = dgx - dgtest;
-            dgym = dgy - dgtest;
-
-            /*
-                Call update_trial_interval() to update the interval of
-                uncertainty and to compute the new step.
-             */
-            uinfo = update_trial_interval(
-                &stx, &fxm, &dgxm,
-                &sty, &fym, &dgym,
-                stp, &fm, &dgm,
-                stmin, stmax, &brackt);
-
-            /* Reset the function and gradient values for f. */
-            fx = fxm + stx * dgtest;
-            fy = fym + sty * dgtest;
-            dgx = dgxm + dgtest;
-            dgy = dgym + dgtest;
-        }
-        else
-        {
-            /*
-                Call update_trial_interval() to update the interval of
-                uncertainty and to compute the new step.
-             */
-            uinfo = update_trial_interval(
-                &stx, &fx, &dgx,
-                &sty, &fy, &dgy,
-                stp, f, &dg,
-                stmin, stmax, &brackt);
-        }
-
-        /*
-            Force a sufficient decrease in the interval of uncertainty.
-         */
-        if (brackt)
-        {
-            if (0.66 * prev_width <= fabs(sty - stx))
-            {
-                *stp = stx + 0.5 * (sty - stx);
-            }
-            prev_width = width;
-            width = fabs(sty - stx);
-        }
-    }
-
-    return LBFGSERR_LOGICERROR;
-}
-
-/**
- * Define the local variables for computing minimizers.
- */
-#define USES_MINIMIZER \
-    lbfgsfloatval_t a, d, gamma, theta, p, q, r, s;
-
-/**
- * Find a minimizer of an interpolated cubic function.
- *  @param  cm      The minimizer of the interpolated cubic.
- *  @param  u       The value of one point, u.
- *  @param  fu      The value of f(u).
- *  @param  du      The value of f'(u).
- *  @param  v       The value of another point, v.
- *  @param  fv      The value of f(v).
- *  @param  du      The value of f'(v).
- */
-#define CUBIC_MINIMIZER(cm, u, fu, du, v, fv, dv)        \
-    d = (v) - (u);                                       \
-    theta = ((fu) - (fv)) * 3 / d + (du) + (dv);         \
-    p = fabs(theta);                                     \
-    q = fabs(du);                                        \
-    r = fabs(dv);                                        \
-    s = max3(p, q, r);                                   \
-    /* gamma = s*sqrt((theta/s)**2 - (du/s) * (dv/s)) */ \
-    a = theta / s;                                       \
-    gamma = s * sqrt(a * a - ((du) / s) * ((dv) / s));   \
-    if ((v) < (u))                                       \
-        gamma = -gamma;                                  \
-    p = gamma - (du) + theta;                            \
-    q = gamma - (du) + gamma + (dv);                     \
-    r = p / q;                                           \
-    (cm) = (u) + r * d;
-
-/**
- * Find a minimizer of an interpolated cubic function.
- *  @param  cm      The minimizer of the interpolated cubic.
- *  @param  u       The value of one point, u.
- *  @param  fu      The value of f(u).
- *  @param  du      The value of f'(u).
- *  @param  v       The value of another point, v.
- *  @param  fv      The value of f(v).
- *  @param  du      The value of f'(v).
- *  @param  xmin    The maximum value.
- *  @param  xmin    The minimum value.
- */
-#define CUBIC_MINIMIZER2(cm, u, fu, du, v, fv, dv, xmin, xmax)  \
-    d = (v) - (u);                                              \
-    theta = ((fu) - (fv)) * 3 / d + (du) + (dv);                \
-    p = fabs(theta);                                            \
-    q = fabs(du);                                               \
-    r = fabs(dv);                                               \
-    s = max3(p, q, r);                                          \
-    /* gamma = s*sqrt((theta/s)**2 - (du/s) * (dv/s)) */        \
-    a = theta / s;                                              \
-    gamma = s * sqrt(max2(0, a * a - ((du) / s) * ((dv) / s))); \
-    if ((u) < (v))                                              \
-        gamma = -gamma;                                         \
-    p = gamma - (dv) + theta;                                   \
-    q = gamma - (dv) + gamma + (du);                            \
-    r = p / q;                                                  \
-    if (r < 0. && gamma != 0.)                                  \
-    {                                                           \
-        (cm) = (v)-r * d;                                       \
-    }                                                           \
-    else if (a < 0)                                             \
-    {                                                           \
-        (cm) = (xmax);                                          \
-    }                                                           \
-    else                                                        \
-    {                                                           \
-        (cm) = (xmin);                                          \
-    }
-
-/**
- * Find a minimizer of an interpolated quadratic function.
- *  @param  qm      The minimizer of the interpolated quadratic.
- *  @param  u       The value of one point, u.
- *  @param  fu      The value of f(u).
- *  @param  du      The value of f'(u).
- *  @param  v       The value of another point, v.
- *  @param  fv      The value of f(v).
- */
-#define QUARD_MINIMIZER(qm, u, fu, du, v, fv) \
-    a = (v) - (u);                            \
-    (qm) = (u) + (du) / (((fu) - (fv)) / a + (du)) / 2 * a;
-
-/**
- * Find a minimizer of an interpolated quadratic function.
- *  @param  qm      The minimizer of the interpolated quadratic.
- *  @param  u       The value of one point, u.
- *  @param  du      The value of f'(u).
- *  @param  v       The value of another point, v.
- *  @param  dv      The value of f'(v).
- */
-#define QUARD_MINIMIZER2(qm, u, du, v, dv) \
-    a = (u) - (v);                         \
-    (qm) = (v) + (dv) / ((dv) - (du)) * a;
-
-/**
- * Update a safeguarded trial value and interval for line search.
- *
- *  The parameter x represents the step with the least function value.
- *  The parameter t represents the current step. This function assumes
- *  that the derivative at the point of x in the direction of the step.
- *  If the bracket is set to true, the minimizer has been bracketed in
- *  an interval of uncertainty with endpoints between x and y.
- *
- *  @param  x       The pointer to the value of one endpoint.
- *  @param  fx      The pointer to the value of f(x).
- *  @param  dx      The pointer to the value of f'(x).
- *  @param  y       The pointer to the value of another endpoint.
- *  @param  fy      The pointer to the value of f(y).
- *  @param  dy      The pointer to the value of f'(y).
- *  @param  t       The pointer to the value of the trial value, t.
- *  @param  ft      The pointer to the value of f(t).
- *  @param  dt      The pointer to the value of f'(t).
- *  @param  tmin    The minimum value for the trial value, t.
- *  @param  tmax    The maximum value for the trial value, t.
- *  @param  brackt  The pointer to the predicate if the trial value is
- *                  bracketed.
- *  @retval int     Status value. Zero indicates a normal termination.
- *
- *  @see
- *      Jorge J. More and David J. Thuente. Line search algorithm with
- *      guaranteed sufficient decrease. ACM Transactions on Mathematical
- *      Software (TOMS), Vol 20, No 3, pp. 286-307, 1994.
- */
-static int update_trial_interval(
-    lbfgsfloatval_t *x,
-    lbfgsfloatval_t *fx,
-    lbfgsfloatval_t *dx,
-    lbfgsfloatval_t *y,
-    lbfgsfloatval_t *fy,
-    lbfgsfloatval_t *dy,
-    lbfgsfloatval_t *t,
-    lbfgsfloatval_t *ft,
-    lbfgsfloatval_t *dt,
-    const lbfgsfloatval_t tmin,
-    const lbfgsfloatval_t tmax,
-    int *brackt)
-{
-    int bound;
-    int dsign = fsigndiff(dt, dx);
-    lbfgsfloatval_t mc;   /* minimizer of an interpolated cubic. */
-    lbfgsfloatval_t mq;   /* minimizer of an interpolated quadratic. */
-    lbfgsfloatval_t newt; /* new trial value. */
-    USES_MINIMIZER;       /* for CUBIC_MINIMIZER and QUARD_MINIMIZER. */
-
-    /* Check the input parameters for errors. */
-    if (*brackt)
-    {
-        if (*t <= min2(*x, *y) || max2(*x, *y) <= *t)
-        {
-            /* The trival value t is out of the interval. */
-            return LBFGSERR_OUTOFINTERVAL;
-        }
-        if (0. <= *dx * (*t - *x))
-        {
-            /* The function must decrease from x. */
-            return LBFGSERR_INCREASEGRADIENT;
-        }
-        if (tmax < tmin)
-        {
-            /* Incorrect tmin and tmax specified. */
-            return LBFGSERR_INCORRECT_TMINMAX;
-        }
-    }
-
-    /*
-        Trial value selection.
-     */
-    if (*fx < *ft)
-    {
-        /*
-            Case 1: a higher function value.
-            The minimum is brackt. If the cubic minimizer is closer
-            to x than the quadratic one, the cubic one is taken, else
-            the average of the minimizers is taken.
-         */
-        *brackt = 1;
-        bound = 1;
-        CUBIC_MINIMIZER(mc, *x, *fx, *dx, *t, *ft, *dt);
-        QUARD_MINIMIZER(mq, *x, *fx, *dx, *t, *ft);
-        if (fabs(mc - *x) < fabs(mq - *x))
-        {
-            newt = mc;
-        }
-        else
-        {
-            newt = mc + 0.5 * (mq - mc);
-        }
-    }
-    else if (dsign)
-    {
-        /*
-            Case 2: a lower function value and derivatives of
-            opposite sign. The minimum is brackt. If the cubic
-            minimizer is closer to x than the quadratic (secant) one,
-            the cubic one is taken, else the quadratic one is taken.
-         */
-        *brackt = 1;
-        bound = 0;
-        CUBIC_MINIMIZER(mc, *x, *fx, *dx, *t, *ft, *dt);
-        QUARD_MINIMIZER2(mq, *x, *dx, *t, *dt);
-        if (fabs(mc - *t) > fabs(mq - *t))
-        {
-            newt = mc;
-        }
-        else
-        {
-            newt = mq;
-        }
-    }
-    else if (fabs(*dt) < fabs(*dx))
-    {
-        /*
-            Case 3: a lower function value, derivatives of the
-            same sign, and the magnitude of the derivative decreases.
-            The cubic minimizer is only used if the cubic tends to
-            infinity in the direction of the minimizer or if the minimum
-            of the cubic is beyond t. Otherwise the cubic minimizer is
-            defined to be either tmin or tmax. The quadratic (secant)
-            minimizer is also computed and if the minimum is brackt
-            then the the minimizer closest to x is taken, else the one
-            farthest away is taken.
-         */
-        bound = 1;
-        CUBIC_MINIMIZER2(mc, *x, *fx, *dx, *t, *ft, *dt, tmin, tmax);
-        QUARD_MINIMIZER2(mq, *x, *dx, *t, *dt);
-        if (*brackt)
-        {
-            if (fabs(*t - mc) < fabs(*t - mq))
-            {
-                newt = mc;
-            }
-            else
-            {
-                newt = mq;
-            }
-        }
-        else
-        {
-            if (fabs(*t - mc) > fabs(*t - mq))
-            {
-                newt = mc;
-            }
-            else
-            {
-                newt = mq;
-            }
-        }
-    }
-    else
-    {
-        /*
-            Case 4: a lower function value, derivatives of the
-            same sign, and the magnitude of the derivative does
-            not decrease. If the minimum is not brackt, the step
-            is either tmin or tmax, else the cubic minimizer is taken.
-         */
-        bound = 0;
-        if (*brackt)
-        {
-            CUBIC_MINIMIZER(newt, *t, *ft, *dt, *y, *fy, *dy);
-        }
-        else if (*x < *t)
-        {
-            newt = tmax;
-        }
-        else
-        {
-            newt = tmin;
-        }
-    }
-
-    /*
-        Update the interval of uncertainty. This update does not
-        depend on the new step or the case analysis above.
-
-        - Case a: if f(x) < f(t),
-            x <- x, y <- t.
-        - Case b: if f(t) <= f(x) && f'(t)*f'(x) > 0,
-            x <- t, y <- y.
-        - Case c: if f(t) <= f(x) && f'(t)*f'(x) < 0,
-            x <- t, y <- x.
-     */
-    if (*fx < *ft)
-    {
-        /* Case a */
-        *y = *t;
-        *fy = *ft;
-        *dy = *dt;
-    }
-    else
-    {
-        /* Case c */
-        if (dsign)
-        {
-            *y = *x;
-            *fy = *fx;
-            *dy = *dx;
-        }
-        /* Cases b and c */
-        *x = *t;
-        *fx = *ft;
-        *dx = *dt;
-    }
-
-    /* Clip the new trial value in [tmin, tmax]. */
-    if (tmax < newt)
-        newt = tmax;
-    if (newt < tmin)
-        newt = tmin;
-
-    /*
-        Redefine the new trial value if it is close to the upper bound
-        of the interval.
-     */
-    if (*brackt && bound)
-    {
-        mq = *x + 0.66 * (*y - *x);
-        if (*x < *y)
-        {
-            if (mq < newt)
-                newt = mq;
-        }
-        else
-        {
-            if (newt < mq)
-                newt = mq;
-        }
-    }
-
-    /* Return the new trial value. */
-    *t = newt;
-    return 0;
-}
-
-static lbfgsfloatval_t owlqn_x1norm(
-    const lbfgsfloatval_t *x,
-    const int start,
-    const int n)
-{
-    int i;
-    lbfgsfloatval_t norm = 0.;
-
-    for (i = start; i < n; ++i)
-    {
-        norm += fabs(x[i]);
-    }
-
-    return norm;
-}
-
-static void owlqn_pseudo_gradient(
-    lbfgsfloatval_t *pg,
-    const lbfgsfloatval_t *x,
-    const lbfgsfloatval_t *g,
-    const int n,
-    const lbfgsfloatval_t c,
-    const int start,
-    const int end)
-{
-    int i;
-
-    /* Compute the negative of gradients. */
-    for (i = 0; i < start; ++i)
-    {
-        pg[i] = g[i];
-    }
-
-    /* Compute the psuedo-gradients. */
-    for (i = start; i < end; ++i)
-    {
-        if (x[i] < 0.)
-        {
-            /* Differentiable. */
-            pg[i] = g[i] - c;
-        }
-        else if (0. < x[i])
-        {
-            /* Differentiable. */
-            pg[i] = g[i] + c;
-        }
-        else
-        {
-            if (g[i] < -c)
-            {
-                /* Take the right partial derivative. */
-                pg[i] = g[i] + c;
-            }
-            else if (c < g[i])
-            {
-                /* Take the left partial derivative. */
-                pg[i] = g[i] - c;
-            }
-            else
-            {
-                pg[i] = 0.;
-            }
-        }
-    }
-
-    for (i = end; i < n; ++i)
-    {
-        pg[i] = g[i];
-    }
-}
-
-static void owlqn_project(
-    lbfgsfloatval_t *d,
-    const lbfgsfloatval_t *sign,
-    const int start,
-    const int end)
-{
-    int i;
-
-    for (i = start; i < end; ++i)
-    {
-        if (d[i] * sign[i] <= 0)
-        {
-            d[i] = 0;
-        }
-    }
-}
+/*
+ *      Limited memory BFGS (L-BFGS).
+ *
+ * Copyright (c) 1990, Jorge Nocedal
+ * Copyright (c) 2007-2010 Naoaki Okazaki
+ * All rights reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+
+/* $Id$ */
+
+/*
+This library is a C port of the FORTRAN implementation of Limited-memory
+Broyden-Fletcher-Goldfarb-Shanno (L-BFGS) method written by Jorge Nocedal.
+The original FORTRAN source code is available at:
+http://www.ece.northwestern.edu/~nocedal/lbfgs.html
+
+The L-BFGS algorithm is described in:
+    - Jorge Nocedal.
+      Updating Quasi-Newton Matrices with Limited Storage.
+      <i>Mathematics of Computation</i>, Vol. 35, No. 151, pp. 773--782, 1980.
+    - Dong C. Liu and Jorge Nocedal.
+      On the limited memory BFGS method for large scale optimization.
+      <i>Mathematical Programming</i> B, Vol. 45, No. 3, pp. 503-528, 1989.
+
+The line search algorithms used in this implementation are described in:
+    - John E. Dennis and Robert B. Schnabel.
+      <i>Numerical Methods for Unconstrained Optimization and Nonlinear
+      Equations</i>, Englewood Cliffs, 1983.
+    - Jorge J. More and David J. Thuente.
+      Line search algorithm with guaranteed sufficient decrease.
+      <i>ACM Transactions on Mathematical Software (TOMS)</i>, Vol. 20, No. 3,
+      pp. 286-307, 1994.
+
+This library also implements Orthant-Wise Limited-memory Quasi-Newton (OWL-QN)
+method presented in:
+    - Galen Andrew and Jianfeng Gao.
+      Scalable training of L1-regularized log-linear models.
+      In <i>Proceedings of the 24th International Conference on Machine
+      Learning (ICML 2007)</i>, pp. 33-40, 2007.
+
+I would like to thank the original author, Jorge Nocedal, who has been
+distributing the effieicnt and explanatory implementation in an open source
+licence.
+*/
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif /*HAVE_CONFIG_H*/
+
+#include <stdint.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <math.h>
+
+#include <lbfgs.h>
+
+#ifdef _MSC_VER
+#define inline __inline
+#endif /*_MSC_VER*/
+
+#if defined(USE_SSE) && defined(__SSE2__) && LBFGS_FLOAT == 64
+/* Use SSE2 optimization for 64bit double precision. */
+#include "arithmetic_sse_double.h"
+
+#elif defined(USE_SSE) && defined(__SSE__) && LBFGS_FLOAT == 32
+/* Use SSE optimization for 32bit float precision. */
+#include "arithmetic_sse_float.h"
+
+#else
+/* No CPU specific optimization. */
+#include "arithmetic_ansi.h"
+
+#endif
+
+#define min2(a, b) ((a) <= (b) ? (a) : (b))
+#define max2(a, b) ((a) >= (b) ? (a) : (b))
+#define max3(a, b, c) max2(max2((a), (b)), (c));
+
+struct tag_callback_data
+{
+    int n;
+    void *instance;
+    lbfgs_evaluate_t proc_evaluate;
+    lbfgs_progress_t proc_progress;
+};
+typedef struct tag_callback_data callback_data_t;
+
+struct tag_iteration_data
+{
+    lbfgsfloatval_t alpha;
+    lbfgsfloatval_t *s; /* [n] */
+    lbfgsfloatval_t *y; /* [n] */
+    lbfgsfloatval_t ys; /* vecdot(y, s) */
+};
+typedef struct tag_iteration_data iteration_data_t;
+
+static const lbfgs_parameter_t _defparam = {
+    6,
+    1e-5,
+    0,
+    1e-5,
+    0,
+    LBFGS_LINESEARCH_DEFAULT,
+    40,
+    1e-20,
+    1e20,
+    1e-4,
+    0.9,
+    0.9,
+    1.0e-16,
+    0.0,
+    0,
+    -1,
+};
+
+/* Forward function declarations. */
+
+typedef int (*line_search_proc)(
+    int n,
+    lbfgsfloatval_t *x,
+    lbfgsfloatval_t *f,
+    lbfgsfloatval_t *g,
+    lbfgsfloatval_t *s,
+    lbfgsfloatval_t *stp,
+    const lbfgsfloatval_t *xp,
+    const lbfgsfloatval_t *gp,
+    lbfgsfloatval_t *wa,
+    callback_data_t *cd,
+    const lbfgs_parameter_t *param);
+
+static int line_search_backtracking(
+    int n,
+    lbfgsfloatval_t *x,
+    lbfgsfloatval_t *f,
+    lbfgsfloatval_t *g,
+    lbfgsfloatval_t *s,
+    lbfgsfloatval_t *stp,
+    const lbfgsfloatval_t *xp,
+    const lbfgsfloatval_t *gp,
+    lbfgsfloatval_t *wa,
+    callback_data_t *cd,
+    const lbfgs_parameter_t *param);
+
+static int line_search_backtracking_owlqn(
+    int n,
+    lbfgsfloatval_t *x,
+    lbfgsfloatval_t *f,
+    lbfgsfloatval_t *g,
+    lbfgsfloatval_t *s,
+    lbfgsfloatval_t *stp,
+    const lbfgsfloatval_t *xp,
+    const lbfgsfloatval_t *gp,
+    lbfgsfloatval_t *wp,
+    callback_data_t *cd,
+    const lbfgs_parameter_t *param);
+
+static int line_search_morethuente(
+    int n,
+    lbfgsfloatval_t *x,
+    lbfgsfloatval_t *f,
+    lbfgsfloatval_t *g,
+    lbfgsfloatval_t *s,
+    lbfgsfloatval_t *stp,
+    const lbfgsfloatval_t *xp,
+    const lbfgsfloatval_t *gp,
+    lbfgsfloatval_t *wa,
+    callback_data_t *cd,
+    const lbfgs_parameter_t *param);
+
+static int update_trial_interval(
+    lbfgsfloatval_t *x,
+    lbfgsfloatval_t *fx,
+    lbfgsfloatval_t *dx,
+    lbfgsfloatval_t *y,
+    lbfgsfloatval_t *fy,
+    lbfgsfloatval_t *dy,
+    lbfgsfloatval_t *t,
+    lbfgsfloatval_t *ft,
+    lbfgsfloatval_t *dt,
+    const lbfgsfloatval_t tmin,
+    const lbfgsfloatval_t tmax,
+    int *brackt);
+
+static lbfgsfloatval_t owlqn_x1norm(
+    const lbfgsfloatval_t *x,
+    const int start,
+    const int n);
+
+static void owlqn_pseudo_gradient(
+    lbfgsfloatval_t *pg,
+    const lbfgsfloatval_t *x,
+    const lbfgsfloatval_t *g,
+    const int n,
+    const lbfgsfloatval_t c,
+    const int start,
+    const int end);
+
+static void owlqn_project(
+    lbfgsfloatval_t *d,
+    const lbfgsfloatval_t *sign,
+    const int start,
+    const int end);
+
+#if defined(USE_SSE) && (defined(__SSE__) || defined(__SSE2__))
+static int round_out_variables(int n)
+{
+    n += 7;
+    n /= 8;
+    n *= 8;
+    return n;
+}
+#endif /*defined(USE_SSE)*/
+
+lbfgsfloatval_t *lbfgs_malloc(int n)
+{
+#if defined(USE_SSE) && (defined(__SSE__) || defined(__SSE2__))
+    n = round_out_variables(n);
+#endif /*defined(USE_SSE)*/
+    return (lbfgsfloatval_t *)vecalloc(sizeof(lbfgsfloatval_t) * n);
+}
+
+void lbfgs_free(lbfgsfloatval_t *x)
+{
+    vecfree(x);
+}
+
+void lbfgs_parameter_init(lbfgs_parameter_t *param)
+{
+    memcpy(param, &_defparam, sizeof(*param));
+}
+
+int lbfgs(
+    int n,
+    lbfgsfloatval_t *x,
+    lbfgsfloatval_t *ptr_fx,
+    lbfgs_evaluate_t proc_evaluate,
+    lbfgs_progress_t proc_progress,
+    void *instance,
+    lbfgs_parameter_t *_param)
+{
+    int ret;
+    int i, j, k, ls, end, bound;
+    lbfgsfloatval_t step;
+
+    /* Constant parameters and their default values. */
+    lbfgs_parameter_t param = (_param != NULL) ? (*_param) : _defparam;
+    const int m = param.m;
+
+    lbfgsfloatval_t *xp = NULL;
+    lbfgsfloatval_t *g = NULL, *gp = NULL, *pg = NULL;
+    lbfgsfloatval_t *d = NULL, *w = NULL, *pf = NULL;
+    iteration_data_t *lm = NULL, *it = NULL;
+    lbfgsfloatval_t ys, yy;
+    lbfgsfloatval_t xnorm, gnorm, beta;
+    lbfgsfloatval_t fx = 0.;
+    lbfgsfloatval_t rate = 0.;
+    line_search_proc linesearch = line_search_morethuente;
+
+    /* Construct a callback data. */
+    callback_data_t cd;
+    cd.n = n;
+    cd.instance = instance;
+    cd.proc_evaluate = proc_evaluate;
+    cd.proc_progress = proc_progress;
+
+#if defined(USE_SSE) && (defined(__SSE__) || defined(__SSE2__))
+    /* Round out the number of variables. */
+    n = round_out_variables(n);
+#endif /*defined(USE_SSE)*/
+
+    /* Check the input parameters for errors. */
+    if (n <= 0)
+    {
+        return LBFGSERR_INVALID_N;
+    }
+#if defined(USE_SSE) && (defined(__SSE__) || defined(__SSE2__))
+    if (n % 8 != 0)
+    {
+        return LBFGSERR_INVALID_N_SSE;
+    }
+    if ((uintptr_t)(const void *)x % 16 != 0)
+    {
+        return LBFGSERR_INVALID_X_SSE;
+    }
+#endif /*defined(USE_SSE)*/
+    if (param.epsilon < 0.)
+    {
+        return LBFGSERR_INVALID_EPSILON;
+    }
+    if (param.past < 0)
+    {
+        return LBFGSERR_INVALID_TESTPERIOD;
+    }
+    if (param.delta < 0.)
+    {
+        return LBFGSERR_INVALID_DELTA;
+    }
+    if (param.min_step < 0.)
+    {
+        return LBFGSERR_INVALID_MINSTEP;
+    }
+    if (param.max_step < param.min_step)
+    {
+        return LBFGSERR_INVALID_MAXSTEP;
+    }
+    if (param.ftol < 0.)
+    {
+        return LBFGSERR_INVALID_FTOL;
+    }
+    if (param.linesearch == LBFGS_LINESEARCH_BACKTRACKING_WOLFE ||
+        param.linesearch == LBFGS_LINESEARCH_BACKTRACKING_STRONG_WOLFE)
+    {
+        if (param.wolfe <= param.ftol || 1. <= param.wolfe)
+        {
+            return LBFGSERR_INVALID_WOLFE;
+        }
+    }
+    if (param.gtol < 0.)
+    {
+        return LBFGSERR_INVALID_GTOL;
+    }
+    if (param.xtol < 0.)
+    {
+        return LBFGSERR_INVALID_XTOL;
+    }
+    if (param.max_linesearch <= 0)
+    {
+        return LBFGSERR_INVALID_MAXLINESEARCH;
+    }
+    if (param.orthantwise_c < 0.)
+    {
+        return LBFGSERR_INVALID_ORTHANTWISE;
+    }
+    if (param.orthantwise_start < 0 || n < param.orthantwise_start)
+    {
+        return LBFGSERR_INVALID_ORTHANTWISE_START;
+    }
+    if (param.orthantwise_end < 0)
+    {
+        param.orthantwise_end = n;
+    }
+    if (n < param.orthantwise_end)
+    {
+        return LBFGSERR_INVALID_ORTHANTWISE_END;
+    }
+    if (param.orthantwise_c != 0.)
+    {
+        switch (param.linesearch)
+        {
+        case LBFGS_LINESEARCH_BACKTRACKING:
+            linesearch = line_search_backtracking_owlqn;
+            break;
+        default:
+            /* Only the backtracking method is available. */
+            return LBFGSERR_INVALID_LINESEARCH;
+        }
+    }
+    else
+    {
+        switch (param.linesearch)
+        {
+        case LBFGS_LINESEARCH_MORETHUENTE:
+            linesearch = line_search_morethuente;
+            break;
+        case LBFGS_LINESEARCH_BACKTRACKING_ARMIJO:
+        case LBFGS_LINESEARCH_BACKTRACKING_WOLFE:
+        case LBFGS_LINESEARCH_BACKTRACKING_STRONG_WOLFE:
+            linesearch = line_search_backtracking;
+            break;
+        default:
+            return LBFGSERR_INVALID_LINESEARCH;
+        }
+    }
+
+    /* Allocate working space. */
+    xp = (lbfgsfloatval_t *)vecalloc(n * sizeof(lbfgsfloatval_t));
+    g = (lbfgsfloatval_t *)vecalloc(n * sizeof(lbfgsfloatval_t));
+    gp = (lbfgsfloatval_t *)vecalloc(n * sizeof(lbfgsfloatval_t));
+    d = (lbfgsfloatval_t *)vecalloc(n * sizeof(lbfgsfloatval_t));
+    w = (lbfgsfloatval_t *)vecalloc(n * sizeof(lbfgsfloatval_t));
+    if (xp == NULL || g == NULL || gp == NULL || d == NULL || w == NULL)
+    {
+        ret = LBFGSERR_OUTOFMEMORY;
+        goto lbfgs_exit;
+    }
+
+    if (param.orthantwise_c != 0.)
+    {
+        /* Allocate working space for OW-LQN. */
+        pg = (lbfgsfloatval_t *)vecalloc(n * sizeof(lbfgsfloatval_t));
+        if (pg == NULL)
+        {
+            ret = LBFGSERR_OUTOFMEMORY;
+            goto lbfgs_exit;
+        }
+    }
+
+    /* Allocate limited memory storage. */
+    lm = (iteration_data_t *)vecalloc(m * sizeof(iteration_data_t));
+    if (lm == NULL)
+    {
+        ret = LBFGSERR_OUTOFMEMORY;
+        goto lbfgs_exit;
+    }
+
+    /* Initialize the limited memory. */
+    for (i = 0; i < m; ++i)
+    {
+        it = &lm[i];
+        it->alpha = 0;
+        it->ys = 0;
+        it->s = (lbfgsfloatval_t *)vecalloc(n * sizeof(lbfgsfloatval_t));
+        it->y = (lbfgsfloatval_t *)vecalloc(n * sizeof(lbfgsfloatval_t));
+        if (it->s == NULL || it->y == NULL)
+        {
+            ret = LBFGSERR_OUTOFMEMORY;
+            goto lbfgs_exit;
+        }
+    }
+
+    /* Allocate an array for storing previous values of the objective function. */
+    if (0 < param.past)
+    {
+        pf = (lbfgsfloatval_t *)vecalloc(param.past * sizeof(lbfgsfloatval_t));
+    }
+
+    /* Evaluate the function value and its gradient. */
+    fx = cd.proc_evaluate(cd.instance, x, g, cd.n, 0);
+    if (0. != param.orthantwise_c)
+    {
+        /* Compute the L1 norm of the variable and add it to the object value. */
+        xnorm = owlqn_x1norm(x, param.orthantwise_start, param.orthantwise_end);
+        fx += xnorm * param.orthantwise_c;
+        owlqn_pseudo_gradient(
+            pg, x, g, n,
+            param.orthantwise_c, param.orthantwise_start, param.orthantwise_end);
+    }
+
+    /* Store the initial value of the objective function. */
+    if (pf != NULL)
+    {
+        pf[0] = fx;
+    }
+
+    /*
+        Compute the direction;
+        we assume the initial hessian matrix H_0 as the identity matrix.
+     */
+    if (param.orthantwise_c == 0.)
+    {
+        vecncpy(d, g, n);
+    }
+    else
+    {
+        vecncpy(d, pg, n);
+    }
+
+    /*
+       Make sure that the initial variables are not a minimizer.
+     */
+    vec2norm(&xnorm, x, n);
+    if (param.orthantwise_c == 0.)
+    {
+        vec2norm(&gnorm, g, n);
+    }
+    else
+    {
+        vec2norm(&gnorm, pg, n);
+    }
+    if (xnorm < 1.0)
+        xnorm = 1.0;
+    if (gnorm / xnorm <= param.epsilon)
+    {
+        ret = LBFGS_ALREADY_MINIMIZED;
+        goto lbfgs_exit;
+    }
+
+    /* Compute the initial step:
+        step = 1.0 / sqrt(vecdot(d, d, n))
+     */
+    vec2norminv(&step, d, n);
+
+    k = 1;
+    end = 0;
+    for (;;)
+    {
+        /* Store the current position and gradient vectors. */
+        veccpy(xp, x, n);
+        veccpy(gp, g, n);
+
+        /* Search for an optimal step. */
+        if (param.orthantwise_c == 0.)
+        {
+            ls = linesearch(n, x, &fx, g, d, &step, xp, gp, w, &cd, &param);
+        }
+        else
+        {
+            ls = linesearch(n, x, &fx, g, d, &step, xp, pg, w, &cd, &param);
+            owlqn_pseudo_gradient(
+                pg, x, g, n,
+                param.orthantwise_c, param.orthantwise_start, param.orthantwise_end);
+        }
+        if (ls < 0)
+        {
+            /* Revert to the previous point. */
+            veccpy(x, xp, n);
+            veccpy(g, gp, n);
+            ret = ls;
+            goto lbfgs_exit;
+        }
+
+        /* Compute x and g norms. */
+        vec2norm(&xnorm, x, n);
+        if (param.orthantwise_c == 0.)
+        {
+            vec2norm(&gnorm, g, n);
+        }
+        else
+        {
+            vec2norm(&gnorm, pg, n);
+        }
+
+        /* Report the progress. */
+        if (cd.proc_progress)
+        {
+            if ((ret = cd.proc_progress(cd.instance, x, g, fx, xnorm, gnorm, step, cd.n, k, ls)))
+            {
+                goto lbfgs_exit;
+            }
+        }
+
+        /*
+            Convergence test.
+            The criterion is given by the following formula:
+                |g(x)| / \max(1, |x|) < \epsilon
+         */
+        if (xnorm < 1.0)
+            xnorm = 1.0;
+        if (gnorm / xnorm <= param.epsilon)
+        {
+            /* Convergence. */
+            ret = LBFGS_SUCCESS;
+            break;
+        }
+
+        /*
+            Test for stopping criterion.
+            The criterion is given by the following formula:
+                (f(past_x) - f(x)) / f(x) < \delta
+         */
+        if (pf != NULL)
+        {
+            /* We don't test the stopping criterion while k < past. */
+            if (param.past <= k)
+            {
+                /* Compute the relative improvement from the past. */
+                rate = (pf[k % param.past] - fx) / fx;
+
+                /* The stopping criterion. */
+                if (rate < param.delta)
+                {
+                    ret = LBFGS_STOP;
+                    break;
+                }
+            }
+
+            /* Store the current value of the objective function. */
+            pf[k % param.past] = fx;
+        }
+
+        if (param.max_iterations != 0 && param.max_iterations < k + 1)
+        {
+            /* Maximum number of iterations. */
+            ret = LBFGSERR_MAXIMUMITERATION;
+            break;
+        }
+
+        /*
+            Update vectors s and y:
+                s_{k+1} = x_{k+1} - x_{k} = \step * d_{k}.
+                y_{k+1} = g_{k+1} - g_{k}.
+         */
+        it = &lm[end];
+        vecdiff(it->s, x, xp, n);
+        vecdiff(it->y, g, gp, n);
+
+        /*
+            Compute scalars ys and yy:
+                ys = y^t \cdot s = 1 / \rho.
+                yy = y^t \cdot y.
+            Notice that yy is used for scaling the hessian matrix H_0 (Cholesky factor).
+         */
+        vecdot(&ys, it->y, it->s, n);
+        vecdot(&yy, it->y, it->y, n);
+        it->ys = ys;
+
+        /*
+            Recursive formula to compute dir = -(H \cdot g).
+                This is described in page 779 of:
+                Jorge Nocedal.
+                Updating Quasi-Newton Matrices with Limited Storage.
+                Mathematics of Computation, Vol. 35, No. 151,
+                pp. 773--782, 1980.
+         */
+        bound = (m <= k) ? m : k;
+        ++k;
+        end = (end + 1) % m;
+
+        /* Compute the steepest direction. */
+        if (param.orthantwise_c == 0.)
+        {
+            /* Compute the negative of gradients. */
+            vecncpy(d, g, n);
+        }
+        else
+        {
+            vecncpy(d, pg, n);
+        }
+
+        j = end;
+        for (i = 0; i < bound; ++i)
+        {
+            j = (j + m - 1) % m; /* if (--j == -1) j = m-1; */
+            it = &lm[j];
+            /* \alpha_{j} = \rho_{j} s^{t}_{j} \cdot q_{k+1}. */
+            vecdot(&it->alpha, it->s, d, n);
+            it->alpha /= it->ys;
+            /* q_{i} = q_{i+1} - \alpha_{i} y_{i}. */
+            vecadd(d, it->y, -it->alpha, n);
+        }
+
+        vecscale(d, ys / yy, n);
+
+        for (i = 0; i < bound; ++i)
+        {
+            it = &lm[j];
+            /* \beta_{j} = \rho_{j} y^t_{j} \cdot \gamma_{i}. */
+            vecdot(&beta, it->y, d, n);
+            beta /= it->ys;
+            /* \gamma_{i+1} = \gamma_{i} + (\alpha_{j} - \beta_{j}) s_{j}. */
+            vecadd(d, it->s, it->alpha - beta, n);
+            j = (j + 1) % m; /* if (++j == m) j = 0; */
+        }
+
+        /*
+            Constrain the search direction for orthant-wise updates.
+         */
+        if (param.orthantwise_c != 0.)
+        {
+            for (i = param.orthantwise_start; i < param.orthantwise_end; ++i)
+            {
+                if (d[i] * pg[i] >= 0)
+                {
+                    d[i] = 0;
+                }
+            }
+        }
+
+        /*
+            Now the search direction d is ready. We try step = 1 first.
+         */
+        step = 1.0;
+    }
+
+lbfgs_exit:
+    /* Return the final value of the objective function. */
+    if (ptr_fx != NULL)
+    {
+        *ptr_fx = fx;
+    }
+
+    vecfree(pf);
+
+    /* Free memory blocks used by this function. */
+    if (lm != NULL)
+    {
+        for (i = 0; i < m; ++i)
+        {
+            vecfree(lm[i].s);
+            vecfree(lm[i].y);
+        }
+        vecfree(lm);
+    }
+    vecfree(pg);
+    vecfree(w);
+    vecfree(d);
+    vecfree(gp);
+    vecfree(g);
+    vecfree(xp);
+
+    return ret;
+}
+
+static int line_search_backtracking(
+    int n,
+    lbfgsfloatval_t *x,
+    lbfgsfloatval_t *f,
+    lbfgsfloatval_t *g,
+    lbfgsfloatval_t *s,
+    lbfgsfloatval_t *stp,
+    const lbfgsfloatval_t *xp,
+    const lbfgsfloatval_t *gp,
+    lbfgsfloatval_t *wp,
+    callback_data_t *cd,
+    const lbfgs_parameter_t *param)
+{
+    int count = 0;
+    lbfgsfloatval_t width, dg;
+    lbfgsfloatval_t finit, dginit = 0., dgtest;
+    const lbfgsfloatval_t dec = 0.5, inc = 2.1;
+
+    /* Check the input parameters for errors. */
+    if (*stp <= 0.)
+    {
+        return LBFGSERR_INVALIDPARAMETERS;
+    }
+
+    /* Compute the initial gradient in the search direction. */
+    vecdot(&dginit, g, s, n);
+
+    /* Make sure that s points to a descent direction. */
+    if (0 < dginit)
+    {
+        return LBFGSERR_INCREASEGRADIENT;
+    }
+
+    /* The initial value of the objective function. */
+    finit = *f;
+    dgtest = param->ftol * dginit;
+
+    for (;;)
+    {
+        veccpy(x, xp, n);
+        vecadd(x, s, *stp, n);
+
+        /* Evaluate the function and gradient values. */
+        *f = cd->proc_evaluate(cd->instance, x, g, cd->n, *stp);
+
+        ++count;
+
+        if (*f > finit + *stp * dgtest)
+        {
+            width = dec;
+        }
+        else
+        {
+            /* The sufficient decrease condition (Armijo condition). */
+            if (param->linesearch == LBFGS_LINESEARCH_BACKTRACKING_ARMIJO)
+            {
+                /* Exit with the Armijo condition. */
+                return count;
+            }
+
+            /* Check the Wolfe condition. */
+            vecdot(&dg, g, s, n);
+            if (dg < param->wolfe * dginit)
+            {
+                width = inc;
+            }
+            else
+            {
+                if (param->linesearch == LBFGS_LINESEARCH_BACKTRACKING_WOLFE)
+                {
+                    /* Exit with the regular Wolfe condition. */
+                    return count;
+                }
+
+                /* Check the strong Wolfe condition. */
+                if (dg > -param->wolfe * dginit)
+                {
+                    width = dec;
+                }
+                else
+                {
+                    /* Exit with the strong Wolfe condition. */
+                    return count;
+                }
+            }
+        }
+
+        if (*stp < param->min_step)
+        {
+            /* The step is the minimum value. */
+            return LBFGSERR_MINIMUMSTEP;
+        }
+        if (*stp > param->max_step)
+        {
+            /* The step is the maximum value. */
+            return LBFGSERR_MAXIMUMSTEP;
+        }
+        if (param->max_linesearch <= count)
+        {
+            /* Maximum number of iteration. */
+            return LBFGSERR_MAXIMUMLINESEARCH;
+        }
+
+        (*stp) *= width;
+    }
+}
+
+static int line_search_backtracking_owlqn(
+    int n,
+    lbfgsfloatval_t *x,
+    lbfgsfloatval_t *f,
+    lbfgsfloatval_t *g,
+    lbfgsfloatval_t *s,
+    lbfgsfloatval_t *stp,
+    const lbfgsfloatval_t *xp,
+    const lbfgsfloatval_t *gp,
+    lbfgsfloatval_t *wp,
+    callback_data_t *cd,
+    const lbfgs_parameter_t *param)
+{
+    int i, count = 0;
+    lbfgsfloatval_t width = 0.5, norm = 0.;
+    lbfgsfloatval_t finit = *f, dgtest;
+
+    /* Check the input parameters for errors. */
+    if (*stp <= 0.)
+    {
+        return LBFGSERR_INVALIDPARAMETERS;
+    }
+
+    /* Choose the orthant for the new point. */
+    for (i = 0; i < n; ++i)
+    {
+        wp[i] = (xp[i] == 0.) ? -gp[i] : xp[i];
+    }
+
+    for (;;)
+    {
+        /* Update the current point. */
+        veccpy(x, xp, n);
+        vecadd(x, s, *stp, n);
+
+        /* The current point is projected onto the orthant. */
+        owlqn_project(x, wp, param->orthantwise_start, param->orthantwise_end);
+
+        /* Evaluate the function and gradient values. */
+        *f = cd->proc_evaluate(cd->instance, x, g, cd->n, *stp);
+
+        /* Compute the L1 norm of the variables and add it to the object value. */
+        norm = owlqn_x1norm(x, param->orthantwise_start, param->orthantwise_end);
+        *f += norm * param->orthantwise_c;
+
+        ++count;
+
+        dgtest = 0.;
+        for (i = 0; i < n; ++i)
+        {
+            dgtest += (x[i] - xp[i]) * gp[i];
+        }
+
+        if (*f <= finit + param->ftol * dgtest)
+        {
+            /* The sufficient decrease condition. */
+            return count;
+        }
+
+        if (*stp < param->min_step)
+        {
+            /* The step is the minimum value. */
+            return LBFGSERR_MINIMUMSTEP;
+        }
+        if (*stp > param->max_step)
+        {
+            /* The step is the maximum value. */
+            return LBFGSERR_MAXIMUMSTEP;
+        }
+        if (param->max_linesearch <= count)
+        {
+            /* Maximum number of iteration. */
+            return LBFGSERR_MAXIMUMLINESEARCH;
+        }
+
+        (*stp) *= width;
+    }
+}
+
+static int line_search_morethuente(
+    int n,
+    lbfgsfloatval_t *x,
+    lbfgsfloatval_t *f,
+    lbfgsfloatval_t *g,
+    lbfgsfloatval_t *s,
+    lbfgsfloatval_t *stp,
+    const lbfgsfloatval_t *xp,
+    const lbfgsfloatval_t *gp,
+    lbfgsfloatval_t *wa,
+    callback_data_t *cd,
+    const lbfgs_parameter_t *param)
+{
+    int count = 0;
+    int brackt, stage1, uinfo = 0;
+    lbfgsfloatval_t dg;
+    lbfgsfloatval_t stx, fx, dgx;
+    lbfgsfloatval_t sty, fy, dgy;
+    lbfgsfloatval_t fxm, dgxm, fym, dgym, fm, dgm;
+    lbfgsfloatval_t finit, ftest1, dginit, dgtest;
+    lbfgsfloatval_t width, prev_width;
+    lbfgsfloatval_t stmin, stmax;
+
+    /* Check the input parameters for errors. */
+    if (*stp <= 0.)
+    {
+        return LBFGSERR_INVALIDPARAMETERS;
+    }
+
+    /* Compute the initial gradient in the search direction. */
+    vecdot(&dginit, g, s, n);
+
+    /* Make sure that s points to a descent direction. */
+    if (0 < dginit)
+    {
+        return LBFGSERR_INCREASEGRADIENT;
+    }
+
+    /* Initialize local variables. */
+    brackt = 0;
+    stage1 = 1;
+    finit = *f;
+    dgtest = param->ftol * dginit;
+    width = param->max_step - param->min_step;
+    prev_width = 2.0 * width;
+
+    /*
+        The variables stx, fx, dgx contain the values of the step,
+        function, and directional derivative at the best step.
+        The variables sty, fy, dgy contain the value of the step,
+        function, and derivative at the other endpoint of
+        the interval of uncertainty.
+        The variables stp, f, dg contain the values of the step,
+        function, and derivative at the current step.
+    */
+    stx = sty = 0.;
+    fx = fy = finit;
+    dgx = dgy = dginit;
+
+    for (;;)
+    {
+        /*
+            Set the minimum and maximum steps to correspond to the
+            present interval of uncertainty.
+         */
+        if (brackt)
+        {
+            stmin = min2(stx, sty);
+            stmax = max2(stx, sty);
+        }
+        else
+        {
+            stmin = stx;
+            stmax = *stp + 4.0 * (*stp - stx);
+        }
+
+        /* Clip the step in the range of [stpmin, stpmax]. */
+        if (*stp < param->min_step)
+            *stp = param->min_step;
+        if (param->max_step < *stp)
+            *stp = param->max_step;
+
+        /*
+            If an unusual termination is to occur then let
+            stp be the lowest point obtained so far.
+         */
+        if ((brackt && ((*stp <= stmin || stmax <= *stp) || param->max_linesearch <= count + 1 || uinfo != 0)) || (brackt && (stmax - stmin <= param->xtol * stmax)))
+        {
+            *stp = stx;
+        }
+
+        /*
+            Compute the current value of x:
+                x <- x + (*stp) * s.
+         */
+        veccpy(x, xp, n);
+        vecadd(x, s, *stp, n);
+
+        /* Evaluate the function and gradient values. */
+        *f = cd->proc_evaluate(cd->instance, x, g, cd->n, *stp);
+        vecdot(&dg, g, s, n);
+
+        ftest1 = finit + *stp * dgtest;
+        ++count;
+
+        /* Test for errors and convergence. */
+        if (brackt && ((*stp <= stmin || stmax <= *stp) || uinfo != 0))
+        {
+            /* Rounding errors prevent further progress. */
+            return LBFGSERR_ROUNDING_ERROR;
+        }
+        if (*stp == param->max_step && *f <= ftest1 && dg <= dgtest)
+        {
+            /* The step is the maximum value. */
+            return LBFGSERR_MAXIMUMSTEP;
+        }
+        if (*stp == param->min_step && (ftest1 < *f || dgtest <= dg))
+        {
+            /* The step is the minimum value. */
+            return LBFGSERR_MINIMUMSTEP;
+        }
+        if (brackt && (stmax - stmin) <= param->xtol * stmax)
+        {
+            /* Relative width of the interval of uncertainty is at most xtol. */
+            return LBFGSERR_WIDTHTOOSMALL;
+        }
+        if (param->max_linesearch <= count)
+        {
+            /* Maximum number of iteration. */
+            return LBFGSERR_MAXIMUMLINESEARCH;
+        }
+        if (*f <= ftest1 && fabs(dg) <= param->gtol * (-dginit))
+        {
+            /* The sufficient decrease condition and the directional derivative condition hold. */
+            return count;
+        }
+
+        /*
+            In the first stage we seek a step for which the modified
+            function has a nonpositive value and nonnegative derivative.
+         */
+        if (stage1 && *f <= ftest1 && min2(param->ftol, param->gtol) * dginit <= dg)
+        {
+            stage1 = 0;
+        }
+
+        /*
+            A modified function is used to predict the step only if
+            we have not obtained a step for which the modified
+            function has a nonpositive function value and nonnegative
+            derivative, and if a lower function value has been
+            obtained but the decrease is not sufficient.
+         */
+        if (stage1 && ftest1 < *f && *f <= fx)
+        {
+            /* Define the modified function and derivative values. */
+            fm = *f - *stp * dgtest;
+            fxm = fx - stx * dgtest;
+            fym = fy - sty * dgtest;
+            dgm = dg - dgtest;
+            dgxm = dgx - dgtest;
+            dgym = dgy - dgtest;
+
+            /*
+                Call update_trial_interval() to update the interval of
+                uncertainty and to compute the new step.
+             */
+            uinfo = update_trial_interval(
+                &stx, &fxm, &dgxm,
+                &sty, &fym, &dgym,
+                stp, &fm, &dgm,
+                stmin, stmax, &brackt);
+
+            /* Reset the function and gradient values for f. */
+            fx = fxm + stx * dgtest;
+            fy = fym + sty * dgtest;
+            dgx = dgxm + dgtest;
+            dgy = dgym + dgtest;
+        }
+        else
+        {
+            /*
+                Call update_trial_interval() to update the interval of
+                uncertainty and to compute the new step.
+             */
+            uinfo = update_trial_interval(
+                &stx, &fx, &dgx,
+                &sty, &fy, &dgy,
+                stp, f, &dg,
+                stmin, stmax, &brackt);
+        }
+
+        /*
+            Force a sufficient decrease in the interval of uncertainty.
+         */
+        if (brackt)
+        {
+            if (0.66 * prev_width <= fabs(sty - stx))
+            {
+                *stp = stx + 0.5 * (sty - stx);
+            }
+            prev_width = width;
+            width = fabs(sty - stx);
+        }
+    }
+
+    return LBFGSERR_LOGICERROR;
+}
+
+/**
+ * Define the local variables for computing minimizers.
+ */
+#define USES_MINIMIZER \
+    lbfgsfloatval_t a, d, gamma, theta, p, q, r, s;
+
+/**
+ * Find a minimizer of an interpolated cubic function.
+ *  @param  cm      The minimizer of the interpolated cubic.
+ *  @param  u       The value of one point, u.
+ *  @param  fu      The value of f(u).
+ *  @param  du      The value of f'(u).
+ *  @param  v       The value of another point, v.
+ *  @param  fv      The value of f(v).
+ *  @param  du      The value of f'(v).
+ */
+#define CUBIC_MINIMIZER(cm, u, fu, du, v, fv, dv)        \
+    d = (v) - (u);                                       \
+    theta = ((fu) - (fv)) * 3 / d + (du) + (dv);         \
+    p = fabs(theta);                                     \
+    q = fabs(du);                                        \
+    r = fabs(dv);                                        \
+    s = max3(p, q, r);                                   \
+    /* gamma = s*sqrt((theta/s)**2 - (du/s) * (dv/s)) */ \
+    a = theta / s;                                       \
+    gamma = s * sqrt(a * a - ((du) / s) * ((dv) / s));   \
+    if ((v) < (u))                                       \
+        gamma = -gamma;                                  \
+    p = gamma - (du) + theta;                            \
+    q = gamma - (du) + gamma + (dv);                     \
+    r = p / q;                                           \
+    (cm) = (u) + r * d;
+
+/**
+ * Find a minimizer of an interpolated cubic function.
+ *  @param  cm      The minimizer of the interpolated cubic.
+ *  @param  u       The value of one point, u.
+ *  @param  fu      The value of f(u).
+ *  @param  du      The value of f'(u).
+ *  @param  v       The value of another point, v.
+ *  @param  fv      The value of f(v).
+ *  @param  du      The value of f'(v).
+ *  @param  xmin    The maximum value.
+ *  @param  xmin    The minimum value.
+ */
+#define CUBIC_MINIMIZER2(cm, u, fu, du, v, fv, dv, xmin, xmax)  \
+    d = (v) - (u);                                              \
+    theta = ((fu) - (fv)) * 3 / d + (du) + (dv);                \
+    p = fabs(theta);                                            \
+    q = fabs(du);                                               \
+    r = fabs(dv);                                               \
+    s = max3(p, q, r);                                          \
+    /* gamma = s*sqrt((theta/s)**2 - (du/s) * (dv/s)) */        \
+    a = theta / s;                                              \
+    gamma = s * sqrt(max2(0, a * a - ((du) / s) * ((dv) / s))); \
+    if ((u) < (v))                                              \
+        gamma = -gamma;                                         \
+    p = gamma - (dv) + theta;                                   \
+    q = gamma - (dv) + gamma + (du);                            \
+    r = p / q;                                                  \
+    if (r < 0. && gamma != 0.)                                  \
+    {                                                           \
+        (cm) = (v)-r * d;                                       \
+    }                                                           \
+    else if (a < 0)                                             \
+    {                                                           \
+        (cm) = (xmax);                                          \
+    }                                                           \
+    else                                                        \
+    {                                                           \
+        (cm) = (xmin);                                          \
+    }
+
+/**
+ * Find a minimizer of an interpolated quadratic function.
+ *  @param  qm      The minimizer of the interpolated quadratic.
+ *  @param  u       The value of one point, u.
+ *  @param  fu      The value of f(u).
+ *  @param  du      The value of f'(u).
+ *  @param  v       The value of another point, v.
+ *  @param  fv      The value of f(v).
+ */
+#define QUARD_MINIMIZER(qm, u, fu, du, v, fv) \
+    a = (v) - (u);                            \
+    (qm) = (u) + (du) / (((fu) - (fv)) / a + (du)) / 2 * a;
+
+/**
+ * Find a minimizer of an interpolated quadratic function.
+ *  @param  qm      The minimizer of the interpolated quadratic.
+ *  @param  u       The value of one point, u.
+ *  @param  du      The value of f'(u).
+ *  @param  v       The value of another point, v.
+ *  @param  dv      The value of f'(v).
+ */
+#define QUARD_MINIMIZER2(qm, u, du, v, dv) \
+    a = (u) - (v);                         \
+    (qm) = (v) + (dv) / ((dv) - (du)) * a;
+
+/**
+ * Update a safeguarded trial value and interval for line search.
+ *
+ *  The parameter x represents the step with the least function value.
+ *  The parameter t represents the current step. This function assumes
+ *  that the derivative at the point of x in the direction of the step.
+ *  If the bracket is set to true, the minimizer has been bracketed in
+ *  an interval of uncertainty with endpoints between x and y.
+ *
+ *  @param  x       The pointer to the value of one endpoint.
+ *  @param  fx      The pointer to the value of f(x).
+ *  @param  dx      The pointer to the value of f'(x).
+ *  @param  y       The pointer to the value of another endpoint.
+ *  @param  fy      The pointer to the value of f(y).
+ *  @param  dy      The pointer to the value of f'(y).
+ *  @param  t       The pointer to the value of the trial value, t.
+ *  @param  ft      The pointer to the value of f(t).
+ *  @param  dt      The pointer to the value of f'(t).
+ *  @param  tmin    The minimum value for the trial value, t.
+ *  @param  tmax    The maximum value for the trial value, t.
+ *  @param  brackt  The pointer to the predicate if the trial value is
+ *                  bracketed.
+ *  @retval int     Status value. Zero indicates a normal termination.
+ *
+ *  @see
+ *      Jorge J. More and David J. Thuente. Line search algorithm with
+ *      guaranteed sufficient decrease. ACM Transactions on Mathematical
+ *      Software (TOMS), Vol 20, No 3, pp. 286-307, 1994.
+ */
+static int update_trial_interval(
+    lbfgsfloatval_t *x,
+    lbfgsfloatval_t *fx,
+    lbfgsfloatval_t *dx,
+    lbfgsfloatval_t *y,
+    lbfgsfloatval_t *fy,
+    lbfgsfloatval_t *dy,
+    lbfgsfloatval_t *t,
+    lbfgsfloatval_t *ft,
+    lbfgsfloatval_t *dt,
+    const lbfgsfloatval_t tmin,
+    const lbfgsfloatval_t tmax,
+    int *brackt)
+{
+    int bound;
+    int dsign = fsigndiff(dt, dx);
+    lbfgsfloatval_t mc;   /* minimizer of an interpolated cubic. */
+    lbfgsfloatval_t mq;   /* minimizer of an interpolated quadratic. */
+    lbfgsfloatval_t newt; /* new trial value. */
+    USES_MINIMIZER;       /* for CUBIC_MINIMIZER and QUARD_MINIMIZER. */
+
+    /* Check the input parameters for errors. */
+    if (*brackt)
+    {
+        if (*t <= min2(*x, *y) || max2(*x, *y) <= *t)
+        {
+            /* The trival value t is out of the interval. */
+            return LBFGSERR_OUTOFINTERVAL;
+        }
+        if (0. <= *dx * (*t - *x))
+        {
+            /* The function must decrease from x. */
+            return LBFGSERR_INCREASEGRADIENT;
+        }
+        if (tmax < tmin)
+        {
+            /* Incorrect tmin and tmax specified. */
+            return LBFGSERR_INCORRECT_TMINMAX;
+        }
+    }
+
+    /*
+        Trial value selection.
+     */
+    if (*fx < *ft)
+    {
+        /*
+            Case 1: a higher function value.
+            The minimum is brackt. If the cubic minimizer is closer
+            to x than the quadratic one, the cubic one is taken, else
+            the average of the minimizers is taken.
+         */
+        *brackt = 1;
+        bound = 1;
+        CUBIC_MINIMIZER(mc, *x, *fx, *dx, *t, *ft, *dt);
+        QUARD_MINIMIZER(mq, *x, *fx, *dx, *t, *ft);
+        if (fabs(mc - *x) < fabs(mq - *x))
+        {
+            newt = mc;
+        }
+        else
+        {
+            newt = mc + 0.5 * (mq - mc);
+        }
+    }
+    else if (dsign)
+    {
+        /*
+            Case 2: a lower function value and derivatives of
+            opposite sign. The minimum is brackt. If the cubic
+            minimizer is closer to x than the quadratic (secant) one,
+            the cubic one is taken, else the quadratic one is taken.
+         */
+        *brackt = 1;
+        bound = 0;
+        CUBIC_MINIMIZER(mc, *x, *fx, *dx, *t, *ft, *dt);
+        QUARD_MINIMIZER2(mq, *x, *dx, *t, *dt);
+        if (fabs(mc - *t) > fabs(mq - *t))
+        {
+            newt = mc;
+        }
+        else
+        {
+            newt = mq;
+        }
+    }
+    else if (fabs(*dt) < fabs(*dx))
+    {
+        /*
+            Case 3: a lower function value, derivatives of the
+            same sign, and the magnitude of the derivative decreases.
+            The cubic minimizer is only used if the cubic tends to
+            infinity in the direction of the minimizer or if the minimum
+            of the cubic is beyond t. Otherwise the cubic minimizer is
+            defined to be either tmin or tmax. The quadratic (secant)
+            minimizer is also computed and if the minimum is brackt
+            then the the minimizer closest to x is taken, else the one
+            farthest away is taken.
+         */
+        bound = 1;
+        CUBIC_MINIMIZER2(mc, *x, *fx, *dx, *t, *ft, *dt, tmin, tmax);
+        QUARD_MINIMIZER2(mq, *x, *dx, *t, *dt);
+        if (*brackt)
+        {
+            if (fabs(*t - mc) < fabs(*t - mq))
+            {
+                newt = mc;
+            }
+            else
+            {
+                newt = mq;
+            }
+        }
+        else
+        {
+            if (fabs(*t - mc) > fabs(*t - mq))
+            {
+                newt = mc;
+            }
+            else
+            {
+                newt = mq;
+            }
+        }
+    }
+    else
+    {
+        /*
+            Case 4: a lower function value, derivatives of the
+            same sign, and the magnitude of the derivative does
+            not decrease. If the minimum is not brackt, the step
+            is either tmin or tmax, else the cubic minimizer is taken.
+         */
+        bound = 0;
+        if (*brackt)
+        {
+            CUBIC_MINIMIZER(newt, *t, *ft, *dt, *y, *fy, *dy);
+        }
+        else if (*x < *t)
+        {
+            newt = tmax;
+        }
+        else
+        {
+            newt = tmin;
+        }
+    }
+
+    /*
+        Update the interval of uncertainty. This update does not
+        depend on the new step or the case analysis above.
+
+        - Case a: if f(x) < f(t),
+            x <- x, y <- t.
+        - Case b: if f(t) <= f(x) && f'(t)*f'(x) > 0,
+            x <- t, y <- y.
+        - Case c: if f(t) <= f(x) && f'(t)*f'(x) < 0,
+            x <- t, y <- x.
+     */
+    if (*fx < *ft)
+    {
+        /* Case a */
+        *y = *t;
+        *fy = *ft;
+        *dy = *dt;
+    }
+    else
+    {
+        /* Case c */
+        if (dsign)
+        {
+            *y = *x;
+            *fy = *fx;
+            *dy = *dx;
+        }
+        /* Cases b and c */
+        *x = *t;
+        *fx = *ft;
+        *dx = *dt;
+    }
+
+    /* Clip the new trial value in [tmin, tmax]. */
+    if (tmax < newt)
+        newt = tmax;
+    if (newt < tmin)
+        newt = tmin;
+
+    /*
+        Redefine the new trial value if it is close to the upper bound
+        of the interval.
+     */
+    if (*brackt && bound)
+    {
+        mq = *x + 0.66 * (*y - *x);
+        if (*x < *y)
+        {
+            if (mq < newt)
+                newt = mq;
+        }
+        else
+        {
+            if (newt < mq)
+                newt = mq;
+        }
+    }
+
+    /* Return the new trial value. */
+    *t = newt;
+    return 0;
+}
+
+static lbfgsfloatval_t owlqn_x1norm(
+    const lbfgsfloatval_t *x,
+    const int start,
+    const int n)
+{
+    int i;
+    lbfgsfloatval_t norm = 0.;
+
+    for (i = start; i < n; ++i)
+    {
+        norm += fabs(x[i]);
+    }
+
+    return norm;
+}
+
+static void owlqn_pseudo_gradient(
+    lbfgsfloatval_t *pg,
+    const lbfgsfloatval_t *x,
+    const lbfgsfloatval_t *g,
+    const int n,
+    const lbfgsfloatval_t c,
+    const int start,
+    const int end)
+{
+    int i;
+
+    /* Compute the negative of gradients. */
+    for (i = 0; i < start; ++i)
+    {
+        pg[i] = g[i];
+    }
+
+    /* Compute the psuedo-gradients. */
+    for (i = start; i < end; ++i)
+    {
+        if (x[i] < 0.)
+        {
+            /* Differentiable. */
+            pg[i] = g[i] - c;
+        }
+        else if (0. < x[i])
+        {
+            /* Differentiable. */
+            pg[i] = g[i] + c;
+        }
+        else
+        {
+            if (g[i] < -c)
+            {
+                /* Take the right partial derivative. */
+                pg[i] = g[i] + c;
+            }
+            else if (c < g[i])
+            {
+                /* Take the left partial derivative. */
+                pg[i] = g[i] - c;
+            }
+            else
+            {
+                pg[i] = 0.;
+            }
+        }
+    }
+
+    for (i = end; i < n; ++i)
+    {
+        pg[i] = g[i];
+    }
+}
+
+static void owlqn_project(
+    lbfgsfloatval_t *d,
+    const lbfgsfloatval_t *sign,
+    const int start,
+    const int end)
+{
+    int i;
+
+    for (i = start; i < end; ++i)
+    {
+        if (d[i] * sign[i] <= 0)
+        {
+            d[i] = 0;
+        }
+    }
+}
```

## chaine/_core/liblbfgs/README

```diff
@@ -1,170 +1,166 @@
-00000000: 0d0a 2020 2020 2020 2020 2020 206c 6962  ..           lib
-00000010: 4c42 4647 533a 2043 206c 6962 7261 7279  LBFGS: C library
-00000020: 206f 6620 6c69 6d69 7465 642d 6d65 6d6f   of limited-memo
-00000030: 7279 2042 4647 5320 284c 2d42 4647 5329  ry BFGS (L-BFGS)
-00000040: 0d0a 0d0a 2020 2020 2020 2020 2020 2020  ....            
+00000000: 0a20 2020 2020 2020 2020 2020 6c69 624c  .           libL
+00000010: 4246 4753 3a20 4320 6c69 6272 6172 7920  BFGS: C library 
+00000020: 6f66 206c 696d 6974 6564 2d6d 656d 6f72  of limited-memor
+00000030: 7920 4246 4753 2028 4c2d 4246 4753 290a  y BFGS (L-BFGS).
+00000040: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
 00000050: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00000060: 2020 2020 2020 2020 2020 2043 6f70 7972             Copyr
-00000070: 6967 6874 2028 6329 2031 3939 302c 204a  ight (c) 1990, J
-00000080: 6f72 6765 204e 6f63 6564 616c 0d0a 2020  orge Nocedal..  
+00000060: 2020 2020 2020 2020 436f 7079 7269 6768          Copyrigh
+00000070: 7420 2863 2920 3139 3930 2c20 4a6f 7267  t (c) 1990, Jorg
+00000080: 6520 4e6f 6365 6461 6c0a 2020 2020 2020  e Nocedal.      
 00000090: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000000a0: 2020 2020 2020 2020 2020 2020 2020 2043                 C
-000000b0: 6f70 7972 6967 6874 2028 6329 2032 3030  opyright (c) 200
-000000c0: 372d 3230 3130 2c20 4e61 6f61 6b69 204f  7-2010, Naoaki O
-000000d0: 6b61 7a61 6b69 0d0a 0d0a 3d3d 3d3d 3d3d  kazaki....======
+000000a0: 2020 2020 2020 2020 2020 2043 6f70 7972             Copyr
+000000b0: 6967 6874 2028 6329 2032 3030 372d 3230  ight (c) 2007-20
+000000c0: 3130 2c20 4e61 6f61 6b69 204f 6b61 7a61  10, Naoaki Okaza
+000000d0: 6b69 0a0a 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ki..============
 000000e0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
 000000f0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
 00000100: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-00000110: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-00000120: 3d3d 3d0d 0a31 2e20 496e 7472 6f64 7563  ===..1. Introduc
-00000130: 7469 6f6e 0d0a 3d3d 3d3d 3d3d 3d3d 3d3d  tion..==========
+00000110: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d0a 312e  =============.1.
+00000120: 2049 6e74 726f 6475 6374 696f 6e0a 3d3d   Introduction.==
+00000130: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
 00000140: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
 00000150: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
 00000160: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-00000170: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d0d  ===============.
-00000180: 0a6c 6962 4c42 4647 5320 6973 2061 2043  .libLBFGS is a C
-00000190: 2070 6f72 7420 6f66 2074 6865 2069 6d70   port of the imp
-000001a0: 6c65 6d65 6e74 6174 696f 6e20 6f66 204c  lementation of L
-000001b0: 696d 6974 6564 2d6d 656d 6f72 790d 0a42  imited-memory..B
-000001c0: 726f 7964 656e 2d46 6c65 7463 6865 722d  royden-Fletcher-
-000001d0: 476f 6c64 6661 7262 2d53 6861 6e6e 6f20  Goldfarb-Shanno 
-000001e0: 284c 2d42 4647 5329 206d 6574 686f 6420  (L-BFGS) method 
-000001f0: 7772 6974 7465 6e20 6279 204a 6f72 6765  written by Jorge
-00000200: 204e 6f63 6564 616c 2e0d 0a54 6865 206f   Nocedal...The o
-00000210: 7269 6769 6e61 6c20 464f 5254 5241 4e20  riginal FORTRAN 
-00000220: 736f 7572 6365 2063 6f64 6520 6973 2061  source code is a
-00000230: 7661 696c 6162 6c65 2061 743a 0d0a 6874  vailable at:..ht
-00000240: 7470 3a2f 2f77 7777 2e65 6365 2e6e 6f72  tp://www.ece.nor
-00000250: 7468 7765 7374 6572 6e2e 6564 752f 7e6e  thwestern.edu/~n
-00000260: 6f63 6564 616c 2f6c 6266 6773 2e68 746d  ocedal/lbfgs.htm
-00000270: 6c0d 0a0d 0a54 6865 204c 2d42 4647 5320  l....The L-BFGS 
-00000280: 6d65 7468 6f64 2073 6f6c 7665 7320 7468  method solves th
-00000290: 6520 756e 636f 6e73 7472 6169 6e74 6564  e unconstrainted
-000002a0: 206d 696e 696d 697a 6174 696f 6e20 7072   minimization pr
-000002b0: 6f62 6c65 6d3a 0d0a 2020 2020 6d69 6e69  oblem:..    mini
-000002c0: 6d69 7a65 2046 2878 292c 2078 203d 2028  mize F(x), x = (
-000002d0: 7831 2c20 7832 2c20 2e2e 2e2c 2078 4e29  x1, x2, ..., xN)
-000002e0: 2c0d 0a6f 6e6c 7920 6966 2074 6865 206f  ,..only if the o
-000002f0: 626a 6563 7469 7665 2066 756e 6374 696f  bjective functio
-00000300: 6e20 4628 7829 2061 6e64 2069 7473 2067  n F(x) and its g
-00000310: 7261 6469 656e 7420 4728 7829 2061 7265  radient G(x) are
-00000320: 2063 6f6d 7075 7461 626c 652e 0d0a 0d0a   computable.....
-00000330: 5265 6665 7220 746f 2074 6865 206c 6962  Refer to the lib
-00000340: 4c42 4647 5320 7765 6220 7369 7465 2066  LBFGS web site f
-00000350: 6f72 206d 6f72 6520 696e 666f 726d 6174  or more informat
-00000360: 696f 6e2e 0d0a 6874 7470 3a2f 2f77 7777  ion...http://www
-00000370: 2e63 686f 6b6b 616e 2e6f 7267 2f73 6f66  .chokkan.org/sof
-00000380: 7477 6172 652f 6c69 626c 6266 6773 2f0d  tware/liblbfgs/.
-00000390: 0a0d 0a0d 0a0d 0a3d 3d3d 3d3d 3d3d 3d3d  .......=========
+00000170: 3d3d 3d3d 3d3d 3d0a 6c69 624c 4246 4753  =======.libLBFGS
+00000180: 2069 7320 6120 4320 706f 7274 206f 6620   is a C port of 
+00000190: 7468 6520 696d 706c 656d 656e 7461 7469  the implementati
+000001a0: 6f6e 206f 6620 4c69 6d69 7465 642d 6d65  on of Limited-me
+000001b0: 6d6f 7279 0a42 726f 7964 656e 2d46 6c65  mory.Broyden-Fle
+000001c0: 7463 6865 722d 476f 6c64 6661 7262 2d53  tcher-Goldfarb-S
+000001d0: 6861 6e6e 6f20 284c 2d42 4647 5329 206d  hanno (L-BFGS) m
+000001e0: 6574 686f 6420 7772 6974 7465 6e20 6279  ethod written by
+000001f0: 204a 6f72 6765 204e 6f63 6564 616c 2e0a   Jorge Nocedal..
+00000200: 5468 6520 6f72 6967 696e 616c 2046 4f52  The original FOR
+00000210: 5452 414e 2073 6f75 7263 6520 636f 6465  TRAN source code
+00000220: 2069 7320 6176 6169 6c61 626c 6520 6174   is available at
+00000230: 3a0a 6874 7470 3a2f 2f77 7777 2e65 6365  :.http://www.ece
+00000240: 2e6e 6f72 7468 7765 7374 6572 6e2e 6564  .northwestern.ed
+00000250: 752f 7e6e 6f63 6564 616c 2f6c 6266 6773  u/~nocedal/lbfgs
+00000260: 2e68 746d 6c0a 0a54 6865 204c 2d42 4647  .html..The L-BFG
+00000270: 5320 6d65 7468 6f64 2073 6f6c 7665 7320  S method solves 
+00000280: 7468 6520 756e 636f 6e73 7472 6169 6e74  the unconstraint
+00000290: 6564 206d 696e 696d 697a 6174 696f 6e20  ed minimization 
+000002a0: 7072 6f62 6c65 6d3a 0a20 2020 206d 696e  problem:.    min
+000002b0: 696d 697a 6520 4628 7829 2c20 7820 3d20  imize F(x), x = 
+000002c0: 2878 312c 2078 322c 202e 2e2e 2c20 784e  (x1, x2, ..., xN
+000002d0: 292c 0a6f 6e6c 7920 6966 2074 6865 206f  ),.only if the o
+000002e0: 626a 6563 7469 7665 2066 756e 6374 696f  bjective functio
+000002f0: 6e20 4628 7829 2061 6e64 2069 7473 2067  n F(x) and its g
+00000300: 7261 6469 656e 7420 4728 7829 2061 7265  radient G(x) are
+00000310: 2063 6f6d 7075 7461 626c 652e 0a0a 5265   computable...Re
+00000320: 6665 7220 746f 2074 6865 206c 6962 4c42  fer to the libLB
+00000330: 4647 5320 7765 6220 7369 7465 2066 6f72  FGS web site for
+00000340: 206d 6f72 6520 696e 666f 726d 6174 696f   more informatio
+00000350: 6e2e 0a68 7474 703a 2f2f 7777 772e 6368  n..http://www.ch
+00000360: 6f6b 6b61 6e2e 6f72 672f 736f 6674 7761  okkan.org/softwa
+00000370: 7265 2f6c 6962 6c62 6667 732f 0a0a 0a0a  re/liblbfgs/....
+00000380: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
+00000390: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
 000003a0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
 000003b0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-000003c0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-000003d0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-000003e0: 0d0a 322e 2048 6f77 2074 6f20 6275 696c  ..2. How to buil
-000003f0: 640d 0a3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  d..=============
+000003c0: 3d3d 3d3d 3d3d 3d3d 3d0a 322e 2048 6f77  =========.2. How
+000003d0: 2074 6f20 6275 696c 640a 3d3d 3d3d 3d3d   to build.======
+000003e0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
+000003f0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
 00000400: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
 00000410: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-00000420: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-00000430: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 0d0a 5b4d  ============..[M
-00000440: 6963 726f 736f 6674 2056 6973 7561 6c20  icrosoft Visual 
-00000450: 5374 7564 696f 2032 3030 385d 0d0a 4f70  Studio 2008]..Op
-00000460: 656e 2074 6865 2073 6f6c 7574 696f 6e20  en the solution 
-00000470: 6669 6c65 2022 6c62 6667 732e 736c 6e22  file "lbfgs.sln"
-00000480: 2061 6e64 2062 7569 6c64 2069 742e 0d0a   and build it...
-00000490: 0d0a 5b47 4343 5d0d 0a24 202e 2f63 6f6e  ..[GCC]..$ ./con
-000004a0: 6669 6775 7265 0d0a 2420 6d61 6b65 0d0a  figure..$ make..
-000004b0: 2420 6d61 6b65 2069 6e73 7461 6c6c 2020  $ make install  
-000004c0: 2320 546f 2069 6e73 7461 6c6c 206c 6962  # To install lib
-000004d0: 4c42 4647 5320 6c69 6272 6172 7920 616e  LBFGS library an
-000004e0: 6420 6865 6164 6572 2e0d 0a0d 0a0d 0a0d  d header........
-000004f0: 0a3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  .===============
+00000420: 3d3d 3d0a 5b4d 6963 726f 736f 6674 2056  ===.[Microsoft V
+00000430: 6973 7561 6c20 5374 7564 696f 2032 3030  isual Studio 200
+00000440: 385d 0a4f 7065 6e20 7468 6520 736f 6c75  8].Open the solu
+00000450: 7469 6f6e 2066 696c 6520 226c 6266 6773  tion file "lbfgs
+00000460: 2e73 6c6e 2220 616e 6420 6275 696c 6420  .sln" and build 
+00000470: 6974 2e0a 0a5b 4743 435d 0a24 202e 2f63  it...[GCC].$ ./c
+00000480: 6f6e 6669 6775 7265 0a24 206d 616b 650a  onfigure.$ make.
+00000490: 2420 6d61 6b65 2069 6e73 7461 6c6c 2020  $ make install  
+000004a0: 2320 546f 2069 6e73 7461 6c6c 206c 6962  # To install lib
+000004b0: 4c42 4647 5320 6c69 6272 6172 7920 616e  LBFGS library an
+000004c0: 6420 6865 6164 6572 2e0a 0a0a 0a3d 3d3d  d header.....===
+000004d0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
+000004e0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
+000004f0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
 00000500: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-00000510: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-00000520: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-00000530: 3d3d 3d3d 3d3d 3d3d 3d3d 0d0a 332e 204e  ==========..3. N
-00000540: 6f74 6520 6f6e 2053 5345 2f53 5345 3220  ote on SSE/SSE2 
-00000550: 6f70 7469 6d69 7a61 7469 6f6e 0d0a 3d3d  optimization..==
+00000510: 3d3d 3d3d 3d3d 0a33 2e20 4e6f 7465 206f  ======.3. Note o
+00000520: 6e20 5353 452f 5353 4532 206f 7074 696d  n SSE/SSE2 optim
+00000530: 697a 6174 696f 6e0a 3d3d 3d3d 3d3d 3d3d  ization.========
+00000540: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
+00000550: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
 00000560: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
 00000570: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-00000580: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-00000590: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-000005a0: 3d3d 3d3d 3d3d 3d0d 0a54 6869 7320 6c69  =======..This li
-000005b0: 6272 6172 7920 6861 7320 5353 452f 5353  brary has SSE/SS
-000005c0: 4532 206f 7074 696d 697a 6174 696f 6e20  E2 optimization 
-000005d0: 726f 7574 696e 6573 2066 6f72 2076 6563  routines for vec
-000005e0: 746f 7220 6172 6974 686d 6574 6963 0d0a  tor arithmetic..
-000005f0: 6f70 6572 6174 696f 6e73 206f 6e20 496e  operations on In
-00000600: 7465 6c2f 414d 4420 7072 6f63 6573 736f  tel/AMD processo
-00000610: 7273 2e20 5468 6520 5353 4532 2072 6f75  rs. The SSE2 rou
-00000620: 7469 6e65 2069 7320 666f 7220 3634 2062  tine is for 64 b
-00000630: 6974 2064 6f75 626c 650d 0a76 616c 7565  it double..value
-00000640: 732c 2061 6e64 2074 6865 2053 5345 2072  s, and the SSE r
-00000650: 6f75 7469 6e65 2069 7320 666f 7220 3332  outine is for 32
-00000660: 2062 6974 2066 6c6f 6174 2076 616c 7565   bit float value
-00000670: 732e 2053 696e 6365 2074 6865 2064 6566  s. Since the def
-00000680: 6175 6c74 0d0a 7061 7261 6d65 7465 7273  ault..parameters
-00000690: 2069 6e20 6c69 624c 4246 4753 2061 7265   in libLBFGS are
-000006a0: 2074 756e 6564 2066 6f72 2064 6f75 626c   tuned for doubl
-000006b0: 6520 7072 6563 6973 696f 6e20 7661 6c75  e precision valu
-000006c0: 6573 2c20 6974 206d 6179 206e 6565 640d  es, it may need.
-000006d0: 0a74 6f20 6d6f 6469 6679 2074 6865 7365  .to modify these
-000006e0: 2070 6172 616d 6574 6572 7320 746f 2075   parameters to u
-000006f0: 7365 2074 6865 2053 5345 206f 7074 696d  se the SSE optim
-00000700: 697a 6174 696f 6e20 726f 7574 696e 6573  ization routines
-00000710: 2e0d 0a0d 0a54 6f20 7573 6520 7468 6520  .....To use the 
-00000720: 5353 4532 206f 7074 696d 697a 6174 696f  SSE2 optimizatio
-00000730: 6e20 726f 7574 696e 652c 2073 7065 6369  n routine, speci
-00000740: 6679 202d 2d65 6e61 626c 652d 7373 6532  fy --enable-sse2
-00000750: 206f 7074 696f 6e20 746f 2074 6865 0d0a   option to the..
-00000760: 636f 6e66 6967 7572 6520 7363 7269 7074  configure script
-00000770: 2e0d 0a0d 0a24 202e 2f63 6f6e 6669 6775  .....$ ./configu
-00000780: 7265 202d 2d65 6e61 626c 652d 7373 6532  re --enable-sse2
-00000790: 0d0a 0d0a 546f 2062 7569 6c64 206c 6962  ....To build lib
-000007a0: 4c42 4647 5320 7769 7468 2053 5345 3220  LBFGS with SSE2 
-000007b0: 6f70 7469 6d69 7a61 7469 6f6e 2065 6e61  optimization ena
-000007c0: 626c 6564 206f 6e20 4d69 6372 6f73 6f66  bled on Microsof
-000007d0: 7420 5669 7375 616c 0d0a 5374 7564 696f  t Visual..Studio
-000007e0: 2032 3030 352c 2064 6566 696e 6520 5553   2005, define US
-000007f0: 455f 5353 4520 616e 6420 5f5f 5353 4532  E_SSE and __SSE2
-00000800: 5f5f 2073 796d 626f 6c73 2e0d 0a0d 0a4d  __ symbols.....M
-00000810: 616b 6520 7375 7265 2074 6f20 7275 6e20  ake sure to run 
-00000820: 6c69 624c 4246 4753 206f 6e20 7072 6f63  libLBFGS on proc
-00000830: 6573 736f 7273 2077 6865 7265 2053 5345  essors where SSE
-00000840: 3220 696e 7374 7275 6e63 7469 6f6e 7320  2 instrunctions 
-00000850: 6172 650d 0a61 7661 696c 6162 6c65 2e20  are..available. 
-00000860: 5468 6520 6c69 6272 6172 7920 646f 6573  The library does
-00000870: 206e 6f74 2063 6865 636b 2074 6865 2065   not check the e
-00000880: 7869 7374 656e 6365 206f 6620 5353 4532  xistence of SSE2
-00000890: 2069 6e73 7472 7563 7469 6f6e 732e 0d0a   instructions...
-000008a0: 0d0a 546f 2070 6163 6b61 6765 206d 6169  ..To package mai
-000008b0: 6e74 6169 6e65 7273 2c0d 0a0d 0a50 6c65  ntainers,....Ple
-000008c0: 6173 6520 646f 206e 6f74 2065 6e61 626c  ase do not enabl
-000008d0: 6520 5353 452f 5353 4532 206f 7074 696d  e SSE/SSE2 optim
-000008e0: 697a 6174 696f 6e20 726f 7574 696e 652e  ization routine.
-000008f0: 2054 6865 206c 6962 7261 7279 2062 7569   The library bui
-00000900: 6c74 0d0a 7769 7468 2053 5345 2f53 5345  lt..with SSE/SSE
-00000910: 3220 6f70 7469 6d69 7a61 7469 6f6e 2077  2 optimization w
-00000920: 696c 6c20 6372 6173 6820 7769 7468 6f75  ill crash withou
-00000930: 7420 616e 7920 6e6f 7469 6365 2077 6865  t any notice whe
-00000940: 6e20 6e65 6365 7373 6172 790d 0a53 5345  n necessary..SSE
-00000950: 2f53 5345 3220 696e 7374 7275 6374 696f  /SSE2 instructio
-00000960: 6e73 2061 7265 2075 6e61 7661 696c 6162  ns are unavailab
-00000970: 6c65 206f 6e20 4350 5573 2e0d 0a0d 0a0d  le on CPUs......
-00000980: 0a0d 0a3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ...=============
-00000990: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
+00000580: 3d0a 5468 6973 206c 6962 7261 7279 2068  =.This library h
+00000590: 6173 2053 5345 2f53 5345 3220 6f70 7469  as SSE/SSE2 opti
+000005a0: 6d69 7a61 7469 6f6e 2072 6f75 7469 6e65  mization routine
+000005b0: 7320 666f 7220 7665 6374 6f72 2061 7269  s for vector ari
+000005c0: 7468 6d65 7469 630a 6f70 6572 6174 696f  thmetic.operatio
+000005d0: 6e73 206f 6e20 496e 7465 6c2f 414d 4420  ns on Intel/AMD 
+000005e0: 7072 6f63 6573 736f 7273 2e20 5468 6520  processors. The 
+000005f0: 5353 4532 2072 6f75 7469 6e65 2069 7320  SSE2 routine is 
+00000600: 666f 7220 3634 2062 6974 2064 6f75 626c  for 64 bit doubl
+00000610: 650a 7661 6c75 6573 2c20 616e 6420 7468  e.values, and th
+00000620: 6520 5353 4520 726f 7574 696e 6520 6973  e SSE routine is
+00000630: 2066 6f72 2033 3220 6269 7420 666c 6f61   for 32 bit floa
+00000640: 7420 7661 6c75 6573 2e20 5369 6e63 6520  t values. Since 
+00000650: 7468 6520 6465 6661 756c 740a 7061 7261  the default.para
+00000660: 6d65 7465 7273 2069 6e20 6c69 624c 4246  meters in libLBF
+00000670: 4753 2061 7265 2074 756e 6564 2066 6f72  GS are tuned for
+00000680: 2064 6f75 626c 6520 7072 6563 6973 696f   double precisio
+00000690: 6e20 7661 6c75 6573 2c20 6974 206d 6179  n values, it may
+000006a0: 206e 6565 640a 746f 206d 6f64 6966 7920   need.to modify 
+000006b0: 7468 6573 6520 7061 7261 6d65 7465 7273  these parameters
+000006c0: 2074 6f20 7573 6520 7468 6520 5353 4520   to use the SSE 
+000006d0: 6f70 7469 6d69 7a61 7469 6f6e 2072 6f75  optimization rou
+000006e0: 7469 6e65 732e 0a0a 546f 2075 7365 2074  tines...To use t
+000006f0: 6865 2053 5345 3220 6f70 7469 6d69 7a61  he SSE2 optimiza
+00000700: 7469 6f6e 2072 6f75 7469 6e65 2c20 7370  tion routine, sp
+00000710: 6563 6966 7920 2d2d 656e 6162 6c65 2d73  ecify --enable-s
+00000720: 7365 3220 6f70 7469 6f6e 2074 6f20 7468  se2 option to th
+00000730: 650a 636f 6e66 6967 7572 6520 7363 7269  e.configure scri
+00000740: 7074 2e0a 0a24 202e 2f63 6f6e 6669 6775  pt...$ ./configu
+00000750: 7265 202d 2d65 6e61 626c 652d 7373 6532  re --enable-sse2
+00000760: 0a0a 546f 2062 7569 6c64 206c 6962 4c42  ..To build libLB
+00000770: 4647 5320 7769 7468 2053 5345 3220 6f70  FGS with SSE2 op
+00000780: 7469 6d69 7a61 7469 6f6e 2065 6e61 626c  timization enabl
+00000790: 6564 206f 6e20 4d69 6372 6f73 6f66 7420  ed on Microsoft 
+000007a0: 5669 7375 616c 0a53 7475 6469 6f20 3230  Visual.Studio 20
+000007b0: 3035 2c20 6465 6669 6e65 2055 5345 5f53  05, define USE_S
+000007c0: 5345 2061 6e64 205f 5f53 5345 325f 5f20  SE and __SSE2__ 
+000007d0: 7379 6d62 6f6c 732e 0a0a 4d61 6b65 2073  symbols...Make s
+000007e0: 7572 6520 746f 2072 756e 206c 6962 4c42  ure to run libLB
+000007f0: 4647 5320 6f6e 2070 726f 6365 7373 6f72  FGS on processor
+00000800: 7320 7768 6572 6520 5353 4532 2069 6e73  s where SSE2 ins
+00000810: 7472 756e 6374 696f 6e73 2061 7265 0a61  trunctions are.a
+00000820: 7661 696c 6162 6c65 2e20 5468 6520 6c69  vailable. The li
+00000830: 6272 6172 7920 646f 6573 206e 6f74 2063  brary does not c
+00000840: 6865 636b 2074 6865 2065 7869 7374 656e  heck the existen
+00000850: 6365 206f 6620 5353 4532 2069 6e73 7472  ce of SSE2 instr
+00000860: 7563 7469 6f6e 732e 0a0a 546f 2070 6163  uctions...To pac
+00000870: 6b61 6765 206d 6169 6e74 6169 6e65 7273  kage maintainers
+00000880: 2c0a 0a50 6c65 6173 6520 646f 206e 6f74  ,..Please do not
+00000890: 2065 6e61 626c 6520 5353 452f 5353 4532   enable SSE/SSE2
+000008a0: 206f 7074 696d 697a 6174 696f 6e20 726f   optimization ro
+000008b0: 7574 696e 652e 2054 6865 206c 6962 7261  utine. The libra
+000008c0: 7279 2062 7569 6c74 0a77 6974 6820 5353  ry built.with SS
+000008d0: 452f 5353 4532 206f 7074 696d 697a 6174  E/SSE2 optimizat
+000008e0: 696f 6e20 7769 6c6c 2063 7261 7368 2077  ion will crash w
+000008f0: 6974 686f 7574 2061 6e79 206e 6f74 6963  ithout any notic
+00000900: 6520 7768 656e 206e 6563 6573 7361 7279  e when necessary
+00000910: 0a53 5345 2f53 5345 3220 696e 7374 7275  .SSE/SSE2 instru
+00000920: 6374 696f 6e73 2061 7265 2075 6e61 7661  ctions are unava
+00000930: 696c 6162 6c65 206f 6e20 4350 5573 2e0a  ilable on CPUs..
+00000940: 0a0a 0a3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ...=============
+00000950: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
+00000960: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
+00000970: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
+00000980: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 0a34 2e20  ============.4. 
+00000990: 4c69 6365 6e73 650a 3d3d 3d3d 3d3d 3d3d  License.========
 000009a0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
 000009b0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-000009c0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 0d0a 342e  ============..4.
-000009d0: 204c 6963 656e 7365 0d0a 3d3d 3d3d 3d3d   License..======
-000009e0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-000009f0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-00000a00: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-00000a10: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-00000a20: 3d3d 3d0d 0a6c 6962 4c42 4647 5320 6973  ===..libLBFGS is
-00000a30: 2064 6973 7472 6962 7574 6564 2075 6e64   distributed und
-00000a40: 6572 2074 6865 2074 6572 6d20 6f66 2074  er the term of t
-00000a50: 6865 204d 4954 206c 6963 656e 7365 2e0d  he MIT license..
-00000a60: 0a50 6c65 6173 6520 7265 6665 7220 746f  .Please refer to
-00000a70: 2043 4f50 5949 4e47 2066 696c 6520 696e   COPYING file in
-00000a80: 2074 6865 2064 6973 7472 6962 7574 696f   the distributio
-00000a90: 6e2e 0d0a 0d0a 2449 6424 0d0a            n.....$Id$..
+000009c0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
+000009d0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
+000009e0: 3d0a 6c69 624c 4246 4753 2069 7320 6469  =.libLBFGS is di
+000009f0: 7374 7269 6275 7465 6420 756e 6465 7220  stributed under 
+00000a00: 7468 6520 7465 726d 206f 6620 7468 6520  the term of the 
+00000a10: 4d49 5420 6c69 6365 6e73 652e 0a50 6c65  MIT license..Ple
+00000a20: 6173 6520 7265 6665 7220 746f 2043 4f50  ase refer to COP
+00000a30: 5949 4e47 2066 696c 6520 696e 2074 6865  YING file in the
+00000a40: 2064 6973 7472 6962 7574 696f 6e2e 0a0a   distribution...
+00000a50: 2449 6424 0a                             $Id$.
```

## chaine/_core/tagger_wrapper.hpp

 * *Ordering differences only*

```diff
@@ -1,58 +1,58 @@
-#ifndef TAGGER_WRAPPER_H
-#define TAGGER_WRAPPER_H 1
-
-#include <stdio.h>
-#include <errno.h>
-#include <stdexcept>
-#include "crfsuite_api.hpp"
-
-namespace CRFSuiteWrapper
-{
-    class Tagger : public CRFSuite::Tagger
-    {
-    public:
-        void dump_states(int fileno)
-        {
-            if (model == NULL)
-            {
-                throw std::runtime_error("Tagger is closed");
-            }
-
-            FILE *file = fdopen(fileno, "w");
-            if (!file)
-            {
-                throw std::runtime_error("Cannot open file");
-            }
-
-            model->dump_states(model, file);
-
-            if (fclose(file))
-            {
-                throw std::runtime_error("Cannot close file");
-            };
-        }
-
-    public:
-        void dump_transitions(int fileno)
-        {
-            if (model == NULL)
-            {
-                throw std::runtime_error("Tagger is closed");
-            }
-
-            FILE *file = fdopen(fileno, "w");
-            if (!file)
-            {
-                throw std::runtime_error("Cannot open file");
-            }
-
-            model->dump_transitions(model, file);
-
-            if (fclose(file))
-            {
-                throw std::runtime_error("Cannot close file");
-            };
-        }
-    };
-} // namespace CRFSuiteWrapper
-#endif
+#ifndef TAGGER_WRAPPER_H
+#define TAGGER_WRAPPER_H 1
+
+#include <stdio.h>
+#include <errno.h>
+#include <stdexcept>
+#include "crfsuite_api.hpp"
+
+namespace CRFSuiteWrapper
+{
+    class Tagger : public CRFSuite::Tagger
+    {
+    public:
+        void dump_states(int fileno)
+        {
+            if (model == NULL)
+            {
+                throw std::runtime_error("Tagger is closed");
+            }
+
+            FILE *file = fdopen(fileno, "w");
+            if (!file)
+            {
+                throw std::runtime_error("Cannot open file");
+            }
+
+            model->dump_states(model, file);
+
+            if (fclose(file))
+            {
+                throw std::runtime_error("Cannot close file");
+            };
+        }
+
+    public:
+        void dump_transitions(int fileno)
+        {
+            if (model == NULL)
+            {
+                throw std::runtime_error("Tagger is closed");
+            }
+
+            FILE *file = fdopen(fileno, "w");
+            if (!file)
+            {
+                throw std::runtime_error("Cannot open file");
+            }
+
+            model->dump_transitions(model, file);
+
+            if (fclose(file))
+            {
+                throw std::runtime_error("Cannot close file");
+            };
+        }
+    };
+} // namespace CRFSuiteWrapper
+#endif
```

## chaine/_core/trainer_wrapper.cpp

 * *Ordering differences only*

```diff
@@ -1,32 +1,32 @@
-#include <iostream>
-#include "Python.h"
-#include "trainer_wrapper.hpp"
-#include <stdexcept>
-
-namespace CRFSuiteWrapper
-{
-    void Trainer::set_handler(PyObject *obj, messagefunc handler)
-    {
-        this->m_obj = obj;
-        this->handler = handler;
-    }
-
-    void Trainer::message(const std::string &msg)
-    {
-        if (this->m_obj == NULL)
-        {
-            std::cerr << "** Trainer invalid state: obj [" << this->m_obj << "]\n";
-            return;
-        }
-        PyObject *result = handler(this->m_obj, msg);
-        if (result == NULL)
-        {
-            throw std::runtime_error("AAAaaahhhhHHhh!!!!!");
-        }
-    }
-
-    void Trainer::_init_trainer()
-    {
-        Trainer::init();
-    }
-} // namespace CRFSuiteWrapper
+#include <iostream>
+#include "Python.h"
+#include "trainer_wrapper.hpp"
+#include <stdexcept>
+
+namespace CRFSuiteWrapper
+{
+    void Trainer::set_handler(PyObject *obj, messagefunc handler)
+    {
+        this->m_obj = obj;
+        this->handler = handler;
+    }
+
+    void Trainer::message(const std::string &msg)
+    {
+        if (this->m_obj == NULL)
+        {
+            std::cerr << "** Trainer invalid state: obj [" << this->m_obj << "]\n";
+            return;
+        }
+        PyObject *result = handler(this->m_obj, msg);
+        if (result == NULL)
+        {
+            throw std::runtime_error("AAAaaahhhhHHhh!!!!!");
+        }
+    }
+
+    void Trainer::_init_trainer()
+    {
+        Trainer::init();
+    }
+} // namespace CRFSuiteWrapper
```

## chaine/_core/trainer_wrapper.hpp

 * *Ordering differences only*

```diff
@@ -1,26 +1,26 @@
-#ifndef TRAINER_WRAPPER_H
-#define TRAINER_WRAPPER_H 1
-
-#include <string>
-#include "crfsuite_api.hpp"
-
-struct _object;
-typedef _object PyObject;
-
-namespace CRFSuiteWrapper
-{
-    typedef PyObject *(*messagefunc)(PyObject *self, std::string message);
-
-    class Trainer : public CRFSuite::Trainer
-    {
-    protected:
-        PyObject *m_obj;
-        messagefunc handler;
-
-    public:
-        void set_handler(PyObject *obj, messagefunc handler);
-        virtual void message(const std::string &msg);
-        void _init_trainer();
-    };
-} // namespace CRFSuiteWrapper
-#endif
+#ifndef TRAINER_WRAPPER_H
+#define TRAINER_WRAPPER_H 1
+
+#include <string>
+#include "crfsuite_api.hpp"
+
+struct _object;
+typedef _object PyObject;
+
+namespace CRFSuiteWrapper
+{
+    typedef PyObject *(*messagefunc)(PyObject *self, std::string message);
+
+    class Trainer : public CRFSuite::Trainer
+    {
+    protected:
+        PyObject *m_obj;
+        messagefunc handler;
+
+    public:
+        void set_handler(PyObject *obj, messagefunc handler);
+        virtual void message(const std::string &msg);
+        void _init_trainer();
+    };
+} // namespace CRFSuiteWrapper
+#endif
```

## chaine/crf.py

 * *Ordering differences only*

```diff
@@ -1,505 +1,505 @@
-"""
-chaine.crf
-~~~~~~~~~~
-
-This module implements the trainer, optimizer and model.
-"""
-
-import json
-import random
-import tempfile
-import uuid
-from functools import cached_property
-from operator import itemgetter
-from pathlib import Path
-
-from chaine._core.crf import Model as _Model
-from chaine._core.crf import Trainer as _Trainer
-from chaine.logging import Logger, set_verbosity
-from chaine.optimization.spaces import (
-    APSearchSpace,
-    AROWSearchSpace,
-    L2SGDSearchSpace,
-    LBFGSSearchSpace,
-    PASearchSpace,
-    SearchSpace,
-)
-from chaine.optimization.trial import OptimizationTrial
-from chaine.optimization.utils import cross_validation, downsample
-from chaine.typing import Filepath, Iterable, Labels, Sequence
-from chaine.validation import is_valid_sequence
-
-LOGGER = Logger(__name__)
-
-
-class Trainer:
-    """Trainer for conditional random fields.
-
-    Parameters
-    ----------
-    algorithm : str
-        The following optimization algorithms are available:
-            * lbfgs: Limited-Memory BFGS with L1/L2 regularization
-            * l2sgd: Stochastic Gradient Descent with L2 regularization
-            * ap: Averaged Perceptron
-            * pa: Passive Aggressive
-            * arow: Adaptive Regularization of Weights
-
-    Limited-Memory BFGS Parameters (lbfgs)
-    --------------------------------------
-    min_freq : float, optional (default=0)
-        Threshold value for minimum frequency of a feature occurring in training data.
-    all_possible_states : bool, optional (default=False)
-        Generate state features that do not even occur in the training data.
-    all_possible_transitions : bool, optional (default=False)
-        Generate transition features that do not even occur in the training data.
-    max_iterations : int, optional (default=None)
-        Maximum number of iterations (unlimited by default).
-    num_memories : int, optional (default=6)
-        Number of limited memories for approximating the inverse hessian matrix.
-    c1 : float, optional (default=0)
-        Coefficient for L1 regularization.
-    c2 : float, optional (default=1.0)
-        Coefficient for L2 regularization.
-    epsilon : float, optional (default=1e-5)
-        Parameter that determines the condition of convergence.
-    period : int, optional (default=10)
-        Threshold value for iterations to test the stopping criterion.
-    delta : float, optional (default=1e-5)
-        Top iteration when log likelihood is not greater than this.
-    linesearch : str, optional (default="MoreThuente")
-        Line search algorithm used in updates:
-            * MoreThuente: More and Thuente's method
-            * Backtracking: Backtracking method with regular Wolfe condition
-            * StrongBacktracking: Backtracking method with strong Wolfe condition
-    max_linesearch : int, optional (default=20)
-        Maximum number of trials for the line search algorithm.
-
-    SGD with L2 Parameters (l2sgd)
-    ------------------------------
-    min_freq : float, optional (default=0)
-        Threshold value for minimum frequency of a feature occurring in training data.
-    all_possible_states : bool, optional (default=False)
-        Generate state features that do not even occur in the training data.
-    all_possible_transitions : bool, optional (default=False)
-        Generate transition features that do not even occur in the training data.
-    max_iterations : int, optional (default=None)
-        Maximum number of iterations (1000 by default).
-    c2 : float, optional (default=1.0)
-        Coefficient for L2 regularization.
-    period : int, optional (default=10)
-        Threshold value for iterations to test the stopping criterion.
-    delta : float, optional (default=1e-5)
-        Top iteration when log likelihood is not greater than this.
-    calibration_eta : float, optional (default=0.1)
-        Initial value of learning rate (eta) used for calibration.
-    calibration_rate : float, optional (default=2.0)
-        Rate of increase/decrease of learning rate for calibration.
-    calibration_samples : int, optional (default=1000)
-        Number of instances used for calibration.
-    calibration_candidates : int, optional (default=10)
-        Number of candidates of learning rate.
-    calibration_max_trials : int, optional (default=20)
-        Maximum number of trials of learning rates for calibration.
-
-    Averaged Perceptron Parameters (ap)
-    -----------------------------------
-    min_freq : float, optional (default=0)
-        Threshold value for minimum frequency of a feature occurring in training data.
-    all_possible_states : bool, optional (default=False)
-        Generate state features that do not even occur in the training data.
-    all_possible_transitions : bool, optional (default=False)
-        Generate transition features that do not even occur in the training data.
-    max_iterations : int, optional (default=None)
-        Maximum number of iterations (100 by default).
-    epsilon : float, optional (default=1e-5)
-        Parameter that determines the condition of convergence.
-
-    Passive Aggressive Parameters (pa)
-    ----------------------------------
-    min_freq : float, optional (default=0)
-        Threshold value for minimum frequency of a feature occurring in training data.
-    all_possible_states : bool, optional (default=False)
-        Generate state features that do not even occur in the training data.
-    all_possible_transitions : bool, optional (default=False)
-        Generate transition features that do not even occur in the training data.
-    max_iterations : int, optional (default=None)
-        Maximum number of iterations (100 by default).
-    epsilon : float, optional (default=1e-5)
-        Parameter that determines the condition of convergence.
-    pa_type : int, optional (default=1)
-        Strategy for updating feature weights:
-            * 0: PA without slack variables
-            * 1: PA type I
-            * 2: PA type II
-    c : float, optional (default=1)
-        Aggressiveness parameter (used only for PA-I and PA-II).
-    error_sensitive : bool, optional (default=True)
-        Include square root of predicted incorrect labels into optimization routine.
-    averaging : bool, optional (default=True)
-        Compute average of feature weights at all updates.
-
-    Adaptive Regularization of Weights Parameters (arow)
-    ----------------------------------------------------
-    min_freq : float, optional (default=0)
-        Threshold value for minimum frequency of a feature occurring in training data.
-    all_possible_states : bool, optional (default=False)
-        Generate state features that do not even occur in the training data.
-    all_possible_transitions : bool, optional (default=False)
-        Generate transition features that do not even occur in the training data.
-    max_iterations : int, optional (default=None)
-        Maximum number of iterations (100 by default).
-    epsilon : float, optional (default=1e-5)
-        Parameter that determines the condition of convergence.
-    variance : float, optional (default=1)
-        Initial variance of every feature weight.
-    gamma : float, optional (default=1)
-        Trade-off between loss function and changes of feature weights.
-    """
-
-    def __init__(self, algorithm: str = "l2sgd", **kwargs):
-        self.algorithm = algorithm
-        self._trainer = _Trainer(algorithm, **kwargs)
-
-    def __repr__(self):
-        return f"<Trainer ({self.algorithm}): {self.params}>"
-
-    def train(
-        self,
-        dataset: Iterable[Sequence],
-        labels: Iterable[Labels],
-        *,
-        model_filepath: Filepath,
-    ):
-        """Start training on the given data set.
-
-        Parameters
-        ----------
-        dataset : Iterable[Sequence]
-            Data set consisting of sequences of feature sets.
-        labels : Iterable[Labels]
-            Labels corresponding to each instance in the data set.
-        model_filepath : Filepath, optional (default=model.chaine)
-            Path to model location.
-        """
-        LOGGER.info("Loading data set")
-        for i, (sequence, labels_) in enumerate(zip(dataset, labels)):
-            if not is_valid_sequence(sequence):
-                raise ValueError(f"Invalid format: {sequence}")
-
-            # log progress every 100 data points
-            if i > 0 and i % 100 == 0:
-                LOGGER.debug(f"{i} processed data points")
-
-            try:
-                self._trainer.append(sequence, labels_)
-            except Exception as message:
-                LOGGER.error(message)
-                LOGGER.debug(f"Sequence: {json.dumps(sequence)}")
-                LOGGER.debug(f"Labels: {json.dumps(labels_)}")
-
-        # fire!
-        LOGGER.info("Start training")
-        self._trainer.train(model_filepath)
-
-    @cached_property
-    def params(self) -> dict[str, str | int | float | bool]:
-        """Set parameters of the trainer.
-
-        Returns
-        -------
-        dict[str, str | int | float | bool]
-            Parameters of the trainer.
-        """
-        return {
-            self._trainer.param2kwarg.get(name, name): self._trainer.get_param(name)
-            for name in self._trainer.params
-        }
-
-
-class HyperparameterOptimizer:
-    def __init__(
-        self,
-        trials: int = 10,
-        seed: int | None = None,
-        metric: str = "f1",
-        folds: int = 5,
-        spaces: list[SearchSpace] = [
-            AROWSearchSpace(),
-            APSearchSpace(),
-            LBFGSSearchSpace(),
-            L2SGDSearchSpace(),
-            PASearchSpace(),
-        ],
-    ):
-        """Optimize hyperparameters in a randomized manner.
-
-        Parameters
-        ----------
-        trials : int, optional
-            Number of trials for an algorithm, by default 10.
-        seed : int | None, optional
-            Random seed, by default None.
-        metric : str, optional
-            Metric to sort the results by, by default "f1"..
-        folds : int, optional
-            Number of folds to split the data set into, by default 5.
-        spaces : list[SearchSpace], optional
-            Search spaces to select hyperparameters from, by default [AROWSearchSpace(),
-            APSearchSpace(), LBFGSSearchSpace(), L2SGDSearchSpace(), PASearchSpace()].
-        """
-        self.trials = trials
-        self.seed = seed
-        self.metric = metric
-        self.folds = folds
-        self.spaces = spaces
-        self.results = []
-        self.baselines = []
-        self.logger = Logger("hyperparameter-optimization")
-
-    def optimize_hyperparameters(
-        self,
-        dataset: Iterable[Sequence],
-        labels: Iterable[Labels],
-        sample_size: int | None = None,
-    ) -> list[dict[str, dict]]:
-        """Optimize hyperparameters on the given data set.
-
-        Parameters
-        ----------
-        dataset : Iterable[Sequence]
-            Data set to train models on.
-        labels : Iterable[Labels]
-            Labels to train models on.
-        sample_size : int | None
-            Number of instances to sample from the data set.
-
-        Returns
-        -------
-        list[dict[str, dict]]
-            Sorted list of hyperparameters and evaluation scores.
-        """
-        # disable logging
-        set_verbosity(0)
-
-        # set random seed
-        random.seed(self.seed)
-
-        # optional downsampling
-        if sample_size:
-            dataset, labels = downsample(dataset, labels, sample_size, self.seed)
-
-        # split data set for cross validation
-        splits = list(cross_validation(dataset, labels, k=self.folds))
-
-        for i, space in enumerate(self.spaces):
-            self.logger.info(f"Starting with {space.algorithm} ({i + 1}/{len(self.spaces)})")
-            self.logger.info(f"Baseline for {space.algorithm}")
-
-            with OptimizationTrial(splits, space, is_baseline=True) as trial:
-                self.results.append(trial)
-                self.baselines.append(trial["stats"])
-
-            for j in range(self.trials):
-                self.logger.info(f"Trial {j + 1}/{self.trials} for {space.algorithm}")
-
-                with OptimizationTrial(splits, space, is_baseline=False) as trial:
-                    self.results.append(trial)
-
-                self.logger.info(f"Best baseline model: {self._best_baseline_score}")
-                self.logger.info(f"Best optimized model: {self._best_optimized_score}")
-
-        self.logger.info("Finished hyperparameter optimization")
-        self.logger.info(f"Trained {len(self.results)} models with different hyperparamters")
-
-        # make more verbose again
-        set_verbosity(1)
-
-        # return sorted results
-        return sorted(self.results, key=self._metric, reverse=True)
-
-    @property
-    def _best_baseline_score(self) -> str | float:
-        """Best evaluation score with default hyperparameters.
-
-        Returns
-        -------
-        str | float
-            Score (or 'n/a' of no results available).
-        """
-        if self.baselines:
-            best = sorted(self.baselines, key=itemgetter(f"mean_{self.metric}"), reverse=True)[0]
-            return best[f"mean_{self.metric}"]
-
-        return "n/a"
-
-    @property
-    def _best_optimized_score(self) -> str | float:
-        """Best evaluation score with optimized hyperparameters.
-
-        Returns
-        -------
-        str | float
-            Score (or 'n/a' of no results available).
-        """
-        if self.results:
-            best = sorted(self.results, key=self._metric, reverse=True)[0]
-            return best["stats"][f"mean_{self.metric}"]
-
-        return "n/a"
-
-    def _metric(self, trial: dict[str, dict]) -> float:
-        """Metric so select for sorting.
-
-        Parameters
-        ----------
-        trial : dict[str, dict]
-            Optimization trial result.
-
-        Returns
-        -------
-        float
-            Metric score.
-        """
-        return trial["stats"][f"mean_{self.metric}"]
-
-
-class Model:
-    """Linear-chain conditional random field.
-
-    Parameters
-    ----------
-    model_filepath : Filepath
-        Path to the trained model.
-    """
-
-    def __init__(self, filepath: Filepath):
-        self._model = _Model(filepath)
-
-    def __repr__(self):
-        return f"<Model: {self.labels}>"
-
-    @cached_property
-    def labels(self) -> set[str]:
-        """Labels the model is trained on."""
-        return set(self._model.labels)
-
-    @cached_property
-    def transitions(self) -> dict[str, float]:
-        """Learned transition weights."""
-        # get temporary file to dump the transitions
-        filepath = Path(tempfile.gettempdir(), str(uuid.uuid4()))
-
-        # write model to disk
-        self.dump_transitions(filepath)
-
-        # return the components
-        transitions = json.loads(filepath.read_text())
-
-        # cleanup
-        filepath.unlink()
-
-        return transitions
-
-    @cached_property
-    def states(self) -> dict[str, float]:
-        """Learned state feature weights."""
-        # get temporary file to dump the states
-        filepath = Path(tempfile.gettempdir(), str(uuid.uuid4()))
-
-        # write model to disk
-        self.dump_states(filepath)
-
-        # return the components
-        states = json.loads(filepath.read_text())
-
-        # cleanup
-        filepath.unlink()
-
-        return states
-
-    def predict_single(self, sequence: Sequence) -> list[str]:
-        """Predict most likely labels for a given sequence of tokens.
-
-        Parameters
-        ----------
-        sequence : Sequence
-            Sequence of tokens represented as feature dictionaries.
-
-        Returns
-        -------
-        list[str]
-            Most likely label sequence.
-        """
-        if not is_valid_sequence(sequence):
-            raise ValueError(f"Invalid format: {sequence}")
-
-        return self._model.predict_single(sequence)
-
-    def predict(self, sequences: Iterable[Sequence]) -> list[list[str]]:
-        """Predict most likely labels for a batch of tokens
-
-        Parameters
-        ----------
-        sequences : Iterable[Sequence]
-            Batch of sequences of tokens represented as feature dictionaries.
-
-        Returns
-        -------
-        list[list[str]]
-            Most likely label sequences.
-        """
-        return [self.predict_single(sequence) for sequence in sequences]
-
-    def predict_proba_single(self, sequence: Sequence) -> list[dict[str, float]]:
-        """Predict probabilities over all labels for each token in a sequence.
-
-        Parameters
-        ----------
-        sequence : Sequence
-            Sequence of tokens represented as feature dictionaries.
-
-        Returns
-        -------
-        list[dict[str, float]]
-            Probability distributions over all labels for each token.
-        """
-        if not is_valid_sequence(sequence):
-            raise ValueError(f"Invalid format: {sequence}")
-
-        return self._model.predict_proba_single(sequence)
-
-    def predict_proba(self, sequences: Iterable[Sequence]) -> list[list[dict[str, float]]]:
-        """Predict probabilities over all labels for each token in a batch of sequences.
-
-        Parameters
-        ----------
-        sequences : Sequence
-            Batch of sequences of tokens represented as feature dictionaries.
-
-        Returns
-        -------
-        list[dict[str, float]]
-            Probability distributions over all labels for each token in the sequences.
-        """
-        return [self.predict_proba_single(sequence) for sequence in sequences]
-
-    def dump_transitions(self, filepath: Filepath):
-        """Dump learned transitions with weights as JSON.
-
-        Parameters
-        ----------
-        filepath : Filepath
-            File to dump transitions to.
-        """
-        self._model.dump_transitions(filepath)
-
-    def dump_states(self, filepath: Filepath):
-        """Dump learned states with weights as JSON.
-
-        Parameters
-        ----------
-        filepath : Filepath
-            File to dump states to.
-        """
-        self._model.dump_states(filepath)
+"""
+chaine.crf
+~~~~~~~~~~
+
+This module implements the trainer, optimizer and model.
+"""
+
+import json
+import random
+import tempfile
+import uuid
+from functools import cached_property
+from operator import itemgetter
+from pathlib import Path
+
+from chaine._core.crf import Model as _Model
+from chaine._core.crf import Trainer as _Trainer
+from chaine.logging import Logger, set_verbosity
+from chaine.optimization.spaces import (
+    APSearchSpace,
+    AROWSearchSpace,
+    L2SGDSearchSpace,
+    LBFGSSearchSpace,
+    PASearchSpace,
+    SearchSpace,
+)
+from chaine.optimization.trial import OptimizationTrial
+from chaine.optimization.utils import cross_validation, downsample
+from chaine.typing import Filepath, Iterable, Labels, Sequence
+from chaine.validation import is_valid_sequence
+
+LOGGER = Logger(__name__)
+
+
+class Trainer:
+    """Trainer for conditional random fields.
+
+    Parameters
+    ----------
+    algorithm : str
+        The following optimization algorithms are available:
+            * lbfgs: Limited-Memory BFGS with L1/L2 regularization
+            * l2sgd: Stochastic Gradient Descent with L2 regularization
+            * ap: Averaged Perceptron
+            * pa: Passive Aggressive
+            * arow: Adaptive Regularization of Weights
+
+    Limited-Memory BFGS Parameters (lbfgs)
+    --------------------------------------
+    min_freq : float, optional (default=0)
+        Threshold value for minimum frequency of a feature occurring in training data.
+    all_possible_states : bool, optional (default=False)
+        Generate state features that do not even occur in the training data.
+    all_possible_transitions : bool, optional (default=False)
+        Generate transition features that do not even occur in the training data.
+    max_iterations : int, optional (default=None)
+        Maximum number of iterations (unlimited by default).
+    num_memories : int, optional (default=6)
+        Number of limited memories for approximating the inverse hessian matrix.
+    c1 : float, optional (default=0)
+        Coefficient for L1 regularization.
+    c2 : float, optional (default=1.0)
+        Coefficient for L2 regularization.
+    epsilon : float, optional (default=1e-5)
+        Parameter that determines the condition of convergence.
+    period : int, optional (default=10)
+        Threshold value for iterations to test the stopping criterion.
+    delta : float, optional (default=1e-5)
+        Top iteration when log likelihood is not greater than this.
+    linesearch : str, optional (default="MoreThuente")
+        Line search algorithm used in updates:
+            * MoreThuente: More and Thuente's method
+            * Backtracking: Backtracking method with regular Wolfe condition
+            * StrongBacktracking: Backtracking method with strong Wolfe condition
+    max_linesearch : int, optional (default=20)
+        Maximum number of trials for the line search algorithm.
+
+    SGD with L2 Parameters (l2sgd)
+    ------------------------------
+    min_freq : float, optional (default=0)
+        Threshold value for minimum frequency of a feature occurring in training data.
+    all_possible_states : bool, optional (default=False)
+        Generate state features that do not even occur in the training data.
+    all_possible_transitions : bool, optional (default=False)
+        Generate transition features that do not even occur in the training data.
+    max_iterations : int, optional (default=None)
+        Maximum number of iterations (1000 by default).
+    c2 : float, optional (default=1.0)
+        Coefficient for L2 regularization.
+    period : int, optional (default=10)
+        Threshold value for iterations to test the stopping criterion.
+    delta : float, optional (default=1e-5)
+        Top iteration when log likelihood is not greater than this.
+    calibration_eta : float, optional (default=0.1)
+        Initial value of learning rate (eta) used for calibration.
+    calibration_rate : float, optional (default=2.0)
+        Rate of increase/decrease of learning rate for calibration.
+    calibration_samples : int, optional (default=1000)
+        Number of instances used for calibration.
+    calibration_candidates : int, optional (default=10)
+        Number of candidates of learning rate.
+    calibration_max_trials : int, optional (default=20)
+        Maximum number of trials of learning rates for calibration.
+
+    Averaged Perceptron Parameters (ap)
+    -----------------------------------
+    min_freq : float, optional (default=0)
+        Threshold value for minimum frequency of a feature occurring in training data.
+    all_possible_states : bool, optional (default=False)
+        Generate state features that do not even occur in the training data.
+    all_possible_transitions : bool, optional (default=False)
+        Generate transition features that do not even occur in the training data.
+    max_iterations : int, optional (default=None)
+        Maximum number of iterations (100 by default).
+    epsilon : float, optional (default=1e-5)
+        Parameter that determines the condition of convergence.
+
+    Passive Aggressive Parameters (pa)
+    ----------------------------------
+    min_freq : float, optional (default=0)
+        Threshold value for minimum frequency of a feature occurring in training data.
+    all_possible_states : bool, optional (default=False)
+        Generate state features that do not even occur in the training data.
+    all_possible_transitions : bool, optional (default=False)
+        Generate transition features that do not even occur in the training data.
+    max_iterations : int, optional (default=None)
+        Maximum number of iterations (100 by default).
+    epsilon : float, optional (default=1e-5)
+        Parameter that determines the condition of convergence.
+    pa_type : int, optional (default=1)
+        Strategy for updating feature weights:
+            * 0: PA without slack variables
+            * 1: PA type I
+            * 2: PA type II
+    c : float, optional (default=1)
+        Aggressiveness parameter (used only for PA-I and PA-II).
+    error_sensitive : bool, optional (default=True)
+        Include square root of predicted incorrect labels into optimization routine.
+    averaging : bool, optional (default=True)
+        Compute average of feature weights at all updates.
+
+    Adaptive Regularization of Weights Parameters (arow)
+    ----------------------------------------------------
+    min_freq : float, optional (default=0)
+        Threshold value for minimum frequency of a feature occurring in training data.
+    all_possible_states : bool, optional (default=False)
+        Generate state features that do not even occur in the training data.
+    all_possible_transitions : bool, optional (default=False)
+        Generate transition features that do not even occur in the training data.
+    max_iterations : int, optional (default=None)
+        Maximum number of iterations (100 by default).
+    epsilon : float, optional (default=1e-5)
+        Parameter that determines the condition of convergence.
+    variance : float, optional (default=1)
+        Initial variance of every feature weight.
+    gamma : float, optional (default=1)
+        Trade-off between loss function and changes of feature weights.
+    """
+
+    def __init__(self, algorithm: str = "l2sgd", **kwargs):
+        self.algorithm = algorithm
+        self._trainer = _Trainer(algorithm, **kwargs)
+
+    def __repr__(self):
+        return f"<Trainer ({self.algorithm}): {self.params}>"
+
+    def train(
+        self,
+        dataset: Iterable[Sequence],
+        labels: Iterable[Labels],
+        *,
+        model_filepath: Filepath,
+    ):
+        """Start training on the given data set.
+
+        Parameters
+        ----------
+        dataset : Iterable[Sequence]
+            Data set consisting of sequences of feature sets.
+        labels : Iterable[Labels]
+            Labels corresponding to each instance in the data set.
+        model_filepath : Filepath, optional (default=model.chaine)
+            Path to model location.
+        """
+        LOGGER.info("Loading data set")
+        for i, (sequence, labels_) in enumerate(zip(dataset, labels)):
+            if not is_valid_sequence(sequence):
+                raise ValueError(f"Invalid format: {sequence}")
+
+            # log progress every 100 data points
+            if i > 0 and i % 100 == 0:
+                LOGGER.debug(f"{i} processed data points")
+
+            try:
+                self._trainer.append(sequence, labels_)
+            except Exception as message:
+                LOGGER.error(message)
+                LOGGER.debug(f"Sequence: {json.dumps(sequence)}")
+                LOGGER.debug(f"Labels: {json.dumps(labels_)}")
+
+        # fire!
+        LOGGER.info("Start training")
+        self._trainer.train(model_filepath)
+
+    @cached_property
+    def params(self) -> dict[str, str | int | float | bool]:
+        """Set parameters of the trainer.
+
+        Returns
+        -------
+        dict[str, str | int | float | bool]
+            Parameters of the trainer.
+        """
+        return {
+            self._trainer.param2kwarg.get(name, name): self._trainer.get_param(name)
+            for name in self._trainer.params
+        }
+
+
+class HyperparameterOptimizer:
+    def __init__(
+        self,
+        trials: int = 10,
+        seed: int | None = None,
+        metric: str = "f1",
+        folds: int = 5,
+        spaces: list[SearchSpace] = [
+            AROWSearchSpace(),
+            APSearchSpace(),
+            LBFGSSearchSpace(),
+            L2SGDSearchSpace(),
+            PASearchSpace(),
+        ],
+    ):
+        """Optimize hyperparameters in a randomized manner.
+
+        Parameters
+        ----------
+        trials : int, optional
+            Number of trials for an algorithm, by default 10.
+        seed : int | None, optional
+            Random seed, by default None.
+        metric : str, optional
+            Metric to sort the results by, by default "f1"..
+        folds : int, optional
+            Number of folds to split the data set into, by default 5.
+        spaces : list[SearchSpace], optional
+            Search spaces to select hyperparameters from, by default [AROWSearchSpace(),
+            APSearchSpace(), LBFGSSearchSpace(), L2SGDSearchSpace(), PASearchSpace()].
+        """
+        self.trials = trials
+        self.seed = seed
+        self.metric = metric
+        self.folds = folds
+        self.spaces = spaces
+        self.results = []
+        self.baselines = []
+        self.logger = Logger("hyperparameter-optimization")
+
+    def optimize_hyperparameters(
+        self,
+        dataset: Iterable[Sequence],
+        labels: Iterable[Labels],
+        sample_size: int | None = None,
+    ) -> list[dict[str, dict]]:
+        """Optimize hyperparameters on the given data set.
+
+        Parameters
+        ----------
+        dataset : Iterable[Sequence]
+            Data set to train models on.
+        labels : Iterable[Labels]
+            Labels to train models on.
+        sample_size : int | None
+            Number of instances to sample from the data set.
+
+        Returns
+        -------
+        list[dict[str, dict]]
+            Sorted list of hyperparameters and evaluation scores.
+        """
+        # disable logging
+        set_verbosity(0)
+
+        # set random seed
+        random.seed(self.seed)
+
+        # optional downsampling
+        if sample_size:
+            dataset, labels = downsample(dataset, labels, sample_size, self.seed)
+
+        # split data set for cross validation
+        splits = list(cross_validation(dataset, labels, k=self.folds))
+
+        for i, space in enumerate(self.spaces):
+            self.logger.info(f"Starting with {space.algorithm} ({i + 1}/{len(self.spaces)})")
+            self.logger.info(f"Baseline for {space.algorithm}")
+
+            with OptimizationTrial(splits, space, is_baseline=True) as trial:
+                self.results.append(trial)
+                self.baselines.append(trial["stats"])
+
+            for j in range(self.trials):
+                self.logger.info(f"Trial {j + 1}/{self.trials} for {space.algorithm}")
+
+                with OptimizationTrial(splits, space, is_baseline=False) as trial:
+                    self.results.append(trial)
+
+                self.logger.info(f"Best baseline model: {self._best_baseline_score}")
+                self.logger.info(f"Best optimized model: {self._best_optimized_score}")
+
+        self.logger.info("Finished hyperparameter optimization")
+        self.logger.info(f"Trained {len(self.results)} models with different hyperparamters")
+
+        # make more verbose again
+        set_verbosity(1)
+
+        # return sorted results
+        return sorted(self.results, key=self._metric, reverse=True)
+
+    @property
+    def _best_baseline_score(self) -> str | float:
+        """Best evaluation score with default hyperparameters.
+
+        Returns
+        -------
+        str | float
+            Score (or 'n/a' of no results available).
+        """
+        if self.baselines:
+            best = sorted(self.baselines, key=itemgetter(f"mean_{self.metric}"), reverse=True)[0]
+            return best[f"mean_{self.metric}"]
+
+        return "n/a"
+
+    @property
+    def _best_optimized_score(self) -> str | float:
+        """Best evaluation score with optimized hyperparameters.
+
+        Returns
+        -------
+        str | float
+            Score (or 'n/a' of no results available).
+        """
+        if self.results:
+            best = sorted(self.results, key=self._metric, reverse=True)[0]
+            return best["stats"][f"mean_{self.metric}"]
+
+        return "n/a"
+
+    def _metric(self, trial: dict[str, dict]) -> float:
+        """Metric so select for sorting.
+
+        Parameters
+        ----------
+        trial : dict[str, dict]
+            Optimization trial result.
+
+        Returns
+        -------
+        float
+            Metric score.
+        """
+        return trial["stats"][f"mean_{self.metric}"]
+
+
+class Model:
+    """Linear-chain conditional random field.
+
+    Parameters
+    ----------
+    model_filepath : Filepath
+        Path to the trained model.
+    """
+
+    def __init__(self, filepath: Filepath):
+        self._model = _Model(filepath)
+
+    def __repr__(self):
+        return f"<Model: {self.labels}>"
+
+    @cached_property
+    def labels(self) -> set[str]:
+        """Labels the model is trained on."""
+        return set(self._model.labels)
+
+    @cached_property
+    def transitions(self) -> dict[str, float]:
+        """Learned transition weights."""
+        # get temporary file to dump the transitions
+        filepath = Path(tempfile.gettempdir(), str(uuid.uuid4()))
+
+        # write model to disk
+        self.dump_transitions(filepath)
+
+        # return the components
+        transitions = json.loads(filepath.read_text())
+
+        # cleanup
+        filepath.unlink()
+
+        return transitions
+
+    @cached_property
+    def states(self) -> dict[str, float]:
+        """Learned state feature weights."""
+        # get temporary file to dump the states
+        filepath = Path(tempfile.gettempdir(), str(uuid.uuid4()))
+
+        # write model to disk
+        self.dump_states(filepath)
+
+        # return the components
+        states = json.loads(filepath.read_text())
+
+        # cleanup
+        filepath.unlink()
+
+        return states
+
+    def predict_single(self, sequence: Sequence) -> list[str]:
+        """Predict most likely labels for a given sequence of tokens.
+
+        Parameters
+        ----------
+        sequence : Sequence
+            Sequence of tokens represented as feature dictionaries.
+
+        Returns
+        -------
+        list[str]
+            Most likely label sequence.
+        """
+        if not is_valid_sequence(sequence):
+            raise ValueError(f"Invalid format: {sequence}")
+
+        return self._model.predict_single(sequence)
+
+    def predict(self, sequences: Iterable[Sequence]) -> list[list[str]]:
+        """Predict most likely labels for a batch of tokens
+
+        Parameters
+        ----------
+        sequences : Iterable[Sequence]
+            Batch of sequences of tokens represented as feature dictionaries.
+
+        Returns
+        -------
+        list[list[str]]
+            Most likely label sequences.
+        """
+        return [self.predict_single(sequence) for sequence in sequences]
+
+    def predict_proba_single(self, sequence: Sequence) -> list[dict[str, float]]:
+        """Predict probabilities over all labels for each token in a sequence.
+
+        Parameters
+        ----------
+        sequence : Sequence
+            Sequence of tokens represented as feature dictionaries.
+
+        Returns
+        -------
+        list[dict[str, float]]
+            Probability distributions over all labels for each token.
+        """
+        if not is_valid_sequence(sequence):
+            raise ValueError(f"Invalid format: {sequence}")
+
+        return self._model.predict_proba_single(sequence)
+
+    def predict_proba(self, sequences: Iterable[Sequence]) -> list[list[dict[str, float]]]:
+        """Predict probabilities over all labels for each token in a batch of sequences.
+
+        Parameters
+        ----------
+        sequences : Sequence
+            Batch of sequences of tokens represented as feature dictionaries.
+
+        Returns
+        -------
+        list[dict[str, float]]
+            Probability distributions over all labels for each token in the sequences.
+        """
+        return [self.predict_proba_single(sequence) for sequence in sequences]
+
+    def dump_transitions(self, filepath: Filepath):
+        """Dump learned transitions with weights as JSON.
+
+        Parameters
+        ----------
+        filepath : Filepath
+            File to dump transitions to.
+        """
+        self._model.dump_transitions(filepath)
+
+    def dump_states(self, filepath: Filepath):
+        """Dump learned states with weights as JSON.
+
+        Parameters
+        ----------
+        filepath : Filepath
+            File to dump states to.
+        """
+        self._model.dump_states(filepath)
```

## chaine/logging.py

 * *Ordering differences only*

```diff
@@ -1,214 +1,214 @@
-"""
-chaine.logging
-~~~~~~~~~~~~~~
-
-This module implements a basic logger.
-"""
-
-import logging
-import sys
-from logging import Formatter, StreamHandler
-
-DEBUG = 10
-INFO = 20
-WARNING = 30
-ERROR = 40
-LEVELS = {"DEBUG": DEBUG, "INFO": INFO, "WARNING": WARNING, "ERROR": ERROR}
-
-DEFAULT_FORMAT = Formatter("[%(asctime)s] [%(levelname)s] %(message)s")
-DEBUG_FORMAT = Formatter("[%(asctime)s] %(name)s:%(lineno)d [%(levelname)s] %(message)s")
-
-
-class Logger:
-    def __init__(self, name: str):
-        """Basic logger
-
-        Parameters
-        ----------
-        name : str
-            Name of the logger
-        """
-        self.name = name
-
-        # return a logger with the specified name, creating it if necessary
-        self._logger = logging.getLogger(name)
-
-        # stream handler to stdout
-        self._stream_handler = StreamHandler(sys.stdout)
-        self._logger.addHandler(self._stream_handler)
-
-        # set level of both the logger and the handler to INFO by default
-        self.set_level("INFO")
-
-    def set_level(self, level: str | int):
-        # translate string to integer
-        if isinstance(level, str):
-            level = LEVELS[level.upper()]
-
-        # set the logger's level
-        self._logger.setLevel(level)
-
-        # and all handlers
-        for handler in self._logger.handlers:
-            handler.setLevel(level)
-
-            # optionally change the formatter (log more when in debug mode)
-            if level < INFO:
-                handler.setFormatter(DEBUG_FORMAT)
-            else:
-                handler.setFormatter(DEFAULT_FORMAT)
-
-    def debug(self, message: str):
-        """Debug log message
-
-        Parameters
-        ----------
-        message : str
-            Message to log
-        """
-        if self._logger.isEnabledFor(DEBUG):
-            self._logger._log(DEBUG, message, ())
-
-    def info(self, message: str):
-        """Info log message
-
-        Parameters
-        ----------
-        message : str
-            Message to log
-        """
-        if self._logger.isEnabledFor(INFO):
-            self._logger._log(INFO, message, ())
-
-    def warning(self, message: str):
-        """Warning log message
-
-        Parameters
-        ----------
-        message : str
-            Message to log
-        """
-        if self._logger.isEnabledFor(WARNING):
-            self._logger._log(WARNING, message, ())
-
-    def error(self, message: str | Exception):
-        """Error log message
-
-        Parameters
-        ----------
-        message : str
-            Message to log
-        """
-        if self._logger.isEnabledFor(ERROR):
-            if isinstance(message, Exception):
-                # log stacktrace if message is an exception
-                self._logger._log(ERROR, message, (), exc_info=True)
-            else:
-                self._logger._log(ERROR, message, ())
-
-    @property
-    def in_debug_mode(self) -> bool:
-        """Checks if the logger's level is DEBUG
-
-        Returns
-        -------
-        bool
-            True, if logger is in DEBUG mode, False otherwise
-        """
-        return self._logger.level == DEBUG
-
-    @property
-    def level(self) -> int:
-        """Returns the current log level
-
-        Returns
-        -------
-        int
-            Log level.
-        """
-        return self._logger.level
-
-    def __repr__(self):
-        return f"<Logger: {self.name} ({self.level})>"
-
-
-def get_logger(name: str) -> logging.Logger:
-    """Gets the specified logger object
-
-    Parameters
-    ----------
-    name : str
-        Name of the module to get the logger for
-
-    Returns
-    -------
-    logging.Logger
-        Logger of the specified module
-    """
-    return logging.getLogger(name)
-
-
-def logger_exists(name: str) -> bool:
-    """Checks if a logger exists for the specified module
-
-    Parameters
-    ----------
-    name : str
-        Name of the module to check the logger for
-
-    Returns
-    -------
-    bool
-        True if logger exists, False otherwise
-    """
-    return logging.getLogger(name).hasHa
-    ndlers()
-
-
-def set_level(name: str, level: int | str):
-    """Sets log level for the specified logger
-
-    Parameters
-    ----------
-    name : str
-        Name of the module
-    level : int | str
-        Level to set
-    """
-    logger = logging.getLogger(name)
-
-    # translate string to integer
-    if isinstance(level, str):
-        level = LEVELS[level.upper()]
-
-    # set the logger's level
-    logger.setLevel(level)
-
-    # and all handlers
-    for handler in logger.handlers:
-        handler.setLevel(level)
-
-        # optionally change the formatter (log more when in debug mode)
-        if level < INFO:
-            handler.setFormatter(DEBUG_FORMAT)
-        else:
-            handler.setFormatter(DEFAULT_FORMAT)
-
-
-def set_verbosity(level: int):
-    """Sets verbosity to the given level
-
-    Parameters
-    ----------
-    level : int
-        Logg only errors (0), info (1) or even debug messages (2)
-    """
-    if level == 0:
-        set_level("chaine._core.crf", "ERROR")
-        set_level("chaine.crf", "ERROR")
-    elif level == 1:
-        set_level("chaine._core.crf", "INFO")
-        set_level("chaine.crf", "INFO")
-    elif level == 2:
-        set_level("chaine._core.crf", "DEBUG")
-        set_level("chaine.crf", "DEBUG")
+"""
+chaine.logging
+~~~~~~~~~~~~~~
+
+This module implements a basic logger.
+"""
+
+import logging
+import sys
+from logging import Formatter, StreamHandler
+
+DEBUG = 10
+INFO = 20
+WARNING = 30
+ERROR = 40
+LEVELS = {"DEBUG": DEBUG, "INFO": INFO, "WARNING": WARNING, "ERROR": ERROR}
+
+DEFAULT_FORMAT = Formatter("[%(asctime)s] [%(levelname)s] %(message)s")
+DEBUG_FORMAT = Formatter("[%(asctime)s] %(name)s:%(lineno)d [%(levelname)s] %(message)s")
+
+
+class Logger:
+    def __init__(self, name: str):
+        """Basic logger
+
+        Parameters
+        ----------
+        name : str
+            Name of the logger
+        """
+        self.name = name
+
+        # return a logger with the specified name, creating it if necessary
+        self._logger = logging.getLogger(name)
+
+        # stream handler to stdout
+        self._stream_handler = StreamHandler(sys.stdout)
+        self._logger.addHandler(self._stream_handler)
+
+        # set level of both the logger and the handler to INFO by default
+        self.set_level("INFO")
+
+    def set_level(self, level: str | int):
+        # translate string to integer
+        if isinstance(level, str):
+            level = LEVELS[level.upper()]
+
+        # set the logger's level
+        self._logger.setLevel(level)
+
+        # and all handlers
+        for handler in self._logger.handlers:
+            handler.setLevel(level)
+
+            # optionally change the formatter (log more when in debug mode)
+            if level < INFO:
+                handler.setFormatter(DEBUG_FORMAT)
+            else:
+                handler.setFormatter(DEFAULT_FORMAT)
+
+    def debug(self, message: str):
+        """Debug log message
+
+        Parameters
+        ----------
+        message : str
+            Message to log
+        """
+        if self._logger.isEnabledFor(DEBUG):
+            self._logger._log(DEBUG, message, ())
+
+    def info(self, message: str):
+        """Info log message
+
+        Parameters
+        ----------
+        message : str
+            Message to log
+        """
+        if self._logger.isEnabledFor(INFO):
+            self._logger._log(INFO, message, ())
+
+    def warning(self, message: str):
+        """Warning log message
+
+        Parameters
+        ----------
+        message : str
+            Message to log
+        """
+        if self._logger.isEnabledFor(WARNING):
+            self._logger._log(WARNING, message, ())
+
+    def error(self, message: str | Exception):
+        """Error log message
+
+        Parameters
+        ----------
+        message : str
+            Message to log
+        """
+        if self._logger.isEnabledFor(ERROR):
+            if isinstance(message, Exception):
+                # log stacktrace if message is an exception
+                self._logger._log(ERROR, message, (), exc_info=True)
+            else:
+                self._logger._log(ERROR, message, ())
+
+    @property
+    def in_debug_mode(self) -> bool:
+        """Checks if the logger's level is DEBUG
+
+        Returns
+        -------
+        bool
+            True, if logger is in DEBUG mode, False otherwise
+        """
+        return self._logger.level == DEBUG
+
+    @property
+    def level(self) -> int:
+        """Returns the current log level
+
+        Returns
+        -------
+        int
+            Log level.
+        """
+        return self._logger.level
+
+    def __repr__(self):
+        return f"<Logger: {self.name} ({self.level})>"
+
+
+def get_logger(name: str) -> logging.Logger:
+    """Gets the specified logger object
+
+    Parameters
+    ----------
+    name : str
+        Name of the module to get the logger for
+
+    Returns
+    -------
+    logging.Logger
+        Logger of the specified module
+    """
+    return logging.getLogger(name)
+
+
+def logger_exists(name: str) -> bool:
+    """Checks if a logger exists for the specified module
+
+    Parameters
+    ----------
+    name : str
+        Name of the module to check the logger for
+
+    Returns
+    -------
+    bool
+        True if logger exists, False otherwise
+    """
+    return logging.getLogger(name).hasHa
+    ndlers()
+
+
+def set_level(name: str, level: int | str):
+    """Sets log level for the specified logger
+
+    Parameters
+    ----------
+    name : str
+        Name of the module
+    level : int | str
+        Level to set
+    """
+    logger = logging.getLogger(name)
+
+    # translate string to integer
+    if isinstance(level, str):
+        level = LEVELS[level.upper()]
+
+    # set the logger's level
+    logger.setLevel(level)
+
+    # and all handlers
+    for handler in logger.handlers:
+        handler.setLevel(level)
+
+        # optionally change the formatter (log more when in debug mode)
+        if level < INFO:
+            handler.setFormatter(DEBUG_FORMAT)
+        else:
+            handler.setFormatter(DEFAULT_FORMAT)
+
+
+def set_verbosity(level: int):
+    """Sets verbosity to the given level
+
+    Parameters
+    ----------
+    level : int
+        Logg only errors (0), info (1) or even debug messages (2)
+    """
+    if level == 0:
+        set_level("chaine._core.crf", "ERROR")
+        set_level("chaine.crf", "ERROR")
+    elif level == 1:
+        set_level("chaine._core.crf", "INFO")
+        set_level("chaine.crf", "INFO")
+    elif level == 2:
+        set_level("chaine._core.crf", "DEBUG")
+        set_level("chaine.crf", "DEBUG")
```

## chaine/optimization/__init__.py

 * *Ordering differences only*

```diff
@@ -1,10 +1,10 @@
-from chaine.optimization import utils
-from chaine.optimization.spaces import (
-    APSearchSpace,
-    AROWSearchSpace,
-    L2SGDSearchSpace,
-    LBFGSSearchSpace,
-    PASearchSpace,
-    SearchSpace,
-)
-from chaine.optimization.trial import OptimizationTrial
+from chaine.optimization import utils
+from chaine.optimization.spaces import (
+    APSearchSpace,
+    AROWSearchSpace,
+    L2SGDSearchSpace,
+    LBFGSSearchSpace,
+    PASearchSpace,
+    SearchSpace,
+)
+from chaine.optimization.trial import OptimizationTrial
```

## chaine/optimization/metrics.py

 * *Ordering differences only*

```diff
@@ -1,129 +1,129 @@
-"""
-chaine.optimization.metrics
-~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
-This module implements metrics to evaluate the performance of a trained model.
-"""
-
-from collections import Counter
-
-
-def calculate_precision(true_positives: int, false_positives: int) -> float:
-    """Calculate precision score.
-
-    Parameters
-    ----------
-    true_positives : int
-        Number of true positives.
-    false_positives : int
-        Number of false positives.
-
-    Returns
-    -------
-    float
-        Precision score.
-    """
-    try:
-        return true_positives / (true_positives + false_positives)
-    except ZeroDivisionError:
-        # only false negatives is perfect precision
-        return 1.0
-
-
-def calculate_recall(true_positives: int, false_negatives: int) -> float:
-    """Calculate recall score.
-
-    Parameters
-    ----------
-    true_positives : int
-        Number of true positives.
-    false_negatives : int
-        Number of false negatives.
-
-    Returns
-    -------
-    float
-        Recall score.
-    """
-    try:
-        return true_positives / (true_positives + false_negatives)
-    except ZeroDivisionError:
-        # only false positives is imperfect recall
-        return 0.0
-
-
-def calculate_f1(true_positives: int, false_positives: int, false_negatives: int) -> float:
-    """Calculate F1 score.
-
-    Parameters
-    ----------
-    true_positives : int
-        Number of true positives.
-    false_negatives : int
-        Number of false negatives.
-
-    Returns
-    -------
-    float
-        Precision score
-    """
-    precision = calculate_precision(true_positives, false_positives)
-    recall = calculate_recall(true_positives, false_negatives)
-    try:
-        return (2 * precision * recall) / (precision + recall)
-    except ZeroDivisionError:
-        # zero precision and zero recall is zero f1
-        return 0.0
-
-
-def evaluate_predictions(true: list[list[str]], pred: list[list[str]]) -> dict[str, float]:
-    """Evaluate the given predictions with the true labels.
-
-    Parameters
-    ----------
-    true : list[list[str]]
-        True labels.
-    pred : list[list[str]]
-        Predicted labels.
-
-    Returns
-    -------
-    dict[str, float]
-        Precision, recall and F1 scores.
-    """
-    # validate input
-    if (
-        not isinstance(true, list)
-        or not isinstance(pred, list)
-        or not isinstance(true[0], list)
-        or not isinstance(pred[0], list)
-    ):
-        raise ValueError("Input lists are invalid")
-
-    counts = Counter()
-
-    # get true positives, true negatives, false positives, false negatives
-    for true_labels, predicted_labels in zip(true, pred):
-        # ignore prefixes
-        true_labels = [l.removeprefix("B-").removeprefix("I-") for l in true_labels]
-        predicted_labels = [l.removeprefix("B-").removeprefix("I-") for l in predicted_labels]
-
-        if len(true_labels) != len(predicted_labels):
-            raise ValueError(f"Different lengths: '{true_labels}' vs. '{predicted_labels}'")
-
-        for true_label, predicted_label in zip(true_labels, predicted_labels):
-            if true_label != "O" and predicted_label == true_label:
-                counts["tp"] += 1
-            if predicted_label != "O" and predicted_label != true_label:
-                counts["fp"] += 1
-            if true_label == "O" and predicted_label == "O":
-                counts["tn"] += 1
-            if true_label != "O" and predicted_label == "O":
-                counts["fn"] += 1
-
-    # calculate precision, recall and f1 score
-    return {
-        "precision": calculate_precision(counts["tp"], counts["fp"]),
-        "recall": calculate_recall(counts["tp"], counts["fn"]),
-        "f1": calculate_f1(counts["tp"], counts["fp"], counts["fn"]),
-    }
+"""
+chaine.optimization.metrics
+~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+This module implements metrics to evaluate the performance of a trained model.
+"""
+
+from collections import Counter
+
+
+def calculate_precision(true_positives: int, false_positives: int) -> float:
+    """Calculate precision score.
+
+    Parameters
+    ----------
+    true_positives : int
+        Number of true positives.
+    false_positives : int
+        Number of false positives.
+
+    Returns
+    -------
+    float
+        Precision score.
+    """
+    try:
+        return true_positives / (true_positives + false_positives)
+    except ZeroDivisionError:
+        # only false negatives is perfect precision
+        return 1.0
+
+
+def calculate_recall(true_positives: int, false_negatives: int) -> float:
+    """Calculate recall score.
+
+    Parameters
+    ----------
+    true_positives : int
+        Number of true positives.
+    false_negatives : int
+        Number of false negatives.
+
+    Returns
+    -------
+    float
+        Recall score.
+    """
+    try:
+        return true_positives / (true_positives + false_negatives)
+    except ZeroDivisionError:
+        # only false positives is imperfect recall
+        return 0.0
+
+
+def calculate_f1(true_positives: int, false_positives: int, false_negatives: int) -> float:
+    """Calculate F1 score.
+
+    Parameters
+    ----------
+    true_positives : int
+        Number of true positives.
+    false_negatives : int
+        Number of false negatives.
+
+    Returns
+    -------
+    float
+        Precision score
+    """
+    precision = calculate_precision(true_positives, false_positives)
+    recall = calculate_recall(true_positives, false_negatives)
+    try:
+        return (2 * precision * recall) / (precision + recall)
+    except ZeroDivisionError:
+        # zero precision and zero recall is zero f1
+        return 0.0
+
+
+def evaluate_predictions(true: list[list[str]], pred: list[list[str]]) -> dict[str, float]:
+    """Evaluate the given predictions with the true labels.
+
+    Parameters
+    ----------
+    true : list[list[str]]
+        True labels.
+    pred : list[list[str]]
+        Predicted labels.
+
+    Returns
+    -------
+    dict[str, float]
+        Precision, recall and F1 scores.
+    """
+    # validate input
+    if (
+        not isinstance(true, list)
+        or not isinstance(pred, list)
+        or not isinstance(true[0], list)
+        or not isinstance(pred[0], list)
+    ):
+        raise ValueError("Input lists are invalid")
+
+    counts = Counter()
+
+    # get true positives, true negatives, false positives, false negatives
+    for true_labels, predicted_labels in zip(true, pred):
+        # ignore prefixes
+        true_labels = [l.removeprefix("B-").removeprefix("I-") for l in true_labels]
+        predicted_labels = [l.removeprefix("B-").removeprefix("I-") for l in predicted_labels]
+
+        if len(true_labels) != len(predicted_labels):
+            raise ValueError(f"Different lengths: '{true_labels}' vs. '{predicted_labels}'")
+
+        for true_label, predicted_label in zip(true_labels, predicted_labels):
+            if true_label != "O" and predicted_label == true_label:
+                counts["tp"] += 1
+            if predicted_label != "O" and predicted_label != true_label:
+                counts["fp"] += 1
+            if true_label == "O" and predicted_label == "O":
+                counts["tn"] += 1
+            if true_label != "O" and predicted_label == "O":
+                counts["fn"] += 1
+
+    # calculate precision, recall and f1 score
+    return {
+        "precision": calculate_precision(counts["tp"], counts["fp"]),
+        "recall": calculate_recall(counts["tp"], counts["fn"]),
+        "f1": calculate_f1(counts["tp"], counts["fp"], counts["fn"]),
+    }
```

## chaine/optimization/spaces.py

 * *Ordering differences only*

```diff
@@ -1,394 +1,394 @@
-"""
-chaine.optimization.spaces
-~~~~~~~~~~~~~~~~~~~~~~~~~~
-
-This module implements hyperparameter search spaces for the different training methods.
-"""
-
-import random
-from abc import ABC, abstractmethod
-
-from chaine.optimization.utils import NumberSeries
-
-
-class SearchSpace(ABC):
-    @property
-    @abstractmethod
-    def algorithm(self) -> str:
-        ...
-
-    @abstractmethod
-    def random_hyperparameters(self) -> dict[str, int | float | bool | str]:
-        ...
-
-
-class LBFGSSearchSpace(SearchSpace):
-    def __init__(
-        self,
-        min_freq: NumberSeries = NumberSeries(start=0, stop=5, step=1),
-        num_memories: NumberSeries = NumberSeries(start=1, stop=10, step=1),
-        c1: NumberSeries = NumberSeries(start=0.0, stop=2.0, step=0.01),
-        c2: NumberSeries = NumberSeries(start=0.0, stop=2.0, step=0.01),
-        epsilon: NumberSeries = NumberSeries(start=0.00001, stop=0.001, step=0.00001),
-        period: NumberSeries = NumberSeries(start=1, stop=20, step=1),
-        delta: NumberSeries = NumberSeries(start=0.00001, stop=0.001, step=0.00001),
-        max_linesearch: NumberSeries = NumberSeries(start=0, stop=50, step=1),
-        linesearch: set[str] = {"MoreThuente", "Backtracking", "StrongBacktracking"},
-        all_possible_states: set[bool] = {True, False},
-        all_possible_transitions: set[bool] = {True, False},
-    ):
-        """Hyperparameter search space for Limited-Memory BFGS.
-
-        Parameters
-        ----------
-        min_freq : NumberSeries, optional
-            Threshold value for minimum frequency of a feature occurring in training data,
-            by default NumberSeries(start=0, stop=5, step=1).
-        num_memories : NumberSeries, optional
-            Number of limited memories for approximating the inverse hessian matrix,
-            by default NumberSeries(start=1, stop=10, step=1)
-        c1 : NumberSeries, optional
-            Coefficient for L1 regularization,
-            by default NumberSeries(start=0.0, stop=2.0, step=0.01).
-        c2 : NumberSeries, optional
-            Coefficient for L2 regularization,
-            by default NumberSeries(start=0.0, stop=2.0, step=0.01).
-        epsilon : NumberSeries, optional
-            Parameter that determines the condition of convergence,
-            by default NumberSeries(start=0.00001, stop=0.001, step=0.00001).
-        period : NumberSeries, optional
-            Threshold value for iterations to test the stopping criterion,
-            by default NumberSeries(start=1, stop=20, step=1).
-        delta : NumberSeries, optional
-            Top iteration when log likelihood is not greater than this,
-            by default NumberSeries(start=0.00001, stop=0.001, step=0.00001).
-        max_linesearch : NumberSeries, optional
-            Maximum number of trials for the line search algorithm,
-            by default NumberSeries(start=0, stop=50, step=1).
-        linesearch : set[str], optional
-            Line search algorithm used in updates,
-            by default {"MoreThuente", "Backtracking", "StrongBacktracking"}.
-        all_possible_states : set[bool], optional
-            Generate state features that do not even occur in the training data,
-            by default {True, False}.
-        all_possible_transitions : set[bool], optional
-            Generate transition features that do not even occur in the training data,
-            by default {True, False}.
-        """
-        self.min_freq = min_freq
-        self.all_possible_states = all_possible_states
-        self.all_possible_transitions = all_possible_transitions
-        self.num_memories = num_memories
-        self.c1 = c1
-        self.c2 = c2
-        self.epsilon = epsilon
-        self.period = period
-        self.delta = delta
-        self.linesearch = linesearch
-        self.max_linesearch = max_linesearch
-
-    @property
-    def algorithm(self) -> str:
-        return "lbfgs"
-
-    def random_hyperparameters(self) -> dict[str, int | float | bool | str]:
-        """Select random hyperparameters from the search space.
-
-        Returns
-        -------
-        dict[str, int | float | bool | str]
-            Randomly selected hyperparameters.
-        """
-        return {
-            "algorithm": self.algorithm,
-            "min_freq": random.choice(list(self.min_freq)),
-            "all_possible_states": random.choice(list(self.all_possible_states)),
-            "all_possible_transitions": random.choice(list(self.all_possible_transitions)),
-            "num_memories": random.choice(list(self.num_memories)),
-            "c1": random.choice(list(self.c1)),
-            "c2": random.choice(list(self.c2)),
-            "epsilon": random.choice(list(self.epsilon)),
-            "period": random.choice(list(self.period)),
-            "delta": random.choice(list(self.delta)),
-            "linesearch": random.choice(list(self.linesearch)),
-            "max_linesearch": random.choice(list(self.max_linesearch)),
-        }
-
-
-class L2SGDSearchSpace(SearchSpace):
-    def __init__(
-        self,
-        min_freq: NumberSeries = NumberSeries(start=0, stop=5, step=1),
-        all_possible_states: set[bool] = {True, False},
-        all_possible_transitions: set[bool] = {True, False},
-        c2: NumberSeries = NumberSeries(start=0.0, stop=2.0, step=0.01),
-        period: NumberSeries = NumberSeries(start=1, stop=20, step=1),
-        delta: NumberSeries = NumberSeries(start=0.00001, stop=0.001, step=0.00001),
-        calibration_eta: NumberSeries = NumberSeries(start=0.00001, stop=0.001, step=0.00001),
-        calibration_rate: NumberSeries = NumberSeries(start=0.5, stop=5.0, step=0.1),
-        calibration_samples: NumberSeries = NumberSeries(start=100, stop=3000, step=10),
-        calibration_candidates: NumberSeries = NumberSeries(start=1, stop=30, step=1),
-        calibration_max_trials: NumberSeries = NumberSeries(start=1, stop=30, step=1),
-    ):
-        """Hyperparameter search space for SGD with L2 parameters.
-
-        Parameters
-        ----------
-        min_freq : NumberSeries, optional
-            Threshold value for minimum frequency of a feature occurring in training data,
-            by default NumberSeries(start=0, stop=5, step=1).
-        all_possible_states : set[bool], optional
-            Generate state features that do not even occur in the training data,
-            by default {True, False}.
-        all_possible_transitions : set[bool], optional
-            Generate transition features that do not even occur in the training data,
-            by default {True, False}.
-        c2 : NumberSeries, optional
-            Coefficient for L2 regularization,
-            by default NumberSeries(start=0.0, stop=2.0, step=0.01).
-        period : NumberSeries, optional
-            Threshold value for iterations to test the stopping criterion,
-            by default NumberSeries(start=1, stop=20, step=1).
-        delta : NumberSeries, optional
-            Top iteration when log likelihood is not greater than this,
-            by default NumberSeries(start=0.00001, stop=0.001, step=0.00001).
-        calibration_eta : NumberSeries, optional
-            Initial value of learning rate (eta) used for calibration,
-            by default NumberSeries(start=0.00001, stop=0.001, step=0.00001).
-        calibration_rate : NumberSeries, optional
-            Rate of increase/decrease of learning rate for calibration,
-            by default NumberSeries(start=0.5, stop=5.0, step=0.1).
-        calibration_samples : NumberSeries, optional
-            Number of instances used for calibration,
-            by default NumberSeries(start=100, stop=3000, step=10).
-        calibration_candidates : NumberSeries, optional
-            Number of candidates of learning rate,
-            by default NumberSeries(start=1, stop=30, step=1).
-        calibration_max_trials : NumberSeries, optional
-            Maximum number of trials of learning rates for calibration,
-            by default NumberSeries(start=1, stop=30, step=1).
-        """
-        self.min_freq = min_freq
-        self.all_possible_states = all_possible_states
-        self.all_possible_transitions = all_possible_transitions
-        self.c2 = c2
-        self.period = period
-        self.delta = delta
-        self.calibration_eta = calibration_eta
-        self.calibration_rate = calibration_rate
-        self.calibration_samples = calibration_samples
-        self.calibration_candidates = calibration_candidates
-        self.calibration_max_trials = calibration_max_trials
-
-    @property
-    def algorithm(self) -> str:
-        return "l2sgd"
-
-    def random_hyperparameters(self) -> dict[str, int | float | bool | str]:
-        """Select random hyperparameters from the search space.
-
-        Returns
-        -------
-        dict[str, int | float | bool | str]
-            Randomly selected hyperparameters.
-        """
-        return {
-            "algorithm": self.algorithm,
-            "min_freq": random.choice(list(self.min_freq)),
-            "all_possible_states": random.choice(list(self.all_possible_states)),
-            "all_possible_transitions": random.choice(list(self.all_possible_transitions)),
-            "c2": random.choice(list(self.c2)),
-            "period": random.choice(list(self.period)),
-            "delta": random.choice(list(self.delta)),
-            "calibration_eta": random.choice(list(self.calibration_eta)),
-            "calibration_rate": random.choice(list(self.calibration_rate)),
-            "calibration_samples": random.choice(list(self.calibration_samples)),
-            "calibration_candidates": random.choice(list(self.calibration_candidates)),
-            "calibration_max_trials": random.choice(list(self.calibration_max_trials)),
-        }
-
-
-class APSearchSpace(SearchSpace):
-    def __init__(
-        self,
-        min_freq: NumberSeries = NumberSeries(start=0, stop=5, step=1),
-        all_possible_states: set[bool] = {True, False},
-        all_possible_transitions: set[bool] = {True, False},
-        epsilon: NumberSeries = NumberSeries(start=0.00001, stop=0.001, step=0.00001),
-    ):
-        """Hyperparameter search space for Averaged Perceptron.
-
-        Parameters
-        ----------
-        min_freq : NumberSeries, optional
-            Threshold value for minimum frequency of a feature occurring in training data,
-            by default NumberSeries(start=0, stop=5, step=1).
-        all_possible_states : set[bool], optional
-            Generate state features that do not even occur in the training data,
-            by default {True, False}.
-        all_possible_transitions : set[bool], optional
-            Generate transition features that do not even occur in the training data,
-            by default {True, False}.
-        epsilon : NumberSeries, optional
-            Parameter that determines the condition of convergence,
-            by default NumberSeries(start=0.00001, stop=0.001, step=0.00001).
-        """
-        self.min_freq = min_freq
-        self.all_possible_states = all_possible_states
-        self.all_possible_transitions = all_possible_transitions
-        self.epsilon = epsilon
-
-    @property
-    def algorithm(self) -> str:
-        return "ap"
-
-    def random_hyperparameters(self) -> dict[str, int | float | bool | str]:
-        """Select random hyperparameters from the search space.
-
-        Returns
-        -------
-        dict[str, int | float | bool | str]
-            Randomly selected hyperparameters.
-        """
-        return {
-            "algorithm": self.algorithm,
-            "min_freq": random.choice(list(self.min_freq)),
-            "all_possible_states": random.choice(list(self.all_possible_states)),
-            "all_possible_transitions": random.choice(list(self.all_possible_transitions)),
-            "epsilon": random.choice(list(self.epsilon)),
-        }
-
-
-class PASearchSpace(SearchSpace):
-    def __init__(
-        self,
-        min_freq: NumberSeries = NumberSeries(start=0, stop=5, step=1),
-        all_possible_states: set[bool] = {True, False},
-        all_possible_transitions: set[bool] = {True, False},
-        epsilon: NumberSeries = NumberSeries(start=0.00001, stop=0.001, step=0.00001),
-        pa_type: NumberSeries = {0, 1, 2},
-        c: NumberSeries = NumberSeries(start=0.0, stop=2.0, step=0.01),
-        error_sensitive: set[bool] = {True, False},
-        averaging: set[bool] = {True, False},
-    ):
-        """Hyperparameter search space for Passive Aggressive.
-
-        Parameters
-        ----------
-        min_freq : NumberSeries, optional
-            Threshold value for minimum frequency of a feature occurring in training data,
-            by default NumberSeries(start=0, stop=5, step=1).
-        all_possible_states : set[bool], optional
-            Generate state features that do not even occur in the training data,
-            by default {True, False}.
-        all_possible_transitions : set[bool], optional
-            Generate transition features that do not even occur in the training data,
-            by default {True, False}.
-        epsilon : NumberSeries, optional
-            Parameter that determines the condition of convergence,
-            by default NumberSeries(start=0.00001, stop=0.001, step=0.00001).
-        pa_type : NumberSeries, optional
-            Strategy for updating feature weights, by default {0, 1, 2}.
-        c : NumberSeries, optional
-            Aggressiveness parameter, by default NumberSeries(start=0.0, stop=2.0, step=0.01).
-        error_sensitive : set[bool], optional
-            Include square root of predicted incorrect labels into optimization routine,
-            by default {True, False}.
-        averaging : set[bool], optional
-            Compute average of feature weights at all updates, by default {True, False}.
-        """
-        self.min_freq = min_freq
-        self.all_possible_states = all_possible_states
-        self.all_possible_transitions = all_possible_transitions
-        self.epsilon = epsilon
-        self.pa_type = pa_type
-        self.c = c
-        self.error_sensitive = error_sensitive
-        self.averaging = averaging
-
-    @property
-    def algorithm(self) -> str:
-        return "pa"
-
-    def random_hyperparameters(self) -> dict[str, int | float | bool | str]:
-        """Select random hyperparameters from the search space.
-
-        Returns
-        -------
-        dict[str, int | float | bool | str]
-            Randomly selected hyperparameters.
-        """
-        return {
-            "algorithm": self.algorithm,
-            "min_freq": random.choice(list(self.min_freq)),
-            "all_possible_states": random.choice(list(self.all_possible_states)),
-            "all_possible_transitions": random.choice(list(self.all_possible_transitions)),
-            "epsilon": random.choice(list(self.epsilon)),
-            "pa_type": random.choice(list(self.pa_type)),
-            "c": random.choice(list(self.c)),
-            "error_sensitive": random.choice(list(self.error_sensitive)),
-            "averaging": random.choice(list(self.averaging)),
-        }
-
-
-class AROWSearchSpace(SearchSpace):
-    def __init__(
-        self,
-        min_freq: NumberSeries = NumberSeries(start=0, stop=5, step=1),
-        all_possible_states: set[bool] = {True, False},
-        all_possible_transitions: set[bool] = {True, False},
-        epsilon: NumberSeries = NumberSeries(start=0.00001, stop=0.001, step=0.00001),
-        variance: NumberSeries = NumberSeries(start=0.00001, stop=0.001, step=0.00001),
-        gamma: NumberSeries = NumberSeries(start=0.00001, stop=0.001, step=0.00001),
-    ):
-        """Hyperparameter search space for AROW.
-
-        Parameters
-        ----------
-        min_freq : NumberSeries, optional
-            Threshold value for minimum frequency of a feature occurring in training data,
-            by default NumberSeries(start=0, stop=5, step=1).
-        all_possible_states : set[bool], optional
-            Generate state features that do not even occur in the training data,
-            by default {True, False}.
-        all_possible_transitions : set[bool], optional
-            Generate transition features that do not even occur in the training data,
-            by default {True, False}.
-        epsilon : NumberSeries, optional
-            Parameter that determines the condition of convergence,
-            by default NumberSeries(start=0.00001, stop=0.001, step=0.00001).
-        variance : NumberSeries, optional
-            Initial variance of every feature weight,
-            by default NumberSeries(start=0.00001, stop=0.001, step=0.00001).
-        gamma : NumberSeries, optional
-            Trade-off between loss function and changes of feature weights,
-            by default NumberSeries(start=0.00001, stop=0.001, step=0.00001).
-        """
-        self.min_freq = min_freq
-        self.all_possible_states = all_possible_states
-        self.all_possible_transitions = all_possible_transitions
-        self.epsilon = epsilon
-        self.variance = variance
-        self.gamma = gamma
-
-    @property
-    def algorithm(self) -> str:
-        return "arow"
-
-    def random_hyperparameters(self) -> dict[str, int | float | bool | str]:
-        """Select random hyperparameters from the search space.
-
-        Returns
-        -------
-        dict[str, int | float | bool | str]
-            Randomly selected hyperparameters.
-        """
-        return {
-            "algorithm": self.algorithm,
-            "min_freq": random.choice(list(self.min_freq)),
-            "all_possible_states": random.choice(list(self.all_possible_states)),
-            "all_possible_transitions": random.choice(list(self.all_possible_transitions)),
-            "epsilon": random.choice(list(self.epsilon)),
-            "variance": random.choice(list(self.variance)),
-            "gamma": random.choice(list(self.gamma)),
-        }
+"""
+chaine.optimization.spaces
+~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+This module implements hyperparameter search spaces for the different training methods.
+"""
+
+import random
+from abc import ABC, abstractmethod
+
+from chaine.optimization.utils import NumberSeries
+
+
+class SearchSpace(ABC):
+    @property
+    @abstractmethod
+    def algorithm(self) -> str:
+        ...
+
+    @abstractmethod
+    def random_hyperparameters(self) -> dict[str, int | float | bool | str]:
+        ...
+
+
+class LBFGSSearchSpace(SearchSpace):
+    def __init__(
+        self,
+        min_freq: NumberSeries = NumberSeries(start=0, stop=5, step=1),
+        num_memories: NumberSeries = NumberSeries(start=1, stop=10, step=1),
+        c1: NumberSeries = NumberSeries(start=0.0, stop=2.0, step=0.01),
+        c2: NumberSeries = NumberSeries(start=0.0, stop=2.0, step=0.01),
+        epsilon: NumberSeries = NumberSeries(start=0.00001, stop=0.001, step=0.00001),
+        period: NumberSeries = NumberSeries(start=1, stop=20, step=1),
+        delta: NumberSeries = NumberSeries(start=0.00001, stop=0.001, step=0.00001),
+        max_linesearch: NumberSeries = NumberSeries(start=0, stop=50, step=1),
+        linesearch: set[str] = {"MoreThuente", "Backtracking", "StrongBacktracking"},
+        all_possible_states: set[bool] = {True, False},
+        all_possible_transitions: set[bool] = {True, False},
+    ):
+        """Hyperparameter search space for Limited-Memory BFGS.
+
+        Parameters
+        ----------
+        min_freq : NumberSeries, optional
+            Threshold value for minimum frequency of a feature occurring in training data,
+            by default NumberSeries(start=0, stop=5, step=1).
+        num_memories : NumberSeries, optional
+            Number of limited memories for approximating the inverse hessian matrix,
+            by default NumberSeries(start=1, stop=10, step=1)
+        c1 : NumberSeries, optional
+            Coefficient for L1 regularization,
+            by default NumberSeries(start=0.0, stop=2.0, step=0.01).
+        c2 : NumberSeries, optional
+            Coefficient for L2 regularization,
+            by default NumberSeries(start=0.0, stop=2.0, step=0.01).
+        epsilon : NumberSeries, optional
+            Parameter that determines the condition of convergence,
+            by default NumberSeries(start=0.00001, stop=0.001, step=0.00001).
+        period : NumberSeries, optional
+            Threshold value for iterations to test the stopping criterion,
+            by default NumberSeries(start=1, stop=20, step=1).
+        delta : NumberSeries, optional
+            Top iteration when log likelihood is not greater than this,
+            by default NumberSeries(start=0.00001, stop=0.001, step=0.00001).
+        max_linesearch : NumberSeries, optional
+            Maximum number of trials for the line search algorithm,
+            by default NumberSeries(start=0, stop=50, step=1).
+        linesearch : set[str], optional
+            Line search algorithm used in updates,
+            by default {"MoreThuente", "Backtracking", "StrongBacktracking"}.
+        all_possible_states : set[bool], optional
+            Generate state features that do not even occur in the training data,
+            by default {True, False}.
+        all_possible_transitions : set[bool], optional
+            Generate transition features that do not even occur in the training data,
+            by default {True, False}.
+        """
+        self.min_freq = min_freq
+        self.all_possible_states = all_possible_states
+        self.all_possible_transitions = all_possible_transitions
+        self.num_memories = num_memories
+        self.c1 = c1
+        self.c2 = c2
+        self.epsilon = epsilon
+        self.period = period
+        self.delta = delta
+        self.linesearch = linesearch
+        self.max_linesearch = max_linesearch
+
+    @property
+    def algorithm(self) -> str:
+        return "lbfgs"
+
+    def random_hyperparameters(self) -> dict[str, int | float | bool | str]:
+        """Select random hyperparameters from the search space.
+
+        Returns
+        -------
+        dict[str, int | float | bool | str]
+            Randomly selected hyperparameters.
+        """
+        return {
+            "algorithm": self.algorithm,
+            "min_freq": random.choice(list(self.min_freq)),
+            "all_possible_states": random.choice(list(self.all_possible_states)),
+            "all_possible_transitions": random.choice(list(self.all_possible_transitions)),
+            "num_memories": random.choice(list(self.num_memories)),
+            "c1": random.choice(list(self.c1)),
+            "c2": random.choice(list(self.c2)),
+            "epsilon": random.choice(list(self.epsilon)),
+            "period": random.choice(list(self.period)),
+            "delta": random.choice(list(self.delta)),
+            "linesearch": random.choice(list(self.linesearch)),
+            "max_linesearch": random.choice(list(self.max_linesearch)),
+        }
+
+
+class L2SGDSearchSpace(SearchSpace):
+    def __init__(
+        self,
+        min_freq: NumberSeries = NumberSeries(start=0, stop=5, step=1),
+        all_possible_states: set[bool] = {True, False},
+        all_possible_transitions: set[bool] = {True, False},
+        c2: NumberSeries = NumberSeries(start=0.0, stop=2.0, step=0.01),
+        period: NumberSeries = NumberSeries(start=1, stop=20, step=1),
+        delta: NumberSeries = NumberSeries(start=0.00001, stop=0.001, step=0.00001),
+        calibration_eta: NumberSeries = NumberSeries(start=0.00001, stop=0.001, step=0.00001),
+        calibration_rate: NumberSeries = NumberSeries(start=0.5, stop=5.0, step=0.1),
+        calibration_samples: NumberSeries = NumberSeries(start=100, stop=3000, step=10),
+        calibration_candidates: NumberSeries = NumberSeries(start=1, stop=30, step=1),
+        calibration_max_trials: NumberSeries = NumberSeries(start=1, stop=30, step=1),
+    ):
+        """Hyperparameter search space for SGD with L2 parameters.
+
+        Parameters
+        ----------
+        min_freq : NumberSeries, optional
+            Threshold value for minimum frequency of a feature occurring in training data,
+            by default NumberSeries(start=0, stop=5, step=1).
+        all_possible_states : set[bool], optional
+            Generate state features that do not even occur in the training data,
+            by default {True, False}.
+        all_possible_transitions : set[bool], optional
+            Generate transition features that do not even occur in the training data,
+            by default {True, False}.
+        c2 : NumberSeries, optional
+            Coefficient for L2 regularization,
+            by default NumberSeries(start=0.0, stop=2.0, step=0.01).
+        period : NumberSeries, optional
+            Threshold value for iterations to test the stopping criterion,
+            by default NumberSeries(start=1, stop=20, step=1).
+        delta : NumberSeries, optional
+            Top iteration when log likelihood is not greater than this,
+            by default NumberSeries(start=0.00001, stop=0.001, step=0.00001).
+        calibration_eta : NumberSeries, optional
+            Initial value of learning rate (eta) used for calibration,
+            by default NumberSeries(start=0.00001, stop=0.001, step=0.00001).
+        calibration_rate : NumberSeries, optional
+            Rate of increase/decrease of learning rate for calibration,
+            by default NumberSeries(start=0.5, stop=5.0, step=0.1).
+        calibration_samples : NumberSeries, optional
+            Number of instances used for calibration,
+            by default NumberSeries(start=100, stop=3000, step=10).
+        calibration_candidates : NumberSeries, optional
+            Number of candidates of learning rate,
+            by default NumberSeries(start=1, stop=30, step=1).
+        calibration_max_trials : NumberSeries, optional
+            Maximum number of trials of learning rates for calibration,
+            by default NumberSeries(start=1, stop=30, step=1).
+        """
+        self.min_freq = min_freq
+        self.all_possible_states = all_possible_states
+        self.all_possible_transitions = all_possible_transitions
+        self.c2 = c2
+        self.period = period
+        self.delta = delta
+        self.calibration_eta = calibration_eta
+        self.calibration_rate = calibration_rate
+        self.calibration_samples = calibration_samples
+        self.calibration_candidates = calibration_candidates
+        self.calibration_max_trials = calibration_max_trials
+
+    @property
+    def algorithm(self) -> str:
+        return "l2sgd"
+
+    def random_hyperparameters(self) -> dict[str, int | float | bool | str]:
+        """Select random hyperparameters from the search space.
+
+        Returns
+        -------
+        dict[str, int | float | bool | str]
+            Randomly selected hyperparameters.
+        """
+        return {
+            "algorithm": self.algorithm,
+            "min_freq": random.choice(list(self.min_freq)),
+            "all_possible_states": random.choice(list(self.all_possible_states)),
+            "all_possible_transitions": random.choice(list(self.all_possible_transitions)),
+            "c2": random.choice(list(self.c2)),
+            "period": random.choice(list(self.period)),
+            "delta": random.choice(list(self.delta)),
+            "calibration_eta": random.choice(list(self.calibration_eta)),
+            "calibration_rate": random.choice(list(self.calibration_rate)),
+            "calibration_samples": random.choice(list(self.calibration_samples)),
+            "calibration_candidates": random.choice(list(self.calibration_candidates)),
+            "calibration_max_trials": random.choice(list(self.calibration_max_trials)),
+        }
+
+
+class APSearchSpace(SearchSpace):
+    def __init__(
+        self,
+        min_freq: NumberSeries = NumberSeries(start=0, stop=5, step=1),
+        all_possible_states: set[bool] = {True, False},
+        all_possible_transitions: set[bool] = {True, False},
+        epsilon: NumberSeries = NumberSeries(start=0.00001, stop=0.001, step=0.00001),
+    ):
+        """Hyperparameter search space for Averaged Perceptron.
+
+        Parameters
+        ----------
+        min_freq : NumberSeries, optional
+            Threshold value for minimum frequency of a feature occurring in training data,
+            by default NumberSeries(start=0, stop=5, step=1).
+        all_possible_states : set[bool], optional
+            Generate state features that do not even occur in the training data,
+            by default {True, False}.
+        all_possible_transitions : set[bool], optional
+            Generate transition features that do not even occur in the training data,
+            by default {True, False}.
+        epsilon : NumberSeries, optional
+            Parameter that determines the condition of convergence,
+            by default NumberSeries(start=0.00001, stop=0.001, step=0.00001).
+        """
+        self.min_freq = min_freq
+        self.all_possible_states = all_possible_states
+        self.all_possible_transitions = all_possible_transitions
+        self.epsilon = epsilon
+
+    @property
+    def algorithm(self) -> str:
+        return "ap"
+
+    def random_hyperparameters(self) -> dict[str, int | float | bool | str]:
+        """Select random hyperparameters from the search space.
+
+        Returns
+        -------
+        dict[str, int | float | bool | str]
+            Randomly selected hyperparameters.
+        """
+        return {
+            "algorithm": self.algorithm,
+            "min_freq": random.choice(list(self.min_freq)),
+            "all_possible_states": random.choice(list(self.all_possible_states)),
+            "all_possible_transitions": random.choice(list(self.all_possible_transitions)),
+            "epsilon": random.choice(list(self.epsilon)),
+        }
+
+
+class PASearchSpace(SearchSpace):
+    def __init__(
+        self,
+        min_freq: NumberSeries = NumberSeries(start=0, stop=5, step=1),
+        all_possible_states: set[bool] = {True, False},
+        all_possible_transitions: set[bool] = {True, False},
+        epsilon: NumberSeries = NumberSeries(start=0.00001, stop=0.001, step=0.00001),
+        pa_type: NumberSeries = {0, 1, 2},
+        c: NumberSeries = NumberSeries(start=0.0, stop=2.0, step=0.01),
+        error_sensitive: set[bool] = {True, False},
+        averaging: set[bool] = {True, False},
+    ):
+        """Hyperparameter search space for Passive Aggressive.
+
+        Parameters
+        ----------
+        min_freq : NumberSeries, optional
+            Threshold value for minimum frequency of a feature occurring in training data,
+            by default NumberSeries(start=0, stop=5, step=1).
+        all_possible_states : set[bool], optional
+            Generate state features that do not even occur in the training data,
+            by default {True, False}.
+        all_possible_transitions : set[bool], optional
+            Generate transition features that do not even occur in the training data,
+            by default {True, False}.
+        epsilon : NumberSeries, optional
+            Parameter that determines the condition of convergence,
+            by default NumberSeries(start=0.00001, stop=0.001, step=0.00001).
+        pa_type : NumberSeries, optional
+            Strategy for updating feature weights, by default {0, 1, 2}.
+        c : NumberSeries, optional
+            Aggressiveness parameter, by default NumberSeries(start=0.0, stop=2.0, step=0.01).
+        error_sensitive : set[bool], optional
+            Include square root of predicted incorrect labels into optimization routine,
+            by default {True, False}.
+        averaging : set[bool], optional
+            Compute average of feature weights at all updates, by default {True, False}.
+        """
+        self.min_freq = min_freq
+        self.all_possible_states = all_possible_states
+        self.all_possible_transitions = all_possible_transitions
+        self.epsilon = epsilon
+        self.pa_type = pa_type
+        self.c = c
+        self.error_sensitive = error_sensitive
+        self.averaging = averaging
+
+    @property
+    def algorithm(self) -> str:
+        return "pa"
+
+    def random_hyperparameters(self) -> dict[str, int | float | bool | str]:
+        """Select random hyperparameters from the search space.
+
+        Returns
+        -------
+        dict[str, int | float | bool | str]
+            Randomly selected hyperparameters.
+        """
+        return {
+            "algorithm": self.algorithm,
+            "min_freq": random.choice(list(self.min_freq)),
+            "all_possible_states": random.choice(list(self.all_possible_states)),
+            "all_possible_transitions": random.choice(list(self.all_possible_transitions)),
+            "epsilon": random.choice(list(self.epsilon)),
+            "pa_type": random.choice(list(self.pa_type)),
+            "c": random.choice(list(self.c)),
+            "error_sensitive": random.choice(list(self.error_sensitive)),
+            "averaging": random.choice(list(self.averaging)),
+        }
+
+
+class AROWSearchSpace(SearchSpace):
+    def __init__(
+        self,
+        min_freq: NumberSeries = NumberSeries(start=0, stop=5, step=1),
+        all_possible_states: set[bool] = {True, False},
+        all_possible_transitions: set[bool] = {True, False},
+        epsilon: NumberSeries = NumberSeries(start=0.00001, stop=0.001, step=0.00001),
+        variance: NumberSeries = NumberSeries(start=0.00001, stop=0.001, step=0.00001),
+        gamma: NumberSeries = NumberSeries(start=0.00001, stop=0.001, step=0.00001),
+    ):
+        """Hyperparameter search space for AROW.
+
+        Parameters
+        ----------
+        min_freq : NumberSeries, optional
+            Threshold value for minimum frequency of a feature occurring in training data,
+            by default NumberSeries(start=0, stop=5, step=1).
+        all_possible_states : set[bool], optional
+            Generate state features that do not even occur in the training data,
+            by default {True, False}.
+        all_possible_transitions : set[bool], optional
+            Generate transition features that do not even occur in the training data,
+            by default {True, False}.
+        epsilon : NumberSeries, optional
+            Parameter that determines the condition of convergence,
+            by default NumberSeries(start=0.00001, stop=0.001, step=0.00001).
+        variance : NumberSeries, optional
+            Initial variance of every feature weight,
+            by default NumberSeries(start=0.00001, stop=0.001, step=0.00001).
+        gamma : NumberSeries, optional
+            Trade-off between loss function and changes of feature weights,
+            by default NumberSeries(start=0.00001, stop=0.001, step=0.00001).
+        """
+        self.min_freq = min_freq
+        self.all_possible_states = all_possible_states
+        self.all_possible_transitions = all_possible_transitions
+        self.epsilon = epsilon
+        self.variance = variance
+        self.gamma = gamma
+
+    @property
+    def algorithm(self) -> str:
+        return "arow"
+
+    def random_hyperparameters(self) -> dict[str, int | float | bool | str]:
+        """Select random hyperparameters from the search space.
+
+        Returns
+        -------
+        dict[str, int | float | bool | str]
+            Randomly selected hyperparameters.
+        """
+        return {
+            "algorithm": self.algorithm,
+            "min_freq": random.choice(list(self.min_freq)),
+            "all_possible_states": random.choice(list(self.all_possible_states)),
+            "all_possible_transitions": random.choice(list(self.all_possible_transitions)),
+            "epsilon": random.choice(list(self.epsilon)),
+            "variance": random.choice(list(self.variance)),
+            "gamma": random.choice(list(self.gamma)),
+        }
```

## chaine/optimization/trial.py

 * *Ordering differences only*

```diff
@@ -1,103 +1,103 @@
-"""
-chaine.optimization.trial
-~~~~~~~~~~~~~~~~~~~~~~~~~
-
-This module implements a class for a hyperparameter optimization trial.
-"""
-
-import statistics
-import tempfile
-import time
-import uuid
-from pathlib import Path
-
-from chaine.optimization.metrics import evaluate_predictions
-from chaine.optimization.spaces import SearchSpace
-from chaine.typing import Iterable, Iterator, Labels, Sequence
-
-
-class OptimizationTrial:
-    def __init__(
-        self,
-        splits: Iterator[tuple[tuple[Iterable[Sequence], Iterable[Labels]]]],
-        space: SearchSpace,
-        *,
-        is_baseline: bool
-    ):
-        """Hyperparameter optimization trial.
-
-        Parameters
-        ----------
-        splits : Iterator[tuple[tuple[Iterable[Sequence], Iterable[Labels]]]]
-            K-fold split data set.
-        space : SearchSpace
-            Search space for hyperparameter optimization.
-        is_baseline : bool
-            True if trial is a baseline (i.e. default hyperparameters to be used).
-        """
-        self.splits = splits
-        self.space = space
-        self.is_baseline = is_baseline
-        self.model_filepath = Path(tempfile.gettempdir(), str(uuid.uuid4()))
-        self.precision = []
-        self.recall = []
-        self.f1 = []
-        self.time = []
-
-    def __enter__(self) -> dict[str, dict]:
-        """Train and evaluate a model.
-
-        Returns
-        -------
-        dict[str, dict]
-            Selected hyperparameters and evaluation scores.
-        """
-        from chaine.crf import Model, Trainer
-
-        if self.is_baseline:
-            # default hyperparameters as baseline
-            params = {"algorithm": self.space.algorithm}
-        else:
-            # select random hyperparameters
-            params = self.space.random_hyperparameters()
-
-        for (train_dataset, train_labels), (test_dataset, test_labels) in self.splits:
-            # fire!
-            start = time.time()
-            trainer = Trainer(max_iterations=100, **params)
-            trainer.train(train_dataset, train_labels, model_filepath=self.model_filepath)
-            end = time.time()
-
-            # evaluate model
-            model = Model(self.model_filepath)
-            predicted_labels = model.predict(test_dataset)
-            scores = evaluate_predictions(test_labels, predicted_labels)
-
-            # save scores
-            self.precision.append(scores["precision"])
-            self.recall.append(scores["recall"])
-            self.f1.append(scores["f1"])
-            self.time.append(end - start)
-
-        # return both hyperparameters and evaluation metrics
-        return {
-            "hyperparameters": params,
-            "stats": {
-                "mean_precision": statistics.mean(self.precision) if self.precision else None,
-                "stdev_precision": statistics.stdev(self.precision) if self.precision else None,
-                "mean_recall": statistics.mean(self.recall) if self.recall else None,
-                "stdev_recall": statistics.stdev(self.recall) if self.recall else None,
-                "mean_f1": statistics.mean(self.f1) if self.f1 else None,
-                "stdev_f1": statistics.stdev(self.f1) if self.f1 else None,
-                "mean_time": statistics.mean(self.time) if self.time else None,
-                "stdev_time": statistics.stdev(self.time) if self.time else None,
-            },
-        }
-
-    def __exit__(self, *args) -> bool:
-        # clean up
-        if self.model_filepath.exists():
-            self.model_filepath.unlink()
-
-        # ignore exceptions
-        return True
+"""
+chaine.optimization.trial
+~~~~~~~~~~~~~~~~~~~~~~~~~
+
+This module implements a class for a hyperparameter optimization trial.
+"""
+
+import statistics
+import tempfile
+import time
+import uuid
+from pathlib import Path
+
+from chaine.optimization.metrics import evaluate_predictions
+from chaine.optimization.spaces import SearchSpace
+from chaine.typing import Iterable, Iterator, Labels, Sequence
+
+
+class OptimizationTrial:
+    def __init__(
+        self,
+        splits: Iterator[tuple[tuple[Iterable[Sequence], Iterable[Labels]]]],
+        space: SearchSpace,
+        *,
+        is_baseline: bool
+    ):
+        """Hyperparameter optimization trial.
+
+        Parameters
+        ----------
+        splits : Iterator[tuple[tuple[Iterable[Sequence], Iterable[Labels]]]]
+            K-fold split data set.
+        space : SearchSpace
+            Search space for hyperparameter optimization.
+        is_baseline : bool
+            True if trial is a baseline (i.e. default hyperparameters to be used).
+        """
+        self.splits = splits
+        self.space = space
+        self.is_baseline = is_baseline
+        self.model_filepath = Path(tempfile.gettempdir(), str(uuid.uuid4()))
+        self.precision = []
+        self.recall = []
+        self.f1 = []
+        self.time = []
+
+    def __enter__(self) -> dict[str, dict]:
+        """Train and evaluate a model.
+
+        Returns
+        -------
+        dict[str, dict]
+            Selected hyperparameters and evaluation scores.
+        """
+        from chaine.crf import Model, Trainer
+
+        if self.is_baseline:
+            # default hyperparameters as baseline
+            params = {"algorithm": self.space.algorithm}
+        else:
+            # select random hyperparameters
+            params = self.space.random_hyperparameters()
+
+        for (train_dataset, train_labels), (test_dataset, test_labels) in self.splits:
+            # fire!
+            start = time.time()
+            trainer = Trainer(max_iterations=100, **params)
+            trainer.train(train_dataset, train_labels, model_filepath=self.model_filepath)
+            end = time.time()
+
+            # evaluate model
+            model = Model(self.model_filepath)
+            predicted_labels = model.predict(test_dataset)
+            scores = evaluate_predictions(test_labels, predicted_labels)
+
+            # save scores
+            self.precision.append(scores["precision"])
+            self.recall.append(scores["recall"])
+            self.f1.append(scores["f1"])
+            self.time.append(end - start)
+
+        # return both hyperparameters and evaluation metrics
+        return {
+            "hyperparameters": params,
+            "stats": {
+                "mean_precision": statistics.mean(self.precision) if self.precision else None,
+                "stdev_precision": statistics.stdev(self.precision) if self.precision else None,
+                "mean_recall": statistics.mean(self.recall) if self.recall else None,
+                "stdev_recall": statistics.stdev(self.recall) if self.recall else None,
+                "mean_f1": statistics.mean(self.f1) if self.f1 else None,
+                "stdev_f1": statistics.stdev(self.f1) if self.f1 else None,
+                "mean_time": statistics.mean(self.time) if self.time else None,
+                "stdev_time": statistics.stdev(self.time) if self.time else None,
+            },
+        }
+
+    def __exit__(self, *args) -> bool:
+        # clean up
+        if self.model_filepath.exists():
+            self.model_filepath.unlink()
+
+        # ignore exceptions
+        return True
```

## chaine/optimization/utils.py

 * *Ordering differences only*

```diff
@@ -1,119 +1,119 @@
-"""
-chaine.optimization.utils
-~~~~~~~~~~~~~~~~~~~~~~~~~
-
-This module implements utility functions for hyperparameter optimization.
-"""
-
-import random
-from collections.abc import Iterable, Iterator
-from dataclasses import dataclass
-
-from chaine.typing import Labels, Sequence
-
-
-@dataclass
-class NumberSeries(Iterable):
-    start: int
-    stop: int
-    step: int | float
-
-    def __repr__(self) -> str:
-        return f"<NumberSeries (start={self.start}, stop={self.stop}, step={self.step})>"
-
-    def __iter__(self) -> Iterator[int | float]:
-        n = int(round((self.stop - self.start) / float(self.step)))
-        if n > 1:
-            yield from [self.start + self.step * i for i in range(n + 1)]
-        elif n == 1:
-            yield self.start
-
-
-def cross_validation(
-    dataset: Iterable[Sequence], labels: Iterable[Labels], k: int, seed: int | None = None
-) -> Iterator[tuple[tuple[Iterable[Sequence], Iterable[Labels]]]]:
-    """K-fold cross validation.
-
-    Parameters
-    ----------
-    dataset : Iterable[Sequence]
-        Data set to split into k folds.
-    labels : Iterable[Labels]
-        Labels to split into k folds.
-    k : int
-        Number of folds.
-    shuffle : bool, optional
-        True if data set should be shuffled first, by default True.
-
-    Yields
-    -------
-    Iterator[tuple[tuple[Iterable[Sequence], Iterable[Labels]]]]
-        Train and test set.
-    """
-    # get indices of the examples
-    indices = list(range(len(dataset)))
-
-    # shuffle examples
-    random.seed(seed)
-    random.shuffle(indices)
-
-    # split into k folds
-    folds = [indices[i::k] for i in range(k)]
-
-    # yield every fold split
-    for i in range(k):
-        # get train and test split
-        test = folds[i]
-        train = [s for x in [fold for fold in folds if fold != test] for s in x]
-
-        # yield train and test split
-        yield (
-            [d for i, d in enumerate(dataset) if i in train],
-            [l for i, l in enumerate(labels) if i in train],
-        ), (
-            [d for i, d in enumerate(dataset) if i in test],
-            [l for i, l in enumerate(labels) if i in test],
-        )
-
-
-def downsample(
-    dataset: Iterable[Sequence], labels: Iterable[Labels], n: int, seed: int | None = None
-) -> tuple[Iterable[Sequence], Iterable[Labels]]:
-    """Downsample the given data set to the specified size.
-
-    Parameters
-    ----------
-    dataset : Iterable[Sequence]
-        Data set to downsample.
-    labels : Iterable[Labels]
-        Labels for the data set.
-    n : int
-        Number of samples to keep.
-    seed : int | None, optional
-        Random seed, by default None.
-
-    Returns
-    -------
-    tuple[Iterable[Sequence], Iterable[Labels]]
-        Downsampled data set and labels.
-
-    Raises
-    ------
-    ValueError
-        If number of instances in the data set is smaller than specified size.
-    """
-    if len(dataset) < n:
-        raise ValueError("Data set is too small")
-
-    # get indices of the data set
-    indices = list(range(len(dataset)))
-
-    # sample indices
-    random.seed(seed)
-    sample = set(random.sample(indices, n))
-
-    # keep only instances of the sample
-    dataset = [s for i, s in enumerate(dataset) if i in sample]
-    labels = [l for i, l in enumerate(labels) if i in sample]
-
-    return dataset, labels
+"""
+chaine.optimization.utils
+~~~~~~~~~~~~~~~~~~~~~~~~~
+
+This module implements utility functions for hyperparameter optimization.
+"""
+
+import random
+from collections.abc import Iterable, Iterator
+from dataclasses import dataclass
+
+from chaine.typing import Labels, Sequence
+
+
+@dataclass
+class NumberSeries(Iterable):
+    start: int
+    stop: int
+    step: int | float
+
+    def __repr__(self) -> str:
+        return f"<NumberSeries (start={self.start}, stop={self.stop}, step={self.step})>"
+
+    def __iter__(self) -> Iterator[int | float]:
+        n = int(round((self.stop - self.start) / float(self.step)))
+        if n > 1:
+            yield from [self.start + self.step * i for i in range(n + 1)]
+        elif n == 1:
+            yield self.start
+
+
+def cross_validation(
+    dataset: Iterable[Sequence], labels: Iterable[Labels], k: int, seed: int | None = None
+) -> Iterator[tuple[tuple[Iterable[Sequence], Iterable[Labels]]]]:
+    """K-fold cross validation.
+
+    Parameters
+    ----------
+    dataset : Iterable[Sequence]
+        Data set to split into k folds.
+    labels : Iterable[Labels]
+        Labels to split into k folds.
+    k : int
+        Number of folds.
+    shuffle : bool, optional
+        True if data set should be shuffled first, by default True.
+
+    Yields
+    -------
+    Iterator[tuple[tuple[Iterable[Sequence], Iterable[Labels]]]]
+        Train and test set.
+    """
+    # get indices of the examples
+    indices = list(range(len(dataset)))
+
+    # shuffle examples
+    random.seed(seed)
+    random.shuffle(indices)
+
+    # split into k folds
+    folds = [indices[i::k] for i in range(k)]
+
+    # yield every fold split
+    for i in range(k):
+        # get train and test split
+        test = folds[i]
+        train = [s for x in [fold for fold in folds if fold != test] for s in x]
+
+        # yield train and test split
+        yield (
+            [d for i, d in enumerate(dataset) if i in train],
+            [l for i, l in enumerate(labels) if i in train],
+        ), (
+            [d for i, d in enumerate(dataset) if i in test],
+            [l for i, l in enumerate(labels) if i in test],
+        )
+
+
+def downsample(
+    dataset: Iterable[Sequence], labels: Iterable[Labels], n: int, seed: int | None = None
+) -> tuple[Iterable[Sequence], Iterable[Labels]]:
+    """Downsample the given data set to the specified size.
+
+    Parameters
+    ----------
+    dataset : Iterable[Sequence]
+        Data set to downsample.
+    labels : Iterable[Labels]
+        Labels for the data set.
+    n : int
+        Number of samples to keep.
+    seed : int | None, optional
+        Random seed, by default None.
+
+    Returns
+    -------
+    tuple[Iterable[Sequence], Iterable[Labels]]
+        Downsampled data set and labels.
+
+    Raises
+    ------
+    ValueError
+        If number of instances in the data set is smaller than specified size.
+    """
+    if len(dataset) < n:
+        raise ValueError("Data set is too small")
+
+    # get indices of the data set
+    indices = list(range(len(dataset)))
+
+    # sample indices
+    random.seed(seed)
+    sample = set(random.sample(indices, n))
+
+    # keep only instances of the sample
+    dataset = [s for i, s in enumerate(dataset) if i in sample]
+    labels = [l for i, l in enumerate(labels) if i in sample]
+
+    return dataset, labels
```

## chaine/training.py

 * *Ordering differences only*

```diff
@@ -1,184 +1,184 @@
-"""
-chaine.training
-~~~~~~~~~~~~~~~
-
-This module implements the high-level API to train a conditional random field.
-"""
-
-
-from chaine.crf import HyperparameterOptimizer, Model, Trainer
-from chaine.logging import Logger, set_verbosity
-from chaine.typing import Filepath, Iterable, Labels, Sequence
-
-LOGGER = Logger(__name__)
-
-
-def train(
-    dataset: Iterable[Sequence],
-    labels: Iterable[Labels],
-    *,
-    model_filepath: Filepath = "model.chaine",
-    optimize_hyperparameters: bool = False,
-    optimization_sample_size: int | None = None,
-    verbose: int = 1,
-    **hyperparameters,
-) -> Model:
-    """Train a conditional random field.
-
-    Parameters
-    ----------
-    dataset : Iterable[Sequence]
-        Data set consisting of sequences of feature sets.
-    labels : Iterable[Labels]
-        Labels corresponding to each instance in the data set.
-    model_filepath : Filepath, optional (default=model.chaine)
-        Path to model location.
-    optimize_hyperparameters : bool
-        If True, optimize hyperparameters first.
-    optimization_sample_size : int | None
-        Number of instances to sample from the data set for hyperparameter optimization.
-    verbose : int
-        Controls the verbosity: the higher, the more messages.
-    algorithm : str
-        The following optimization algorithms are available:
-            * lbfgs: Limited-memory BFGS with L1/L2 regularization
-            * l2sgd: Stochastic gradient descent with L2 regularization
-            * ap: Averaged perceptron
-            * pa: Passive aggressive
-            * arow: Adaptive regularization of weights
-
-    Limited-memory BFGS Parameters (lbfgs)
-    --------------------------------------
-    min_freq : float, optional (default=0)
-        Threshold value for minimum frequency of a feature occurring in training data.
-    all_possible_states : bool, optional (default=False)
-        Generate state features that do not even occur in the training data.
-    all_possible_transitions : bool, optional (default=False)
-        Generate transition features that do not even occur in the training data.
-    max_iterations : int, optional (default=None)
-        Maximum number of iterations (unlimited by default).
-    num_memories : int, optional (default=6)
-        Number of limited memories for approximating the inverse hessian matrix.
-    c1 : float, optional (default=0)
-        Coefficient for L1 regularization.
-    c2 : float, optional (default=1.0)
-        Coefficient for L2 regularization.
-    epsilon : float, optional (default=1e-5)
-        Parameter that determines the condition of convergence.
-    period : int, optional (default=10)
-        Threshold value for iterations to test the stopping criterion.
-    delta : float, optional (default=1e-5)
-        Top iteration when log likelihood is not greater than this.
-    linesearch : str, optional (default="MoreThuente")
-        Line search algorithm used in updates:
-            * MoreThuente: More and Thuente's method
-            * Backtracking: Backtracking method with regular Wolfe condition
-            * StrongBacktracking: Backtracking method with strong Wolfe condition
-    max_linesearch : int, optional (default=20)
-        Maximum number of trials for the line search algorithm.
-
-    SGD with L2 Parameters (l2sgd)
-    ------------------------------
-    min_freq : float, optional (default=0)
-        Threshold value for minimum frequency of a feature occurring in training data.
-    all_possible_states : bool, optional (default=False)
-        Generate state features that do not even occur in the training data.
-    all_possible_transitions : bool, optional (default=False)
-        Generate transition features that do not even occur in the training data.
-    max_iterations : int, optional (default=None)
-        Maximum number of iterations (1000 by default).
-    c2 : float, optional (default=1.0)
-        Coefficient for L2 regularization.
-    period : int, optional (default=10)
-        Threshold value for iterations to test the stopping criterion.
-    delta : float, optional (default=1e-5)
-        Top iteration when log likelihood is not greater than this.
-    calibration_eta : float, optional (default=0.1)
-        Initial value of learning rate (eta) used for calibration.
-    calibration_rate : float, optional (default=2.0)
-        Rate of increase/decrease of learning rate for calibration.
-    calibration_samples : int, optional (default=1000)
-        Number of instances used for calibration.
-    calibration_candidates : int, optional (default=10)
-        Number of candidates of learning rate.
-    calibration_max_trials : int, optional (default=20)
-        Maximum number of trials of learning rates for calibration.
-
-    Averaged Perceptron Parameters (ap)
-    -----------------------------------
-    min_freq : float, optional (default=0)
-        Threshold value for minimum frequency of a feature occurring in training data.
-    all_possible_states : bool, optional (default=False)
-        Generate state features that do not even occur in the training data.
-    all_possible_transitions : bool, optional (default=False)
-        Generate transition features that do not even occur in the training data.
-    max_iterations : int, optional (default=None)
-        Maximum number of iterations (100 by default).
-    epsilon : float, optional (default=1e-5)
-        Parameter that determines the condition of convergence.
-
-    Passive Aggressive Parameters (pa)
-    ----------------------------------
-    min_freq : float, optional (default=0)
-        Threshold value for minimum frequency of a feature occurring in training data.
-    all_possible_states : bool, optional (default=False)
-        Generate state features that do not even occur in the training data.
-    all_possible_transitions : bool, optional (default=False)
-        Generate transition features that do not even occur in the training data.
-    max_iterations : int, optional (default=None)
-        Maximum number of iterations (100 by default).
-    epsilon : float, optional (default=1e-5)
-        Parameter that determines the condition of convergence.
-    pa_type : int, optional (default=1)
-        Strategy for updating feature weights:
-            * 0: PA without slack variables
-            * 1: PA type I
-            * 2: PA type II
-    c : float, optional (default=1)
-        Aggressiveness parameter (used only for PA-I and PA-II).
-    error_sensitive : bool, optional (default=True)
-        Include square root of predicted incorrect labels into optimization routine.
-    averaging : bool, optional (default=True)
-        Compute average of feature weights at all updates.
-
-    Adaptive Regularization of Weights Parameters (arow)
-    ----------------------------------------------------
-    min_freq : float, optional (default=0)
-        Threshold value for minimum frequency of a feature occurring in training data.
-    all_possible_states : bool, optional (default=False)
-        Generate state features that do not even occur in the training data.
-    all_possible_transitions : bool, optional (default=False)
-        Generate transition features that do not even occur in the training data.
-    max_iterations : int, optional (default=None)
-        Maximum number of iterations (100 by default).
-    epsilon : float, optional (default=1e-5)
-        Parameter that determines the condition of convergence.
-    variance : float, optional (default=1)
-        Initial variance of every feature weight.
-    gamma : float, optional (default=1)
-        Trade-off between loss function and changes of feature weights.
-
-    Returns
-    -------
-    Model
-        A conditional random field trained on the dataset.
-    """
-    set_verbosity(verbose)
-
-    if optimize_hyperparameters:
-        if hyperparameters:
-            LOGGER.warning(f"Specified hyperparameters will be overwritten: {hyperparameters}")
-
-        # optionally tune hyperparameters first
-        optimizer = HyperparameterOptimizer()
-        results = optimizer.optimize_hyperparameters(dataset, labels, optimization_sample_size)
-
-        # use hyperparameters of the best run
-        hyperparameters = results[0]["hyperparameters"]
-
-    # initialize trainer and start training
-    trainer = Trainer(**hyperparameters)
-    trainer.train(dataset, labels, model_filepath=str(model_filepath))
-
-    # load and return the trained model
-    return Model(model_filepath)
+"""
+chaine.training
+~~~~~~~~~~~~~~~
+
+This module implements the high-level API to train a conditional random field.
+"""
+
+
+from chaine.crf import HyperparameterOptimizer, Model, Trainer
+from chaine.logging import Logger, set_verbosity
+from chaine.typing import Filepath, Iterable, Labels, Sequence
+
+LOGGER = Logger(__name__)
+
+
+def train(
+    dataset: Iterable[Sequence],
+    labels: Iterable[Labels],
+    *,
+    model_filepath: Filepath = "model.chaine",
+    optimize_hyperparameters: bool = False,
+    optimization_sample_size: int | None = None,
+    verbose: int = 1,
+    **hyperparameters,
+) -> Model:
+    """Train a conditional random field.
+
+    Parameters
+    ----------
+    dataset : Iterable[Sequence]
+        Data set consisting of sequences of feature sets.
+    labels : Iterable[Labels]
+        Labels corresponding to each instance in the data set.
+    model_filepath : Filepath, optional (default=model.chaine)
+        Path to model location.
+    optimize_hyperparameters : bool
+        If True, optimize hyperparameters first.
+    optimization_sample_size : int | None
+        Number of instances to sample from the data set for hyperparameter optimization.
+    verbose : int
+        Controls the verbosity: the higher, the more messages.
+    algorithm : str
+        The following optimization algorithms are available:
+            * lbfgs: Limited-memory BFGS with L1/L2 regularization
+            * l2sgd: Stochastic gradient descent with L2 regularization
+            * ap: Averaged perceptron
+            * pa: Passive aggressive
+            * arow: Adaptive regularization of weights
+
+    Limited-memory BFGS Parameters (lbfgs)
+    --------------------------------------
+    min_freq : float, optional (default=0)
+        Threshold value for minimum frequency of a feature occurring in training data.
+    all_possible_states : bool, optional (default=False)
+        Generate state features that do not even occur in the training data.
+    all_possible_transitions : bool, optional (default=False)
+        Generate transition features that do not even occur in the training data.
+    max_iterations : int, optional (default=None)
+        Maximum number of iterations (unlimited by default).
+    num_memories : int, optional (default=6)
+        Number of limited memories for approximating the inverse hessian matrix.
+    c1 : float, optional (default=0)
+        Coefficient for L1 regularization.
+    c2 : float, optional (default=1.0)
+        Coefficient for L2 regularization.
+    epsilon : float, optional (default=1e-5)
+        Parameter that determines the condition of convergence.
+    period : int, optional (default=10)
+        Threshold value for iterations to test the stopping criterion.
+    delta : float, optional (default=1e-5)
+        Top iteration when log likelihood is not greater than this.
+    linesearch : str, optional (default="MoreThuente")
+        Line search algorithm used in updates:
+            * MoreThuente: More and Thuente's method
+            * Backtracking: Backtracking method with regular Wolfe condition
+            * StrongBacktracking: Backtracking method with strong Wolfe condition
+    max_linesearch : int, optional (default=20)
+        Maximum number of trials for the line search algorithm.
+
+    SGD with L2 Parameters (l2sgd)
+    ------------------------------
+    min_freq : float, optional (default=0)
+        Threshold value for minimum frequency of a feature occurring in training data.
+    all_possible_states : bool, optional (default=False)
+        Generate state features that do not even occur in the training data.
+    all_possible_transitions : bool, optional (default=False)
+        Generate transition features that do not even occur in the training data.
+    max_iterations : int, optional (default=None)
+        Maximum number of iterations (1000 by default).
+    c2 : float, optional (default=1.0)
+        Coefficient for L2 regularization.
+    period : int, optional (default=10)
+        Threshold value for iterations to test the stopping criterion.
+    delta : float, optional (default=1e-5)
+        Top iteration when log likelihood is not greater than this.
+    calibration_eta : float, optional (default=0.1)
+        Initial value of learning rate (eta) used for calibration.
+    calibration_rate : float, optional (default=2.0)
+        Rate of increase/decrease of learning rate for calibration.
+    calibration_samples : int, optional (default=1000)
+        Number of instances used for calibration.
+    calibration_candidates : int, optional (default=10)
+        Number of candidates of learning rate.
+    calibration_max_trials : int, optional (default=20)
+        Maximum number of trials of learning rates for calibration.
+
+    Averaged Perceptron Parameters (ap)
+    -----------------------------------
+    min_freq : float, optional (default=0)
+        Threshold value for minimum frequency of a feature occurring in training data.
+    all_possible_states : bool, optional (default=False)
+        Generate state features that do not even occur in the training data.
+    all_possible_transitions : bool, optional (default=False)
+        Generate transition features that do not even occur in the training data.
+    max_iterations : int, optional (default=None)
+        Maximum number of iterations (100 by default).
+    epsilon : float, optional (default=1e-5)
+        Parameter that determines the condition of convergence.
+
+    Passive Aggressive Parameters (pa)
+    ----------------------------------
+    min_freq : float, optional (default=0)
+        Threshold value for minimum frequency of a feature occurring in training data.
+    all_possible_states : bool, optional (default=False)
+        Generate state features that do not even occur in the training data.
+    all_possible_transitions : bool, optional (default=False)
+        Generate transition features that do not even occur in the training data.
+    max_iterations : int, optional (default=None)
+        Maximum number of iterations (100 by default).
+    epsilon : float, optional (default=1e-5)
+        Parameter that determines the condition of convergence.
+    pa_type : int, optional (default=1)
+        Strategy for updating feature weights:
+            * 0: PA without slack variables
+            * 1: PA type I
+            * 2: PA type II
+    c : float, optional (default=1)
+        Aggressiveness parameter (used only for PA-I and PA-II).
+    error_sensitive : bool, optional (default=True)
+        Include square root of predicted incorrect labels into optimization routine.
+    averaging : bool, optional (default=True)
+        Compute average of feature weights at all updates.
+
+    Adaptive Regularization of Weights Parameters (arow)
+    ----------------------------------------------------
+    min_freq : float, optional (default=0)
+        Threshold value for minimum frequency of a feature occurring in training data.
+    all_possible_states : bool, optional (default=False)
+        Generate state features that do not even occur in the training data.
+    all_possible_transitions : bool, optional (default=False)
+        Generate transition features that do not even occur in the training data.
+    max_iterations : int, optional (default=None)
+        Maximum number of iterations (100 by default).
+    epsilon : float, optional (default=1e-5)
+        Parameter that determines the condition of convergence.
+    variance : float, optional (default=1)
+        Initial variance of every feature weight.
+    gamma : float, optional (default=1)
+        Trade-off between loss function and changes of feature weights.
+
+    Returns
+    -------
+    Model
+        A conditional random field trained on the dataset.
+    """
+    set_verbosity(verbose)
+
+    if optimize_hyperparameters:
+        if hyperparameters:
+            LOGGER.warning(f"Specified hyperparameters will be overwritten: {hyperparameters}")
+
+        # optionally tune hyperparameters first
+        optimizer = HyperparameterOptimizer()
+        results = optimizer.optimize_hyperparameters(dataset, labels, optimization_sample_size)
+
+        # use hyperparameters of the best run
+        hyperparameters = results[0]["hyperparameters"]
+
+    # initialize trainer and start training
+    trainer = Trainer(**hyperparameters)
+    trainer.train(dataset, labels, model_filepath=str(model_filepath))
+
+    # load and return the trained model
+    return Model(model_filepath)
```

## chaine/typing.py

 * *Ordering differences only*

```diff
@@ -1,18 +1,18 @@
-"""
-chaine.typing
-~~~~~~~~~~~~~
-
-A collection of type hints.
-"""
-
-from os import PathLike
-from pathlib import Path
-from typing import Any, Iterable, Iterator
-
-Sequence = Iterable[dict[str, str | int | float | bool]]
-Labels = Iterable[str]
-Filepath = Path | PathLike | str
-Sentence = list[str]
-Tags = list[str]
-Features = dict[str, float | int | str | bool]
-Dataset = dict[str, dict[str, Any]]
+"""
+chaine.typing
+~~~~~~~~~~~~~
+
+A collection of type hints.
+"""
+
+from os import PathLike
+from pathlib import Path
+from typing import Any, Iterable, Iterator
+
+Sequence = Iterable[dict[str, str | int | float | bool]]
+Labels = Iterable[str]
+Filepath = Path | PathLike | str
+Sentence = list[str]
+Tags = list[str]
+Features = dict[str, float | int | str | bool]
+Dataset = dict[str, dict[str, Any]]
```

## chaine/validation.py

 * *Ordering differences only*

```diff
@@ -1,43 +1,43 @@
-"""
-chaine.validation
-~~~~~~~~~~~~~~~~~
-
-This module implements functions to validate input sequences (either for training or inference).
-"""
-
-from chaine.typing import Sequence
-
-# supported feature value data types
-TYPES = (str, int, float, bool)
-
-
-def is_valid_sequence(sequence: Sequence) -> bool:
-    """Check if the given sequence has valid input format.
-
-    Parameters
-    ----------
-    sequence : Sequence
-        Sequence to validate.
-
-    Returns
-    -------
-    bool
-        True if sequence is valid, False otherwise.
-    """
-    return isinstance(sequence, list) and all(is_valid_token(token) for token in sequence)
-
-
-def is_valid_token(token: dict) -> bool:
-    """Check if the given token has valid input format.
-
-    Parameters
-    ----------
-    token : dict
-        Token to validate.
-
-    Returns
-    -------
-    bool
-        True if sequence is valid, False otherwise.
-    """
-    return isinstance(token, dict) and all(isinstance(value, TYPES) for value in token.values())
+"""
+chaine.validation
+~~~~~~~~~~~~~~~~~
+
+This module implements functions to validate input sequences (either for training or inference).
+"""
+
+from chaine.typing import Sequence
+
+# supported feature value data types
+TYPES = (str, int, float, bool)
+
+
+def is_valid_sequence(sequence: Sequence) -> bool:
+    """Check if the given sequence has valid input format.
+
+    Parameters
+    ----------
+    sequence : Sequence
+        Sequence to validate.
+
+    Returns
+    -------
+    bool
+        True if sequence is valid, False otherwise.
+    """
+    return isinstance(sequence, list) and all(is_valid_token(token) for token in sequence)
+
+
+def is_valid_token(token: dict) -> bool:
+    """Check if the given token has valid input format.
+
+    Parameters
+    ----------
+    token : dict
+        Token to validate.
+
+    Returns
+    -------
+    bool
+        True if sequence is valid, False otherwise.
+    """
+    return isinstance(token, dict) and all(isinstance(value, TYPES) for value in token.values())
```

## Comparing `chaine-2.1.0.dist-info/METADATA` & `chaine-3.11.0.dist-info/METADATA`

 * *Files 0% similar despite different names*

```diff
@@ -1,14 +1,14 @@
 Metadata-Version: 2.1
 Name: chaine
-Version: 2.1.0
+Version: 3.11.0
 Summary: Linear-chain conditional random fields for natural language processing
 Author: Severin Simmler
 Author-email: s.simmler@snapaddy.com
-Requires-Python: >=3.11,<4.0
+Requires-Python: ==3.11.*
 Classifier: Programming Language :: Python :: 3
 Classifier: Programming Language :: Python :: 3.11
 Description-Content-Type: text/markdown
 
 # Chaine
 
 [![downloads](https://static.pepy.tech/personalized-badge/chaine?period=total&units=international_system&left_color=black&right_color=black&left_text=downloads)](https://pepy.tech/project/chaine)
```

