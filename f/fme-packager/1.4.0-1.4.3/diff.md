# Comparing `tmp/fme_packager-1.4.0-py3-none-any.whl.zip` & `tmp/fme_packager-1.4.3-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,20 +1,20 @@
-Zip file size: 21312 bytes, number of entries: 18
--rw-rw-rw-  2.0 fat       23 b- defN 23-May-02 17:25 fme_packager/__init__.py
+Zip file size: 21620 bytes, number of entries: 18
+-rw-rw-rw-  2.0 fat       23 b- defN 23-May-12 21:44 fme_packager/__init__.py
 -rw-rw-rw-  2.0 fat       90 b- defN 22-Nov-29 23:42 fme_packager/__main__.py
 -rw-rw-rw-  2.0 fat     4445 b- defN 23-May-02 17:25 fme_packager/cli.py
 -rw-rw-rw-  2.0 fat      647 b- defN 22-Nov-29 23:42 fme_packager/exception.py
 -rw-rw-rw-  2.0 fat      543 b- defN 22-Nov-29 23:42 fme_packager/fme_env.py
--rw-rw-rw-  2.0 fat     9196 b- defN 23-Feb-10 01:59 fme_packager/help.py
+-rw-rw-rw-  2.0 fat     9683 b- defN 23-May-12 21:44 fme_packager/help.py
 -rw-rw-rw-  2.0 fat     3356 b- defN 22-Nov-29 23:42 fme_packager/metadata.py
 -rw-rw-rw-  2.0 fat     2457 b- defN 23-Jan-31 23:37 fme_packager/operations.py
--rw-rw-rw-  2.0 fat    21780 b- defN 23-May-02 17:25 fme_packager/packager.py
+-rw-rw-rw-  2.0 fat    22830 b- defN 23-May-12 21:44 fme_packager/packager.py
 -rw-rw-rw-  2.0 fat     4692 b- defN 23-Jan-12 22:04 fme_packager/spec.json
 -rw-rw-rw-  2.0 fat     6158 b- defN 23-Jan-12 22:04 fme_packager/transformer.py
--rw-rw-rw-  2.0 fat     2270 b- defN 23-May-02 17:25 fme_packager/verifier.py
--rw-rw-rw-  2.0 fat     1307 b- defN 23-May-02 17:25 fme_packager-1.4.0.dist-info/LICENSE
--rw-rw-rw-  2.0 fat     3649 b- defN 23-May-02 17:25 fme_packager-1.4.0.dist-info/METADATA
--rw-rw-rw-  2.0 fat       92 b- defN 23-May-02 17:25 fme_packager-1.4.0.dist-info/WHEEL
--rw-rw-rw-  2.0 fat       54 b- defN 23-May-02 17:25 fme_packager-1.4.0.dist-info/entry_points.txt
--rw-rw-rw-  2.0 fat       13 b- defN 23-May-02 17:25 fme_packager-1.4.0.dist-info/top_level.txt
--rw-rw-r--  2.0 fat     1472 b- defN 23-May-02 17:25 fme_packager-1.4.0.dist-info/RECORD
-18 files, 62244 bytes uncompressed, 18900 bytes compressed:  69.6%
+-rw-rw-rw-  2.0 fat     1796 b- defN 23-May-12 21:44 fme_packager/verifier.py
+-rw-rw-rw-  2.0 fat     1307 b- defN 23-May-12 21:50 fme_packager-1.4.3.dist-info/LICENSE
+-rw-rw-rw-  2.0 fat     3748 b- defN 23-May-12 21:50 fme_packager-1.4.3.dist-info/METADATA
+-rw-rw-rw-  2.0 fat       92 b- defN 23-May-12 21:50 fme_packager-1.4.3.dist-info/WHEEL
+-rw-rw-rw-  2.0 fat       54 b- defN 23-May-12 21:49 fme_packager-1.4.3.dist-info/entry_points.txt
+-rw-rw-rw-  2.0 fat       13 b- defN 23-May-12 21:49 fme_packager-1.4.3.dist-info/top_level.txt
+-rw-rw-r--  2.0 fat     1472 b- defN 23-May-12 21:50 fme_packager-1.4.3.dist-info/RECORD
+18 files, 63406 bytes uncompressed, 19208 bytes compressed:  69.7%
```

## zipnote {}

```diff
@@ -30,26 +30,26 @@
 
 Filename: fme_packager/transformer.py
 Comment: 
 
 Filename: fme_packager/verifier.py
 Comment: 
 
-Filename: fme_packager-1.4.0.dist-info/LICENSE
+Filename: fme_packager-1.4.3.dist-info/LICENSE
 Comment: 
 
-Filename: fme_packager-1.4.0.dist-info/METADATA
+Filename: fme_packager-1.4.3.dist-info/METADATA
 Comment: 
 
-Filename: fme_packager-1.4.0.dist-info/WHEEL
+Filename: fme_packager-1.4.3.dist-info/WHEEL
 Comment: 
 
-Filename: fme_packager-1.4.0.dist-info/entry_points.txt
+Filename: fme_packager-1.4.3.dist-info/entry_points.txt
 Comment: 
 
-Filename: fme_packager-1.4.0.dist-info/top_level.txt
+Filename: fme_packager-1.4.3.dist-info/top_level.txt
 Comment: 
 
-Filename: fme_packager-1.4.0.dist-info/RECORD
+Filename: fme_packager-1.4.3.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## fme_packager/__init__.py

```diff
@@ -1 +1 @@
-__version__ = "1.4.0"
+__version__ = "1.4.3"
```

## fme_packager/help.py

```diff
@@ -1,229 +1,237 @@
-"""
-Logic for preparing help documentation for the FPKG packing process.
-
-- package_help.csv validation
-- File copy logic for the help folder
-- Markdown to HTML conversion and package_help.csv generation
-"""
-import csv
-import re
-import shutil
-import warnings
-from pathlib import Path
-
-from markdown import Markdown
-
-from fme_packager.metadata import FMEPackageMetadata
-from fme_packager.operations import TREE_COPY_IGNORE_GLOBS
-
-
-HTML_TPL = """<!DOCTYPE html>
-<html>
-<head>
-<title>{title}</title>
-<link rel="stylesheet" href="{css_path}" />
-</head>
-<body>
-{body}
-</body>
-</html>
-"""
-
-
-def add_transformer_classes_to_doc(html):
-    """
-    Given a string that is HTML doc, modify the first h1 and p tags
-    to mark the relevant contents to show for the FME Workbench Quick Add pane.
-    See FMEENGINE-75813.
-
-    Assumes that:
-    - these tags don't already have a class attribute
-    - the HTML was generated by python-markdown without extensions that modify tags
-    """
-    # Must be exact match: Workbench finds these tags through text search, not DOM.
-    html, _ = re.subn(r"<h1>", '<h1 class="fmx">', html, count=1)
-    html, _ = re.subn(r"<p>", '<p><span class="TransformerSummary">', html, count=1)
-    html, _ = re.subn(r"</p>", "</span></p>", html, count=1)
-    return html
-
-
-class DocCopier:
-    """
-    Callable with the same signature as shutil.copy2(), for use with shutil.copytree().
-    Copies files while converting MD files to HTML at the destination.
-    Identical to shutil.copy2() when conversion is disabled.
-    """
-
-    def __init__(self, root_path):
-        """
-        :param root_path: All files copied must be descendants of this root.
-            Used to determine hardcoded relative paths in generated HTML.
-        """
-        self.root_path = root_path
-        self.convert_md = True
-        self.converted_files = {}
-        self._md_converter = Markdown(
-            extensions=[
-                "tables",
-                "fenced_code",
-            ],
-        )
-        # DEVOPS-3078: Path to CSS relative to the doc root folder
-        self._css_path_rel_doc = "../../css/style.css"
-
-        # When generating HTML, transformer doc gets special treatment.
-        self.transformer_names = set()
-
-    def md_to_html(self, src_file: Path):
-        # Not using python-markdown extensions API because this is a one-off task.
-        body = self._md_converter.reset().convert(src_file.read_text("utf8"))
-        if src_file.stem in self.transformer_names:
-            body = add_transformer_classes_to_doc(body)
-        # Count number of subfolders down from the root,
-        # so the CSS relative path gets updated correctly.
-        subfolder_count = len(src_file.relative_to(self.root_path).parts) - 1
-        return HTML_TPL.format(
-            title=src_file.stem,
-            body=body,
-            css_path="../" * subfolder_count + self._css_path_rel_doc,
-        )
-
-    def __call__(self, src, dst, *args, **kwargs):
-        # Has same signature as shutil.copy(), for use with shutil.copytree().
-        src = Path(src)
-        if not self.convert_md or src.suffix.lower() != ".md":
-            return shutil.copy2(src, dst, *args, **kwargs)
-        dst = Path(dst)
-        dst_filename = src.stem + ".htm"
-        if dst.is_dir():
-            dst = dst / dst_filename
-        else:
-            dst = dst.with_name(dst_filename)
-        htm = self.md_to_html(src)
-        with dst.open("w", encoding="utf8") as f:
-            f.write(htm)
-        self.converted_files[src] = dst
-        return dst
-
-
-def get_expected_help_index(fpkg_metadata: FMEPackageMetadata, format_directions=None):
-    """
-    Returns a mapping of the expected help contexts
-    to the name of its corresponding HTML doc file,
-    based on the formats and transformers in the given package metadata.
-
-    Help contexts are keys used by FME Workbench to map help buttons in the UI
-    to its corresponding page of documentation.
-    The names of the expected HTML files follow a naming convention based on the help context.
-    """
-    # /foundation/ui/core/include/ui/core/helpkeywords.h
-    index = {}
-    if not format_directions:
-        format_directions = {}
-    fpkg_ident = f"{fpkg_metadata.publisher_uid}_{fpkg_metadata.uid}"
-    # Each transformer has only one topic.
-    for xformer in fpkg_metadata.transformers:
-        index[f"fmx_{fpkg_ident}_{xformer.name}"] = f"/{xformer.name}.htm"
-    # Each format has many topics.
-    for fmt in fpkg_metadata.formats:
-        fmt_ident = f"{fpkg_ident}_{fmt.name}".lower()
-        directions = format_directions.get(fmt.name, "rw")
-        # Format prefix is "rw" even when read-only or write-only
-        index[f"rw_{fmt_ident}_index"] = f"/{fmt.name}.htm"
-        index[f"rw_{fmt_ident}_feature_rep"] = f"/{fmt.name}_feature_rep.htm"
-        for direction in directions:
-            index[f"param_{fmt_ident}_{direction}"] = f"/{fmt.name}_param_{direction}.htm"
-            index[f"ft_{fmt_ident}_param_{direction}"] = f"/{fmt.name}_ft_param_{direction}.htm"
-        index[f"ft_{fmt_ident}_user_attr"] = f"/{fmt.name}_ft_user_attr.htm"
-    return index
-
-
-class HelpBuilder:
-    def __init__(self, fpkg_metadata: FMEPackageMetadata, help_src_dir, help_dst_dir):
-        self.fpkg_metadata = fpkg_metadata
-        self.help_src_dir = Path(help_src_dir)
-        self.help_dst_dir = Path(help_dst_dir)
-
-    def build(self):
-        """
-        Copies help from src to dst. If dst folder exists, it's deleted first.
-
-        If the src has a package_help.csv, then switch to the "manual" mode
-        where doc is copied as-is and package_help.csv is validated for correctness.
-
-        If the src doesn't have package_help.csv, then all .md files are converted to .htm
-        at the dst, and generate package_help.csv at the dst.
-        To map help contexts to their doc, the Markdown files must follow a naming convention.
-        """
-        src_index_file = self.help_src_dir / "package_help.csv"
-        copier = DocCopier(self.help_src_dir)
-        for item in self.fpkg_metadata.transformers:
-            copier.transformer_names.add(item.name)
-        if src_index_file.is_file():
-            self.validate_index(self.help_src_dir)
-            copier.convert_md = False
-
-        if self.help_dst_dir.exists():
-            shutil.rmtree(self.help_dst_dir)
-
-        shutil.copytree(
-            self.help_src_dir,
-            self.help_dst_dir,
-            ignore=shutil.ignore_patterns(*TREE_COPY_IGNORE_GLOBS),
-            copy_function=copier,
-        )
-        if not (self.help_dst_dir / "package_help.csv").is_file():
-            self.build_index(self.help_dst_dir)
-        self.validate_index(self.help_dst_dir)
-
-    def build_index(self, doc_dir):
-        """
-        Write package_help.csv based on package metadata and HTML help files present in doc_dir.
-        To map help contexts to their doc, the Markdown files must follow a naming convention.
-        Help contexts missing a doc file results in a warning,
-        and its row omitted from the output.
-        """
-        expected = get_expected_help_index(self.fpkg_metadata)
-
-        path = Path(doc_dir) / "package_help.csv"
-        with path.open("w", encoding="utf8", newline="") as f:
-            writer = csv.writer(f)
-            for context in sorted(expected.keys()):
-                expected_doc = Path(doc_dir) / expected[context][1:]  # Strip leading /
-                if not expected_doc.is_file():
-                    warnings.warn(f"Missing doc {expected_doc} ({context})")
-                    continue
-                writer.writerow([context, expected[context]])
-        return path
-
-    def validate_index(self, doc_dir):
-        """
-        Read package_help.csv and validates its contents. Checks that:
-
-        - All expected help contexts are present, based on package metadata
-        - No unrecognized help contexts are present
-        - Referenced files exist and are HTML or MD
-        """
-        links = {}
-        with (Path(doc_dir) / "package_help.csv").open("r", encoding="utf8", newline="") as f:
-            try:
-                for row in csv.reader(f):
-                    links[row[0]] = row[1]
-            except IndexError as e:
-                raise IndexError("Invalid package_help.csv: must have 2 columns") from e
-        for ctx, doc_path in links.items():
-            if not doc_path.startswith("/"):
-                raise ValueError(f"Path must start with /: {doc_path}")
-            expected_doc = Path(doc_dir) / doc_path.lstrip("/")
-            if not expected_doc.exists():
-                raise FileNotFoundError(f"{expected_doc} does not exist")
-            if expected_doc.suffix[1:].lower() not in ("htm", "html", "md"):
-                raise ValueError(f"{expected_doc} must be htm(l) or md")
-        expected = set(get_expected_help_index(self.fpkg_metadata).keys())
-        contexts_present = set(links.keys())
-        unrecognized = contexts_present - expected
-        if unrecognized:
-            raise ValueError(f"Unrecognized help: {', '.join(unrecognized)}")
-        missing = expected - contexts_present
-        if missing:
-            raise ValueError(f"Missing help: {', '.join(missing)}")
+"""
+Logic for preparing help documentation for the FPKG packing process.
+
+- package_help.csv validation
+- File copy logic for the help folder
+- Markdown to HTML conversion and package_help.csv generation
+"""
+import csv
+import re
+import shutil
+import warnings
+from pathlib import Path
+
+from markdown import Markdown
+
+from fme_packager.metadata import FMEPackageMetadata
+from fme_packager.operations import TREE_COPY_IGNORE_GLOBS
+
+
+HTML_TPL = """<!DOCTYPE html>
+<html>
+<head>
+<title>{title}</title>
+<link rel="stylesheet" href="{css_path}" />
+</head>
+<body>
+{body}
+</body>
+</html>
+"""
+
+
+def add_transformer_classes_to_doc(html):
+    """
+    Given a string that is HTML doc, modify the first h1 and p tags
+    to mark the relevant contents to show for the FME Workbench Quick Add pane.
+    See FMEENGINE-75813.
+
+    Assumes that:
+    - these tags don't already have a class attribute
+    - the HTML was generated by python-markdown without extensions that modify tags
+    """
+    # Must be exact match: Workbench finds these tags through text search, not DOM.
+    html, _ = re.subn(r"<h1>", '<h1 class="fmx">', html, count=1)
+    html, _ = re.subn(r"<p>", '<p><span class="TransformerSummary">', html, count=1)
+    html, _ = re.subn(r"</p>", "</span></p>", html, count=1)
+    return html
+
+
+class DocCopier:
+    """
+    Callable with the same signature as shutil.copy2(), for use with shutil.copytree().
+    Copies files while converting MD files to HTML at the destination.
+    Identical to shutil.copy2() when conversion is disabled.
+    """
+
+    def __init__(self, root_path):
+        """
+        :param root_path: All files copied must be descendants of this root.
+            Used to determine hardcoded relative paths in generated HTML.
+        """
+        self.root_path = root_path
+        self.convert_md = True
+        self.converted_files = {}
+        self._md_converter = Markdown(
+            extensions=[
+                "tables",
+                "fenced_code",
+            ],
+        )
+        # DEVOPS-3078: Path to CSS relative to the doc root folder
+        self._css_path_rel_doc = "../../css/style.css"
+
+        # When generating HTML, transformer doc gets special treatment.
+        self.transformer_names = set()
+
+    def md_to_html(self, src_file: Path):
+        # Not using python-markdown extensions API because this is a one-off task.
+        body = self._md_converter.reset().convert(src_file.read_text("utf8"))
+        if src_file.stem in self.transformer_names:
+            body = add_transformer_classes_to_doc(body)
+        # Count number of subfolders down from the root,
+        # so the CSS relative path gets updated correctly.
+        subfolder_count = len(src_file.relative_to(self.root_path).parts) - 1
+        return HTML_TPL.format(
+            title=src_file.stem,
+            body=body,
+            css_path="../" * subfolder_count + self._css_path_rel_doc,
+        )
+
+    def __call__(self, src, dst, *args, **kwargs):
+        # Has same signature as shutil.copy(), for use with shutil.copytree().
+        src = Path(src)
+        if not self.convert_md or src.suffix.lower() != ".md":
+            return shutil.copy2(src, dst, *args, **kwargs)
+        dst = Path(dst)
+        dst_filename = src.stem + ".htm"
+        if dst.is_dir():
+            dst = dst / dst_filename
+        else:
+            dst = dst.with_name(dst_filename)
+        htm = self.md_to_html(src)
+        with dst.open("w", encoding="utf8") as f:
+            f.write(htm)
+        self.converted_files[src] = dst
+        return dst
+
+
+def get_expected_help_index(fpkg_metadata: FMEPackageMetadata, format_directions=None):
+    """
+    Returns a mapping of the expected help contexts
+    to the name of its corresponding HTML doc file,
+    based on the formats and transformers in the given package metadata.
+
+    Help contexts are keys used by FME Workbench to map help buttons in the UI
+    to its corresponding page of documentation.
+    The names of the expected HTML files follow a naming convention based on the help context.
+    """
+    # /foundation/ui/core/include/ui/core/helpkeywords.h
+    index = {}
+    if not format_directions:
+        format_directions = {}
+    # dashes in the UIDs get turned to underscores
+    fpkg_ident = f"{fpkg_metadata.publisher_uid}_{fpkg_metadata.uid}".replace("-", "_")
+    # Each transformer has only one topic.
+    for xformer in fpkg_metadata.transformers:
+        index[f"fmx_{fpkg_ident}_{xformer.name}"] = f"/{xformer.name}.htm"
+    # Each format has many topics.
+    for fmt in fpkg_metadata.formats:
+        fmt_ident = f"{fpkg_ident}_{fmt.name}".lower()
+        directions = format_directions.get(fmt.name, "rw")
+        # Format prefix is "rw" even when read-only or write-only
+        index[f"rw_{fmt_ident}_index"] = f"/{fmt.name}.htm"
+        index[f"rw_{fmt_ident}_feature_rep"] = f"/{fmt.name}_feature_rep.htm"
+        for direction in directions:
+            index[f"param_{fmt_ident}_{direction}"] = f"/{fmt.name}_param_{direction}.htm"
+            index[f"ft_{fmt_ident}_param_{direction}"] = f"/{fmt.name}_ft_param_{direction}.htm"
+        index[f"ft_{fmt_ident}_user_attr"] = f"/{fmt.name}_ft_user_attr.htm"
+    return index
+
+
+class HelpBuilder:
+    def __init__(
+        self,
+        fpkg_metadata: FMEPackageMetadata,
+        help_src_dir,
+        help_dst_dir,
+        format_visible_directions,
+    ):
+        self.fpkg_metadata = fpkg_metadata
+        self.help_src_dir = Path(help_src_dir)
+        self.help_dst_dir = Path(help_dst_dir)
+        self.format_directions = format_visible_directions
+
+    def build(self):
+        """
+        Copies help from src to dst. If dst folder exists, it's deleted first.
+
+        If the src has a package_help.csv, then switch to the "manual" mode
+        where doc is copied as-is and package_help.csv is validated for correctness.
+
+        If the src doesn't have package_help.csv, then all .md files are converted to .htm
+        at the dst, and generate package_help.csv at the dst.
+        To map help contexts to their doc, the Markdown files must follow a naming convention.
+        """
+        src_index_file = self.help_src_dir / "package_help.csv"
+        copier = DocCopier(self.help_src_dir)
+        for item in self.fpkg_metadata.transformers:
+            copier.transformer_names.add(item.name)
+        if src_index_file.is_file():
+            self.validate_index(self.help_src_dir)
+            copier.convert_md = False
+
+        if self.help_dst_dir.exists():
+            shutil.rmtree(self.help_dst_dir)
+
+        shutil.copytree(
+            self.help_src_dir,
+            self.help_dst_dir,
+            ignore=shutil.ignore_patterns(*TREE_COPY_IGNORE_GLOBS),
+            copy_function=copier,
+        )
+        if not (self.help_dst_dir / "package_help.csv").is_file():
+            self.build_index(self.help_dst_dir)
+        self.validate_index(self.help_dst_dir)
+
+    def build_index(self, doc_dir):
+        """
+        Write package_help.csv based on package metadata and HTML help files present in doc_dir.
+        To map help contexts to their doc, the Markdown files must follow a naming convention.
+        Help contexts missing a doc file results in a warning,
+        and its row omitted from the output.
+        """
+        expected = get_expected_help_index(self.fpkg_metadata, self.format_directions)
+
+        path = Path(doc_dir) / "package_help.csv"
+        with path.open("w", encoding="utf8", newline="") as f:
+            writer = csv.writer(f)
+            for context in sorted(expected.keys()):
+                expected_doc = Path(doc_dir) / expected[context][1:]  # Strip leading /
+                if not expected_doc.is_file():
+                    warnings.warn(f"Missing doc {expected_doc} ({context})")
+                    continue
+                writer.writerow([context, expected[context]])
+        return path
+
+    def validate_index(self, doc_dir):
+        """
+        Read package_help.csv and validates its contents. Checks that:
+
+        - All expected help contexts are present, based on package metadata
+        - No unrecognized help contexts are present
+        - Referenced files exist and are HTML or MD
+        """
+        links = {}
+        with (Path(doc_dir) / "package_help.csv").open("r", encoding="utf8", newline="") as f:
+            try:
+                for row in csv.reader(f):
+                    links[row[0]] = row[1]
+            except IndexError as e:
+                raise IndexError("Invalid package_help.csv: must have 2 columns") from e
+        for ctx, doc_path in links.items():
+            if not doc_path.startswith("/"):
+                raise ValueError(f"Path must start with /: {doc_path}")
+            expected_doc = Path(doc_dir) / doc_path.lstrip("/")
+            if not expected_doc.exists():
+                raise FileNotFoundError(f"{expected_doc} does not exist")
+            if expected_doc.suffix[1:].lower() not in ("htm", "html", "md"):
+                raise ValueError(f"{expected_doc} must be htm(l) or md")
+        expected = set(get_expected_help_index(self.fpkg_metadata, self.format_directions).keys())
+        contexts_present = set(links.keys())
+        unrecognized = contexts_present - expected
+        if unrecognized:
+            raise ValueError(f"Unrecognized help: {', '.join(unrecognized)}")
+        missing = expected - contexts_present
+        if missing:
+            raise ValueError(f"Missing help: {', '.join(missing)}")
```

## fme_packager/packager.py

```diff
@@ -109,38 +109,61 @@
     if (
         "SOURCE_READER {}".format(fqname) not in contents
         or "FORMAT_NAME {}".format(fqname) not in contents
     ):
         raise ValueError("SOURCE_READER and FORMAT_NAME must be '{}'".format(fqname))
 
 
-def check_formatinfo(package_metadata, format_metadata, db_path):
+def get_formatinfo(package_metadata, format_metadata, db_path):
     """
-    Checks formatinfo is consistent with the package and format metadata.
+    Retrieves formatinfo and checks that it is consistent with the package and format metadata.
 
     :param package_metadata: The package metadata.
     :param format_metadata: The format metadata.
     :param db_path: The path to the format file.
     """
+    fqname = fq_format_short_name(
+        package_metadata.publisher_uid, package_metadata.uid, format_metadata.name
+    )
+
     line = None
     with open(db_path) as inf:
         for line in inf:
             if line.startswith(";"):
                 continue  # comment line.
+            formatinfo = parse_formatinfo(line)
+            if formatinfo.FORMAT_NAME == fqname:
+                return formatinfo
 
     if not line:
         raise ValueError("{} empty".format(db_path))
 
-    fqname = fq_format_short_name(
-        package_metadata.publisher_uid, package_metadata.uid, format_metadata.name
-    )
+    raise ValueError("{} must have FORMAT_NAME of '{}'".format(db_path, fqname))
 
-    formatinfo = parse_formatinfo(line)
-    if formatinfo.FORMAT_NAME != fqname:
-        raise ValueError("{} must have FORMAT_NAME of '{}'".format(db_path, fqname))
+
+def get_format_visibility(formatinfo):
+    """
+    Get the directions for which a format is visible to the user
+
+    :param formatinfo: the format info.
+    """
+    direction_to_visibility_map = {
+        "BOTH": {"YES": "rw", "INPUT": "r", "OUTPUT": "w", "NO": ""},
+        "INPUT": {"YES": "r", "INPUT": "r", "NO": ""},  # exclude visibility: OUTPUT
+        "OUTPUT": {"YES": "w", "OUTPUT": "w", "NO": ""},  # exclude visibility: INPUT
+    }
+
+    try:
+        return direction_to_visibility_map[formatinfo.DIRECTION][formatinfo.VISIBLE]
+    except KeyError:
+        raise ValueError(
+            "Format visibility '{visible}' is not compatible with direction '{direction}'".format(
+                visible=formatinfo.VISIBLE, direction=formatinfo.DIRECTION
+            )
+        )
 
 
 class FMEPackager:
     def __init__(self, src_dir, verbose=True):
         """
         :param src_dir: FME package directory
         :param verbose: If true, print out build steps
@@ -149,14 +172,16 @@
         self.build_dir = self.src_dir / "build"
         self.dist_dir = self.src_dir / "dist"
         self.src_python_dir = self.src_dir / "python"
 
         self.metadata = load_fpkg_metadata(src_dir)
         self.verbose = verbose
 
+        self.fmt_visible_directions = {}
+
         validate(self.metadata.dict, load_metadata_json_schema())
 
     def apply_help(self, help_src):
         """
         Import an Safe TechPubs doc export into an FME Package directory.
 
         :param help_src: Help source path.
@@ -296,15 +321,18 @@
                 raise ValueError(f"{fmf_path} is in metadata, but was not found")
             check_fmf(self.metadata, fmt, fmf_path)
             shutil.copy(fmf_path, dst)
 
             db_path = src / f"{fmt.name}.db"
             if not db_path.is_file():
                 raise ValueError(f"{db_path} is in metadata, but was not found")
-            check_formatinfo(self.metadata, fmt, db_path)
+            formatinfo = get_formatinfo(self.metadata, fmt, db_path)
+
+            self.fmt_visible_directions[fmt.name] = get_format_visibility(formatinfo)
+
             shutil.copy(db_path, dst)
 
     def validate_transformer(self, transformer_path, expected_metadata: TransformerMetadata):
         self._print(f"Checking {transformer_path}")
         transformer_file = load_transformer(transformer_path)
 
         expected_fqname = "{}.{}.{}".format(
@@ -517,13 +545,13 @@
     def _copy_help(self):
         src = self.src_dir / "help"
         dest = self.build_dir / "help"
         if not src.is_dir():
             return
 
         self._print("Copying help")
-        builder = HelpBuilder(self.metadata, src, dest)
+        builder = HelpBuilder(self.metadata, src, dest, self.fmt_visible_directions)
         builder.build()
 
     def _print(self, msg):
         if self.verbose:
             print(msg)
```

## fme_packager/verifier.py

```diff
@@ -43,20 +43,10 @@
             shutil.unpack_archive(temp_zip_file, temp_dir)
 
             # Verify the fpkg files by building the package
             steps = FMEPackager(temp_dir, self.verbose)
             steps.build()
             steps.make_fpkg()
 
-            # Verify package file name is the same
-            if not os.path.exists(pathlib.Path(temp_dir) / "dist" / os.path.basename(self.file)):
-                raise ValueError(
-                    "The file name is invalid. Expected {}".format(
-                        build_fpkg_filename(
-                            steps.metadata.publisher_uid, steps.metadata.uid, steps.metadata.version
-                        )
-                    )
-                )
-
     def _print(self, msg):
         if self.verbose:
             print(msg)
```

## Comparing `fme_packager-1.4.0.dist-info/LICENSE` & `fme_packager-1.4.3.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `fme_packager-1.4.0.dist-info/METADATA` & `fme_packager-1.4.3.dist-info/METADATA`

 * *Files 2% similar despite different names*

```diff
@@ -1,21 +1,22 @@
 Metadata-Version: 2.1
 Name: fme-packager
-Version: 1.4.0
+Version: 1.4.3
 Summary: Tool for creating FME Packages.
 Home-page: https://github.com/safesoftware/fme-packager
 Author: Safe Software Inc.
 License: BSD
 Keywords: FME fmeobjects
 Classifier: Programming Language :: Python :: 3
 Classifier: Programming Language :: Python :: 3.6
 Classifier: Programming Language :: Python :: 3.7
 Classifier: Programming Language :: Python :: 3.8
 Classifier: Programming Language :: Python :: 3.9
 Classifier: Programming Language :: Python :: 3.10
+Classifier: Programming Language :: Python :: 3.11
 Classifier: License :: OSI Approved :: BSD License
 Classifier: Intended Audience :: Developers
 Requires-Python: >=3.6
 Description-Content-Type: text/markdown
 License-File: LICENSE
 Requires-Dist: click (~=8.0.0)
 Requires-Dist: cookiecutter (~=1.7.2)
@@ -30,14 +31,15 @@
 Requires-Dist: markdown (>=3.3.0)
 Provides-Extra: dev
 Requires-Dist: pipenv ; extra == 'dev'
 Requires-Dist: pytest ; extra == 'dev'
 Requires-Dist: black ; extra == 'dev'
 Requires-Dist: tox ; extra == 'dev'
 Requires-Dist: twine ; extra == 'dev'
+Requires-Dist: urllib3 (<2) ; extra == 'dev'
 
 # fme-packager: FME Package Creator
 
 `fme-packager` is a Python command-line tool for validating and creating FME Packages.
 Give it the path to an FME Package directory, and it'll do some quick checks
 and build an `.fpkg` file out of it.
 
@@ -83,15 +85,15 @@
 `fme-packager init [template name]` helps you get started with developing FME Packages by
 using [Cookiecutter](https://cookiecutter.readthedocs.io/) templates.
 
 Available templates:
 
 * `transformer`: [Transformer template for FME Packages](https://github.com/safesoftware/fpkg-transformer-template)
 
-_These templates are not currently bundled with fme-packager.
+_These templates are not currently bundled with fme-packager._
 
 
 ## Make an fpkg distribution
 
 Call `fme-packager pack` with the path to your package directory (it contains package.yml):
 
 ```
```

## Comparing `fme_packager-1.4.0.dist-info/RECORD` & `fme_packager-1.4.3.dist-info/RECORD`

 * *Files 12% similar despite different names*

```diff
@@ -1,18 +1,18 @@
-fme_packager/__init__.py,sha256=-pa9pj_zJgPDZtE3ena4mjuVS3FEWQWYij1shjLYS80,23
+fme_packager/__init__.py,sha256=u4xGo4EEZVX-u-TCwr4E7xqiNI8CBa-r7K0R3sGJbck,23
 fme_packager/__main__.py,sha256=e_t_YkADgMuemYD7ZjgjDL_zcOF7fnr5mxhVigFciSY,90
 fme_packager/cli.py,sha256=bC-pakWfV7Vaos0Pj9JQq4KeFbm1Z-qcZgob8xgKGJI,4445
 fme_packager/exception.py,sha256=B-56eGIMxhexxI8cE6Su5PhGBf5A2Ur_CFXkWJrUKYo,647
 fme_packager/fme_env.py,sha256=4Sp_K5T2vmGz_Q0Fk0wOMARRAyBTHbKO9rqLQnfkO0Q,543
-fme_packager/help.py,sha256=V7kF29qSM0NsYBF3MmDkVcGQU1GAXFHKZ2Ch2w5Ww1I,9196
+fme_packager/help.py,sha256=OFBS2zT7YQr9vPbFpg0UZiFWzV84y-dWrbsCvqjLUu4,9683
 fme_packager/metadata.py,sha256=MmZLwN0SgKUMMYbtOiboYLuSVG-hl_vID7RAn0IlYq4,3356
 fme_packager/operations.py,sha256=PeBTeYgN7jrz3t4UOmKkJvV2OSzfqgRPLTzBsqoz3JE,2457
-fme_packager/packager.py,sha256=J3sK2MofB5ioa90ejiO4DCSQOrBec5RCiVJ0gVPp268,21780
+fme_packager/packager.py,sha256=YRrnpRJKQTQWXEyGoRQ4Kp7ZuDnnB6xOu2mFSgCwvLA,22830
 fme_packager/spec.json,sha256=QvKySilad0_l4OuBmChYIa3DjCNoYjd9N_MsqOEHMYg,4692
 fme_packager/transformer.py,sha256=xi_HlDqrIe693vFSQN68v7wkI3O-0UUeDgGikUbJ--E,6158
-fme_packager/verifier.py,sha256=Jmb5BVMArE4hInpg5TM6wXEq0DwQKVdoNCcWRjnfB_s,2270
-fme_packager-1.4.0.dist-info/LICENSE,sha256=E2nvDknEP3y3-Jn678X5XScioCszhxbdZReb_co7xvI,1307
-fme_packager-1.4.0.dist-info/METADATA,sha256=yiZRCJrDqXY9tUJhP9RHwmGdrxVCcid8Q5PMzhnjPbs,3649
-fme_packager-1.4.0.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
-fme_packager-1.4.0.dist-info/entry_points.txt,sha256=b_VV36s6ys9391Lkvz7-J9mKHUa_cJ5gmmbfoCUWxBQ,54
-fme_packager-1.4.0.dist-info/top_level.txt,sha256=8aDyB1LNmaWY3QSnnrXmSrk2T5R_G61VzN9rEpXN2no,13
-fme_packager-1.4.0.dist-info/RECORD,,
+fme_packager/verifier.py,sha256=LwcLsAvw6wgNZHun3G62r9Y6r2LqNk5fH35JPB7pgGI,1796
+fme_packager-1.4.3.dist-info/LICENSE,sha256=E2nvDknEP3y3-Jn678X5XScioCszhxbdZReb_co7xvI,1307
+fme_packager-1.4.3.dist-info/METADATA,sha256=e37z-ZAZM1w3gfq-4HGLUkFJFUWvFC5q9XCE9NseDlw,3748
+fme_packager-1.4.3.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
+fme_packager-1.4.3.dist-info/entry_points.txt,sha256=b_VV36s6ys9391Lkvz7-J9mKHUa_cJ5gmmbfoCUWxBQ,54
+fme_packager-1.4.3.dist-info/top_level.txt,sha256=8aDyB1LNmaWY3QSnnrXmSrk2T5R_G61VzN9rEpXN2no,13
+fme_packager-1.4.3.dist-info/RECORD,,
```

