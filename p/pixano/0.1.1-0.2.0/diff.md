# Comparing `tmp/pixano-0.1.1.tar.gz` & `tmp/pixano-0.2.0.tar.gz`

## Comparing `pixano-0.1.1.tar` & `pixano-0.2.0.tar`

### file list

```diff
@@ -1,39 +1,42 @@
--rw-r--r--   0        0        0      575 2020-02-02 00:00:00.000000 pixano-0.1.1/pixano/__init__.py
--rw-r--r--   0        0        0      598 2020-02-02 00:00:00.000000 pixano-0.1.1/pixano/__version__.py
--rw-r--r--   0        0        0      575 2020-02-02 00:00:00.000000 pixano-0.1.1/pixano/analytics/__init__.py
--rw-r--r--   0        0        0     3095 2020-02-02 00:00:00.000000 pixano-0.1.1/pixano/analytics/feature_statistics.py
--rw-r--r--   0        0        0       17 2020-02-02 00:00:00.000000 pixano-0.1.1/pixano/apps/explorer/README.md
--rw-r--r--   0        0        0      575 2020-02-02 00:00:00.000000 pixano-0.1.1/pixano/apps/explorer/__init__.py
--rw-r--r--   0        0        0     6769 2020-02-02 00:00:00.000000 pixano-0.1.1/pixano/apps/explorer/db_utils.py
--rw-r--r--   0        0        0     4462 2020-02-02 00:00:00.000000 pixano-0.1.1/pixano/apps/explorer/main.py
--rw-r--r--   0        0        0     3041 2020-02-02 00:00:00.000000 pixano-0.1.1/pixano/apps/explorer/serve.py
--rw-r--r--   0        0        0      567 2020-02-02 00:00:00.000000 pixano-0.1.1/pixano/apps/explorer/dist/index.html
--rw-r--r--   0        0        0  1079144 2020-02-02 00:00:00.000000 pixano-0.1.1/pixano/apps/explorer/dist/assets/index-275a5f8e.js
--rw-r--r--   0        0        0    13850 2020-02-02 00:00:00.000000 pixano-0.1.1/pixano/apps/explorer/dist/assets/index-ab1a97a8.css
--rw-r--r--   0        0        0    13031 2020-02-02 00:00:00.000000 pixano-0.1.1/pixano/apps/explorer/dist/assets/pixano-354ac9df.png
--rw-r--r--   0        0        0      575 2020-02-02 00:00:00.000000 pixano-0.1.1/pixano/core/__init__.py
--rw-r--r--   0        0        0     2561 2020-02-02 00:00:00.000000 pixano-0.1.1/pixano/core/dataset.py
--rw-r--r--   0        0        0     1262 2020-02-02 00:00:00.000000 pixano-0.1.1/pixano/core/dataset_test.py
--rw-r--r--   0        0        0     2322 2020-02-02 00:00:00.000000 pixano-0.1.1/pixano/core/models.py
--rw-r--r--   0        0        0     3940 2020-02-02 00:00:00.000000 pixano-0.1.1/pixano/core/arrow_types/__init__.py
--rw-r--r--   0        0        0      975 2020-02-02 00:00:00.000000 pixano-0.1.1/pixano/core/arrow_types/features.py
--rw-r--r--   0        0        0     4504 2020-02-02 00:00:00.000000 pixano-0.1.1/pixano/core/arrow_types/image.py
--rw-r--r--   0        0        0     1325 2020-02-02 00:00:00.000000 pixano-0.1.1/pixano/core/arrow_types/image_test.py
--rw-r--r--   0        0        0      760 2020-02-02 00:00:00.000000 pixano-0.1.1/pixano/data/__init__.py
--rw-r--r--   0        0        0     3580 2020-02-02 00:00:00.000000 pixano-0.1.1/pixano/data/coco_loader.py
--rw-r--r--   0        0        0      920 2020-02-02 00:00:00.000000 pixano-0.1.1/pixano/data/data_loader.py
--rw-r--r--   0        0        0     2760 2020-02-02 00:00:00.000000 pixano-0.1.1/pixano/data/models.py
--rw-r--r--   0        0        0     9717 2020-02-02 00:00:00.000000 pixano-0.1.1/pixano/data/pixano_loader.py
--rw-r--r--   0        0        0      658 2020-02-02 00:00:00.000000 pixano-0.1.1/pixano/inference/__init__.py
--rw-r--r--   0        0        0     6302 2020-02-02 00:00:00.000000 pixano-0.1.1/pixano/inference/inference_model.py
--rw-r--r--   0        0        0      644 2020-02-02 00:00:00.000000 pixano-0.1.1/pixano/tools/converter/__init__.py
--rw-r--r--   0        0        0     9891 2020-02-02 00:00:00.000000 pixano-0.1.1/pixano/tools/converter/convert2parquet.py
--rw-r--r--   0        0        0     1309 2020-02-02 00:00:00.000000 pixano-0.1.1/pixano/transforms/__init__.py
--rw-r--r--   0        0        0     3077 2020-02-02 00:00:00.000000 pixano-0.1.1/pixano/transforms/boxes.py
--rw-r--r--   0        0        0     5680 2020-02-02 00:00:00.000000 pixano-0.1.1/pixano/transforms/image.py
--rw-r--r--   0        0        0     5594 2020-02-02 00:00:00.000000 pixano-0.1.1/pixano/transforms/labels.py
--rw-r--r--   0        0        0      394 2020-02-02 00:00:00.000000 pixano-0.1.1/.gitignore
--rw-r--r--   0        0        0    21864 2020-02-02 00:00:00.000000 pixano-0.1.1/LICENSE.txt
--rw-r--r--   0        0        0      456 2020-02-02 00:00:00.000000 pixano-0.1.1/README.md
--rw-r--r--   0        0        0     1760 2020-02-02 00:00:00.000000 pixano-0.1.1/pyproject.toml
--rw-r--r--   0        0        0     2150 2020-02-02 00:00:00.000000 pixano-0.1.1/PKG-INFO
+-rw-r--r--   0        0        0      575 2020-02-02 00:00:00.000000 pixano-0.2.0/pixano/__init__.py
+-rw-r--r--   0        0        0      599 2020-02-02 00:00:00.000000 pixano-0.2.0/pixano/__version__.py
+-rw-r--r--   0        0        0      575 2020-02-02 00:00:00.000000 pixano-0.2.0/pixano/analytics/__init__.py
+-rw-r--r--   0        0        0     3102 2020-02-02 00:00:00.000000 pixano-0.2.0/pixano/analytics/feature_statistics.py
+-rw-r--r--   0        0        0     1238 2020-02-02 00:00:00.000000 pixano-0.2.0/pixano/apps/explorer/README.md
+-rw-r--r--   0        0        0      575 2020-02-02 00:00:00.000000 pixano-0.2.0/pixano/apps/explorer/__init__.py
+-rw-r--r--   0        0        0     6736 2020-02-02 00:00:00.000000 pixano-0.2.0/pixano/apps/explorer/db_utils.py
+-rw-r--r--   0        0        0     5672 2020-02-02 00:00:00.000000 pixano-0.2.0/pixano/apps/explorer/main.py
+-rw-r--r--   0        0        0     3042 2020-02-02 00:00:00.000000 pixano-0.2.0/pixano/apps/explorer/serve.py
+-rw-r--r--   0        0        0      567 2020-02-02 00:00:00.000000 pixano-0.2.0/pixano/apps/explorer/dist/index.html
+-rw-r--r--   0        0        0  1043692 2020-02-02 00:00:00.000000 pixano-0.2.0/pixano/apps/explorer/dist/assets/index-69c43586.js
+-rw-r--r--   0        0        0    14024 2020-02-02 00:00:00.000000 pixano-0.2.0/pixano/apps/explorer/dist/assets/index-f2b8d192.css
+-rw-r--r--   0        0        0    13031 2020-02-02 00:00:00.000000 pixano-0.2.0/pixano/apps/explorer/dist/assets/pixano-354ac9df.png
+-rw-r--r--   0        0        0      575 2020-02-02 00:00:00.000000 pixano-0.2.0/pixano/core/__init__.py
+-rw-r--r--   0        0        0     3555 2020-02-02 00:00:00.000000 pixano-0.2.0/pixano/core/dataset.py
+-rw-r--r--   0        0        0     1262 2020-02-02 00:00:00.000000 pixano-0.2.0/pixano/core/dataset_test.py
+-rw-r--r--   0        0        0     3429 2020-02-02 00:00:00.000000 pixano-0.2.0/pixano/core/arrow_types/__init__.py
+-rw-r--r--   0        0        0     4218 2020-02-02 00:00:00.000000 pixano-0.2.0/pixano/core/arrow_types/features.py
+-rw-r--r--   0        0        0     4477 2020-02-02 00:00:00.000000 pixano-0.2.0/pixano/core/arrow_types/image.py
+-rw-r--r--   0        0        0     1861 2020-02-02 00:00:00.000000 pixano-0.2.0/pixano/core/arrow_types/image_test.py
+-rw-r--r--   0        0        0      760 2020-02-02 00:00:00.000000 pixano-0.2.0/pixano/data/__init__.py
+-rw-r--r--   0        0        0     4049 2020-02-02 00:00:00.000000 pixano-0.2.0/pixano/data/coco_loader.py
+-rw-r--r--   0        0        0      934 2020-02-02 00:00:00.000000 pixano-0.2.0/pixano/data/data_loader.py
+-rw-r--r--   0        0        0     4208 2020-02-02 00:00:00.000000 pixano-0.2.0/pixano/data/models.py
+-rw-r--r--   0        0        0    10221 2020-02-02 00:00:00.000000 pixano-0.2.0/pixano/data/pixano_loader.py
+-rw-r--r--   0        0        0      775 2020-02-02 00:00:00.000000 pixano-0.2.0/pixano/inference/__init__.py
+-rw-r--r--   0        0        0     3688 2020-02-02 00:00:00.000000 pixano-0.2.0/pixano/inference/inference_model.py
+-rw-r--r--   0        0        0     5751 2020-02-02 00:00:00.000000 pixano-0.2.0/pixano/inference/offline_model.py
+-rw-r--r--   0        0        0     7942 2020-02-02 00:00:00.000000 pixano-0.2.0/pixano/inference/online_model.py
+-rw-r--r--   0        0        0      636 2020-02-02 00:00:00.000000 pixano-0.2.0/pixano/notebook/__init__.py
+-rw-r--r--   0        0        0     4443 2020-02-02 00:00:00.000000 pixano-0.2.0/pixano/notebook/display.py
+-rw-r--r--   0        0        0      644 2020-02-02 00:00:00.000000 pixano-0.2.0/pixano/tools/converter/__init__.py
+-rw-r--r--   0        0        0    10184 2020-02-02 00:00:00.000000 pixano-0.2.0/pixano/tools/converter/convert2parquet.py
+-rw-r--r--   0        0        0     1308 2020-02-02 00:00:00.000000 pixano-0.2.0/pixano/transforms/__init__.py
+-rw-r--r--   0        0        0     3077 2020-02-02 00:00:00.000000 pixano-0.2.0/pixano/transforms/boxes.py
+-rw-r--r--   0        0        0     5675 2020-02-02 00:00:00.000000 pixano-0.2.0/pixano/transforms/image.py
+-rw-r--r--   0        0        0     5594 2020-02-02 00:00:00.000000 pixano-0.2.0/pixano/transforms/labels.py
+-rw-r--r--   0        0        0      401 2020-02-02 00:00:00.000000 pixano-0.2.0/.gitignore
+-rw-r--r--   0        0        0    21864 2020-02-02 00:00:00.000000 pixano-0.2.0/LICENSE
+-rw-r--r--   0        0        0     1751 2020-02-02 00:00:00.000000 pixano-0.2.0/README.md
+-rw-r--r--   0        0        0     1599 2020-02-02 00:00:00.000000 pixano-0.2.0/pyproject.toml
+-rw-r--r--   0        0        0    29190 2020-02-02 00:00:00.000000 pixano-0.2.0/PKG-INFO
```

### Comparing `pixano-0.1.1/pixano/__init__.py` & `pixano-0.2.0/pixano/__init__.py`

 * *Files identical despite different names*

### Comparing `pixano-0.1.1/pixano/__version__.py` & `pixano-0.2.0/pixano/__version__.py`

 * *Files 1% similar despite different names*

```diff
@@ -7,8 +7,8 @@
 # This software is governed by the CeCILL-C license under French law and
 # abiding by the rules of distribution of free software. You can use,
 # modify and/ or redistribute the software under the terms of the CeCILL-C
 # license as circulated by CEA, CNRS and INRIA at the following URL
 #
 # http://www.cecill.info
 
-__version__ = "0.1.1"
+__version__ = "0.2.0"
```

### Comparing `pixano-0.1.1/pixano/analytics/__init__.py` & `pixano-0.2.0/pixano/analytics/__init__.py`

 * *Files identical despite different names*

### Comparing `pixano-0.1.1/pixano/analytics/feature_statistics.py` & `pixano-0.2.0/pixano/analytics/feature_statistics.py`

 * *Files 10% similar despite different names*

```diff
@@ -14,16 +14,15 @@
 from fractions import Fraction
 
 import numpy as np
 import pandas as pd
 import pyarrow as pa
 
 
-# Compute additional data from existing values
-def compute_additional_data(data_table: pa.Table):
+def compute_additional_data(data_table: pa.Table) -> pd.DataFrame:
     """Convert Table to DataFrame and add resolution and aspect ratio
 
     Args:
         data_table (pa.Table): Input Table
 
     Returns:
         pd.DataFrame: DataFrame with added resolution and aspect ratio
@@ -41,15 +40,15 @@
     data["aspect_ratio"] = data.apply(
         lambda x: str(Fraction(x["width"], x["height"])).replace("/", ":"), axis=1
     )
 
     return data
 
 
-def objects_tableToDF(data_table: pa.Table, field: str):
+def objects_tableToDF(data_table: pa.Table, field: str) -> pd.DataFrame:
     """Convert a field from the objects column to a DataFrame
 
     Args:
         data_table (pa.Table): Table with an objects column
         field (str): Selected field from the objects column
 
     Returns:
@@ -61,15 +60,15 @@
         sel = [{field: d[field]} for objs in df_objs["objects"] for d in objs]
         return pd.DataFrame.from_dict(sel)
     except Exception:
         print("ERROR: Unable to convert table Pandas DataFrame")
         return None
 
 
-def numeric_features_stats(df: pd.DataFrame, field: str):
+def numeric_features_stats(df: pd.DataFrame, field: str) -> list[dict]:
     """Compute numerical statistics (histogram)
 
     Args:
         df (pd.DataFrame): Input DataFrame
         field (str): Selected field
 
     Returns:
@@ -81,15 +80,15 @@
     for i in range(len(counts)):
         res.append(
             {"bin_start": bins[i], "bin_end": bins[i + 1], "sample_count": counts[i]}
         )
     return res
 
 
-def categorical_feature_stats(df: pd.DataFrame, field: str, title: str):
+def categorical_feature_stats(df: pd.DataFrame, field: str, title: str) -> dict:
     """Compute categorical statistics
 
     Args:
         df (pd.DataFrame): Input DataFrame
         field (str): Selected field
         title (str): Field title
```

### Comparing `pixano-0.1.1/pixano/apps/explorer/__init__.py` & `pixano-0.2.0/pixano/apps/explorer/__init__.py`

 * *Files identical despite different names*

### Comparing `pixano-0.1.1/pixano/apps/explorer/db_utils.py` & `pixano-0.2.0/pixano/apps/explorer/db_utils.py`

 * *Files 11% similar despite different names*

```diff
@@ -7,44 +7,44 @@
 # This software is governed by the CeCILL-C license under French law and
 # abiding by the rules of distribution of free software. You can use,
 # modify and/ or redistribute the software under the terms of the CeCILL-C
 # license as circulated by CEA, CNRS and INRIA at the following URL
 #
 # http://www.cecill.info
 
-from typing import Any, Optional
+from pathlib import Path
 
 import duckdb
 import numpy as np
 import pyarrow as pa
-import pyarrow.dataset as arrow_ds
+import pyarrow.dataset as ds
 from fastapi_pagination.api import create_page, resolve_params
 from fastapi_pagination.bases import AbstractPage, AbstractParams
 
+from pixano import transforms
 from pixano.core import arrow_types
 from pixano.data import models
-from pixano import transforms
 
 
 def get_item_details(
-    dataset: arrow_ds.Dataset,
-    item_id,
-    media_dir,
-    infer_datasets: list[arrow_ds.Dataset] = None,
-):
+    dataset: ds.Dataset,
+    item_id: int,
+    media_dir: Path,
+    infer_datasets: list[ds.Dataset] = [],
+) -> dict:
     """Get item details
 
     Args:
-        dataset (arrow_ds.Dataset): dataset
-        item_id (int): id of selected item
-        media_dir (Path): path to media directory
-        infer_datasets (list[arrow_ds.Dataset], optionnal): list of inference datasets
+        dataset (ds.Dataset): Dataset
+        item_id (int): Selected item ID
+        media_dir (Path): Dataset media path
+        infer_datasets (list[ds.Dataset], optional): List of inference datasets. Defaults to [].
 
     Returns:
-        dict: features for ui (ImageDetails)
+        dict: ImageDetails features for UI
     """
     schema = dataset.schema
     item = duckdb.query(f"SELECT * FROM dataset WHERE id={item_id}").fetchone()
 
     field_names = [f.name for f in schema]
     item_dict = dict(zip(field_names, item))
 
@@ -137,40 +137,38 @@
                     "segmentation": masks,
                 },
             }
 
     return features
 
 
-def get_items(
-    dataset: arrow_ds.Dataset, params: Optional[AbstractParams] = None
-) -> AbstractPage[Any]:
+def get_items(dataset: ds.Dataset, params: AbstractParams = None) -> AbstractPage:
     """Get items
 
     Args:
-        dataset (pa.Dataset): dataset
-        params (Optional[AbstractParams], optional): FastAPI params for pagination. Defaults to None.
+        dataset (pa.Dataset): Dataset
+        params (AbstractParams, optional): FastAPI params for pagination. Defaults to None.
 
     Returns:
-        AbstractPage[models.Features]: list of features for ui (DatasetExplorer)
+        AbstractPage: List of models.Feature for UI (DatasetExplorer)
     """
 
     params = resolve_params(params)
     raw_params = params.to_raw_params()
 
     total = dataset.count_rows()
     schema = dataset.schema
 
     items_table = duckdb.query(
         # HACK TO SELECT ONLY VAL FOR COCO
         # f"SELECT * from dataset WHERE split='val2017' OFFSET {raw_params.offset} LIMIT {raw_params.limit}"
         f"SELECT * from dataset OFFSET {raw_params.offset} LIMIT {raw_params.limit}"
     ).arrow()
 
-    def _create_features(row):
+    def _create_features(row: list) -> list[models.Feature]:
         features = []
         for field in schema:
             if arrow_types.is_number(field.type):
                 features.append(
                     models.Feature(
                         name=field.name, dtype="number", value=row[field.name]
                     )
```

### Comparing `pixano-0.1.1/pixano/apps/explorer/serve.py` & `pixano-0.2.0/pixano/apps/explorer/serve.py`

 * *Files 0% similar despite different names*

```diff
@@ -7,22 +7,23 @@
 # This software is governed by the CeCILL-C license under French law and
 # abiding by the rules of distribution of free software. You can use,
 # modify and/ or redistribute the software under the terms of the CeCILL-C
 # license as circulated by CEA, CNRS and INRIA at the following URL
 #
 # http://www.cecill.info
 
+from pathlib import Path
+
 import click
 import fastapi
 import pkg_resources
 import uvicorn
 from fastapi.responses import HTMLResponse
 from fastapi.staticfiles import StaticFiles
 from fastapi.templating import Jinja2Templates
-from pathlib import Path
 
 from .main import app, settings
 
 logo = """
                              ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒
                            ▒▓▒                                       ▓
               █▓          ▓▓                                         ▓
```

### Comparing `pixano-0.1.1/pixano/apps/explorer/dist/index.html` & `pixano-0.2.0/pixano/apps/explorer/dist/index.html`

 * *Files 22% similar despite different names*

```diff
@@ -1,16 +1,16 @@
 <!DOCTYPE html>
 <html lang="en">
   <head>
     <meta charset="UTF-8" />
     <link rel="icon" type="image/svg+xml" href="/assets/pixano-354ac9df.png" />
     <meta name="viewport" content="width=device-width, initial-scale=1.0" />
     <title>Pixano Explorer</title>
-    <script type="module" crossorigin src="/assets/index-275a5f8e.js"></script>
-    <link rel="stylesheet" href="/assets/index-ab1a97a8.css">
+    <script type="module" crossorigin src="/assets/index-69c43586.js"></script>
+    <link rel="stylesheet" href="/assets/index-f2b8d192.css">
   </head>
   <body>
     <div
       id="app"
       class="h-full min-h-screen text-zinc-900 dark:bg-zinc-800 dark:text-zinc-300"
     ></div>
```

### Comparing `pixano-0.1.1/pixano/apps/explorer/dist/assets/index-275a5f8e.js` & `pixano-0.2.0/pixano/apps/explorer/dist/assets/index-69c43586.js`

 * *Files 4% similar despite different names*

#### js-beautify {}

```diff
@@ -1,384 +1,384 @@
-var $8 = (e, t) => () => (t || e((t = {
+var L8 = (e, t) => () => (t || e((t = {
     exports: {}
 }).exports, t), t.exports);
-var exe = $8((hxe, wC) => {
+var Ube = L8((F2e, jC) => {
     (function() {
         const t = document.createElement("link").relList;
         if (t && t.supports && t.supports("modulepreload")) return;
         for (const r of document.querySelectorAll('link[rel="modulepreload"]')) i(r);
         new MutationObserver(r => {
-            for (const a of r)
-                if (a.type === "childList")
-                    for (const s of a.addedNodes) s.tagName === "LINK" && s.rel === "modulepreload" && i(s)
+            for (const s of r)
+                if (s.type === "childList")
+                    for (const a of s.addedNodes) a.tagName === "LINK" && a.rel === "modulepreload" && i(a)
         }).observe(document, {
             childList: !0,
             subtree: !0
         });
 
         function n(r) {
-            const a = {};
-            return r.integrity && (a.integrity = r.integrity), r.referrerPolicy && (a.referrerPolicy = r.referrerPolicy), r.crossOrigin === "use-credentials" ? a.credentials = "include" : r.crossOrigin === "anonymous" ? a.credentials = "omit" : a.credentials = "same-origin", a
+            const s = {};
+            return r.integrity && (s.integrity = r.integrity), r.referrerPolicy && (s.referrerPolicy = r.referrerPolicy), r.crossOrigin === "use-credentials" ? s.credentials = "include" : r.crossOrigin === "anonymous" ? s.credentials = "omit" : s.credentials = "same-origin", s
         }
 
         function i(r) {
             if (r.ep) return;
             r.ep = !0;
-            const a = n(r);
-            fetch(r.href, a)
+            const s = n(r);
+            fetch(r.href, s)
         }
     })();
 
-    function Ke() {}
+    function Ve() {}
 
-    function hM(e) {
+    function SM(e) {
         return e()
     }
 
-    function RC() {
+    function XC() {
         return Object.create(null)
     }
 
-    function Ka(e) {
-        e.forEach(hM)
+    function js(e) {
+        e.forEach(SM)
     }
 
-    function dM(e) {
+    function EM(e) {
         return typeof e == "function"
     }
 
-    function rn(e, t) {
+    function tn(e, t) {
         return e != e ? t == t : e !== t || e && typeof e == "object" || typeof e == "function"
     }
-    let tg;
+    let Bd;
 
-    function Sh(e, t) {
-        return tg || (tg = document.createElement("a")), tg.href = t, e === tg.href
+    function fh(e, t) {
+        return Bd || (Bd = document.createElement("a")), Bd.href = t, e === Bd.href
     }
 
-    function M8(e) {
+    function I8(e) {
         return Object.keys(e).length === 0
     }
 
-    function U(e, t) {
+    function G(e, t) {
         e.appendChild(t)
     }
 
-    function _e(e, t, n) {
+    function we(e, t, n) {
         e.insertBefore(t, n || null)
     }
 
-    function xe(e) {
+    function _e(e) {
         e.parentNode && e.parentNode.removeChild(e)
     }
 
-    function ol(e, t) {
+    function Vo(e, t) {
         for (let n = 0; n < e.length; n += 1) e[n] && e[n].d(t)
     }
 
-    function K(e) {
+    function J(e) {
         return document.createElement(e)
     }
 
-    function Qe(e) {
+    function Je(e) {
         return document.createTextNode(e)
     }
 
-    function Se() {
-        return Qe(" ")
+    function Ee() {
+        return Je(" ")
     }
 
-    function $l() {
-        return Qe("")
+    function bl() {
+        return Je("")
     }
 
-    function Ot(e, t, n, i) {
+    function wt(e, t, n, i) {
         return e.addEventListener(t, n, i), () => e.removeEventListener(t, n, i)
     }
 
-    function B(e, t, n) {
+    function j(e, t, n) {
         n == null ? e.removeAttribute(t) : e.getAttribute(t) !== n && e.setAttribute(t, n)
     }
 
-    function PC(e) {
+    function VC(e) {
         return e === "" ? null : +e
     }
 
-    function F8(e) {
+    function z8(e) {
         return Array.from(e.childNodes)
     }
 
-    function Pt(e, t) {
+    function Ot(e, t) {
         t = "" + t, e.data !== t && (e.data = t)
     }
 
-    function ng(e, t) {
+    function jd(e, t) {
         e.value = t ?? ""
     }
 
-    function NC(e, t, n, i) {
-        n === null ? e.style.removeProperty(t) : e.style.setProperty(t, n, i ? "important" : "")
+    function KC(e, t, n, i) {
+        n == null ? e.style.removeProperty(t) : e.style.setProperty(t, n, i ? "important" : "")
     }
 
-    function D8(e, t, {
+    function B8(e, t, {
         bubbles: n = !1,
         cancelable: i = !1
     } = {}) {
         const r = document.createEvent("CustomEvent");
         return r.initCustomEvent(e, n, i, t), r
     }
 
-    function LC(e, t) {
+    function JC(e, t) {
         return new e(t)
     }
-    let Eh;
+    let hh;
 
-    function rh(e) {
-        Eh = e
+    function Hf(e) {
+        hh = e
     }
 
-    function sd() {
-        if (!Eh) throw new Error("Function called outside component initialization");
-        return Eh
+    function Xh() {
+        if (!hh) throw new Error("Function called outside component initialization");
+        return hh
     }
 
-    function R8(e) {
-        sd().$$.before_update.push(e)
+    function j8(e) {
+        Xh().$$.before_update.push(e)
     }
 
-    function bm(e) {
-        sd().$$.on_mount.push(e)
+    function Z0(e) {
+        Xh().$$.on_mount.push(e)
     }
 
-    function P8(e) {
-        sd().$$.after_update.push(e)
+    function U8(e) {
+        Xh().$$.after_update.push(e)
     }
 
-    function N8(e) {
-        sd().$$.on_destroy.push(e)
+    function G8(e) {
+        Xh().$$.on_destroy.push(e)
     }
 
-    function Sc() {
-        const e = sd();
+    function fc() {
+        const e = Xh();
         return (t, n, {
             cancelable: i = !1
         } = {}) => {
             const r = e.$$.callbacks[t];
             if (r) {
-                const a = D8(t, n, {
+                const s = B8(t, n, {
                     cancelable: i
                 });
-                return r.slice().forEach(s => {
-                    s.call(e, a)
-                }), !a.defaultPrevented
+                return r.slice().forEach(a => {
+                    a.call(e, s)
+                }), !s.defaultPrevented
             }
             return !0
         }
     }
 
-    function IC(e, t) {
+    function QC(e, t) {
         const n = e.$$.callbacks[t.type];
         n && n.slice().forEach(i => i.call(this, t))
     }
-    const mu = [],
-        Rp = [];
-    let ku = [];
-    const mb = [],
-        L8 = Promise.resolve();
-    let yb = !1;
+    const su = [],
+        pp = [];
+    let mu = [];
+    const Wv = [],
+        W8 = Promise.resolve();
+    let qv = !1;
 
-    function I8() {
-        yb || (yb = !0, L8.then(gM))
+    function q8() {
+        qv || (qv = !0, W8.then(CM))
     }
 
-    function vb(e) {
-        ku.push(e)
+    function Hv(e) {
+        mu.push(e)
     }
 
-    function j8(e) {
-        mb.push(e)
+    function H8(e) {
+        Wv.push(e)
     }
-    const Ty = new Set;
-    let Ql = 0;
+    const oy = new Set;
+    let jl = 0;
 
-    function gM() {
-        if (Ql !== 0) return;
-        const e = Eh;
+    function CM() {
+        if (jl !== 0) return;
+        const e = hh;
         do {
             try {
-                for (; Ql < mu.length;) {
-                    const t = mu[Ql];
-                    Ql++, rh(t), z8(t.$$)
+                for (; jl < su.length;) {
+                    const t = su[jl];
+                    jl++, Hf(t), Y8(t.$$)
                 }
             } catch (t) {
-                throw mu.length = 0, Ql = 0, t
+                throw su.length = 0, jl = 0, t
             }
-            for (rh(null), mu.length = 0, Ql = 0; Rp.length;) Rp.pop()();
-            for (let t = 0; t < ku.length; t += 1) {
-                const n = ku[t];
-                Ty.has(n) || (Ty.add(n), n())
-            }
-            ku.length = 0
-        } while (mu.length);
-        for (; mb.length;) mb.pop()();
-        yb = !1, Ty.clear(), rh(e)
+            for (Hf(null), su.length = 0, jl = 0; pp.length;) pp.pop()();
+            for (let t = 0; t < mu.length; t += 1) {
+                const n = mu[t];
+                oy.has(n) || (oy.add(n), n())
+            }
+            mu.length = 0
+        } while (su.length);
+        for (; Wv.length;) Wv.pop()();
+        qv = !1, oy.clear(), Hf(e)
     }
 
-    function z8(e) {
+    function Y8(e) {
         if (e.fragment !== null) {
-            e.update(), Ka(e.before_update);
+            e.update(), js(e.before_update);
             const t = e.dirty;
-            e.dirty = [-1], e.fragment && e.fragment.p(e.ctx, t), e.after_update.forEach(vb)
+            e.dirty = [-1], e.fragment && e.fragment.p(e.ctx, t), e.after_update.forEach(Hv)
         }
     }
 
-    function B8(e) {
+    function X8(e) {
         const t = [],
             n = [];
-        ku.forEach(i => e.indexOf(i) === -1 ? t.push(i) : n.push(i)), n.forEach(i => i()), ku = t
+        mu.forEach(i => e.indexOf(i) === -1 ? t.push(i) : n.push(i)), n.forEach(i => i()), mu = t
     }
-    const rp = new Set;
-    let Wo;
+    const Bg = new Set;
+    let Ro;
 
-    function yr() {
-        Wo = {
+    function ur() {
+        Ro = {
             r: 0,
             c: [],
-            p: Wo
+            p: Ro
         }
     }
 
-    function vr() {
-        Wo.r || Ka(Wo.c), Wo = Wo.p
+    function cr() {
+        Ro.r || js(Ro.c), Ro = Ro.p
     }
 
     function Te(e, t) {
-        e && e.i && (rp.delete(e), e.i(t))
+        e && e.i && (Bg.delete(e), e.i(t))
     }
 
-    function ze(e, t, n, i) {
+    function Ie(e, t, n, i) {
         if (e && e.o) {
-            if (rp.has(e)) return;
-            rp.add(e), Wo.c.push(() => {
-                rp.delete(e), i && (n && e.d(1), i())
+            if (Bg.has(e)) return;
+            Bg.add(e), Ro.c.push(() => {
+                Bg.delete(e), i && (n && e.d(1), i())
             }), e.o(t)
         } else i && i()
     }
 
-    function G8(e, t, n) {
+    function V8(e, t, n) {
         const i = e.$$.props[t];
         i !== void 0 && (e.$$.bound[i] = n, n(e.$$.ctx[i]))
     }
 
-    function ni(e) {
+    function ei(e) {
         e && e.c()
     }
 
-    function In(e, t, n, i) {
+    function Nn(e, t, n, i) {
         const {
             fragment: r,
-            after_update: a
+            after_update: s
         } = e.$$;
-        r && r.m(t, n), i || vb(() => {
-            const s = e.$$.on_mount.map(hM).filter(dM);
-            e.$$.on_destroy ? e.$$.on_destroy.push(...s) : Ka(s), e.$$.on_mount = []
-        }), a.forEach(vb)
+        r && r.m(t, n), i || Hv(() => {
+            const a = e.$$.on_mount.map(SM).filter(EM);
+            e.$$.on_destroy ? e.$$.on_destroy.push(...a) : js(a), e.$$.on_mount = []
+        }), s.forEach(Hv)
     }
 
-    function jn(e, t) {
+    function Pn(e, t) {
         const n = e.$$;
-        n.fragment !== null && (B8(n.after_update), Ka(n.on_destroy), n.fragment && n.fragment.d(t), n.on_destroy = n.fragment = null, n.ctx = [])
+        n.fragment !== null && (X8(n.after_update), js(n.on_destroy), n.fragment && n.fragment.d(t), n.on_destroy = n.fragment = null, n.ctx = [])
     }
 
-    function U8(e, t) {
-        e.$$.dirty[0] === -1 && (mu.push(e), I8(), e.$$.dirty.fill(0)), e.$$.dirty[t / 31 | 0] |= 1 << t % 31
+    function K8(e, t) {
+        e.$$.dirty[0] === -1 && (su.push(e), q8(), e.$$.dirty.fill(0)), e.$$.dirty[t / 31 | 0] |= 1 << t % 31
     }
 
-    function On(e, t, n, i, r, a, s, o = [-1]) {
-        const l = Eh;
-        rh(e);
+    function _n(e, t, n, i, r, s, a, o = [-1]) {
+        const l = hh;
+        Hf(e);
         const u = e.$$ = {
             fragment: null,
             ctx: [],
-            props: a,
-            update: Ke,
+            props: s,
+            update: Ve,
             not_equal: r,
-            bound: RC(),
+            bound: XC(),
             on_mount: [],
             on_destroy: [],
             on_disconnect: [],
             before_update: [],
             after_update: [],
             context: new Map(t.context || (l ? l.$$.context : [])),
-            callbacks: RC(),
+            callbacks: XC(),
             dirty: o,
             skip_bound: !1,
             root: t.target || l.$$.root
         };
-        s && s(u.root);
+        a && a(u.root);
         let c = !1;
         if (u.ctx = n ? n(e, t.props || {}, (f, h, ...d) => {
                 const g = d.length ? d[0] : h;
-                return u.ctx && r(u.ctx[f], u.ctx[f] = g) && (!u.skip_bound && u.bound[f] && u.bound[f](g), c && U8(e, f)), h
-            }) : [], u.update(), c = !0, Ka(u.before_update), u.fragment = i ? i(u.ctx) : !1, t.target) {
+                return u.ctx && r(u.ctx[f], u.ctx[f] = g) && (!u.skip_bound && u.bound[f] && u.bound[f](g), c && K8(e, f)), h
+            }) : [], u.update(), c = !0, js(u.before_update), u.fragment = i ? i(u.ctx) : !1, t.target) {
             if (t.hydrate) {
-                const f = F8(t.target);
-                u.fragment && u.fragment.l(f), f.forEach(xe)
+                const f = z8(t.target);
+                u.fragment && u.fragment.l(f), f.forEach(_e)
             } else u.fragment && u.fragment.c();
-            t.intro && Te(e.$$.fragment), In(e, t.target, t.anchor, t.customElement), gM()
+            t.intro && Te(e.$$.fragment), Nn(e, t.target, t.anchor, t.customElement), CM()
         }
-        rh(l)
+        Hf(l)
     }
-    class Cn {
+    class wn {
         $destroy() {
-            jn(this, 1), this.$destroy = Ke
+            Pn(this, 1), this.$destroy = Ve
         }
         $on(t, n) {
-            if (!dM(n)) return Ke;
+            if (!EM(n)) return Ve;
             const i = this.$$.callbacks[t] || (this.$$.callbacks[t] = []);
             return i.push(n), () => {
                 const r = i.indexOf(n);
                 r !== -1 && i.splice(r, 1)
             }
         }
         $set(t) {
-            this.$$set && !M8(t) && (this.$$.skip_bound = !0, this.$$set(t), this.$$.skip_bound = !1)
+            this.$$set && !I8(t) && (this.$$.skip_bound = !0, this.$$set(t), this.$$.skip_bound = !1)
         }
     }
-    const Zl = [];
+    const Ul = [];
 
-    function q8(e, t = Ke) {
+    function J8(e, t = Ve) {
         let n;
         const i = new Set;
 
         function r(o) {
-            if (rn(e, o) && (e = o, n)) {
-                const l = !Zl.length;
-                for (const u of i) u[1](), Zl.push(u, e);
+            if (tn(e, o) && (e = o, n)) {
+                const l = !Ul.length;
+                for (const u of i) u[1](), Ul.push(u, e);
                 if (l) {
-                    for (let u = 0; u < Zl.length; u += 2) Zl[u][0](Zl[u + 1]);
-                    Zl.length = 0
+                    for (let u = 0; u < Ul.length; u += 2) Ul[u][0](Ul[u + 1]);
+                    Ul.length = 0
                 }
             }
         }
 
-        function a(o) {
+        function s(o) {
             r(o(e))
         }
 
-        function s(o, l = Ke) {
+        function a(o, l = Ve) {
             const u = [o, l];
-            return i.add(u), i.size === 1 && (n = t(r) || Ke), o(e), () => {
+            return i.add(u), i.size === 1 && (n = t(r) || Ve), o(e), () => {
                 i.delete(u), i.size === 0 && n && (n(), n = null)
             }
         }
         return {
             set: r,
-            update: a,
-            subscribe: s
+            update: s,
+            subscribe: a
         }
     }
     /**
     @copyright CEA-LIST/DIASI/SIALV/LVA (2023)
     @author CEA-LIST/DIASI/SIALV/LVA <pixano@cea.fr>
     @license CECILL-C
 
@@ -387,194 +387,194 @@
     This software is governed by the CeCILL-C license under French law and
     abiding by the rules of distribution of free software. You can use, 
     modify and/ or redistribute the software under the terms of the CeCILL-C
     license as circulated by CEA, CNRS and INRIA at the following URL
 
     http://www.cecill.info
     */
-    const ap = q8(1),
-        W8 = "/assets/pixano-354ac9df.png";
+    const jg = J8(1),
+        Q8 = "/assets/pixano-354ac9df.png";
 
-    function H8(e) {
+    function Z8(e) {
         let t, n, i, r = e[0].name + "",
-            a, s, o, l = e[0].num_elements + "",
+            s, a, o, l = e[0].num_elements + "",
             u, c, f, h, d, g, p, m, y, v, b, x;
         return {
             c() {
-                t = K("div"), n = K("div"), i = K("h3"), a = Qe(r), s = Se(), o = K("p"), u = Qe(l), c = Qe(" elements"), f = Se(), h = K("div"), d = K("img"), m = Se(), y = K("div"), v = K("button"), v.textContent = "Explore", B(i, "class", "text-lg font-medium text-zinc-900 dark:text-zinc-300"), B(o, "class", "text-sm text-zinc-500"), B(n, "class", "h-1/5 px-4 flex flex-col justify-center"), Sh(d.src, g = e[0].preview) || B(d, "src", g), B(d, "alt", p = e[0].name), B(d, "class", "h-full w-full object-cover object-center"), B(h, "class", "h-3/5 border-t border-b border-zinc-200 dark:border-zinc-700"), B(v, "class", "py-2 px-3 bg-rose-500 text-zinc-50 font-medium rounded-md border-2 border-rose-500 transition-all hover:text-rose-600 hover:bg-zinc-50 dark:bg-rose-800 dark:border-rose-800 dark:hover:text-rose-700 dark:hover:bg-zinc-800"), B(y, "class", "h-1/5 px-4 flex flex-col justify-center items-end text-sm"), B(t, "class", "w-64 h-80 m-4 flex flex-col bg-zinc-50 text-zinc-900 border border-zinc-300 rounded-md cursor-pointer transition-all hover:scale-[102.5%] dark:bg-zinc-800 dark:text-zinc-50 dark:border-zinc-700")
+                t = J("div"), n = J("div"), i = J("h3"), s = Je(r), a = Ee(), o = J("p"), u = Je(l), c = Je(" elements"), f = Ee(), h = J("div"), d = J("img"), m = Ee(), y = J("div"), v = J("button"), v.textContent = "Explore", j(i, "class", "text-lg font-medium text-zinc-900 dark:text-zinc-300"), j(o, "class", "text-sm text-zinc-500"), j(n, "class", "h-1/5 px-4 flex flex-col justify-center"), fh(d.src, g = e[0].preview) || j(d, "src", g), j(d, "alt", p = e[0].name), j(d, "class", "h-full w-full object-cover object-center"), j(h, "class", "h-3/5 border-t border-b border-zinc-200 dark:border-zinc-700"), j(v, "class", "py-2 px-3 bg-rose-500 text-zinc-50 font-medium rounded-md border-2 border-rose-500 transition-all hover:text-rose-600 hover:bg-zinc-50 dark:bg-rose-800 dark:border-rose-800 dark:hover:text-rose-700 dark:hover:bg-zinc-800"), j(y, "class", "h-1/5 px-4 flex flex-col justify-center items-end text-sm"), j(t, "class", "w-64 h-80 m-4 flex flex-col bg-zinc-50 text-zinc-900 border border-zinc-300 rounded-md cursor-pointer transition-all hover:scale-[102.5%] dark:bg-zinc-800 dark:text-zinc-50 dark:border-zinc-700")
             },
             m(_, S) {
-                _e(_, t, S), U(t, n), U(n, i), U(i, a), U(n, s), U(n, o), U(o, u), U(o, c), U(t, f), U(t, h), U(h, d), U(t, m), U(t, y), U(y, v), b || (x = [Ot(v, "click", e[1]), Ot(t, "click", e[1])], b = !0)
+                we(_, t, S), G(t, n), G(n, i), G(i, s), G(n, a), G(n, o), G(o, u), G(o, c), G(t, f), G(t, h), G(h, d), G(t, m), G(t, y), G(y, v), b || (x = [wt(v, "click", e[1]), wt(t, "click", e[1])], b = !0)
             },
             p(_, [S]) {
-                S & 1 && r !== (r = _[0].name + "") && Pt(a, r), S & 1 && l !== (l = _[0].num_elements + "") && Pt(u, l), S & 1 && !Sh(d.src, g = _[0].preview) && B(d, "src", g), S & 1 && p !== (p = _[0].name) && B(d, "alt", p)
+                S & 1 && r !== (r = _[0].name + "") && Ot(s, r), S & 1 && l !== (l = _[0].num_elements + "") && Ot(u, l), S & 1 && !fh(d.src, g = _[0].preview) && j(d, "src", g), S & 1 && p !== (p = _[0].name) && j(d, "alt", p)
             },
-            i: Ke,
-            o: Ke,
+            i: Ve,
+            o: Ve,
             d(_) {
-                _ && xe(t), b = !1, Ka(x)
+                _ && _e(t), b = !1, js(x)
             }
         }
     }
 
-    function Y8(e, t, n) {
+    function e9(e, t, n) {
         let {
             dataset: i
         } = t;
-        const r = Sc();
+        const r = fc();
 
-        function a() {
+        function s() {
             r("click")
         }
-        return e.$$set = s => {
-            "dataset" in s && n(0, i = s.dataset)
-        }, [i, a]
+        return e.$$set = a => {
+            "dataset" in a && n(0, i = a.dataset)
+        }, [i, s]
     }
-    class X8 extends Cn {
+    class t9 extends wn {
         constructor(t) {
-            super(), On(this, t, Y8, H8, rn, {
+            super(), _n(this, t, e9, Z8, tn, {
                 dataset: 0
             })
         }
     }
 
-    function jC(e, t, n) {
+    function ZC(e, t, n) {
         const i = e.slice();
         return i[4] = t[n], i
     }
 
-    function zC(e) {
+    function ek(e) {
         let t, n;
 
         function i() {
             return e[2](e[4])
         }
-        return t = new X8({
+        return t = new t9({
             props: {
                 dataset: e[4]
             }
         }), t.$on("click", i), {
             c() {
-                ni(t.$$.fragment)
+                ei(t.$$.fragment)
             },
-            m(r, a) {
-                In(t, r, a), n = !0
+            m(r, s) {
+                Nn(t, r, s), n = !0
             },
-            p(r, a) {
+            p(r, s) {
                 e = r;
-                const s = {};
-                a & 1 && (s.dataset = e[4]), t.$set(s)
+                const a = {};
+                s & 1 && (a.dataset = e[4]), t.$set(a)
             },
             i(r) {
                 n || (Te(t.$$.fragment, r), n = !0)
             },
             o(r) {
-                ze(t.$$.fragment, r), n = !1
+                Ie(t.$$.fragment, r), n = !1
             },
             d(r) {
-                jn(t, r)
+                Pn(t, r)
             }
         }
     }
 
-    function V8(e) {
+    function n9(e) {
         let t, n, i, r = e[0],
-            a = [];
-        for (let o = 0; o < r.length; o += 1) a[o] = zC(jC(e, r, o));
-        const s = o => ze(a[o], 1, 1, () => {
-            a[o] = null
+            s = [];
+        for (let o = 0; o < r.length; o += 1) s[o] = ek(ZC(e, r, o));
+        const a = o => Ie(s[o], 1, 1, () => {
+            s[o] = null
         });
         return {
             c() {
-                t = K("div"), n = K("div");
-                for (let o = 0; o < a.length; o += 1) a[o].c();
-                B(n, "class", "grid grid-cols-6 gap-4"), B(t, "class", "mx-auto px-8")
+                t = J("div"), n = J("div");
+                for (let o = 0; o < s.length; o += 1) s[o].c();
+                j(n, "class", "grid grid-cols-6 gap-4"), j(t, "class", "mx-auto px-8")
             },
             m(o, l) {
-                _e(o, t, l), U(t, n);
-                for (let u = 0; u < a.length; u += 1) a[u] && a[u].m(n, null);
+                we(o, t, l), G(t, n);
+                for (let u = 0; u < s.length; u += 1) s[u] && s[u].m(n, null);
                 i = !0
             },
             p(o, [l]) {
                 if (l & 3) {
                     r = o[0];
                     let u;
                     for (u = 0; u < r.length; u += 1) {
-                        const c = jC(o, r, u);
-                        a[u] ? (a[u].p(c, l), Te(a[u], 1)) : (a[u] = zC(c), a[u].c(), Te(a[u], 1), a[u].m(n, null))
+                        const c = ZC(o, r, u);
+                        s[u] ? (s[u].p(c, l), Te(s[u], 1)) : (s[u] = ek(c), s[u].c(), Te(s[u], 1), s[u].m(n, null))
                     }
-                    for (yr(), u = r.length; u < a.length; u += 1) s(u);
-                    vr()
+                    for (ur(), u = r.length; u < s.length; u += 1) a(u);
+                    cr()
                 }
             },
             i(o) {
                 if (!i) {
-                    for (let l = 0; l < r.length; l += 1) Te(a[l]);
+                    for (let l = 0; l < r.length; l += 1) Te(s[l]);
                     i = !0
                 }
             },
             o(o) {
-                a = a.filter(Boolean);
-                for (let l = 0; l < a.length; l += 1) ze(a[l]);
+                s = s.filter(Boolean);
+                for (let l = 0; l < s.length; l += 1) Ie(s[l]);
                 i = !1
             },
             d(o) {
-                o && xe(t), ol(a, o)
+                o && _e(t), Vo(s, o)
             }
         }
     }
 
-    function K8(e, t, n) {
+    function i9(e, t, n) {
         let {
             datasets: i
         } = t;
-        const r = Sc();
+        const r = fc();
 
-        function a(o) {
+        function s(o) {
             r("datasetclick", {
                 dataset: o
             })
         }
-        const s = o => a(o);
+        const a = o => s(o);
         return e.$$set = o => {
             "datasets" in o && n(0, i = o.datasets)
-        }, [i, a, s]
+        }, [i, s, a]
     }
-    class J8 extends Cn {
+    class r9 extends wn {
         constructor(t) {
-            super(), On(this, t, K8, V8, rn, {
+            super(), _n(this, t, i9, n9, tn, {
                 datasets: 0
             })
         }
     }
 
-    function Q8(e) {
+    function s9(e) {
         let t, n, i;
         return {
             c() {
-                t = K("div"), t.textContent = "Loading datasets...", n = Se(), i = K("div"), i.innerHTML = `<div class="animate-pulse flex space-x-4"><div class="rounded-full bg-slate-200 h-10 w-10"></div> 
+                t = J("div"), t.textContent = "Loading datasets...", n = Ee(), i = J("div"), i.innerHTML = `<div class="animate-pulse flex space-x-4"><div class="rounded-full bg-slate-200 h-10 w-10"></div> 
     <div class="flex-1 space-y-6 py-1"><div class="h-2 bg-slate-200 rounded"></div> 
       <div class="space-y-3"><div class="grid grid-cols-3 gap-4"><div class="h-2 bg-slate-200 rounded col-span-2"></div> 
           <div class="h-2 bg-slate-200 rounded col-span-1"></div></div> 
-        <div class="h-2 bg-slate-200 rounded"></div></div></div></div>`, B(t, "class", "mt-4 flex w-full justify-center font-bold italic text-zinc-500"), B(i, "class", "mt-8 mx-auto border border-zinc-100 shadow rounded-md p-4 max-w-sm w-full dark:border-zinc-700")
+        <div class="h-2 bg-slate-200 rounded"></div></div></div></div>`, j(t, "class", "mt-4 flex w-full justify-center font-bold italic text-zinc-500"), j(i, "class", "mt-8 mx-auto border border-zinc-100 shadow rounded-md p-4 max-w-sm w-full dark:border-zinc-700")
             },
-            m(r, a) {
-                _e(r, t, a), _e(r, n, a), _e(r, i, a)
+            m(r, s) {
+                we(r, t, s), we(r, n, s), we(r, i, s)
             },
-            p: Ke,
-            i: Ke,
-            o: Ke,
+            p: Ve,
+            i: Ve,
+            o: Ve,
             d(r) {
-                r && xe(t), r && xe(n), r && xe(i)
+                r && _e(t), r && _e(n), r && _e(i)
             }
         }
     }
-    class Z8 extends Cn {
+    class a9 extends wn {
         constructor(t) {
-            super(), On(this, t, null, Q8, rn, {})
+            super(), _n(this, t, null, s9, tn, {})
         }
     }
     /**
     @copyright CEA-LIST/DIASI/SIALV/LVA (2023)
     @author CEA-LIST/DIASI/SIALV/LVA <pixano@cea.fr>
     @license CECILL-C
 
@@ -583,64 +583,64 @@
     This software is governed by the CeCILL-C license under French law and
     abiding by the rules of distribution of free software. You can use, 
     modify and/ or redistribute the software under the terms of the CeCILL-C
     license as circulated by CEA, CNRS and INRIA at the following URL
 
     http://www.cecill.info
     */
-    async function e9() {
+    async function o9() {
         let e = null;
         try {
             e = await (await fetch("/datasets")).json()
         } catch (t) {
             console.log(t)
         }
         return e
     }
-    async function $y(e, t = 1, n = 100) {
+    async function ly(e, t = 1, n = 100) {
         let i = null;
         try {
             i = await (await fetch(`/datasets/${e}/items?page=${t}&size=${n}`)).json()
         } catch (r) {
             console.log(r)
         }
         return i
     }
-    async function t9(e) {
+    async function l9(e) {
         let t = null;
         try {
             t = await (await fetch(`/datasets/${e}/stats`)).json()
         } catch (n) {
             console.log(n)
         }
         return t
     }
-    async function n9(e, t) {
+    async function u9(e, t) {
         let n = null;
         try {
             n = await (await fetch(`/datasets/${e}/items/${t}`)).json()
         } catch (i) {
             console.log(i)
         }
         return n
     }
-    var i9 = Math.PI / 180;
+    var c9 = Math.PI / 180;
 
-    function r9() {
+    function f9() {
         return typeof window < "u" && ({}.toString.call(window) === "[object Window]" || {}.toString.call(window) === "[object global]")
     }
-    const Au = typeof global < "u" ? global : typeof window < "u" ? window : typeof WorkerGlobalScope < "u" ? self : {},
+    const yu = typeof global < "u" ? global : typeof window < "u" ? window : typeof WorkerGlobalScope < "u" ? self : {},
         le = {
-            _global: Au,
+            _global: yu,
             version: "8.4.3",
-            isBrowser: r9(),
+            isBrowser: f9(),
             isUnminified: /param/.test(function(e) {}.toString()),
             dblClickWindow: 400,
             getAngle(e) {
-                return le.angleDeg ? e * i9 : e
+                return le.angleDeg ? e * c9 : e
             },
             enableTrace: !1,
             pointerEventsEnabled: !0,
             autoDrawEnabled: !0,
             hitOnDragEnabled: !1,
             capturePointerEventsEnabled: !1,
             _mouseListenClick: !1,
@@ -660,32 +660,32 @@
             isDragging() {
                 return le.DD.isDragging
             },
             isDragReady() {
                 return !!le.DD.node
             },
             releaseCanvasOnDestroy: !0,
-            document: Au.document,
+            document: yu.document,
             _injectGlobal(e) {
-                Au.Konva = e
+                yu.Konva = e
             }
         },
-        mt = e => {
+        pt = e => {
             le[e.prototype.getClassName()] = e
         };
     le._injectGlobal(le);
-    let ir = class pM {
+    let Ki = class kM {
         constructor(t = [1, 0, 0, 1, 0, 0]) {
             this.dirty = !1, this.m = t && t.slice() || [1, 0, 0, 1, 0, 0]
         }
         reset() {
             this.m[0] = 1, this.m[1] = 0, this.m[2] = 0, this.m[3] = 1, this.m[4] = 0, this.m[5] = 0
         }
         copy() {
-            return new pM(this.m)
+            return new kM(this.m)
         }
         copyInto(t) {
             t.m[0] = this.m[0], t.m[1] = this.m[1], t.m[2] = this.m[2], t.m[3] = this.m[3], t.m[4] = this.m[4], t.m[5] = this.m[5]
         }
         point(t) {
             var n = this.m;
             return {
@@ -699,94 +699,94 @@
         scale(t, n) {
             return this.m[0] *= t, this.m[1] *= t, this.m[2] *= n, this.m[3] *= n, this
         }
         rotate(t) {
             var n = Math.cos(t),
                 i = Math.sin(t),
                 r = this.m[0] * n + this.m[2] * i,
-                a = this.m[1] * n + this.m[3] * i,
-                s = this.m[0] * -i + this.m[2] * n,
+                s = this.m[1] * n + this.m[3] * i,
+                a = this.m[0] * -i + this.m[2] * n,
                 o = this.m[1] * -i + this.m[3] * n;
-            return this.m[0] = r, this.m[1] = a, this.m[2] = s, this.m[3] = o, this
+            return this.m[0] = r, this.m[1] = s, this.m[2] = a, this.m[3] = o, this
         }
         getTranslation() {
             return {
                 x: this.m[4],
                 y: this.m[5]
             }
         }
         skew(t, n) {
             var i = this.m[0] + this.m[2] * n,
                 r = this.m[1] + this.m[3] * n,
-                a = this.m[2] + this.m[0] * t,
-                s = this.m[3] + this.m[1] * t;
-            return this.m[0] = i, this.m[1] = r, this.m[2] = a, this.m[3] = s, this
+                s = this.m[2] + this.m[0] * t,
+                a = this.m[3] + this.m[1] * t;
+            return this.m[0] = i, this.m[1] = r, this.m[2] = s, this.m[3] = a, this
         }
         multiply(t) {
             var n = this.m[0] * t.m[0] + this.m[2] * t.m[1],
                 i = this.m[1] * t.m[0] + this.m[3] * t.m[1],
                 r = this.m[0] * t.m[2] + this.m[2] * t.m[3],
-                a = this.m[1] * t.m[2] + this.m[3] * t.m[3],
-                s = this.m[0] * t.m[4] + this.m[2] * t.m[5] + this.m[4],
+                s = this.m[1] * t.m[2] + this.m[3] * t.m[3],
+                a = this.m[0] * t.m[4] + this.m[2] * t.m[5] + this.m[4],
                 o = this.m[1] * t.m[4] + this.m[3] * t.m[5] + this.m[5];
-            return this.m[0] = n, this.m[1] = i, this.m[2] = r, this.m[3] = a, this.m[4] = s, this.m[5] = o, this
+            return this.m[0] = n, this.m[1] = i, this.m[2] = r, this.m[3] = s, this.m[4] = a, this.m[5] = o, this
         }
         invert() {
             var t = 1 / (this.m[0] * this.m[3] - this.m[1] * this.m[2]),
                 n = this.m[3] * t,
                 i = -this.m[1] * t,
                 r = -this.m[2] * t,
-                a = this.m[0] * t,
-                s = t * (this.m[2] * this.m[5] - this.m[3] * this.m[4]),
+                s = this.m[0] * t,
+                a = t * (this.m[2] * this.m[5] - this.m[3] * this.m[4]),
                 o = t * (this.m[1] * this.m[4] - this.m[0] * this.m[5]);
-            return this.m[0] = n, this.m[1] = i, this.m[2] = r, this.m[3] = a, this.m[4] = s, this.m[5] = o, this
+            return this.m[0] = n, this.m[1] = i, this.m[2] = r, this.m[3] = s, this.m[4] = a, this.m[5] = o, this
         }
         getMatrix() {
             return this.m
         }
         decompose() {
             var t = this.m[0],
                 n = this.m[1],
                 i = this.m[2],
                 r = this.m[3],
-                a = this.m[4],
-                s = this.m[5],
+                s = this.m[4],
+                a = this.m[5],
                 o = t * r - n * i;
             let l = {
-                x: a,
-                y: s,
+                x: s,
+                y: a,
                 rotation: 0,
                 scaleX: 0,
                 scaleY: 0,
                 skewX: 0,
                 skewY: 0
             };
             if (t != 0 || n != 0) {
                 var u = Math.sqrt(t * t + n * n);
                 l.rotation = n > 0 ? Math.acos(t / u) : -Math.acos(t / u), l.scaleX = u, l.scaleY = o / u, l.skewX = (t * i + n * r) / o, l.skewY = 0
             } else if (i != 0 || r != 0) {
                 var c = Math.sqrt(i * i + r * r);
                 l.rotation = Math.PI / 2 - (r > 0 ? Math.acos(-i / c) : -Math.acos(i / c)), l.scaleX = o / c, l.scaleY = c, l.skewX = 0, l.skewY = (t * i + n * r) / o
             }
-            return l.rotation = R._getRotation(l.rotation), l
+            return l.rotation = D._getRotation(l.rotation), l
         }
     };
-    var a9 = "[object Array]",
-        s9 = "[object Number]",
-        o9 = "[object String]",
-        l9 = "[object Boolean]",
-        u9 = Math.PI / 180,
-        c9 = 180 / Math.PI,
-        My = "#",
-        f9 = "",
-        h9 = "0",
-        d9 = "Konva warning: ",
-        BC = "Konva error: ",
-        g9 = "rgb(",
-        Fy = {
+    var h9 = "[object Array]",
+        d9 = "[object Number]",
+        g9 = "[object String]",
+        p9 = "[object Boolean]",
+        m9 = Math.PI / 180,
+        y9 = 180 / Math.PI,
+        uy = "#",
+        v9 = "",
+        b9 = "0",
+        x9 = "Konva warning: ",
+        tk = "Konva error: ",
+        _9 = "rgb(",
+        cy = {
             aliceblue: [240, 248, 255],
             antiquewhite: [250, 235, 215],
             aqua: [0, 255, 255],
             aquamarine: [127, 255, 212],
             azure: [240, 255, 255],
             beige: [245, 245, 220],
             bisque: [255, 228, 196],
@@ -929,56 +929,56 @@
             violet: [238, 130, 238],
             wheat: [245, 222, 179],
             white: [255, 255, 255],
             whitesmoke: [245, 245, 245],
             yellow: [255, 255, 0],
             yellowgreen: [154, 205, 5]
         },
-        p9 = /rgb\((\d{1,3}),(\d{1,3}),(\d{1,3})\)/,
-        ig = [];
-    const m9 = typeof requestAnimationFrame < "u" && requestAnimationFrame || function(e) {
+        w9 = /rgb\((\d{1,3}),(\d{1,3}),(\d{1,3})\)/,
+        Ud = [];
+    const S9 = typeof requestAnimationFrame < "u" && requestAnimationFrame || function(e) {
             setTimeout(e, 60)
         },
-        R = {
+        D = {
             _isElement(e) {
                 return !!(e && e.nodeType == 1)
             },
             _isFunction(e) {
                 return !!(e && e.constructor && e.call && e.apply)
             },
             _isPlainObject(e) {
                 return !!e && e.constructor === Object
             },
             _isArray(e) {
-                return Object.prototype.toString.call(e) === a9
+                return Object.prototype.toString.call(e) === h9
             },
             _isNumber(e) {
-                return Object.prototype.toString.call(e) === s9 && !isNaN(e) && isFinite(e)
+                return Object.prototype.toString.call(e) === d9 && !isNaN(e) && isFinite(e)
             },
             _isString(e) {
-                return Object.prototype.toString.call(e) === o9
+                return Object.prototype.toString.call(e) === g9
             },
             _isBoolean(e) {
-                return Object.prototype.toString.call(e) === l9
+                return Object.prototype.toString.call(e) === p9
             },
             isObject(e) {
                 return e instanceof Object
             },
             isValidSelector(e) {
                 if (typeof e != "string") return !1;
                 var t = e[0];
                 return t === "#" || t === "." || t === t.toUpperCase()
             },
             _sign(e) {
                 return e === 0 || e > 0 ? 1 : -1
             },
             requestAnimFrame(e) {
-                ig.push(e), ig.length === 1 && m9(function() {
-                    const t = ig;
-                    ig = [], t.forEach(function(n) {
+                Ud.push(e), Ud.length === 1 && S9(function() {
+                    const t = Ud;
+                    Ud = [], t.forEach(function(n) {
                         n()
                     })
                 })
             },
             createCanvasElement() {
                 var e = document.createElement("canvas");
                 try {
@@ -991,56 +991,56 @@
             },
             _isInDocument(e) {
                 for (; e = e.parentNode;)
                     if (e == document) return !0;
                 return !1
             },
             _urlToImage(e, t) {
-                var n = R.createImageElement();
+                var n = D.createImageElement();
                 n.onload = function() {
                     t(n)
                 }, n.src = e
             },
             _rgbToHex(e, t, n) {
                 return ((1 << 24) + (e << 16) + (t << 8) + n).toString(16).slice(1)
             },
             _hexToRgb(e) {
-                e = e.replace(My, f9);
+                e = e.replace(uy, v9);
                 var t = parseInt(e, 16);
                 return {
                     r: t >> 16 & 255,
                     g: t >> 8 & 255,
                     b: t & 255
                 }
             },
             getRandomColor() {
-                for (var e = (Math.random() * 16777215 << 0).toString(16); e.length < 6;) e = h9 + e;
-                return My + e
+                for (var e = (Math.random() * 16777215 << 0).toString(16); e.length < 6;) e = b9 + e;
+                return uy + e
             },
             getRGB(e) {
                 var t;
-                return e in Fy ? (t = Fy[e], {
+                return e in cy ? (t = cy[e], {
                     r: t[0],
                     g: t[1],
                     b: t[2]
-                }) : e[0] === My ? this._hexToRgb(e.substring(1)) : e.substr(0, 4) === g9 ? (t = p9.exec(e.replace(/ /g, "")), {
+                }) : e[0] === uy ? this._hexToRgb(e.substring(1)) : e.substr(0, 4) === _9 ? (t = w9.exec(e.replace(/ /g, "")), {
                     r: parseInt(t[1], 10),
                     g: parseInt(t[2], 10),
                     b: parseInt(t[3], 10)
                 }) : {
                     r: 0,
                     g: 0,
                     b: 0
                 }
             },
             colorToRGBA(e) {
-                return e = e || "black", R._namedColorToRBA(e) || R._hex3ColorToRGBA(e) || R._hex4ColorToRGBA(e) || R._hex6ColorToRGBA(e) || R._hex8ColorToRGBA(e) || R._rgbColorToRGBA(e) || R._rgbaColorToRGBA(e) || R._hslColorToRGBA(e)
+                return e = e || "black", D._namedColorToRBA(e) || D._hex3ColorToRGBA(e) || D._hex4ColorToRGBA(e) || D._hex6ColorToRGBA(e) || D._hex8ColorToRGBA(e) || D._rgbColorToRGBA(e) || D._rgbaColorToRGBA(e) || D._hslColorToRGBA(e)
             },
             _namedColorToRBA(e) {
-                var t = Fy[e.toLowerCase()];
+                var t = cy[e.toLowerCase()];
                 return t ? {
                     r: t[0],
                     g: t[1],
                     b: t[2],
                     a: 1
                 } : null
             },
@@ -1098,26 +1098,26 @@
                     g: parseInt(e[2] + e[2], 16),
                     b: parseInt(e[3] + e[3], 16),
                     a: 1
                 }
             },
             _hslColorToRGBA(e) {
                 if (/hsl\((\d+),\s*([\d.]+)%,\s*([\d.]+)%\)/g.test(e)) {
-                    const [t, ...n] = /hsl\((\d+),\s*([\d.]+)%,\s*([\d.]+)%\)/g.exec(e), i = Number(n[0]) / 360, r = Number(n[1]) / 100, a = Number(n[2]) / 100;
-                    let s, o, l;
-                    if (r === 0) return l = a * 255, {
+                    const [t, ...n] = /hsl\((\d+),\s*([\d.]+)%,\s*([\d.]+)%\)/g.exec(e), i = Number(n[0]) / 360, r = Number(n[1]) / 100, s = Number(n[2]) / 100;
+                    let a, o, l;
+                    if (r === 0) return l = s * 255, {
                         r: Math.round(l),
                         g: Math.round(l),
                         b: Math.round(l),
                         a: 1
                     };
-                    a < .5 ? s = a * (1 + r) : s = a + r - a * r;
-                    const u = 2 * a - s,
+                    s < .5 ? a = s * (1 + r) : a = s + r - s * r;
+                    const u = 2 * s - a,
                         c = [0, 0, 0];
-                    for (let f = 0; f < 3; f++) o = i + 1 / 3 * -(f - 1), o < 0 && o++, o > 1 && o--, 6 * o < 1 ? l = u + (s - u) * 6 * o : 2 * o < 1 ? l = s : 3 * o < 2 ? l = u + (s - u) * (2 / 3 - o) * 6 : l = u, c[f] = l * 255;
+                    for (let f = 0; f < 3; f++) o = i + 1 / 3 * -(f - 1), o < 0 && o++, o > 1 && o--, 6 * o < 1 ? l = u + (a - u) * 6 * o : 2 * o < 1 ? l = a : 3 * o < 2 ? l = u + (a - u) * (2 / 3 - o) * 6 : l = u, c[f] = l * 255;
                     return {
                         r: Math.round(c[0]),
                         g: Math.round(c[1]),
                         b: Math.round(c[2]),
                         a: 1
                     }
                 }
@@ -1130,99 +1130,99 @@
                 for (var n in e) this._isPlainObject(e[n]) ? t[n] = this.cloneObject(e[n]) : this._isArray(e[n]) ? t[n] = this.cloneArray(e[n]) : t[n] = e[n];
                 return t
             },
             cloneArray(e) {
                 return e.slice(0)
             },
             degToRad(e) {
-                return e * u9
+                return e * m9
             },
             radToDeg(e) {
-                return e * c9
+                return e * y9
             },
             _degToRad(e) {
-                return R.warn("Util._degToRad is removed. Please use public Util.degToRad instead."), R.degToRad(e)
+                return D.warn("Util._degToRad is removed. Please use public Util.degToRad instead."), D.degToRad(e)
             },
             _radToDeg(e) {
-                return R.warn("Util._radToDeg is removed. Please use public Util.radToDeg instead."), R.radToDeg(e)
+                return D.warn("Util._radToDeg is removed. Please use public Util.radToDeg instead."), D.radToDeg(e)
             },
             _getRotation(e) {
-                return le.angleDeg ? R.radToDeg(e) : e
+                return le.angleDeg ? D.radToDeg(e) : e
             },
             _capitalize(e) {
                 return e.charAt(0).toUpperCase() + e.slice(1)
             },
             throw (e) {
-                throw new Error(BC + e)
+                throw new Error(tk + e)
             },
             error(e) {
-                console.error(BC + e)
+                console.error(tk + e)
             },
             warn(e) {
-                le.showWarnings && console.warn(d9 + e)
+                le.showWarnings && console.warn(x9 + e)
             },
             each(e, t) {
                 for (var n in e) t(n, e[n])
             },
             _inRange(e, t, n) {
                 return t <= e && e < n
             },
-            _getProjectionToSegment(e, t, n, i, r, a) {
-                var s, o, l, u = (e - n) * (e - n) + (t - i) * (t - i);
-                if (u == 0) s = e, o = t, l = (r - n) * (r - n) + (a - i) * (a - i);
+            _getProjectionToSegment(e, t, n, i, r, s) {
+                var a, o, l, u = (e - n) * (e - n) + (t - i) * (t - i);
+                if (u == 0) a = e, o = t, l = (r - n) * (r - n) + (s - i) * (s - i);
                 else {
-                    var c = ((r - e) * (n - e) + (a - t) * (i - t)) / u;
-                    c < 0 ? (s = e, o = t, l = (e - r) * (e - r) + (t - a) * (t - a)) : c > 1 ? (s = n, o = i, l = (n - r) * (n - r) + (i - a) * (i - a)) : (s = e + c * (n - e), o = t + c * (i - t), l = (s - r) * (s - r) + (o - a) * (o - a))
+                    var c = ((r - e) * (n - e) + (s - t) * (i - t)) / u;
+                    c < 0 ? (a = e, o = t, l = (e - r) * (e - r) + (t - s) * (t - s)) : c > 1 ? (a = n, o = i, l = (n - r) * (n - r) + (i - s) * (i - s)) : (a = e + c * (n - e), o = t + c * (i - t), l = (a - r) * (a - r) + (o - s) * (o - s))
                 }
-                return [s, o, l]
+                return [a, o, l]
             },
             _getProjectionToLine(e, t, n) {
-                var i = R.cloneObject(e),
+                var i = D.cloneObject(e),
                     r = Number.MAX_VALUE;
-                return t.forEach(function(a, s) {
-                    if (!(!n && s === t.length - 1)) {
-                        var o = t[(s + 1) % t.length],
-                            l = R._getProjectionToSegment(a.x, a.y, o.x, o.y, e.x, e.y),
+                return t.forEach(function(s, a) {
+                    if (!(!n && a === t.length - 1)) {
+                        var o = t[(a + 1) % t.length],
+                            l = D._getProjectionToSegment(s.x, s.y, o.x, o.y, e.x, e.y),
                             u = l[0],
                             c = l[1],
                             f = l[2];
                         f < r && (i.x = u, i.y = c, r = f)
                     }
                 }), i
             },
             _prepareArrayForTween(e, t, n) {
                 var i, r = [],
-                    a = [];
+                    s = [];
                 if (e.length > t.length) {
-                    var s = t;
-                    t = e, e = s
+                    var a = t;
+                    t = e, e = a
                 }
                 for (i = 0; i < e.length; i += 2) r.push({
                     x: e[i],
                     y: e[i + 1]
                 });
-                for (i = 0; i < t.length; i += 2) a.push({
+                for (i = 0; i < t.length; i += 2) s.push({
                     x: t[i],
                     y: t[i + 1]
                 });
                 var o = [];
-                return a.forEach(function(l) {
-                    var u = R._getProjectionToLine(l, r, n);
+                return s.forEach(function(l) {
+                    var u = D._getProjectionToLine(l, r, n);
                     o.push(u.x), o.push(u.y)
                 }), o
             },
             _prepareToStringify(e) {
                 var t;
                 e.visitedByCircularReferenceRemoval = !0;
                 for (var n in e)
                     if (e.hasOwnProperty(n) && e[n] && typeof e[n] == "object") {
-                        if (t = Object.getOwnPropertyDescriptor(e, n), e[n].visitedByCircularReferenceRemoval || R._isElement(e[n]))
+                        if (t = Object.getOwnPropertyDescriptor(e, n), e[n].visitedByCircularReferenceRemoval || D._isElement(e[n]))
                             if (t.configurable) delete e[n];
                             else return null;
-                        else if (R._prepareToStringify(e[n]) === null)
+                        else if (D._prepareToStringify(e[n]) === null)
                             if (t.configurable) delete e[n];
                             else return null
                     } return delete e.visitedByCircularReferenceRemoval, e
             },
             _assign(e, t) {
                 for (var n in t) e[n] = t[n];
                 return e
@@ -1233,188 +1233,188 @@
             releaseCanvas(...e) {
                 le.releaseCanvasOnDestroy && e.forEach(t => {
                     t.width = 0, t.height = 0
                 })
             },
             drawRoundedRectPath(e, t, n, i) {
                 let r = 0,
-                    a = 0,
                     s = 0,
+                    a = 0,
                     o = 0;
-                typeof i == "number" ? r = a = s = o = Math.min(i, t / 2, n / 2) : (r = Math.min(i[0] || 0, t / 2, n / 2), a = Math.min(i[1] || 0, t / 2, n / 2), o = Math.min(i[2] || 0, t / 2, n / 2), s = Math.min(i[3] || 0, t / 2, n / 2)), e.moveTo(r, 0), e.lineTo(t - a, 0), e.arc(t - a, a, a, Math.PI * 3 / 2, 0, !1), e.lineTo(t, n - o), e.arc(t - o, n - o, o, 0, Math.PI / 2, !1), e.lineTo(s, n), e.arc(s, n - s, s, Math.PI / 2, Math.PI, !1), e.lineTo(0, r), e.arc(r, r, r, Math.PI, Math.PI * 3 / 2, !1)
+                typeof i == "number" ? r = s = a = o = Math.min(i, t / 2, n / 2) : (r = Math.min(i[0] || 0, t / 2, n / 2), s = Math.min(i[1] || 0, t / 2, n / 2), o = Math.min(i[2] || 0, t / 2, n / 2), a = Math.min(i[3] || 0, t / 2, n / 2)), e.moveTo(r, 0), e.lineTo(t - s, 0), e.arc(t - s, s, s, Math.PI * 3 / 2, 0, !1), e.lineTo(t, n - o), e.arc(t - o, n - o, o, 0, Math.PI / 2, !1), e.lineTo(a, n), e.arc(a, n - a, a, Math.PI / 2, Math.PI, !1), e.lineTo(0, r), e.arc(r, r, r, Math.PI, Math.PI * 3 / 2, !1)
             }
         };
 
-    function io(e) {
-        return R._isString(e) ? '"' + e + '"' : Object.prototype.toString.call(e) === "[object Number]" || R._isBoolean(e) ? e : Object.prototype.toString.call(e)
+    function Ha(e) {
+        return D._isString(e) ? '"' + e + '"' : Object.prototype.toString.call(e) === "[object Number]" || D._isBoolean(e) ? e : Object.prototype.toString.call(e)
     }
 
-    function mM(e) {
+    function AM(e) {
         return e > 255 ? 255 : e < 0 ? 0 : Math.round(e)
     }
 
-    function ee() {
+    function te() {
         if (le.isUnminified) return function(e, t) {
-            return R._isNumber(e) || R.warn(io(e) + ' is a not valid value for "' + t + '" attribute. The value should be a number.'), e
+            return D._isNumber(e) || D.warn(Ha(e) + ' is a not valid value for "' + t + '" attribute. The value should be a number.'), e
         }
     }
 
-    function Kx(e) {
+    function px(e) {
         if (le.isUnminified) return function(t, n) {
-            let i = R._isNumber(t),
-                r = R._isArray(t) && t.length == e;
-            return !i && !r && R.warn(io(t) + ' is a not valid value for "' + n + '" attribute. The value should be a number or Array<number>(' + e + ")"), t
+            let i = D._isNumber(t),
+                r = D._isArray(t) && t.length == e;
+            return !i && !r && D.warn(Ha(t) + ' is a not valid value for "' + n + '" attribute. The value should be a number or Array<number>(' + e + ")"), t
         }
     }
 
-    function Jx() {
+    function mx() {
         if (le.isUnminified) return function(e, t) {
-            var n = R._isNumber(e),
+            var n = D._isNumber(e),
                 i = e === "auto";
-            return n || i || R.warn(io(e) + ' is a not valid value for "' + t + '" attribute. The value should be a number or "auto".'), e
+            return n || i || D.warn(Ha(e) + ' is a not valid value for "' + t + '" attribute. The value should be a number or "auto".'), e
         }
     }
 
-    function Ec() {
+    function hc() {
         if (le.isUnminified) return function(e, t) {
-            return R._isString(e) || R.warn(io(e) + ' is a not valid value for "' + t + '" attribute. The value should be a string.'), e
+            return D._isString(e) || D.warn(Ha(e) + ' is a not valid value for "' + t + '" attribute. The value should be a string.'), e
         }
     }
 
-    function yM() {
+    function $M() {
         if (le.isUnminified) return function(e, t) {
-            const n = R._isString(e),
+            const n = D._isString(e),
                 i = Object.prototype.toString.call(e) === "[object CanvasGradient]" || e && e.addColorStop;
-            return n || i || R.warn(io(e) + ' is a not valid value for "' + t + '" attribute. The value should be a string or a native gradient.'), e
+            return n || i || D.warn(Ha(e) + ' is a not valid value for "' + t + '" attribute. The value should be a string or a native gradient.'), e
         }
     }
 
-    function y9() {
+    function E9() {
         if (le.isUnminified) return function(e, t) {
             const n = Int8Array ? Object.getPrototypeOf(Int8Array) : null;
-            return n && e instanceof n || (R._isArray(e) ? e.forEach(function(i) {
-                R._isNumber(i) || R.warn('"' + t + '" attribute has non numeric element ' + i + ". Make sure that all elements are numbers.")
-            }) : R.warn(io(e) + ' is a not valid value for "' + t + '" attribute. The value should be a array of numbers.')), e
+            return n && e instanceof n || (D._isArray(e) ? e.forEach(function(i) {
+                D._isNumber(i) || D.warn('"' + t + '" attribute has non numeric element ' + i + ". Make sure that all elements are numbers.")
+            }) : D.warn(Ha(e) + ' is a not valid value for "' + t + '" attribute. The value should be a array of numbers.')), e
         }
     }
 
-    function Sr() {
+    function mr() {
         if (le.isUnminified) return function(e, t) {
             var n = e === !0 || e === !1;
-            return n || R.warn(io(e) + ' is a not valid value for "' + t + '" attribute. The value should be a boolean.'), e
+            return n || D.warn(Ha(e) + ' is a not valid value for "' + t + '" attribute. The value should be a boolean.'), e
         }
     }
 
-    function v9(e) {
+    function C9(e) {
         if (le.isUnminified) return function(t, n) {
-            return t == null || R.isObject(t) || R.warn(io(t) + ' is a not valid value for "' + n + '" attribute. The value should be an object with properties ' + e), t
+            return t == null || D.isObject(t) || D.warn(Ha(t) + ' is a not valid value for "' + n + '" attribute. The value should be an object with properties ' + e), t
         }
     }
-    var Zc = "get",
-        ef = "set";
-    const M = {
+    var Bc = "get",
+        jc = "set";
+    const O = {
         addGetterSetter(e, t, n, i, r) {
-            M.addGetter(e, t, n), M.addSetter(e, t, i, r), M.addOverloadedGetterSetter(e, t)
+            O.addGetter(e, t, n), O.addSetter(e, t, i, r), O.addOverloadedGetterSetter(e, t)
         },
         addGetter(e, t, n) {
-            var i = Zc + R._capitalize(t);
+            var i = Bc + D._capitalize(t);
             e.prototype[i] = e.prototype[i] || function() {
                 var r = this.attrs[t];
                 return r === void 0 ? n : r
             }
         },
         addSetter(e, t, n, i) {
-            var r = ef + R._capitalize(t);
-            e.prototype[r] || M.overWriteSetter(e, t, n, i)
+            var r = jc + D._capitalize(t);
+            e.prototype[r] || O.overWriteSetter(e, t, n, i)
         },
         overWriteSetter(e, t, n, i) {
-            var r = ef + R._capitalize(t);
-            e.prototype[r] = function(a) {
-                return n && a !== void 0 && a !== null && (a = n.call(this, a, t)), this._setAttr(t, a), i && i.call(this), this
+            var r = jc + D._capitalize(t);
+            e.prototype[r] = function(s) {
+                return n && s !== void 0 && s !== null && (s = n.call(this, s, t)), this._setAttr(t, s), i && i.call(this), this
             }
         },
         addComponentsGetterSetter(e, t, n, i, r) {
-            var a = n.length,
-                s = R._capitalize,
-                o = Zc + s(t),
-                l = ef + s(t),
+            var s = n.length,
+                a = D._capitalize,
+                o = Bc + a(t),
+                l = jc + a(t),
                 u, c;
             e.prototype[o] = function() {
                 var h = {};
-                for (u = 0; u < a; u++) c = n[u], h[c] = this.getAttr(t + s(c));
+                for (u = 0; u < s; u++) c = n[u], h[c] = this.getAttr(t + a(c));
                 return h
             };
-            var f = v9(n);
+            var f = C9(n);
             e.prototype[l] = function(h) {
                 var d = this.attrs[t],
                     g;
                 i && (h = i.call(this, h)), f && f.call(this, h, t);
-                for (g in h) h.hasOwnProperty(g) && this._setAttr(t + s(g), h[g]);
+                for (g in h) h.hasOwnProperty(g) && this._setAttr(t + a(g), h[g]);
                 return h || n.forEach(p => {
-                    this._setAttr(t + s(p), void 0)
+                    this._setAttr(t + a(p), void 0)
                 }), this._fireChangeEvent(t, d, h), r && r.call(this), this
-            }, M.addOverloadedGetterSetter(e, t)
+            }, O.addOverloadedGetterSetter(e, t)
         },
         addOverloadedGetterSetter(e, t) {
-            var n = R._capitalize(t),
-                i = ef + n,
-                r = Zc + n;
+            var n = D._capitalize(t),
+                i = jc + n,
+                r = Bc + n;
             e.prototype[t] = function() {
                 return arguments.length ? (this[i](arguments[0]), this) : this[r]()
             }
         },
         addDeprecatedGetterSetter(e, t, n, i) {
-            R.error("Adding deprecated " + t);
-            var r = Zc + R._capitalize(t),
-                a = t + " property is deprecated and will be removed soon. Look at Konva change log for more information.";
+            D.error("Adding deprecated " + t);
+            var r = Bc + D._capitalize(t),
+                s = t + " property is deprecated and will be removed soon. Look at Konva change log for more information.";
             e.prototype[r] = function() {
-                R.error(a);
-                var s = this.attrs[t];
-                return s === void 0 ? n : s
-            }, M.addSetter(e, t, i, function() {
-                R.error(a)
-            }), M.addOverloadedGetterSetter(e, t)
+                D.error(s);
+                var a = this.attrs[t];
+                return a === void 0 ? n : a
+            }, O.addSetter(e, t, i, function() {
+                D.error(s)
+            }), O.addOverloadedGetterSetter(e, t)
         },
         backCompat(e, t) {
-            R.each(t, function(n, i) {
+            D.each(t, function(n, i) {
                 var r = e.prototype[i],
-                    a = Zc + R._capitalize(n),
-                    s = ef + R._capitalize(n);
+                    s = Bc + D._capitalize(n),
+                    a = jc + D._capitalize(n);
 
                 function o() {
-                    r.apply(this, arguments), R.error('"' + n + '" method is deprecated and will be removed soon. Use ""' + i + '" instead.')
+                    r.apply(this, arguments), D.error('"' + n + '" method is deprecated and will be removed soon. Use ""' + i + '" instead.')
                 }
-                e.prototype[n] = o, e.prototype[a] = o, e.prototype[s] = o
+                e.prototype[n] = o, e.prototype[s] = o, e.prototype[a] = o
             })
         },
         afterSetFilter() {
             this._filterUpToDate = !1
         }
     };
 
-    function b9(e) {
+    function k9(e) {
         var t = [],
             n = e.length,
-            i = R,
-            r, a;
-        for (r = 0; r < n; r++) a = e[r], i._isNumber(a) ? a = Math.round(a * 1e3) / 1e3 : i._isString(a) || (a = a + ""), t.push(a);
+            i = D,
+            r, s;
+        for (r = 0; r < n; r++) s = e[r], i._isNumber(s) ? s = Math.round(s * 1e3) / 1e3 : i._isString(s) || (s = s + ""), t.push(s);
         return t
     }
-    var GC = ",",
-        x9 = "(",
-        _9 = ")",
-        w9 = "([",
-        S9 = "])",
-        E9 = ";",
-        O9 = "()",
-        C9 = "=",
-        UC = ["arc", "arcTo", "beginPath", "bezierCurveTo", "clearRect", "clip", "closePath", "createLinearGradient", "createPattern", "createRadialGradient", "drawImage", "ellipse", "fill", "fillText", "getImageData", "createImageData", "lineTo", "moveTo", "putImageData", "quadraticCurveTo", "rect", "restore", "rotate", "save", "scale", "setLineDash", "setTransform", "stroke", "strokeText", "transform", "translate"],
-        k9 = ["fillStyle", "strokeStyle", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY", "lineCap", "lineDashOffset", "lineJoin", "lineWidth", "miterLimit", "font", "textAlign", "textBaseline", "globalAlpha", "globalCompositeOperation", "imageSmoothingEnabled"];
-    const A9 = 100;
-    let xm = class {
+    var nk = ",",
+        A9 = "(",
+        $9 = ")",
+        T9 = "([",
+        M9 = "])",
+        O9 = ";",
+        F9 = "()",
+        R9 = "=",
+        ik = ["arc", "arcTo", "beginPath", "bezierCurveTo", "clearRect", "clip", "closePath", "createLinearGradient", "createPattern", "createRadialGradient", "drawImage", "ellipse", "fill", "fillText", "getImageData", "createImageData", "lineTo", "moveTo", "putImageData", "quadraticCurveTo", "rect", "restore", "rotate", "save", "scale", "setLineDash", "setTransform", "stroke", "strokeText", "transform", "translate"],
+        D9 = ["fillStyle", "strokeStyle", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY", "lineCap", "lineDashOffset", "lineJoin", "lineWidth", "miterLimit", "font", "textAlign", "textBaseline", "globalAlpha", "globalCompositeOperation", "imageSmoothingEnabled"];
+    const N9 = 100;
+    let em = class {
         constructor(t) {
             this.canvas = t, le.enableTrace && (this.traceArr = [], this._enableTrace())
         }
         fillShape(t) {
             t.fillEnabled() && this._fill(t)
         }
         _fill(t) {}
@@ -1424,26 +1424,26 @@
         _stroke(t) {}
         fillStrokeShape(t) {
             t.attrs.fillAfterStrokeEnabled ? (this.strokeShape(t), this.fillShape(t)) : (this.fillShape(t), this.strokeShape(t))
         }
         getTrace(t, n) {
             var i = this.traceArr,
                 r = i.length,
-                a = "",
-                s, o, l, u;
-            for (s = 0; s < r; s++) o = i[s], l = o.method, l ? (u = o.args, a += l, t ? a += O9 : R._isArray(u[0]) ? a += w9 + u.join(GC) + S9 : (n && (u = u.map(c => typeof c == "number" ? Math.floor(c) : c)), a += x9 + u.join(GC) + _9)) : (a += o.property, t || (a += C9 + o.val)), a += E9;
-            return a
+                s = "",
+                a, o, l, u;
+            for (a = 0; a < r; a++) o = i[a], l = o.method, l ? (u = o.args, s += l, t ? s += F9 : D._isArray(u[0]) ? s += T9 + u.join(nk) + M9 : (n && (u = u.map(c => typeof c == "number" ? Math.floor(c) : c)), s += A9 + u.join(nk) + $9)) : (s += o.property, t || (s += R9 + o.val)), s += O9;
+            return s
         }
         clearTrace() {
             this.traceArr = []
         }
         _trace(t) {
             var n = this.traceArr,
                 i;
-            n.push(t), i = n.length, i >= A9 && n.shift()
+            n.push(t), i = n.length, i >= N9 && n.shift()
         }
         reset() {
             var t = this.getCanvas().getPixelRatio();
             this.setTransform(1 * t, 0, 0, 1 * t, 0, 0)
         }
         getCanvas() {
             return this.canvas
@@ -1463,25 +1463,25 @@
         _applyLineJoin(t) {
             const n = t.attrs.lineJoin;
             n && this.setAttr("lineJoin", n)
         }
         setAttr(t, n) {
             this._context[t] = n
         }
-        arc(t, n, i, r, a, s) {
-            this._context.arc(t, n, i, r, a, s)
+        arc(t, n, i, r, s, a) {
+            this._context.arc(t, n, i, r, s, a)
         }
-        arcTo(t, n, i, r, a) {
-            this._context.arcTo(t, n, i, r, a)
+        arcTo(t, n, i, r, s) {
+            this._context.arcTo(t, n, i, r, s)
         }
         beginPath() {
             this._context.beginPath()
         }
-        bezierCurveTo(t, n, i, r, a, s) {
-            this._context.bezierCurveTo(t, n, i, r, a, s)
+        bezierCurveTo(t, n, i, r, s, a) {
+            this._context.bezierCurveTo(t, n, i, r, s, a)
         }
         clearRect(t, n, i, r) {
             this._context.clearRect(t, n, i, r)
         }
         clip() {
             this._context.clip()
         }
@@ -1495,24 +1495,24 @@
         }
         createLinearGradient(t, n, i, r) {
             return this._context.createLinearGradient(t, n, i, r)
         }
         createPattern(t, n) {
             return this._context.createPattern(t, n)
         }
-        createRadialGradient(t, n, i, r, a, s) {
-            return this._context.createRadialGradient(t, n, i, r, a, s)
+        createRadialGradient(t, n, i, r, s, a) {
+            return this._context.createRadialGradient(t, n, i, r, s, a)
         }
-        drawImage(t, n, i, r, a, s, o, l, u) {
+        drawImage(t, n, i, r, s, a, o, l, u) {
             var c = arguments,
                 f = this._context;
-            c.length === 3 ? f.drawImage(t, n, i) : c.length === 5 ? f.drawImage(t, n, i, r, a) : c.length === 9 && f.drawImage(t, n, i, r, a, s, o, l, u)
+            c.length === 3 ? f.drawImage(t, n, i) : c.length === 5 ? f.drawImage(t, n, i, r, s) : c.length === 9 && f.drawImage(t, n, i, r, s, a, o, l, u)
         }
-        ellipse(t, n, i, r, a, s, o, l) {
-            this._context.ellipse(t, n, i, r, a, s, o, l)
+        ellipse(t, n, i, r, s, a, o, l) {
+            this._context.ellipse(t, n, i, r, s, a, o, l)
         }
         isPointInPath(t, n, i, r) {
             return i ? this._context.isPointInPath(i, t, n, r) : this._context.isPointInPath(t, n, r)
         }
         fill(t) {
             t ? this._context.fill(t) : this._context.fill()
         }
@@ -1560,44 +1560,44 @@
         }
         setLineDash(t) {
             this._context.setLineDash ? this._context.setLineDash(t) : "mozDash" in this._context ? this._context.mozDash = t : "webkitLineDash" in this._context && (this._context.webkitLineDash = t)
         }
         getLineDash() {
             return this._context.getLineDash()
         }
-        setTransform(t, n, i, r, a, s) {
-            this._context.setTransform(t, n, i, r, a, s)
+        setTransform(t, n, i, r, s, a) {
+            this._context.setTransform(t, n, i, r, s, a)
         }
         stroke(t) {
             t ? this._context.stroke(t) : this._context.stroke()
         }
         strokeText(t, n, i, r) {
             this._context.strokeText(t, n, i, r)
         }
-        transform(t, n, i, r, a, s) {
-            this._context.transform(t, n, i, r, a, s)
+        transform(t, n, i, r, s, a) {
+            this._context.transform(t, n, i, r, s, a)
         }
         translate(t, n) {
             this._context.translate(t, n)
         }
         _enableTrace() {
             var t = this,
-                n = UC.length,
+                n = ik.length,
                 i = this.setAttr,
-                r, a, s = function(o) {
+                r, s, a = function(o) {
                     var l = t[o],
                         u;
                     t[o] = function() {
-                        return a = b9(Array.prototype.slice.call(arguments, 0)), u = l.apply(t, arguments), t._trace({
+                        return s = k9(Array.prototype.slice.call(arguments, 0)), u = l.apply(t, arguments), t._trace({
                             method: o,
-                            args: a
+                            args: s
                         }), u
                     }
                 };
-            for (r = 0; r < n; r++) s(UC[r]);
+            for (r = 0; r < n; r++) a(ik[r]);
             t.setAttr = function() {
                 i.apply(t, arguments);
                 var o = arguments[0],
                     l = arguments[1];
                 (o === "shadowOffsetX" || o === "shadowOffsetY" || o === "shadowBlur") && (l = l / this.canvas.getPixelRatio()), t._trace({
                     property: o,
                     val: l
@@ -1606,25 +1606,25 @@
         }
         _applyGlobalCompositeOperation(t) {
             const n = t.attrs.globalCompositeOperation;
             var i = !n || n === "source-over";
             i || this.setAttr("globalCompositeOperation", n)
         }
     };
-    k9.forEach(function(e) {
-        Object.defineProperty(xm.prototype, e, {
+    D9.forEach(function(e) {
+        Object.defineProperty(em.prototype, e, {
             get() {
                 return this._context[e]
             },
             set(t) {
                 this._context[e] = t
             }
         })
     });
-    class T9 extends xm {
+    class P9 extends em {
         constructor(t) {
             super(t), this._context = t._canvas.getContext("2d")
         }
         _fillColor(t) {
             var n = t.fill();
             this.setAttr("fillStyle", n), t._fillFunc(this)
         }
@@ -1647,109 +1647,109 @@
                 return
             }
             const r = t.getFillPatternImage();
             if (r && i === "pattern") {
                 this._fillPattern(t);
                 return
             }
-            const a = t.getFillLinearGradientColorStops();
-            if (a && i === "linear-gradient") {
+            const s = t.getFillLinearGradientColorStops();
+            if (s && i === "linear-gradient") {
                 this._fillLinearGradient(t);
                 return
             }
-            const s = t.getFillRadialGradientColorStops();
-            if (s && i === "radial-gradient") {
+            const a = t.getFillRadialGradientColorStops();
+            if (a && i === "radial-gradient") {
                 this._fillRadialGradient(t);
                 return
             }
-            n ? this._fillColor(t) : r ? this._fillPattern(t) : a ? this._fillLinearGradient(t) : s && this._fillRadialGradient(t)
+            n ? this._fillColor(t) : r ? this._fillPattern(t) : s ? this._fillLinearGradient(t) : a && this._fillRadialGradient(t)
         }
         _strokeLinearGradient(t) {
             const n = t.getStrokeLinearGradientStartPoint(),
                 i = t.getStrokeLinearGradientEndPoint(),
                 r = t.getStrokeLinearGradientColorStops(),
-                a = this.createLinearGradient(n.x, n.y, i.x, i.y);
+                s = this.createLinearGradient(n.x, n.y, i.x, i.y);
             if (r) {
-                for (var s = 0; s < r.length; s += 2) a.addColorStop(r[s], r[s + 1]);
-                this.setAttr("strokeStyle", a)
+                for (var a = 0; a < r.length; a += 2) s.addColorStop(r[a], r[a + 1]);
+                this.setAttr("strokeStyle", s)
             }
         }
         _stroke(t) {
             var n = t.dash(),
                 i = t.getStrokeScaleEnabled();
             if (t.hasStroke()) {
                 if (!i) {
                     this.save();
                     var r = this.getCanvas().getPixelRatio();
                     this.setTransform(r, 0, 0, r, 0, 0)
                 }
                 this._applyLineCap(t), n && t.dashEnabled() && (this.setLineDash(n), this.setAttr("lineDashOffset", t.dashOffset())), this.setAttr("lineWidth", t.strokeWidth()), t.getShadowForStrokeEnabled() || this.setAttr("shadowColor", "rgba(0,0,0,0)");
-                var a = t.getStrokeLinearGradientColorStops();
-                a ? this._strokeLinearGradient(t) : this.setAttr("strokeStyle", t.stroke()), t._strokeFunc(this), i || this.restore()
+                var s = t.getStrokeLinearGradientColorStops();
+                s ? this._strokeLinearGradient(t) : this.setAttr("strokeStyle", t.stroke()), t._strokeFunc(this), i || this.restore()
             }
         }
         _applyShadow(t) {
-            var n, i, r, a = (n = t.getShadowRGBA()) !== null && n !== void 0 ? n : "black",
-                s = (i = t.getShadowBlur()) !== null && i !== void 0 ? i : 5,
+            var n, i, r, s = (n = t.getShadowRGBA()) !== null && n !== void 0 ? n : "black",
+                a = (i = t.getShadowBlur()) !== null && i !== void 0 ? i : 5,
                 o = (r = t.getShadowOffset()) !== null && r !== void 0 ? r : {
                     x: 0,
                     y: 0
                 },
                 l = t.getAbsoluteScale(),
                 u = this.canvas.getPixelRatio(),
                 c = l.x * u,
                 f = l.y * u;
-            this.setAttr("shadowColor", a), this.setAttr("shadowBlur", s * Math.min(Math.abs(c), Math.abs(f))), this.setAttr("shadowOffsetX", o.x * c), this.setAttr("shadowOffsetY", o.y * f)
+            this.setAttr("shadowColor", s), this.setAttr("shadowBlur", a * Math.min(Math.abs(c), Math.abs(f))), this.setAttr("shadowOffsetX", o.x * c), this.setAttr("shadowOffsetY", o.y * f)
         }
     }
-    class $9 extends xm {
+    class L9 extends em {
         constructor(t) {
             super(t), this._context = t._canvas.getContext("2d", {
                 willReadFrequently: !0
             })
         }
         _fill(t) {
             this.save(), this.setAttr("fillStyle", t.colorKey), t._fillFuncHit(this), this.restore()
         }
         strokeShape(t) {
             t.hasHitStroke() && this._stroke(t)
         }
         _stroke(t) {
             if (t.hasHitStroke()) {
-                const a = t.getStrokeScaleEnabled();
-                if (!a) {
+                const s = t.getStrokeScaleEnabled();
+                if (!s) {
                     this.save();
                     var n = this.getCanvas().getPixelRatio();
                     this.setTransform(n, 0, 0, n, 0, 0)
                 }
                 this._applyLineCap(t);
                 var i = t.hitStrokeWidth(),
                     r = i === "auto" ? t.strokeWidth() : i;
-                this.setAttr("lineWidth", r), this.setAttr("strokeStyle", t.colorKey), t._strokeFuncHit(this), a || this.restore()
+                this.setAttr("lineWidth", r), this.setAttr("strokeStyle", t.colorKey), t._strokeFuncHit(this), s || this.restore()
             }
         }
     }
-    var rg;
+    var Gd;
 
-    function M9() {
-        if (rg) return rg;
-        var e = R.createCanvasElement(),
+    function I9() {
+        if (Gd) return Gd;
+        var e = D.createCanvasElement(),
             t = e.getContext("2d");
-        return rg = function() {
+        return Gd = function() {
             var n = le._global.devicePixelRatio || 1,
                 i = t.webkitBackingStorePixelRatio || t.mozBackingStorePixelRatio || t.msBackingStorePixelRatio || t.oBackingStorePixelRatio || t.backingStorePixelRatio || 1;
             return n / i
-        }(), R.releaseCanvas(e), rg
+        }(), D.releaseCanvas(e), Gd
     }
-    let _m = class {
+    let tm = class {
         constructor(t) {
             this.pixelRatio = 1, this.width = 0, this.height = 0, this.isCache = !1;
             var n = t || {},
-                i = n.pixelRatio || le.pixelRatio || M9();
-            this.pixelRatio = i, this._canvas = R.createCanvasElement(), this._canvas.style.padding = "0", this._canvas.style.margin = "0", this._canvas.style.border = "0", this._canvas.style.background = "transparent", this._canvas.style.position = "absolute", this._canvas.style.top = "0", this._canvas.style.left = "0"
+                i = n.pixelRatio || le.pixelRatio || I9();
+            this.pixelRatio = i, this._canvas = D.createCanvasElement(), this._canvas.style.padding = "0", this._canvas.style.margin = "0", this._canvas.style.border = "0", this._canvas.style.background = "transparent", this._canvas.style.position = "absolute", this._canvas.style.top = "0", this._canvas.style.left = "0"
         }
         getContext() {
             return this.context
         }
         getPixelRatio() {
             return this.pixelRatio
         }
@@ -1781,63 +1781,63 @@
         toDataURL(t, n) {
             try {
                 return this._canvas.toDataURL(t, n)
             } catch {
                 try {
                     return this._canvas.toDataURL()
                 } catch (r) {
-                    return R.error("Unable to get data URL. " + r.message + " For more info read https://konvajs.org/docs/posts/Tainted_Canvas.html."), ""
+                    return D.error("Unable to get data URL. " + r.message + " For more info read https://konvajs.org/docs/posts/Tainted_Canvas.html."), ""
                 }
             }
         }
     };
-    M.addGetterSetter(_m, "pixelRatio", void 0, ee());
-    class Tu extends _m {
+    O.addGetterSetter(tm, "pixelRatio", void 0, te());
+    class vu extends tm {
         constructor(t = {
             width: 0,
             height: 0
         }) {
-            super(t), this.context = new T9(this), this.setSize(t.width, t.height)
+            super(t), this.context = new P9(this), this.setSize(t.width, t.height)
         }
     }
-    class Qx extends _m {
+    class yx extends tm {
         constructor(t = {
             width: 0,
             height: 0
         }) {
-            super(t), this.hitCanvas = !0, this.context = new $9(this), this.setSize(t.width, t.height)
+            super(t), this.hitCanvas = !0, this.context = new L9(this), this.setSize(t.width, t.height)
         }
     }
-    const Be = {
+    const je = {
         get isDragging() {
             var e = !1;
-            return Be._dragElements.forEach(t => {
+            return je._dragElements.forEach(t => {
                 t.dragStatus === "dragging" && (e = !0)
             }), e
         },
         justDragged: !1,
         get node() {
             var e;
-            return Be._dragElements.forEach(t => {
+            return je._dragElements.forEach(t => {
                 e = t.node
             }), e
         },
         _dragElements: new Map,
         _drag(e) {
             const t = [];
-            Be._dragElements.forEach((n, i) => {
+            je._dragElements.forEach((n, i) => {
                 const {
                     node: r
-                } = n, a = r.getStage();
-                a.setPointersPositions(e), n.pointerId === void 0 && (n.pointerId = R._getFirstPointerId(e));
-                const s = a._changedPointerPositions.find(u => u.id === n.pointerId);
-                if (s) {
+                } = n, s = r.getStage();
+                s.setPointersPositions(e), n.pointerId === void 0 && (n.pointerId = D._getFirstPointerId(e));
+                const a = s._changedPointerPositions.find(u => u.id === n.pointerId);
+                if (a) {
                     if (n.dragStatus !== "dragging") {
                         var o = r.dragDistance(),
-                            l = Math.max(Math.abs(s.x - n.startPointerPos.x), Math.abs(s.y - n.startPointerPos.y));
+                            l = Math.max(Math.abs(a.x - n.startPointerPos.x), Math.abs(a.y - n.startPointerPos.y));
                         if (l < o || (r.startDrag({
                                 evt: e
                             }), !r.isDragging())) return
                     }
                     r._setDragPosition(e, n), t.push(r)
                 }
             }), t.forEach(n => {
@@ -1846,146 +1846,146 @@
                     target: n,
                     evt: e
                 }, !0)
             })
         },
         _endDragBefore(e) {
             const t = [];
-            Be._dragElements.forEach(n => {
+            je._dragElements.forEach(n => {
                 const {
                     node: i
                 } = n, r = i.getStage();
                 if (e && r.setPointersPositions(e), !r._changedPointerPositions.find(o => o.id === n.pointerId)) return;
-                (n.dragStatus === "dragging" || n.dragStatus === "stopped") && (Be.justDragged = !0, le._mouseListenClick = !1, le._touchListenClick = !1, le._pointerListenClick = !1, n.dragStatus = "stopped");
-                const s = n.node.getLayer() || n.node instanceof le.Stage && n.node;
-                s && t.indexOf(s) === -1 && t.push(s)
+                (n.dragStatus === "dragging" || n.dragStatus === "stopped") && (je.justDragged = !0, le._mouseListenClick = !1, le._touchListenClick = !1, le._pointerListenClick = !1, n.dragStatus = "stopped");
+                const a = n.node.getLayer() || n.node instanceof le.Stage && n.node;
+                a && t.indexOf(a) === -1 && t.push(a)
             }), t.forEach(n => {
                 n.draw()
             })
         },
         _endDragAfter(e) {
-            Be._dragElements.forEach((t, n) => {
+            je._dragElements.forEach((t, n) => {
                 t.dragStatus === "stopped" && t.node.fire("dragend", {
                     type: "dragend",
                     target: t.node,
                     evt: e
-                }, !0), t.dragStatus !== "dragging" && Be._dragElements.delete(n)
+                }, !0), t.dragStatus !== "dragging" && je._dragElements.delete(n)
             })
         }
     };
-    le.isBrowser && (window.addEventListener("mouseup", Be._endDragBefore, !0), window.addEventListener("touchend", Be._endDragBefore, !0), window.addEventListener("mousemove", Be._drag), window.addEventListener("touchmove", Be._drag), window.addEventListener("mouseup", Be._endDragAfter, !1), window.addEventListener("touchend", Be._endDragAfter, !1));
-    var sp = "absoluteOpacity",
-        ag = "allEventListeners",
-        Ca = "absoluteTransform",
-        qC = "absoluteScale",
-        Eo = "canvas",
-        F9 = "Change",
-        D9 = "children",
-        R9 = "konva",
-        bb = "listening",
-        WC = "mouseenter",
-        HC = "mouseleave",
-        YC = "set",
-        XC = "Shape",
-        op = " ",
-        VC = "stage",
-        hs = "transform",
-        P9 = "Stage",
-        xb = "visible",
-        N9 = ["xChange.konva", "yChange.konva", "scaleXChange.konva", "scaleYChange.konva", "skewXChange.konva", "skewYChange.konva", "rotationChange.konva", "offsetXChange.konva", "offsetYChange.konva", "transformsEnabledChange.konva"].join(op);
-    let L9 = 1,
-        te = class _b {
+    le.isBrowser && (window.addEventListener("mouseup", je._endDragBefore, !0), window.addEventListener("touchend", je._endDragBefore, !0), window.addEventListener("mousemove", je._drag), window.addEventListener("touchmove", je._drag), window.addEventListener("mouseup", je._endDragAfter, !1), window.addEventListener("touchend", je._endDragAfter, !1));
+    var Ug = "absoluteOpacity",
+        Wd = "allEventListeners",
+        ms = "absoluteTransform",
+        rk = "absoluteScale",
+        fo = "canvas",
+        z9 = "Change",
+        B9 = "children",
+        j9 = "konva",
+        Yv = "listening",
+        sk = "mouseenter",
+        ak = "mouseleave",
+        ok = "set",
+        lk = "Shape",
+        Gg = " ",
+        uk = "stage",
+        na = "transform",
+        U9 = "Stage",
+        Xv = "visible",
+        G9 = ["xChange.konva", "yChange.konva", "scaleXChange.konva", "scaleYChange.konva", "skewXChange.konva", "skewYChange.konva", "rotationChange.konva", "offsetXChange.konva", "offsetYChange.konva", "transformsEnabledChange.konva"].join(Gg);
+    let W9 = 1,
+        ne = class Vv {
             constructor(t) {
-                this._id = L9++, this.eventListeners = {}, this.attrs = {}, this.index = 0, this._allEventListeners = null, this.parent = null, this._cache = new Map, this._attachedDepsListeners = new Map, this._lastPos = null, this._batchingTransformChange = !1, this._needClearTransformCache = !1, this._filterUpToDate = !1, this._isUnderCache = !1, this._dragEventId = null, this._shouldFireChangeEvents = !1, this.setAttrs(t), this._shouldFireChangeEvents = !0
+                this._id = W9++, this.eventListeners = {}, this.attrs = {}, this.index = 0, this._allEventListeners = null, this.parent = null, this._cache = new Map, this._attachedDepsListeners = new Map, this._lastPos = null, this._batchingTransformChange = !1, this._needClearTransformCache = !1, this._filterUpToDate = !1, this._isUnderCache = !1, this._dragEventId = null, this._shouldFireChangeEvents = !1, this.setAttrs(t), this._shouldFireChangeEvents = !0
             }
             hasChildren() {
                 return !1
             }
             _clearCache(t) {
-                (t === hs || t === Ca) && this._cache.get(t) ? this._cache.get(t).dirty = !0 : t ? this._cache.delete(t) : this._cache.clear()
+                (t === na || t === ms) && this._cache.get(t) ? this._cache.get(t).dirty = !0 : t ? this._cache.delete(t) : this._cache.clear()
             }
             _getCache(t, n) {
                 var i = this._cache.get(t),
-                    r = t === hs || t === Ca,
-                    a = i === void 0 || r && i.dirty === !0;
-                return a && (i = n.call(this), this._cache.set(t, i)), i
+                    r = t === na || t === ms,
+                    s = i === void 0 || r && i.dirty === !0;
+                return s && (i = n.call(this), this._cache.set(t, i)), i
             }
             _calculate(t, n, i) {
                 if (!this._attachedDepsListeners.get(t)) {
-                    const r = n.map(a => a + "Change.konva").join(op);
+                    const r = n.map(s => s + "Change.konva").join(Gg);
                     this.on(r, () => {
                         this._clearCache(t)
                     }), this._attachedDepsListeners.set(t, !0)
                 }
                 return this._getCache(t, i)
             }
             _getCanvasCache() {
-                return this._cache.get(Eo)
+                return this._cache.get(fo)
             }
             _clearSelfAndDescendantCache(t) {
-                this._clearCache(t), t === Ca && this.fire("absoluteTransformChange")
+                this._clearCache(t), t === ms && this.fire("absoluteTransformChange")
             }
             clearCache() {
-                if (this._cache.has(Eo)) {
+                if (this._cache.has(fo)) {
                     const {
                         scene: t,
                         filter: n,
                         hit: i
-                    } = this._cache.get(Eo);
-                    R.releaseCanvas(t, n, i), this._cache.delete(Eo)
+                    } = this._cache.get(fo);
+                    D.releaseCanvas(t, n, i), this._cache.delete(fo)
                 }
                 return this._clearSelfAndDescendantCache(), this._requestDraw(), this
             }
             cache(t) {
                 var n = t || {},
                     i = {};
                 (n.x === void 0 || n.y === void 0 || n.width === void 0 || n.height === void 0) && (i = this.getClientRect({
                     skipTransform: !0,
                     relativeTo: this.getParent()
                 }));
                 var r = Math.ceil(n.width || i.width),
-                    a = Math.ceil(n.height || i.height),
-                    s = n.pixelRatio,
+                    s = Math.ceil(n.height || i.height),
+                    a = n.pixelRatio,
                     o = n.x === void 0 ? Math.floor(i.x) : n.x,
                     l = n.y === void 0 ? Math.floor(i.y) : n.y,
                     u = n.offset || 0,
                     c = n.drawBorder || !1,
                     f = n.hitCanvasPixelRatio || 1;
-                if (!r || !a) {
-                    R.error("Can not cache the node. Width or height of the node equals 0. Caching is skipped.");
+                if (!r || !s) {
+                    D.error("Can not cache the node. Width or height of the node equals 0. Caching is skipped.");
                     return
                 }
-                r += u * 2 + 1, a += u * 2 + 1, o -= u, l -= u;
-                var h = new Tu({
-                        pixelRatio: s,
+                r += u * 2 + 1, s += u * 2 + 1, o -= u, l -= u;
+                var h = new vu({
+                        pixelRatio: a,
                         width: r,
-                        height: a
+                        height: s
                     }),
-                    d = new Tu({
-                        pixelRatio: s,
+                    d = new vu({
+                        pixelRatio: a,
                         width: 0,
                         height: 0
                     }),
-                    g = new Qx({
+                    g = new yx({
                         pixelRatio: f,
                         width: r,
-                        height: a
+                        height: s
                     }),
                     p = h.getContext(),
                     m = g.getContext();
-                return g.isCache = !0, h.isCache = !0, this._cache.delete(Eo), this._filterUpToDate = !1, n.imageSmoothingEnabled === !1 && (h.getContext()._context.imageSmoothingEnabled = !1, d.getContext()._context.imageSmoothingEnabled = !1), p.save(), m.save(), p.translate(-o, -l), m.translate(-o, -l), this._isUnderCache = !0, this._clearSelfAndDescendantCache(sp), this._clearSelfAndDescendantCache(qC), this.drawScene(h, this), this.drawHit(g, this), this._isUnderCache = !1, p.restore(), m.restore(), c && (p.save(), p.beginPath(), p.rect(0, 0, r, a), p.closePath(), p.setAttr("strokeStyle", "red"), p.setAttr("lineWidth", 5), p.stroke(), p.restore()), this._cache.set(Eo, {
+                return g.isCache = !0, h.isCache = !0, this._cache.delete(fo), this._filterUpToDate = !1, n.imageSmoothingEnabled === !1 && (h.getContext()._context.imageSmoothingEnabled = !1, d.getContext()._context.imageSmoothingEnabled = !1), p.save(), m.save(), p.translate(-o, -l), m.translate(-o, -l), this._isUnderCache = !0, this._clearSelfAndDescendantCache(Ug), this._clearSelfAndDescendantCache(rk), this.drawScene(h, this), this.drawHit(g, this), this._isUnderCache = !1, p.restore(), m.restore(), c && (p.save(), p.beginPath(), p.rect(0, 0, r, s), p.closePath(), p.setAttr("strokeStyle", "red"), p.setAttr("lineWidth", 5), p.stroke(), p.restore()), this._cache.set(fo, {
                     scene: h,
                     filter: d,
                     hit: g,
                     x: o,
                     y: l
                 }), this._requestDraw(), this
             }
             isCached() {
-                return this._cache.has(Eo)
+                return this._cache.has(fo)
             }
             getClientRect(t) {
                 throw new Error('abstract "getClientRect" method call')
             }
             _transformedRect(t, n) {
                 var i = [{
                         x: t.x,
@@ -1996,23 +1996,23 @@
                     }, {
                         x: t.x + t.width,
                         y: t.y + t.height
                     }, {
                         x: t.x,
                         y: t.y + t.height
                     }],
-                    r, a, s, o, l = this.getAbsoluteTransform(n);
+                    r, s, a, o, l = this.getAbsoluteTransform(n);
                 return i.forEach(function(u) {
                     var c = l.point(u);
-                    r === void 0 && (r = s = c.x, a = o = c.y), r = Math.min(r, c.x), a = Math.min(a, c.y), s = Math.max(s, c.x), o = Math.max(o, c.y)
+                    r === void 0 && (r = a = c.x, s = o = c.y), r = Math.min(r, c.x), s = Math.min(s, c.y), a = Math.max(a, c.x), o = Math.max(o, c.y)
                 }), {
                     x: r,
-                    y: a,
-                    width: s - r,
-                    height: o - a
+                    y: s,
+                    width: a - r,
+                    height: o - s
                 }
             }
             _drawCachedSceneCanvas(t) {
                 t.save(), t._applyOpacity(this), t._applyGlobalCompositeOperation(this);
                 const n = this._getCanvasCache();
                 t.translate(n.x, n.y);
                 var i = this._getCachedSceneCanvas(),
@@ -2025,58 +2025,58 @@
                 t.save(), t.translate(n.x, n.y), t.drawImage(i._canvas, 0, 0, i.width / i.pixelRatio, i.height / i.pixelRatio), t.restore()
             }
             _getCachedSceneCanvas() {
                 var t = this.filters(),
                     n = this._getCanvasCache(),
                     i = n.scene,
                     r = n.filter,
-                    a = r.getContext(),
-                    s, o, l, u;
+                    s = r.getContext(),
+                    a, o, l, u;
                 if (t) {
                     if (!this._filterUpToDate) {
                         var c = i.pixelRatio;
                         r.setSize(i.width / i.pixelRatio, i.height / i.pixelRatio);
                         try {
-                            for (s = t.length, a.clear(), a.drawImage(i._canvas, 0, 0, i.getWidth() / c, i.getHeight() / c), o = a.getImageData(0, 0, r.getWidth(), r.getHeight()), l = 0; l < s; l++) {
+                            for (a = t.length, s.clear(), s.drawImage(i._canvas, 0, 0, i.getWidth() / c, i.getHeight() / c), o = s.getImageData(0, 0, r.getWidth(), r.getHeight()), l = 0; l < a; l++) {
                                 if (u = t[l], typeof u != "function") {
-                                    R.error("Filter should be type of function, but got " + typeof u + " instead. Please check correct filters");
+                                    D.error("Filter should be type of function, but got " + typeof u + " instead. Please check correct filters");
                                     continue
                                 }
-                                u.call(this, o), a.putImageData(o, 0, 0)
+                                u.call(this, o), s.putImageData(o, 0, 0)
                             }
                         } catch (f) {
-                            R.error("Unable to apply filter. " + f.message + " This post my help you https://konvajs.org/docs/posts/Tainted_Canvas.html.")
+                            D.error("Unable to apply filter. " + f.message + " This post my help you https://konvajs.org/docs/posts/Tainted_Canvas.html.")
                         }
                         this._filterUpToDate = !0
                     }
                     return r
                 }
                 return i
             }
             on(t, n) {
-                if (this._cache && this._cache.delete(ag), arguments.length === 3) return this._delegate.apply(this, arguments);
-                var i = t.split(op),
+                if (this._cache && this._cache.delete(Wd), arguments.length === 3) return this._delegate.apply(this, arguments);
+                var i = t.split(Gg),
                     r = i.length,
-                    a, s, o, l, u;
-                for (a = 0; a < r; a++) s = i[a], o = s.split("."), l = o[0], u = o[1] || "", this.eventListeners[l] || (this.eventListeners[l] = []), this.eventListeners[l].push({
+                    s, a, o, l, u;
+                for (s = 0; s < r; s++) a = i[s], o = a.split("."), l = o[0], u = o[1] || "", this.eventListeners[l] || (this.eventListeners[l] = []), this.eventListeners[l].push({
                     name: u,
                     handler: n
                 });
                 return this
             }
             off(t, n) {
-                var i = (t || "").split(op),
+                var i = (t || "").split(Gg),
                     r = i.length,
-                    a, s, o, l, u, c;
-                if (this._cache && this._cache.delete(ag), !t)
-                    for (s in this.eventListeners) this._off(s);
-                for (a = 0; a < r; a++)
-                    if (o = i[a], l = o.split("."), u = l[0], c = l[1], u) this.eventListeners[u] && this._off(u, c, n);
+                    s, a, o, l, u, c;
+                if (this._cache && this._cache.delete(Wd), !t)
+                    for (a in this.eventListeners) this._off(a);
+                for (s = 0; s < r; s++)
+                    if (o = i[s], l = o.split("."), u = l[0], c = l[1], u) this.eventListeners[u] && this._off(u, c, n);
                     else
-                        for (s in this.eventListeners) this._off(s, c, n);
+                        for (a in this.eventListeners) this._off(a, c, n);
                 return this
             }
             dispatchEvent(t) {
                 var n = {
                     target: this,
                     type: t.type,
                     evt: t
@@ -2089,103 +2089,103 @@
                 }), this
             }
             removeEventListener(t) {
                 return this.off(t), this
             }
             _delegate(t, n, i) {
                 var r = this;
-                this.on(t, function(a) {
-                    for (var s = a.target.findAncestors(n, !0, r), o = 0; o < s.length; o++) a = R.cloneObject(a), a.currentTarget = s[o], i.call(s[o], a)
+                this.on(t, function(s) {
+                    for (var a = s.target.findAncestors(n, !0, r), o = 0; o < a.length; o++) s = D.cloneObject(s), s.currentTarget = a[o], i.call(a[o], s)
                 })
             }
             remove() {
-                return this.isDragging() && this.stopDrag(), Be._dragElements.delete(this._id), this._remove(), this
+                return this.isDragging() && this.stopDrag(), je._dragElements.delete(this._id), this._remove(), this
             }
             _clearCaches() {
-                this._clearSelfAndDescendantCache(Ca), this._clearSelfAndDescendantCache(sp), this._clearSelfAndDescendantCache(qC), this._clearSelfAndDescendantCache(VC), this._clearSelfAndDescendantCache(xb), this._clearSelfAndDescendantCache(bb)
+                this._clearSelfAndDescendantCache(ms), this._clearSelfAndDescendantCache(Ug), this._clearSelfAndDescendantCache(rk), this._clearSelfAndDescendantCache(uk), this._clearSelfAndDescendantCache(Xv), this._clearSelfAndDescendantCache(Yv)
             }
             _remove() {
                 this._clearCaches();
                 var t = this.getParent();
                 t && t.children && (t.children.splice(this.index, 1), t._setChildrenIndices(), this.parent = null)
             }
             destroy() {
                 return this.remove(), this.clearCache(), this
             }
             getAttr(t) {
-                var n = "get" + R._capitalize(t);
-                return R._isFunction(this[n]) ? this[n]() : this.attrs[t]
+                var n = "get" + D._capitalize(t);
+                return D._isFunction(this[n]) ? this[n]() : this.attrs[t]
             }
             getAncestors() {
                 for (var t = this.getParent(), n = []; t;) n.push(t), t = t.getParent();
                 return n
             }
             getAttrs() {
                 return this.attrs || {}
             }
             setAttrs(t) {
                 return this._batchTransformChanges(() => {
                     var n, i;
                     if (!t) return this;
-                    for (n in t) n !== D9 && (i = YC + R._capitalize(n), R._isFunction(this[i]) ? this[i](t[n]) : this._setAttr(n, t[n]))
+                    for (n in t) n !== B9 && (i = ok + D._capitalize(n), D._isFunction(this[i]) ? this[i](t[n]) : this._setAttr(n, t[n]))
                 }), this
             }
             isListening() {
-                return this._getCache(bb, this._isListening)
+                return this._getCache(Yv, this._isListening)
             }
             _isListening(t) {
                 if (!this.listening()) return !1;
                 const i = this.getParent();
                 return i && i !== t && this !== t ? i._isListening(t) : !0
             }
             isVisible() {
-                return this._getCache(xb, this._isVisible)
+                return this._getCache(Xv, this._isVisible)
             }
             _isVisible(t) {
                 if (!this.visible()) return !1;
                 const i = this.getParent();
                 return i && i !== t && this !== t ? i._isVisible(t) : !0
             }
             shouldDrawHit(t, n = !1) {
                 if (t) return this._isVisible(t) && this._isListening(t);
                 var i = this.getLayer(),
                     r = !1;
-                Be._dragElements.forEach(s => {
-                    s.dragStatus === "dragging" && (s.node.nodeType === "Stage" || s.node.getLayer() === i) && (r = !0)
+                je._dragElements.forEach(a => {
+                    a.dragStatus === "dragging" && (a.node.nodeType === "Stage" || a.node.getLayer() === i) && (r = !0)
                 });
-                var a = !n && !le.hitOnDragEnabled && r;
-                return this.isListening() && this.isVisible() && !a
+                var s = !n && !le.hitOnDragEnabled && r;
+                return this.isListening() && this.isVisible() && !s
             }
             show() {
                 return this.visible(!0), this
             }
             hide() {
                 return this.visible(!1), this
             }
             getZIndex() {
                 return this.index || 0
             }
             getAbsoluteZIndex() {
                 var t = this.getDepth(),
                     n = this,
                     i = 0,
-                    r, a, s, o;
+                    r, s, a, o;
 
                 function l(u) {
-                    for (r = [], a = u.length, s = 0; s < a; s++) o = u[s], i++, o.nodeType !== XC && (r = r.concat(o.getChildren().slice())), o._id === n._id && (s = a);
+                    for (r = [], s = u.length, a = 0; a < s; a++) o = u[a], i++, o.nodeType !== lk && (r = r.concat(o.getChildren().slice())), o._id === n._id && (a = s);
                     r.length > 0 && r[0].getDepth() <= t && l(r)
                 }
-                return n.nodeType !== P9 && l(n.getStage().getChildren()), i
+                return n.nodeType !== U9 && l(n.getStage().getChildren()), i
             }
             getDepth() {
                 for (var t = 0, n = this.parent; n;) t++, n = n.parent;
                 return t
             }
             _batchTransformChanges(t) {
-                this._batchingTransformChange = !0, t(), this._batchingTransformChange = !1, this._needClearTransformCache && (this._clearCache(hs), this._clearSelfAndDescendantCache(Ca)), this._needClearTransformCache = !1
+                this._batchingTransformChange = !0, t(), this._batchingTransformChange = !1, this._needClearTransformCache && (this._clearCache(na), this._clearSelfAndDescendantCache(ms)), this._needClearTransformCache = !1
             }
             setPosition(t) {
                 return this._batchTransformChanges(() => {
                     this.x(t.x), this.y(t.y)
                 }), this
             }
             getPosition() {
@@ -2209,29 +2209,29 @@
                         n = !0;
                         break
                     }
                     i = i.parent
                 }
                 n && !t && (t = !0);
                 var r = this.getAbsoluteTransform(t).getMatrix(),
-                    a = new ir,
-                    s = this.offset();
-                return a.m = r.slice(), a.translate(s.x, s.y), a.getTranslation()
+                    s = new Ki,
+                    a = this.offset();
+                return s.m = r.slice(), s.translate(a.x, a.y), s.getTranslation()
             }
             setAbsolutePosition(t) {
                 var n = this._clearTransform();
-                this.attrs.x = n.x, this.attrs.y = n.y, delete n.x, delete n.y, this._clearCache(hs);
+                this.attrs.x = n.x, this.attrs.y = n.y, delete n.x, delete n.y, this._clearCache(na);
                 var i = this._getAbsoluteTransform().copy();
                 return i.invert(), i.translate(t.x, t.y), t = {
                     x: this.attrs.x + i.getTranslation().x,
                     y: this.attrs.y + i.getTranslation().y
                 }, this._setTransform(n), this.setPosition({
                     x: t.x,
                     y: t.y
-                }), this._clearCache(hs), this._clearSelfAndDescendantCache(Ca), this
+                }), this._clearCache(na), this._clearSelfAndDescendantCache(ms), this
             }
             _setTransform(t) {
                 var n;
                 for (n in t) this.attrs[n] = t[n]
             }
             _clearTransform() {
                 var t = {
@@ -2247,146 +2247,146 @@
                 };
                 return this.attrs.x = 0, this.attrs.y = 0, this.attrs.rotation = 0, this.attrs.scaleX = 1, this.attrs.scaleY = 1, this.attrs.offsetX = 0, this.attrs.offsetY = 0, this.attrs.skewX = 0, this.attrs.skewY = 0, t
             }
             move(t) {
                 var n = t.x,
                     i = t.y,
                     r = this.x(),
-                    a = this.y();
-                return n !== void 0 && (r += n), i !== void 0 && (a += i), this.setPosition({
+                    s = this.y();
+                return n !== void 0 && (r += n), i !== void 0 && (s += i), this.setPosition({
                     x: r,
-                    y: a
+                    y: s
                 }), this
             }
             _eachAncestorReverse(t, n) {
                 var i = [],
                     r = this.getParent(),
-                    a, s;
+                    s, a;
                 if (!(n && n._id === this._id)) {
                     for (i.unshift(this); r && (!n || r._id !== n._id);) i.unshift(r), r = r.parent;
-                    for (a = i.length, s = 0; s < a; s++) t(i[s])
+                    for (s = i.length, a = 0; a < s; a++) t(i[a])
                 }
             }
             rotate(t) {
                 return this.rotation(this.rotation() + t), this
             }
             moveToTop() {
-                if (!this.parent) return R.warn("Node has no parent. moveToTop function is ignored."), !1;
+                if (!this.parent) return D.warn("Node has no parent. moveToTop function is ignored."), !1;
                 var t = this.index,
                     n = this.parent.getChildren().length;
                 return t < n - 1 ? (this.parent.children.splice(t, 1), this.parent.children.push(this), this.parent._setChildrenIndices(), !0) : !1
             }
             moveUp() {
-                if (!this.parent) return R.warn("Node has no parent. moveUp function is ignored."), !1;
+                if (!this.parent) return D.warn("Node has no parent. moveUp function is ignored."), !1;
                 var t = this.index,
                     n = this.parent.getChildren().length;
                 return t < n - 1 ? (this.parent.children.splice(t, 1), this.parent.children.splice(t + 1, 0, this), this.parent._setChildrenIndices(), !0) : !1
             }
             moveDown() {
-                if (!this.parent) return R.warn("Node has no parent. moveDown function is ignored."), !1;
+                if (!this.parent) return D.warn("Node has no parent. moveDown function is ignored."), !1;
                 var t = this.index;
                 return t > 0 ? (this.parent.children.splice(t, 1), this.parent.children.splice(t - 1, 0, this), this.parent._setChildrenIndices(), !0) : !1
             }
             moveToBottom() {
-                if (!this.parent) return R.warn("Node has no parent. moveToBottom function is ignored."), !1;
+                if (!this.parent) return D.warn("Node has no parent. moveToBottom function is ignored."), !1;
                 var t = this.index;
                 return t > 0 ? (this.parent.children.splice(t, 1), this.parent.children.unshift(this), this.parent._setChildrenIndices(), !0) : !1
             }
             setZIndex(t) {
-                if (!this.parent) return R.warn("Node has no parent. zIndex parameter is ignored."), this;
-                (t < 0 || t >= this.parent.children.length) && R.warn("Unexpected value " + t + " for zIndex property. zIndex is just index of a node in children of its parent. Expected value is from 0 to " + (this.parent.children.length - 1) + ".");
+                if (!this.parent) return D.warn("Node has no parent. zIndex parameter is ignored."), this;
+                (t < 0 || t >= this.parent.children.length) && D.warn("Unexpected value " + t + " for zIndex property. zIndex is just index of a node in children of its parent. Expected value is from 0 to " + (this.parent.children.length - 1) + ".");
                 var n = this.index;
                 return this.parent.children.splice(n, 1), this.parent.children.splice(t, 0, this), this.parent._setChildrenIndices(), this
             }
             getAbsoluteOpacity() {
-                return this._getCache(sp, this._getAbsoluteOpacity)
+                return this._getCache(Ug, this._getAbsoluteOpacity)
             }
             _getAbsoluteOpacity() {
                 var t = this.opacity(),
                     n = this.getParent();
                 return n && !n._isUnderCache && (t *= n.getAbsoluteOpacity()), t
             }
             moveTo(t) {
                 return this.getParent() !== t && (this._remove(), t.add(this)), this
             }
             toObject() {
                 var t = {},
                     n = this.getAttrs(),
-                    i, r, a, s, o;
+                    i, r, s, a, o;
                 t.attrs = {};
-                for (i in n) r = n[i], o = R.isObject(r) && !R._isPlainObject(r) && !R._isArray(r), !o && (a = typeof this[i] == "function" && this[i], delete n[i], s = a ? a.call(this) : null, n[i] = r, s !== r && (t.attrs[i] = r));
-                return t.className = this.getClassName(), R._prepareToStringify(t)
+                for (i in n) r = n[i], o = D.isObject(r) && !D._isPlainObject(r) && !D._isArray(r), !o && (s = typeof this[i] == "function" && this[i], delete n[i], a = s ? s.call(this) : null, n[i] = r, a !== r && (t.attrs[i] = r));
+                return t.className = this.getClassName(), D._prepareToStringify(t)
             }
             toJSON() {
                 return JSON.stringify(this.toObject())
             }
             getParent() {
                 return this.parent
             }
             findAncestors(t, n, i) {
                 var r = [];
                 n && this._isMatch(t) && r.push(this);
-                for (var a = this.parent; a;) {
-                    if (a === i) return r;
-                    a._isMatch(t) && r.push(a), a = a.parent
+                for (var s = this.parent; s;) {
+                    if (s === i) return r;
+                    s._isMatch(t) && r.push(s), s = s.parent
                 }
                 return r
             }
             isAncestorOf(t) {
                 return !1
             }
             findAncestor(t, n, i) {
                 return this.findAncestors(t, n, i)[0]
             }
             _isMatch(t) {
                 if (!t) return !1;
                 if (typeof t == "function") return t(this);
                 var n = t.replace(/ /g, "").split(","),
                     i = n.length,
-                    r, a;
+                    r, s;
                 for (r = 0; r < i; r++)
-                    if (a = n[r], R.isValidSelector(a) || (R.warn('Selector "' + a + '" is invalid. Allowed selectors examples are "#foo", ".bar" or "Group".'), R.warn('If you have a custom shape with such className, please change it to start with upper letter like "Triangle".'), R.warn("Konva is awesome, right?")), a.charAt(0) === "#") {
-                        if (this.id() === a.slice(1)) return !0
-                    } else if (a.charAt(0) === ".") {
-                    if (this.hasName(a.slice(1))) return !0
-                } else if (this.className === a || this.nodeType === a) return !0;
+                    if (s = n[r], D.isValidSelector(s) || (D.warn('Selector "' + s + '" is invalid. Allowed selectors examples are "#foo", ".bar" or "Group".'), D.warn('If you have a custom shape with such className, please change it to start with upper letter like "Triangle".'), D.warn("Konva is awesome, right?")), s.charAt(0) === "#") {
+                        if (this.id() === s.slice(1)) return !0
+                    } else if (s.charAt(0) === ".") {
+                    if (this.hasName(s.slice(1))) return !0
+                } else if (this.className === s || this.nodeType === s) return !0;
                 return !1
             }
             getLayer() {
                 var t = this.getParent();
                 return t ? t.getLayer() : null
             }
             getStage() {
-                return this._getCache(VC, this._getStage)
+                return this._getCache(uk, this._getStage)
             }
             _getStage() {
                 var t = this.getParent();
                 if (t) return t.getStage()
             }
             fire(t, n = {}, i) {
                 return n.target = n.target || this, i ? this._fireAndBubble(t, n) : this._fire(t, n), this
             }
             getAbsoluteTransform(t) {
-                return t ? this._getAbsoluteTransform(t) : this._getCache(Ca, this._getAbsoluteTransform)
+                return t ? this._getAbsoluteTransform(t) : this._getCache(ms, this._getAbsoluteTransform)
             }
             _getAbsoluteTransform(t) {
                 var n;
-                if (t) return n = new ir, this._eachAncestorReverse(function(r) {
-                    var a = r.transformsEnabled();
-                    a === "all" ? n.multiply(r.getTransform()) : a === "position" && n.translate(r.x() - r.offsetX(), r.y() - r.offsetY())
+                if (t) return n = new Ki, this._eachAncestorReverse(function(r) {
+                    var s = r.transformsEnabled();
+                    s === "all" ? n.multiply(r.getTransform()) : s === "position" && n.translate(r.x() - r.offsetX(), r.y() - r.offsetY())
                 }, t), n;
-                n = this._cache.get(Ca) || new ir, this.parent ? this.parent.getAbsoluteTransform().copyInto(n) : n.reset();
+                n = this._cache.get(ms) || new Ki, this.parent ? this.parent.getAbsoluteTransform().copyInto(n) : n.reset();
                 var i = this.transformsEnabled();
                 if (i === "all") n.multiply(this.getTransform());
                 else if (i === "position") {
                     const r = this.attrs.x || 0,
-                        a = this.attrs.y || 0,
-                        s = this.attrs.offsetX || 0,
+                        s = this.attrs.y || 0,
+                        a = this.attrs.offsetX || 0,
                         o = this.attrs.offsetY || 0;
-                    n.translate(r - s, a - o)
+                    n.translate(r - a, s - o)
                 }
                 return n.dirty = !1, n
             }
             getAbsoluteScale(t) {
                 for (var n = this; n;) n._isUnderCache && (t = n), n = n.getParent();
                 const r = this.getAbsoluteTransform(t).decompose();
                 return {
@@ -2394,53 +2394,53 @@
                     y: r.scaleY
                 }
             }
             getAbsoluteRotation() {
                 return this.getAbsoluteTransform().decompose().rotation
             }
             getTransform() {
-                return this._getCache(hs, this._getTransform)
+                return this._getCache(na, this._getTransform)
             }
             _getTransform() {
-                var t, n, i = this._cache.get(hs) || new ir;
+                var t, n, i = this._cache.get(na) || new Ki;
                 i.reset();
                 var r = this.x(),
-                    a = this.y(),
-                    s = le.getAngle(this.rotation()),
+                    s = this.y(),
+                    a = le.getAngle(this.rotation()),
                     o = (t = this.attrs.scaleX) !== null && t !== void 0 ? t : 1,
                     l = (n = this.attrs.scaleY) !== null && n !== void 0 ? n : 1,
                     u = this.attrs.skewX || 0,
                     c = this.attrs.skewY || 0,
                     f = this.attrs.offsetX || 0,
                     h = this.attrs.offsetY || 0;
-                return (r !== 0 || a !== 0) && i.translate(r, a), s !== 0 && i.rotate(s), (u !== 0 || c !== 0) && i.skew(u, c), (o !== 1 || l !== 1) && i.scale(o, l), (f !== 0 || h !== 0) && i.translate(-1 * f, -1 * h), i.dirty = !1, i
+                return (r !== 0 || s !== 0) && i.translate(r, s), a !== 0 && i.rotate(a), (u !== 0 || c !== 0) && i.skew(u, c), (o !== 1 || l !== 1) && i.scale(o, l), (f !== 0 || h !== 0) && i.translate(-1 * f, -1 * h), i.dirty = !1, i
             }
             clone(t) {
-                var n = R.cloneObject(this.attrs),
-                    i, r, a, s, o;
+                var n = D.cloneObject(this.attrs),
+                    i, r, s, a, o;
                 for (i in t) n[i] = t[i];
                 var l = new this.constructor(n);
                 for (i in this.eventListeners)
-                    for (r = this.eventListeners[i], a = r.length, s = 0; s < a; s++) o = r[s], o.name.indexOf(R9) < 0 && (l.eventListeners[i] || (l.eventListeners[i] = []), l.eventListeners[i].push(o));
+                    for (r = this.eventListeners[i], s = r.length, a = 0; a < s; a++) o = r[a], o.name.indexOf(j9) < 0 && (l.eventListeners[i] || (l.eventListeners[i] = []), l.eventListeners[i].push(o));
                 return l
             }
             _toKonvaCanvas(t) {
                 t = t || {};
                 var n = this.getClientRect(),
                     i = this.getStage(),
                     r = t.x !== void 0 ? t.x : Math.floor(n.x),
-                    a = t.y !== void 0 ? t.y : Math.floor(n.y),
-                    s = t.pixelRatio || 1,
-                    o = new Tu({
+                    s = t.y !== void 0 ? t.y : Math.floor(n.y),
+                    a = t.pixelRatio || 1,
+                    o = new vu({
                         width: t.width || Math.ceil(n.width) || (i ? i.width() : 0),
                         height: t.height || Math.ceil(n.height) || (i ? i.height() : 0),
-                        pixelRatio: s
+                        pixelRatio: a
                     }),
                     l = o.getContext();
-                return t.imageSmoothingEnabled === !1 && (l._context.imageSmoothingEnabled = !1), l.save(), (r || a) && l.translate(-1 * r, -1 * a), this.drawScene(o), l.restore(), o
+                return t.imageSmoothingEnabled === !1 && (l._context.imageSmoothingEnabled = !1), l.save(), (r || s) && l.translate(-1 * r, -1 * s), this.drawScene(o), l.restore(), o
             }
             toCanvas(t) {
                 return this._toKonvaCanvas(t)._canvas
             }
             toDataURL(t) {
                 t = t || {};
                 var n = t.mimeType || null,
@@ -2448,28 +2448,28 @@
                     r = this._toKonvaCanvas(t).toDataURL(n, i);
                 return t.callback && t.callback(r), r
             }
             toImage(t) {
                 return new Promise((n, i) => {
                     try {
                         const r = t == null ? void 0 : t.callback;
-                        r && delete t.callback, R._urlToImage(this.toDataURL(t), function(a) {
-                            n(a), r == null || r(a)
+                        r && delete t.callback, D._urlToImage(this.toDataURL(t), function(s) {
+                            n(s), r == null || r(s)
                         })
                     } catch (r) {
                         i(r)
                     }
                 })
             }
             toBlob(t) {
                 return new Promise((n, i) => {
                     try {
                         const r = t == null ? void 0 : t.callback;
-                        r && delete t.callback, this.toCanvas(t).toBlob(a => {
-                            n(a), r == null || r(a)
+                        r && delete t.callback, this.toCanvas(t).toBlob(s => {
+                            n(s), r == null || r(s)
                         })
                     } catch (r) {
                         i(r)
                     }
                 })
             }
             setSize(t) {
@@ -2488,26 +2488,26 @@
                 return this.nodeType
             }
             getDragDistance() {
                 return this.attrs.dragDistance !== void 0 ? this.attrs.dragDistance : this.parent ? this.parent.getDragDistance() : le.dragDistance
             }
             _off(t, n, i) {
                 var r = this.eventListeners[t],
-                    a, s, o;
-                for (a = 0; a < r.length; a++)
-                    if (s = r[a].name, o = r[a].handler, (s !== "konva" || n === "konva") && (!n || s === n) && (!i || i === o)) {
-                        if (r.splice(a, 1), r.length === 0) {
+                    s, a, o;
+                for (s = 0; s < r.length; s++)
+                    if (a = r[s].name, o = r[s].handler, (a !== "konva" || n === "konva") && (!n || a === n) && (!i || i === o)) {
+                        if (r.splice(s, 1), r.length === 0) {
                             delete this.eventListeners[t];
                             break
                         }
-                        a--
+                        s--
                     }
             }
             _fireChangeEvent(t, n, i) {
-                this._fire(t + F9, {
+                this._fire(t + z9, {
                     oldVal: n,
                     newVal: i
                 })
             }
             addName(t) {
                 if (!this.hasName(t)) {
                     var n = this.name(),
@@ -2525,145 +2525,145 @@
             }
             removeName(t) {
                 var n = (this.name() || "").split(/\s/g),
                     i = n.indexOf(t);
                 return i !== -1 && (n.splice(i, 1), this.name(n.join(" "))), this
             }
             setAttr(t, n) {
-                var i = this[YC + R._capitalize(t)];
-                return R._isFunction(i) ? i.call(this, n) : this._setAttr(t, n), this
+                var i = this[ok + D._capitalize(t)];
+                return D._isFunction(i) ? i.call(this, n) : this._setAttr(t, n), this
             }
             _requestDraw() {
                 if (le.autoDrawEnabled) {
                     const t = this.getLayer() || this.getStage();
                     t == null || t.batchDraw()
                 }
             }
             _setAttr(t, n) {
                 var i = this.attrs[t];
-                i === n && !R.isObject(n) || (n == null ? delete this.attrs[t] : this.attrs[t] = n, this._shouldFireChangeEvents && this._fireChangeEvent(t, i, n), this._requestDraw())
+                i === n && !D.isObject(n) || (n == null ? delete this.attrs[t] : this.attrs[t] = n, this._shouldFireChangeEvents && this._fireChangeEvent(t, i, n), this._requestDraw())
             }
             _setComponentAttr(t, n, i) {
                 var r;
                 i !== void 0 && (r = this.attrs[t], r || (this.attrs[t] = this.getAttr(t)), this.attrs[t][n] = i, this._fireChangeEvent(t, r, i))
             }
             _fireAndBubble(t, n, i) {
-                n && this.nodeType === XC && (n.target = this);
-                var r = (t === WC || t === HC) && (i && (this === i || this.isAncestorOf && this.isAncestorOf(i)) || this.nodeType === "Stage" && !i);
+                n && this.nodeType === lk && (n.target = this);
+                var r = (t === sk || t === ak) && (i && (this === i || this.isAncestorOf && this.isAncestorOf(i)) || this.nodeType === "Stage" && !i);
                 if (!r) {
                     this._fire(t, n);
-                    var a = (t === WC || t === HC) && i && i.isAncestorOf && i.isAncestorOf(this) && !i.isAncestorOf(this.parent);
-                    (n && !n.cancelBubble || !n) && this.parent && this.parent.isListening() && !a && (i && i.parent ? this._fireAndBubble.call(this.parent, t, n, i) : this._fireAndBubble.call(this.parent, t, n))
+                    var s = (t === sk || t === ak) && i && i.isAncestorOf && i.isAncestorOf(this) && !i.isAncestorOf(this.parent);
+                    (n && !n.cancelBubble || !n) && this.parent && this.parent.isListening() && !s && (i && i.parent ? this._fireAndBubble.call(this.parent, t, n, i) : this._fireAndBubble.call(this.parent, t, n))
                 }
             }
             _getProtoListeners(t) {
-                let n = this._cache.get(ag);
+                let n = this._cache.get(Wd);
                 if (!n) {
                     n = {};
                     let r = Object.getPrototypeOf(this);
                     for (; r;) {
                         if (!r.eventListeners) {
                             r = Object.getPrototypeOf(r);
                             continue
                         }
                         for (var i in r.eventListeners) {
-                            const a = r.eventListeners[i],
-                                s = n[i] || [];
-                            n[i] = a.concat(s)
+                            const s = r.eventListeners[i],
+                                a = n[i] || [];
+                            n[i] = s.concat(a)
                         }
                         r = Object.getPrototypeOf(r)
                     }
-                    this._cache.set(ag, n)
+                    this._cache.set(Wd, n)
                 }
                 return n[t]
             }
             _fire(t, n) {
                 n = n || {}, n.currentTarget = this, n.type = t;
                 const i = this._getProtoListeners(t);
                 if (i)
                     for (var r = 0; r < i.length; r++) i[r].handler.call(this, n);
-                const a = this.eventListeners[t];
-                if (a)
-                    for (var r = 0; r < a.length; r++) a[r].handler.call(this, n)
+                const s = this.eventListeners[t];
+                if (s)
+                    for (var r = 0; r < s.length; r++) s[r].handler.call(this, n)
             }
             draw() {
                 return this.drawScene(), this.drawHit(), this
             }
             _createDragElement(t) {
                 var n = t ? t.pointerId : void 0,
                     i = this.getStage(),
                     r = this.getAbsolutePosition(),
-                    a = i._getPointerById(n) || i._changedPointerPositions[0] || r;
-                Be._dragElements.set(this._id, {
+                    s = i._getPointerById(n) || i._changedPointerPositions[0] || r;
+                je._dragElements.set(this._id, {
                     node: this,
-                    startPointerPos: a,
+                    startPointerPos: s,
                     offset: {
-                        x: a.x - r.x,
-                        y: a.y - r.y
+                        x: s.x - r.x,
+                        y: s.y - r.y
                     },
                     dragStatus: "ready",
                     pointerId: n
                 })
             }
             startDrag(t, n = !0) {
-                Be._dragElements.has(this._id) || this._createDragElement(t);
-                const i = Be._dragElements.get(this._id);
+                je._dragElements.has(this._id) || this._createDragElement(t);
+                const i = je._dragElements.get(this._id);
                 i.dragStatus = "dragging", this.fire("dragstart", {
                     type: "dragstart",
                     target: this,
                     evt: t && t.evt
                 }, n)
             }
             _setDragPosition(t, n) {
                 const i = this.getStage()._getPointerById(n.pointerId);
                 if (i) {
                     var r = {
                             x: i.x - n.offset.x,
                             y: i.y - n.offset.y
                         },
-                        a = this.dragBoundFunc();
-                    if (a !== void 0) {
-                        const s = a.call(this, r, t);
-                        s ? r = s : R.warn("dragBoundFunc did not return any value. That is unexpected behavior. You must return new absolute position from dragBoundFunc.")
+                        s = this.dragBoundFunc();
+                    if (s !== void 0) {
+                        const a = s.call(this, r, t);
+                        a ? r = a : D.warn("dragBoundFunc did not return any value. That is unexpected behavior. You must return new absolute position from dragBoundFunc.")
                     }(!this._lastPos || this._lastPos.x !== r.x || this._lastPos.y !== r.y) && (this.setAbsolutePosition(r), this._requestDraw()), this._lastPos = r
                 }
             }
             stopDrag(t) {
-                const n = Be._dragElements.get(this._id);
-                n && (n.dragStatus = "stopped"), Be._endDragBefore(t), Be._endDragAfter(t)
+                const n = je._dragElements.get(this._id);
+                n && (n.dragStatus = "stopped"), je._endDragBefore(t), je._endDragAfter(t)
             }
             setDraggable(t) {
                 this._setAttr("draggable", t), this._dragChange()
             }
             isDragging() {
-                const t = Be._dragElements.get(this._id);
+                const t = je._dragElements.get(this._id);
                 return t ? t.dragStatus === "dragging" : !1
             }
             _listenDrag() {
                 this._dragCleanup(), this.on("mousedown.konva touchstart.konva", function(t) {
                     var n = t.evt.button !== void 0,
                         i = !n || le.dragButtons.indexOf(t.evt.button) >= 0;
                     if (i && !this.isDragging()) {
                         var r = !1;
-                        Be._dragElements.forEach(a => {
-                            this.isAncestorOf(a.node) && (r = !0)
+                        je._dragElements.forEach(s => {
+                            this.isAncestorOf(s.node) && (r = !0)
                         }), r || this._createDragElement(t)
                     }
                 })
             }
             _dragChange() {
                 if (this.attrs.draggable) this._listenDrag();
                 else {
                     this._dragCleanup();
                     var t = this.getStage();
                     if (!t) return;
-                    const n = Be._dragElements.get(this._id),
+                    const n = je._dragElements.get(this._id),
                         i = n && n.dragStatus === "dragging",
                         r = n && n.dragStatus === "ready";
-                    i ? this.stopDrag() : r && Be._dragElements.delete(this._id)
+                    i ? this.stopDrag() : r && je._dragElements.delete(this._id)
                 }
             }
             _dragCleanup() {
                 this.off("mousedown.konva"), this.off("touchstart.konva")
             }
             isClientRectOnScreen(t = {
                 x: 0,
@@ -2673,88 +2673,88 @@
                 if (!n) return !1;
                 const i = {
                     x: -t.x,
                     y: -t.y,
                     width: n.width() + 2 * t.x,
                     height: n.height() + 2 * t.y
                 };
-                return R.haveIntersection(i, this.getClientRect())
+                return D.haveIntersection(i, this.getClientRect())
             }
             static create(t, n) {
-                return R._isString(t) && (t = JSON.parse(t)), this._createNode(t, n)
+                return D._isString(t) && (t = JSON.parse(t)), this._createNode(t, n)
             }
             static _createNode(t, n) {
-                var i = _b.prototype.getClassName.call(t),
+                var i = Vv.prototype.getClassName.call(t),
                     r = t.children,
-                    a, s, o;
-                n && (t.attrs.container = n), le[i] || (R.warn('Can not find a node with class name "' + i + '". Fallback to "Shape".'), i = "Shape");
+                    s, a, o;
+                n && (t.attrs.container = n), le[i] || (D.warn('Can not find a node with class name "' + i + '". Fallback to "Shape".'), i = "Shape");
                 const l = le[i];
-                if (a = new l(t.attrs), r)
-                    for (s = r.length, o = 0; o < s; o++) a.add(_b._createNode(r[o]));
-                return a
+                if (s = new l(t.attrs), r)
+                    for (a = r.length, o = 0; o < a; o++) s.add(Vv._createNode(r[o]));
+                return s
             }
         };
-    te.prototype.nodeType = "Node";
-    te.prototype._attrsAffectingSize = [];
-    te.prototype.eventListeners = {};
-    te.prototype.on.call(te.prototype, N9, function() {
+    ne.prototype.nodeType = "Node";
+    ne.prototype._attrsAffectingSize = [];
+    ne.prototype.eventListeners = {};
+    ne.prototype.on.call(ne.prototype, G9, function() {
         if (this._batchingTransformChange) {
             this._needClearTransformCache = !0;
             return
         }
-        this._clearCache(hs), this._clearSelfAndDescendantCache(Ca)
+        this._clearCache(na), this._clearSelfAndDescendantCache(ms)
     });
-    te.prototype.on.call(te.prototype, "visibleChange.konva", function() {
-        this._clearSelfAndDescendantCache(xb)
+    ne.prototype.on.call(ne.prototype, "visibleChange.konva", function() {
+        this._clearSelfAndDescendantCache(Xv)
     });
-    te.prototype.on.call(te.prototype, "listeningChange.konva", function() {
-        this._clearSelfAndDescendantCache(bb)
+    ne.prototype.on.call(ne.prototype, "listeningChange.konva", function() {
+        this._clearSelfAndDescendantCache(Yv)
     });
-    te.prototype.on.call(te.prototype, "opacityChange.konva", function() {
-        this._clearSelfAndDescendantCache(sp)
-    });
-    const at = M.addGetterSetter;
-    at(te, "zIndex");
-    at(te, "absolutePosition");
-    at(te, "position");
-    at(te, "x", 0, ee());
-    at(te, "y", 0, ee());
-    at(te, "globalCompositeOperation", "source-over", Ec());
-    at(te, "opacity", 1, ee());
-    at(te, "name", "", Ec());
-    at(te, "id", "", Ec());
-    at(te, "rotation", 0, ee());
-    M.addComponentsGetterSetter(te, "scale", ["x", "y"]);
-    at(te, "scaleX", 1, ee());
-    at(te, "scaleY", 1, ee());
-    M.addComponentsGetterSetter(te, "skew", ["x", "y"]);
-    at(te, "skewX", 0, ee());
-    at(te, "skewY", 0, ee());
-    M.addComponentsGetterSetter(te, "offset", ["x", "y"]);
-    at(te, "offsetX", 0, ee());
-    at(te, "offsetY", 0, ee());
-    at(te, "dragDistance", null, ee());
-    at(te, "width", 0, ee());
-    at(te, "height", 0, ee());
-    at(te, "listening", !0, Sr());
-    at(te, "preventDefault", !0, Sr());
-    at(te, "filters", null, function(e) {
+    ne.prototype.on.call(ne.prototype, "opacityChange.konva", function() {
+        this._clearSelfAndDescendantCache(Ug)
+    });
+    const rt = O.addGetterSetter;
+    rt(ne, "zIndex");
+    rt(ne, "absolutePosition");
+    rt(ne, "position");
+    rt(ne, "x", 0, te());
+    rt(ne, "y", 0, te());
+    rt(ne, "globalCompositeOperation", "source-over", hc());
+    rt(ne, "opacity", 1, te());
+    rt(ne, "name", "", hc());
+    rt(ne, "id", "", hc());
+    rt(ne, "rotation", 0, te());
+    O.addComponentsGetterSetter(ne, "scale", ["x", "y"]);
+    rt(ne, "scaleX", 1, te());
+    rt(ne, "scaleY", 1, te());
+    O.addComponentsGetterSetter(ne, "skew", ["x", "y"]);
+    rt(ne, "skewX", 0, te());
+    rt(ne, "skewY", 0, te());
+    O.addComponentsGetterSetter(ne, "offset", ["x", "y"]);
+    rt(ne, "offsetX", 0, te());
+    rt(ne, "offsetY", 0, te());
+    rt(ne, "dragDistance", null, te());
+    rt(ne, "width", 0, te());
+    rt(ne, "height", 0, te());
+    rt(ne, "listening", !0, mr());
+    rt(ne, "preventDefault", !0, mr());
+    rt(ne, "filters", null, function(e) {
         return this._filterUpToDate = !1, e
     });
-    at(te, "visible", !0, Sr());
-    at(te, "transformsEnabled", "all", Ec());
-    at(te, "size");
-    at(te, "dragBoundFunc");
-    at(te, "draggable", !1, Sr());
-    M.backCompat(te, {
+    rt(ne, "visible", !0, mr());
+    rt(ne, "transformsEnabled", "all", hc());
+    rt(ne, "size");
+    rt(ne, "dragBoundFunc");
+    rt(ne, "draggable", !1, mr());
+    O.backCompat(ne, {
         rotateDeg: "rotate",
         setRotationDeg: "setRotation",
         getRotationDeg: "getRotation"
     });
-    class vi extends te {
+    class mi extends ne {
         constructor() {
             super(...arguments), this.children = []
         }
         getChildren(t) {
             if (!t) return this.children || [];
             const n = this.children || [];
             var i = [];
@@ -2795,42 +2795,42 @@
         findOne(t) {
             var n = this._generalFind(t, !0);
             return n.length > 0 ? n[0] : void 0
         }
         _generalFind(t, n) {
             var i = [];
             return this._descendants(r => {
-                const a = r._isMatch(t);
-                return a && i.push(r), !!(a && n)
+                const s = r._isMatch(t);
+                return s && i.push(r), !!(s && n)
             }), i
         }
         _descendants(t) {
             let n = !1;
             const i = this.getChildren();
             for (const r of i) {
                 if (n = t(r), n) return !0;
                 if (r.hasChildren() && (n = r._descendants(t), n)) return !0
             }
             return !1
         }
         toObject() {
-            var t = te.prototype.toObject.call(this);
+            var t = ne.prototype.toObject.call(this);
             return t.children = [], this.getChildren().forEach(n => {
                 t.children.push(n.toObject())
             }), t
         }
         isAncestorOf(t) {
             for (var n = t.getParent(); n;) {
                 if (n._id === this._id) return !0;
                 n = n.getParent()
             }
             return !1
         }
         clone(t) {
-            var n = te.prototype.clone.call(this, t);
+            var n = ne.prototype.clone.call(this, t);
             return this.getChildren().forEach(function(i) {
                 n.add(i.clone())
             }), n
         }
         getAllIntersections(t) {
             var n = [];
             return this.find("Shape").forEach(function(i) {
@@ -2848,254 +2848,254 @@
             (t = this.children) === null || t === void 0 || t.forEach(function(n, i) {
                 n.index = i
             }), this._requestDraw()
         }
         drawScene(t, n) {
             var i = this.getLayer(),
                 r = t || i && i.getCanvas(),
-                a = r && r.getContext(),
-                s = this._getCanvasCache(),
-                o = s && s.scene,
+                s = r && r.getContext(),
+                a = this._getCanvasCache(),
+                o = a && a.scene,
                 l = r && r.isCache;
             if (!this.isVisible() && !l) return this;
             if (o) {
-                a.save();
+                s.save();
                 var u = this.getAbsoluteTransform(n).getMatrix();
-                a.transform(u[0], u[1], u[2], u[3], u[4], u[5]), this._drawCachedSceneCanvas(a), a.restore()
+                s.transform(u[0], u[1], u[2], u[3], u[4], u[5]), this._drawCachedSceneCanvas(s), s.restore()
             } else this._drawChildren("drawScene", r, n);
             return this
         }
         drawHit(t, n) {
             if (!this.shouldDrawHit(n)) return this;
             var i = this.getLayer(),
                 r = t || i && i.hitCanvas,
-                a = r && r.getContext(),
-                s = this._getCanvasCache(),
-                o = s && s.hit;
+                s = r && r.getContext(),
+                a = this._getCanvasCache(),
+                o = a && a.hit;
             if (o) {
-                a.save();
+                s.save();
                 var l = this.getAbsoluteTransform(n).getMatrix();
-                a.transform(l[0], l[1], l[2], l[3], l[4], l[5]), this._drawCachedHitCanvas(a), a.restore()
+                s.transform(l[0], l[1], l[2], l[3], l[4], l[5]), this._drawCachedHitCanvas(s), s.restore()
             } else this._drawChildren("drawHit", r, n);
             return this
         }
         _drawChildren(t, n, i) {
-            var r, a = n && n.getContext(),
-                s = this.clipWidth(),
+            var r, s = n && n.getContext(),
+                a = this.clipWidth(),
                 o = this.clipHeight(),
                 l = this.clipFunc(),
-                u = s && o || l;
+                u = a && o || l;
             const c = i === this;
             if (u) {
-                a.save();
+                s.save();
                 var f = this.getAbsoluteTransform(i),
                     h = f.getMatrix();
-                if (a.transform(h[0], h[1], h[2], h[3], h[4], h[5]), a.beginPath(), l) l.call(this, a, this);
+                if (s.transform(h[0], h[1], h[2], h[3], h[4], h[5]), s.beginPath(), l) l.call(this, s, this);
                 else {
                     var d = this.clipX(),
                         g = this.clipY();
-                    a.rect(d, g, s, o)
+                    s.rect(d, g, a, o)
                 }
-                a.clip(), h = f.copy().invert().getMatrix(), a.transform(h[0], h[1], h[2], h[3], h[4], h[5])
+                s.clip(), h = f.copy().invert().getMatrix(), s.transform(h[0], h[1], h[2], h[3], h[4], h[5])
             }
             var p = !c && this.globalCompositeOperation() !== "source-over" && t === "drawScene";
-            p && (a.save(), a._applyGlobalCompositeOperation(this)), (r = this.children) === null || r === void 0 || r.forEach(function(m) {
+            p && (s.save(), s._applyGlobalCompositeOperation(this)), (r = this.children) === null || r === void 0 || r.forEach(function(m) {
                 m[t](n, i)
-            }), p && a.restore(), u && a.restore()
+            }), p && s.restore(), u && s.restore()
         }
         getClientRect(t) {
             var n;
             t = t || {};
             var i = t.skipTransform,
                 r = t.relativeTo,
-                a, s, o, l, u = {
+                s, a, o, l, u = {
                     x: 1 / 0,
                     y: 1 / 0,
                     width: 0,
                     height: 0
                 },
                 c = this;
             (n = this.children) === null || n === void 0 || n.forEach(function(p) {
                 if (p.visible()) {
                     var m = p.getClientRect({
                         relativeTo: c,
                         skipShadow: t.skipShadow,
                         skipStroke: t.skipStroke
                     });
-                    m.width === 0 && m.height === 0 || (a === void 0 ? (a = m.x, s = m.y, o = m.x + m.width, l = m.y + m.height) : (a = Math.min(a, m.x), s = Math.min(s, m.y), o = Math.max(o, m.x + m.width), l = Math.max(l, m.y + m.height)))
+                    m.width === 0 && m.height === 0 || (s === void 0 ? (s = m.x, a = m.y, o = m.x + m.width, l = m.y + m.height) : (s = Math.min(s, m.x), a = Math.min(a, m.y), o = Math.max(o, m.x + m.width), l = Math.max(l, m.y + m.height)))
                 }
             });
             for (var f = this.find("Shape"), h = !1, d = 0; d < f.length; d++) {
                 var g = f[d];
                 if (g._isVisible(this)) {
                     h = !0;
                     break
                 }
             }
-            return h && a !== void 0 ? u = {
-                x: a,
-                y: s,
-                width: o - a,
-                height: l - s
+            return h && s !== void 0 ? u = {
+                x: s,
+                y: a,
+                width: o - s,
+                height: l - a
             } : u = {
                 x: 0,
                 y: 0,
                 width: 0,
                 height: 0
             }, i ? u : this._transformedRect(u, r)
         }
     }
-    M.addComponentsGetterSetter(vi, "clip", ["x", "y", "width", "height"]);
-    M.addGetterSetter(vi, "clipX", void 0, ee());
-    M.addGetterSetter(vi, "clipY", void 0, ee());
-    M.addGetterSetter(vi, "clipWidth", void 0, ee());
-    M.addGetterSetter(vi, "clipHeight", void 0, ee());
-    M.addGetterSetter(vi, "clipFunc");
-    const Oh = new Map,
-        vM = le._global.PointerEvent !== void 0;
+    O.addComponentsGetterSetter(mi, "clip", ["x", "y", "width", "height"]);
+    O.addGetterSetter(mi, "clipX", void 0, te());
+    O.addGetterSetter(mi, "clipY", void 0, te());
+    O.addGetterSetter(mi, "clipWidth", void 0, te());
+    O.addGetterSetter(mi, "clipHeight", void 0, te());
+    O.addGetterSetter(mi, "clipFunc");
+    const dh = new Map,
+        TM = le._global.PointerEvent !== void 0;
 
-    function Dy(e) {
-        return Oh.get(e)
+    function fy(e) {
+        return dh.get(e)
     }
 
-    function Zx(e) {
+    function vx(e) {
         return {
             evt: e,
             pointerId: e.pointerId
         }
     }
 
-    function bM(e, t) {
-        return Oh.get(e) === t
+    function MM(e, t) {
+        return dh.get(e) === t
     }
 
-    function xM(e, t) {
-        ah(e), t.getStage() && (Oh.set(e, t), vM && t._fire("gotpointercapture", Zx(new PointerEvent("gotpointercapture"))))
+    function OM(e, t) {
+        Yf(e), t.getStage() && (dh.set(e, t), TM && t._fire("gotpointercapture", vx(new PointerEvent("gotpointercapture"))))
     }
 
-    function ah(e, t) {
-        const n = Oh.get(e);
+    function Yf(e, t) {
+        const n = dh.get(e);
         if (!n) return;
         const i = n.getStage();
-        i && i.content, Oh.delete(e), vM && n._fire("lostpointercapture", Zx(new PointerEvent("lostpointercapture")))
+        i && i.content, dh.delete(e), TM && n._fire("lostpointercapture", vx(new PointerEvent("lostpointercapture")))
     }
-    var I9 = "Stage",
-        j9 = "string",
-        KC = "px",
-        z9 = "mouseout",
-        _M = "mouseleave",
-        wM = "mouseover",
-        SM = "mouseenter",
-        EM = "mousemove",
-        OM = "mousedown",
-        CM = "mouseup",
-        $f = "pointermove",
-        Mf = "pointerdown",
-        bu = "pointerup",
-        Ff = "pointercancel",
-        B9 = "lostpointercapture",
-        sg = "pointerout",
-        og = "pointerleave",
-        lg = "pointerover",
-        ug = "pointerenter",
-        wb = "contextmenu",
-        kM = "touchstart",
-        AM = "touchend",
-        TM = "touchmove",
-        $M = "touchcancel",
-        Sb = "wheel",
-        G9 = 5,
-        U9 = [
-            [SM, "_pointerenter"],
-            [OM, "_pointerdown"],
-            [EM, "_pointermove"],
-            [CM, "_pointerup"],
-            [_M, "_pointerleave"],
-            [kM, "_pointerdown"],
-            [TM, "_pointermove"],
-            [AM, "_pointerup"],
-            [$M, "_pointercancel"],
-            [wM, "_pointerover"],
-            [Sb, "_wheel"],
-            [wb, "_contextmenu"],
-            [Mf, "_pointerdown"],
-            [$f, "_pointermove"],
-            [bu, "_pointerup"],
-            [Ff, "_pointercancel"],
-            [B9, "_lostpointercapture"]
+    var q9 = "Stage",
+        H9 = "string",
+        ck = "px",
+        Y9 = "mouseout",
+        FM = "mouseleave",
+        RM = "mouseover",
+        DM = "mouseenter",
+        NM = "mousemove",
+        PM = "mousedown",
+        LM = "mouseup",
+        vf = "pointermove",
+        bf = "pointerdown",
+        lu = "pointerup",
+        xf = "pointercancel",
+        X9 = "lostpointercapture",
+        qd = "pointerout",
+        Hd = "pointerleave",
+        Yd = "pointerover",
+        Xd = "pointerenter",
+        Kv = "contextmenu",
+        IM = "touchstart",
+        zM = "touchend",
+        BM = "touchmove",
+        jM = "touchcancel",
+        Jv = "wheel",
+        V9 = 5,
+        K9 = [
+            [DM, "_pointerenter"],
+            [PM, "_pointerdown"],
+            [NM, "_pointermove"],
+            [LM, "_pointerup"],
+            [FM, "_pointerleave"],
+            [IM, "_pointerdown"],
+            [BM, "_pointermove"],
+            [zM, "_pointerup"],
+            [jM, "_pointercancel"],
+            [RM, "_pointerover"],
+            [Jv, "_wheel"],
+            [Kv, "_contextmenu"],
+            [bf, "_pointerdown"],
+            [vf, "_pointermove"],
+            [lu, "_pointerup"],
+            [xf, "_pointercancel"],
+            [X9, "_lostpointercapture"]
         ];
-    const Ry = {
+    const hy = {
             mouse: {
-                [sg]: z9,
-                [og]: _M,
-                [lg]: wM,
-                [ug]: SM,
-                [$f]: EM,
-                [Mf]: OM,
-                [bu]: CM,
-                [Ff]: "mousecancel",
+                [qd]: Y9,
+                [Hd]: FM,
+                [Yd]: RM,
+                [Xd]: DM,
+                [vf]: NM,
+                [bf]: PM,
+                [lu]: LM,
+                [xf]: "mousecancel",
                 pointerclick: "click",
                 pointerdblclick: "dblclick"
             },
             touch: {
-                [sg]: "touchout",
-                [og]: "touchleave",
-                [lg]: "touchover",
-                [ug]: "touchenter",
-                [$f]: TM,
-                [Mf]: kM,
-                [bu]: AM,
-                [Ff]: $M,
+                [qd]: "touchout",
+                [Hd]: "touchleave",
+                [Yd]: "touchover",
+                [Xd]: "touchenter",
+                [vf]: BM,
+                [bf]: IM,
+                [lu]: zM,
+                [xf]: jM,
                 pointerclick: "tap",
                 pointerdblclick: "dbltap"
             },
             pointer: {
-                [sg]: sg,
-                [og]: og,
-                [lg]: lg,
-                [ug]: ug,
-                [$f]: $f,
-                [Mf]: Mf,
-                [bu]: bu,
-                [Ff]: Ff,
+                [qd]: qd,
+                [Hd]: Hd,
+                [Yd]: Yd,
+                [Xd]: Xd,
+                [vf]: vf,
+                [bf]: bf,
+                [lu]: lu,
+                [xf]: xf,
                 pointerclick: "pointerclick",
                 pointerdblclick: "pointerdblclick"
             }
         },
-        Df = e => e.indexOf("pointer") >= 0 ? "pointer" : e.indexOf("touch") >= 0 ? "touch" : "mouse",
-        eu = e => {
-            const t = Df(e);
-            if (t === "pointer") return le.pointerEventsEnabled && Ry.pointer;
-            if (t === "touch") return Ry.touch;
-            if (t === "mouse") return Ry.mouse
+        _f = e => e.indexOf("pointer") >= 0 ? "pointer" : e.indexOf("touch") >= 0 ? "touch" : "mouse",
+        Gl = e => {
+            const t = _f(e);
+            if (t === "pointer") return le.pointerEventsEnabled && hy.pointer;
+            if (t === "touch") return hy.touch;
+            if (t === "mouse") return hy.mouse
         };
 
-    function JC(e = {}) {
-        return (e.clipFunc || e.clipWidth || e.clipHeight) && R.warn("Stage does not support clipping. Please use clip for Layers or Groups."), e
-    }
-    const q9 = "Pointer position is missing and not registered by the stage. Looks like it is outside of the stage container. You can set it manually from event: stage.setPointersPositions(event);",
-        lp = [];
-    class wm extends vi {
+    function fk(e = {}) {
+        return (e.clipFunc || e.clipWidth || e.clipHeight) && D.warn("Stage does not support clipping. Please use clip for Layers or Groups."), e
+    }
+    const J9 = "Pointer position is missing and not registered by the stage. Looks like it is outside of the stage container. You can set it manually from event: stage.setPointersPositions(event);",
+        Wg = [];
+    class nm extends mi {
         constructor(t) {
-            super(JC(t)), this._pointerPositions = [], this._changedPointerPositions = [], this._buildDOM(), this._bindContentEvents(), lp.push(this), this.on("widthChange.konva heightChange.konva", this._resizeDOM), this.on("visibleChange.konva", this._checkVisibility), this.on("clipWidthChange.konva clipHeightChange.konva clipFuncChange.konva", () => {
-                JC(this.attrs)
+            super(fk(t)), this._pointerPositions = [], this._changedPointerPositions = [], this._buildDOM(), this._bindContentEvents(), Wg.push(this), this.on("widthChange.konva heightChange.konva", this._resizeDOM), this.on("visibleChange.konva", this._checkVisibility), this.on("clipWidthChange.konva clipHeightChange.konva clipFuncChange.konva", () => {
+                fk(this.attrs)
             }), this._checkVisibility()
         }
         _validateAdd(t) {
             const n = t.getType() === "Layer",
                 i = t.getType() === "FastLayer";
-            n || i || R.throw("You may only add layers to the stage.")
+            n || i || D.throw("You may only add layers to the stage.")
         }
         _checkVisibility() {
             if (!this.content) return;
             const t = this.visible() ? "" : "none";
             this.content.style.display = t
         }
         setContainer(t) {
-            if (typeof t === j9) {
+            if (typeof t === H9) {
                 if (t.charAt(0) === ".") {
                     var n = t.slice(1);
                     t = document.getElementsByClassName(n)[0]
                 } else {
                     var i;
                     t.charAt(0) !== "#" ? i = t : i = t.slice(1), t = document.getElementById(i)
                 }
@@ -3110,29 +3110,29 @@
             var t = this.children,
                 n = t.length,
                 i;
             for (i = 0; i < n; i++) t[i].clear();
             return this
         }
         clone(t) {
-            return t || (t = {}), t.container = typeof document < "u" && document.createElement("div"), vi.prototype.clone.call(this, t)
+            return t || (t = {}), t.container = typeof document < "u" && document.createElement("div"), mi.prototype.clone.call(this, t)
         }
         destroy() {
             super.destroy();
             var t = this.content;
-            t && R._isInDocument(t) && this.container().removeChild(t);
-            var n = lp.indexOf(this);
-            return n > -1 && lp.splice(n, 1), R.releaseCanvas(this.bufferCanvas._canvas, this.bufferHitCanvas._canvas), this
+            t && D._isInDocument(t) && this.container().removeChild(t);
+            var n = Wg.indexOf(this);
+            return n > -1 && Wg.splice(n, 1), D.releaseCanvas(this.bufferCanvas._canvas, this.bufferHitCanvas._canvas), this
         }
         getPointerPosition() {
             const t = this._pointerPositions[0] || this._changedPointerPositions[0];
             return t ? {
                 x: t.x,
                 y: t.y
-            } : (R.warn(q9), null)
+            } : (D.warn(J9), null)
         }
         _getPointerById(t) {
             return this._pointerPositions.find(n => n.id === t)
         }
         getPointersPositions() {
             return this._pointerPositions
         }
@@ -3140,219 +3140,219 @@
             return this
         }
         getContent() {
             return this.content
         }
         _toKonvaCanvas(t) {
             t = t || {}, t.x = t.x || 0, t.y = t.y || 0, t.width = t.width || this.width(), t.height = t.height || this.height();
-            var n = new Tu({
+            var n = new vu({
                     width: t.width,
                     height: t.height,
                     pixelRatio: t.pixelRatio || 1
                 }),
                 i = n.getContext()._context,
                 r = this.children;
-            return (t.x || t.y) && i.translate(-1 * t.x, -1 * t.y), r.forEach(function(a) {
-                if (a.isVisible()) {
-                    var s = a._toKonvaCanvas(t);
-                    i.drawImage(s._canvas, t.x, t.y, s.getWidth() / s.getPixelRatio(), s.getHeight() / s.getPixelRatio())
+            return (t.x || t.y) && i.translate(-1 * t.x, -1 * t.y), r.forEach(function(s) {
+                if (s.isVisible()) {
+                    var a = s._toKonvaCanvas(t);
+                    i.drawImage(a._canvas, t.x, t.y, a.getWidth() / a.getPixelRatio(), a.getHeight() / a.getPixelRatio())
                 }
             }), n
         }
         getIntersection(t) {
             if (!t) return null;
             var n = this.children,
                 i = n.length,
                 r = i - 1,
-                a;
-            for (a = r; a >= 0; a--) {
-                const s = n[a].getIntersection(t);
-                if (s) return s
+                s;
+            for (s = r; s >= 0; s--) {
+                const a = n[s].getIntersection(t);
+                if (a) return a
             }
             return null
         }
         _resizeDOM() {
             var t = this.width(),
                 n = this.height();
-            this.content && (this.content.style.width = t + KC, this.content.style.height = n + KC), this.bufferCanvas.setSize(t, n), this.bufferHitCanvas.setSize(t, n), this.children.forEach(i => {
+            this.content && (this.content.style.width = t + ck, this.content.style.height = n + ck), this.bufferCanvas.setSize(t, n), this.bufferHitCanvas.setSize(t, n), this.children.forEach(i => {
                 i.setSize({
                     width: t,
                     height: n
                 }), i.draw()
             })
         }
         add(t, ...n) {
             if (arguments.length > 1) {
                 for (var i = 0; i < arguments.length; i++) this.add(arguments[i]);
                 return this
             }
             super.add(t);
             var r = this.children.length;
-            return r > G9 && R.warn("The stage has " + r + " layers. Recommended maximum number of layers is 3-5. Adding more layers into the stage may drop the performance. Rethink your tree structure, you can use Konva.Group."), t.setSize({
+            return r > V9 && D.warn("The stage has " + r + " layers. Recommended maximum number of layers is 3-5. Adding more layers into the stage may drop the performance. Rethink your tree structure, you can use Konva.Group."), t.setSize({
                 width: this.width(),
                 height: this.height()
             }), t.draw(), le.isBrowser && this.content.appendChild(t.canvas._canvas), this
         }
         getParent() {
             return null
         }
         getLayer() {
             return null
         }
         hasPointerCapture(t) {
-            return bM(t, this)
+            return MM(t, this)
         }
         setPointerCapture(t) {
-            xM(t, this)
+            OM(t, this)
         }
         releaseCapture(t) {
-            ah(t)
+            Yf(t)
         }
         getLayers() {
             return this.children
         }
         _bindContentEvents() {
-            le.isBrowser && U9.forEach(([t, n]) => {
+            le.isBrowser && K9.forEach(([t, n]) => {
                 this.content.addEventListener(t, i => {
                     this[n](i)
                 }, {
                     passive: !1
                 })
             })
         }
         _pointerenter(t) {
             this.setPointersPositions(t);
-            const n = eu(t.type);
+            const n = Gl(t.type);
             this._fire(n.pointerenter, {
                 evt: t,
                 target: this,
                 currentTarget: this
             })
         }
         _pointerover(t) {
             this.setPointersPositions(t);
-            const n = eu(t.type);
+            const n = Gl(t.type);
             this._fire(n.pointerover, {
                 evt: t,
                 target: this,
                 currentTarget: this
             })
         }
         _getTargetShape(t) {
             let n = this[t + "targetShape"];
             return n && !n.getStage() && (n = null), n
         }
         _pointerleave(t) {
-            const n = eu(t.type),
-                i = Df(t.type);
+            const n = Gl(t.type),
+                i = _f(t.type);
             if (n) {
                 this.setPointersPositions(t);
                 var r = this._getTargetShape(i),
-                    a = !Be.isDragging || le.hitOnDragEnabled;
-                r && a ? (r._fireAndBubble(n.pointerout, {
+                    s = !je.isDragging || le.hitOnDragEnabled;
+                r && s ? (r._fireAndBubble(n.pointerout, {
                     evt: t
                 }), r._fireAndBubble(n.pointerleave, {
                     evt: t
                 }), this._fire(n.pointerleave, {
                     evt: t,
                     target: this,
                     currentTarget: this
-                }), this[i + "targetShape"] = null) : a && (this._fire(n.pointerleave, {
+                }), this[i + "targetShape"] = null) : s && (this._fire(n.pointerleave, {
                     evt: t,
                     target: this,
                     currentTarget: this
                 }), this._fire(n.pointerout, {
                     evt: t,
                     target: this,
                     currentTarget: this
                 })), this.pointerPos = void 0, this._pointerPositions = []
             }
         }
         _pointerdown(t) {
-            const n = eu(t.type),
-                i = Df(t.type);
+            const n = Gl(t.type),
+                i = _f(t.type);
             if (n) {
                 this.setPointersPositions(t);
                 var r = !1;
-                this._changedPointerPositions.forEach(a => {
-                    var s = this.getIntersection(a);
-                    if (Be.justDragged = !1, le["_" + i + "ListenClick"] = !0, !(s && s.isListening())) return;
-                    le.capturePointerEventsEnabled && s.setPointerCapture(a.id), this[i + "ClickStartShape"] = s, s._fireAndBubble(n.pointerdown, {
+                this._changedPointerPositions.forEach(s => {
+                    var a = this.getIntersection(s);
+                    if (je.justDragged = !1, le["_" + i + "ListenClick"] = !0, !(a && a.isListening())) return;
+                    le.capturePointerEventsEnabled && a.setPointerCapture(s.id), this[i + "ClickStartShape"] = a, a._fireAndBubble(n.pointerdown, {
                         evt: t,
-                        pointerId: a.id
+                        pointerId: s.id
                     }), r = !0;
                     const l = t.type.indexOf("touch") >= 0;
-                    s.preventDefault() && t.cancelable && l && t.preventDefault()
+                    a.preventDefault() && t.cancelable && l && t.preventDefault()
                 }), r || this._fire(n.pointerdown, {
                     evt: t,
                     target: this,
                     currentTarget: this,
                     pointerId: this._pointerPositions[0].id
                 })
             }
         }
         _pointermove(t) {
-            const n = eu(t.type),
-                i = Df(t.type);
+            const n = Gl(t.type),
+                i = _f(t.type);
             if (!n) return;
-            Be.isDragging && Be.node.preventDefault() && t.cancelable && t.preventDefault(), this.setPointersPositions(t);
-            var r = !Be.isDragging || le.hitOnDragEnabled;
+            je.isDragging && je.node.preventDefault() && t.cancelable && t.preventDefault(), this.setPointersPositions(t);
+            var r = !je.isDragging || le.hitOnDragEnabled;
             if (!r) return;
-            var a = {};
-            let s = !1;
+            var s = {};
+            let a = !1;
             var o = this._getTargetShape(i);
             this._changedPointerPositions.forEach(l => {
-                const u = Dy(l.id) || this.getIntersection(l),
+                const u = fy(l.id) || this.getIntersection(l),
                     c = l.id,
                     f = {
                         evt: t,
                         pointerId: c
                     };
                 var h = o !== u;
                 if (h && o && (o._fireAndBubble(n.pointerout, Object.assign({}, f), u), o._fireAndBubble(n.pointerleave, Object.assign({}, f), u)), u) {
-                    if (a[u._id]) return;
-                    a[u._id] = !0
+                    if (s[u._id]) return;
+                    s[u._id] = !0
                 }
-                u && u.isListening() ? (s = !0, h && (u._fireAndBubble(n.pointerover, Object.assign({}, f), o), u._fireAndBubble(n.pointerenter, Object.assign({}, f), o), this[i + "targetShape"] = u), u._fireAndBubble(n.pointermove, Object.assign({}, f))) : o && (this._fire(n.pointerover, {
+                u && u.isListening() ? (a = !0, h && (u._fireAndBubble(n.pointerover, Object.assign({}, f), o), u._fireAndBubble(n.pointerenter, Object.assign({}, f), o), this[i + "targetShape"] = u), u._fireAndBubble(n.pointermove, Object.assign({}, f))) : o && (this._fire(n.pointerover, {
                     evt: t,
                     target: this,
                     currentTarget: this,
                     pointerId: c
                 }), this[i + "targetShape"] = null)
-            }), s || this._fire(n.pointermove, {
+            }), a || this._fire(n.pointermove, {
                 evt: t,
                 target: this,
                 currentTarget: this,
                 pointerId: this._changedPointerPositions[0].id
             })
         }
         _pointerup(t) {
-            const n = eu(t.type),
-                i = Df(t.type);
+            const n = Gl(t.type),
+                i = _f(t.type);
             if (!n) return;
             this.setPointersPositions(t);
             const r = this[i + "ClickStartShape"],
-                a = this[i + "ClickEndShape"];
-            var s = {};
+                s = this[i + "ClickEndShape"];
+            var a = {};
             let o = !1;
             this._changedPointerPositions.forEach(l => {
-                const u = Dy(l.id) || this.getIntersection(l);
+                const u = fy(l.id) || this.getIntersection(l);
                 if (u) {
-                    if (u.releaseCapture(l.id), s[u._id]) return;
-                    s[u._id] = !0
+                    if (u.releaseCapture(l.id), a[u._id]) return;
+                    a[u._id] = !0
                 }
                 const c = l.id,
                     f = {
                         evt: t,
                         pointerId: c
                     };
                 let h = !1;
-                le["_" + i + "InDblClickWindow"] ? (h = !0, clearTimeout(this[i + "DblTimeout"])) : Be.justDragged || (le["_" + i + "InDblClickWindow"] = !0, clearTimeout(this[i + "DblTimeout"])), this[i + "DblTimeout"] = setTimeout(function() {
+                le["_" + i + "InDblClickWindow"] ? (h = !0, clearTimeout(this[i + "DblTimeout"])) : je.justDragged || (le["_" + i + "InDblClickWindow"] = !0, clearTimeout(this[i + "DblTimeout"])), this[i + "DblTimeout"] = setTimeout(function() {
                     le["_" + i + "InDblClickWindow"] = !1
-                }, le.dblClickWindow), u && u.isListening() ? (o = !0, this[i + "ClickEndShape"] = u, u._fireAndBubble(n.pointerup, Object.assign({}, f)), le["_" + i + "ListenClick"] && r && r === u && (u._fireAndBubble(n.pointerclick, Object.assign({}, f)), h && a && a === u && u._fireAndBubble(n.pointerdblclick, Object.assign({}, f)))) : (this[i + "ClickEndShape"] = null, le["_" + i + "ListenClick"] && this._fire(n.pointerclick, {
+                }, le.dblClickWindow), u && u.isListening() ? (o = !0, this[i + "ClickEndShape"] = u, u._fireAndBubble(n.pointerup, Object.assign({}, f)), le["_" + i + "ListenClick"] && r && r === u && (u._fireAndBubble(n.pointerclick, Object.assign({}, f)), h && s && s === u && u._fireAndBubble(n.pointerdblclick, Object.assign({}, f)))) : (this[i + "ClickEndShape"] = null, le["_" + i + "ListenClick"] && this._fire(n.pointerclick, {
                     evt: t,
                     target: this,
                     currentTarget: this,
                     pointerId: c
                 }), h && this._fire(n.pointerdblclick, {
                     evt: t,
                     target: this,
@@ -3365,72 +3365,72 @@
                 currentTarget: this,
                 pointerId: this._changedPointerPositions[0].id
             }), le["_" + i + "ListenClick"] = !1, t.cancelable && i !== "touch" && t.preventDefault()
         }
         _contextmenu(t) {
             this.setPointersPositions(t);
             var n = this.getIntersection(this.getPointerPosition());
-            n && n.isListening() ? n._fireAndBubble(wb, {
+            n && n.isListening() ? n._fireAndBubble(Kv, {
                 evt: t
-            }) : this._fire(wb, {
+            }) : this._fire(Kv, {
                 evt: t,
                 target: this,
                 currentTarget: this
             })
         }
         _wheel(t) {
             this.setPointersPositions(t);
             var n = this.getIntersection(this.getPointerPosition());
-            n && n.isListening() ? n._fireAndBubble(Sb, {
+            n && n.isListening() ? n._fireAndBubble(Jv, {
                 evt: t
-            }) : this._fire(Sb, {
+            }) : this._fire(Jv, {
                 evt: t,
                 target: this,
                 currentTarget: this
             })
         }
         _pointercancel(t) {
             this.setPointersPositions(t);
-            const n = Dy(t.pointerId) || this.getIntersection(this.getPointerPosition());
-            n && n._fireAndBubble(bu, Zx(t)), ah(t.pointerId)
+            const n = fy(t.pointerId) || this.getIntersection(this.getPointerPosition());
+            n && n._fireAndBubble(lu, vx(t)), Yf(t.pointerId)
         }
         _lostpointercapture(t) {
-            ah(t.pointerId)
+            Yf(t.pointerId)
         }
         setPointersPositions(t) {
             var n = this._getContentPosition(),
                 i = null,
                 r = null;
-            t = t || window.event, t.touches !== void 0 ? (this._pointerPositions = [], this._changedPointerPositions = [], Array.prototype.forEach.call(t.touches, a => {
+            t = t || window.event, t.touches !== void 0 ? (this._pointerPositions = [], this._changedPointerPositions = [], Array.prototype.forEach.call(t.touches, s => {
                 this._pointerPositions.push({
-                    id: a.identifier,
-                    x: (a.clientX - n.left) / n.scaleX,
-                    y: (a.clientY - n.top) / n.scaleY
+                    id: s.identifier,
+                    x: (s.clientX - n.left) / n.scaleX,
+                    y: (s.clientY - n.top) / n.scaleY
                 })
-            }), Array.prototype.forEach.call(t.changedTouches || t.touches, a => {
+            }), Array.prototype.forEach.call(t.changedTouches || t.touches, s => {
                 this._changedPointerPositions.push({
-                    id: a.identifier,
-                    x: (a.clientX - n.left) / n.scaleX,
-                    y: (a.clientY - n.top) / n.scaleY
+                    id: s.identifier,
+                    x: (s.clientX - n.left) / n.scaleX,
+                    y: (s.clientY - n.top) / n.scaleY
                 })
             })) : (i = (t.clientX - n.left) / n.scaleX, r = (t.clientY - n.top) / n.scaleY, this.pointerPos = {
                 x: i,
                 y: r
             }, this._pointerPositions = [{
                 x: i,
                 y: r,
-                id: R._getFirstPointerId(t)
+                id: D._getFirstPointerId(t)
             }], this._changedPointerPositions = [{
                 x: i,
                 y: r,
-                id: R._getFirstPointerId(t)
+                id: D._getFirstPointerId(t)
             }])
         }
         _setPointerPosition(t) {
-            R.warn('Method _setPointerPosition is deprecated. Use "stage.setPointersPositions(event)" instead.'), this.setPointersPositions(t)
+            D.warn('Method _setPointerPosition is deprecated. Use "stage.setPointersPositions(event)" instead.'), this.setPointersPositions(t)
         }
         _getContentPosition() {
             if (!this.content || !this.content.getBoundingClientRect) return {
                 top: 0,
                 left: 0,
                 scaleX: 1,
                 scaleY: 1
@@ -3440,164 +3440,164 @@
                 top: t.top,
                 left: t.left,
                 scaleX: t.width / this.content.clientWidth || 1,
                 scaleY: t.height / this.content.clientHeight || 1
             }
         }
         _buildDOM() {
-            if (this.bufferCanvas = new Tu({
+            if (this.bufferCanvas = new vu({
                     width: this.width(),
                     height: this.height()
-                }), this.bufferHitCanvas = new Qx({
+                }), this.bufferHitCanvas = new yx({
                     pixelRatio: 1,
                     width: this.width(),
                     height: this.height()
                 }), !!le.isBrowser) {
                 var t = this.container();
                 if (!t) throw "Stage has no container. A container is required.";
                 t.innerHTML = "", this.content = document.createElement("div"), this.content.style.position = "relative", this.content.style.userSelect = "none", this.content.className = "konvajs-content", this.content.setAttribute("role", "presentation"), t.appendChild(this.content), this._resizeDOM()
             }
         }
         cache() {
-            return R.warn("Cache function is not allowed for stage. You may use cache only for layers, groups and shapes."), this
+            return D.warn("Cache function is not allowed for stage. You may use cache only for layers, groups and shapes."), this
         }
         clearCache() {
             return this
         }
         batchDraw() {
             return this.getChildren().forEach(function(t) {
                 t.batchDraw()
             }), this
         }
     }
-    wm.prototype.nodeType = I9;
-    mt(wm);
-    M.addGetterSetter(wm, "container");
-    var MM = "hasShadow",
-        FM = "shadowRGBA",
-        DM = "patternImage",
-        RM = "linearGradient",
-        PM = "radialGradient";
-    let cg;
+    nm.prototype.nodeType = q9;
+    pt(nm);
+    O.addGetterSetter(nm, "container");
+    var UM = "hasShadow",
+        GM = "shadowRGBA",
+        WM = "patternImage",
+        qM = "linearGradient",
+        HM = "radialGradient";
+    let Vd;
 
-    function Py() {
-        return cg || (cg = R.createCanvasElement().getContext("2d"), cg)
+    function dy() {
+        return Vd || (Vd = D.createCanvasElement().getContext("2d"), Vd)
     }
-    const sh = {};
+    const Xf = {};
 
-    function W9(e) {
+    function Q9(e) {
         e.fill()
     }
 
-    function H9(e) {
+    function Z9(e) {
         e.stroke()
     }
 
-    function Y9(e) {
+    function e7(e) {
         e.fill()
     }
 
-    function X9(e) {
+    function t7(e) {
         e.stroke()
     }
 
-    function V9() {
-        this._clearCache(MM)
+    function n7() {
+        this._clearCache(UM)
     }
 
-    function K9() {
-        this._clearCache(FM)
+    function i7() {
+        this._clearCache(GM)
     }
 
-    function J9() {
-        this._clearCache(DM)
+    function r7() {
+        this._clearCache(WM)
     }
 
-    function Q9() {
-        this._clearCache(RM)
+    function s7() {
+        this._clearCache(qM)
     }
 
-    function Z9() {
-        this._clearCache(PM)
+    function a7() {
+        this._clearCache(HM)
     }
-    let V = class extends te {
+    let V = class extends ne {
         constructor(t) {
             super(t);
             let n;
-            for (; n = R.getRandomColor(), !(n && !(n in sh)););
-            this.colorKey = n, sh[n] = this
+            for (; n = D.getRandomColor(), !(n && !(n in Xf)););
+            this.colorKey = n, Xf[n] = this
         }
         getContext() {
-            return R.warn("shape.getContext() method is deprecated. Please do not use it."), this.getLayer().getContext()
+            return D.warn("shape.getContext() method is deprecated. Please do not use it."), this.getLayer().getContext()
         }
         getCanvas() {
-            return R.warn("shape.getCanvas() method is deprecated. Please do not use it."), this.getLayer().getCanvas()
+            return D.warn("shape.getCanvas() method is deprecated. Please do not use it."), this.getLayer().getCanvas()
         }
         getSceneFunc() {
             return this.attrs.sceneFunc || this._sceneFunc
         }
         getHitFunc() {
             return this.attrs.hitFunc || this._hitFunc
         }
         hasShadow() {
-            return this._getCache(MM, this._hasShadow)
+            return this._getCache(UM, this._hasShadow)
         }
         _hasShadow() {
             return this.shadowEnabled() && this.shadowOpacity() !== 0 && !!(this.shadowColor() || this.shadowBlur() || this.shadowOffsetX() || this.shadowOffsetY())
         }
         _getFillPattern() {
-            return this._getCache(DM, this.__getFillPattern)
+            return this._getCache(WM, this.__getFillPattern)
         }
         __getFillPattern() {
             if (this.fillPatternImage()) {
-                var t = Py();
+                var t = dy();
                 const n = t.createPattern(this.fillPatternImage(), this.fillPatternRepeat() || "repeat");
                 if (n && n.setTransform) {
-                    const i = new ir;
+                    const i = new Ki;
                     i.translate(this.fillPatternX(), this.fillPatternY()), i.rotate(le.getAngle(this.fillPatternRotation())), i.scale(this.fillPatternScaleX(), this.fillPatternScaleY()), i.translate(-1 * this.fillPatternOffsetX(), -1 * this.fillPatternOffsetY());
                     const r = i.getMatrix(),
-                        a = typeof DOMMatrix > "u" ? {
+                        s = typeof DOMMatrix > "u" ? {
                             a: r[0],
                             b: r[1],
                             c: r[2],
                             d: r[3],
                             e: r[4],
                             f: r[5]
                         } : new DOMMatrix(r);
-                    n.setTransform(a)
+                    n.setTransform(s)
                 }
                 return n
             }
         }
         _getLinearGradient() {
-            return this._getCache(RM, this.__getLinearGradient)
+            return this._getCache(qM, this.__getLinearGradient)
         }
         __getLinearGradient() {
             var t = this.fillLinearGradientColorStops();
             if (t) {
-                for (var n = Py(), i = this.fillLinearGradientStartPoint(), r = this.fillLinearGradientEndPoint(), a = n.createLinearGradient(i.x, i.y, r.x, r.y), s = 0; s < t.length; s += 2) a.addColorStop(t[s], t[s + 1]);
-                return a
+                for (var n = dy(), i = this.fillLinearGradientStartPoint(), r = this.fillLinearGradientEndPoint(), s = n.createLinearGradient(i.x, i.y, r.x, r.y), a = 0; a < t.length; a += 2) s.addColorStop(t[a], t[a + 1]);
+                return s
             }
         }
         _getRadialGradient() {
-            return this._getCache(PM, this.__getRadialGradient)
+            return this._getCache(HM, this.__getRadialGradient)
         }
         __getRadialGradient() {
             var t = this.fillRadialGradientColorStops();
             if (t) {
-                for (var n = Py(), i = this.fillRadialGradientStartPoint(), r = this.fillRadialGradientEndPoint(), a = n.createRadialGradient(i.x, i.y, this.fillRadialGradientStartRadius(), r.x, r.y, this.fillRadialGradientEndRadius()), s = 0; s < t.length; s += 2) a.addColorStop(t[s], t[s + 1]);
-                return a
+                for (var n = dy(), i = this.fillRadialGradientStartPoint(), r = this.fillRadialGradientEndPoint(), s = n.createRadialGradient(i.x, i.y, this.fillRadialGradientStartRadius(), r.x, r.y, this.fillRadialGradientEndRadius()), a = 0; a < t.length; a += 2) s.addColorStop(t[a], t[a + 1]);
+                return s
             }
         }
         getShadowRGBA() {
-            return this._getCache(FM, this._getShadowRGBA)
+            return this._getCache(GM, this._getShadowRGBA)
         }
         _getShadowRGBA() {
             if (this.hasShadow()) {
-                var t = R.colorToRGBA(this.shadowColor());
+                var t = D.colorToRGBA(this.shadowColor());
                 if (t) return "rgba(" + t.r + "," + t.g + "," + t.b + "," + t.a * (this.shadowOpacity() || 1) + ")"
             }
         }
         hasFill() {
             return this._calculate("hasFill", ["fillEnabled", "fill", "fillPatternImage", "fillLinearGradientColorStops", "fillRadialGradientColorStops"], () => this.fillEnabled() && !!(this.fill() || this.fillPatternImage() || this.fillLinearGradientColorStops() || this.fillRadialGradientColorStops()))
         }
         hasStroke() {
@@ -3610,29 +3610,29 @@
         intersects(t) {
             var n = this.getStage(),
                 i = n.bufferHitCanvas,
                 r;
             return i.getContext().clear(), this.drawHit(i, null, !0), r = i.context.getImageData(Math.round(t.x), Math.round(t.y), 1, 1).data, r[3] > 0
         }
         destroy() {
-            return te.prototype.destroy.call(this), delete sh[this.colorKey], delete this.colorKey, this
+            return ne.prototype.destroy.call(this), delete Xf[this.colorKey], delete this.colorKey, this
         }
         _useBufferCanvas(t) {
             var n;
             if (!this.getStage() || !((n = this.attrs.perfectDrawEnabled) !== null && n !== void 0 ? n : !0)) return !1;
             const r = t || this.hasFill(),
-                a = this.hasStroke(),
-                s = this.getAbsoluteOpacity() !== 1;
-            if (r && a && s) return !0;
+                s = this.hasStroke(),
+                a = this.getAbsoluteOpacity() !== 1;
+            if (r && s && a) return !0;
             const o = this.hasShadow(),
                 l = this.shadowForStrokeEnabled();
-            return !!(r && a && o && l)
+            return !!(r && s && o && l)
         }
         setStrokeHitEnabled(t) {
-            R.warn("strokeHitEnabled property is deprecated. Please use hitStrokeWidth instead."), t ? this.hitStrokeWidth("auto") : this.hitStrokeWidth(0)
+            D.warn("strokeHitEnabled property is deprecated. Please use hitStrokeWidth instead."), t ? this.hitStrokeWidth("auto") : this.hitStrokeWidth(0)
         }
         getStrokeHitEnabled() {
             return this.hitStrokeWidth() !== 0
         }
         getSelfRect() {
             var t = this.size();
             return {
@@ -3642,199 +3642,199 @@
                 height: t.height
             }
         }
         getClientRect(t = {}) {
             const n = t.skipTransform,
                 i = t.relativeTo,
                 r = this.getSelfRect(),
-                s = !t.skipStroke && this.hasStroke() && this.strokeWidth() || 0,
-                o = r.width + s,
-                l = r.height + s,
+                a = !t.skipStroke && this.hasStroke() && this.strokeWidth() || 0,
+                o = r.width + a,
+                l = r.height + a,
                 u = !t.skipShadow && this.hasShadow(),
                 c = u ? this.shadowOffsetX() : 0,
                 f = u ? this.shadowOffsetY() : 0,
                 h = o + Math.abs(c),
                 d = l + Math.abs(f),
                 g = u && this.shadowBlur() || 0,
                 p = h + g * 2,
                 m = d + g * 2,
                 y = {
                     width: p,
                     height: m,
-                    x: -(s / 2 + g) + Math.min(c, 0) + r.x,
-                    y: -(s / 2 + g) + Math.min(f, 0) + r.y
+                    x: -(a / 2 + g) + Math.min(c, 0) + r.x,
+                    y: -(a / 2 + g) + Math.min(f, 0) + r.y
                 };
             return n ? y : this._transformedRect(y, i)
         }
         drawScene(t, n) {
             var i = this.getLayer(),
                 r = t || i.getCanvas(),
-                a = r.getContext(),
-                s = this._getCanvasCache(),
+                s = r.getContext(),
+                a = this._getCanvasCache(),
                 o = this.getSceneFunc(),
                 l = this.hasShadow(),
                 u, c, f, h = r.isCache,
                 d = n === this;
             if (!this.isVisible() && !d) return this;
-            if (s) {
-                a.save();
+            if (a) {
+                s.save();
                 var g = this.getAbsoluteTransform(n).getMatrix();
-                return a.transform(g[0], g[1], g[2], g[3], g[4], g[5]), this._drawCachedSceneCanvas(a), a.restore(), this
+                return s.transform(g[0], g[1], g[2], g[3], g[4], g[5]), this._drawCachedSceneCanvas(s), s.restore(), this
             }
             if (!o) return this;
-            if (a.save(), this._useBufferCanvas() && !h) {
+            if (s.save(), this._useBufferCanvas() && !h) {
                 u = this.getStage(), c = u.bufferCanvas, f = c.getContext(), f.clear(), f.save(), f._applyLineJoin(this);
                 var p = this.getAbsoluteTransform(n).getMatrix();
                 f.transform(p[0], p[1], p[2], p[3], p[4], p[5]), o.call(this, f, this), f.restore();
                 var m = c.pixelRatio;
-                l && a._applyShadow(this), a._applyOpacity(this), a._applyGlobalCompositeOperation(this), a.drawImage(c._canvas, 0, 0, c.width / m, c.height / m)
+                l && s._applyShadow(this), s._applyOpacity(this), s._applyGlobalCompositeOperation(this), s.drawImage(c._canvas, 0, 0, c.width / m, c.height / m)
             } else {
-                if (a._applyLineJoin(this), !d) {
+                if (s._applyLineJoin(this), !d) {
                     var p = this.getAbsoluteTransform(n).getMatrix();
-                    a.transform(p[0], p[1], p[2], p[3], p[4], p[5]), a._applyOpacity(this), a._applyGlobalCompositeOperation(this)
+                    s.transform(p[0], p[1], p[2], p[3], p[4], p[5]), s._applyOpacity(this), s._applyGlobalCompositeOperation(this)
                 }
-                l && a._applyShadow(this), o.call(this, a, this)
+                l && s._applyShadow(this), o.call(this, s, this)
             }
-            return a.restore(), this
+            return s.restore(), this
         }
         drawHit(t, n, i = !1) {
             if (!this.shouldDrawHit(n, i)) return this;
             var r = this.getLayer(),
-                a = t || r.hitCanvas,
-                s = a && a.getContext(),
+                s = t || r.hitCanvas,
+                a = s && s.getContext(),
                 o = this.hitFunc() || this.sceneFunc(),
                 l = this._getCanvasCache(),
                 u = l && l.hit;
-            if (this.colorKey || R.warn("Looks like your canvas has a destroyed shape in it. Do not reuse shape after you destroyed it. If you want to reuse shape you should call remove() instead of destroy()"), u) {
-                s.save();
+            if (this.colorKey || D.warn("Looks like your canvas has a destroyed shape in it. Do not reuse shape after you destroyed it. If you want to reuse shape you should call remove() instead of destroy()"), u) {
+                a.save();
                 var c = this.getAbsoluteTransform(n).getMatrix();
-                return s.transform(c[0], c[1], c[2], c[3], c[4], c[5]), this._drawCachedHitCanvas(s), s.restore(), this
+                return a.transform(c[0], c[1], c[2], c[3], c[4], c[5]), this._drawCachedHitCanvas(a), a.restore(), this
             }
             if (!o) return this;
-            if (s.save(), s._applyLineJoin(this), !(this === n)) {
+            if (a.save(), a._applyLineJoin(this), !(this === n)) {
                 var h = this.getAbsoluteTransform(n).getMatrix();
-                s.transform(h[0], h[1], h[2], h[3], h[4], h[5])
+                a.transform(h[0], h[1], h[2], h[3], h[4], h[5])
             }
-            return o.call(this, s, this), s.restore(), this
+            return o.call(this, a, this), a.restore(), this
         }
         drawHitFromCache(t = 0) {
             var n = this._getCanvasCache(),
                 i = this._getCachedSceneCanvas(),
                 r = n.hit,
-                a = r.getContext(),
-                s = r.getWidth(),
+                s = r.getContext(),
+                a = r.getWidth(),
                 o = r.getHeight(),
                 l, u, c, f, h, d;
-            a.clear(), a.drawImage(i._canvas, 0, 0, s, o);
+            s.clear(), s.drawImage(i._canvas, 0, 0, a, o);
             try {
-                for (l = a.getImageData(0, 0, s, o), u = l.data, c = u.length, f = R._hexToRgb(this.colorKey), h = 0; h < c; h += 4) d = u[h + 3], d > t ? (u[h] = f.r, u[h + 1] = f.g, u[h + 2] = f.b, u[h + 3] = 255) : u[h + 3] = 0;
-                a.putImageData(l, 0, 0)
+                for (l = s.getImageData(0, 0, a, o), u = l.data, c = u.length, f = D._hexToRgb(this.colorKey), h = 0; h < c; h += 4) d = u[h + 3], d > t ? (u[h] = f.r, u[h + 1] = f.g, u[h + 2] = f.b, u[h + 3] = 255) : u[h + 3] = 0;
+                s.putImageData(l, 0, 0)
             } catch (g) {
-                R.error("Unable to draw hit graph from cached scene canvas. " + g.message)
+                D.error("Unable to draw hit graph from cached scene canvas. " + g.message)
             }
             return this
         }
         hasPointerCapture(t) {
-            return bM(t, this)
+            return MM(t, this)
         }
         setPointerCapture(t) {
-            xM(t, this)
+            OM(t, this)
         }
         releaseCapture(t) {
-            ah(t)
+            Yf(t)
         }
     };
-    V.prototype._fillFunc = W9;
-    V.prototype._strokeFunc = H9;
-    V.prototype._fillFuncHit = Y9;
-    V.prototype._strokeFuncHit = X9;
+    V.prototype._fillFunc = Q9;
+    V.prototype._strokeFunc = Z9;
+    V.prototype._fillFuncHit = e7;
+    V.prototype._strokeFuncHit = t7;
     V.prototype._centroid = !1;
     V.prototype.nodeType = "Shape";
-    mt(V);
+    pt(V);
     V.prototype.eventListeners = {};
-    V.prototype.on.call(V.prototype, "shadowColorChange.konva shadowBlurChange.konva shadowOffsetChange.konva shadowOpacityChange.konva shadowEnabledChange.konva", V9);
-    V.prototype.on.call(V.prototype, "shadowColorChange.konva shadowOpacityChange.konva shadowEnabledChange.konva", K9);
-    V.prototype.on.call(V.prototype, "fillPriorityChange.konva fillPatternImageChange.konva fillPatternRepeatChange.konva fillPatternScaleXChange.konva fillPatternScaleYChange.konva fillPatternOffsetXChange.konva fillPatternOffsetYChange.konva fillPatternXChange.konva fillPatternYChange.konva fillPatternRotationChange.konva", J9);
-    V.prototype.on.call(V.prototype, "fillPriorityChange.konva fillLinearGradientColorStopsChange.konva fillLinearGradientStartPointXChange.konva fillLinearGradientStartPointYChange.konva fillLinearGradientEndPointXChange.konva fillLinearGradientEndPointYChange.konva", Q9);
-    V.prototype.on.call(V.prototype, "fillPriorityChange.konva fillRadialGradientColorStopsChange.konva fillRadialGradientStartPointXChange.konva fillRadialGradientStartPointYChange.konva fillRadialGradientEndPointXChange.konva fillRadialGradientEndPointYChange.konva fillRadialGradientStartRadiusChange.konva fillRadialGradientEndRadiusChange.konva", Z9);
-    M.addGetterSetter(V, "stroke", void 0, yM());
-    M.addGetterSetter(V, "strokeWidth", 2, ee());
-    M.addGetterSetter(V, "fillAfterStrokeEnabled", !1);
-    M.addGetterSetter(V, "hitStrokeWidth", "auto", Jx());
-    M.addGetterSetter(V, "strokeHitEnabled", !0, Sr());
-    M.addGetterSetter(V, "perfectDrawEnabled", !0, Sr());
-    M.addGetterSetter(V, "shadowForStrokeEnabled", !0, Sr());
-    M.addGetterSetter(V, "lineJoin");
-    M.addGetterSetter(V, "lineCap");
-    M.addGetterSetter(V, "sceneFunc");
-    M.addGetterSetter(V, "hitFunc");
-    M.addGetterSetter(V, "dash");
-    M.addGetterSetter(V, "dashOffset", 0, ee());
-    M.addGetterSetter(V, "shadowColor", void 0, Ec());
-    M.addGetterSetter(V, "shadowBlur", 0, ee());
-    M.addGetterSetter(V, "shadowOpacity", 1, ee());
-    M.addComponentsGetterSetter(V, "shadowOffset", ["x", "y"]);
-    M.addGetterSetter(V, "shadowOffsetX", 0, ee());
-    M.addGetterSetter(V, "shadowOffsetY", 0, ee());
-    M.addGetterSetter(V, "fillPatternImage");
-    M.addGetterSetter(V, "fill", void 0, yM());
-    M.addGetterSetter(V, "fillPatternX", 0, ee());
-    M.addGetterSetter(V, "fillPatternY", 0, ee());
-    M.addGetterSetter(V, "fillLinearGradientColorStops");
-    M.addGetterSetter(V, "strokeLinearGradientColorStops");
-    M.addGetterSetter(V, "fillRadialGradientStartRadius", 0);
-    M.addGetterSetter(V, "fillRadialGradientEndRadius", 0);
-    M.addGetterSetter(V, "fillRadialGradientColorStops");
-    M.addGetterSetter(V, "fillPatternRepeat", "repeat");
-    M.addGetterSetter(V, "fillEnabled", !0);
-    M.addGetterSetter(V, "strokeEnabled", !0);
-    M.addGetterSetter(V, "shadowEnabled", !0);
-    M.addGetterSetter(V, "dashEnabled", !0);
-    M.addGetterSetter(V, "strokeScaleEnabled", !0);
-    M.addGetterSetter(V, "fillPriority", "color");
-    M.addComponentsGetterSetter(V, "fillPatternOffset", ["x", "y"]);
-    M.addGetterSetter(V, "fillPatternOffsetX", 0, ee());
-    M.addGetterSetter(V, "fillPatternOffsetY", 0, ee());
-    M.addComponentsGetterSetter(V, "fillPatternScale", ["x", "y"]);
-    M.addGetterSetter(V, "fillPatternScaleX", 1, ee());
-    M.addGetterSetter(V, "fillPatternScaleY", 1, ee());
-    M.addComponentsGetterSetter(V, "fillLinearGradientStartPoint", ["x", "y"]);
-    M.addComponentsGetterSetter(V, "strokeLinearGradientStartPoint", ["x", "y"]);
-    M.addGetterSetter(V, "fillLinearGradientStartPointX", 0);
-    M.addGetterSetter(V, "strokeLinearGradientStartPointX", 0);
-    M.addGetterSetter(V, "fillLinearGradientStartPointY", 0);
-    M.addGetterSetter(V, "strokeLinearGradientStartPointY", 0);
-    M.addComponentsGetterSetter(V, "fillLinearGradientEndPoint", ["x", "y"]);
-    M.addComponentsGetterSetter(V, "strokeLinearGradientEndPoint", ["x", "y"]);
-    M.addGetterSetter(V, "fillLinearGradientEndPointX", 0);
-    M.addGetterSetter(V, "strokeLinearGradientEndPointX", 0);
-    M.addGetterSetter(V, "fillLinearGradientEndPointY", 0);
-    M.addGetterSetter(V, "strokeLinearGradientEndPointY", 0);
-    M.addComponentsGetterSetter(V, "fillRadialGradientStartPoint", ["x", "y"]);
-    M.addGetterSetter(V, "fillRadialGradientStartPointX", 0);
-    M.addGetterSetter(V, "fillRadialGradientStartPointY", 0);
-    M.addComponentsGetterSetter(V, "fillRadialGradientEndPoint", ["x", "y"]);
-    M.addGetterSetter(V, "fillRadialGradientEndPointX", 0);
-    M.addGetterSetter(V, "fillRadialGradientEndPointY", 0);
-    M.addGetterSetter(V, "fillPatternRotation", 0);
-    M.backCompat(V, {
+    V.prototype.on.call(V.prototype, "shadowColorChange.konva shadowBlurChange.konva shadowOffsetChange.konva shadowOpacityChange.konva shadowEnabledChange.konva", n7);
+    V.prototype.on.call(V.prototype, "shadowColorChange.konva shadowOpacityChange.konva shadowEnabledChange.konva", i7);
+    V.prototype.on.call(V.prototype, "fillPriorityChange.konva fillPatternImageChange.konva fillPatternRepeatChange.konva fillPatternScaleXChange.konva fillPatternScaleYChange.konva fillPatternOffsetXChange.konva fillPatternOffsetYChange.konva fillPatternXChange.konva fillPatternYChange.konva fillPatternRotationChange.konva", r7);
+    V.prototype.on.call(V.prototype, "fillPriorityChange.konva fillLinearGradientColorStopsChange.konva fillLinearGradientStartPointXChange.konva fillLinearGradientStartPointYChange.konva fillLinearGradientEndPointXChange.konva fillLinearGradientEndPointYChange.konva", s7);
+    V.prototype.on.call(V.prototype, "fillPriorityChange.konva fillRadialGradientColorStopsChange.konva fillRadialGradientStartPointXChange.konva fillRadialGradientStartPointYChange.konva fillRadialGradientEndPointXChange.konva fillRadialGradientEndPointYChange.konva fillRadialGradientStartRadiusChange.konva fillRadialGradientEndRadiusChange.konva", a7);
+    O.addGetterSetter(V, "stroke", void 0, $M());
+    O.addGetterSetter(V, "strokeWidth", 2, te());
+    O.addGetterSetter(V, "fillAfterStrokeEnabled", !1);
+    O.addGetterSetter(V, "hitStrokeWidth", "auto", mx());
+    O.addGetterSetter(V, "strokeHitEnabled", !0, mr());
+    O.addGetterSetter(V, "perfectDrawEnabled", !0, mr());
+    O.addGetterSetter(V, "shadowForStrokeEnabled", !0, mr());
+    O.addGetterSetter(V, "lineJoin");
+    O.addGetterSetter(V, "lineCap");
+    O.addGetterSetter(V, "sceneFunc");
+    O.addGetterSetter(V, "hitFunc");
+    O.addGetterSetter(V, "dash");
+    O.addGetterSetter(V, "dashOffset", 0, te());
+    O.addGetterSetter(V, "shadowColor", void 0, hc());
+    O.addGetterSetter(V, "shadowBlur", 0, te());
+    O.addGetterSetter(V, "shadowOpacity", 1, te());
+    O.addComponentsGetterSetter(V, "shadowOffset", ["x", "y"]);
+    O.addGetterSetter(V, "shadowOffsetX", 0, te());
+    O.addGetterSetter(V, "shadowOffsetY", 0, te());
+    O.addGetterSetter(V, "fillPatternImage");
+    O.addGetterSetter(V, "fill", void 0, $M());
+    O.addGetterSetter(V, "fillPatternX", 0, te());
+    O.addGetterSetter(V, "fillPatternY", 0, te());
+    O.addGetterSetter(V, "fillLinearGradientColorStops");
+    O.addGetterSetter(V, "strokeLinearGradientColorStops");
+    O.addGetterSetter(V, "fillRadialGradientStartRadius", 0);
+    O.addGetterSetter(V, "fillRadialGradientEndRadius", 0);
+    O.addGetterSetter(V, "fillRadialGradientColorStops");
+    O.addGetterSetter(V, "fillPatternRepeat", "repeat");
+    O.addGetterSetter(V, "fillEnabled", !0);
+    O.addGetterSetter(V, "strokeEnabled", !0);
+    O.addGetterSetter(V, "shadowEnabled", !0);
+    O.addGetterSetter(V, "dashEnabled", !0);
+    O.addGetterSetter(V, "strokeScaleEnabled", !0);
+    O.addGetterSetter(V, "fillPriority", "color");
+    O.addComponentsGetterSetter(V, "fillPatternOffset", ["x", "y"]);
+    O.addGetterSetter(V, "fillPatternOffsetX", 0, te());
+    O.addGetterSetter(V, "fillPatternOffsetY", 0, te());
+    O.addComponentsGetterSetter(V, "fillPatternScale", ["x", "y"]);
+    O.addGetterSetter(V, "fillPatternScaleX", 1, te());
+    O.addGetterSetter(V, "fillPatternScaleY", 1, te());
+    O.addComponentsGetterSetter(V, "fillLinearGradientStartPoint", ["x", "y"]);
+    O.addComponentsGetterSetter(V, "strokeLinearGradientStartPoint", ["x", "y"]);
+    O.addGetterSetter(V, "fillLinearGradientStartPointX", 0);
+    O.addGetterSetter(V, "strokeLinearGradientStartPointX", 0);
+    O.addGetterSetter(V, "fillLinearGradientStartPointY", 0);
+    O.addGetterSetter(V, "strokeLinearGradientStartPointY", 0);
+    O.addComponentsGetterSetter(V, "fillLinearGradientEndPoint", ["x", "y"]);
+    O.addComponentsGetterSetter(V, "strokeLinearGradientEndPoint", ["x", "y"]);
+    O.addGetterSetter(V, "fillLinearGradientEndPointX", 0);
+    O.addGetterSetter(V, "strokeLinearGradientEndPointX", 0);
+    O.addGetterSetter(V, "fillLinearGradientEndPointY", 0);
+    O.addGetterSetter(V, "strokeLinearGradientEndPointY", 0);
+    O.addComponentsGetterSetter(V, "fillRadialGradientStartPoint", ["x", "y"]);
+    O.addGetterSetter(V, "fillRadialGradientStartPointX", 0);
+    O.addGetterSetter(V, "fillRadialGradientStartPointY", 0);
+    O.addComponentsGetterSetter(V, "fillRadialGradientEndPoint", ["x", "y"]);
+    O.addGetterSetter(V, "fillRadialGradientEndPointX", 0);
+    O.addGetterSetter(V, "fillRadialGradientEndPointY", 0);
+    O.addGetterSetter(V, "fillPatternRotation", 0);
+    O.backCompat(V, {
         dashArray: "dash",
         getDashArray: "getDash",
         setDashArray: "getDash",
         drawFunc: "sceneFunc",
         getDrawFunc: "getSceneFunc",
         setDrawFunc: "setSceneFunc",
         drawHitFunc: "hitFunc",
         getDrawHitFunc: "getHitFunc",
         setDrawHitFunc: "setHitFunc"
     });
-    var e7 = "#",
-        t7 = "beforeDraw",
-        n7 = "draw",
-        NM = [{
+    var o7 = "#",
+        l7 = "beforeDraw",
+        u7 = "draw",
+        YM = [{
             x: 0,
             y: 0
         }, {
             x: -1,
             y: -1
         }, {
             x: 1,
@@ -3842,18 +3842,18 @@
         }, {
             x: 1,
             y: 1
         }, {
             x: -1,
             y: 1
         }],
-        i7 = NM.length;
-    class Ml extends vi {
+        c7 = YM.length;
+    class xl extends mi {
         constructor(t) {
-            super(t), this.canvas = new Tu, this.hitCanvas = new Qx({
+            super(t), this.canvas = new vu, this.hitCanvas = new yx({
                 pixelRatio: 1
             }), this._waitingForDraw = !1, this.on("visibleChange.konva", this._checkVisibility), this._checkVisibility(), this.on("imageSmoothingEnabledChange.konva", this._setSmoothEnabled), this._setSmoothEnabled()
         }
         createPNGStream() {
             return this.canvas._canvas.createPNGStream()
         }
         getCanvas() {
@@ -3873,196 +3873,196 @@
         }
         setZIndex(t) {
             super.setZIndex(t);
             var n = this.getStage();
             return n && n.content && (n.content.removeChild(this.getNativeCanvasElement()), t < n.children.length - 1 ? n.content.insertBefore(this.getNativeCanvasElement(), n.children[t + 1].getCanvas()._canvas) : n.content.appendChild(this.getNativeCanvasElement())), this
         }
         moveToTop() {
-            te.prototype.moveToTop.call(this);
+            ne.prototype.moveToTop.call(this);
             var t = this.getStage();
             return t && t.content && (t.content.removeChild(this.getNativeCanvasElement()), t.content.appendChild(this.getNativeCanvasElement())), !0
         }
         moveUp() {
-            var t = te.prototype.moveUp.call(this);
+            var t = ne.prototype.moveUp.call(this);
             if (!t) return !1;
             var n = this.getStage();
             return !n || !n.content ? !1 : (n.content.removeChild(this.getNativeCanvasElement()), this.index < n.children.length - 1 ? n.content.insertBefore(this.getNativeCanvasElement(), n.children[this.index + 1].getCanvas()._canvas) : n.content.appendChild(this.getNativeCanvasElement()), !0)
         }
         moveDown() {
-            if (te.prototype.moveDown.call(this)) {
+            if (ne.prototype.moveDown.call(this)) {
                 var t = this.getStage();
                 if (t) {
                     var n = t.children;
                     t.content && (t.content.removeChild(this.getNativeCanvasElement()), t.content.insertBefore(this.getNativeCanvasElement(), n[this.index + 1].getCanvas()._canvas))
                 }
                 return !0
             }
             return !1
         }
         moveToBottom() {
-            if (te.prototype.moveToBottom.call(this)) {
+            if (ne.prototype.moveToBottom.call(this)) {
                 var t = this.getStage();
                 if (t) {
                     var n = t.children;
                     t.content && (t.content.removeChild(this.getNativeCanvasElement()), t.content.insertBefore(this.getNativeCanvasElement(), n[1].getCanvas()._canvas))
                 }
                 return !0
             }
             return !1
         }
         getLayer() {
             return this
         }
         remove() {
             var t = this.getNativeCanvasElement();
-            return te.prototype.remove.call(this), t && t.parentNode && R._isInDocument(t) && t.parentNode.removeChild(t), this
+            return ne.prototype.remove.call(this), t && t.parentNode && D._isInDocument(t) && t.parentNode.removeChild(t), this
         }
         getStage() {
             return this.parent
         }
         setSize({
             width: t,
             height: n
         }) {
             return this.canvas.setSize(t, n), this.hitCanvas.setSize(t, n), this._setSmoothEnabled(), this
         }
         _validateAdd(t) {
             var n = t.getType();
-            n !== "Group" && n !== "Shape" && R.throw("You may only add groups and shapes to a layer.")
+            n !== "Group" && n !== "Shape" && D.throw("You may only add groups and shapes to a layer.")
         }
         _toKonvaCanvas(t) {
-            return t = t || {}, t.width = t.width || this.getWidth(), t.height = t.height || this.getHeight(), t.x = t.x !== void 0 ? t.x : this.x(), t.y = t.y !== void 0 ? t.y : this.y(), te.prototype._toKonvaCanvas.call(this, t)
+            return t = t || {}, t.width = t.width || this.getWidth(), t.height = t.height || this.getHeight(), t.x = t.x !== void 0 ? t.x : this.x(), t.y = t.y !== void 0 ? t.y : this.y(), ne.prototype._toKonvaCanvas.call(this, t)
         }
         _checkVisibility() {
             this.visible() ? this.canvas._canvas.style.display = "block" : this.canvas._canvas.style.display = "none"
         }
         _setSmoothEnabled() {
             this.getContext()._context.imageSmoothingEnabled = this.imageSmoothingEnabled()
         }
         getWidth() {
             if (this.parent) return this.parent.width()
         }
         setWidth() {
-            R.warn('Can not change width of layer. Use "stage.width(value)" function instead.')
+            D.warn('Can not change width of layer. Use "stage.width(value)" function instead.')
         }
         getHeight() {
             if (this.parent) return this.parent.height()
         }
         setHeight() {
-            R.warn('Can not change height of layer. Use "stage.height(value)" function instead.')
+            D.warn('Can not change height of layer. Use "stage.height(value)" function instead.')
         }
         batchDraw() {
-            return this._waitingForDraw || (this._waitingForDraw = !0, R.requestAnimFrame(() => {
+            return this._waitingForDraw || (this._waitingForDraw = !0, D.requestAnimFrame(() => {
                 this.draw(), this._waitingForDraw = !1
             })), this
         }
         getIntersection(t) {
             if (!this.isListening() || !this.isVisible()) return null;
             for (var n = 1, i = !1;;) {
-                for (let r = 0; r < i7; r++) {
-                    const a = NM[r],
-                        s = this._getIntersection({
-                            x: t.x + a.x * n,
-                            y: t.y + a.y * n
+                for (let r = 0; r < c7; r++) {
+                    const s = YM[r],
+                        a = this._getIntersection({
+                            x: t.x + s.x * n,
+                            y: t.y + s.y * n
                         }),
-                        o = s.shape;
+                        o = a.shape;
                     if (o) return o;
-                    if (i = !!s.antialiased, !s.antialiased) break
+                    if (i = !!a.antialiased, !a.antialiased) break
                 }
                 if (i) n += 1;
                 else return null
             }
         }
         _getIntersection(t) {
             const n = this.hitCanvas.pixelRatio,
                 i = this.hitCanvas.context.getImageData(Math.round(t.x * n), Math.round(t.y * n), 1, 1).data,
                 r = i[3];
             if (r === 255) {
-                const a = R._rgbToHex(i[0], i[1], i[2]),
-                    s = sh[e7 + a];
-                return s ? {
-                    shape: s
+                const s = D._rgbToHex(i[0], i[1], i[2]),
+                    a = Xf[o7 + s];
+                return a ? {
+                    shape: a
                 } : {
                     antialiased: !0
                 }
             } else if (r > 0) return {
                 antialiased: !0
             };
             return {}
         }
         drawScene(t, n) {
             var i = this.getLayer(),
                 r = t || i && i.getCanvas();
-            return this._fire(t7, {
+            return this._fire(l7, {
                 node: this
-            }), this.clearBeforeDraw() && r.getContext().clear(), vi.prototype.drawScene.call(this, r, n), this._fire(n7, {
+            }), this.clearBeforeDraw() && r.getContext().clear(), mi.prototype.drawScene.call(this, r, n), this._fire(u7, {
                 node: this
             }), this
         }
         drawHit(t, n) {
             var i = this.getLayer(),
                 r = t || i && i.hitCanvas;
-            return i && i.clearBeforeDraw() && i.getHitCanvas().getContext().clear(), vi.prototype.drawHit.call(this, r, n), this
+            return i && i.clearBeforeDraw() && i.getHitCanvas().getContext().clear(), mi.prototype.drawHit.call(this, r, n), this
         }
         enableHitGraph() {
             return this.hitGraphEnabled(!0), this
         }
         disableHitGraph() {
             return this.hitGraphEnabled(!1), this
         }
         setHitGraphEnabled(t) {
-            R.warn("hitGraphEnabled method is deprecated. Please use layer.listening() instead."), this.listening(t)
+            D.warn("hitGraphEnabled method is deprecated. Please use layer.listening() instead."), this.listening(t)
         }
         getHitGraphEnabled(t) {
-            return R.warn("hitGraphEnabled method is deprecated. Please use layer.listening() instead."), this.listening()
+            return D.warn("hitGraphEnabled method is deprecated. Please use layer.listening() instead."), this.listening()
         }
         toggleHitCanvas() {
             if (!(!this.parent || !this.parent.content)) {
                 var t = this.parent,
                     n = !!this.hitCanvas._canvas.parentNode;
                 n ? t.content.removeChild(this.hitCanvas._canvas) : t.content.appendChild(this.hitCanvas._canvas)
             }
         }
         destroy() {
-            return R.releaseCanvas(this.getNativeCanvasElement(), this.getHitCanvas()._canvas), super.destroy()
+            return D.releaseCanvas(this.getNativeCanvasElement(), this.getHitCanvas()._canvas), super.destroy()
         }
     }
-    Ml.prototype.nodeType = "Layer";
-    mt(Ml);
-    M.addGetterSetter(Ml, "imageSmoothingEnabled", !0);
-    M.addGetterSetter(Ml, "clearBeforeDraw", !0);
-    M.addGetterSetter(Ml, "hitGraphEnabled", !0, Sr());
-    class e_ extends Ml {
+    xl.prototype.nodeType = "Layer";
+    pt(xl);
+    O.addGetterSetter(xl, "imageSmoothingEnabled", !0);
+    O.addGetterSetter(xl, "clearBeforeDraw", !0);
+    O.addGetterSetter(xl, "hitGraphEnabled", !0, mr());
+    class bx extends xl {
         constructor(t) {
-            super(t), this.listening(!1), R.warn('Konva.Fast layer is deprecated. Please use "new Konva.Layer({ listening: false })" instead.')
+            super(t), this.listening(!1), D.warn('Konva.Fast layer is deprecated. Please use "new Konva.Layer({ listening: false })" instead.')
         }
     }
-    e_.prototype.nodeType = "FastLayer";
-    mt(e_);
-    let Bu = class extends vi {
+    bx.prototype.nodeType = "FastLayer";
+    pt(bx);
+    let Mu = class extends mi {
         _validateAdd(t) {
             var n = t.getType();
-            n !== "Group" && n !== "Shape" && R.throw("You may only add groups and shapes to groups.")
+            n !== "Group" && n !== "Shape" && D.throw("You may only add groups and shapes to groups.")
         }
     };
-    Bu.prototype.nodeType = "Group";
-    mt(Bu);
-    var Ny = function() {
-        return Au.performance && Au.performance.now ? function() {
-            return Au.performance.now()
+    Mu.prototype.nodeType = "Group";
+    pt(Mu);
+    var gy = function() {
+        return yu.performance && yu.performance.now ? function() {
+            return yu.performance.now()
         } : function() {
             return new Date().getTime()
         }
     }();
-    class Ti {
+    class Ci {
         constructor(t, n) {
-            this.id = Ti.animIdCounter++, this.frame = {
+            this.id = Ci.animIdCounter++, this.frame = {
                 time: 0,
                 timeDiff: 0,
-                lastTime: Ny(),
+                lastTime: gy(),
                 frameRate: 0
             }, this.func = t, this.setLayers(n)
         }
         setLayers(t) {
             var n = [];
             return t ? t.length > 0 ? n = t : n = [t] : n = [], this.layers = n, this
         }
@@ -4074,80 +4074,80 @@
                 i = n.length,
                 r;
             for (r = 0; r < i; r++)
                 if (n[r]._id === t._id) return !1;
             return this.layers.push(t), !0
         }
         isRunning() {
-            var t = Ti,
+            var t = Ci,
                 n = t.animations,
                 i = n.length,
                 r;
             for (r = 0; r < i; r++)
                 if (n[r].id === this.id) return !0;
             return !1
         }
         start() {
-            return this.stop(), this.frame.timeDiff = 0, this.frame.lastTime = Ny(), Ti._addAnimation(this), this
+            return this.stop(), this.frame.timeDiff = 0, this.frame.lastTime = gy(), Ci._addAnimation(this), this
         }
         stop() {
-            return Ti._removeAnimation(this), this
+            return Ci._removeAnimation(this), this
         }
         _updateFrameObject(t) {
             this.frame.timeDiff = t - this.frame.lastTime, this.frame.lastTime = t, this.frame.time += this.frame.timeDiff, this.frame.frameRate = 1e3 / this.frame.timeDiff
         }
         static _addAnimation(t) {
             this.animations.push(t), this._handleAnimation()
         }
         static _removeAnimation(t) {
             var n = t.id,
                 i = this.animations,
                 r = i.length,
-                a;
-            for (a = 0; a < r; a++)
-                if (i[a].id === n) {
-                    this.animations.splice(a, 1);
+                s;
+            for (s = 0; s < r; s++)
+                if (i[s].id === n) {
+                    this.animations.splice(s, 1);
                     break
                 }
         }
         static _runFrames() {
             var t = {},
                 n = this.animations,
-                i, r, a, s, o, l, u, c, f;
-            for (s = 0; s < n.length; s++)
-                if (i = n[s], r = i.layers, a = i.func, i._updateFrameObject(Ny()), l = r.length, a ? f = a.call(i, i.frame) !== !1 : f = !0, !!f)
+                i, r, s, a, o, l, u, c, f;
+            for (a = 0; a < n.length; a++)
+                if (i = n[a], r = i.layers, s = i.func, i._updateFrameObject(gy()), l = r.length, s ? f = s.call(i, i.frame) !== !1 : f = !0, !!f)
                     for (o = 0; o < l; o++) u = r[o], u._id !== void 0 && (t[u._id] = u);
             for (c in t) t.hasOwnProperty(c) && t[c].batchDraw()
         }
         static _animationLoop() {
-            var t = Ti;
-            t.animations.length ? (t._runFrames(), R.requestAnimFrame(t._animationLoop)) : t.animRunning = !1
+            var t = Ci;
+            t.animations.length ? (t._runFrames(), D.requestAnimFrame(t._animationLoop)) : t.animRunning = !1
         }
         static _handleAnimation() {
-            this.animRunning || (this.animRunning = !0, R.requestAnimFrame(this._animationLoop))
+            this.animRunning || (this.animRunning = !0, D.requestAnimFrame(this._animationLoop))
         }
     }
-    Ti.animations = [];
-    Ti.animIdCounter = 0;
-    Ti.animRunning = !1;
-    var r7 = {
+    Ci.animations = [];
+    Ci.animIdCounter = 0;
+    Ci.animRunning = !1;
+    var f7 = {
             node: 1,
             duration: 1,
             easing: 1,
             onFinish: 1,
             yoyo: 1
         },
-        a7 = 1,
-        QC = 2,
-        ZC = 3,
-        s7 = 0,
-        ek = ["fill", "stroke", "shadowColor"];
-    class o7 {
-        constructor(t, n, i, r, a, s, o) {
-            this.prop = t, this.propFunc = n, this.begin = r, this._pos = r, this.duration = s, this._change = 0, this.prevPos = 0, this.yoyo = o, this._time = 0, this._position = 0, this._startTime = 0, this._finish = 0, this.func = i, this._change = a - this.begin, this.pause()
+        h7 = 1,
+        hk = 2,
+        dk = 3,
+        d7 = 0,
+        gk = ["fill", "stroke", "shadowColor"];
+    class g7 {
+        constructor(t, n, i, r, s, a, o) {
+            this.prop = t, this.propFunc = n, this.begin = r, this._pos = r, this.duration = a, this._change = 0, this.prevPos = 0, this.yoyo = o, this._time = 0, this._position = 0, this._startTime = 0, this._finish = 0, this.func = i, this._change = s - this.begin, this.pause()
         }
         fire(t) {
             var n = this[t];
             n && n()
         }
         setTime(t) {
             t > this.duration ? this.yoyo ? (this._time = this.duration, this.reverse()) : this.finish() : t < 0 ? this.yoyo ? (this._time = 0, this.play()) : this.reset() : (this._time = t, this.update())
@@ -4158,18 +4158,18 @@
         setPosition(t) {
             this.prevPos = this._pos, this.propFunc(t), this._pos = t
         }
         getPosition(t) {
             return t === void 0 && (t = this._time), this.func(t, this.begin, this._change, this.duration)
         }
         play() {
-            this.state = QC, this._startTime = this.getTimer() - this._time, this.onEnterFrame(), this.fire("onPlay")
+            this.state = hk, this._startTime = this.getTimer() - this._time, this.onEnterFrame(), this.fire("onPlay")
         }
         reverse() {
-            this.state = ZC, this._time = this.duration - this._time, this._startTime = this.getTimer() - this._time, this.onEnterFrame(), this.fire("onReverse")
+            this.state = dk, this._time = this.duration - this._time, this._startTime = this.getTimer() - this._time, this.onEnterFrame(), this.fire("onReverse")
         }
         seek(t) {
             this.pause(), this._time = t, this.update(), this.fire("onSeek")
         }
         reset() {
             this.pause(), this._time = 0, this.update(), this.fire("onReset")
         }
@@ -4177,102 +4177,102 @@
             this.pause(), this._time = this.duration, this.update(), this.fire("onFinish")
         }
         update() {
             this.setPosition(this.getPosition(this._time)), this.fire("onUpdate")
         }
         onEnterFrame() {
             var t = this.getTimer() - this._startTime;
-            this.state === QC ? this.setTime(t) : this.state === ZC && this.setTime(this.duration - t)
+            this.state === hk ? this.setTime(t) : this.state === dk && this.setTime(this.duration - t)
         }
         pause() {
-            this.state = a7, this.fire("onPause")
+            this.state = h7, this.fire("onPause")
         }
         getTimer() {
             return new Date().getTime()
         }
     }
-    class Et {
+    class _t {
         constructor(t) {
             var n = this,
                 i = t.node,
                 r = i._id,
-                a, s = t.easing || oh.Linear,
+                s, a = t.easing || Vf.Linear,
                 o = !!t.yoyo,
                 l;
-            typeof t.duration > "u" ? a = .3 : t.duration === 0 ? a = .001 : a = t.duration, this.node = i, this._id = s7++;
+            typeof t.duration > "u" ? s = .3 : t.duration === 0 ? s = .001 : s = t.duration, this.node = i, this._id = d7++;
             var u = i.getLayer() || (i instanceof le.Stage ? i.getLayers() : null);
-            u || R.error("Tween constructor have `node` that is not in a layer. Please add node into layer first."), this.anim = new Ti(function() {
+            u || D.error("Tween constructor have `node` that is not in a layer. Please add node into layer first."), this.anim = new Ci(function() {
                 n.tween.onEnterFrame()
-            }, u), this.tween = new o7(l, function(c) {
+            }, u), this.tween = new g7(l, function(c) {
                 n._tweenFunc(c)
-            }, s, 0, 1, a * 1e3, o), this._addListeners(), Et.attrs[r] || (Et.attrs[r] = {}), Et.attrs[r][this._id] || (Et.attrs[r][this._id] = {}), Et.tweens[r] || (Et.tweens[r] = {});
-            for (l in t) r7[l] === void 0 && this._addAttr(l, t[l]);
+            }, a, 0, 1, s * 1e3, o), this._addListeners(), _t.attrs[r] || (_t.attrs[r] = {}), _t.attrs[r][this._id] || (_t.attrs[r][this._id] = {}), _t.tweens[r] || (_t.tweens[r] = {});
+            for (l in t) f7[l] === void 0 && this._addAttr(l, t[l]);
             this.reset(), this.onFinish = t.onFinish, this.onReset = t.onReset, this.onUpdate = t.onUpdate
         }
         _addAttr(t, n) {
             var i = this.node,
                 r = i._id,
-                a, s, o, l, u, c, f, h;
-            if (o = Et.tweens[r][t], o && delete Et.attrs[r][o][t], a = i.getAttr(t), R._isArray(n))
-                if (s = [], u = Math.max(n.length, a.length), t === "points" && n.length !== a.length && (n.length > a.length ? (f = a, a = R._prepareArrayForTween(a, n, i.closed())) : (c = n, n = R._prepareArrayForTween(n, a, i.closed()))), t.indexOf("fill") === 0)
+                s, a, o, l, u, c, f, h;
+            if (o = _t.tweens[r][t], o && delete _t.attrs[r][o][t], s = i.getAttr(t), D._isArray(n))
+                if (a = [], u = Math.max(n.length, s.length), t === "points" && n.length !== s.length && (n.length > s.length ? (f = s, s = D._prepareArrayForTween(s, n, i.closed())) : (c = n, n = D._prepareArrayForTween(n, s, i.closed()))), t.indexOf("fill") === 0)
                     for (l = 0; l < u; l++)
-                        if (l % 2 === 0) s.push(n[l] - a[l]);
+                        if (l % 2 === 0) a.push(n[l] - s[l]);
                         else {
-                            var d = R.colorToRGBA(a[l]);
-                            h = R.colorToRGBA(n[l]), a[l] = d, s.push({
+                            var d = D.colorToRGBA(s[l]);
+                            h = D.colorToRGBA(n[l]), s[l] = d, a.push({
                                 r: h.r - d.r,
                                 g: h.g - d.g,
                                 b: h.b - d.b,
                                 a: h.a - d.a
                             })
                         }
             else
-                for (l = 0; l < u; l++) s.push(n[l] - a[l]);
-            else ek.indexOf(t) !== -1 ? (a = R.colorToRGBA(a), h = R.colorToRGBA(n), s = {
-                r: h.r - a.r,
-                g: h.g - a.g,
-                b: h.b - a.b,
-                a: h.a - a.a
-            }) : s = n - a;
-            Et.attrs[r][this._id][t] = {
-                start: a,
-                diff: s,
+                for (l = 0; l < u; l++) a.push(n[l] - s[l]);
+            else gk.indexOf(t) !== -1 ? (s = D.colorToRGBA(s), h = D.colorToRGBA(n), a = {
+                r: h.r - s.r,
+                g: h.g - s.g,
+                b: h.b - s.b,
+                a: h.a - s.a
+            }) : a = n - s;
+            _t.attrs[r][this._id][t] = {
+                start: s,
+                diff: a,
                 end: n,
                 trueEnd: c,
                 trueStart: f
-            }, Et.tweens[r][t] = this._id
+            }, _t.tweens[r][t] = this._id
         }
         _tweenFunc(t) {
             var n = this.node,
-                i = Et.attrs[n._id][this._id],
-                r, a, s, o, l, u, c, f;
+                i = _t.attrs[n._id][this._id],
+                r, s, a, o, l, u, c, f;
             for (r in i) {
-                if (a = i[r], s = a.start, o = a.diff, f = a.end, R._isArray(s))
-                    if (l = [], c = Math.max(s.length, f.length), r.indexOf("fill") === 0)
-                        for (u = 0; u < c; u++) u % 2 === 0 ? l.push((s[u] || 0) + o[u] * t) : l.push("rgba(" + Math.round(s[u].r + o[u].r * t) + "," + Math.round(s[u].g + o[u].g * t) + "," + Math.round(s[u].b + o[u].b * t) + "," + (s[u].a + o[u].a * t) + ")");
+                if (s = i[r], a = s.start, o = s.diff, f = s.end, D._isArray(a))
+                    if (l = [], c = Math.max(a.length, f.length), r.indexOf("fill") === 0)
+                        for (u = 0; u < c; u++) u % 2 === 0 ? l.push((a[u] || 0) + o[u] * t) : l.push("rgba(" + Math.round(a[u].r + o[u].r * t) + "," + Math.round(a[u].g + o[u].g * t) + "," + Math.round(a[u].b + o[u].b * t) + "," + (a[u].a + o[u].a * t) + ")");
                     else
-                        for (u = 0; u < c; u++) l.push((s[u] || 0) + o[u] * t);
-                else ek.indexOf(r) !== -1 ? l = "rgba(" + Math.round(s.r + o.r * t) + "," + Math.round(s.g + o.g * t) + "," + Math.round(s.b + o.b * t) + "," + (s.a + o.a * t) + ")" : l = s + o * t;
+                        for (u = 0; u < c; u++) l.push((a[u] || 0) + o[u] * t);
+                else gk.indexOf(r) !== -1 ? l = "rgba(" + Math.round(a.r + o.r * t) + "," + Math.round(a.g + o.g * t) + "," + Math.round(a.b + o.b * t) + "," + (a.a + o.a * t) + ")" : l = a + o * t;
                 n.setAttr(r, l)
             }
         }
         _addListeners() {
             this.tween.onPlay = () => {
                 this.anim.start()
             }, this.tween.onReverse = () => {
                 this.anim.start()
             }, this.tween.onPause = () => {
                 this.anim.stop()
             }, this.tween.onFinish = () => {
                 var t = this.node,
-                    n = Et.attrs[t._id][this._id];
+                    n = _t.attrs[t._id][this._id];
                 n.points && n.points.trueEnd && t.setAttr("points", n.points.trueEnd), this.onFinish && this.onFinish.call(this)
             }, this.tween.onReset = () => {
                 var t = this.node,
-                    n = Et.attrs[t._id][this._id];
+                    n = _t.attrs[t._id][this._id];
                 n.points && n.points.trueStart && t.points(n.points.trueStart), this.onReset && this.onReset()
             }, this.tween.onUpdate = () => {
                 this.onUpdate && this.onUpdate.call(this)
             }
         }
         play() {
             return this.tween.play(), this
@@ -4291,64 +4291,64 @@
         }
         finish() {
             return this.tween.finish(), this
         }
         destroy() {
             var t = this.node._id,
                 n = this._id,
-                i = Et.tweens[t],
+                i = _t.tweens[t],
                 r;
             this.pause();
-            for (r in i) delete Et.tweens[t][r];
-            delete Et.attrs[t][n]
+            for (r in i) delete _t.tweens[t][r];
+            delete _t.attrs[t][n]
         }
     }
-    Et.attrs = {};
-    Et.tweens = {};
-    te.prototype.to = function(e) {
+    _t.attrs = {};
+    _t.tweens = {};
+    ne.prototype.to = function(e) {
         var t = e.onFinish;
         e.node = this, e.onFinish = function() {
             this.destroy(), t && t()
         };
-        var n = new Et(e);
+        var n = new _t(e);
         n.play()
     };
-    const oh = {
+    const Vf = {
             BackEaseIn(e, t, n, i) {
                 var r = 1.70158;
                 return n * (e /= i) * e * ((r + 1) * e - r) + t
             },
             BackEaseOut(e, t, n, i) {
                 var r = 1.70158;
                 return n * ((e = e / i - 1) * e * ((r + 1) * e + r) + 1) + t
             },
             BackEaseInOut(e, t, n, i) {
                 var r = 1.70158;
                 return (e /= i / 2) < 1 ? n / 2 * (e * e * (((r *= 1.525) + 1) * e - r)) + t : n / 2 * ((e -= 2) * e * (((r *= 1.525) + 1) * e + r) + 2) + t
             },
-            ElasticEaseIn(e, t, n, i, r, a) {
-                var s = 0;
-                return e === 0 ? t : (e /= i) === 1 ? t + n : (a || (a = i * .3), !r || r < Math.abs(n) ? (r = n, s = a / 4) : s = a / (2 * Math.PI) * Math.asin(n / r), -(r * Math.pow(2, 10 * (e -= 1)) * Math.sin((e * i - s) * (2 * Math.PI) / a)) + t)
-            },
-            ElasticEaseOut(e, t, n, i, r, a) {
-                var s = 0;
-                return e === 0 ? t : (e /= i) === 1 ? t + n : (a || (a = i * .3), !r || r < Math.abs(n) ? (r = n, s = a / 4) : s = a / (2 * Math.PI) * Math.asin(n / r), r * Math.pow(2, -10 * e) * Math.sin((e * i - s) * (2 * Math.PI) / a) + n + t)
-            },
-            ElasticEaseInOut(e, t, n, i, r, a) {
-                var s = 0;
-                return e === 0 ? t : (e /= i / 2) === 2 ? t + n : (a || (a = i * (.3 * 1.5)), !r || r < Math.abs(n) ? (r = n, s = a / 4) : s = a / (2 * Math.PI) * Math.asin(n / r), e < 1 ? -.5 * (r * Math.pow(2, 10 * (e -= 1)) * Math.sin((e * i - s) * (2 * Math.PI) / a)) + t : r * Math.pow(2, -10 * (e -= 1)) * Math.sin((e * i - s) * (2 * Math.PI) / a) * .5 + n + t)
+            ElasticEaseIn(e, t, n, i, r, s) {
+                var a = 0;
+                return e === 0 ? t : (e /= i) === 1 ? t + n : (s || (s = i * .3), !r || r < Math.abs(n) ? (r = n, a = s / 4) : a = s / (2 * Math.PI) * Math.asin(n / r), -(r * Math.pow(2, 10 * (e -= 1)) * Math.sin((e * i - a) * (2 * Math.PI) / s)) + t)
+            },
+            ElasticEaseOut(e, t, n, i, r, s) {
+                var a = 0;
+                return e === 0 ? t : (e /= i) === 1 ? t + n : (s || (s = i * .3), !r || r < Math.abs(n) ? (r = n, a = s / 4) : a = s / (2 * Math.PI) * Math.asin(n / r), r * Math.pow(2, -10 * e) * Math.sin((e * i - a) * (2 * Math.PI) / s) + n + t)
+            },
+            ElasticEaseInOut(e, t, n, i, r, s) {
+                var a = 0;
+                return e === 0 ? t : (e /= i / 2) === 2 ? t + n : (s || (s = i * (.3 * 1.5)), !r || r < Math.abs(n) ? (r = n, a = s / 4) : a = s / (2 * Math.PI) * Math.asin(n / r), e < 1 ? -.5 * (r * Math.pow(2, 10 * (e -= 1)) * Math.sin((e * i - a) * (2 * Math.PI) / s)) + t : r * Math.pow(2, -10 * (e -= 1)) * Math.sin((e * i - a) * (2 * Math.PI) / s) * .5 + n + t)
             },
             BounceEaseOut(e, t, n, i) {
                 return (e /= i) < 1 / 2.75 ? n * (7.5625 * e * e) + t : e < 2 / 2.75 ? n * (7.5625 * (e -= 1.5 / 2.75) * e + .75) + t : e < 2.5 / 2.75 ? n * (7.5625 * (e -= 2.25 / 2.75) * e + .9375) + t : n * (7.5625 * (e -= 2.625 / 2.75) * e + .984375) + t
             },
             BounceEaseIn(e, t, n, i) {
-                return n - oh.BounceEaseOut(i - e, 0, n, i) + t
+                return n - Vf.BounceEaseOut(i - e, 0, n, i) + t
             },
             BounceEaseInOut(e, t, n, i) {
-                return e < i / 2 ? oh.BounceEaseIn(e * 2, 0, n, i) * .5 + t : oh.BounceEaseOut(e * 2 - i, 0, n, i) * .5 + n * .5 + t
+                return e < i / 2 ? Vf.BounceEaseIn(e * 2, 0, n, i) * .5 + t : Vf.BounceEaseOut(e * 2 - i, 0, n, i) * .5 + n * .5 + t
             },
             EaseIn(e, t, n, i) {
                 return n * (e /= i) * e + t
             },
             EaseOut(e, t, n, i) {
                 return -n * (e /= i) * (e - 2) + t
             },
@@ -4364,34 +4364,34 @@
             StrongEaseInOut(e, t, n, i) {
                 return (e /= i / 2) < 1 ? n / 2 * e * e * e * e * e + t : n / 2 * ((e -= 2) * e * e * e * e + 2) + t
             },
             Linear(e, t, n, i) {
                 return n * e / i + t
             }
         },
-        tk = R._assign(le, {
-            Util: R,
-            Transform: ir,
-            Node: te,
-            Container: vi,
-            Stage: wm,
-            stages: lp,
-            Layer: Ml,
-            FastLayer: e_,
-            Group: Bu,
-            DD: Be,
+        pk = D._assign(le, {
+            Util: D,
+            Transform: Ki,
+            Node: ne,
+            Container: mi,
+            Stage: nm,
+            stages: Wg,
+            Layer: xl,
+            FastLayer: bx,
+            Group: Mu,
+            DD: je,
             Shape: V,
-            shapes: sh,
-            Animation: Ti,
-            Tween: Et,
-            Easings: oh,
-            Context: xm,
-            Canvas: _m
+            shapes: Xf,
+            Animation: Ci,
+            Tween: _t,
+            Easings: Vf,
+            Context: em,
+            Canvas: tm
         });
-    class Ja extends V {
+    class Us extends V {
         _sceneFunc(t) {
             var n = le.getAngle(this.angle()),
                 i = this.clockwise();
             t.beginPath(), t.arc(0, 0, this.outerRadius(), 0, n, i), t.arc(0, 0, this.innerRadius(), n, 0, !i), t.closePath(), t.fillStrokeShape(this)
         }
         getWidth() {
             return this.outerRadius() * 2
@@ -4406,96 +4406,96 @@
             this.outerRadius(t / 2)
         }
         getSelfRect() {
             const t = this.innerRadius(),
                 n = this.outerRadius(),
                 i = this.clockwise(),
                 r = le.getAngle(i ? 360 - this.angle() : this.angle()),
-                a = Math.cos(Math.min(r, Math.PI)),
-                s = 1,
+                s = Math.cos(Math.min(r, Math.PI)),
+                a = 1,
                 o = Math.sin(Math.min(Math.max(Math.PI, r), 3 * Math.PI / 2)),
                 l = Math.sin(Math.min(r, Math.PI / 2)),
-                u = a * (a > 0 ? t : n),
-                c = s * n,
+                u = s * (s > 0 ? t : n),
+                c = a * n,
                 f = o * (o > 0 ? t : n),
                 h = l * (l > 0 ? n : t);
             return {
                 x: u,
                 y: i ? -1 * h : f,
                 width: c - u,
                 height: h - f
             }
         }
     }
-    Ja.prototype._centroid = !0;
-    Ja.prototype.className = "Arc";
-    Ja.prototype._attrsAffectingSize = ["innerRadius", "outerRadius"];
-    mt(Ja);
-    M.addGetterSetter(Ja, "innerRadius", 0, ee());
-    M.addGetterSetter(Ja, "outerRadius", 0, ee());
-    M.addGetterSetter(Ja, "angle", 0, ee());
-    M.addGetterSetter(Ja, "clockwise", !1, Sr());
+    Us.prototype._centroid = !0;
+    Us.prototype.className = "Arc";
+    Us.prototype._attrsAffectingSize = ["innerRadius", "outerRadius"];
+    pt(Us);
+    O.addGetterSetter(Us, "innerRadius", 0, te());
+    O.addGetterSetter(Us, "outerRadius", 0, te());
+    O.addGetterSetter(Us, "angle", 0, te());
+    O.addGetterSetter(Us, "clockwise", !1, mr());
 
-    function Eb(e, t, n, i, r, a, s) {
+    function Qv(e, t, n, i, r, s, a) {
         var o = Math.sqrt(Math.pow(n - e, 2) + Math.pow(i - t, 2)),
-            l = Math.sqrt(Math.pow(r - n, 2) + Math.pow(a - i, 2)),
-            u = s * o / (o + l),
-            c = s * l / (o + l),
+            l = Math.sqrt(Math.pow(r - n, 2) + Math.pow(s - i, 2)),
+            u = a * o / (o + l),
+            c = a * l / (o + l),
             f = n - u * (r - e),
-            h = i - u * (a - t),
+            h = i - u * (s - t),
             d = n + c * (r - e),
-            g = i + c * (a - t);
+            g = i + c * (s - t);
         return [f, h, d, g]
     }
 
-    function nk(e, t) {
+    function mk(e, t) {
         var n = e.length,
             i = [],
-            r, a;
-        for (r = 2; r < n - 2; r += 2) a = Eb(e[r - 2], e[r - 1], e[r], e[r + 1], e[r + 2], e[r + 3], t), !isNaN(a[0]) && (i.push(a[0]), i.push(a[1]), i.push(e[r]), i.push(e[r + 1]), i.push(a[2]), i.push(a[3]));
+            r, s;
+        for (r = 2; r < n - 2; r += 2) s = Qv(e[r - 2], e[r - 1], e[r], e[r + 1], e[r + 2], e[r + 3], t), !isNaN(s[0]) && (i.push(s[0]), i.push(s[1]), i.push(e[r]), i.push(e[r + 1]), i.push(s[2]), i.push(s[3]));
         return i
     }
-    class Qa extends V {
+    class Gs extends V {
         constructor(t) {
             super(t), this.on("pointsChange.konva tensionChange.konva closedChange.konva bezierChange.konva", function() {
                 this._clearCache("tensionPoints")
             })
         }
         _sceneFunc(t) {
             var n = this.points(),
                 i = n.length,
                 r = this.tension(),
-                a = this.closed(),
-                s = this.bezier(),
+                s = this.closed(),
+                a = this.bezier(),
                 o, l, u;
             if (i) {
                 if (t.beginPath(), t.moveTo(n[0], n[1]), r !== 0 && i > 4) {
-                    for (o = this.getTensionPoints(), l = o.length, u = a ? 0 : 4, a || t.quadraticCurveTo(o[0], o[1], o[2], o[3]); u < l - 2;) t.bezierCurveTo(o[u++], o[u++], o[u++], o[u++], o[u++], o[u++]);
-                    a || t.quadraticCurveTo(o[l - 2], o[l - 1], n[i - 2], n[i - 1])
-                } else if (s)
+                    for (o = this.getTensionPoints(), l = o.length, u = s ? 0 : 4, s || t.quadraticCurveTo(o[0], o[1], o[2], o[3]); u < l - 2;) t.bezierCurveTo(o[u++], o[u++], o[u++], o[u++], o[u++], o[u++]);
+                    s || t.quadraticCurveTo(o[l - 2], o[l - 1], n[i - 2], n[i - 1])
+                } else if (a)
                     for (u = 2; u < i;) t.bezierCurveTo(n[u++], n[u++], n[u++], n[u++], n[u++], n[u++]);
                 else
                     for (u = 2; u < i; u += 2) t.lineTo(n[u], n[u + 1]);
-                a ? (t.closePath(), t.fillStrokeShape(this)) : t.strokeShape(this)
+                s ? (t.closePath(), t.fillStrokeShape(this)) : t.strokeShape(this)
             }
         }
         getTensionPoints() {
             return this._getCache("tensionPoints", this._getTensionPoints)
         }
         _getTensionPoints() {
-            return this.closed() ? this._getTensionPointsClosed() : nk(this.points(), this.tension())
+            return this.closed() ? this._getTensionPointsClosed() : mk(this.points(), this.tension())
         }
         _getTensionPointsClosed() {
             var t = this.points(),
                 n = t.length,
                 i = this.tension(),
-                r = Eb(t[n - 2], t[n - 1], t[0], t[1], t[2], t[3], i),
-                a = Eb(t[n - 4], t[n - 3], t[n - 2], t[n - 1], t[0], t[1], i),
-                s = nk(t, i),
-                o = [r[2], r[3]].concat(s).concat([a[0], a[1], t[n - 2], t[n - 1], a[2], a[3], r[0], r[1], t[0], t[1]]);
+                r = Qv(t[n - 2], t[n - 1], t[0], t[1], t[2], t[3], i),
+                s = Qv(t[n - 4], t[n - 3], t[n - 2], t[n - 1], t[0], t[1], i),
+                a = mk(t, i),
+                o = [r[2], r[3]].concat(a).concat([s[0], s[1], t[n - 2], t[n - 1], s[2], s[3], r[0], r[1], t[0], t[1]]);
             return o
         }
         getWidth() {
             return this.getSelfRect().width
         }
         getHeight() {
             return this.getSelfRect().height
@@ -4505,67 +4505,67 @@
             if (t.length < 4) return {
                 x: t[0] || 0,
                 y: t[1] || 0,
                 width: 0,
                 height: 0
             };
             this.tension() !== 0 ? t = [t[0], t[1], ...this._getTensionPoints(), t[t.length - 2], t[t.length - 1]] : t = this.points();
-            for (var n = t[0], i = t[0], r = t[1], a = t[1], s, o, l = 0; l < t.length / 2; l++) s = t[l * 2], o = t[l * 2 + 1], n = Math.min(n, s), i = Math.max(i, s), r = Math.min(r, o), a = Math.max(a, o);
+            for (var n = t[0], i = t[0], r = t[1], s = t[1], a, o, l = 0; l < t.length / 2; l++) a = t[l * 2], o = t[l * 2 + 1], n = Math.min(n, a), i = Math.max(i, a), r = Math.min(r, o), s = Math.max(s, o);
             return {
                 x: n,
                 y: r,
                 width: i - n,
-                height: a - r
+                height: s - r
             }
         }
     }
-    Qa.prototype.className = "Line";
-    Qa.prototype._attrsAffectingSize = ["points", "bezier", "tension"];
-    mt(Qa);
-    M.addGetterSetter(Qa, "closed", !1);
-    M.addGetterSetter(Qa, "bezier", !1);
-    M.addGetterSetter(Qa, "tension", 0, ee());
-    M.addGetterSetter(Qa, "points", [], y9());
-    let Jt = class Vi extends V {
+    Gs.prototype.className = "Line";
+    Gs.prototype._attrsAffectingSize = ["points", "bezier", "tension"];
+    pt(Gs);
+    O.addGetterSetter(Gs, "closed", !1);
+    O.addGetterSetter(Gs, "bezier", !1);
+    O.addGetterSetter(Gs, "tension", 0, te());
+    O.addGetterSetter(Gs, "points", [], E9());
+    let Yt = class Ui extends V {
         constructor(t) {
-            super(t), this.dataArray = [], this.pathLength = 0, this.dataArray = Vi.parsePathData(this.data()), this.pathLength = 0;
+            super(t), this.dataArray = [], this.pathLength = 0, this.dataArray = Ui.parsePathData(this.data()), this.pathLength = 0;
             for (var n = 0; n < this.dataArray.length; ++n) this.pathLength += this.dataArray[n].pathLength;
             this.on("dataChange.konva", function() {
-                this.dataArray = Vi.parsePathData(this.data()), this.pathLength = 0;
+                this.dataArray = Ui.parsePathData(this.data()), this.pathLength = 0;
                 for (var i = 0; i < this.dataArray.length; ++i) this.pathLength += this.dataArray[i].pathLength
             })
         }
         _sceneFunc(t) {
             var n = this.dataArray;
             t.beginPath();
             for (var i = !1, r = 0; r < n.length; r++) {
-                var a = n[r].command,
-                    s = n[r].points;
-                switch (a) {
+                var s = n[r].command,
+                    a = n[r].points;
+                switch (s) {
                     case "L":
-                        t.lineTo(s[0], s[1]);
+                        t.lineTo(a[0], a[1]);
                         break;
                     case "M":
-                        t.moveTo(s[0], s[1]);
+                        t.moveTo(a[0], a[1]);
                         break;
                     case "C":
-                        t.bezierCurveTo(s[0], s[1], s[2], s[3], s[4], s[5]);
+                        t.bezierCurveTo(a[0], a[1], a[2], a[3], a[4], a[5]);
                         break;
                     case "Q":
-                        t.quadraticCurveTo(s[0], s[1], s[2], s[3]);
+                        t.quadraticCurveTo(a[0], a[1], a[2], a[3]);
                         break;
                     case "A":
-                        var o = s[0],
-                            l = s[1],
-                            u = s[2],
-                            c = s[3],
-                            f = s[4],
-                            h = s[5],
-                            d = s[6],
-                            g = s[7],
+                        var o = a[0],
+                            l = a[1],
+                            u = a[2],
+                            c = a[3],
+                            f = a[4],
+                            h = a[5],
+                            d = a[6],
+                            g = a[7],
                             p = u > c ? u : c,
                             m = u > c ? 1 : u / c,
                             y = u > c ? c / u : 1;
                         t.translate(o, l), t.rotate(d), t.scale(m, y), t.arc(0, 0, p, f, f + h, 1 - g), t.scale(1 / m, 1 / y), t.rotate(-d), t.translate(-o, -l);
                         break;
                     case "z":
                         i = !0, t.closePath();
@@ -4579,33 +4579,33 @@
                 if (u.command === "A") {
                     var c = u.points[4],
                         f = u.points[5],
                         h = u.points[4] + f,
                         d = Math.PI / 180;
                     if (Math.abs(c - h) < d && (d = Math.abs(c - h)), f < 0)
                         for (let g = c - d; g > h; g -= d) {
-                            const p = Vi.getPointOnEllipticalArc(u.points[0], u.points[1], u.points[2], u.points[3], g, 0);
+                            const p = Ui.getPointOnEllipticalArc(u.points[0], u.points[1], u.points[2], u.points[3], g, 0);
                             t.push(p.x, p.y)
                         } else
                             for (let g = c + d; g < h; g += d) {
-                                const p = Vi.getPointOnEllipticalArc(u.points[0], u.points[1], u.points[2], u.points[3], g, 0);
+                                const p = Ui.getPointOnEllipticalArc(u.points[0], u.points[1], u.points[2], u.points[3], g, 0);
                                 t.push(p.x, p.y)
                             }
                 } else if (u.command === "C")
                     for (let g = 0; g <= 1; g += .01) {
-                        const p = Vi.getPointOnCubicBezier(g, u.start.x, u.start.y, u.points[0], u.points[1], u.points[2], u.points[3], u.points[4], u.points[5]);
+                        const p = Ui.getPointOnCubicBezier(g, u.start.x, u.start.y, u.points[0], u.points[1], u.points[2], u.points[3], u.points[4], u.points[5]);
                         t.push(p.x, p.y)
                     } else t = t.concat(u.points)
             });
-            for (var n = t[0], i = t[0], r = t[1], a = t[1], s, o, l = 0; l < t.length / 2; l++) s = t[l * 2], o = t[l * 2 + 1], isNaN(s) || (n = Math.min(n, s), i = Math.max(i, s)), isNaN(o) || (r = Math.min(r, o), a = Math.max(a, o));
+            for (var n = t[0], i = t[0], r = t[1], s = t[1], a, o, l = 0; l < t.length / 2; l++) a = t[l * 2], o = t[l * 2 + 1], isNaN(a) || (n = Math.min(n, a), i = Math.max(i, a)), isNaN(o) || (r = Math.min(r, o), s = Math.max(s, o));
             return {
                 x: n,
                 y: r,
                 width: i - n,
-                height: a - r
+                height: s - r
             }
         }
         getLength() {
             return this.pathLength
         }
         getPointAtLength(t) {
             var n, i = 0,
@@ -4616,67 +4616,67 @@
                 x: n[0],
                 y: n[1]
             };
             if (t < .01) return n = this.dataArray[i].points.slice(0, 2), {
                 x: n[0],
                 y: n[1]
             };
-            var a = this.dataArray[i],
-                s = a.points;
-            switch (a.command) {
+            var s = this.dataArray[i],
+                a = s.points;
+            switch (s.command) {
                 case "L":
-                    return Vi.getPointOnLine(t, a.start.x, a.start.y, s[0], s[1]);
+                    return Ui.getPointOnLine(t, s.start.x, s.start.y, a[0], a[1]);
                 case "C":
-                    return Vi.getPointOnCubicBezier(t / a.pathLength, a.start.x, a.start.y, s[0], s[1], s[2], s[3], s[4], s[5]);
+                    return Ui.getPointOnCubicBezier(t / s.pathLength, s.start.x, s.start.y, a[0], a[1], a[2], a[3], a[4], a[5]);
                 case "Q":
-                    return Vi.getPointOnQuadraticBezier(t / a.pathLength, a.start.x, a.start.y, s[0], s[1], s[2], s[3]);
+                    return Ui.getPointOnQuadraticBezier(t / s.pathLength, s.start.x, s.start.y, a[0], a[1], a[2], a[3]);
                 case "A":
-                    var o = s[0],
-                        l = s[1],
-                        u = s[2],
-                        c = s[3],
-                        f = s[4],
-                        h = s[5],
-                        d = s[6];
-                    return f += h * t / a.pathLength, Vi.getPointOnEllipticalArc(o, l, u, c, f, d)
+                    var o = a[0],
+                        l = a[1],
+                        u = a[2],
+                        c = a[3],
+                        f = a[4],
+                        h = a[5],
+                        d = a[6];
+                    return f += h * t / s.pathLength, Ui.getPointOnEllipticalArc(o, l, u, c, f, d)
             }
             return null
         }
         static getLineLength(t, n, i, r) {
             return Math.sqrt((i - t) * (i - t) + (r - n) * (r - n))
         }
-        static getPointOnLine(t, n, i, r, a, s, o) {
-            s === void 0 && (s = n), o === void 0 && (o = i);
-            var l = (a - i) / (r - n + 1e-8),
+        static getPointOnLine(t, n, i, r, s, a, o) {
+            a === void 0 && (a = n), o === void 0 && (o = i);
+            var l = (s - i) / (r - n + 1e-8),
                 u = Math.sqrt(t * t / (1 + l * l));
             r < n && (u *= -1);
             var c = l * u,
                 f;
             if (r === n) f = {
-                x: s,
+                x: a,
                 y: o + c
             };
-            else if ((o - i) / (s - n + 1e-8) === l) f = {
-                x: s + u,
+            else if ((o - i) / (a - n + 1e-8) === l) f = {
+                x: a + u,
                 y: o + c
             };
             else {
-                var h, d, g = this.getLineLength(n, i, r, a),
-                    p = (s - n) * (r - n) + (o - i) * (a - i);
-                p = p / (g * g), h = n + p * (r - n), d = i + p * (a - i);
-                var m = this.getLineLength(s, o, h, d),
+                var h, d, g = this.getLineLength(n, i, r, s),
+                    p = (a - n) * (r - n) + (o - i) * (s - i);
+                p = p / (g * g), h = n + p * (r - n), d = i + p * (s - i);
+                var m = this.getLineLength(a, o, h, d),
                     y = Math.sqrt(t * t - m * m);
                 u = Math.sqrt(y * y / (1 + l * l)), r < n && (u *= -1), c = l * u, f = {
                     x: h + u,
                     y: d + c
                 }
             }
             return f
         }
-        static getPointOnCubicBezier(t, n, i, r, a, s, o, l, u) {
+        static getPointOnCubicBezier(t, n, i, r, s, a, o, l, u) {
             function c(m) {
                 return m * m * m
             }
 
             function f(m) {
                 return 3 * m * m * (1 - m)
             }
@@ -4684,67 +4684,67 @@
             function h(m) {
                 return 3 * m * (1 - m) * (1 - m)
             }
 
             function d(m) {
                 return (1 - m) * (1 - m) * (1 - m)
             }
-            var g = l * c(t) + s * f(t) + r * h(t) + n * d(t),
-                p = u * c(t) + o * f(t) + a * h(t) + i * d(t);
+            var g = l * c(t) + a * f(t) + r * h(t) + n * d(t),
+                p = u * c(t) + o * f(t) + s * h(t) + i * d(t);
             return {
                 x: g,
                 y: p
             }
         }
-        static getPointOnQuadraticBezier(t, n, i, r, a, s, o) {
+        static getPointOnQuadraticBezier(t, n, i, r, s, a, o) {
             function l(d) {
                 return d * d
             }
 
             function u(d) {
                 return 2 * d * (1 - d)
             }
 
             function c(d) {
                 return (1 - d) * (1 - d)
             }
-            var f = s * l(t) + r * u(t) + n * c(t),
-                h = o * l(t) + a * u(t) + i * c(t);
+            var f = a * l(t) + r * u(t) + n * c(t),
+                h = o * l(t) + s * u(t) + i * c(t);
             return {
                 x: f,
                 y: h
             }
         }
-        static getPointOnEllipticalArc(t, n, i, r, a, s) {
-            var o = Math.cos(s),
-                l = Math.sin(s),
+        static getPointOnEllipticalArc(t, n, i, r, s, a) {
+            var o = Math.cos(a),
+                l = Math.sin(a),
                 u = {
-                    x: i * Math.cos(a),
-                    y: r * Math.sin(a)
+                    x: i * Math.cos(s),
+                    y: r * Math.sin(s)
                 };
             return {
                 x: t + (u.x * o - u.y * l),
                 y: n + (u.x * l + u.y * o)
             }
         }
         static parsePathData(t) {
             if (!t) return [];
             var n = t,
                 i = ["m", "M", "l", "L", "v", "V", "h", "H", "z", "Z", "c", "C", "q", "Q", "t", "T", "s", "S", "a", "A"];
             n = n.replace(new RegExp(" ", "g"), ",");
             for (var r = 0; r < i.length; r++) n = n.replace(new RegExp(i[r], "g"), "|" + i[r]);
-            var a = n.split("|"),
-                s = [],
+            var s = n.split("|"),
+                a = [],
                 o = [],
                 l = 0,
                 u = 0,
                 c = /([-+]?((\d+\.\d+)|((\d+)|(\.\d+)))(?:e[-+]?\d+)?)/gi,
                 f;
-            for (r = 1; r < a.length; r++) {
-                var h = a[r],
+            for (r = 1; r < s.length; r++) {
+                var h = s[r],
                     d = h.charAt(0);
                 for (h = h.slice(1), o.length = 0; f = c.exec(h);) o.push(f[0]);
                 for (var g = [], p = 0, m = o.length; p < m; p++) {
                     if (o[p] === "00") {
                         g.push(0, 0);
                         continue
                     }
@@ -4752,29 +4752,29 @@
                     isNaN(y) ? g.push(0) : g.push(y)
                 }
                 for (; g.length > 0 && !isNaN(g[0]);) {
                     var v = null,
                         b = [],
                         x = l,
                         _ = u,
-                        S, w, O, k, C, E, T, A, F, $;
+                        S, w, E, A, C, k, R, $, T, M;
                     switch (d) {
                         case "l":
                             l += g.shift(), u += g.shift(), v = "L", b.push(l, u);
                             break;
                         case "L":
                             l = g.shift(), u = g.shift(), b.push(l, u);
                             break;
                         case "m":
-                            var D = g.shift(),
-                                P = g.shift();
-                            if (l += D, u += P, v = "M", s.length > 2 && s[s.length - 1].command === "z") {
-                                for (var N = s.length - 2; N >= 0; N--)
-                                    if (s[N].command === "M") {
-                                        l = s[N].points[0] + D, u = s[N].points[1] + P;
+                            var F = g.shift(),
+                                N = g.shift();
+                            if (l += F, u += N, v = "M", a.length > 2 && a[a.length - 1].command === "z") {
+                                for (var P = a.length - 2; P >= 0; P--)
+                                    if (a[P].command === "M") {
+                                        l = a[P].points[0] + F, u = a[P].points[1] + N;
                                         break
                                     }
                             }
                             b.push(l, u), d = "l";
                             break;
                         case "M":
                             l = g.shift(), u = g.shift(), v = "M", b.push(l, u), d = "L";
@@ -4794,133 +4794,133 @@
                         case "C":
                             b.push(g.shift(), g.shift(), g.shift(), g.shift()), l = g.shift(), u = g.shift(), b.push(l, u);
                             break;
                         case "c":
                             b.push(l + g.shift(), u + g.shift(), l + g.shift(), u + g.shift()), l += g.shift(), u += g.shift(), v = "C", b.push(l, u);
                             break;
                         case "S":
-                            w = l, O = u, S = s[s.length - 1], S.command === "C" && (w = l + (l - S.points[2]), O = u + (u - S.points[3])), b.push(w, O, g.shift(), g.shift()), l = g.shift(), u = g.shift(), v = "C", b.push(l, u);
+                            w = l, E = u, S = a[a.length - 1], S.command === "C" && (w = l + (l - S.points[2]), E = u + (u - S.points[3])), b.push(w, E, g.shift(), g.shift()), l = g.shift(), u = g.shift(), v = "C", b.push(l, u);
                             break;
                         case "s":
-                            w = l, O = u, S = s[s.length - 1], S.command === "C" && (w = l + (l - S.points[2]), O = u + (u - S.points[3])), b.push(w, O, l + g.shift(), u + g.shift()), l += g.shift(), u += g.shift(), v = "C", b.push(l, u);
+                            w = l, E = u, S = a[a.length - 1], S.command === "C" && (w = l + (l - S.points[2]), E = u + (u - S.points[3])), b.push(w, E, l + g.shift(), u + g.shift()), l += g.shift(), u += g.shift(), v = "C", b.push(l, u);
                             break;
                         case "Q":
                             b.push(g.shift(), g.shift()), l = g.shift(), u = g.shift(), b.push(l, u);
                             break;
                         case "q":
                             b.push(l + g.shift(), u + g.shift()), l += g.shift(), u += g.shift(), v = "Q", b.push(l, u);
                             break;
                         case "T":
-                            w = l, O = u, S = s[s.length - 1], S.command === "Q" && (w = l + (l - S.points[0]), O = u + (u - S.points[1])), l = g.shift(), u = g.shift(), v = "Q", b.push(w, O, l, u);
+                            w = l, E = u, S = a[a.length - 1], S.command === "Q" && (w = l + (l - S.points[0]), E = u + (u - S.points[1])), l = g.shift(), u = g.shift(), v = "Q", b.push(w, E, l, u);
                             break;
                         case "t":
-                            w = l, O = u, S = s[s.length - 1], S.command === "Q" && (w = l + (l - S.points[0]), O = u + (u - S.points[1])), l += g.shift(), u += g.shift(), v = "Q", b.push(w, O, l, u);
+                            w = l, E = u, S = a[a.length - 1], S.command === "Q" && (w = l + (l - S.points[0]), E = u + (u - S.points[1])), l += g.shift(), u += g.shift(), v = "Q", b.push(w, E, l, u);
                             break;
                         case "A":
-                            k = g.shift(), C = g.shift(), E = g.shift(), T = g.shift(), A = g.shift(), F = l, $ = u, l = g.shift(), u = g.shift(), v = "A", b = this.convertEndpointToCenterParameterization(F, $, l, u, T, A, k, C, E);
+                            A = g.shift(), C = g.shift(), k = g.shift(), R = g.shift(), $ = g.shift(), T = l, M = u, l = g.shift(), u = g.shift(), v = "A", b = this.convertEndpointToCenterParameterization(T, M, l, u, R, $, A, C, k);
                             break;
                         case "a":
-                            k = g.shift(), C = g.shift(), E = g.shift(), T = g.shift(), A = g.shift(), F = l, $ = u, l += g.shift(), u += g.shift(), v = "A", b = this.convertEndpointToCenterParameterization(F, $, l, u, T, A, k, C, E);
+                            A = g.shift(), C = g.shift(), k = g.shift(), R = g.shift(), $ = g.shift(), T = l, M = u, l += g.shift(), u += g.shift(), v = "A", b = this.convertEndpointToCenterParameterization(T, M, l, u, R, $, A, C, k);
                             break
                     }
-                    s.push({
+                    a.push({
                         command: v || d,
                         points: b,
                         start: {
                             x,
                             y: _
                         },
                         pathLength: this.calcLength(x, _, v || d, b)
                     })
-                }(d === "z" || d === "Z") && s.push({
+                }(d === "z" || d === "Z") && a.push({
                     command: "z",
                     points: [],
                     start: void 0,
                     pathLength: 0
                 })
             }
-            return s
+            return a
         }
         static calcLength(t, n, i, r) {
-            var a, s, o, l, u = Vi;
+            var s, a, o, l, u = Ui;
             switch (i) {
                 case "L":
                     return u.getLineLength(t, n, r[0], r[1]);
                 case "C":
-                    for (a = 0, s = u.getPointOnCubicBezier(0, t, n, r[0], r[1], r[2], r[3], r[4], r[5]), l = .01; l <= 1; l += .01) o = u.getPointOnCubicBezier(l, t, n, r[0], r[1], r[2], r[3], r[4], r[5]), a += u.getLineLength(s.x, s.y, o.x, o.y), s = o;
-                    return a;
+                    for (s = 0, a = u.getPointOnCubicBezier(0, t, n, r[0], r[1], r[2], r[3], r[4], r[5]), l = .01; l <= 1; l += .01) o = u.getPointOnCubicBezier(l, t, n, r[0], r[1], r[2], r[3], r[4], r[5]), s += u.getLineLength(a.x, a.y, o.x, o.y), a = o;
+                    return s;
                 case "Q":
-                    for (a = 0, s = u.getPointOnQuadraticBezier(0, t, n, r[0], r[1], r[2], r[3]), l = .01; l <= 1; l += .01) o = u.getPointOnQuadraticBezier(l, t, n, r[0], r[1], r[2], r[3]), a += u.getLineLength(s.x, s.y, o.x, o.y), s = o;
-                    return a;
+                    for (s = 0, a = u.getPointOnQuadraticBezier(0, t, n, r[0], r[1], r[2], r[3]), l = .01; l <= 1; l += .01) o = u.getPointOnQuadraticBezier(l, t, n, r[0], r[1], r[2], r[3]), s += u.getLineLength(a.x, a.y, o.x, o.y), a = o;
+                    return s;
                 case "A":
-                    a = 0;
+                    s = 0;
                     var c = r[4],
                         f = r[5],
                         h = r[4] + f,
                         d = Math.PI / 180;
-                    if (Math.abs(c - h) < d && (d = Math.abs(c - h)), s = u.getPointOnEllipticalArc(r[0], r[1], r[2], r[3], c, 0), f < 0)
-                        for (l = c - d; l > h; l -= d) o = u.getPointOnEllipticalArc(r[0], r[1], r[2], r[3], l, 0), a += u.getLineLength(s.x, s.y, o.x, o.y), s = o;
+                    if (Math.abs(c - h) < d && (d = Math.abs(c - h)), a = u.getPointOnEllipticalArc(r[0], r[1], r[2], r[3], c, 0), f < 0)
+                        for (l = c - d; l > h; l -= d) o = u.getPointOnEllipticalArc(r[0], r[1], r[2], r[3], l, 0), s += u.getLineLength(a.x, a.y, o.x, o.y), a = o;
                     else
-                        for (l = c + d; l < h; l += d) o = u.getPointOnEllipticalArc(r[0], r[1], r[2], r[3], l, 0), a += u.getLineLength(s.x, s.y, o.x, o.y), s = o;
-                    return o = u.getPointOnEllipticalArc(r[0], r[1], r[2], r[3], h, 0), a += u.getLineLength(s.x, s.y, o.x, o.y), a
+                        for (l = c + d; l < h; l += d) o = u.getPointOnEllipticalArc(r[0], r[1], r[2], r[3], l, 0), s += u.getLineLength(a.x, a.y, o.x, o.y), a = o;
+                    return o = u.getPointOnEllipticalArc(r[0], r[1], r[2], r[3], h, 0), s += u.getLineLength(a.x, a.y, o.x, o.y), s
             }
             return 0
         }
-        static convertEndpointToCenterParameterization(t, n, i, r, a, s, o, l, u) {
+        static convertEndpointToCenterParameterization(t, n, i, r, s, a, o, l, u) {
             var c = u * (Math.PI / 180),
                 f = Math.cos(c) * (t - i) / 2 + Math.sin(c) * (n - r) / 2,
                 h = -1 * Math.sin(c) * (t - i) / 2 + Math.cos(c) * (n - r) / 2,
                 d = f * f / (o * o) + h * h / (l * l);
             d > 1 && (o *= Math.sqrt(d), l *= Math.sqrt(d));
             var g = Math.sqrt((o * o * (l * l) - o * o * (h * h) - l * l * (f * f)) / (o * o * (h * h) + l * l * (f * f)));
-            a === s && (g *= -1), isNaN(g) && (g = 0);
+            s === a && (g *= -1), isNaN(g) && (g = 0);
             var p = g * o * h / l,
                 m = g * -l * f / o,
                 y = (t + i) / 2 + Math.cos(c) * p - Math.sin(c) * m,
                 v = (n + r) / 2 + Math.sin(c) * p + Math.cos(c) * m,
                 b = function(C) {
                     return Math.sqrt(C[0] * C[0] + C[1] * C[1])
                 },
-                x = function(C, E) {
-                    return (C[0] * E[0] + C[1] * E[1]) / (b(C) * b(E))
+                x = function(C, k) {
+                    return (C[0] * k[0] + C[1] * k[1]) / (b(C) * b(k))
                 },
-                _ = function(C, E) {
-                    return (C[0] * E[1] < C[1] * E[0] ? -1 : 1) * Math.acos(x(C, E))
+                _ = function(C, k) {
+                    return (C[0] * k[1] < C[1] * k[0] ? -1 : 1) * Math.acos(x(C, k))
                 },
                 S = _([1, 0], [(f - p) / o, (h - m) / l]),
                 w = [(f - p) / o, (h - m) / l],
-                O = [(-1 * f - p) / o, (-1 * h - m) / l],
-                k = _(w, O);
-            return x(w, O) <= -1 && (k = Math.PI), x(w, O) >= 1 && (k = 0), s === 0 && k > 0 && (k = k - 2 * Math.PI), s === 1 && k < 0 && (k = k + 2 * Math.PI), [y, v, o, l, S, k, c, s]
+                E = [(-1 * f - p) / o, (-1 * h - m) / l],
+                A = _(w, E);
+            return x(w, E) <= -1 && (A = Math.PI), x(w, E) >= 1 && (A = 0), a === 0 && A > 0 && (A = A - 2 * Math.PI), a === 1 && A < 0 && (A = A + 2 * Math.PI), [y, v, o, l, S, A, c, a]
         }
     };
-    Jt.prototype.className = "Path";
-    Jt.prototype._attrsAffectingSize = ["data"];
-    mt(Jt);
-    M.addGetterSetter(Jt, "data");
-    class Fl extends Qa {
+    Yt.prototype.className = "Path";
+    Yt.prototype._attrsAffectingSize = ["data"];
+    pt(Yt);
+    O.addGetterSetter(Yt, "data");
+    class _l extends Gs {
         _sceneFunc(t) {
             super._sceneFunc(t);
             var n = Math.PI * 2,
                 i = this.points(),
                 r = i,
-                a = this.tension() !== 0 && i.length > 4;
-            a && (r = this.getTensionPoints());
-            var s = this.pointerLength(),
+                s = this.tension() !== 0 && i.length > 4;
+            s && (r = this.getTensionPoints());
+            var a = this.pointerLength(),
                 o = i.length,
                 l, u;
-            if (a) {
+            if (s) {
                 const h = [r[r.length - 4], r[r.length - 3], r[r.length - 2], r[r.length - 1], i[o - 2], i[o - 1]],
-                    d = Jt.calcLength(r[r.length - 4], r[r.length - 3], "C", h),
-                    g = Jt.getPointOnQuadraticBezier(Math.min(1, 1 - s / d), h[0], h[1], h[2], h[3], h[4], h[5]);
+                    d = Yt.calcLength(r[r.length - 4], r[r.length - 3], "C", h),
+                    g = Yt.getPointOnQuadraticBezier(Math.min(1, 1 - a / d), h[0], h[1], h[2], h[3], h[4], h[5]);
                 l = i[o - 2] - g.x, u = i[o - 1] - g.y
             } else l = i[o - 2] - i[o - 4], u = i[o - 1] - i[o - 3];
             var c = (Math.atan2(u, l) + n) % n,
                 f = this.pointerWidth();
-            this.pointerAtEnding() && (t.save(), t.beginPath(), t.translate(i[o - 2], i[o - 1]), t.rotate(c), t.moveTo(0, 0), t.lineTo(-s, f / 2), t.lineTo(-s, -f / 2), t.closePath(), t.restore(), this.__fillStroke(t)), this.pointerAtBeginning() && (t.save(), t.beginPath(), t.translate(i[0], i[1]), a ? (l = (r[0] + r[2]) / 2 - i[0], u = (r[1] + r[3]) / 2 - i[1]) : (l = i[2] - i[0], u = i[3] - i[1]), t.rotate((Math.atan2(-u, -l) + n) % n), t.moveTo(0, 0), t.lineTo(-s, f / 2), t.lineTo(-s, -f / 2), t.closePath(), t.restore(), this.__fillStroke(t))
+            this.pointerAtEnding() && (t.save(), t.beginPath(), t.translate(i[o - 2], i[o - 1]), t.rotate(c), t.moveTo(0, 0), t.lineTo(-a, f / 2), t.lineTo(-a, -f / 2), t.closePath(), t.restore(), this.__fillStroke(t)), this.pointerAtBeginning() && (t.save(), t.beginPath(), t.translate(i[0], i[1]), s ? (l = (r[0] + r[2]) / 2 - i[0], u = (r[1] + r[3]) / 2 - i[1]) : (l = i[2] - i[0], u = i[3] - i[1]), t.rotate((Math.atan2(-u, -l) + n) % n), t.moveTo(0, 0), t.lineTo(-a, f / 2), t.lineTo(-a, -f / 2), t.closePath(), t.restore(), this.__fillStroke(t))
         }
         __fillStroke(t) {
             var n = this.dashEnabled();
             n && (this.attrs.dashEnabled = !1, t.setLineDash([])), t.fillStrokeShape(this), n && (this.attrs.dashEnabled = !0)
         }
         getSelfRect() {
             const t = super.getSelfRect(),
@@ -4929,21 +4929,21 @@
                 x: t.x - n,
                 y: t.y - n,
                 width: t.width + n * 2,
                 height: t.height + n * 2
             }
         }
     }
-    Fl.prototype.className = "Arrow";
-    mt(Fl);
-    M.addGetterSetter(Fl, "pointerLength", 10, ee());
-    M.addGetterSetter(Fl, "pointerWidth", 10, ee());
-    M.addGetterSetter(Fl, "pointerAtBeginning", !1);
-    M.addGetterSetter(Fl, "pointerAtEnding", !0);
-    class Oc extends V {
+    _l.prototype.className = "Arrow";
+    pt(_l);
+    O.addGetterSetter(_l, "pointerLength", 10, te());
+    O.addGetterSetter(_l, "pointerWidth", 10, te());
+    O.addGetterSetter(_l, "pointerAtBeginning", !1);
+    O.addGetterSetter(_l, "pointerAtEnding", !0);
+    class dc extends V {
         _sceneFunc(t) {
             t.beginPath(), t.arc(0, 0, this.attrs.radius || 0, 0, Math.PI * 2, !1), t.closePath(), t.fillStrokeShape(this)
         }
         getWidth() {
             return this.radius() * 2
         }
         getHeight() {
@@ -4952,20 +4952,20 @@
         setWidth(t) {
             this.radius() !== t / 2 && this.radius(t / 2)
         }
         setHeight(t) {
             this.radius() !== t / 2 && this.radius(t / 2)
         }
     }
-    Oc.prototype._centroid = !0;
-    Oc.prototype.className = "Circle";
-    Oc.prototype._attrsAffectingSize = ["radius"];
-    mt(Oc);
-    M.addGetterSetter(Oc, "radius", 0, ee());
-    class ro extends V {
+    dc.prototype._centroid = !0;
+    dc.prototype.className = "Circle";
+    dc.prototype._attrsAffectingSize = ["radius"];
+    pt(dc);
+    O.addGetterSetter(dc, "radius", 0, te());
+    class Ya extends V {
         _sceneFunc(t) {
             var n = this.radiusX(),
                 i = this.radiusY();
             t.beginPath(), t.save(), n !== i && t.scale(1, i / n), t.arc(0, 0, n, 0, Math.PI * 2, !1), t.restore(), t.closePath(), t.fillStrokeShape(this)
         }
         getWidth() {
             return this.radiusX() * 2
@@ -4976,22 +4976,22 @@
         setWidth(t) {
             this.radiusX(t / 2)
         }
         setHeight(t) {
             this.radiusY(t / 2)
         }
     }
-    ro.prototype.className = "Ellipse";
-    ro.prototype._centroid = !0;
-    ro.prototype._attrsAffectingSize = ["radiusX", "radiusY"];
-    mt(ro);
-    M.addComponentsGetterSetter(ro, "radius", ["x", "y"]);
-    M.addGetterSetter(ro, "radiusX", 0, ee());
-    M.addGetterSetter(ro, "radiusY", 0, ee());
-    let sa = class LM extends V {
+    Ya.prototype.className = "Ellipse";
+    Ya.prototype._centroid = !0;
+    Ya.prototype._attrsAffectingSize = ["radiusX", "radiusY"];
+    pt(Ya);
+    O.addComponentsGetterSetter(Ya, "radius", ["x", "y"]);
+    O.addGetterSetter(Ya, "radiusX", 0, te());
+    O.addGetterSetter(Ya, "radiusY", 0, te());
+    let Qr = class XM extends V {
         constructor(t) {
             super(t), this.on("imageChange.konva", () => {
                 this._setImageLoad()
             }), this._setImageLoad()
         }
         _setImageLoad() {
             const t = this.image();
@@ -5002,64 +5002,64 @@
         _useBufferCanvas() {
             return super._useBufferCanvas(!0)
         }
         _sceneFunc(t) {
             const n = this.getWidth(),
                 i = this.getHeight(),
                 r = this.cornerRadius(),
-                a = this.attrs.image;
-            let s;
-            if (a) {
+                s = this.attrs.image;
+            let a;
+            if (s) {
                 const o = this.attrs.cropWidth,
                     l = this.attrs.cropHeight;
-                o && l ? s = [a, this.cropX(), this.cropY(), o, l, 0, 0, n, i] : s = [a, 0, 0, n, i]
-            }(this.hasFill() || this.hasStroke() || r) && (t.beginPath(), r ? R.drawRoundedRectPath(t, n, i, r) : t.rect(0, 0, n, i), t.closePath(), t.fillStrokeShape(this)), a && (r && t.clip(), t.drawImage.apply(t, s))
+                o && l ? a = [s, this.cropX(), this.cropY(), o, l, 0, 0, n, i] : a = [s, 0, 0, n, i]
+            }(this.hasFill() || this.hasStroke() || r) && (t.beginPath(), r ? D.drawRoundedRectPath(t, n, i, r) : t.rect(0, 0, n, i), t.closePath(), t.fillStrokeShape(this)), s && (r && t.clip(), t.drawImage.apply(t, a))
         }
         _hitFunc(t) {
             var n = this.width(),
                 i = this.height(),
                 r = this.cornerRadius();
-            t.beginPath(), r ? R.drawRoundedRectPath(t, n, i, r) : t.rect(0, 0, n, i), t.closePath(), t.fillStrokeShape(this)
+            t.beginPath(), r ? D.drawRoundedRectPath(t, n, i, r) : t.rect(0, 0, n, i), t.closePath(), t.fillStrokeShape(this)
         }
         getWidth() {
             var t, n;
             return (t = this.attrs.width) !== null && t !== void 0 ? t : (n = this.image()) === null || n === void 0 ? void 0 : n.width
         }
         getHeight() {
             var t, n;
             return (t = this.attrs.height) !== null && t !== void 0 ? t : (n = this.image()) === null || n === void 0 ? void 0 : n.height
         }
         static fromURL(t, n, i = null) {
-            var r = R.createImageElement();
+            var r = D.createImageElement();
             r.onload = function() {
-                var a = new LM({
+                var s = new XM({
                     image: r
                 });
-                n(a)
+                n(s)
             }, r.onerror = i, r.crossOrigin = "Anonymous", r.src = t
         }
     };
-    sa.prototype.className = "Image";
-    mt(sa);
-    M.addGetterSetter(sa, "cornerRadius", 0, Kx(4));
-    M.addGetterSetter(sa, "image");
-    M.addComponentsGetterSetter(sa, "crop", ["x", "y", "width", "height"]);
-    M.addGetterSetter(sa, "cropX", 0, ee());
-    M.addGetterSetter(sa, "cropY", 0, ee());
-    M.addGetterSetter(sa, "cropWidth", 0, ee());
-    M.addGetterSetter(sa, "cropHeight", 0, ee());
-    var IM = ["fontFamily", "fontSize", "fontStyle", "padding", "lineHeight", "text", "width", "height", "pointerDirection", "pointerWidth", "pointerHeight"],
-        l7 = "Change.konva",
-        u7 = "none",
-        Ob = "up",
-        Cb = "right",
-        kb = "down",
-        Ab = "left",
-        c7 = IM.length;
-    let t_ = class extends Bu {
+    Qr.prototype.className = "Image";
+    pt(Qr);
+    O.addGetterSetter(Qr, "cornerRadius", 0, px(4));
+    O.addGetterSetter(Qr, "image");
+    O.addComponentsGetterSetter(Qr, "crop", ["x", "y", "width", "height"]);
+    O.addGetterSetter(Qr, "cropX", 0, te());
+    O.addGetterSetter(Qr, "cropY", 0, te());
+    O.addGetterSetter(Qr, "cropWidth", 0, te());
+    O.addGetterSetter(Qr, "cropHeight", 0, te());
+    var VM = ["fontFamily", "fontSize", "fontStyle", "padding", "lineHeight", "text", "width", "height", "pointerDirection", "pointerWidth", "pointerHeight"],
+        p7 = "Change.konva",
+        m7 = "none",
+        Zv = "up",
+        eb = "right",
+        tb = "down",
+        nb = "left",
+        y7 = VM.length;
+    let xx = class extends Mu {
         constructor(t) {
             super(t), this.on("add.konva", function(n) {
                 this._addListeners(n.child), this._sync()
             })
         }
         getText() {
             return this.find("Text")[0]
@@ -5068,103 +5068,103 @@
             return this.find("Tag")[0]
         }
         _addListeners(t) {
             var n = this,
                 i, r = function() {
                     n._sync()
                 };
-            for (i = 0; i < c7; i++) t.on(IM[i] + l7, r)
+            for (i = 0; i < y7; i++) t.on(VM[i] + p7, r)
         }
         getWidth() {
             return this.getText().width()
         }
         getHeight() {
             return this.getText().height()
         }
         _sync() {
             var t = this.getText(),
                 n = this.getTag(),
-                i, r, a, s, o, l, u;
+                i, r, s, a, o, l, u;
             if (t && n) {
-                switch (i = t.width(), r = t.height(), a = n.pointerDirection(), s = n.pointerWidth(), u = n.pointerHeight(), o = 0, l = 0, a) {
-                    case Ob:
+                switch (i = t.width(), r = t.height(), s = n.pointerDirection(), a = n.pointerWidth(), u = n.pointerHeight(), o = 0, l = 0, s) {
+                    case Zv:
                         o = i / 2, l = -1 * u;
                         break;
-                    case Cb:
-                        o = i + s, l = r / 2;
+                    case eb:
+                        o = i + a, l = r / 2;
                         break;
-                    case kb:
+                    case tb:
                         o = i / 2, l = r + u;
                         break;
-                    case Ab:
-                        o = -1 * s, l = r / 2;
+                    case nb:
+                        o = -1 * a, l = r / 2;
                         break
                 }
                 n.setAttrs({
                     x: -1 * o,
                     y: -1 * l,
                     width: i,
                     height: r
                 }), t.setAttrs({
                     x: -1 * o,
                     y: -1 * l
                 })
             }
         }
     };
-    t_.prototype.className = "Label";
-    mt(t_);
-    class Dl extends V {
+    xx.prototype.className = "Label";
+    pt(xx);
+    class wl extends V {
         _sceneFunc(t) {
             var n = this.width(),
                 i = this.height(),
                 r = this.pointerDirection(),
-                a = this.pointerWidth(),
-                s = this.pointerHeight(),
+                s = this.pointerWidth(),
+                a = this.pointerHeight(),
                 o = this.cornerRadius();
             let l = 0,
                 u = 0,
                 c = 0,
                 f = 0;
-            typeof o == "number" ? l = u = c = f = Math.min(o, n / 2, i / 2) : (l = Math.min(o[0] || 0, n / 2, i / 2), u = Math.min(o[1] || 0, n / 2, i / 2), f = Math.min(o[2] || 0, n / 2, i / 2), c = Math.min(o[3] || 0, n / 2, i / 2)), t.beginPath(), t.moveTo(l, 0), r === Ob && (t.lineTo((n - a) / 2, 0), t.lineTo(n / 2, -1 * s), t.lineTo((n + a) / 2, 0)), t.lineTo(n - u, 0), t.arc(n - u, u, u, Math.PI * 3 / 2, 0, !1), r === Cb && (t.lineTo(n, (i - s) / 2), t.lineTo(n + a, i / 2), t.lineTo(n, (i + s) / 2)), t.lineTo(n, i - f), t.arc(n - f, i - f, f, 0, Math.PI / 2, !1), r === kb && (t.lineTo((n + a) / 2, i), t.lineTo(n / 2, i + s), t.lineTo((n - a) / 2, i)), t.lineTo(c, i), t.arc(c, i - c, c, Math.PI / 2, Math.PI, !1), r === Ab && (t.lineTo(0, (i + s) / 2), t.lineTo(-1 * a, i / 2), t.lineTo(0, (i - s) / 2)), t.lineTo(0, l), t.arc(l, l, l, Math.PI, Math.PI * 3 / 2, !1), t.closePath(), t.fillStrokeShape(this)
+            typeof o == "number" ? l = u = c = f = Math.min(o, n / 2, i / 2) : (l = Math.min(o[0] || 0, n / 2, i / 2), u = Math.min(o[1] || 0, n / 2, i / 2), f = Math.min(o[2] || 0, n / 2, i / 2), c = Math.min(o[3] || 0, n / 2, i / 2)), t.beginPath(), t.moveTo(l, 0), r === Zv && (t.lineTo((n - s) / 2, 0), t.lineTo(n / 2, -1 * a), t.lineTo((n + s) / 2, 0)), t.lineTo(n - u, 0), t.arc(n - u, u, u, Math.PI * 3 / 2, 0, !1), r === eb && (t.lineTo(n, (i - a) / 2), t.lineTo(n + s, i / 2), t.lineTo(n, (i + a) / 2)), t.lineTo(n, i - f), t.arc(n - f, i - f, f, 0, Math.PI / 2, !1), r === tb && (t.lineTo((n + s) / 2, i), t.lineTo(n / 2, i + a), t.lineTo((n - s) / 2, i)), t.lineTo(c, i), t.arc(c, i - c, c, Math.PI / 2, Math.PI, !1), r === nb && (t.lineTo(0, (i + a) / 2), t.lineTo(-1 * s, i / 2), t.lineTo(0, (i - a) / 2)), t.lineTo(0, l), t.arc(l, l, l, Math.PI, Math.PI * 3 / 2, !1), t.closePath(), t.fillStrokeShape(this)
         }
         getSelfRect() {
             var t = 0,
                 n = 0,
                 i = this.pointerWidth(),
                 r = this.pointerHeight(),
-                a = this.pointerDirection(),
-                s = this.width(),
+                s = this.pointerDirection(),
+                a = this.width(),
                 o = this.height();
-            return a === Ob ? (n -= r, o += r) : a === kb ? o += r : a === Ab ? (t -= i * 1.5, s += i) : a === Cb && (s += i * 1.5), {
+            return s === Zv ? (n -= r, o += r) : s === tb ? o += r : s === nb ? (t -= i * 1.5, a += i) : s === eb && (a += i * 1.5), {
                 x: t,
                 y: n,
-                width: s,
+                width: a,
                 height: o
             }
         }
     }
-    Dl.prototype.className = "Tag";
-    mt(Dl);
-    M.addGetterSetter(Dl, "pointerDirection", u7);
-    M.addGetterSetter(Dl, "pointerWidth", 0, ee());
-    M.addGetterSetter(Dl, "pointerHeight", 0, ee());
-    M.addGetterSetter(Dl, "cornerRadius", 0, Kx(4));
-    class od extends V {
+    wl.prototype.className = "Tag";
+    pt(wl);
+    O.addGetterSetter(wl, "pointerDirection", m7);
+    O.addGetterSetter(wl, "pointerWidth", 0, te());
+    O.addGetterSetter(wl, "pointerHeight", 0, te());
+    O.addGetterSetter(wl, "cornerRadius", 0, px(4));
+    class Vh extends V {
         _sceneFunc(t) {
             var n = this.cornerRadius(),
                 i = this.width(),
                 r = this.height();
-            t.beginPath(), n ? R.drawRoundedRectPath(t, i, r, n) : t.rect(0, 0, i, r), t.closePath(), t.fillStrokeShape(this)
+            t.beginPath(), n ? D.drawRoundedRectPath(t, i, r, n) : t.rect(0, 0, i, r), t.closePath(), t.fillStrokeShape(this)
         }
     }
-    od.prototype.className = "Rect";
-    mt(od);
-    M.addGetterSetter(od, "cornerRadius", 0, Kx(4));
-    class Rl extends V {
+    Vh.prototype.className = "Rect";
+    pt(Vh);
+    O.addGetterSetter(Vh, "cornerRadius", 0, px(4));
+    class Sl extends V {
         _sceneFunc(t) {
             const n = this._getPoints();
             t.beginPath(), t.moveTo(n[0].x, n[0].y);
             for (var i = 1; i < n.length; i++) t.lineTo(n[i].x, n[i].y);
             t.closePath(), t.fillStrokeShape(this)
         }
         _getPoints() {
@@ -5178,22 +5178,22 @@
             return i
         }
         getSelfRect() {
             const t = this._getPoints();
             var n = t[0].x,
                 i = t[0].y,
                 r = t[0].x,
-                a = t[0].y;
-            return t.forEach(s => {
-                n = Math.min(n, s.x), i = Math.max(i, s.x), r = Math.min(r, s.y), a = Math.max(a, s.y)
+                s = t[0].y;
+            return t.forEach(a => {
+                n = Math.min(n, a.x), i = Math.max(i, a.x), r = Math.min(r, a.y), s = Math.max(s, a.y)
             }), {
                 x: n,
                 y: r,
                 width: i - n,
-                height: a - r
+                height: s - r
             }
         }
         getWidth() {
             return this.radius() * 2
         }
         getHeight() {
             return this.radius() * 2
@@ -5201,85 +5201,85 @@
         setWidth(t) {
             this.radius(t / 2)
         }
         setHeight(t) {
             this.radius(t / 2)
         }
     }
-    Rl.prototype.className = "RegularPolygon";
-    Rl.prototype._centroid = !0;
-    Rl.prototype._attrsAffectingSize = ["radius"];
-    mt(Rl);
-    M.addGetterSetter(Rl, "radius", 0, ee());
-    M.addGetterSetter(Rl, "sides", 0, ee());
-    var ik = Math.PI * 2;
-    class Pl extends V {
+    Sl.prototype.className = "RegularPolygon";
+    Sl.prototype._centroid = !0;
+    Sl.prototype._attrsAffectingSize = ["radius"];
+    pt(Sl);
+    O.addGetterSetter(Sl, "radius", 0, te());
+    O.addGetterSetter(Sl, "sides", 0, te());
+    var yk = Math.PI * 2;
+    class El extends V {
         _sceneFunc(t) {
-            t.beginPath(), t.arc(0, 0, this.innerRadius(), 0, ik, !1), t.moveTo(this.outerRadius(), 0), t.arc(0, 0, this.outerRadius(), ik, 0, !0), t.closePath(), t.fillStrokeShape(this)
+            t.beginPath(), t.arc(0, 0, this.innerRadius(), 0, yk, !1), t.moveTo(this.outerRadius(), 0), t.arc(0, 0, this.outerRadius(), yk, 0, !0), t.closePath(), t.fillStrokeShape(this)
         }
         getWidth() {
             return this.outerRadius() * 2
         }
         getHeight() {
             return this.outerRadius() * 2
         }
         setWidth(t) {
             this.outerRadius(t / 2)
         }
         setHeight(t) {
             this.outerRadius(t / 2)
         }
     }
-    Pl.prototype.className = "Ring";
-    Pl.prototype._centroid = !0;
-    Pl.prototype._attrsAffectingSize = ["innerRadius", "outerRadius"];
-    mt(Pl);
-    M.addGetterSetter(Pl, "innerRadius", 0, ee());
-    M.addGetterSetter(Pl, "outerRadius", 0, ee());
-    class oa extends V {
+    El.prototype.className = "Ring";
+    El.prototype._centroid = !0;
+    El.prototype._attrsAffectingSize = ["innerRadius", "outerRadius"];
+    pt(El);
+    O.addGetterSetter(El, "innerRadius", 0, te());
+    O.addGetterSetter(El, "outerRadius", 0, te());
+    class Zr extends V {
         constructor(t) {
-            super(t), this._updated = !0, this.anim = new Ti(() => {
+            super(t), this._updated = !0, this.anim = new Ci(() => {
                 var n = this._updated;
                 return this._updated = !1, n
             }), this.on("animationChange.konva", function() {
                 this.frameIndex(0)
             }), this.on("frameIndexChange.konva", function() {
                 this._updated = !0
             }), this.on("frameRateChange.konva", function() {
                 this.anim.isRunning() && (clearInterval(this.interval), this._setInterval())
             })
         }
         _sceneFunc(t) {
             var n = this.animation(),
                 i = this.frameIndex(),
                 r = i * 4,
-                a = this.animations()[n],
-                s = this.frameOffsets(),
-                o = a[r + 0],
-                l = a[r + 1],
-                u = a[r + 2],
-                c = a[r + 3],
+                s = this.animations()[n],
+                a = this.frameOffsets(),
+                o = s[r + 0],
+                l = s[r + 1],
+                u = s[r + 2],
+                c = s[r + 3],
                 f = this.image();
             if ((this.hasFill() || this.hasStroke()) && (t.beginPath(), t.rect(0, 0, u, c), t.closePath(), t.fillStrokeShape(this)), f)
-                if (s) {
-                    var h = s[n],
+                if (a) {
+                    var h = a[n],
                         d = i * 2;
                     t.drawImage(f, o, l, u, c, h[d + 0], h[d + 1], u, c)
                 } else t.drawImage(f, o, l, u, c, 0, 0, u, c)
         }
         _hitFunc(t) {
             var n = this.animation(),
                 i = this.frameIndex(),
                 r = i * 4,
-                a = this.animations()[n],
-                s = this.frameOffsets(),
-                o = a[r + 2],
-                l = a[r + 3];
-            if (t.beginPath(), s) {
-                var u = s[n],
+                s = this.animations()[n],
+                a = this.frameOffsets(),
+                o = s[r + 2],
+                l = s[r + 3];
+            if (t.beginPath(), a) {
+                var u = a[n],
                     c = i * 2;
                 t.rect(u[c + 0], u[c + 1], o, l)
             } else t.rect(0, 0, o, l);
             t.closePath(), t.fillShape(this)
         }
         _useBufferCanvas() {
             return super._useBufferCanvas(!0)
@@ -5303,41 +5303,41 @@
             return this.anim.isRunning()
         }
         _updateIndex() {
             var t = this.frameIndex(),
                 n = this.animation(),
                 i = this.animations(),
                 r = i[n],
-                a = r.length / 4;
-            t < a - 1 ? this.frameIndex(t + 1) : this.frameIndex(0)
+                s = r.length / 4;
+            t < s - 1 ? this.frameIndex(t + 1) : this.frameIndex(0)
         }
     }
-    oa.prototype.className = "Sprite";
-    mt(oa);
-    M.addGetterSetter(oa, "animation");
-    M.addGetterSetter(oa, "animations");
-    M.addGetterSetter(oa, "frameOffsets");
-    M.addGetterSetter(oa, "image");
-    M.addGetterSetter(oa, "frameIndex", 0, ee());
-    M.addGetterSetter(oa, "frameRate", 17, ee());
-    M.backCompat(oa, {
+    Zr.prototype.className = "Sprite";
+    pt(Zr);
+    O.addGetterSetter(Zr, "animation");
+    O.addGetterSetter(Zr, "animations");
+    O.addGetterSetter(Zr, "frameOffsets");
+    O.addGetterSetter(Zr, "image");
+    O.addGetterSetter(Zr, "frameIndex", 0, te());
+    O.addGetterSetter(Zr, "frameRate", 17, te());
+    O.backCompat(Zr, {
         index: "frameIndex",
         getIndex: "getFrameIndex",
         setIndex: "setFrameIndex"
     });
-    class ao extends V {
+    class Xa extends V {
         _sceneFunc(t) {
             var n = this.innerRadius(),
                 i = this.outerRadius(),
                 r = this.numPoints();
             t.beginPath(), t.moveTo(0, 0 - i);
-            for (var a = 1; a < r * 2; a++) {
-                var s = a % 2 === 0 ? i : n,
-                    o = s * Math.sin(a * Math.PI / r),
-                    l = -1 * s * Math.cos(a * Math.PI / r);
+            for (var s = 1; s < r * 2; s++) {
+                var a = s % 2 === 0 ? i : n,
+                    o = a * Math.sin(s * Math.PI / r),
+                    l = -1 * a * Math.cos(s * Math.PI / r);
                 t.lineTo(o, l)
             }
             t.closePath(), t.fillStrokeShape(this)
         }
         getWidth() {
             return this.outerRadius() * 2
         }
@@ -5347,216 +5347,216 @@
         setWidth(t) {
             this.outerRadius(t / 2)
         }
         setHeight(t) {
             this.outerRadius(t / 2)
         }
     }
-    ao.prototype.className = "Star";
-    ao.prototype._centroid = !0;
-    ao.prototype._attrsAffectingSize = ["innerRadius", "outerRadius"];
-    mt(ao);
-    M.addGetterSetter(ao, "numPoints", 5, ee());
-    M.addGetterSetter(ao, "innerRadius", 0, ee());
-    M.addGetterSetter(ao, "outerRadius", 0, ee());
+    Xa.prototype.className = "Star";
+    Xa.prototype._centroid = !0;
+    Xa.prototype._attrsAffectingSize = ["innerRadius", "outerRadius"];
+    pt(Xa);
+    O.addGetterSetter(Xa, "numPoints", 5, te());
+    O.addGetterSetter(Xa, "innerRadius", 0, te());
+    O.addGetterSetter(Xa, "outerRadius", 0, te());
 
-    function jM(e) {
+    function KM(e) {
         return Array.from(e)
     }
-    var tu = "auto",
-        f7 = "center",
-        tf = "justify",
-        h7 = "Change.konva",
-        d7 = "2d",
-        rk = "-",
-        zM = "left",
-        g7 = "text",
-        p7 = "Text",
-        m7 = "top",
-        y7 = "bottom",
-        ak = "middle",
-        BM = "normal",
-        v7 = "px ",
-        fg = " ",
-        b7 = "right",
-        x7 = "word",
-        _7 = "char",
-        sk = "none",
-        Ly = "…",
-        GM = ["fontFamily", "fontSize", "fontStyle", "fontVariant", "padding", "align", "verticalAlign", "lineHeight", "text", "width", "height", "wrap", "ellipsis", "letterSpacing"],
-        w7 = GM.length;
+    var Wl = "auto",
+        v7 = "center",
+        Uc = "justify",
+        b7 = "Change.konva",
+        x7 = "2d",
+        vk = "-",
+        JM = "left",
+        _7 = "text",
+        w7 = "Text",
+        S7 = "top",
+        E7 = "bottom",
+        bk = "middle",
+        QM = "normal",
+        C7 = "px ",
+        Kd = " ",
+        k7 = "right",
+        A7 = "word",
+        $7 = "char",
+        xk = "none",
+        py = "…",
+        ZM = ["fontFamily", "fontSize", "fontStyle", "fontVariant", "padding", "align", "verticalAlign", "lineHeight", "text", "width", "height", "wrap", "ellipsis", "letterSpacing"],
+        T7 = ZM.length;
 
-    function S7(e) {
+    function M7(e) {
         return e.split(",").map(t => {
             t = t.trim();
             const n = t.indexOf(" ") >= 0,
                 i = t.indexOf('"') >= 0 || t.indexOf("'") >= 0;
             return n && !i && (t = `"${t}"`), t
         }).join(", ")
     }
-    var hg;
+    var Jd;
 
-    function Iy() {
-        return hg || (hg = R.createCanvasElement().getContext(d7), hg)
+    function my() {
+        return Jd || (Jd = D.createCanvasElement().getContext(x7), Jd)
     }
 
-    function E7(e) {
+    function O7(e) {
         e.fillText(this._partialText, this._partialTextX, this._partialTextY)
     }
 
-    function O7(e) {
+    function F7(e) {
         e.strokeText(this._partialText, this._partialTextX, this._partialTextY)
     }
 
-    function C7(e) {
+    function R7(e) {
         return e = e || {}, !e.fillLinearGradientColorStops && !e.fillRadialGradientColorStops && !e.fillPatternImage && (e.fill = e.fill || "black"), e
     }
-    class pt extends V {
+    class gt extends V {
         constructor(t) {
-            super(C7(t)), this._partialTextX = 0, this._partialTextY = 0;
-            for (var n = 0; n < w7; n++) this.on(GM[n] + h7, this._setTextData);
+            super(R7(t)), this._partialTextX = 0, this._partialTextY = 0;
+            for (var n = 0; n < T7; n++) this.on(ZM[n] + b7, this._setTextData);
             this._setTextData()
         }
         _sceneFunc(t) {
             var n = this.textArr,
                 i = n.length;
             if (this.text()) {
                 var r = this.padding(),
-                    a = this.fontSize(),
-                    s = this.lineHeight() * a,
+                    s = this.fontSize(),
+                    a = this.lineHeight() * s,
                     o = this.verticalAlign(),
                     l = 0,
                     u = this.align(),
                     c = this.getWidth(),
                     f = this.letterSpacing(),
                     h = this.fill(),
                     d = this.textDecoration(),
                     g = d.indexOf("underline") !== -1,
                     p = d.indexOf("line-through") !== -1,
                     m, y = 0,
-                    y = s / 2,
+                    y = a / 2,
                     v = 0,
                     b = 0;
-                for (t.setAttr("font", this._getContextFont()), t.setAttr("textBaseline", ak), t.setAttr("textAlign", zM), o === ak ? l = (this.getHeight() - i * s - r * 2) / 2 : o === y7 && (l = this.getHeight() - i * s - r * 2), t.translate(r, l + r), m = 0; m < i; m++) {
+                for (t.setAttr("font", this._getContextFont()), t.setAttr("textBaseline", bk), t.setAttr("textAlign", JM), o === bk ? l = (this.getHeight() - i * a - r * 2) / 2 : o === E7 && (l = this.getHeight() - i * a - r * 2), t.translate(r, l + r), m = 0; m < i; m++) {
                     var v = 0,
                         b = 0,
                         x = n[m],
                         _ = x.text,
                         S = x.width,
                         w = x.lastInParagraph,
-                        O, k, C;
-                    if (t.save(), u === b7 ? v += c - S - r * 2 : u === f7 && (v += (c - S - r * 2) / 2), g) {
-                        t.save(), t.beginPath(), t.moveTo(v, y + b + Math.round(a / 2)), O = _.split(" ").length - 1, k = O === 0, C = u === tf && !w ? c - r * 2 : S, t.lineTo(v + Math.round(C), y + b + Math.round(a / 2)), t.lineWidth = a / 15;
-                        const D = this._getLinearGradient();
-                        t.strokeStyle = D || h, t.stroke(), t.restore()
+                        E, A, C;
+                    if (t.save(), u === k7 ? v += c - S - r * 2 : u === v7 && (v += (c - S - r * 2) / 2), g) {
+                        t.save(), t.beginPath(), t.moveTo(v, y + b + Math.round(s / 2)), E = _.split(" ").length - 1, A = E === 0, C = u === Uc && !w ? c - r * 2 : S, t.lineTo(v + Math.round(C), y + b + Math.round(s / 2)), t.lineWidth = s / 15;
+                        const F = this._getLinearGradient();
+                        t.strokeStyle = F || h, t.stroke(), t.restore()
                     }
                     if (p) {
-                        t.save(), t.beginPath(), t.moveTo(v, y + b), O = _.split(" ").length - 1, k = O === 0, C = u === tf && w && !k ? c - r * 2 : S, t.lineTo(v + Math.round(C), y + b), t.lineWidth = a / 15;
-                        const D = this._getLinearGradient();
-                        t.strokeStyle = D || h, t.stroke(), t.restore()
-                    }
-                    if (f !== 0 || u === tf) {
-                        O = _.split(" ").length - 1;
-                        for (var E = jM(_), T = 0; T < E.length; T++) {
-                            var A = E[T];
-                            A === " " && !w && u === tf && (v += (c - r * 2 - S) / O), this._partialTextX = v, this._partialTextY = y + b, this._partialText = A, t.fillStrokeShape(this), v += this.measureSize(A).width + f
+                        t.save(), t.beginPath(), t.moveTo(v, y + b), E = _.split(" ").length - 1, A = E === 0, C = u === Uc && w && !A ? c - r * 2 : S, t.lineTo(v + Math.round(C), y + b), t.lineWidth = s / 15;
+                        const F = this._getLinearGradient();
+                        t.strokeStyle = F || h, t.stroke(), t.restore()
+                    }
+                    if (f !== 0 || u === Uc) {
+                        E = _.split(" ").length - 1;
+                        for (var k = KM(_), R = 0; R < k.length; R++) {
+                            var $ = k[R];
+                            $ === " " && !w && u === Uc && (v += (c - r * 2 - S) / E), this._partialTextX = v, this._partialTextY = y + b, this._partialText = $, t.fillStrokeShape(this), v += this.measureSize($).width + f
                         }
                     } else this._partialTextX = v, this._partialTextY = y + b, this._partialText = _, t.fillStrokeShape(this);
-                    t.restore(), i > 1 && (y += s)
+                    t.restore(), i > 1 && (y += a)
                 }
             }
         }
         _hitFunc(t) {
             var n = this.getWidth(),
                 i = this.getHeight();
             t.beginPath(), t.rect(0, 0, n, i), t.closePath(), t.fillStrokeShape(this)
         }
         setText(t) {
-            var n = R._isString(t) ? t : t == null ? "" : t + "";
-            return this._setAttr(g7, n), this
+            var n = D._isString(t) ? t : t == null ? "" : t + "";
+            return this._setAttr(_7, n), this
         }
         getWidth() {
-            var t = this.attrs.width === tu || this.attrs.width === void 0;
+            var t = this.attrs.width === Wl || this.attrs.width === void 0;
             return t ? this.getTextWidth() + this.padding() * 2 : this.attrs.width
         }
         getHeight() {
-            var t = this.attrs.height === tu || this.attrs.height === void 0;
+            var t = this.attrs.height === Wl || this.attrs.height === void 0;
             return t ? this.fontSize() * this.textArr.length * this.lineHeight() + this.padding() * 2 : this.attrs.height
         }
         getTextWidth() {
             return this.textWidth
         }
         getTextHeight() {
-            return R.warn("text.getTextHeight() method is deprecated. Use text.height() - for full height and text.fontSize() - for one line height."), this.textHeight
+            return D.warn("text.getTextHeight() method is deprecated. Use text.height() - for full height and text.fontSize() - for one line height."), this.textHeight
         }
         measureSize(t) {
-            var n = Iy(),
+            var n = my(),
                 i = this.fontSize(),
                 r;
             return n.save(), n.font = this._getContextFont(), r = n.measureText(t), n.restore(), {
                 width: r.width,
                 height: i
             }
         }
         _getContextFont() {
-            return this.fontStyle() + fg + this.fontVariant() + fg + (this.fontSize() + v7) + S7(this.fontFamily())
+            return this.fontStyle() + Kd + this.fontVariant() + Kd + (this.fontSize() + C7) + M7(this.fontFamily())
         }
         _addTextLine(t) {
-            this.align() === tf && (t = t.trim());
+            this.align() === Uc && (t = t.trim());
             var i = this._getTextWidth(t);
             return this.textArr.push({
                 text: t,
                 width: i,
                 lastInParagraph: !1
             })
         }
         _getTextWidth(t) {
             var n = this.letterSpacing(),
                 i = t.length;
-            return Iy().measureText(t).width + (i ? n * (i - 1) : 0)
+            return my().measureText(t).width + (i ? n * (i - 1) : 0)
         }
         _setTextData() {
             var t = this.text().split(`
 `),
                 n = +this.fontSize(),
                 i = 0,
                 r = this.lineHeight() * n,
-                a = this.attrs.width,
-                s = this.attrs.height,
-                o = a !== tu && a !== void 0,
-                l = s !== tu && s !== void 0,
+                s = this.attrs.width,
+                a = this.attrs.height,
+                o = s !== Wl && s !== void 0,
+                l = a !== Wl && a !== void 0,
                 u = this.padding(),
-                c = a - u * 2,
-                f = s - u * 2,
+                c = s - u * 2,
+                f = a - u * 2,
                 h = 0,
                 d = this.wrap(),
-                g = d !== sk,
-                p = d !== _7 && g,
+                g = d !== xk,
+                p = d !== $7 && g,
                 m = this.ellipsis();
-            this.textArr = [], Iy().font = this._getContextFont();
-            for (var y = m ? this._getTextWidth(Ly) : 0, v = 0, b = t.length; v < b; ++v) {
+            this.textArr = [], my().font = this._getContextFont();
+            for (var y = m ? this._getTextWidth(py) : 0, v = 0, b = t.length; v < b; ++v) {
                 var x = t[v],
                     _ = this._getTextWidth(x);
                 if (o && _ > c)
                     for (; x.length > 0;) {
-                        for (var S = 0, w = x.length, O = "", k = 0; S < w;) {
+                        for (var S = 0, w = x.length, E = "", A = 0; S < w;) {
                             var C = S + w >>> 1,
-                                E = x.slice(0, C + 1),
-                                T = this._getTextWidth(E) + y;
-                            T <= c ? (S = C + 1, O = E, k = T) : w = C
+                                k = x.slice(0, C + 1),
+                                R = this._getTextWidth(k) + y;
+                            R <= c ? (S = C + 1, E = k, A = R) : w = C
                         }
-                        if (O) {
+                        if (E) {
                             if (p) {
-                                var A, F = x[O.length],
-                                    $ = F === fg || F === rk;
-                                $ && k <= c ? A = O.length : A = Math.max(O.lastIndexOf(fg), O.lastIndexOf(rk)) + 1, A > 0 && (S = A, O = O.slice(0, S), k = this._getTextWidth(O))
+                                var $, T = x[E.length],
+                                    M = T === Kd || T === vk;
+                                M && A <= c ? $ = E.length : $ = Math.max(E.lastIndexOf(Kd), E.lastIndexOf(vk)) + 1, $ > 0 && (S = $, E = E.slice(0, S), A = this._getTextWidth(E))
                             }
-                            O = O.trimRight(), this._addTextLine(O), i = Math.max(i, k), h += r;
-                            var D = this._shouldHandleEllipsis(h);
-                            if (D) {
+                            E = E.trimRight(), this._addTextLine(E), i = Math.max(i, A), h += r;
+                            var F = this._shouldHandleEllipsis(h);
+                            if (F) {
                                 this._tryToAddEllipsisToLastLine();
                                 break
                             }
                             if (x = x.slice(S), x = x.trimLeft(), x.length > 0 && (_ = this._getTextWidth(x), _ <= c)) {
                                 this._addTextLine(x), h += r, i = Math.max(i, _);
                                 break
                             }
@@ -5566,114 +5566,114 @@
             }
             this.textHeight = n, this.textWidth = i
         }
         _shouldHandleEllipsis(t) {
             var n = +this.fontSize(),
                 i = this.lineHeight() * n,
                 r = this.attrs.height,
-                a = r !== tu && r !== void 0,
-                s = this.padding(),
-                o = r - s * 2,
+                s = r !== Wl && r !== void 0,
+                a = this.padding(),
+                o = r - a * 2,
                 l = this.wrap(),
-                u = l !== sk;
-            return !u || a && t + i > o
+                u = l !== xk;
+            return !u || s && t + i > o
         }
         _tryToAddEllipsisToLastLine() {
             var t = this.attrs.width,
-                n = t !== tu && t !== void 0,
+                n = t !== Wl && t !== void 0,
                 i = this.padding(),
                 r = t - i * 2,
-                a = this.ellipsis(),
-                s = this.textArr[this.textArr.length - 1];
-            if (!(!s || !a)) {
+                s = this.ellipsis(),
+                a = this.textArr[this.textArr.length - 1];
+            if (!(!a || !s)) {
                 if (n) {
-                    var o = this._getTextWidth(s.text + Ly) < r;
-                    o || (s.text = s.text.slice(0, s.text.length - 3))
+                    var o = this._getTextWidth(a.text + py) < r;
+                    o || (a.text = a.text.slice(0, a.text.length - 3))
                 }
-                this.textArr.splice(this.textArr.length - 1, 1), this._addTextLine(s.text + Ly)
+                this.textArr.splice(this.textArr.length - 1, 1), this._addTextLine(a.text + py)
             }
         }
         getStrokeScaleEnabled() {
             return !0
         }
     }
-    pt.prototype._fillFunc = E7;
-    pt.prototype._strokeFunc = O7;
-    pt.prototype.className = p7;
-    pt.prototype._attrsAffectingSize = ["text", "fontSize", "padding", "wrap", "lineHeight", "letterSpacing"];
-    mt(pt);
-    M.overWriteSetter(pt, "width", Jx());
-    M.overWriteSetter(pt, "height", Jx());
-    M.addGetterSetter(pt, "fontFamily", "Arial");
-    M.addGetterSetter(pt, "fontSize", 12, ee());
-    M.addGetterSetter(pt, "fontStyle", BM);
-    M.addGetterSetter(pt, "fontVariant", BM);
-    M.addGetterSetter(pt, "padding", 0, ee());
-    M.addGetterSetter(pt, "align", zM);
-    M.addGetterSetter(pt, "verticalAlign", m7);
-    M.addGetterSetter(pt, "lineHeight", 1, ee());
-    M.addGetterSetter(pt, "wrap", x7);
-    M.addGetterSetter(pt, "ellipsis", !1, Sr());
-    M.addGetterSetter(pt, "letterSpacing", 0, ee());
-    M.addGetterSetter(pt, "text", "", Ec());
-    M.addGetterSetter(pt, "textDecoration", "");
-    var k7 = "",
-        UM = "normal";
+    gt.prototype._fillFunc = O7;
+    gt.prototype._strokeFunc = F7;
+    gt.prototype.className = w7;
+    gt.prototype._attrsAffectingSize = ["text", "fontSize", "padding", "wrap", "lineHeight", "letterSpacing"];
+    pt(gt);
+    O.overWriteSetter(gt, "width", mx());
+    O.overWriteSetter(gt, "height", mx());
+    O.addGetterSetter(gt, "fontFamily", "Arial");
+    O.addGetterSetter(gt, "fontSize", 12, te());
+    O.addGetterSetter(gt, "fontStyle", QM);
+    O.addGetterSetter(gt, "fontVariant", QM);
+    O.addGetterSetter(gt, "padding", 0, te());
+    O.addGetterSetter(gt, "align", JM);
+    O.addGetterSetter(gt, "verticalAlign", S7);
+    O.addGetterSetter(gt, "lineHeight", 1, te());
+    O.addGetterSetter(gt, "wrap", A7);
+    O.addGetterSetter(gt, "ellipsis", !1, mr());
+    O.addGetterSetter(gt, "letterSpacing", 0, te());
+    O.addGetterSetter(gt, "text", "", hc());
+    O.addGetterSetter(gt, "textDecoration", "");
+    var D7 = "",
+        eO = "normal";
 
-    function qM(e) {
+    function tO(e) {
         e.fillText(this.partialText, 0, 0)
     }
 
-    function WM(e) {
+    function nO(e) {
         e.strokeText(this.partialText, 0, 0)
     }
-    class Lt extends V {
+    class Rt extends V {
         constructor(t) {
-            super(t), this.dummyCanvas = R.createCanvasElement(), this.dataArray = [], this.dataArray = Jt.parsePathData(this.attrs.data), this.on("dataChange.konva", function() {
-                this.dataArray = Jt.parsePathData(this.attrs.data), this._setTextData()
+            super(t), this.dummyCanvas = D.createCanvasElement(), this.dataArray = [], this.dataArray = Yt.parsePathData(this.attrs.data), this.on("dataChange.konva", function() {
+                this.dataArray = Yt.parsePathData(this.attrs.data), this._setTextData()
             }), this.on("textChange.konva alignChange.konva letterSpacingChange.konva kerningFuncChange.konva fontSizeChange.konva fontFamilyChange.konva", this._setTextData), this._setTextData()
         }
         _sceneFunc(t) {
             t.setAttr("font", this._getContextFont()), t.setAttr("textBaseline", this.textBaseline()), t.setAttr("textAlign", "left"), t.save();
             var n = this.textDecoration(),
                 i = this.fill(),
                 r = this.fontSize(),
-                a = this.glyphInfo;
+                s = this.glyphInfo;
             n === "underline" && t.beginPath();
-            for (var s = 0; s < a.length; s++) {
+            for (var a = 0; a < s.length; a++) {
                 t.save();
-                var o = a[s].p0;
-                t.translate(o.x, o.y), t.rotate(a[s].rotation), this.partialText = a[s].text, t.fillStrokeShape(this), n === "underline" && (s === 0 && t.moveTo(0, r / 2 + 1), t.lineTo(r, r / 2 + 1)), t.restore()
+                var o = s[a].p0;
+                t.translate(o.x, o.y), t.rotate(s[a].rotation), this.partialText = s[a].text, t.fillStrokeShape(this), n === "underline" && (a === 0 && t.moveTo(0, r / 2 + 1), t.lineTo(r, r / 2 + 1)), t.restore()
             }
             n === "underline" && (t.strokeStyle = i, t.lineWidth = r / 20, t.stroke()), t.restore()
         }
         _hitFunc(t) {
             t.beginPath();
             var n = this.glyphInfo;
             if (n.length >= 1) {
                 var i = n[0].p0;
                 t.moveTo(i.x, i.y)
             }
             for (var r = 0; r < n.length; r++) {
-                var a = n[r].p1;
-                t.lineTo(a.x, a.y)
+                var s = n[r].p1;
+                t.lineTo(s.x, s.y)
             }
             t.setAttr("lineWidth", this.fontSize()), t.setAttr("strokeStyle", this.colorKey), t.stroke()
         }
         getTextWidth() {
             return this.textWidth
         }
         getTextHeight() {
-            return R.warn("text.getTextHeight() method is deprecated. Use text.height() - for full height and text.fontSize() - for one line height."), this.textHeight
+            return D.warn("text.getTextHeight() method is deprecated. Use text.height() - for full height and text.fontSize() - for one line height."), this.textHeight
         }
         setText(t) {
-            return pt.prototype.setText.call(this, t)
+            return gt.prototype.setText.call(this, t)
         }
         _getContextFont() {
-            return pt.prototype._getContextFont.call(this)
+            return gt.prototype._getContextFont.call(this)
         }
         _getTextSize(t) {
             var n = this.dummyCanvas,
                 i = n.getContext("2d");
             i.save(), i.font = this._getContextFont();
             var r = i.measureText(t);
             return i.restore(), {
@@ -5682,77 +5682,77 @@
             }
         }
         _setTextData() {
             var t = this,
                 n = this._getTextSize(this.attrs.text),
                 i = this.letterSpacing(),
                 r = this.align(),
-                a = this.kerningFunc();
+                s = this.kerningFunc();
             this.textWidth = n.width, this.textHeight = n.height;
-            var s = Math.max(this.textWidth + ((this.attrs.text || "").length - 1) * i, 0);
+            var a = Math.max(this.textWidth + ((this.attrs.text || "").length - 1) * i, 0);
             this.glyphInfo = [];
             for (var o = 0, l = 0; l < t.dataArray.length; l++) t.dataArray[l].pathLength > 0 && (o += t.dataArray[l].pathLength);
             var u = 0;
-            r === "center" && (u = Math.max(0, o / 2 - s / 2)), r === "right" && (u = Math.max(0, o - s));
-            for (var c = jM(this.text()), f = this.text().split(" ").length - 1, h, d, g, p = -1, m = 0, y = function() {
+            r === "center" && (u = Math.max(0, o / 2 - a / 2)), r === "right" && (u = Math.max(0, o - a));
+            for (var c = KM(this.text()), f = this.text().split(" ").length - 1, h, d, g, p = -1, m = 0, y = function() {
                     m = 0;
-                    for (var T = t.dataArray, A = p + 1; A < T.length; A++) {
-                        if (T[A].pathLength > 0) return p = A, T[A];
-                        T[A].command === "M" && (h = {
-                            x: T[A].points[0],
-                            y: T[A].points[1]
+                    for (var R = t.dataArray, $ = p + 1; $ < R.length; $++) {
+                        if (R[$].pathLength > 0) return p = $, R[$];
+                        R[$].command === "M" && (h = {
+                            x: R[$].points[0],
+                            y: R[$].points[1]
                         })
                     }
                     return {}
-                }, v = function(T) {
-                    var A = t._getTextSize(T).width + i;
-                    T === " " && r === "justify" && (A += (o - s) / f);
-                    var F = 0,
-                        $ = 0;
-                    for (d = void 0; Math.abs(A - F) / A > .01 && $ < 20;) {
-                        $++;
-                        for (var D = F; g === void 0;) g = y(), g && D + g.pathLength < A && (D += g.pathLength, g = void 0);
+                }, v = function(R) {
+                    var $ = t._getTextSize(R).width + i;
+                    R === " " && r === "justify" && ($ += (o - a) / f);
+                    var T = 0,
+                        M = 0;
+                    for (d = void 0; Math.abs($ - T) / $ > .01 && M < 20;) {
+                        M++;
+                        for (var F = T; g === void 0;) g = y(), g && F + g.pathLength < $ && (F += g.pathLength, g = void 0);
                         if (Object.keys(g).length === 0 || h === void 0) return;
-                        var P = !1;
+                        var N = !1;
                         switch (g.command) {
                             case "L":
-                                Jt.getLineLength(h.x, h.y, g.points[0], g.points[1]) > A ? d = Jt.getPointOnLine(A, h.x, h.y, g.points[0], g.points[1], h.x, h.y) : g = void 0;
+                                Yt.getLineLength(h.x, h.y, g.points[0], g.points[1]) > $ ? d = Yt.getPointOnLine($, h.x, h.y, g.points[0], g.points[1], h.x, h.y) : g = void 0;
                                 break;
                             case "A":
-                                var N = g.points[4],
+                                var P = g.points[4],
                                     z = g.points[5],
                                     I = g.points[4] + z;
-                                m === 0 ? m = N + 1e-8 : A > F ? m += Math.PI / 180 * z / Math.abs(z) : m -= Math.PI / 360 * z / Math.abs(z), (z < 0 && m < I || z >= 0 && m > I) && (m = I, P = !0), d = Jt.getPointOnEllipticalArc(g.points[0], g.points[1], g.points[2], g.points[3], m, g.points[6]);
+                                m === 0 ? m = P + 1e-8 : $ > T ? m += Math.PI / 180 * z / Math.abs(z) : m -= Math.PI / 360 * z / Math.abs(z), (z < 0 && m < I || z >= 0 && m > I) && (m = I, N = !0), d = Yt.getPointOnEllipticalArc(g.points[0], g.points[1], g.points[2], g.points[3], m, g.points[6]);
                                 break;
                             case "C":
-                                m === 0 ? A > g.pathLength ? m = 1e-8 : m = A / g.pathLength : A > F ? m += (A - F) / g.pathLength / 2 : m = Math.max(m - (F - A) / g.pathLength / 2, 0), m > 1 && (m = 1, P = !0), d = Jt.getPointOnCubicBezier(m, g.start.x, g.start.y, g.points[0], g.points[1], g.points[2], g.points[3], g.points[4], g.points[5]);
+                                m === 0 ? $ > g.pathLength ? m = 1e-8 : m = $ / g.pathLength : $ > T ? m += ($ - T) / g.pathLength / 2 : m = Math.max(m - (T - $) / g.pathLength / 2, 0), m > 1 && (m = 1, N = !0), d = Yt.getPointOnCubicBezier(m, g.start.x, g.start.y, g.points[0], g.points[1], g.points[2], g.points[3], g.points[4], g.points[5]);
                                 break;
                             case "Q":
-                                m === 0 ? m = A / g.pathLength : A > F ? m += (A - F) / g.pathLength : m -= (F - A) / g.pathLength, m > 1 && (m = 1, P = !0), d = Jt.getPointOnQuadraticBezier(m, g.start.x, g.start.y, g.points[0], g.points[1], g.points[2], g.points[3]);
+                                m === 0 ? m = $ / g.pathLength : $ > T ? m += ($ - T) / g.pathLength : m -= (T - $) / g.pathLength, m > 1 && (m = 1, N = !0), d = Yt.getPointOnQuadraticBezier(m, g.start.x, g.start.y, g.points[0], g.points[1], g.points[2], g.points[3]);
                                 break
                         }
-                        d !== void 0 && (F = Jt.getLineLength(h.x, h.y, d.x, d.y)), P && (P = !1, g = void 0)
+                        d !== void 0 && (T = Yt.getLineLength(h.x, h.y, d.x, d.y)), N && (N = !1, g = void 0)
                     }
                 }, b = "C", x = t._getTextSize(b).width + i, _ = u / x - 1, S = 0; S < _ && (v(b), !(h === void 0 || d === void 0)); S++) h = d;
             for (var w = 0; w < c.length && (v(c[w]), !(h === void 0 || d === void 0)); w++) {
-                var O = Jt.getLineLength(h.x, h.y, d.x, d.y),
-                    k = 0;
-                if (a) try {
-                    k = a(c[w - 1], c[w]) * this.fontSize()
+                var E = Yt.getLineLength(h.x, h.y, d.x, d.y),
+                    A = 0;
+                if (s) try {
+                    A = s(c[w - 1], c[w]) * this.fontSize()
                 } catch {
-                    k = 0
+                    A = 0
                 }
-                h.x += k, d.x += k, this.textWidth += k;
-                var C = Jt.getPointOnLine(k + O / 2, h.x, h.y, d.x, d.y),
-                    E = Math.atan2(d.y - h.y, d.x - h.x);
+                h.x += A, d.x += A, this.textWidth += A;
+                var C = Yt.getPointOnLine(A + E / 2, h.x, h.y, d.x, d.y),
+                    k = Math.atan2(d.y - h.y, d.x - h.x);
                 this.glyphInfo.push({
                     transposeX: C.x,
                     transposeY: C.y,
                     text: c[w],
-                    rotation: E,
+                    rotation: k,
                     p0: h,
                     p1: d
                 }), h = d
             }
         }
         getSelfRect() {
             if (!this.glyphInfo.length) return {
@@ -5761,145 +5761,145 @@
                 width: 0,
                 height: 0
             };
             var t = [];
             this.glyphInfo.forEach(function(c) {
                 t.push(c.p0.x), t.push(c.p0.y), t.push(c.p1.x), t.push(c.p1.y)
             });
-            for (var n = t[0] || 0, i = t[0] || 0, r = t[1] || 0, a = t[1] || 0, s, o, l = 0; l < t.length / 2; l++) s = t[l * 2], o = t[l * 2 + 1], n = Math.min(n, s), i = Math.max(i, s), r = Math.min(r, o), a = Math.max(a, o);
+            for (var n = t[0] || 0, i = t[0] || 0, r = t[1] || 0, s = t[1] || 0, a, o, l = 0; l < t.length / 2; l++) a = t[l * 2], o = t[l * 2 + 1], n = Math.min(n, a), i = Math.max(i, a), r = Math.min(r, o), s = Math.max(s, o);
             var u = this.fontSize();
             return {
                 x: n - u / 2,
                 y: r - u / 2,
                 width: i - n + u,
-                height: a - r + u
+                height: s - r + u
             }
         }
         destroy() {
-            return R.releaseCanvas(this.dummyCanvas), super.destroy()
+            return D.releaseCanvas(this.dummyCanvas), super.destroy()
         }
     }
-    Lt.prototype._fillFunc = qM;
-    Lt.prototype._strokeFunc = WM;
-    Lt.prototype._fillFuncHit = qM;
-    Lt.prototype._strokeFuncHit = WM;
-    Lt.prototype.className = "TextPath";
-    Lt.prototype._attrsAffectingSize = ["text", "fontSize", "data"];
-    mt(Lt);
-    M.addGetterSetter(Lt, "data");
-    M.addGetterSetter(Lt, "fontFamily", "Arial");
-    M.addGetterSetter(Lt, "fontSize", 12, ee());
-    M.addGetterSetter(Lt, "fontStyle", UM);
-    M.addGetterSetter(Lt, "align", "left");
-    M.addGetterSetter(Lt, "letterSpacing", 0, ee());
-    M.addGetterSetter(Lt, "textBaseline", "middle");
-    M.addGetterSetter(Lt, "fontVariant", UM);
-    M.addGetterSetter(Lt, "text", k7);
-    M.addGetterSetter(Lt, "textDecoration", null);
-    M.addGetterSetter(Lt, "kerningFunc", null);
-    var HM = "tr-konva",
-        A7 = ["resizeEnabledChange", "rotateAnchorOffsetChange", "rotateEnabledChange", "enabledAnchorsChange", "anchorSizeChange", "borderEnabledChange", "borderStrokeChange", "borderStrokeWidthChange", "borderDashChange", "anchorStrokeChange", "anchorStrokeWidthChange", "anchorFillChange", "anchorCornerRadiusChange", "ignoreStrokeChange"].map(e => e + `.${HM}`).join(" "),
-        ok = "nodesRect",
-        T7 = ["widthChange", "heightChange", "scaleXChange", "scaleYChange", "skewXChange", "skewYChange", "rotationChange", "offsetXChange", "offsetYChange", "transformsEnabledChange", "strokeWidthChange"],
-        $7 = {
+    Rt.prototype._fillFunc = tO;
+    Rt.prototype._strokeFunc = nO;
+    Rt.prototype._fillFuncHit = tO;
+    Rt.prototype._strokeFuncHit = nO;
+    Rt.prototype.className = "TextPath";
+    Rt.prototype._attrsAffectingSize = ["text", "fontSize", "data"];
+    pt(Rt);
+    O.addGetterSetter(Rt, "data");
+    O.addGetterSetter(Rt, "fontFamily", "Arial");
+    O.addGetterSetter(Rt, "fontSize", 12, te());
+    O.addGetterSetter(Rt, "fontStyle", eO);
+    O.addGetterSetter(Rt, "align", "left");
+    O.addGetterSetter(Rt, "letterSpacing", 0, te());
+    O.addGetterSetter(Rt, "textBaseline", "middle");
+    O.addGetterSetter(Rt, "fontVariant", eO);
+    O.addGetterSetter(Rt, "text", D7);
+    O.addGetterSetter(Rt, "textDecoration", null);
+    O.addGetterSetter(Rt, "kerningFunc", null);
+    var iO = "tr-konva",
+        N7 = ["resizeEnabledChange", "rotateAnchorOffsetChange", "rotateEnabledChange", "enabledAnchorsChange", "anchorSizeChange", "borderEnabledChange", "borderStrokeChange", "borderStrokeWidthChange", "borderDashChange", "anchorStrokeChange", "anchorStrokeWidthChange", "anchorFillChange", "anchorCornerRadiusChange", "ignoreStrokeChange"].map(e => e + `.${iO}`).join(" "),
+        _k = "nodesRect",
+        P7 = ["widthChange", "heightChange", "scaleXChange", "scaleYChange", "skewXChange", "skewYChange", "rotationChange", "offsetXChange", "offsetYChange", "transformsEnabledChange", "strokeWidthChange"],
+        L7 = {
             "top-left": -45,
             "top-center": 0,
             "top-right": 45,
             "middle-right": -90,
             "middle-left": 90,
             "bottom-left": -135,
             "bottom-center": 180,
             "bottom-right": 135
         };
-    const M7 = "ontouchstart" in le._global;
+    const I7 = "ontouchstart" in le._global;
 
-    function F7(e, t) {
+    function z7(e, t) {
         if (e === "rotater") return "crosshair";
-        t += R.degToRad($7[e] || 0);
-        var n = (R.radToDeg(t) % 360 + 360) % 360;
-        return R._inRange(n, 315 + 22.5, 360) || R._inRange(n, 0, 22.5) ? "ns-resize" : R._inRange(n, 45 - 22.5, 45 + 22.5) ? "nesw-resize" : R._inRange(n, 90 - 22.5, 90 + 22.5) ? "ew-resize" : R._inRange(n, 135 - 22.5, 135 + 22.5) ? "nwse-resize" : R._inRange(n, 180 - 22.5, 180 + 22.5) ? "ns-resize" : R._inRange(n, 225 - 22.5, 225 + 22.5) ? "nesw-resize" : R._inRange(n, 270 - 22.5, 270 + 22.5) ? "ew-resize" : R._inRange(n, 315 - 22.5, 315 + 22.5) ? "nwse-resize" : (R.error("Transformer has unknown angle for cursor detection: " + n), "pointer")
+        t += D.degToRad(L7[e] || 0);
+        var n = (D.radToDeg(t) % 360 + 360) % 360;
+        return D._inRange(n, 315 + 22.5, 360) || D._inRange(n, 0, 22.5) ? "ns-resize" : D._inRange(n, 45 - 22.5, 45 + 22.5) ? "nesw-resize" : D._inRange(n, 90 - 22.5, 90 + 22.5) ? "ew-resize" : D._inRange(n, 135 - 22.5, 135 + 22.5) ? "nwse-resize" : D._inRange(n, 180 - 22.5, 180 + 22.5) ? "ns-resize" : D._inRange(n, 225 - 22.5, 225 + 22.5) ? "nesw-resize" : D._inRange(n, 270 - 22.5, 270 + 22.5) ? "ew-resize" : D._inRange(n, 315 - 22.5, 315 + 22.5) ? "nwse-resize" : (D.error("Transformer has unknown angle for cursor detection: " + n), "pointer")
     }
-    var Pp = ["top-left", "top-center", "top-right", "middle-right", "middle-left", "bottom-left", "bottom-center", "bottom-right"],
-        lk = 1e8;
+    var mp = ["top-left", "top-center", "top-right", "middle-right", "middle-left", "bottom-left", "bottom-center", "bottom-right"],
+        wk = 1e8;
 
-    function D7(e) {
+    function B7(e) {
         return {
             x: e.x + e.width / 2 * Math.cos(e.rotation) + e.height / 2 * Math.sin(-e.rotation),
             y: e.y + e.height / 2 * Math.cos(e.rotation) + e.width / 2 * Math.sin(e.rotation)
         }
     }
 
-    function YM(e, t, n) {
+    function rO(e, t, n) {
         const i = n.x + (e.x - n.x) * Math.cos(t) - (e.y - n.y) * Math.sin(t),
             r = n.y + (e.x - n.x) * Math.sin(t) + (e.y - n.y) * Math.cos(t);
         return Object.assign(Object.assign({}, e), {
             rotation: e.rotation + t,
             x: i,
             y: r
         })
     }
 
-    function R7(e, t) {
-        const n = D7(e);
-        return YM(e, t, n)
+    function j7(e, t) {
+        const n = B7(e);
+        return rO(e, t, n)
     }
 
-    function P7(e, t, n) {
+    function U7(e, t, n) {
         let i = t;
         for (let r = 0; r < e.length; r++) {
-            const a = le.getAngle(e[r]),
-                s = Math.abs(a - t) % (Math.PI * 2);
-            Math.min(s, Math.PI * 2 - s) < n && (i = a)
+            const s = le.getAngle(e[r]),
+                a = Math.abs(s - t) % (Math.PI * 2);
+            Math.min(a, Math.PI * 2 - a) < n && (i = s)
         }
         return i
     }
-    class Je extends Bu {
+    class Ke extends Mu {
         constructor(t) {
-            super(t), this._transforming = !1, this._createElements(), this._handleMouseMove = this._handleMouseMove.bind(this), this._handleMouseUp = this._handleMouseUp.bind(this), this.update = this.update.bind(this), this.on(A7, this.update), this.getNode() && this.update()
+            super(t), this._transforming = !1, this._createElements(), this._handleMouseMove = this._handleMouseMove.bind(this), this._handleMouseUp = this._handleMouseUp.bind(this), this.update = this.update.bind(this), this.on(N7, this.update), this.getNode() && this.update()
         }
         attachTo(t) {
             return this.setNode(t), this
         }
         setNode(t) {
-            return R.warn("tr.setNode(shape), tr.node(shape) and tr.attachTo(shape) methods are deprecated. Please use tr.nodes(nodesArray) instead."), this.setNodes([t])
+            return D.warn("tr.setNode(shape), tr.node(shape) and tr.attachTo(shape) methods are deprecated. Please use tr.nodes(nodesArray) instead."), this.setNodes([t])
         }
         getNode() {
             return this._nodes && this._nodes[0]
         }
         _getEventNamespace() {
-            return HM + this._id
+            return iO + this._id
         }
         setNodes(t = []) {
             this._nodes && this._nodes.length && this.detach();
-            const n = t.filter(r => r.isAncestorOf(this) ? (R.error("Konva.Transformer cannot be an a child of the node you are trying to attach"), !1) : !0);
+            const n = t.filter(r => r.isAncestorOf(this) ? (D.error("Konva.Transformer cannot be an a child of the node you are trying to attach"), !1) : !0);
             this._nodes = t = n, t.length === 1 && this.useSingleNodeRotation() ? this.rotation(t[0].getAbsoluteRotation()) : this.rotation(0), this._nodes.forEach(r => {
-                const a = () => {
+                const s = () => {
                         this.nodes().length === 1 && this.useSingleNodeRotation() && this.rotation(this.nodes()[0].getAbsoluteRotation()), this._resetTransformCache(), !this._transforming && !this.isDragging() && this.update()
                     },
-                    s = r._attrsAffectingSize.map(o => o + "Change." + this._getEventNamespace()).join(" ");
-                r.on(s, a), r.on(T7.map(o => o + `.${this._getEventNamespace()}`).join(" "), a), r.on(`absoluteTransformChange.${this._getEventNamespace()}`, a), this._proxyDrag(r)
+                    a = r._attrsAffectingSize.map(o => o + "Change." + this._getEventNamespace()).join(" ");
+                r.on(a, s), r.on(P7.map(o => o + `.${this._getEventNamespace()}`).join(" "), s), r.on(`absoluteTransformChange.${this._getEventNamespace()}`, s), this._proxyDrag(r)
             }), this._resetTransformCache();
             var i = !!this.findOne(".top-left");
             return i && this.update(), this
         }
         _proxyDrag(t) {
             let n;
             t.on(`dragstart.${this._getEventNamespace()}`, i => {
                 n = t.getAbsolutePosition(), !this.isDragging() && t !== this.findOne(".back") && this.startDrag(i, !1)
             }), t.on(`dragmove.${this._getEventNamespace()}`, i => {
                 if (!n) return;
                 const r = t.getAbsolutePosition(),
-                    a = r.x - n.x,
-                    s = r.y - n.y;
+                    s = r.x - n.x,
+                    a = r.y - n.y;
                 this.nodes().forEach(o => {
                     if (o === t || o.isDragging()) return;
                     const l = o.getAbsolutePosition();
                     o.setAbsolutePosition({
-                        x: l.x + a,
-                        y: l.y + s
+                        x: l.x + s,
+                        y: l.y + a
                     }), o.startDrag(i)
                 }), n = null
             })
         }
         getNodes() {
             return this._nodes || []
         }
@@ -5908,47 +5908,47 @@
         }
         detach() {
             this._nodes && this._nodes.forEach(t => {
                 t.off("." + this._getEventNamespace())
             }), this._nodes = [], this._resetTransformCache()
         }
         _resetTransformCache() {
-            this._clearCache(ok), this._clearCache("transform"), this._clearSelfAndDescendantCache("absoluteTransform")
+            this._clearCache(_k), this._clearCache("transform"), this._clearSelfAndDescendantCache("absoluteTransform")
         }
         _getNodeRect() {
-            return this._getCache(ok, this.__getNodeRect)
+            return this._getCache(_k, this.__getNodeRect)
         }
         __getNodeShape(t, n = this.rotation(), i) {
             var r = t.getClientRect({
                     skipTransform: !0,
                     skipShadow: !0,
                     skipStroke: this.ignoreStroke()
                 }),
-                a = t.getAbsoluteScale(i),
-                s = t.getAbsolutePosition(i),
-                o = r.x * a.x - t.offsetX() * a.x,
-                l = r.y * a.y - t.offsetY() * a.y;
+                s = t.getAbsoluteScale(i),
+                a = t.getAbsolutePosition(i),
+                o = r.x * s.x - t.offsetX() * s.x,
+                l = r.y * s.y - t.offsetY() * s.y;
             const u = (le.getAngle(t.getAbsoluteRotation()) + Math.PI * 2) % (Math.PI * 2),
                 c = {
-                    x: s.x + o * Math.cos(u) + l * Math.sin(-u),
-                    y: s.y + l * Math.cos(u) + o * Math.sin(u),
-                    width: r.width * a.x,
-                    height: r.height * a.y,
+                    x: a.x + o * Math.cos(u) + l * Math.sin(-u),
+                    y: a.y + l * Math.cos(u) + o * Math.sin(u),
+                    width: r.width * s.x,
+                    height: r.height * s.y,
                     rotation: u
                 };
-            return YM(c, -le.getAngle(n), {
+            return rO(c, -le.getAngle(n), {
                 x: 0,
                 y: 0
             })
         }
         __getNodeRect() {
             var t = this.getNode();
             if (!t) return {
-                x: -lk,
-                y: -lk,
+                x: -wk,
+                y: -wk,
                 width: 0,
                 height: 0,
                 rotation: 0
             };
             const n = [];
             this.nodes().map(u => {
                 const c = u.getClientRect({
@@ -5971,30 +5971,30 @@
                     }],
                     h = u.getAbsoluteTransform();
                 f.forEach(function(d) {
                     var g = h.point(d);
                     n.push(g)
                 })
             });
-            const i = new ir;
+            const i = new Ki;
             i.rotate(-le.getAngle(this.rotation()));
-            var r, a, s, o;
+            var r, s, a, o;
             n.forEach(function(u) {
                 var c = i.point(u);
-                r === void 0 && (r = s = c.x, a = o = c.y), r = Math.min(r, c.x), a = Math.min(a, c.y), s = Math.max(s, c.x), o = Math.max(o, c.y)
+                r === void 0 && (r = a = c.x, s = o = c.y), r = Math.min(r, c.x), s = Math.min(s, c.y), a = Math.max(a, c.x), o = Math.max(o, c.y)
             }), i.invert();
             const l = i.point({
                 x: r,
-                y: a
+                y: s
             });
             return {
                 x: l.x,
                 y: l.y,
-                width: s - r,
-                height: o - a,
+                width: a - r,
+                height: o - s,
                 rotation: le.getAngle(this.rotation())
             }
         }
         getX() {
             return this._getNodeRect().x
         }
         getY() {
@@ -6003,53 +6003,53 @@
         getWidth() {
             return this._getNodeRect().width
         }
         getHeight() {
             return this._getNodeRect().height
         }
         _createElements() {
-            this._createBack(), Pp.forEach(function(t) {
+            this._createBack(), mp.forEach(function(t) {
                 this._createAnchor(t)
             }.bind(this)), this._createAnchor("rotater")
         }
         _createAnchor(t) {
-            var n = new od({
+            var n = new Vh({
                     stroke: "rgb(0, 161, 255)",
                     fill: "white",
                     strokeWidth: 1,
                     name: t + " _anchor",
                     dragDistance: 0,
                     draggable: !0,
-                    hitStrokeWidth: M7 ? 10 : "auto"
+                    hitStrokeWidth: I7 ? 10 : "auto"
                 }),
                 i = this;
             n.on("mousedown touchstart", function(r) {
                 i._handleMouseDown(r)
             }), n.on("dragstart", r => {
                 n.stopDrag(), r.cancelBubble = !0
             }), n.on("dragend", r => {
                 r.cancelBubble = !0
             }), n.on("mouseenter", () => {
                 var r = le.getAngle(this.rotation()),
-                    a = F7(t, r);
-                n.getStage().content && (n.getStage().content.style.cursor = a), this._cursorChange = !0
+                    s = z7(t, r);
+                n.getStage().content && (n.getStage().content.style.cursor = s), this._cursorChange = !0
             }), n.on("mouseout", () => {
                 n.getStage().content && (n.getStage().content.style.cursor = ""), this._cursorChange = !1
             }), this.add(n)
         }
         _createBack() {
             var t = new V({
                 name: "back",
                 width: 0,
                 height: 0,
                 draggable: !0,
                 sceneFunc(n) {
                     var i = this.getParent(),
                         r = i.padding();
-                    n.beginPath(), n.rect(-r, -r, this.width() + r * 2, this.height() + r * 2), n.moveTo(this.width() / 2, -r), i.rotateEnabled() && n.lineTo(this.width() / 2, -i.rotateAnchorOffset() * R._sign(this.height()) - r), n.fillStrokeShape(this)
+                    n.beginPath(), n.rect(-r, -r, this.width() + r * 2, this.height() + r * 2), n.moveTo(this.width() / 2, -r), i.rotateEnabled() && n.lineTo(this.width() / 2, -i.rotateAnchorOffset() * D._sign(this.height()) - r), n.fillStrokeShape(this)
                 },
                 hitFunc: (n, i) => {
                     if (this.shouldOverdrawWholeArea()) {
                         var r = this.padding();
                         n.beginPath(), n.rect(-r, -r, i.width() + r * 2, i.height() + r * 2), n.fillStrokeShape(i)
                     }
                 }
@@ -6065,148 +6065,148 @@
             })
         }
         _handleMouseDown(t) {
             this._movingAnchorName = t.target.name().split(" ")[0];
             var n = this._getNodeRect(),
                 i = n.width,
                 r = n.height,
-                a = Math.sqrt(Math.pow(i, 2) + Math.pow(r, 2));
-            this.sin = Math.abs(r / a), this.cos = Math.abs(i / a), typeof window < "u" && (window.addEventListener("mousemove", this._handleMouseMove), window.addEventListener("touchmove", this._handleMouseMove), window.addEventListener("mouseup", this._handleMouseUp, !0), window.addEventListener("touchend", this._handleMouseUp, !0)), this._transforming = !0;
-            var s = t.target.getAbsolutePosition(),
+                s = Math.sqrt(Math.pow(i, 2) + Math.pow(r, 2));
+            this.sin = Math.abs(r / s), this.cos = Math.abs(i / s), typeof window < "u" && (window.addEventListener("mousemove", this._handleMouseMove), window.addEventListener("touchmove", this._handleMouseMove), window.addEventListener("mouseup", this._handleMouseUp, !0), window.addEventListener("touchend", this._handleMouseUp, !0)), this._transforming = !0;
+            var a = t.target.getAbsolutePosition(),
                 o = t.target.getStage().getPointerPosition();
             this._anchorDragOffset = {
-                x: o.x - s.x,
-                y: o.y - s.y
+                x: o.x - a.x,
+                y: o.y - a.y
             }, this._fire("transformstart", {
                 evt: t.evt,
                 target: this.getNode()
             }), this._nodes.forEach(l => {
                 l._fire("transformstart", {
                     evt: t.evt,
                     target: l
                 })
             })
         }
         _handleMouseMove(t) {
-            var n, i, r, a = this.findOne("." + this._movingAnchorName),
-                s = a.getStage();
-            s.setPointersPositions(t);
-            const o = s.getPointerPosition();
+            var n, i, r, s = this.findOne("." + this._movingAnchorName),
+                a = s.getStage();
+            a.setPointersPositions(t);
+            const o = a.getPointerPosition();
             let l = {
                 x: o.x - this._anchorDragOffset.x,
                 y: o.y - this._anchorDragOffset.y
             };
-            const u = a.getAbsolutePosition();
-            this.anchorDragBoundFunc() && (l = this.anchorDragBoundFunc()(u, l, t)), a.setAbsolutePosition(l);
-            const c = a.getAbsolutePosition();
+            const u = s.getAbsolutePosition();
+            this.anchorDragBoundFunc() && (l = this.anchorDragBoundFunc()(u, l, t)), s.setAbsolutePosition(l);
+            const c = s.getAbsolutePosition();
             if (!(u.x === c.x && u.y === c.y)) {
                 if (this._movingAnchorName === "rotater") {
                     var f = this._getNodeRect();
-                    n = a.x() - f.width / 2, i = -a.y() + f.height / 2;
-                    let T = Math.atan2(-i, n) + Math.PI / 2;
-                    f.height < 0 && (T -= Math.PI);
+                    n = s.x() - f.width / 2, i = -s.y() + f.height / 2;
+                    let R = Math.atan2(-i, n) + Math.PI / 2;
+                    f.height < 0 && (R -= Math.PI);
                     var h = le.getAngle(this.rotation());
-                    const A = h + T,
-                        F = le.getAngle(this.rotationSnapTolerance()),
-                        D = P7(this.rotationSnaps(), A, F) - f.rotation,
-                        P = R7(f, D);
-                    this._fitNodesInto(P, t);
+                    const $ = h + R,
+                        T = le.getAngle(this.rotationSnapTolerance()),
+                        F = U7(this.rotationSnaps(), $, T) - f.rotation,
+                        N = j7(f, F);
+                    this._fitNodesInto(N, t);
                     return
                 }
                 var d = this.keepRatio() || t.shiftKey,
                     v = this.centeredScaling() || t.altKey;
                 if (this._movingAnchorName === "top-left") {
                     if (d) {
                         var g = v ? {
                             x: this.width() / 2,
                             y: this.height() / 2
                         } : {
                             x: this.findOne(".bottom-right").x(),
                             y: this.findOne(".bottom-right").y()
                         };
-                        r = Math.sqrt(Math.pow(g.x - a.x(), 2) + Math.pow(g.y - a.y(), 2));
+                        r = Math.sqrt(Math.pow(g.x - s.x(), 2) + Math.pow(g.y - s.y(), 2));
                         var p = this.findOne(".top-left").x() > g.x ? -1 : 1,
                             m = this.findOne(".top-left").y() > g.y ? -1 : 1;
                         n = r * this.cos * p, i = r * this.sin * m, this.findOne(".top-left").x(g.x - n), this.findOne(".top-left").y(g.y - i)
                     }
-                } else if (this._movingAnchorName === "top-center") this.findOne(".top-left").y(a.y());
+                } else if (this._movingAnchorName === "top-center") this.findOne(".top-left").y(s.y());
                 else if (this._movingAnchorName === "top-right") {
                     if (d) {
                         var g = v ? {
                             x: this.width() / 2,
                             y: this.height() / 2
                         } : {
                             x: this.findOne(".bottom-left").x(),
                             y: this.findOne(".bottom-left").y()
                         };
-                        r = Math.sqrt(Math.pow(a.x() - g.x, 2) + Math.pow(g.y - a.y(), 2));
+                        r = Math.sqrt(Math.pow(s.x() - g.x, 2) + Math.pow(g.y - s.y(), 2));
                         var p = this.findOne(".top-right").x() < g.x ? -1 : 1,
                             m = this.findOne(".top-right").y() > g.y ? -1 : 1;
                         n = r * this.cos * p, i = r * this.sin * m, this.findOne(".top-right").x(g.x + n), this.findOne(".top-right").y(g.y - i)
                     }
-                    var y = a.position();
+                    var y = s.position();
                     this.findOne(".top-left").y(y.y), this.findOne(".bottom-right").x(y.x)
-                } else if (this._movingAnchorName === "middle-left") this.findOne(".top-left").x(a.x());
-                else if (this._movingAnchorName === "middle-right") this.findOne(".bottom-right").x(a.x());
+                } else if (this._movingAnchorName === "middle-left") this.findOne(".top-left").x(s.x());
+                else if (this._movingAnchorName === "middle-right") this.findOne(".bottom-right").x(s.x());
                 else if (this._movingAnchorName === "bottom-left") {
                     if (d) {
                         var g = v ? {
                             x: this.width() / 2,
                             y: this.height() / 2
                         } : {
                             x: this.findOne(".top-right").x(),
                             y: this.findOne(".top-right").y()
                         };
-                        r = Math.sqrt(Math.pow(g.x - a.x(), 2) + Math.pow(a.y() - g.y, 2));
-                        var p = g.x < a.x() ? -1 : 1,
-                            m = a.y() < g.y ? -1 : 1;
-                        n = r * this.cos * p, i = r * this.sin * m, a.x(g.x - n), a.y(g.y + i)
+                        r = Math.sqrt(Math.pow(g.x - s.x(), 2) + Math.pow(s.y() - g.y, 2));
+                        var p = g.x < s.x() ? -1 : 1,
+                            m = s.y() < g.y ? -1 : 1;
+                        n = r * this.cos * p, i = r * this.sin * m, s.x(g.x - n), s.y(g.y + i)
                     }
-                    y = a.position(), this.findOne(".top-left").x(y.x), this.findOne(".bottom-right").y(y.y)
-                } else if (this._movingAnchorName === "bottom-center") this.findOne(".bottom-right").y(a.y());
+                    y = s.position(), this.findOne(".top-left").x(y.x), this.findOne(".bottom-right").y(y.y)
+                } else if (this._movingAnchorName === "bottom-center") this.findOne(".bottom-right").y(s.y());
                 else if (this._movingAnchorName === "bottom-right") {
                     if (d) {
                         var g = v ? {
                             x: this.width() / 2,
                             y: this.height() / 2
                         } : {
                             x: this.findOne(".top-left").x(),
                             y: this.findOne(".top-left").y()
                         };
-                        r = Math.sqrt(Math.pow(a.x() - g.x, 2) + Math.pow(a.y() - g.y, 2));
+                        r = Math.sqrt(Math.pow(s.x() - g.x, 2) + Math.pow(s.y() - g.y, 2));
                         var p = this.findOne(".bottom-right").x() < g.x ? -1 : 1,
                             m = this.findOne(".bottom-right").y() < g.y ? -1 : 1;
                         n = r * this.cos * p, i = r * this.sin * m, this.findOne(".bottom-right").x(g.x + n), this.findOne(".bottom-right").y(g.y + i)
                     }
                 } else console.error(new Error("Wrong position argument of selection resizer: " + this._movingAnchorName));
                 var v = this.centeredScaling() || t.altKey;
                 if (v) {
                     var b = this.findOne(".top-left"),
                         x = this.findOne(".bottom-right"),
                         _ = b.x(),
                         S = b.y(),
                         w = this.getWidth() - x.x(),
-                        O = this.getHeight() - x.y();
+                        E = this.getHeight() - x.y();
                     x.move({
                         x: -_,
                         y: -S
                     }), b.move({
                         x: w,
-                        y: O
+                        y: E
                     })
                 }
-                var k = this.findOne(".top-left").getAbsolutePosition();
-                n = k.x, i = k.y;
+                var A = this.findOne(".top-left").getAbsolutePosition();
+                n = A.x, i = A.y;
                 var C = this.findOne(".bottom-right").x() - this.findOne(".top-left").x(),
-                    E = this.findOne(".bottom-right").y() - this.findOne(".top-left").y();
+                    k = this.findOne(".bottom-right").y() - this.findOne(".top-left").y();
                 this._fitNodesInto({
                     x: n,
                     y: i,
                     width: C,
-                    height: E,
+                    height: k,
                     rotation: le.getAngle(this.rotation())
                 }, t)
             }
         }
         _handleMouseUp(t) {
             this._removeEvents(t)
         }
@@ -6227,102 +6227,102 @@
                     })
                 }), this._movingAnchorName = null
             }
         }
         _fitNodesInto(t, n) {
             var i = this._getNodeRect();
             const r = 1;
-            if (R._inRange(t.width, -this.padding() * 2 - r, r)) {
+            if (D._inRange(t.width, -this.padding() * 2 - r, r)) {
                 this.update();
                 return
             }
-            if (R._inRange(t.height, -this.padding() * 2 - r, r)) {
+            if (D._inRange(t.height, -this.padding() * 2 - r, r)) {
                 this.update();
                 return
             }
-            const a = this.flipEnabled();
-            var s = new ir;
-            if (s.rotate(le.getAngle(this.rotation())), this._movingAnchorName && t.width < 0 && this._movingAnchorName.indexOf("left") >= 0) {
-                const f = s.point({
+            const s = this.flipEnabled();
+            var a = new Ki;
+            if (a.rotate(le.getAngle(this.rotation())), this._movingAnchorName && t.width < 0 && this._movingAnchorName.indexOf("left") >= 0) {
+                const f = a.point({
                     x: -this.padding() * 2,
                     y: 0
                 });
-                if (t.x += f.x, t.y += f.y, t.width += this.padding() * 2, this._movingAnchorName = this._movingAnchorName.replace("left", "right"), this._anchorDragOffset.x -= f.x, this._anchorDragOffset.y -= f.y, !a) {
+                if (t.x += f.x, t.y += f.y, t.width += this.padding() * 2, this._movingAnchorName = this._movingAnchorName.replace("left", "right"), this._anchorDragOffset.x -= f.x, this._anchorDragOffset.y -= f.y, !s) {
                     this.update();
                     return
                 }
             } else if (this._movingAnchorName && t.width < 0 && this._movingAnchorName.indexOf("right") >= 0) {
-                const f = s.point({
+                const f = a.point({
                     x: this.padding() * 2,
                     y: 0
                 });
-                if (this._movingAnchorName = this._movingAnchorName.replace("right", "left"), this._anchorDragOffset.x -= f.x, this._anchorDragOffset.y -= f.y, t.width += this.padding() * 2, !a) {
+                if (this._movingAnchorName = this._movingAnchorName.replace("right", "left"), this._anchorDragOffset.x -= f.x, this._anchorDragOffset.y -= f.y, t.width += this.padding() * 2, !s) {
                     this.update();
                     return
                 }
             }
             if (this._movingAnchorName && t.height < 0 && this._movingAnchorName.indexOf("top") >= 0) {
-                const f = s.point({
+                const f = a.point({
                     x: 0,
                     y: -this.padding() * 2
                 });
-                if (t.x += f.x, t.y += f.y, this._movingAnchorName = this._movingAnchorName.replace("top", "bottom"), this._anchorDragOffset.x -= f.x, this._anchorDragOffset.y -= f.y, t.height += this.padding() * 2, !a) {
+                if (t.x += f.x, t.y += f.y, this._movingAnchorName = this._movingAnchorName.replace("top", "bottom"), this._anchorDragOffset.x -= f.x, this._anchorDragOffset.y -= f.y, t.height += this.padding() * 2, !s) {
                     this.update();
                     return
                 }
             } else if (this._movingAnchorName && t.height < 0 && this._movingAnchorName.indexOf("bottom") >= 0) {
-                const f = s.point({
+                const f = a.point({
                     x: 0,
                     y: this.padding() * 2
                 });
-                if (this._movingAnchorName = this._movingAnchorName.replace("bottom", "top"), this._anchorDragOffset.x -= f.x, this._anchorDragOffset.y -= f.y, t.height += this.padding() * 2, !a) {
+                if (this._movingAnchorName = this._movingAnchorName.replace("bottom", "top"), this._anchorDragOffset.x -= f.x, this._anchorDragOffset.y -= f.y, t.height += this.padding() * 2, !s) {
                     this.update();
                     return
                 }
             }
             if (this.boundBoxFunc()) {
                 const f = this.boundBoxFunc()(i, t);
-                f ? t = f : R.warn("boundBoxFunc returned falsy. You should return new bound rect from it!")
+                f ? t = f : D.warn("boundBoxFunc returned falsy. You should return new bound rect from it!")
             }
             const o = 1e7,
-                l = new ir;
+                l = new Ki;
             l.translate(i.x, i.y), l.rotate(i.rotation), l.scale(i.width / o, i.height / o);
-            const u = new ir;
+            const u = new Ki;
             u.translate(t.x, t.y), u.rotate(t.rotation), u.scale(t.width / o, t.height / o);
             const c = u.multiply(l.invert());
             this._nodes.forEach(f => {
                 var h;
                 const d = f.getParent().getAbsoluteTransform(),
                     g = f.getTransform().copy();
                 g.translate(f.offsetX(), f.offsetY());
-                const p = new ir;
+                const p = new Ki;
                 p.multiply(d.copy().invert()).multiply(c).multiply(d).multiply(g);
                 const m = p.decompose();
                 f.setAttrs(m), this._fire("transform", {
                     evt: n,
                     target: f
                 }), f._fire("transform", {
                     evt: n,
                     target: f
                 }), (h = f.getLayer()) === null || h === void 0 || h.batchDraw()
-            }), this.rotation(R._getRotation(t.rotation)), this._resetTransformCache(), this.update(), this.getLayer().batchDraw()
+            }), this.rotation(D._getRotation(t.rotation)), this._resetTransformCache(), this.update(), this.getLayer().batchDraw()
         }
         forceUpdate() {
             this._resetTransformCache(), this.update()
         }
         _batchChangeChild(t, n) {
             this.findOne(t).setAttrs(n)
         }
         update() {
             var t, n = this._getNodeRect();
-            this.rotation(R._getRotation(n.rotation));
+            this.rotation(D._getRotation(n.rotation));
             var i = n.width,
                 r = n.height,
-                a = this.enabledAnchors(),
-                s = this.resizeEnabled(),
+                s = this.enabledAnchors(),
+                a = this.resizeEnabled(),
                 o = this.padding(),
                 l = this.anchorSize();
             this.find("._anchor").forEach(u => {
                 u.setAttrs({
                     width: l,
                     height: l,
                     offsetX: l / 2,
@@ -6333,56 +6333,56 @@
                     cornerRadius: this.anchorCornerRadius()
                 })
             }), this._batchChangeChild(".top-left", {
                 x: 0,
                 y: 0,
                 offsetX: l / 2 + o,
                 offsetY: l / 2 + o,
-                visible: s && a.indexOf("top-left") >= 0
+                visible: a && s.indexOf("top-left") >= 0
             }), this._batchChangeChild(".top-center", {
                 x: i / 2,
                 y: 0,
                 offsetY: l / 2 + o,
-                visible: s && a.indexOf("top-center") >= 0
+                visible: a && s.indexOf("top-center") >= 0
             }), this._batchChangeChild(".top-right", {
                 x: i,
                 y: 0,
                 offsetX: l / 2 - o,
                 offsetY: l / 2 + o,
-                visible: s && a.indexOf("top-right") >= 0
+                visible: a && s.indexOf("top-right") >= 0
             }), this._batchChangeChild(".middle-left", {
                 x: 0,
                 y: r / 2,
                 offsetX: l / 2 + o,
-                visible: s && a.indexOf("middle-left") >= 0
+                visible: a && s.indexOf("middle-left") >= 0
             }), this._batchChangeChild(".middle-right", {
                 x: i,
                 y: r / 2,
                 offsetX: l / 2 - o,
-                visible: s && a.indexOf("middle-right") >= 0
+                visible: a && s.indexOf("middle-right") >= 0
             }), this._batchChangeChild(".bottom-left", {
                 x: 0,
                 y: r,
                 offsetX: l / 2 + o,
                 offsetY: l / 2 - o,
-                visible: s && a.indexOf("bottom-left") >= 0
+                visible: a && s.indexOf("bottom-left") >= 0
             }), this._batchChangeChild(".bottom-center", {
                 x: i / 2,
                 y: r,
                 offsetY: l / 2 - o,
-                visible: s && a.indexOf("bottom-center") >= 0
+                visible: a && s.indexOf("bottom-center") >= 0
             }), this._batchChangeChild(".bottom-right", {
                 x: i,
                 y: r,
                 offsetX: l / 2 - o,
                 offsetY: l / 2 - o,
-                visible: s && a.indexOf("bottom-right") >= 0
+                visible: a && s.indexOf("bottom-right") >= 0
             }), this._batchChangeChild(".rotater", {
                 x: i / 2,
-                y: -this.rotateAnchorOffset() * R._sign(r) - o,
+                y: -this.rotateAnchorOffset() * D._sign(r) - o,
                 visible: this.rotateEnabled()
             }), this._batchChangeChild(".back", {
                 width: i,
                 height: r,
                 visible: this.borderEnabled(),
                 stroke: this.borderStroke(),
                 strokeWidth: this.borderStrokeWidth(),
@@ -6398,72 +6398,72 @@
             if (this._transforming) {
                 this._removeEvents();
                 var t = this.findOne("." + this._movingAnchorName);
                 t && t.stopDrag()
             }
         }
         destroy() {
-            return this.getStage() && this._cursorChange && this.getStage().content && (this.getStage().content.style.cursor = ""), Bu.prototype.destroy.call(this), this.detach(), this._removeEvents(), this
+            return this.getStage() && this._cursorChange && this.getStage().content && (this.getStage().content.style.cursor = ""), Mu.prototype.destroy.call(this), this.detach(), this._removeEvents(), this
         }
         toObject() {
-            return te.prototype.toObject.call(this)
+            return ne.prototype.toObject.call(this)
         }
         clone(t) {
-            var n = te.prototype.clone.call(this, t);
+            var n = ne.prototype.clone.call(this, t);
             return n
         }
         getClientRect() {
             return this.nodes().length > 0 ? super.getClientRect() : {
                 x: 0,
                 y: 0,
                 width: 0,
                 height: 0
             }
         }
     }
 
-    function N7(e) {
-        return e instanceof Array || R.warn("enabledAnchors value should be an array"), e instanceof Array && e.forEach(function(t) {
-            Pp.indexOf(t) === -1 && R.warn("Unknown anchor name: " + t + ". Available names are: " + Pp.join(", "))
+    function G7(e) {
+        return e instanceof Array || D.warn("enabledAnchors value should be an array"), e instanceof Array && e.forEach(function(t) {
+            mp.indexOf(t) === -1 && D.warn("Unknown anchor name: " + t + ". Available names are: " + mp.join(", "))
         }), e || []
     }
-    Je.prototype.className = "Transformer";
-    mt(Je);
-    M.addGetterSetter(Je, "enabledAnchors", Pp, N7);
-    M.addGetterSetter(Je, "flipEnabled", !0, Sr());
-    M.addGetterSetter(Je, "resizeEnabled", !0);
-    M.addGetterSetter(Je, "anchorSize", 10, ee());
-    M.addGetterSetter(Je, "rotateEnabled", !0);
-    M.addGetterSetter(Je, "rotationSnaps", []);
-    M.addGetterSetter(Je, "rotateAnchorOffset", 50, ee());
-    M.addGetterSetter(Je, "rotationSnapTolerance", 5, ee());
-    M.addGetterSetter(Je, "borderEnabled", !0);
-    M.addGetterSetter(Je, "anchorStroke", "rgb(0, 161, 255)");
-    M.addGetterSetter(Je, "anchorStrokeWidth", 1, ee());
-    M.addGetterSetter(Je, "anchorFill", "white");
-    M.addGetterSetter(Je, "anchorCornerRadius", 0, ee());
-    M.addGetterSetter(Je, "borderStroke", "rgb(0, 161, 255)");
-    M.addGetterSetter(Je, "borderStrokeWidth", 1, ee());
-    M.addGetterSetter(Je, "borderDash");
-    M.addGetterSetter(Je, "keepRatio", !0);
-    M.addGetterSetter(Je, "centeredScaling", !1);
-    M.addGetterSetter(Je, "ignoreStroke", !1);
-    M.addGetterSetter(Je, "padding", 0, ee());
-    M.addGetterSetter(Je, "node");
-    M.addGetterSetter(Je, "nodes");
-    M.addGetterSetter(Je, "boundBoxFunc");
-    M.addGetterSetter(Je, "anchorDragBoundFunc");
-    M.addGetterSetter(Je, "shouldOverdrawWholeArea", !1);
-    M.addGetterSetter(Je, "useSingleNodeRotation", !0);
-    M.backCompat(Je, {
+    Ke.prototype.className = "Transformer";
+    pt(Ke);
+    O.addGetterSetter(Ke, "enabledAnchors", mp, G7);
+    O.addGetterSetter(Ke, "flipEnabled", !0, mr());
+    O.addGetterSetter(Ke, "resizeEnabled", !0);
+    O.addGetterSetter(Ke, "anchorSize", 10, te());
+    O.addGetterSetter(Ke, "rotateEnabled", !0);
+    O.addGetterSetter(Ke, "rotationSnaps", []);
+    O.addGetterSetter(Ke, "rotateAnchorOffset", 50, te());
+    O.addGetterSetter(Ke, "rotationSnapTolerance", 5, te());
+    O.addGetterSetter(Ke, "borderEnabled", !0);
+    O.addGetterSetter(Ke, "anchorStroke", "rgb(0, 161, 255)");
+    O.addGetterSetter(Ke, "anchorStrokeWidth", 1, te());
+    O.addGetterSetter(Ke, "anchorFill", "white");
+    O.addGetterSetter(Ke, "anchorCornerRadius", 0, te());
+    O.addGetterSetter(Ke, "borderStroke", "rgb(0, 161, 255)");
+    O.addGetterSetter(Ke, "borderStrokeWidth", 1, te());
+    O.addGetterSetter(Ke, "borderDash");
+    O.addGetterSetter(Ke, "keepRatio", !0);
+    O.addGetterSetter(Ke, "centeredScaling", !1);
+    O.addGetterSetter(Ke, "ignoreStroke", !1);
+    O.addGetterSetter(Ke, "padding", 0, te());
+    O.addGetterSetter(Ke, "node");
+    O.addGetterSetter(Ke, "nodes");
+    O.addGetterSetter(Ke, "boundBoxFunc");
+    O.addGetterSetter(Ke, "anchorDragBoundFunc");
+    O.addGetterSetter(Ke, "shouldOverdrawWholeArea", !1);
+    O.addGetterSetter(Ke, "useSingleNodeRotation", !0);
+    O.backCompat(Ke, {
         lineEnabled: "borderEnabled",
         rotateHandlerOffset: "rotateAnchorOffset",
         enabledHandlers: "enabledAnchors"
     });
-    class Za extends V {
+    class Ws extends V {
         _sceneFunc(t) {
             t.beginPath(), t.arc(0, 0, this.radius(), 0, le.getAngle(this.angle()), this.clockwise()), t.lineTo(0, 0), t.closePath(), t.fillStrokeShape(this)
         }
         getWidth() {
             return this.radius() * 2
         }
         getHeight() {
@@ -6472,559 +6472,559 @@
         setWidth(t) {
             this.radius(t / 2)
         }
         setHeight(t) {
             this.radius(t / 2)
         }
     }
-    Za.prototype.className = "Wedge";
-    Za.prototype._centroid = !0;
-    Za.prototype._attrsAffectingSize = ["radius"];
-    mt(Za);
-    M.addGetterSetter(Za, "radius", 0, ee());
-    M.addGetterSetter(Za, "angle", 0, ee());
-    M.addGetterSetter(Za, "clockwise", !1);
-    M.backCompat(Za, {
+    Ws.prototype.className = "Wedge";
+    Ws.prototype._centroid = !0;
+    Ws.prototype._attrsAffectingSize = ["radius"];
+    pt(Ws);
+    O.addGetterSetter(Ws, "radius", 0, te());
+    O.addGetterSetter(Ws, "angle", 0, te());
+    O.addGetterSetter(Ws, "clockwise", !1);
+    O.backCompat(Ws, {
         angleDeg: "angle",
         getAngleDeg: "getAngle",
         setAngleDeg: "setAngle"
     });
 
-    function uk() {
+    function Sk() {
         this.r = 0, this.g = 0, this.b = 0, this.a = 0, this.next = null
     }
-    var L7 = [512, 512, 456, 512, 328, 456, 335, 512, 405, 328, 271, 456, 388, 335, 292, 512, 454, 405, 364, 328, 298, 271, 496, 456, 420, 388, 360, 335, 312, 292, 273, 512, 482, 454, 428, 405, 383, 364, 345, 328, 312, 298, 284, 271, 259, 496, 475, 456, 437, 420, 404, 388, 374, 360, 347, 335, 323, 312, 302, 292, 282, 273, 265, 512, 497, 482, 468, 454, 441, 428, 417, 405, 394, 383, 373, 364, 354, 345, 337, 328, 320, 312, 305, 298, 291, 284, 278, 271, 265, 259, 507, 496, 485, 475, 465, 456, 446, 437, 428, 420, 412, 404, 396, 388, 381, 374, 367, 360, 354, 347, 341, 335, 329, 323, 318, 312, 307, 302, 297, 292, 287, 282, 278, 273, 269, 265, 261, 512, 505, 497, 489, 482, 475, 468, 461, 454, 447, 441, 435, 428, 422, 417, 411, 405, 399, 394, 389, 383, 378, 373, 368, 364, 359, 354, 350, 345, 341, 337, 332, 328, 324, 320, 316, 312, 309, 305, 301, 298, 294, 291, 287, 284, 281, 278, 274, 271, 268, 265, 262, 259, 257, 507, 501, 496, 491, 485, 480, 475, 470, 465, 460, 456, 451, 446, 442, 437, 433, 428, 424, 420, 416, 412, 408, 404, 400, 396, 392, 388, 385, 381, 377, 374, 370, 367, 363, 360, 357, 354, 350, 347, 344, 341, 338, 335, 332, 329, 326, 323, 320, 318, 315, 312, 310, 307, 304, 302, 299, 297, 294, 292, 289, 287, 285, 282, 280, 278, 275, 273, 271, 269, 267, 265, 263, 261, 259],
-        I7 = [9, 11, 12, 13, 13, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24];
+    var W7 = [512, 512, 456, 512, 328, 456, 335, 512, 405, 328, 271, 456, 388, 335, 292, 512, 454, 405, 364, 328, 298, 271, 496, 456, 420, 388, 360, 335, 312, 292, 273, 512, 482, 454, 428, 405, 383, 364, 345, 328, 312, 298, 284, 271, 259, 496, 475, 456, 437, 420, 404, 388, 374, 360, 347, 335, 323, 312, 302, 292, 282, 273, 265, 512, 497, 482, 468, 454, 441, 428, 417, 405, 394, 383, 373, 364, 354, 345, 337, 328, 320, 312, 305, 298, 291, 284, 278, 271, 265, 259, 507, 496, 485, 475, 465, 456, 446, 437, 428, 420, 412, 404, 396, 388, 381, 374, 367, 360, 354, 347, 341, 335, 329, 323, 318, 312, 307, 302, 297, 292, 287, 282, 278, 273, 269, 265, 261, 512, 505, 497, 489, 482, 475, 468, 461, 454, 447, 441, 435, 428, 422, 417, 411, 405, 399, 394, 389, 383, 378, 373, 368, 364, 359, 354, 350, 345, 341, 337, 332, 328, 324, 320, 316, 312, 309, 305, 301, 298, 294, 291, 287, 284, 281, 278, 274, 271, 268, 265, 262, 259, 257, 507, 501, 496, 491, 485, 480, 475, 470, 465, 460, 456, 451, 446, 442, 437, 433, 428, 424, 420, 416, 412, 408, 404, 400, 396, 392, 388, 385, 381, 377, 374, 370, 367, 363, 360, 357, 354, 350, 347, 344, 341, 338, 335, 332, 329, 326, 323, 320, 318, 315, 312, 310, 307, 304, 302, 299, 297, 294, 292, 289, 287, 285, 282, 280, 278, 275, 273, 271, 269, 267, 265, 263, 261, 259],
+        q7 = [9, 11, 12, 13, 13, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24];
 
-    function j7(e, t) {
+    function H7(e, t) {
         var n = e.data,
             i = e.width,
             r = e.height,
-            a, s, o, l, u, c, f, h, d, g, p, m, y, v, b, x, _, S, w, O, k, C, E, T, A = t + t + 1,
-            F = i - 1,
-            $ = r - 1,
-            D = t + 1,
-            P = D * (D + 1) / 2,
-            N = new uk,
+            s, a, o, l, u, c, f, h, d, g, p, m, y, v, b, x, _, S, w, E, A, C, k, R, $ = t + t + 1,
+            T = i - 1,
+            M = r - 1,
+            F = t + 1,
+            N = F * (F + 1) / 2,
+            P = new Sk,
             z = null,
-            I = N,
-            ae = null,
-            ye = null,
-            we = L7[t],
-            $e = I7[t];
-        for (o = 1; o < A; o++) I = I.next = new uk, o === D && (z = I);
-        for (I.next = N, f = c = 0, s = 0; s < r; s++) {
-            for (x = _ = S = w = h = d = g = p = 0, m = D * (O = n[c]), y = D * (k = n[c + 1]), v = D * (C = n[c + 2]), b = D * (E = n[c + 3]), h += P * O, d += P * k, g += P * C, p += P * E, I = N, o = 0; o < D; o++) I.r = O, I.g = k, I.b = C, I.a = E, I = I.next;
-            for (o = 1; o < D; o++) l = c + ((F < o ? F : o) << 2), h += (I.r = O = n[l]) * (T = D - o), d += (I.g = k = n[l + 1]) * T, g += (I.b = C = n[l + 2]) * T, p += (I.a = E = n[l + 3]) * T, x += O, _ += k, S += C, w += E, I = I.next;
-            for (ae = N, ye = z, a = 0; a < i; a++) n[c + 3] = E = p * we >> $e, E !== 0 ? (E = 255 / E, n[c] = (h * we >> $e) * E, n[c + 1] = (d * we >> $e) * E, n[c + 2] = (g * we >> $e) * E) : n[c] = n[c + 1] = n[c + 2] = 0, h -= m, d -= y, g -= v, p -= b, m -= ae.r, y -= ae.g, v -= ae.b, b -= ae.a, l = f + ((l = a + t + 1) < F ? l : F) << 2, x += ae.r = n[l], _ += ae.g = n[l + 1], S += ae.b = n[l + 2], w += ae.a = n[l + 3], h += x, d += _, g += S, p += w, ae = ae.next, m += O = ye.r, y += k = ye.g, v += C = ye.b, b += E = ye.a, x -= O, _ -= k, S -= C, w -= E, ye = ye.next, c += 4;
+            I = P,
+            Q = null,
+            oe = null,
+            Se = W7[t],
+            ye = q7[t];
+        for (o = 1; o < $; o++) I = I.next = new Sk, o === F && (z = I);
+        for (I.next = P, f = c = 0, a = 0; a < r; a++) {
+            for (x = _ = S = w = h = d = g = p = 0, m = F * (E = n[c]), y = F * (A = n[c + 1]), v = F * (C = n[c + 2]), b = F * (k = n[c + 3]), h += N * E, d += N * A, g += N * C, p += N * k, I = P, o = 0; o < F; o++) I.r = E, I.g = A, I.b = C, I.a = k, I = I.next;
+            for (o = 1; o < F; o++) l = c + ((T < o ? T : o) << 2), h += (I.r = E = n[l]) * (R = F - o), d += (I.g = A = n[l + 1]) * R, g += (I.b = C = n[l + 2]) * R, p += (I.a = k = n[l + 3]) * R, x += E, _ += A, S += C, w += k, I = I.next;
+            for (Q = P, oe = z, s = 0; s < i; s++) n[c + 3] = k = p * Se >> ye, k !== 0 ? (k = 255 / k, n[c] = (h * Se >> ye) * k, n[c + 1] = (d * Se >> ye) * k, n[c + 2] = (g * Se >> ye) * k) : n[c] = n[c + 1] = n[c + 2] = 0, h -= m, d -= y, g -= v, p -= b, m -= Q.r, y -= Q.g, v -= Q.b, b -= Q.a, l = f + ((l = s + t + 1) < T ? l : T) << 2, x += Q.r = n[l], _ += Q.g = n[l + 1], S += Q.b = n[l + 2], w += Q.a = n[l + 3], h += x, d += _, g += S, p += w, Q = Q.next, m += E = oe.r, y += A = oe.g, v += C = oe.b, b += k = oe.a, x -= E, _ -= A, S -= C, w -= k, oe = oe.next, c += 4;
             f += i
         }
-        for (a = 0; a < i; a++) {
-            for (_ = S = w = x = d = g = p = h = 0, c = a << 2, m = D * (O = n[c]), y = D * (k = n[c + 1]), v = D * (C = n[c + 2]), b = D * (E = n[c + 3]), h += P * O, d += P * k, g += P * C, p += P * E, I = N, o = 0; o < D; o++) I.r = O, I.g = k, I.b = C, I.a = E, I = I.next;
-            for (u = i, o = 1; o <= t; o++) c = u + a << 2, h += (I.r = O = n[c]) * (T = D - o), d += (I.g = k = n[c + 1]) * T, g += (I.b = C = n[c + 2]) * T, p += (I.a = E = n[c + 3]) * T, x += O, _ += k, S += C, w += E, I = I.next, o < $ && (u += i);
-            for (c = a, ae = N, ye = z, s = 0; s < r; s++) l = c << 2, n[l + 3] = E = p * we >> $e, E > 0 ? (E = 255 / E, n[l] = (h * we >> $e) * E, n[l + 1] = (d * we >> $e) * E, n[l + 2] = (g * we >> $e) * E) : n[l] = n[l + 1] = n[l + 2] = 0, h -= m, d -= y, g -= v, p -= b, m -= ae.r, y -= ae.g, v -= ae.b, b -= ae.a, l = a + ((l = s + D) < $ ? l : $) * i << 2, h += x += ae.r = n[l], d += _ += ae.g = n[l + 1], g += S += ae.b = n[l + 2], p += w += ae.a = n[l + 3], ae = ae.next, m += O = ye.r, y += k = ye.g, v += C = ye.b, b += E = ye.a, x -= O, _ -= k, S -= C, w -= E, ye = ye.next, c += i
+        for (s = 0; s < i; s++) {
+            for (_ = S = w = x = d = g = p = h = 0, c = s << 2, m = F * (E = n[c]), y = F * (A = n[c + 1]), v = F * (C = n[c + 2]), b = F * (k = n[c + 3]), h += N * E, d += N * A, g += N * C, p += N * k, I = P, o = 0; o < F; o++) I.r = E, I.g = A, I.b = C, I.a = k, I = I.next;
+            for (u = i, o = 1; o <= t; o++) c = u + s << 2, h += (I.r = E = n[c]) * (R = F - o), d += (I.g = A = n[c + 1]) * R, g += (I.b = C = n[c + 2]) * R, p += (I.a = k = n[c + 3]) * R, x += E, _ += A, S += C, w += k, I = I.next, o < M && (u += i);
+            for (c = s, Q = P, oe = z, a = 0; a < r; a++) l = c << 2, n[l + 3] = k = p * Se >> ye, k > 0 ? (k = 255 / k, n[l] = (h * Se >> ye) * k, n[l + 1] = (d * Se >> ye) * k, n[l + 2] = (g * Se >> ye) * k) : n[l] = n[l + 1] = n[l + 2] = 0, h -= m, d -= y, g -= v, p -= b, m -= Q.r, y -= Q.g, v -= Q.b, b -= Q.a, l = s + ((l = a + F) < M ? l : M) * i << 2, h += x += Q.r = n[l], d += _ += Q.g = n[l + 1], g += S += Q.b = n[l + 2], p += w += Q.a = n[l + 3], Q = Q.next, m += E = oe.r, y += A = oe.g, v += C = oe.b, b += k = oe.a, x -= E, _ -= A, S -= C, w -= k, oe = oe.next, c += i
         }
     }
-    const z7 = function(t) {
+    const Y7 = function(t) {
         var n = Math.round(this.blurRadius());
-        n > 0 && j7(t, n)
+        n > 0 && H7(t, n)
     };
-    M.addGetterSetter(te, "blurRadius", 0, ee(), M.afterSetFilter);
-    const B7 = function(e) {
+    O.addGetterSetter(ne, "blurRadius", 0, te(), O.afterSetFilter);
+    const X7 = function(e) {
         var t = this.brightness() * 255,
             n = e.data,
             i = n.length,
             r;
         for (r = 0; r < i; r += 4) n[r] += t, n[r + 1] += t, n[r + 2] += t
     };
-    M.addGetterSetter(te, "brightness", 0, ee(), M.afterSetFilter);
-    const G7 = function(e) {
+    O.addGetterSetter(ne, "brightness", 0, te(), O.afterSetFilter);
+    const V7 = function(e) {
         var t = Math.pow((this.contrast() + 100) / 100, 2),
             n = e.data,
             i = n.length,
             r = 150,
-            a = 150,
             s = 150,
+            a = 150,
             o;
-        for (o = 0; o < i; o += 4) r = n[o], a = n[o + 1], s = n[o + 2], r /= 255, r -= .5, r *= t, r += .5, r *= 255, a /= 255, a -= .5, a *= t, a += .5, a *= 255, s /= 255, s -= .5, s *= t, s += .5, s *= 255, r = r < 0 ? 0 : r > 255 ? 255 : r, a = a < 0 ? 0 : a > 255 ? 255 : a, s = s < 0 ? 0 : s > 255 ? 255 : s, n[o] = r, n[o + 1] = a, n[o + 2] = s
+        for (o = 0; o < i; o += 4) r = n[o], s = n[o + 1], a = n[o + 2], r /= 255, r -= .5, r *= t, r += .5, r *= 255, s /= 255, s -= .5, s *= t, s += .5, s *= 255, a /= 255, a -= .5, a *= t, a += .5, a *= 255, r = r < 0 ? 0 : r > 255 ? 255 : r, s = s < 0 ? 0 : s > 255 ? 255 : s, a = a < 0 ? 0 : a > 255 ? 255 : a, n[o] = r, n[o + 1] = s, n[o + 2] = a
     };
-    M.addGetterSetter(te, "contrast", 0, ee(), M.afterSetFilter);
-    const U7 = function(e) {
+    O.addGetterSetter(ne, "contrast", 0, te(), O.afterSetFilter);
+    const K7 = function(e) {
         var t = this.embossStrength() * 10,
             n = this.embossWhiteLevel() * 255,
             i = this.embossDirection(),
             r = this.embossBlend(),
-            a = 0,
             s = 0,
+            a = 0,
             o = e.data,
             l = e.width,
             u = e.height,
             c = l * 4,
             f = u;
         switch (i) {
             case "top-left":
-                a = -1, s = -1;
+                s = -1, a = -1;
                 break;
             case "top":
-                a = -1, s = 0;
+                s = -1, a = 0;
                 break;
             case "top-right":
-                a = -1, s = 1;
+                s = -1, a = 1;
                 break;
             case "right":
-                a = 0, s = 1;
+                s = 0, a = 1;
                 break;
             case "bottom-right":
-                a = 1, s = 1;
+                s = 1, a = 1;
                 break;
             case "bottom":
-                a = 1, s = 0;
+                s = 1, a = 0;
                 break;
             case "bottom-left":
-                a = 1, s = -1;
+                s = 1, a = -1;
                 break;
             case "left":
-                a = 0, s = -1;
+                s = 0, a = -1;
                 break;
             default:
-                R.error("Unknown emboss direction: " + i)
+                D.error("Unknown emboss direction: " + i)
         }
         do {
             var h = (f - 1) * c,
-                d = a;
+                d = s;
             f + d < 1 && (d = 0), f + d > u && (d = 0);
             var g = (f - 1 + d) * l * 4,
                 p = l;
             do {
                 var m = h + (p - 1) * 4,
-                    y = s;
+                    y = a;
                 p + y < 1 && (y = 0), p + y > l && (y = 0);
                 var v = g + (p - 1 + y) * 4,
                     b = o[m] - o[v],
                     x = o[m + 1] - o[v + 1],
                     _ = o[m + 2] - o[v + 2],
                     S = b,
                     w = S > 0 ? S : -S,
-                    O = x > 0 ? x : -x,
-                    k = _ > 0 ? _ : -_;
-                if (O > w && (S = x), k > w && (S = _), S *= t, r) {
+                    E = x > 0 ? x : -x,
+                    A = _ > 0 ? _ : -_;
+                if (E > w && (S = x), A > w && (S = _), S *= t, r) {
                     var C = o[m] + S,
-                        E = o[m + 1] + S,
-                        T = o[m + 2] + S;
-                    o[m] = C > 255 ? 255 : C < 0 ? 0 : C, o[m + 1] = E > 255 ? 255 : E < 0 ? 0 : E, o[m + 2] = T > 255 ? 255 : T < 0 ? 0 : T
+                        k = o[m + 1] + S,
+                        R = o[m + 2] + S;
+                    o[m] = C > 255 ? 255 : C < 0 ? 0 : C, o[m + 1] = k > 255 ? 255 : k < 0 ? 0 : k, o[m + 2] = R > 255 ? 255 : R < 0 ? 0 : R
                 } else {
-                    var A = n - S;
-                    A < 0 ? A = 0 : A > 255 && (A = 255), o[m] = o[m + 1] = o[m + 2] = A
+                    var $ = n - S;
+                    $ < 0 ? $ = 0 : $ > 255 && ($ = 255), o[m] = o[m + 1] = o[m + 2] = $
                 }
             } while (--p)
         } while (--f)
     };
-    M.addGetterSetter(te, "embossStrength", .5, ee(), M.afterSetFilter);
-    M.addGetterSetter(te, "embossWhiteLevel", .5, ee(), M.afterSetFilter);
-    M.addGetterSetter(te, "embossDirection", "top-left", null, M.afterSetFilter);
-    M.addGetterSetter(te, "embossBlend", !1, null, M.afterSetFilter);
-
-    function jy(e, t, n, i, r) {
-        var a = n - t,
-            s = r - i,
+    O.addGetterSetter(ne, "embossStrength", .5, te(), O.afterSetFilter);
+    O.addGetterSetter(ne, "embossWhiteLevel", .5, te(), O.afterSetFilter);
+    O.addGetterSetter(ne, "embossDirection", "top-left", null, O.afterSetFilter);
+    O.addGetterSetter(ne, "embossBlend", !1, null, O.afterSetFilter);
+
+    function yy(e, t, n, i, r) {
+        var s = n - t,
+            a = r - i,
             o;
-        return a === 0 ? i + s / 2 : s === 0 ? i : (o = (e - t) / a, o = s * o + i, o)
+        return s === 0 ? i + a / 2 : a === 0 ? i : (o = (e - t) / s, o = a * o + i, o)
     }
-    const q7 = function(e) {
+    const J7 = function(e) {
         var t = e.data,
             n = t.length,
             i = t[0],
             r = i,
-            a, s = t[1],
-            o = s,
+            s, a = t[1],
+            o = a,
             l, u = t[2],
             c = u,
             f, h, d = this.enhance();
         if (d !== 0) {
-            for (h = 0; h < n; h += 4) a = t[h + 0], a < i ? i = a : a > r && (r = a), l = t[h + 1], l < s ? s = l : l > o && (o = l), f = t[h + 2], f < u ? u = f : f > c && (c = f);
-            r === i && (r = 255, i = 0), o === s && (o = 255, s = 0), c === u && (c = 255, u = 0);
+            for (h = 0; h < n; h += 4) s = t[h + 0], s < i ? i = s : s > r && (r = s), l = t[h + 1], l < a ? a = l : l > o && (o = l), f = t[h + 2], f < u ? u = f : f > c && (c = f);
+            r === i && (r = 255, i = 0), o === a && (o = 255, a = 0), c === u && (c = 255, u = 0);
             var g, p, m, y, v, b, x, _, S;
-            for (d > 0 ? (p = r + d * (255 - r), m = i - d * (i - 0), v = o + d * (255 - o), b = s - d * (s - 0), _ = c + d * (255 - c), S = u - d * (u - 0)) : (g = (r + i) * .5, p = r + d * (r - g), m = i + d * (i - g), y = (o + s) * .5, v = o + d * (o - y), b = s + d * (s - y), x = (c + u) * .5, _ = c + d * (c - x), S = u + d * (u - x)), h = 0; h < n; h += 4) t[h + 0] = jy(t[h + 0], i, r, m, p), t[h + 1] = jy(t[h + 1], s, o, b, v), t[h + 2] = jy(t[h + 2], u, c, S, _)
+            for (d > 0 ? (p = r + d * (255 - r), m = i - d * (i - 0), v = o + d * (255 - o), b = a - d * (a - 0), _ = c + d * (255 - c), S = u - d * (u - 0)) : (g = (r + i) * .5, p = r + d * (r - g), m = i + d * (i - g), y = (o + a) * .5, v = o + d * (o - y), b = a + d * (a - y), x = (c + u) * .5, _ = c + d * (c - x), S = u + d * (u - x)), h = 0; h < n; h += 4) t[h + 0] = yy(t[h + 0], i, r, m, p), t[h + 1] = yy(t[h + 1], a, o, b, v), t[h + 2] = yy(t[h + 2], u, c, S, _)
         }
     };
-    M.addGetterSetter(te, "enhance", 0, ee(), M.afterSetFilter);
-    const W7 = function(e) {
+    O.addGetterSetter(ne, "enhance", 0, te(), O.afterSetFilter);
+    const Q7 = function(e) {
         var t = e.data,
             n = t.length,
             i, r;
         for (i = 0; i < n; i += 4) r = .34 * t[i] + .5 * t[i + 1] + .16 * t[i + 2], t[i] = r, t[i + 1] = r, t[i + 2] = r
     };
-    M.addGetterSetter(te, "hue", 0, ee(), M.afterSetFilter);
-    M.addGetterSetter(te, "saturation", 0, ee(), M.afterSetFilter);
-    M.addGetterSetter(te, "luminance", 0, ee(), M.afterSetFilter);
-    const H7 = function(e) {
+    O.addGetterSetter(ne, "hue", 0, te(), O.afterSetFilter);
+    O.addGetterSetter(ne, "saturation", 0, te(), O.afterSetFilter);
+    O.addGetterSetter(ne, "luminance", 0, te(), O.afterSetFilter);
+    const Z7 = function(e) {
             var t = e.data,
                 n = t.length,
                 i = 1,
                 r = Math.pow(2, this.saturation()),
-                a = Math.abs(this.hue() + 360) % 360,
-                s = this.luminance() * 127,
-                o, l = i * r * Math.cos(a * Math.PI / 180),
-                u = i * r * Math.sin(a * Math.PI / 180),
+                s = Math.abs(this.hue() + 360) % 360,
+                a = this.luminance() * 127,
+                o, l = i * r * Math.cos(s * Math.PI / 180),
+                u = i * r * Math.sin(s * Math.PI / 180),
                 c = .299 * i + .701 * l + .167 * u,
                 f = .587 * i - .587 * l + .33 * u,
                 h = .114 * i - .114 * l - .497 * u,
                 d = .299 * i - .299 * l - .328 * u,
                 g = .587 * i + .413 * l + .035 * u,
                 p = .114 * i - .114 * l + .293 * u,
                 m = .299 * i - .3 * l + 1.25 * u,
                 y = .587 * i - .586 * l - 1.05 * u,
                 v = .114 * i + .886 * l - .2 * u,
                 b, x, _, S;
-            for (o = 0; o < n; o += 4) b = t[o + 0], x = t[o + 1], _ = t[o + 2], S = t[o + 3], t[o + 0] = c * b + f * x + h * _ + s, t[o + 1] = d * b + g * x + p * _ + s, t[o + 2] = m * b + y * x + v * _ + s, t[o + 3] = S
+            for (o = 0; o < n; o += 4) b = t[o + 0], x = t[o + 1], _ = t[o + 2], S = t[o + 3], t[o + 0] = c * b + f * x + h * _ + a, t[o + 1] = d * b + g * x + p * _ + a, t[o + 2] = m * b + y * x + v * _ + a, t[o + 3] = S
         },
-        Y7 = function(e) {
+        eB = function(e) {
             var t = e.data,
                 n = t.length,
                 i = Math.pow(2, this.value()),
                 r = Math.pow(2, this.saturation()),
-                a = Math.abs(this.hue() + 360) % 360,
-                s, o = i * r * Math.cos(a * Math.PI / 180),
-                l = i * r * Math.sin(a * Math.PI / 180),
+                s = Math.abs(this.hue() + 360) % 360,
+                a, o = i * r * Math.cos(s * Math.PI / 180),
+                l = i * r * Math.sin(s * Math.PI / 180),
                 u = .299 * i + .701 * o + .167 * l,
                 c = .587 * i - .587 * o + .33 * l,
                 f = .114 * i - .114 * o - .497 * l,
                 h = .299 * i - .299 * o - .328 * l,
                 d = .587 * i + .413 * o + .035 * l,
                 g = .114 * i - .114 * o + .293 * l,
                 p = .299 * i - .3 * o + 1.25 * l,
                 m = .587 * i - .586 * o - 1.05 * l,
                 y = .114 * i + .886 * o - .2 * l,
                 v, b, x, _;
-            for (s = 0; s < n; s += 4) v = t[s + 0], b = t[s + 1], x = t[s + 2], _ = t[s + 3], t[s + 0] = u * v + c * b + f * x, t[s + 1] = h * v + d * b + g * x, t[s + 2] = p * v + m * b + y * x, t[s + 3] = _
+            for (a = 0; a < n; a += 4) v = t[a + 0], b = t[a + 1], x = t[a + 2], _ = t[a + 3], t[a + 0] = u * v + c * b + f * x, t[a + 1] = h * v + d * b + g * x, t[a + 2] = p * v + m * b + y * x, t[a + 3] = _
         };
-    M.addGetterSetter(te, "hue", 0, ee(), M.afterSetFilter);
-    M.addGetterSetter(te, "saturation", 0, ee(), M.afterSetFilter);
-    M.addGetterSetter(te, "value", 0, ee(), M.afterSetFilter);
-    const X7 = function(e) {
+    O.addGetterSetter(ne, "hue", 0, te(), O.afterSetFilter);
+    O.addGetterSetter(ne, "saturation", 0, te(), O.afterSetFilter);
+    O.addGetterSetter(ne, "value", 0, te(), O.afterSetFilter);
+    const tB = function(e) {
         var t = e.data,
             n = t.length,
             i;
         for (i = 0; i < n; i += 4) t[i] = 255 - t[i], t[i + 1] = 255 - t[i + 1], t[i + 2] = 255 - t[i + 2]
     };
-    var V7 = function(e, t, n) {
+    var nB = function(e, t, n) {
             var i = e.data,
                 r = t.data,
-                a = e.width,
-                s = e.height,
-                o = n.polarCenterX || a / 2,
-                l = n.polarCenterY || s / 2,
+                s = e.width,
+                a = e.height,
+                o = n.polarCenterX || s / 2,
+                l = n.polarCenterY || a / 2,
                 u, c, f, h = 0,
                 d = 0,
                 g = 0,
                 p = 0,
                 m, y = Math.sqrt(o * o + l * l);
-            c = a - o, f = s - l, m = Math.sqrt(c * c + f * f), y = m > y ? m : y;
-            var v = s,
-                b = a,
+            c = s - o, f = a - l, m = Math.sqrt(c * c + f * f), y = m > y ? m : y;
+            var v = a,
+                b = s,
                 x, _, S = 360 / b * Math.PI / 180,
-                w, O;
+                w, E;
             for (_ = 0; _ < b; _ += 1)
-                for (w = Math.sin(_ * S), O = Math.cos(_ * S), x = 0; x < v; x += 1) c = Math.floor(o + y * x / v * O), f = Math.floor(l + y * x / v * w), u = (f * a + c) * 4, h = i[u + 0], d = i[u + 1], g = i[u + 2], p = i[u + 3], u = (_ + x * a) * 4, r[u + 0] = h, r[u + 1] = d, r[u + 2] = g, r[u + 3] = p
+                for (w = Math.sin(_ * S), E = Math.cos(_ * S), x = 0; x < v; x += 1) c = Math.floor(o + y * x / v * E), f = Math.floor(l + y * x / v * w), u = (f * s + c) * 4, h = i[u + 0], d = i[u + 1], g = i[u + 2], p = i[u + 3], u = (_ + x * s) * 4, r[u + 0] = h, r[u + 1] = d, r[u + 2] = g, r[u + 3] = p
         },
-        K7 = function(e, t, n) {
+        iB = function(e, t, n) {
             var i = e.data,
                 r = t.data,
-                a = e.width,
-                s = e.height,
-                o = n.polarCenterX || a / 2,
-                l = n.polarCenterY || s / 2,
+                s = e.width,
+                a = e.height,
+                o = n.polarCenterX || s / 2,
+                l = n.polarCenterY || a / 2,
                 u, c, f, h, d, g = 0,
                 p = 0,
                 m = 0,
                 y = 0,
                 v, b = Math.sqrt(o * o + l * l);
-            c = a - o, f = s - l, v = Math.sqrt(c * c + f * f), b = v > b ? v : b;
-            var x = s,
-                _ = a,
-                S, w, O = n.polarRotation || 0,
-                k, C;
-            for (c = 0; c < a; c += 1)
-                for (f = 0; f < s; f += 1) h = c - o, d = f - l, S = Math.sqrt(h * h + d * d) * x / b, w = (Math.atan2(d, h) * 180 / Math.PI + 360 + O) % 360, w = w * _ / 360, k = Math.floor(w), C = Math.floor(S), u = (C * a + k) * 4, g = i[u + 0], p = i[u + 1], m = i[u + 2], y = i[u + 3], u = (f * a + c) * 4, r[u + 0] = g, r[u + 1] = p, r[u + 2] = m, r[u + 3] = y
+            c = s - o, f = a - l, v = Math.sqrt(c * c + f * f), b = v > b ? v : b;
+            var x = a,
+                _ = s,
+                S, w, E = n.polarRotation || 0,
+                A, C;
+            for (c = 0; c < s; c += 1)
+                for (f = 0; f < a; f += 1) h = c - o, d = f - l, S = Math.sqrt(h * h + d * d) * x / b, w = (Math.atan2(d, h) * 180 / Math.PI + 360 + E) % 360, w = w * _ / 360, A = Math.floor(w), C = Math.floor(S), u = (C * s + A) * 4, g = i[u + 0], p = i[u + 1], m = i[u + 2], y = i[u + 3], u = (f * s + c) * 4, r[u + 0] = g, r[u + 1] = p, r[u + 2] = m, r[u + 3] = y
         };
-    const J7 = function(e) {
+    const rB = function(e) {
         var t = e.width,
             n = e.height,
-            i, r, a, s, o, l, u, c, f, h, d = Math.round(this.kaleidoscopePower()),
+            i, r, s, a, o, l, u, c, f, h, d = Math.round(this.kaleidoscopePower()),
             g = Math.round(this.kaleidoscopeAngle()),
             p = Math.floor(t * (g % 360) / 360);
         if (!(d < 1)) {
-            var m = R.createCanvasElement();
+            var m = D.createCanvasElement();
             m.width = t, m.height = n;
             var y = m.getContext("2d").getImageData(0, 0, t, n);
-            R.releaseCanvas(m), V7(e, y, {
+            D.releaseCanvas(m), nB(e, y, {
                 polarCenterX: t / 2,
                 polarCenterY: n / 2
             });
             for (var v = t / Math.pow(2, d); v <= 8;) v = v * 2, d -= 1;
             v = Math.ceil(v);
             var b = v,
                 x = 0,
                 _ = b,
                 S = 1;
             for (p + v > t && (x = b, _ = 0, S = -1), r = 0; r < n; r += 1)
-                for (i = x; i !== _; i += S) a = Math.round(i + p) % t, f = (t * r + a) * 4, o = y.data[f + 0], l = y.data[f + 1], u = y.data[f + 2], c = y.data[f + 3], h = (t * r + i) * 4, y.data[h + 0] = o, y.data[h + 1] = l, y.data[h + 2] = u, y.data[h + 3] = c;
+                for (i = x; i !== _; i += S) s = Math.round(i + p) % t, f = (t * r + s) * 4, o = y.data[f + 0], l = y.data[f + 1], u = y.data[f + 2], c = y.data[f + 3], h = (t * r + i) * 4, y.data[h + 0] = o, y.data[h + 1] = l, y.data[h + 2] = u, y.data[h + 3] = c;
             for (r = 0; r < n; r += 1)
-                for (b = Math.floor(v), s = 0; s < d; s += 1) {
+                for (b = Math.floor(v), a = 0; a < d; a += 1) {
                     for (i = 0; i < b + 1; i += 1) f = (t * r + i) * 4, o = y.data[f + 0], l = y.data[f + 1], u = y.data[f + 2], c = y.data[f + 3], h = (t * r + b * 2 - i - 1) * 4, y.data[h + 0] = o, y.data[h + 1] = l, y.data[h + 2] = u, y.data[h + 3] = c;
                     b *= 2
                 }
-            K7(y, e, {
+            iB(y, e, {
                 polarRotation: 0
             })
         }
     };
-    M.addGetterSetter(te, "kaleidoscopePower", 2, ee(), M.afterSetFilter);
-    M.addGetterSetter(te, "kaleidoscopeAngle", 0, ee(), M.afterSetFilter);
+    O.addGetterSetter(ne, "kaleidoscopePower", 2, te(), O.afterSetFilter);
+    O.addGetterSetter(ne, "kaleidoscopeAngle", 0, te(), O.afterSetFilter);
 
-    function dg(e, t, n) {
+    function Qd(e, t, n) {
         var i = (n * e.width + t) * 4,
             r = [];
         return r.push(e.data[i++], e.data[i++], e.data[i++], e.data[i++]), r
     }
 
-    function nf(e, t) {
+    function Gc(e, t) {
         return Math.sqrt(Math.pow(e[0] - t[0], 2) + Math.pow(e[1] - t[1], 2) + Math.pow(e[2] - t[2], 2))
     }
 
-    function Q7(e) {
+    function sB(e) {
         for (var t = [0, 0, 0], n = 0; n < e.length; n++) t[0] += e[n][0], t[1] += e[n][1], t[2] += e[n][2];
         return t[0] /= e.length, t[1] /= e.length, t[2] /= e.length, t
     }
 
-    function Z7(e, t) {
-        var n = dg(e, 0, 0),
-            i = dg(e, e.width - 1, 0),
-            r = dg(e, 0, e.height - 1),
-            a = dg(e, e.width - 1, e.height - 1),
-            s = t || 10;
-        if (nf(n, i) < s && nf(i, a) < s && nf(a, r) < s && nf(r, n) < s) {
-            for (var o = Q7([i, n, a, r]), l = [], u = 0; u < e.width * e.height; u++) {
-                var c = nf(o, [e.data[u * 4], e.data[u * 4 + 1], e.data[u * 4 + 2]]);
-                l[u] = c < s ? 0 : 255
+    function aB(e, t) {
+        var n = Qd(e, 0, 0),
+            i = Qd(e, e.width - 1, 0),
+            r = Qd(e, 0, e.height - 1),
+            s = Qd(e, e.width - 1, e.height - 1),
+            a = t || 10;
+        if (Gc(n, i) < a && Gc(i, s) < a && Gc(s, r) < a && Gc(r, n) < a) {
+            for (var o = sB([i, n, s, r]), l = [], u = 0; u < e.width * e.height; u++) {
+                var c = Gc(o, [e.data[u * 4], e.data[u * 4 + 1], e.data[u * 4 + 2]]);
+                l[u] = c < a ? 0 : 255
             }
             return l
         }
     }
 
-    function eB(e, t) {
+    function oB(e, t) {
         for (var n = 0; n < e.width * e.height; n++) e.data[4 * n + 3] = t[n]
     }
 
-    function tB(e, t, n) {
-        for (var i = [1, 1, 1, 1, 0, 1, 1, 1, 1], r = Math.round(Math.sqrt(i.length)), a = Math.floor(r / 2), s = [], o = 0; o < n; o++)
+    function lB(e, t, n) {
+        for (var i = [1, 1, 1, 1, 0, 1, 1, 1, 1], r = Math.round(Math.sqrt(i.length)), s = Math.floor(r / 2), a = [], o = 0; o < n; o++)
             for (var l = 0; l < t; l++) {
                 for (var u = o * t + l, c = 0, f = 0; f < r; f++)
                     for (var h = 0; h < r; h++) {
-                        var d = o + f - a,
-                            g = l + h - a;
+                        var d = o + f - s,
+                            g = l + h - s;
                         if (d >= 0 && d < n && g >= 0 && g < t) {
                             var p = d * t + g,
                                 m = i[f * r + h];
                             c += e[p] * m
                         }
                     }
-                s[u] = c === 255 * 8 ? 255 : 0
+                a[u] = c === 255 * 8 ? 255 : 0
             }
-        return s
+        return a
     }
 
-    function nB(e, t, n) {
-        for (var i = [1, 1, 1, 1, 1, 1, 1, 1, 1], r = Math.round(Math.sqrt(i.length)), a = Math.floor(r / 2), s = [], o = 0; o < n; o++)
+    function uB(e, t, n) {
+        for (var i = [1, 1, 1, 1, 1, 1, 1, 1, 1], r = Math.round(Math.sqrt(i.length)), s = Math.floor(r / 2), a = [], o = 0; o < n; o++)
             for (var l = 0; l < t; l++) {
                 for (var u = o * t + l, c = 0, f = 0; f < r; f++)
                     for (var h = 0; h < r; h++) {
-                        var d = o + f - a,
-                            g = l + h - a;
+                        var d = o + f - s,
+                            g = l + h - s;
                         if (d >= 0 && d < n && g >= 0 && g < t) {
                             var p = d * t + g,
                                 m = i[f * r + h];
                             c += e[p] * m
                         }
                     }
-                s[u] = c >= 255 * 4 ? 255 : 0
+                a[u] = c >= 255 * 4 ? 255 : 0
             }
-        return s
+        return a
     }
 
-    function iB(e, t, n) {
-        for (var i = [.1111111111111111, .1111111111111111, .1111111111111111, .1111111111111111, .1111111111111111, .1111111111111111, .1111111111111111, .1111111111111111, .1111111111111111], r = Math.round(Math.sqrt(i.length)), a = Math.floor(r / 2), s = [], o = 0; o < n; o++)
+    function cB(e, t, n) {
+        for (var i = [.1111111111111111, .1111111111111111, .1111111111111111, .1111111111111111, .1111111111111111, .1111111111111111, .1111111111111111, .1111111111111111, .1111111111111111], r = Math.round(Math.sqrt(i.length)), s = Math.floor(r / 2), a = [], o = 0; o < n; o++)
             for (var l = 0; l < t; l++) {
                 for (var u = o * t + l, c = 0, f = 0; f < r; f++)
                     for (var h = 0; h < r; h++) {
-                        var d = o + f - a,
-                            g = l + h - a;
+                        var d = o + f - s,
+                            g = l + h - s;
                         if (d >= 0 && d < n && g >= 0 && g < t) {
                             var p = d * t + g,
                                 m = i[f * r + h];
                             c += e[p] * m
                         }
                     }
-                s[u] = c
+                a[u] = c
             }
-        return s
+        return a
     }
-    const rB = function(e) {
+    const fB = function(e) {
         var t = this.threshold(),
-            n = Z7(e, t);
-        return n && (n = tB(n, e.width, e.height), n = nB(n, e.width, e.height), n = iB(n, e.width, e.height), eB(e, n)), e
+            n = aB(e, t);
+        return n && (n = lB(n, e.width, e.height), n = uB(n, e.width, e.height), n = cB(n, e.width, e.height), oB(e, n)), e
     };
-    M.addGetterSetter(te, "threshold", 0, ee(), M.afterSetFilter);
-    const aB = function(e) {
+    O.addGetterSetter(ne, "threshold", 0, te(), O.afterSetFilter);
+    const hB = function(e) {
         var t = this.noise() * 255,
             n = e.data,
             i = n.length,
             r = t / 2,
-            a;
-        for (a = 0; a < i; a += 4) n[a + 0] += r - 2 * r * Math.random(), n[a + 1] += r - 2 * r * Math.random(), n[a + 2] += r - 2 * r * Math.random()
+            s;
+        for (s = 0; s < i; s += 4) n[s + 0] += r - 2 * r * Math.random(), n[s + 1] += r - 2 * r * Math.random(), n[s + 2] += r - 2 * r * Math.random()
     };
-    M.addGetterSetter(te, "noise", .2, ee(), M.afterSetFilter);
-    const sB = function(e) {
+    O.addGetterSetter(ne, "noise", .2, te(), O.afterSetFilter);
+    const dB = function(e) {
         var t = Math.ceil(this.pixelSize()),
             n = e.width,
             i = e.height,
-            r, a, s, o, l, u, c, f = Math.ceil(n / t),
+            r, s, a, o, l, u, c, f = Math.ceil(n / t),
             h = Math.ceil(i / t),
             d, g, p, m, y, v, b, x = e.data;
         if (t <= 0) {
-            R.error("pixelSize value can not be <= 0");
+            D.error("pixelSize value can not be <= 0");
             return
         }
         for (y = 0; y < f; y += 1)
             for (v = 0; v < h; v += 1) {
                 for (o = 0, l = 0, u = 0, c = 0, d = y * t, g = d + t, p = v * t, m = p + t, b = 0, r = d; r < g; r += 1)
                     if (!(r >= n))
-                        for (a = p; a < m; a += 1) a >= i || (s = (n * a + r) * 4, o += x[s + 0], l += x[s + 1], u += x[s + 2], c += x[s + 3], b += 1);
+                        for (s = p; s < m; s += 1) s >= i || (a = (n * s + r) * 4, o += x[a + 0], l += x[a + 1], u += x[a + 2], c += x[a + 3], b += 1);
                 for (o = o / b, l = l / b, u = u / b, c = c / b, r = d; r < g; r += 1)
                     if (!(r >= n))
-                        for (a = p; a < m; a += 1) a >= i || (s = (n * a + r) * 4, x[s + 0] = o, x[s + 1] = l, x[s + 2] = u, x[s + 3] = c)
+                        for (s = p; s < m; s += 1) s >= i || (a = (n * s + r) * 4, x[a + 0] = o, x[a + 1] = l, x[a + 2] = u, x[a + 3] = c)
             }
     };
-    M.addGetterSetter(te, "pixelSize", 8, ee(), M.afterSetFilter);
-    const oB = function(e) {
+    O.addGetterSetter(ne, "pixelSize", 8, te(), O.afterSetFilter);
+    const gB = function(e) {
         var t = Math.round(this.levels() * 254) + 1,
             n = e.data,
             i = n.length,
             r = 255 / t,
-            a;
-        for (a = 0; a < i; a += 1) n[a] = Math.floor(n[a] / r) * r
+            s;
+        for (s = 0; s < i; s += 1) n[s] = Math.floor(n[s] / r) * r
     };
-    M.addGetterSetter(te, "levels", .5, ee(), M.afterSetFilter);
-    const lB = function(e) {
+    O.addGetterSetter(ne, "levels", .5, te(), O.afterSetFilter);
+    const pB = function(e) {
         var t = e.data,
             n = t.length,
             i = this.red(),
             r = this.green(),
-            a = this.blue(),
-            s, o;
-        for (s = 0; s < n; s += 4) o = (.34 * t[s] + .5 * t[s + 1] + .16 * t[s + 2]) / 255, t[s] = o * i, t[s + 1] = o * r, t[s + 2] = o * a, t[s + 3] = t[s + 3]
+            s = this.blue(),
+            a, o;
+        for (a = 0; a < n; a += 4) o = (.34 * t[a] + .5 * t[a + 1] + .16 * t[a + 2]) / 255, t[a] = o * i, t[a + 1] = o * r, t[a + 2] = o * s, t[a + 3] = t[a + 3]
     };
-    M.addGetterSetter(te, "red", 0, function(e) {
+    O.addGetterSetter(ne, "red", 0, function(e) {
         return this._filterUpToDate = !1, e > 255 ? 255 : e < 0 ? 0 : Math.round(e)
     });
-    M.addGetterSetter(te, "green", 0, function(e) {
+    O.addGetterSetter(ne, "green", 0, function(e) {
         return this._filterUpToDate = !1, e > 255 ? 255 : e < 0 ? 0 : Math.round(e)
     });
-    M.addGetterSetter(te, "blue", 0, mM, M.afterSetFilter);
-    const uB = function(e) {
+    O.addGetterSetter(ne, "blue", 0, AM, O.afterSetFilter);
+    const mB = function(e) {
         var t = e.data,
             n = t.length,
             i = this.red(),
             r = this.green(),
-            a = this.blue(),
-            s = this.alpha(),
+            s = this.blue(),
+            a = this.alpha(),
             o, l;
-        for (o = 0; o < n; o += 4) l = 1 - s, t[o] = i * s + t[o] * l, t[o + 1] = r * s + t[o + 1] * l, t[o + 2] = a * s + t[o + 2] * l
+        for (o = 0; o < n; o += 4) l = 1 - a, t[o] = i * a + t[o] * l, t[o + 1] = r * a + t[o + 1] * l, t[o + 2] = s * a + t[o + 2] * l
     };
-    M.addGetterSetter(te, "red", 0, function(e) {
+    O.addGetterSetter(ne, "red", 0, function(e) {
         return this._filterUpToDate = !1, e > 255 ? 255 : e < 0 ? 0 : Math.round(e)
     });
-    M.addGetterSetter(te, "green", 0, function(e) {
+    O.addGetterSetter(ne, "green", 0, function(e) {
         return this._filterUpToDate = !1, e > 255 ? 255 : e < 0 ? 0 : Math.round(e)
     });
-    M.addGetterSetter(te, "blue", 0, mM, M.afterSetFilter);
-    M.addGetterSetter(te, "alpha", 1, function(e) {
+    O.addGetterSetter(ne, "blue", 0, AM, O.afterSetFilter);
+    O.addGetterSetter(ne, "alpha", 1, function(e) {
         return this._filterUpToDate = !1, e > 1 ? 1 : e < 0 ? 0 : e
     });
-    const cB = function(e) {
+    const yB = function(e) {
             var t = e.data,
                 n = t.length,
-                i, r, a, s;
-            for (i = 0; i < n; i += 4) r = t[i + 0], a = t[i + 1], s = t[i + 2], t[i + 0] = Math.min(255, r * .393 + a * .769 + s * .189), t[i + 1] = Math.min(255, r * .349 + a * .686 + s * .168), t[i + 2] = Math.min(255, r * .272 + a * .534 + s * .131)
+                i, r, s, a;
+            for (i = 0; i < n; i += 4) r = t[i + 0], s = t[i + 1], a = t[i + 2], t[i + 0] = Math.min(255, r * .393 + s * .769 + a * .189), t[i + 1] = Math.min(255, r * .349 + s * .686 + a * .168), t[i + 2] = Math.min(255, r * .272 + s * .534 + a * .131)
         },
-        fB = function(e) {
+        vB = function(e) {
             var t = e.data,
                 n = e.width,
                 i = e.height,
                 r = n * 4,
-                a = i;
+                s = i;
             do {
-                var s = (a - 1) * r,
+                var a = (s - 1) * r,
                     o = n;
                 do {
-                    var l = s + (o - 1) * 4,
+                    var l = a + (o - 1) * 4,
                         u = t[l],
                         c = t[l + 1],
                         f = t[l + 2];
                     u > 127 && (u = 255 - u), c > 127 && (c = 255 - c), f > 127 && (f = 255 - f), t[l] = u, t[l + 1] = c, t[l + 2] = f
                 } while (--o)
-            } while (--a)
+            } while (--s)
         },
-        hB = function(e) {
+        bB = function(e) {
             var t = this.threshold() * 255,
                 n = e.data,
                 i = n.length,
                 r;
             for (r = 0; r < i; r += 1) n[r] = n[r] < t ? 0 : 255
         };
-    M.addGetterSetter(te, "threshold", .5, ee(), M.afterSetFilter);
-    const hn = tk.Util._assign(tk, {
-        Arc: Ja,
-        Arrow: Fl,
-        Circle: Oc,
-        Ellipse: ro,
-        Image: sa,
-        Label: t_,
-        Tag: Dl,
-        Line: Qa,
-        Path: Jt,
-        Rect: od,
-        RegularPolygon: Rl,
-        Ring: Pl,
-        Sprite: oa,
-        Star: ao,
-        Text: pt,
-        TextPath: Lt,
-        Transformer: Je,
-        Wedge: Za,
+    O.addGetterSetter(ne, "threshold", .5, te(), O.afterSetFilter);
+    const cn = pk.Util._assign(pk, {
+        Arc: Us,
+        Arrow: _l,
+        Circle: dc,
+        Ellipse: Ya,
+        Image: Qr,
+        Label: xx,
+        Tag: wl,
+        Line: Gs,
+        Path: Yt,
+        Rect: Vh,
+        RegularPolygon: Sl,
+        Ring: El,
+        Sprite: Zr,
+        Star: Xa,
+        Text: gt,
+        TextPath: Rt,
+        Transformer: Ke,
+        Wedge: Ws,
         Filters: {
-            Blur: z7,
-            Brighten: B7,
-            Contrast: G7,
-            Emboss: U7,
-            Enhance: q7,
-            Grayscale: W7,
-            HSL: H7,
-            HSV: Y7,
-            Invert: X7,
-            Kaleidoscope: J7,
-            Mask: rB,
-            Noise: aB,
-            Pixelate: sB,
-            Posterize: oB,
-            RGB: lB,
-            RGBA: uB,
-            Sepia: cB,
-            Solarize: fB,
-            Threshold: hB
+            Blur: Y7,
+            Brighten: X7,
+            Contrast: V7,
+            Emboss: K7,
+            Enhance: J7,
+            Grayscale: Q7,
+            HSL: Z7,
+            HSV: eB,
+            Invert: tB,
+            Kaleidoscope: rB,
+            Mask: fB,
+            Noise: hB,
+            Pixelate: dB,
+            Posterize: gB,
+            RGB: pB,
+            RGBA: mB,
+            Sepia: yB,
+            Solarize: vB,
+            Threshold: bB
         }
     });
     /**
     @copyright CEA-LIST/DIASI/SIALV/LVA (2023)
     @author CEA-LIST/DIASI/SIALV/LVA <pixano@cea.fr>
     @license CECILL-C
 
@@ -7033,167 +7033,167 @@
     This software is governed by the CeCILL-C license under French law and
     abiding by the rules of distribution of free software. You can use, 
     modify and/ or redistribute the software under the terms of the CeCILL-C
     license as circulated by CEA, CNRS and INRIA at the following URL
 
     http://www.cecill.info
     */
-    function dB(e, t, n) {
+    function xB(e, t, n) {
         return {
             x: e.x * t.width + n.x,
             y: e.y * t.height + n.y,
             width: e.width * t.width,
             height: e.height * t.height
         }
     }
 
-    function gB(e, t, n) {
-        const i = (r, a) => a % 2 == 0 ? r * t.width + n.x : r * t.height + n.y;
+    function _B(e, t, n) {
+        const i = (r, s) => s % 2 == 0 ? r * t.width + n.x : r * t.height + n.y;
         for (let r = 0; r < e.length; ++r) {
-            let a = e[r];
-            for (let s = 0; s < a.length; ++s) a[s] = i(a[s], s)
+            let s = e[r];
+            for (let a = 0; a < s.length; ++a) s[a] = i(s[a], a)
         }
         return e
     }
 
-    function pB(e) {
+    function wB(e) {
         e.clear(), e.children.forEach(t => t.destroyChildren())
     }
 
-    function mB(e, t, n, i, r = "black", a = !0) {
-        const s = new hn.Label({
+    function SB(e, t, n, i, r = "black", s = !0) {
+        const a = new cn.Label({
             id: e,
             x: i.x,
             y: i.y,
-            visible: a
+            visible: s
         });
-        s.add(new hn.Tag({
+        a.add(new cn.Tag({
             fill: r,
             stroke: r
-        })), s.add(new hn.Text({
+        })), a.add(new cn.Text({
             text: n,
             fontSize: 10,
             fontStyle: "bold",
             padding: 2,
             x: i.x,
             y: i.y
-        })), t.add(s)
+        })), t.add(a)
     }
 
-    function yB(e = "", t, n, i = "black", r = !1, a = !0) {
-        const s = new hn.Rect({
+    function EB(e = "", t, n, i = "black", r = !1, s = !0) {
+        const a = new cn.Rect({
             x: n.x,
             y: n.y,
             id: e,
             width: n.width,
             height: n.height,
             stroke: i,
             strokeWidth: 3,
-            visible: a,
+            visible: s,
             dash: r ? [10, 10] : []
         });
-        t.add(s)
+        t.add(a)
     }
 
-    function vB(e = "", t, n, i = "black", r = !0, a = .5) {
-        let s = new hn.Group({
+    function CB(e = "", t, n, i = "black", r = !0, s = .5) {
+        let a = new cn.Group({
             id: e,
-            opacity: a,
+            opacity: s,
             visible: r
         });
         n.forEach(o => {
-            const l = new hn.Line({
+            const l = new cn.Line({
                 points: o,
                 fill: i,
                 closed: !0
             });
-            s.add(l)
-        }), t.add(s)
+            a.add(l)
+        }), t.add(a)
     }
 
-    function bB(e, t, n, i) {
-        const r = new hn.Image({
+    function kB(e, t, n, i) {
+        const r = new cn.Image({
             image: t,
             x: n.x,
             y: n.y,
             scaleX: i,
             scaleY: i
         });
         e.add(r)
     }
 
-    function xB(e, t, n) {
-        const i = new hn.Label({
+    function AB(e, t, n) {
+        const i = new cn.Label({
             x: n.x + 5,
             y: n.y + 5
         });
-        i.add(new hn.Tag({
+        i.add(new cn.Tag({
             fill: "black",
             cornerRadius: 5
-        })), i.add(new hn.Text({
+        })), i.add(new cn.Text({
             text: t,
             fontSize: 15,
             fontStyle: "bold",
             padding: 5,
             fill: "white"
         })), e.add(i)
     }
 
-    function _B(e, t) {
+    function $B(e, t) {
         e == null || e.children.forEach(n => n.opacity(t))
     }
 
-    function wB(e, t) {
+    function TB(e, t) {
         const i = e.scaleX(),
             r = e.getPointerPosition(),
-            a = {
+            s = {
                 x: (r.x - e.x()) / i,
                 y: (r.y - e.y()) / i
             },
-            s = t > 0 ? i * 1.05 : i / 1.05,
+            a = t > 0 ? i * 1.05 : i / 1.05,
             o = {
-                x: r.x - a.x * s,
-                y: r.y - a.y * s
+                x: r.x - s.x * a,
+                y: r.y - s.y * a
             };
         e.scale({
-            x: s,
-            y: s
+            x: a,
+            y: a
         }), e.position(o)
     }
 
-    function SB(e) {
+    function MB(e) {
         for (var t = e.length / 6 | 0, n = new Array(t), i = 0; i < t;) n[i] = "#" + e.slice(i * 6, ++i * 6);
         return n
     }
-    const EB = SB("8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9bc80bdccebc5ffed6f");
+    const OB = MB("8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9bc80bdccebc5ffed6f");
 
-    function Cc(e, t, n) {
+    function gc(e, t, n) {
         e.prototype = t.prototype = n, n.constructor = e
     }
 
-    function ld(e, t) {
+    function Kh(e, t) {
         var n = Object.create(e.prototype);
         for (var i in t) n[i] = t[i];
         return n
     }
 
-    function so() {}
-    var ll = .7,
-        Gu = 1 / ll,
-        $u = "\\s*([+-]?\\d+)\\s*",
-        Ch = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*",
-        qr = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*",
-        OB = /^#([0-9a-f]{3,8})$/,
-        CB = new RegExp(`^rgb\\(${$u},${$u},${$u}\\)$`),
-        kB = new RegExp(`^rgb\\(${qr},${qr},${qr}\\)$`),
-        AB = new RegExp(`^rgba\\(${$u},${$u},${$u},${Ch}\\)$`),
-        TB = new RegExp(`^rgba\\(${qr},${qr},${qr},${Ch}\\)$`),
-        $B = new RegExp(`^hsl\\(${Ch},${qr},${qr}\\)$`),
-        MB = new RegExp(`^hsla\\(${Ch},${qr},${qr},${Ch}\\)$`),
-        ck = {
+    function Va() {}
+    var Ko = .7,
+        Ou = 1 / Ko,
+        bu = "\\s*([+-]?\\d+)\\s*",
+        gh = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*",
+        Lr = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*",
+        FB = /^#([0-9a-f]{3,8})$/,
+        RB = new RegExp(`^rgb\\(${bu},${bu},${bu}\\)$`),
+        DB = new RegExp(`^rgb\\(${Lr},${Lr},${Lr}\\)$`),
+        NB = new RegExp(`^rgba\\(${bu},${bu},${bu},${gh}\\)$`),
+        PB = new RegExp(`^rgba\\(${Lr},${Lr},${Lr},${gh}\\)$`),
+        LB = new RegExp(`^hsl\\(${gh},${Lr},${Lr}\\)$`),
+        IB = new RegExp(`^hsla\\(${gh},${Lr},${Lr},${gh}\\)$`),
+        Ek = {
             aliceblue: 15792383,
             antiquewhite: 16444375,
             aqua: 65535,
             aquamarine: 8388564,
             azure: 15794175,
             beige: 16119260,
             bisque: 16770244,
@@ -7335,1706 +7335,1706 @@
             violet: 15631086,
             wheat: 16113331,
             white: 16777215,
             whitesmoke: 16119285,
             yellow: 16776960,
             yellowgreen: 10145074
         };
-    Cc(so, kh, {
+    gc(Va, ph, {
         copy(e) {
             return Object.assign(new this.constructor, this, e)
         },
         displayable() {
             return this.rgb().displayable()
         },
-        hex: fk,
-        formatHex: fk,
-        formatHex8: FB,
-        formatHsl: DB,
-        formatRgb: hk,
-        toString: hk
+        hex: Ck,
+        formatHex: Ck,
+        formatHex8: zB,
+        formatHsl: BB,
+        formatRgb: kk,
+        toString: kk
     });
 
-    function fk() {
+    function Ck() {
         return this.rgb().formatHex()
     }
 
-    function FB() {
+    function zB() {
         return this.rgb().formatHex8()
     }
 
-    function DB() {
-        return XM(this).formatHsl()
+    function BB() {
+        return sO(this).formatHsl()
     }
 
-    function hk() {
+    function kk() {
         return this.rgb().formatRgb()
     }
 
-    function kh(e) {
+    function ph(e) {
         var t, n;
-        return e = (e + "").trim().toLowerCase(), (t = OB.exec(e)) ? (n = t[1].length, t = parseInt(t[1], 16), n === 6 ? dk(t) : n === 3 ? new Gt(t >> 8 & 15 | t >> 4 & 240, t >> 4 & 15 | t & 240, (t & 15) << 4 | t & 15, 1) : n === 8 ? gg(t >> 24 & 255, t >> 16 & 255, t >> 8 & 255, (t & 255) / 255) : n === 4 ? gg(t >> 12 & 15 | t >> 8 & 240, t >> 8 & 15 | t >> 4 & 240, t >> 4 & 15 | t & 240, ((t & 15) << 4 | t & 15) / 255) : null) : (t = CB.exec(e)) ? new Gt(t[1], t[2], t[3], 1) : (t = kB.exec(e)) ? new Gt(t[1] * 255 / 100, t[2] * 255 / 100, t[3] * 255 / 100, 1) : (t = AB.exec(e)) ? gg(t[1], t[2], t[3], t[4]) : (t = TB.exec(e)) ? gg(t[1] * 255 / 100, t[2] * 255 / 100, t[3] * 255 / 100, t[4]) : (t = $B.exec(e)) ? mk(t[1], t[2] / 100, t[3] / 100, 1) : (t = MB.exec(e)) ? mk(t[1], t[2] / 100, t[3] / 100, t[4]) : ck.hasOwnProperty(e) ? dk(ck[e]) : e === "transparent" ? new Gt(NaN, NaN, NaN, 0) : null
+        return e = (e + "").trim().toLowerCase(), (t = FB.exec(e)) ? (n = t[1].length, t = parseInt(t[1], 16), n === 6 ? Ak(t) : n === 3 ? new It(t >> 8 & 15 | t >> 4 & 240, t >> 4 & 15 | t & 240, (t & 15) << 4 | t & 15, 1) : n === 8 ? Zd(t >> 24 & 255, t >> 16 & 255, t >> 8 & 255, (t & 255) / 255) : n === 4 ? Zd(t >> 12 & 15 | t >> 8 & 240, t >> 8 & 15 | t >> 4 & 240, t >> 4 & 15 | t & 240, ((t & 15) << 4 | t & 15) / 255) : null) : (t = RB.exec(e)) ? new It(t[1], t[2], t[3], 1) : (t = DB.exec(e)) ? new It(t[1] * 255 / 100, t[2] * 255 / 100, t[3] * 255 / 100, 1) : (t = NB.exec(e)) ? Zd(t[1], t[2], t[3], t[4]) : (t = PB.exec(e)) ? Zd(t[1] * 255 / 100, t[2] * 255 / 100, t[3] * 255 / 100, t[4]) : (t = LB.exec(e)) ? Mk(t[1], t[2] / 100, t[3] / 100, 1) : (t = IB.exec(e)) ? Mk(t[1], t[2] / 100, t[3] / 100, t[4]) : Ek.hasOwnProperty(e) ? Ak(Ek[e]) : e === "transparent" ? new It(NaN, NaN, NaN, 0) : null
     }
 
-    function dk(e) {
-        return new Gt(e >> 16 & 255, e >> 8 & 255, e & 255, 1)
+    function Ak(e) {
+        return new It(e >> 16 & 255, e >> 8 & 255, e & 255, 1)
     }
 
-    function gg(e, t, n, i) {
-        return i <= 0 && (e = t = n = NaN), new Gt(e, t, n, i)
+    function Zd(e, t, n, i) {
+        return i <= 0 && (e = t = n = NaN), new It(e, t, n, i)
     }
 
-    function n_(e) {
-        return e instanceof so || (e = kh(e)), e ? (e = e.rgb(), new Gt(e.r, e.g, e.b, e.opacity)) : new Gt
+    function _x(e) {
+        return e instanceof Va || (e = ph(e)), e ? (e = e.rgb(), new It(e.r, e.g, e.b, e.opacity)) : new It
     }
 
-    function zs(e, t, n, i) {
-        return arguments.length === 1 ? n_(e) : new Gt(e, t, n, i ?? 1)
+    function Ma(e, t, n, i) {
+        return arguments.length === 1 ? _x(e) : new It(e, t, n, i ?? 1)
     }
 
-    function Gt(e, t, n, i) {
+    function It(e, t, n, i) {
         this.r = +e, this.g = +t, this.b = +n, this.opacity = +i
     }
-    Cc(Gt, zs, ld(so, {
+    gc(It, Ma, Kh(Va, {
         brighter(e) {
-            return e = e == null ? Gu : Math.pow(Gu, e), new Gt(this.r * e, this.g * e, this.b * e, this.opacity)
+            return e = e == null ? Ou : Math.pow(Ou, e), new It(this.r * e, this.g * e, this.b * e, this.opacity)
         },
         darker(e) {
-            return e = e == null ? ll : Math.pow(ll, e), new Gt(this.r * e, this.g * e, this.b * e, this.opacity)
+            return e = e == null ? Ko : Math.pow(Ko, e), new It(this.r * e, this.g * e, this.b * e, this.opacity)
         },
         rgb() {
             return this
         },
         clamp() {
-            return new Gt(Qo(this.r), Qo(this.g), Qo(this.b), Np(this.opacity))
+            return new It(zo(this.r), zo(this.g), zo(this.b), yp(this.opacity))
         },
         displayable() {
             return -.5 <= this.r && this.r < 255.5 && -.5 <= this.g && this.g < 255.5 && -.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1
         },
-        hex: gk,
-        formatHex: gk,
-        formatHex8: RB,
-        formatRgb: pk,
-        toString: pk
+        hex: $k,
+        formatHex: $k,
+        formatHex8: jB,
+        formatRgb: Tk,
+        toString: Tk
     }));
 
-    function gk() {
-        return `#${Ho(this.r)}${Ho(this.g)}${Ho(this.b)}`
+    function $k() {
+        return `#${Do(this.r)}${Do(this.g)}${Do(this.b)}`
     }
 
-    function RB() {
-        return `#${Ho(this.r)}${Ho(this.g)}${Ho(this.b)}${Ho((isNaN(this.opacity)?1:this.opacity)*255)}`
+    function jB() {
+        return `#${Do(this.r)}${Do(this.g)}${Do(this.b)}${Do((isNaN(this.opacity)?1:this.opacity)*255)}`
     }
 
-    function pk() {
-        const e = Np(this.opacity);
-        return `${e===1?"rgb(":"rgba("}${Qo(this.r)}, ${Qo(this.g)}, ${Qo(this.b)}${e===1?")":`, ${e})`}`
+    function Tk() {
+        const e = yp(this.opacity);
+        return `${e===1?"rgb(":"rgba("}${zo(this.r)}, ${zo(this.g)}, ${zo(this.b)}${e===1?")":`, ${e})`}`
     }
 
-    function Np(e) {
+    function yp(e) {
         return isNaN(e) ? 1 : Math.max(0, Math.min(1, e))
     }
 
-    function Qo(e) {
+    function zo(e) {
         return Math.max(0, Math.min(255, Math.round(e) || 0))
     }
 
-    function Ho(e) {
-        return e = Qo(e), (e < 16 ? "0" : "") + e.toString(16)
+    function Do(e) {
+        return e = zo(e), (e < 16 ? "0" : "") + e.toString(16)
     }
 
-    function mk(e, t, n, i) {
-        return i <= 0 ? e = t = n = NaN : n <= 0 || n >= 1 ? e = t = NaN : t <= 0 && (e = NaN), new rr(e, t, n, i)
+    function Mk(e, t, n, i) {
+        return i <= 0 ? e = t = n = NaN : n <= 0 || n >= 1 ? e = t = NaN : t <= 0 && (e = NaN), new Ji(e, t, n, i)
     }
 
-    function XM(e) {
-        if (e instanceof rr) return new rr(e.h, e.s, e.l, e.opacity);
-        if (e instanceof so || (e = kh(e)), !e) return new rr;
-        if (e instanceof rr) return e;
+    function sO(e) {
+        if (e instanceof Ji) return new Ji(e.h, e.s, e.l, e.opacity);
+        if (e instanceof Va || (e = ph(e)), !e) return new Ji;
+        if (e instanceof Ji) return e;
         e = e.rgb();
         var t = e.r / 255,
             n = e.g / 255,
             i = e.b / 255,
             r = Math.min(t, n, i),
-            a = Math.max(t, n, i),
-            s = NaN,
-            o = a - r,
-            l = (a + r) / 2;
-        return o ? (t === a ? s = (n - i) / o + (n < i) * 6 : n === a ? s = (i - t) / o + 2 : s = (t - n) / o + 4, o /= l < .5 ? a + r : 2 - a - r, s *= 60) : o = l > 0 && l < 1 ? 0 : s, new rr(s, o, l, e.opacity)
+            s = Math.max(t, n, i),
+            a = NaN,
+            o = s - r,
+            l = (s + r) / 2;
+        return o ? (t === s ? a = (n - i) / o + (n < i) * 6 : n === s ? a = (i - t) / o + 2 : a = (t - n) / o + 4, o /= l < .5 ? s + r : 2 - s - r, a *= 60) : o = l > 0 && l < 1 ? 0 : a, new Ji(a, o, l, e.opacity)
     }
 
-    function Lp(e, t, n, i) {
-        return arguments.length === 1 ? XM(e) : new rr(e, t, n, i ?? 1)
+    function vp(e, t, n, i) {
+        return arguments.length === 1 ? sO(e) : new Ji(e, t, n, i ?? 1)
     }
 
-    function rr(e, t, n, i) {
+    function Ji(e, t, n, i) {
         this.h = +e, this.s = +t, this.l = +n, this.opacity = +i
     }
-    Cc(rr, Lp, ld(so, {
+    gc(Ji, vp, Kh(Va, {
         brighter(e) {
-            return e = e == null ? Gu : Math.pow(Gu, e), new rr(this.h, this.s, this.l * e, this.opacity)
+            return e = e == null ? Ou : Math.pow(Ou, e), new Ji(this.h, this.s, this.l * e, this.opacity)
         },
         darker(e) {
-            return e = e == null ? ll : Math.pow(ll, e), new rr(this.h, this.s, this.l * e, this.opacity)
+            return e = e == null ? Ko : Math.pow(Ko, e), new Ji(this.h, this.s, this.l * e, this.opacity)
         },
         rgb() {
             var e = this.h % 360 + (this.h < 0) * 360,
                 t = isNaN(e) || isNaN(this.s) ? 0 : this.s,
                 n = this.l,
                 i = n + (n < .5 ? n : 1 - n) * t,
                 r = 2 * n - i;
-            return new Gt(zy(e >= 240 ? e - 240 : e + 120, r, i), zy(e, r, i), zy(e < 120 ? e + 240 : e - 120, r, i), this.opacity)
+            return new It(vy(e >= 240 ? e - 240 : e + 120, r, i), vy(e, r, i), vy(e < 120 ? e + 240 : e - 120, r, i), this.opacity)
         },
         clamp() {
-            return new rr(yk(this.h), pg(this.s), pg(this.l), Np(this.opacity))
+            return new Ji(Ok(this.h), eg(this.s), eg(this.l), yp(this.opacity))
         },
         displayable() {
             return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1
         },
         formatHsl() {
-            const e = Np(this.opacity);
-            return `${e===1?"hsl(":"hsla("}${yk(this.h)}, ${pg(this.s)*100}%, ${pg(this.l)*100}%${e===1?")":`, ${e})`}`
+            const e = yp(this.opacity);
+            return `${e===1?"hsl(":"hsla("}${Ok(this.h)}, ${eg(this.s)*100}%, ${eg(this.l)*100}%${e===1?")":`, ${e})`}`
         }
     }));
 
-    function yk(e) {
+    function Ok(e) {
         return e = (e || 0) % 360, e < 0 ? e + 360 : e
     }
 
-    function pg(e) {
+    function eg(e) {
         return Math.max(0, Math.min(1, e || 0))
     }
 
-    function zy(e, t, n) {
+    function vy(e, t, n) {
         return (e < 60 ? t + (n - t) * e / 60 : e < 180 ? n : e < 240 ? t + (n - t) * (240 - e) / 60 : t) * 255
     }
-    const VM = Math.PI / 180,
-        KM = 180 / Math.PI,
-        Ip = 18,
-        JM = .96422,
-        QM = 1,
-        ZM = .82521,
-        eF = 4 / 29,
-        Mu = 6 / 29,
-        tF = 3 * Mu * Mu,
-        PB = Mu * Mu * Mu;
-
-    function nF(e) {
-        if (e instanceof Wr) return new Wr(e.l, e.a, e.b, e.opacity);
-        if (e instanceof Da) return iF(e);
-        e instanceof Gt || (e = n_(e));
-        var t = qy(e.r),
-            n = qy(e.g),
-            i = qy(e.b),
-            r = By((.2225045 * t + .7168786 * n + .0606169 * i) / QM),
-            a, s;
-        return t === n && n === i ? a = s = r : (a = By((.4360747 * t + .3850649 * n + .1430804 * i) / JM), s = By((.0139322 * t + .0971045 * n + .7141733 * i) / ZM)), new Wr(116 * r - 16, 500 * (a - r), 200 * (r - s), e.opacity)
+    const aO = Math.PI / 180,
+        oO = 180 / Math.PI,
+        bp = 18,
+        lO = .96422,
+        uO = 1,
+        cO = .82521,
+        fO = 4 / 29,
+        xu = 6 / 29,
+        hO = 3 * xu * xu,
+        UB = xu * xu * xu;
+
+    function dO(e) {
+        if (e instanceof Ir) return new Ir(e.l, e.a, e.b, e.opacity);
+        if (e instanceof Ss) return gO(e);
+        e instanceof It || (e = _x(e));
+        var t = wy(e.r),
+            n = wy(e.g),
+            i = wy(e.b),
+            r = by((.2225045 * t + .7168786 * n + .0606169 * i) / uO),
+            s, a;
+        return t === n && n === i ? s = a = r : (s = by((.4360747 * t + .3850649 * n + .1430804 * i) / lO), a = by((.0139322 * t + .0971045 * n + .7141733 * i) / cO)), new Ir(116 * r - 16, 500 * (s - r), 200 * (r - a), e.opacity)
     }
 
-    function jp(e, t, n, i) {
-        return arguments.length === 1 ? nF(e) : new Wr(e, t, n, i ?? 1)
+    function xp(e, t, n, i) {
+        return arguments.length === 1 ? dO(e) : new Ir(e, t, n, i ?? 1)
     }
 
-    function Wr(e, t, n, i) {
+    function Ir(e, t, n, i) {
         this.l = +e, this.a = +t, this.b = +n, this.opacity = +i
     }
-    Cc(Wr, jp, ld(so, {
+    gc(Ir, xp, Kh(Va, {
         brighter(e) {
-            return new Wr(this.l + Ip * (e ?? 1), this.a, this.b, this.opacity)
+            return new Ir(this.l + bp * (e ?? 1), this.a, this.b, this.opacity)
         },
         darker(e) {
-            return new Wr(this.l - Ip * (e ?? 1), this.a, this.b, this.opacity)
+            return new Ir(this.l - bp * (e ?? 1), this.a, this.b, this.opacity)
         },
         rgb() {
             var e = (this.l + 16) / 116,
                 t = isNaN(this.a) ? e : e + this.a / 500,
                 n = isNaN(this.b) ? e : e - this.b / 200;
-            return t = JM * Gy(t), e = QM * Gy(e), n = ZM * Gy(n), new Gt(Uy(3.1338561 * t - 1.6168667 * e - .4906146 * n), Uy(-.9787684 * t + 1.9161415 * e + .033454 * n), Uy(.0719453 * t - .2289914 * e + 1.4052427 * n), this.opacity)
+            return t = lO * xy(t), e = uO * xy(e), n = cO * xy(n), new It(_y(3.1338561 * t - 1.6168667 * e - .4906146 * n), _y(-.9787684 * t + 1.9161415 * e + .033454 * n), _y(.0719453 * t - .2289914 * e + 1.4052427 * n), this.opacity)
         }
     }));
 
-    function By(e) {
-        return e > PB ? Math.pow(e, 1 / 3) : e / tF + eF
+    function by(e) {
+        return e > UB ? Math.pow(e, 1 / 3) : e / hO + fO
     }
 
-    function Gy(e) {
-        return e > Mu ? e * e * e : tF * (e - eF)
+    function xy(e) {
+        return e > xu ? e * e * e : hO * (e - fO)
     }
 
-    function Uy(e) {
+    function _y(e) {
         return 255 * (e <= .0031308 ? 12.92 * e : 1.055 * Math.pow(e, 1 / 2.4) - .055)
     }
 
-    function qy(e) {
+    function wy(e) {
         return (e /= 255) <= .04045 ? e / 12.92 : Math.pow((e + .055) / 1.055, 2.4)
     }
 
-    function NB(e) {
-        if (e instanceof Da) return new Da(e.h, e.c, e.l, e.opacity);
-        if (e instanceof Wr || (e = nF(e)), e.a === 0 && e.b === 0) return new Da(NaN, 0 < e.l && e.l < 100 ? 0 : NaN, e.l, e.opacity);
-        var t = Math.atan2(e.b, e.a) * KM;
-        return new Da(t < 0 ? t + 360 : t, Math.sqrt(e.a * e.a + e.b * e.b), e.l, e.opacity)
+    function GB(e) {
+        if (e instanceof Ss) return new Ss(e.h, e.c, e.l, e.opacity);
+        if (e instanceof Ir || (e = dO(e)), e.a === 0 && e.b === 0) return new Ss(NaN, 0 < e.l && e.l < 100 ? 0 : NaN, e.l, e.opacity);
+        var t = Math.atan2(e.b, e.a) * oO;
+        return new Ss(t < 0 ? t + 360 : t, Math.sqrt(e.a * e.a + e.b * e.b), e.l, e.opacity)
     }
 
-    function zp(e, t, n, i) {
-        return arguments.length === 1 ? NB(e) : new Da(e, t, n, i ?? 1)
+    function _p(e, t, n, i) {
+        return arguments.length === 1 ? GB(e) : new Ss(e, t, n, i ?? 1)
     }
 
-    function Da(e, t, n, i) {
+    function Ss(e, t, n, i) {
         this.h = +e, this.c = +t, this.l = +n, this.opacity = +i
     }
 
-    function iF(e) {
-        if (isNaN(e.h)) return new Wr(e.l, 0, 0, e.opacity);
-        var t = e.h * VM;
-        return new Wr(e.l, Math.cos(t) * e.c, Math.sin(t) * e.c, e.opacity)
+    function gO(e) {
+        if (isNaN(e.h)) return new Ir(e.l, 0, 0, e.opacity);
+        var t = e.h * aO;
+        return new Ir(e.l, Math.cos(t) * e.c, Math.sin(t) * e.c, e.opacity)
     }
-    Cc(Da, zp, ld(so, {
+    gc(Ss, _p, Kh(Va, {
         brighter(e) {
-            return new Da(this.h, this.c, this.l + Ip * (e ?? 1), this.opacity)
+            return new Ss(this.h, this.c, this.l + bp * (e ?? 1), this.opacity)
         },
         darker(e) {
-            return new Da(this.h, this.c, this.l - Ip * (e ?? 1), this.opacity)
+            return new Ss(this.h, this.c, this.l - bp * (e ?? 1), this.opacity)
         },
         rgb() {
-            return iF(this).rgb()
+            return gO(this).rgb()
         }
     }));
-    var rF = -.14861,
-        i_ = 1.78277,
-        r_ = -.29227,
-        Sm = -.90649,
-        Ah = 1.97294,
-        vk = Ah * Sm,
-        bk = Ah * i_,
-        xk = i_ * r_ - Sm * rF;
-
-    function LB(e) {
-        if (e instanceof Zo) return new Zo(e.h, e.s, e.l, e.opacity);
-        e instanceof Gt || (e = n_(e));
+    var pO = -.14861,
+        wx = 1.78277,
+        Sx = -.29227,
+        im = -.90649,
+        mh = 1.97294,
+        Fk = mh * im,
+        Rk = mh * wx,
+        Dk = wx * Sx - im * pO;
+
+    function WB(e) {
+        if (e instanceof Bo) return new Bo(e.h, e.s, e.l, e.opacity);
+        e instanceof It || (e = _x(e));
         var t = e.r / 255,
             n = e.g / 255,
             i = e.b / 255,
-            r = (xk * i + vk * t - bk * n) / (xk + vk - bk),
-            a = i - r,
-            s = (Ah * (n - r) - r_ * a) / Sm,
-            o = Math.sqrt(s * s + a * a) / (Ah * r * (1 - r)),
-            l = o ? Math.atan2(s, a) * KM - 120 : NaN;
-        return new Zo(l < 0 ? l + 360 : l, o, r, e.opacity)
+            r = (Dk * i + Fk * t - Rk * n) / (Dk + Fk - Rk),
+            s = i - r,
+            a = (mh * (n - r) - Sx * s) / im,
+            o = Math.sqrt(a * a + s * s) / (mh * r * (1 - r)),
+            l = o ? Math.atan2(a, s) * oO - 120 : NaN;
+        return new Bo(l < 0 ? l + 360 : l, o, r, e.opacity)
     }
 
-    function Tb(e, t, n, i) {
-        return arguments.length === 1 ? LB(e) : new Zo(e, t, n, i ?? 1)
+    function ib(e, t, n, i) {
+        return arguments.length === 1 ? WB(e) : new Bo(e, t, n, i ?? 1)
     }
 
-    function Zo(e, t, n, i) {
+    function Bo(e, t, n, i) {
         this.h = +e, this.s = +t, this.l = +n, this.opacity = +i
     }
-    Cc(Zo, Tb, ld(so, {
+    gc(Bo, ib, Kh(Va, {
         brighter(e) {
-            return e = e == null ? Gu : Math.pow(Gu, e), new Zo(this.h, this.s, this.l * e, this.opacity)
+            return e = e == null ? Ou : Math.pow(Ou, e), new Bo(this.h, this.s, this.l * e, this.opacity)
         },
         darker(e) {
-            return e = e == null ? ll : Math.pow(ll, e), new Zo(this.h, this.s, this.l * e, this.opacity)
+            return e = e == null ? Ko : Math.pow(Ko, e), new Bo(this.h, this.s, this.l * e, this.opacity)
         },
         rgb() {
-            var e = isNaN(this.h) ? 0 : (this.h + 120) * VM,
+            var e = isNaN(this.h) ? 0 : (this.h + 120) * aO,
                 t = +this.l,
                 n = isNaN(this.s) ? 0 : this.s * t * (1 - t),
                 i = Math.cos(e),
                 r = Math.sin(e);
-            return new Gt(255 * (t + n * (rF * i + i_ * r)), 255 * (t + n * (r_ * i + Sm * r)), 255 * (t + n * (Ah * i)), this.opacity)
+            return new It(255 * (t + n * (pO * i + wx * r)), 255 * (t + n * (Sx * i + im * r)), 255 * (t + n * (mh * i)), this.opacity)
         }
     }));
 
-    function aF(e, t, n, i, r) {
-        var a = e * e,
-            s = a * e;
-        return ((1 - 3 * e + 3 * a - s) * t + (4 - 6 * a + 3 * s) * n + (1 + 3 * e + 3 * a - 3 * s) * i + s * r) / 6
+    function mO(e, t, n, i, r) {
+        var s = e * e,
+            a = s * e;
+        return ((1 - 3 * e + 3 * s - a) * t + (4 - 6 * s + 3 * a) * n + (1 + 3 * e + 3 * s - 3 * a) * i + a * r) / 6
     }
 
-    function sF(e) {
+    function yO(e) {
         var t = e.length - 1;
         return function(n) {
             var i = n <= 0 ? n = 0 : n >= 1 ? (n = 1, t - 1) : Math.floor(n * t),
                 r = e[i],
-                a = e[i + 1],
-                s = i > 0 ? e[i - 1] : 2 * r - a,
-                o = i < t - 1 ? e[i + 2] : 2 * a - r;
-            return aF((n - i / t) * t, s, r, a, o)
+                s = e[i + 1],
+                a = i > 0 ? e[i - 1] : 2 * r - s,
+                o = i < t - 1 ? e[i + 2] : 2 * s - r;
+            return mO((n - i / t) * t, a, r, s, o)
         }
     }
 
-    function oF(e) {
+    function vO(e) {
         var t = e.length;
         return function(n) {
             var i = Math.floor(((n %= 1) < 0 ? ++n : n) * t),
                 r = e[(i + t - 1) % t],
-                a = e[i % t],
-                s = e[(i + 1) % t],
+                s = e[i % t],
+                a = e[(i + 1) % t],
                 o = e[(i + 2) % t];
-            return aF((n - i / t) * t, r, a, s, o)
+            return mO((n - i / t) * t, r, s, a, o)
         }
     }
-    const Em = e => () => e;
+    const rm = e => () => e;
 
-    function lF(e, t) {
+    function bO(e, t) {
         return function(n) {
             return e + n * t
         }
     }
 
-    function IB(e, t, n) {
+    function qB(e, t, n) {
         return e = Math.pow(e, n), t = Math.pow(t, n) - e, n = 1 / n,
             function(i) {
                 return Math.pow(e + i * t, n)
             }
     }
 
-    function Om(e, t) {
+    function sm(e, t) {
         var n = t - e;
-        return n ? lF(e, n > 180 || n < -180 ? n - 360 * Math.round(n / 360) : n) : Em(isNaN(e) ? t : e)
+        return n ? bO(e, n > 180 || n < -180 ? n - 360 * Math.round(n / 360) : n) : rm(isNaN(e) ? t : e)
     }
 
-    function jB(e) {
-        return (e = +e) == 1 ? Ut : function(t, n) {
-            return n - t ? IB(t, n, e) : Em(isNaN(t) ? n : t)
+    function HB(e) {
+        return (e = +e) == 1 ? zt : function(t, n) {
+            return n - t ? qB(t, n, e) : rm(isNaN(t) ? n : t)
         }
     }
 
-    function Ut(e, t) {
+    function zt(e, t) {
         var n = t - e;
-        return n ? lF(e, n) : Em(isNaN(e) ? t : e)
+        return n ? bO(e, n) : rm(isNaN(e) ? t : e)
     }
-    const $b = function e(t) {
-        var n = jB(t);
+    const rb = function e(t) {
+        var n = HB(t);
 
-        function i(r, a) {
-            var s = n((r = zs(r)).r, (a = zs(a)).r),
-                o = n(r.g, a.g),
-                l = n(r.b, a.b),
-                u = Ut(r.opacity, a.opacity);
+        function i(r, s) {
+            var a = n((r = Ma(r)).r, (s = Ma(s)).r),
+                o = n(r.g, s.g),
+                l = n(r.b, s.b),
+                u = zt(r.opacity, s.opacity);
             return function(c) {
-                return r.r = s(c), r.g = o(c), r.b = l(c), r.opacity = u(c), r + ""
+                return r.r = a(c), r.g = o(c), r.b = l(c), r.opacity = u(c), r + ""
             }
         }
         return i.gamma = e, i
     }(1);
 
-    function uF(e) {
+    function xO(e) {
         return function(t) {
             var n = t.length,
                 i = new Array(n),
                 r = new Array(n),
-                a = new Array(n),
-                s, o;
-            for (s = 0; s < n; ++s) o = zs(t[s]), i[s] = o.r || 0, r[s] = o.g || 0, a[s] = o.b || 0;
-            return i = e(i), r = e(r), a = e(a), o.opacity = 1,
+                s = new Array(n),
+                a, o;
+            for (a = 0; a < n; ++a) o = Ma(t[a]), i[a] = o.r || 0, r[a] = o.g || 0, s[a] = o.b || 0;
+            return i = e(i), r = e(r), s = e(s), o.opacity = 1,
                 function(l) {
-                    return o.r = i(l), o.g = r(l), o.b = a(l), o + ""
+                    return o.r = i(l), o.g = r(l), o.b = s(l), o + ""
                 }
         }
     }
-    var zB = uF(sF),
-        BB = uF(oF);
+    var YB = xO(yO),
+        XB = xO(vO);
 
-    function a_(e, t) {
+    function Ex(e, t) {
         t || (t = []);
         var n = e ? Math.min(t.length, e.length) : 0,
             i = t.slice(),
             r;
-        return function(a) {
-            for (r = 0; r < n; ++r) i[r] = e[r] * (1 - a) + t[r] * a;
+        return function(s) {
+            for (r = 0; r < n; ++r) i[r] = e[r] * (1 - s) + t[r] * s;
             return i
         }
     }
 
-    function cF(e) {
+    function _O(e) {
         return ArrayBuffer.isView(e) && !(e instanceof DataView)
     }
 
-    function GB(e, t) {
-        return (cF(t) ? a_ : fF)(e, t)
+    function VB(e, t) {
+        return (_O(t) ? Ex : wO)(e, t)
     }
 
-    function fF(e, t) {
+    function wO(e, t) {
         var n = t ? t.length : 0,
             i = e ? Math.min(n, e.length) : 0,
             r = new Array(i),
-            a = new Array(n),
-            s;
-        for (s = 0; s < i; ++s) r[s] = oo(e[s], t[s]);
-        for (; s < n; ++s) a[s] = t[s];
+            s = new Array(n),
+            a;
+        for (a = 0; a < i; ++a) r[a] = Ka(e[a], t[a]);
+        for (; a < n; ++a) s[a] = t[a];
         return function(o) {
-            for (s = 0; s < i; ++s) a[s] = r[s](o);
-            return a
+            for (a = 0; a < i; ++a) s[a] = r[a](o);
+            return s
         }
     }
 
-    function hF(e, t) {
+    function SO(e, t) {
         var n = new Date;
         return e = +e, t = +t,
             function(i) {
                 return n.setTime(e * (1 - i) + t * i), n
             }
     }
 
-    function tr(e, t) {
+    function Xi(e, t) {
         return e = +e, t = +t,
             function(n) {
                 return e * (1 - n) + t * n
             }
     }
 
-    function dF(e, t) {
+    function EO(e, t) {
         var n = {},
             i = {},
             r;
         (e === null || typeof e != "object") && (e = {}), (t === null || typeof t != "object") && (t = {});
-        for (r in t) r in e ? n[r] = oo(e[r], t[r]) : i[r] = t[r];
-        return function(a) {
-            for (r in n) i[r] = n[r](a);
+        for (r in t) r in e ? n[r] = Ka(e[r], t[r]) : i[r] = t[r];
+        return function(s) {
+            for (r in n) i[r] = n[r](s);
             return i
         }
     }
-    var Mb = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,
-        Wy = new RegExp(Mb.source, "g");
+    var sb = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,
+        Sy = new RegExp(sb.source, "g");
 
-    function UB(e) {
+    function KB(e) {
         return function() {
             return e
         }
     }
 
-    function qB(e) {
+    function JB(e) {
         return function(t) {
             return e(t) + ""
         }
     }
 
-    function gF(e, t) {
-        var n = Mb.lastIndex = Wy.lastIndex = 0,
-            i, r, a, s = -1,
+    function CO(e, t) {
+        var n = sb.lastIndex = Sy.lastIndex = 0,
+            i, r, s, a = -1,
             o = [],
             l = [];
         for (e = e + "", t = t + "";
-            (i = Mb.exec(e)) && (r = Wy.exec(t));)(a = r.index) > n && (a = t.slice(n, a), o[s] ? o[s] += a : o[++s] = a), (i = i[0]) === (r = r[0]) ? o[s] ? o[s] += r : o[++s] = r : (o[++s] = null, l.push({
-            i: s,
-            x: tr(i, r)
-        })), n = Wy.lastIndex;
-        return n < t.length && (a = t.slice(n), o[s] ? o[s] += a : o[++s] = a), o.length < 2 ? l[0] ? qB(l[0].x) : UB(t) : (t = l.length, function(u) {
+            (i = sb.exec(e)) && (r = Sy.exec(t));)(s = r.index) > n && (s = t.slice(n, s), o[a] ? o[a] += s : o[++a] = s), (i = i[0]) === (r = r[0]) ? o[a] ? o[a] += r : o[++a] = r : (o[++a] = null, l.push({
+            i: a,
+            x: Xi(i, r)
+        })), n = Sy.lastIndex;
+        return n < t.length && (s = t.slice(n), o[a] ? o[a] += s : o[++a] = s), o.length < 2 ? l[0] ? JB(l[0].x) : KB(t) : (t = l.length, function(u) {
             for (var c = 0, f; c < t; ++c) o[(f = l[c]).i] = f.x(u);
             return o.join("")
         })
     }
 
-    function oo(e, t) {
+    function Ka(e, t) {
         var n = typeof t,
             i;
-        return t == null || n === "boolean" ? Em(t) : (n === "number" ? tr : n === "string" ? (i = kh(t)) ? (t = i, $b) : gF : t instanceof kh ? $b : t instanceof Date ? hF : cF(t) ? a_ : Array.isArray(t) ? fF : typeof t.valueOf != "function" && typeof t.toString != "function" || isNaN(t) ? dF : tr)(e, t)
+        return t == null || n === "boolean" ? rm(t) : (n === "number" ? Xi : n === "string" ? (i = ph(t)) ? (t = i, rb) : CO : t instanceof ph ? rb : t instanceof Date ? SO : _O(t) ? Ex : Array.isArray(t) ? wO : typeof t.valueOf != "function" && typeof t.toString != "function" || isNaN(t) ? EO : Xi)(e, t)
     }
 
-    function WB(e) {
+    function QB(e) {
         var t = e.length;
         return function(n) {
             return e[Math.max(0, Math.min(t - 1, Math.floor(n * t)))]
         }
     }
 
-    function HB(e, t) {
-        var n = Om(+e, +t);
+    function ZB(e, t) {
+        var n = sm(+e, +t);
         return function(i) {
             var r = n(i);
             return r - 360 * Math.floor(r / 360)
         }
     }
 
-    function ud(e, t) {
+    function Jh(e, t) {
         return e = +e, t = +t,
             function(n) {
                 return Math.round(e * (1 - n) + t * n)
             }
     }
-    var _k = 180 / Math.PI,
-        Fb = {
+    var Nk = 180 / Math.PI,
+        ab = {
             translateX: 0,
             translateY: 0,
             rotate: 0,
             skewX: 0,
             scaleX: 1,
             scaleY: 1
         };
 
-    function pF(e, t, n, i, r, a) {
-        var s, o, l;
-        return (s = Math.sqrt(e * e + t * t)) && (e /= s, t /= s), (l = e * n + t * i) && (n -= e * l, i -= t * l), (o = Math.sqrt(n * n + i * i)) && (n /= o, i /= o, l /= o), e * i < t * n && (e = -e, t = -t, l = -l, s = -s), {
+    function kO(e, t, n, i, r, s) {
+        var a, o, l;
+        return (a = Math.sqrt(e * e + t * t)) && (e /= a, t /= a), (l = e * n + t * i) && (n -= e * l, i -= t * l), (o = Math.sqrt(n * n + i * i)) && (n /= o, i /= o, l /= o), e * i < t * n && (e = -e, t = -t, l = -l, a = -a), {
             translateX: r,
-            translateY: a,
-            rotate: Math.atan2(t, e) * _k,
-            skewX: Math.atan(l) * _k,
-            scaleX: s,
+            translateY: s,
+            rotate: Math.atan2(t, e) * Nk,
+            skewX: Math.atan(l) * Nk,
+            scaleX: a,
             scaleY: o
         }
     }
-    var mg;
+    var tg;
 
-    function YB(e) {
+    function ej(e) {
         const t = new(typeof DOMMatrix == "function" ? DOMMatrix : WebKitCSSMatrix)(e + "");
-        return t.isIdentity ? Fb : pF(t.a, t.b, t.c, t.d, t.e, t.f)
+        return t.isIdentity ? ab : kO(t.a, t.b, t.c, t.d, t.e, t.f)
     }
 
-    function XB(e) {
-        return e == null || (mg || (mg = document.createElementNS("http://www.w3.org/2000/svg", "g")), mg.setAttribute("transform", e), !(e = mg.transform.baseVal.consolidate())) ? Fb : (e = e.matrix, pF(e.a, e.b, e.c, e.d, e.e, e.f))
+    function tj(e) {
+        return e == null || (tg || (tg = document.createElementNS("http://www.w3.org/2000/svg", "g")), tg.setAttribute("transform", e), !(e = tg.transform.baseVal.consolidate())) ? ab : (e = e.matrix, kO(e.a, e.b, e.c, e.d, e.e, e.f))
     }
 
-    function mF(e, t, n, i) {
+    function AO(e, t, n, i) {
         function r(u) {
             return u.length ? u.pop() + " " : ""
         }
 
-        function a(u, c, f, h, d, g) {
+        function s(u, c, f, h, d, g) {
             if (u !== f || c !== h) {
                 var p = d.push("translate(", null, t, null, n);
                 g.push({
                     i: p - 4,
-                    x: tr(u, f)
+                    x: Xi(u, f)
                 }, {
                     i: p - 2,
-                    x: tr(c, h)
+                    x: Xi(c, h)
                 })
             } else(f || h) && d.push("translate(" + f + t + h + n)
         }
 
-        function s(u, c, f, h) {
+        function a(u, c, f, h) {
             u !== c ? (u - c > 180 ? c += 360 : c - u > 180 && (u += 360), h.push({
                 i: f.push(r(f) + "rotate(", null, i) - 2,
-                x: tr(u, c)
+                x: Xi(u, c)
             })) : c && f.push(r(f) + "rotate(" + c + i)
         }
 
         function o(u, c, f, h) {
             u !== c ? h.push({
                 i: f.push(r(f) + "skewX(", null, i) - 2,
-                x: tr(u, c)
+                x: Xi(u, c)
             }) : c && f.push(r(f) + "skewX(" + c + i)
         }
 
         function l(u, c, f, h, d, g) {
             if (u !== f || c !== h) {
                 var p = d.push(r(d) + "scale(", null, ",", null, ")");
                 g.push({
                     i: p - 4,
-                    x: tr(u, f)
+                    x: Xi(u, f)
                 }, {
                     i: p - 2,
-                    x: tr(c, h)
+                    x: Xi(c, h)
                 })
             } else(f !== 1 || h !== 1) && d.push(r(d) + "scale(" + f + "," + h + ")")
         }
         return function(u, c) {
             var f = [],
                 h = [];
-            return u = e(u), c = e(c), a(u.translateX, u.translateY, c.translateX, c.translateY, f, h), s(u.rotate, c.rotate, f, h), o(u.skewX, c.skewX, f, h), l(u.scaleX, u.scaleY, c.scaleX, c.scaleY, f, h), u = c = null,
+            return u = e(u), c = e(c), s(u.translateX, u.translateY, c.translateX, c.translateY, f, h), a(u.rotate, c.rotate, f, h), o(u.skewX, c.skewX, f, h), l(u.scaleX, u.scaleY, c.scaleX, c.scaleY, f, h), u = c = null,
                 function(d) {
                     for (var g = -1, p = h.length, m; ++g < p;) f[(m = h[g]).i] = m.x(d);
                     return f.join("")
                 }
         }
     }
-    var VB = mF(YB, "px, ", "px)", "deg)"),
-        KB = mF(XB, ", ", ")", ")"),
-        JB = 1e-12;
+    var nj = AO(ej, "px, ", "px)", "deg)"),
+        ij = AO(tj, ", ", ")", ")"),
+        rj = 1e-12;
 
-    function wk(e) {
+    function Pk(e) {
         return ((e = Math.exp(e)) + 1 / e) / 2
     }
 
-    function QB(e) {
+    function sj(e) {
         return ((e = Math.exp(e)) - 1 / e) / 2
     }
 
-    function ZB(e) {
+    function aj(e) {
         return ((e = Math.exp(2 * e)) - 1) / (e + 1)
     }
-    const eG = function e(t, n, i) {
-        function r(a, s) {
-            var o = a[0],
-                l = a[1],
-                u = a[2],
-                c = s[0],
-                f = s[1],
-                h = s[2],
+    const oj = function e(t, n, i) {
+        function r(s, a) {
+            var o = s[0],
+                l = s[1],
+                u = s[2],
+                c = a[0],
+                f = a[1],
+                h = a[2],
                 d = c - o,
                 g = f - l,
                 p = d * d + g * g,
                 m, y;
-            if (p < JB) y = Math.log(h / u) / t, m = function(w) {
+            if (p < rj) y = Math.log(h / u) / t, m = function(w) {
                 return [o + w * d, l + w * g, u * Math.exp(t * w * y)]
             };
             else {
                 var v = Math.sqrt(p),
                     b = (h * h - u * u + i * p) / (2 * u * n * v),
                     x = (h * h - u * u - i * p) / (2 * h * n * v),
                     _ = Math.log(Math.sqrt(b * b + 1) - b),
                     S = Math.log(Math.sqrt(x * x + 1) - x);
                 y = (S - _) / t, m = function(w) {
-                    var O = w * y,
-                        k = wk(_),
-                        C = u / (n * v) * (k * ZB(t * O + _) - QB(_));
-                    return [o + C * d, l + C * g, u * k / wk(t * O + _)]
+                    var E = w * y,
+                        A = Pk(_),
+                        C = u / (n * v) * (A * aj(t * E + _) - sj(_));
+                    return [o + C * d, l + C * g, u * A / Pk(t * E + _)]
                 }
             }
             return m.duration = y * 1e3 * t / Math.SQRT2, m
         }
-        return r.rho = function(a) {
-            var s = Math.max(.001, +a),
-                o = s * s,
+        return r.rho = function(s) {
+            var a = Math.max(.001, +s),
+                o = a * a,
                 l = o * o;
-            return e(s, o, l)
+            return e(a, o, l)
         }, r
     }(Math.SQRT2, 2, 4);
 
-    function yF(e) {
+    function $O(e) {
         return function(t, n) {
-            var i = e((t = Lp(t)).h, (n = Lp(n)).h),
-                r = Ut(t.s, n.s),
-                a = Ut(t.l, n.l),
-                s = Ut(t.opacity, n.opacity);
+            var i = e((t = vp(t)).h, (n = vp(n)).h),
+                r = zt(t.s, n.s),
+                s = zt(t.l, n.l),
+                a = zt(t.opacity, n.opacity);
             return function(o) {
-                return t.h = i(o), t.s = r(o), t.l = a(o), t.opacity = s(o), t + ""
+                return t.h = i(o), t.s = r(o), t.l = s(o), t.opacity = a(o), t + ""
             }
         }
     }
-    const tG = yF(Om);
-    var nG = yF(Ut);
+    const lj = $O(sm);
+    var uj = $O(zt);
 
-    function iG(e, t) {
-        var n = Ut((e = jp(e)).l, (t = jp(t)).l),
-            i = Ut(e.a, t.a),
-            r = Ut(e.b, t.b),
-            a = Ut(e.opacity, t.opacity);
-        return function(s) {
-            return e.l = n(s), e.a = i(s), e.b = r(s), e.opacity = a(s), e + ""
+    function cj(e, t) {
+        var n = zt((e = xp(e)).l, (t = xp(t)).l),
+            i = zt(e.a, t.a),
+            r = zt(e.b, t.b),
+            s = zt(e.opacity, t.opacity);
+        return function(a) {
+            return e.l = n(a), e.a = i(a), e.b = r(a), e.opacity = s(a), e + ""
         }
     }
 
-    function vF(e) {
+    function TO(e) {
         return function(t, n) {
-            var i = e((t = zp(t)).h, (n = zp(n)).h),
-                r = Ut(t.c, n.c),
-                a = Ut(t.l, n.l),
-                s = Ut(t.opacity, n.opacity);
+            var i = e((t = _p(t)).h, (n = _p(n)).h),
+                r = zt(t.c, n.c),
+                s = zt(t.l, n.l),
+                a = zt(t.opacity, n.opacity);
             return function(o) {
-                return t.h = i(o), t.c = r(o), t.l = a(o), t.opacity = s(o), t + ""
+                return t.h = i(o), t.c = r(o), t.l = s(o), t.opacity = a(o), t + ""
             }
         }
     }
-    const rG = vF(Om);
-    var aG = vF(Ut);
+    const fj = TO(sm);
+    var hj = TO(zt);
 
-    function bF(e) {
+    function MO(e) {
         return function t(n) {
             n = +n;
 
-            function i(r, a) {
-                var s = e((r = Tb(r)).h, (a = Tb(a)).h),
-                    o = Ut(r.s, a.s),
-                    l = Ut(r.l, a.l),
-                    u = Ut(r.opacity, a.opacity);
+            function i(r, s) {
+                var a = e((r = ib(r)).h, (s = ib(s)).h),
+                    o = zt(r.s, s.s),
+                    l = zt(r.l, s.l),
+                    u = zt(r.opacity, s.opacity);
                 return function(c) {
-                    return r.h = s(c), r.s = o(c), r.l = l(Math.pow(c, n)), r.opacity = u(c), r + ""
+                    return r.h = a(c), r.s = o(c), r.l = l(Math.pow(c, n)), r.opacity = u(c), r + ""
                 }
             }
             return i.gamma = t, i
         }(1)
     }
-    const sG = bF(Om);
-    var oG = bF(Ut);
+    const dj = MO(sm);
+    var gj = MO(zt);
 
-    function s_(e, t) {
-        t === void 0 && (t = e, e = oo);
-        for (var n = 0, i = t.length - 1, r = t[0], a = new Array(i < 0 ? 0 : i); n < i;) a[n] = e(r, r = t[++n]);
-        return function(s) {
-            var o = Math.max(0, Math.min(i - 1, Math.floor(s *= i)));
-            return a[o](s - o)
+    function Cx(e, t) {
+        t === void 0 && (t = e, e = Ka);
+        for (var n = 0, i = t.length - 1, r = t[0], s = new Array(i < 0 ? 0 : i); n < i;) s[n] = e(r, r = t[++n]);
+        return function(a) {
+            var o = Math.max(0, Math.min(i - 1, Math.floor(a *= i)));
+            return s[o](a - o)
         }
     }
 
-    function lG(e, t) {
+    function pj(e, t) {
         for (var n = new Array(t), i = 0; i < t; ++i) n[i] = e(i / (t - 1));
         return n
     }
-    const uG = Object.freeze(Object.defineProperty({
+    const mj = Object.freeze(Object.defineProperty({
         __proto__: null,
-        interpolate: oo,
-        interpolateArray: GB,
-        interpolateBasis: sF,
-        interpolateBasisClosed: oF,
-        interpolateCubehelix: sG,
-        interpolateCubehelixLong: oG,
-        interpolateDate: hF,
-        interpolateDiscrete: WB,
-        interpolateHcl: rG,
-        interpolateHclLong: aG,
-        interpolateHsl: tG,
-        interpolateHslLong: nG,
-        interpolateHue: HB,
-        interpolateLab: iG,
-        interpolateNumber: tr,
-        interpolateNumberArray: a_,
-        interpolateObject: dF,
-        interpolateRgb: $b,
-        interpolateRgbBasis: zB,
-        interpolateRgbBasisClosed: BB,
-        interpolateRound: ud,
-        interpolateString: gF,
-        interpolateTransformCss: VB,
-        interpolateTransformSvg: KB,
-        interpolateZoom: eG,
-        piecewise: s_,
-        quantize: lG
+        interpolate: Ka,
+        interpolateArray: VB,
+        interpolateBasis: yO,
+        interpolateBasisClosed: vO,
+        interpolateCubehelix: dj,
+        interpolateCubehelixLong: gj,
+        interpolateDate: SO,
+        interpolateDiscrete: QB,
+        interpolateHcl: fj,
+        interpolateHclLong: hj,
+        interpolateHsl: lj,
+        interpolateHslLong: uj,
+        interpolateHue: ZB,
+        interpolateLab: cj,
+        interpolateNumber: Xi,
+        interpolateNumberArray: Ex,
+        interpolateObject: EO,
+        interpolateRgb: rb,
+        interpolateRgbBasis: YB,
+        interpolateRgbBasisClosed: XB,
+        interpolateRound: Jh,
+        interpolateString: CO,
+        interpolateTransformCss: nj,
+        interpolateTransformSvg: ij,
+        interpolateZoom: oj,
+        piecewise: Cx,
+        quantize: pj
     }, Symbol.toStringTag, {
         value: "Module"
     }));
 
-    function ja(e, t) {
+    function Ts(e, t) {
         return e == null || t == null ? NaN : e < t ? -1 : e > t ? 1 : e >= t ? 0 : NaN
     }
 
-    function cG(e, t) {
+    function yj(e, t) {
         return e == null || t == null ? NaN : t < e ? -1 : t > e ? 1 : t >= e ? 0 : NaN
     }
 
-    function cd(e) {
+    function Qh(e) {
         let t, n, i;
-        e.length !== 2 ? (t = ja, n = (o, l) => ja(e(o), l), i = (o, l) => e(o) - l) : (t = e === ja || e === cG ? e : fG, n = e, i = e);
+        e.length !== 2 ? (t = Ts, n = (o, l) => Ts(e(o), l), i = (o, l) => e(o) - l) : (t = e === Ts || e === yj ? e : vj, n = e, i = e);
 
         function r(o, l, u = 0, c = o.length) {
             if (u < c) {
                 if (t(l, l) !== 0) return c;
                 do {
                     const f = u + c >>> 1;
                     n(o[f], l) < 0 ? u = f + 1 : c = f
                 } while (u < c)
             }
             return u
         }
 
-        function a(o, l, u = 0, c = o.length) {
+        function s(o, l, u = 0, c = o.length) {
             if (u < c) {
                 if (t(l, l) !== 0) return c;
                 do {
                     const f = u + c >>> 1;
                     n(o[f], l) <= 0 ? u = f + 1 : c = f
                 } while (u < c)
             }
             return u
         }
 
-        function s(o, l, u = 0, c = o.length) {
+        function a(o, l, u = 0, c = o.length) {
             const f = r(o, l, u, c - 1);
             return f > u && i(o[f - 1], l) > -i(o[f], l) ? f - 1 : f
         }
         return {
             left: r,
-            center: s,
-            right: a
+            center: a,
+            right: s
         }
     }
 
-    function fG() {
+    function vj() {
         return 0
     }
 
-    function xF(e) {
+    function OO(e) {
         return e === null ? NaN : +e
     }
 
-    function* hG(e, t) {
+    function* bj(e, t) {
         if (t === void 0)
             for (let n of e) n != null && (n = +n) >= n && (yield n);
         else {
             let n = -1;
             for (let i of e)(i = t(i, ++n, e)) != null && (i = +i) >= i && (yield i)
         }
     }
-    const _F = cd(ja),
-        Bp = _F.right,
-        dG = _F.left;
-    cd(xF).center;
-    const fd = Bp;
+    const FO = Qh(Ts),
+        wp = FO.right,
+        xj = FO.left;
+    Qh(OO).center;
+    const Zh = wp;
 
-    function gG(e, t) {
+    function _j(e, t) {
         let n = 0,
             i, r = 0,
-            a = 0;
+            s = 0;
         if (t === void 0)
-            for (let s of e) s != null && (s = +s) >= s && (i = s - r, r += i / ++n, a += i * (s - r));
+            for (let a of e) a != null && (a = +a) >= a && (i = a - r, r += i / ++n, s += i * (a - r));
         else {
-            let s = -1;
-            for (let o of e)(o = t(o, ++s, e)) != null && (o = +o) >= o && (i = o - r, r += i / ++n, a += i * (o - r))
+            let a = -1;
+            for (let o of e)(o = t(o, ++a, e)) != null && (o = +o) >= o && (i = o - r, r += i / ++n, s += i * (o - r))
         }
-        if (n > 1) return a / (n - 1)
+        if (n > 1) return s / (n - 1)
     }
 
-    function pG(e, t) {
-        const n = gG(e, t);
+    function wj(e, t) {
+        const n = _j(e, t);
         return n && Math.sqrt(n)
     }
-    class Nn {
+    class Rn {
         constructor() {
             this._partials = new Float64Array(32), this._n = 0
         }
         add(t) {
             const n = this._partials;
             let i = 0;
             for (let r = 0; r < this._n && r < 32; r++) {
-                const a = n[r],
-                    s = t + a,
-                    o = Math.abs(t) < Math.abs(a) ? t - (s - a) : a - (s - t);
-                o && (n[i++] = o), t = s
+                const s = n[r],
+                    a = t + s,
+                    o = Math.abs(t) < Math.abs(s) ? t - (a - s) : s - (a - t);
+                o && (n[i++] = o), t = a
             }
             return n[i] = t, this._n = i + 1, this
         }
         valueOf() {
             const t = this._partials;
             let n = this._n,
-                i, r, a, s = 0;
+                i, r, s, a = 0;
             if (n > 0) {
-                for (s = t[--n]; n > 0 && (i = s, r = t[--n], s = i + r, a = r - (s - i), !a););
-                n > 0 && (a < 0 && t[n - 1] < 0 || a > 0 && t[n - 1] > 0) && (r = a * 2, i = s + r, r == i - s && (s = i))
+                for (a = t[--n]; n > 0 && (i = a, r = t[--n], a = i + r, s = r - (a - i), !s););
+                n > 0 && (s < 0 && t[n - 1] < 0 || s > 0 && t[n - 1] > 0) && (r = s * 2, i = a + r, r == i - a && (a = i))
             }
-            return s
+            return a
         }
     }
-    class Sk extends Map {
-        constructor(t, n = EF) {
+    class Lk extends Map {
+        constructor(t, n = NO) {
             if (super(), Object.defineProperties(this, {
                     _intern: {
                         value: new Map
                     },
                     _key: {
                         value: n
                     }
                 }), t != null)
                 for (const [i, r] of t) this.set(i, r)
         }
         get(t) {
-            return super.get(Db(this, t))
+            return super.get(ob(this, t))
         }
         has(t) {
-            return super.has(Db(this, t))
+            return super.has(ob(this, t))
         }
         set(t, n) {
-            return super.set(wF(this, t), n)
+            return super.set(RO(this, t), n)
         }
         delete(t) {
-            return super.delete(SF(this, t))
+            return super.delete(DO(this, t))
         }
     }
-    class Gp extends Set {
-        constructor(t, n = EF) {
+    class Sp extends Set {
+        constructor(t, n = NO) {
             if (super(), Object.defineProperties(this, {
                     _intern: {
                         value: new Map
                     },
                     _key: {
                         value: n
                     }
                 }), t != null)
                 for (const i of t) this.add(i)
         }
         has(t) {
-            return super.has(Db(this, t))
+            return super.has(ob(this, t))
         }
         add(t) {
-            return super.add(wF(this, t))
+            return super.add(RO(this, t))
         }
         delete(t) {
-            return super.delete(SF(this, t))
+            return super.delete(DO(this, t))
         }
     }
 
-    function Db({
+    function ob({
         _intern: e,
         _key: t
     }, n) {
         const i = t(n);
         return e.has(i) ? e.get(i) : n
     }
 
-    function wF({
+    function RO({
         _intern: e,
         _key: t
     }, n) {
         const i = t(n);
         return e.has(i) ? e.get(i) : (e.set(i, n), n)
     }
 
-    function SF({
+    function DO({
         _intern: e,
         _key: t
     }, n) {
         const i = t(n);
         return e.has(i) && (n = e.get(i), e.delete(i)), n
     }
 
-    function EF(e) {
+    function NO(e) {
         return e !== null && typeof e == "object" ? e.valueOf() : e
     }
 
-    function mG(e, t) {
+    function Sj(e, t) {
         return Array.from(t, n => e[n])
     }
 
-    function yG(e = ja) {
-        if (e === ja) return OF;
+    function Ej(e = Ts) {
+        if (e === Ts) return PO;
         if (typeof e != "function") throw new TypeError("compare is not a function");
         return (t, n) => {
             const i = e(t, n);
             return i || i === 0 ? i : (e(n, n) === 0) - (e(t, t) === 0)
         }
     }
 
-    function OF(e, t) {
+    function PO(e, t) {
         return (e == null || !(e >= e)) - (t == null || !(t >= t)) || (e < t ? -1 : e > t ? 1 : 0)
     }
-    const vG = Math.sqrt(50),
-        bG = Math.sqrt(10),
-        xG = Math.sqrt(2);
+    const Cj = Math.sqrt(50),
+        kj = Math.sqrt(10),
+        Aj = Math.sqrt(2);
 
-    function Up(e, t, n) {
+    function Ep(e, t, n) {
         const i = (t - e) / Math.max(0, n),
             r = Math.floor(Math.log10(i)),
-            a = i / Math.pow(10, r),
-            s = a >= vG ? 10 : a >= bG ? 5 : a >= xG ? 2 : 1;
+            s = i / Math.pow(10, r),
+            a = s >= Cj ? 10 : s >= kj ? 5 : s >= Aj ? 2 : 1;
         let o, l, u;
-        return r < 0 ? (u = Math.pow(10, -r) / s, o = Math.round(e * u), l = Math.round(t * u), o / u < e && ++o, l / u > t && --l, u = -u) : (u = Math.pow(10, r) * s, o = Math.round(e / u), l = Math.round(t / u), o * u < e && ++o, l * u > t && --l), l < o && .5 <= n && n < 2 ? Up(e, t, n * 2) : [o, l, u]
+        return r < 0 ? (u = Math.pow(10, -r) / a, o = Math.round(e * u), l = Math.round(t * u), o / u < e && ++o, l / u > t && --l, u = -u) : (u = Math.pow(10, r) * a, o = Math.round(e / u), l = Math.round(t / u), o * u < e && ++o, l * u > t && --l), l < o && .5 <= n && n < 2 ? Ep(e, t, n * 2) : [o, l, u]
     }
 
-    function Rb(e, t, n) {
+    function lb(e, t, n) {
         if (t = +t, e = +e, n = +n, !(n > 0)) return [];
         if (e === t) return [e];
         const i = t < e,
-            [r, a, s] = i ? Up(t, e, n) : Up(e, t, n);
-        if (!(a >= r)) return [];
-        const o = a - r + 1,
+            [r, s, a] = i ? Ep(t, e, n) : Ep(e, t, n);
+        if (!(s >= r)) return [];
+        const o = s - r + 1,
             l = new Array(o);
         if (i)
-            if (s < 0)
-                for (let u = 0; u < o; ++u) l[u] = (a - u) / -s;
+            if (a < 0)
+                for (let u = 0; u < o; ++u) l[u] = (s - u) / -a;
             else
-                for (let u = 0; u < o; ++u) l[u] = (a - u) * s;
-        else if (s < 0)
-            for (let u = 0; u < o; ++u) l[u] = (r + u) / -s;
+                for (let u = 0; u < o; ++u) l[u] = (s - u) * a;
+        else if (a < 0)
+            for (let u = 0; u < o; ++u) l[u] = (r + u) / -a;
         else
-            for (let u = 0; u < o; ++u) l[u] = (r + u) * s;
+            for (let u = 0; u < o; ++u) l[u] = (r + u) * a;
         return l
     }
 
-    function Pb(e, t, n) {
-        return t = +t, e = +e, n = +n, Up(e, t, n)[2]
+    function ub(e, t, n) {
+        return t = +t, e = +e, n = +n, Ep(e, t, n)[2]
     }
 
-    function Bs(e, t, n) {
+    function Oa(e, t, n) {
         t = +t, e = +e, n = +n;
         const i = t < e,
-            r = i ? Pb(t, e, n) : Pb(e, t, n);
+            r = i ? ub(t, e, n) : ub(e, t, n);
         return (i ? -1 : 1) * (r < 0 ? 1 / -r : r)
     }
 
-    function el(e, t) {
+    function jo(e, t) {
         let n;
         if (t === void 0)
             for (const i of e) i != null && (n < i || n === void 0 && i >= i) && (n = i);
         else {
             let i = -1;
             for (let r of e)(r = t(r, ++i, e)) != null && (n < r || n === void 0 && r >= r) && (n = r)
         }
         return n
     }
 
-    function Nb(e, t) {
+    function cb(e, t) {
         let n;
         if (t === void 0)
             for (const i of e) i != null && (n > i || n === void 0 && i >= i) && (n = i);
         else {
             let i = -1;
             for (let r of e)(r = t(r, ++i, e)) != null && (n > r || n === void 0 && r >= r) && (n = r)
         }
         return n
     }
 
-    function CF(e, t, n = 0, i = 1 / 0, r) {
+    function LO(e, t, n = 0, i = 1 / 0, r) {
         if (t = Math.floor(t), n = Math.floor(Math.max(0, n)), i = Math.floor(Math.min(e.length - 1, i)), !(n <= t && t <= i)) return e;
-        for (r = r === void 0 ? OF : yG(r); i > n;) {
+        for (r = r === void 0 ? PO : Ej(r); i > n;) {
             if (i - n > 600) {
                 const l = i - n + 1,
                     u = t - n + 1,
                     c = Math.log(l),
                     f = .5 * Math.exp(2 * c / 3),
                     h = .5 * Math.sqrt(c * f * (l - f) / l) * (u - l / 2 < 0 ? -1 : 1),
                     d = Math.max(n, Math.floor(t - u * f / l + h)),
                     g = Math.min(i, Math.floor(t + (l - u) * f / l + h));
-                CF(e, t, d, g, r)
+                LO(e, t, d, g, r)
             }
-            const a = e[t];
-            let s = n,
+            const s = e[t];
+            let a = n,
                 o = i;
-            for (rf(e, n, t), r(e[i], a) > 0 && rf(e, n, i); s < o;) {
-                for (rf(e, s, o), ++s, --o; r(e[s], a) < 0;) ++s;
-                for (; r(e[o], a) > 0;) --o
+            for (Wc(e, n, t), r(e[i], s) > 0 && Wc(e, n, i); a < o;) {
+                for (Wc(e, a, o), ++a, --o; r(e[a], s) < 0;) ++a;
+                for (; r(e[o], s) > 0;) --o
             }
-            r(e[n], a) === 0 ? rf(e, n, o) : (++o, rf(e, o, i)), o <= t && (n = o + 1), t <= o && (i = o - 1)
+            r(e[n], s) === 0 ? Wc(e, n, o) : (++o, Wc(e, o, i)), o <= t && (n = o + 1), t <= o && (i = o - 1)
         }
         return e
     }
 
-    function rf(e, t, n) {
+    function Wc(e, t, n) {
         const i = e[t];
         e[t] = e[n], e[n] = i
     }
 
-    function Lb(e, t, n) {
-        if (e = Float64Array.from(hG(e, n)), !(!(i = e.length) || isNaN(t = +t))) {
-            if (t <= 0 || i < 2) return Nb(e);
-            if (t >= 1) return el(e);
+    function fb(e, t, n) {
+        if (e = Float64Array.from(bj(e, n)), !(!(i = e.length) || isNaN(t = +t))) {
+            if (t <= 0 || i < 2) return cb(e);
+            if (t >= 1) return jo(e);
             var i, r = (i - 1) * t,
-                a = Math.floor(r),
-                s = el(CF(e, a).subarray(0, a + 1)),
-                o = Nb(e.subarray(a + 1));
-            return s + (o - s) * (r - a)
+                s = Math.floor(r),
+                a = jo(LO(e, s).subarray(0, s + 1)),
+                o = cb(e.subarray(s + 1));
+            return a + (o - a) * (r - s)
         }
     }
 
-    function kF(e, t, n = xF) {
+    function IO(e, t, n = OO) {
         if (!(!(i = e.length) || isNaN(t = +t))) {
             if (t <= 0 || i < 2) return +n(e[0], 0, e);
             if (t >= 1) return +n(e[i - 1], i - 1, e);
             var i, r = (i - 1) * t,
-                a = Math.floor(r),
-                s = +n(e[a], a, e),
-                o = +n(e[a + 1], a + 1, e);
-            return s + (o - s) * (r - a)
+                s = Math.floor(r),
+                a = +n(e[s], s, e),
+                o = +n(e[s + 1], s + 1, e);
+            return a + (o - a) * (r - s)
         }
     }
 
-    function _G(e, t) {
+    function $j(e, t) {
         let n = 0,
             i = 0;
         if (t === void 0)
             for (let r of e) r != null && (r = +r) >= r && (++n, i += r);
         else {
             let r = -1;
-            for (let a of e)(a = t(a, ++r, e)) != null && (a = +a) >= a && (++n, i += a)
+            for (let s of e)(s = t(s, ++r, e)) != null && (s = +s) >= s && (++n, i += s)
         }
         if (n) return i / n
     }
 
-    function AF(e, t) {
-        return Lb(e, .5, t)
+    function zO(e, t) {
+        return fb(e, .5, t)
     }
 
-    function* wG(e) {
+    function* Tj(e) {
         for (const t of e) yield* t
     }
 
-    function TF(e) {
-        return Array.from(wG(e))
+    function BO(e) {
+        return Array.from(Tj(e))
     }
 
-    function mi(e, t, n) {
+    function gi(e, t, n) {
         e = +e, t = +t, n = (r = arguments.length) < 2 ? (t = e, e = 0, 1) : r < 3 ? 1 : +n;
-        for (var i = -1, r = Math.max(0, Math.ceil((t - e) / n)) | 0, a = new Array(r); ++i < r;) a[i] = e + i * n;
-        return a
+        for (var i = -1, r = Math.max(0, Math.ceil((t - e) / n)) | 0, s = new Array(r); ++i < r;) s[i] = e + i * n;
+        return s
     }
 
-    function $F(e, t) {
+    function jO(e, t) {
         let n = 0;
         if (t === void 0)
             for (let i of e)(i = +i) && (n += i);
         else {
             let i = -1;
             for (let r of e)(r = +t(r, ++i, e)) && (n += r)
         }
         return n
     }
-    var SG = {
+    var Mj = {
         value: () => {}
     };
 
-    function MF() {
+    function UO() {
         for (var e = 0, t = arguments.length, n = {}, i; e < t; ++e) {
             if (!(i = arguments[e] + "") || i in n || /[\s.]/.test(i)) throw new Error("illegal type: " + i);
             n[i] = []
         }
-        return new up(n)
+        return new qg(n)
     }
 
-    function up(e) {
+    function qg(e) {
         this._ = e
     }
 
-    function EG(e, t) {
+    function Oj(e, t) {
         return e.trim().split(/^|\s+/).map(function(n) {
             var i = "",
                 r = n.indexOf(".");
             if (r >= 0 && (i = n.slice(r + 1), n = n.slice(0, r)), n && !t.hasOwnProperty(n)) throw new Error("unknown type: " + n);
             return {
                 type: n,
                 name: i
             }
         })
     }
-    up.prototype = MF.prototype = {
-        constructor: up,
+    qg.prototype = UO.prototype = {
+        constructor: qg,
         on: function(e, t) {
             var n = this._,
-                i = EG(e + "", n),
-                r, a = -1,
-                s = i.length;
+                i = Oj(e + "", n),
+                r, s = -1,
+                a = i.length;
             if (arguments.length < 2) {
-                for (; ++a < s;)
-                    if ((r = (e = i[a]).type) && (r = OG(n[r], e.name))) return r;
+                for (; ++s < a;)
+                    if ((r = (e = i[s]).type) && (r = Fj(n[r], e.name))) return r;
                 return
             }
             if (t != null && typeof t != "function") throw new Error("invalid callback: " + t);
-            for (; ++a < s;)
-                if (r = (e = i[a]).type) n[r] = Ek(n[r], e.name, t);
+            for (; ++s < a;)
+                if (r = (e = i[s]).type) n[r] = Ik(n[r], e.name, t);
                 else if (t == null)
-                for (r in n) n[r] = Ek(n[r], e.name, null);
+                for (r in n) n[r] = Ik(n[r], e.name, null);
             return this
         },
         copy: function() {
             var e = {},
                 t = this._;
             for (var n in t) e[n] = t[n].slice();
-            return new up(e)
+            return new qg(e)
         },
         call: function(e, t) {
             if ((r = arguments.length - 2) > 0)
-                for (var n = new Array(r), i = 0, r, a; i < r; ++i) n[i] = arguments[i + 2];
+                for (var n = new Array(r), i = 0, r, s; i < r; ++i) n[i] = arguments[i + 2];
             if (!this._.hasOwnProperty(e)) throw new Error("unknown type: " + e);
-            for (a = this._[e], i = 0, r = a.length; i < r; ++i) a[i].value.apply(t, n)
+            for (s = this._[e], i = 0, r = s.length; i < r; ++i) s[i].value.apply(t, n)
         },
         apply: function(e, t, n) {
             if (!this._.hasOwnProperty(e)) throw new Error("unknown type: " + e);
-            for (var i = this._[e], r = 0, a = i.length; r < a; ++r) i[r].value.apply(t, n)
+            for (var i = this._[e], r = 0, s = i.length; r < s; ++r) i[r].value.apply(t, n)
         }
     };
 
-    function OG(e, t) {
+    function Fj(e, t) {
         for (var n = 0, i = e.length, r; n < i; ++n)
             if ((r = e[n]).name === t) return r.value
     }
 
-    function Ek(e, t, n) {
+    function Ik(e, t, n) {
         for (var i = 0, r = e.length; i < r; ++i)
             if (e[i].name === t) {
-                e[i] = SG, e = e.slice(0, i).concat(e.slice(i + 1));
+                e[i] = Mj, e = e.slice(0, i).concat(e.slice(i + 1));
                 break
             } return n != null && e.push({
             name: t,
             value: n
         }), e
     }
-    var Uu = 0,
-        Rf = 0,
-        af = 0,
-        FF = 1e3,
-        qp, Pf, Wp = 0,
-        ul = 0,
-        Cm = 0,
-        Th = typeof performance == "object" && performance.now ? performance : Date,
-        DF = typeof window == "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(e) {
+    var Fu = 0,
+        wf = 0,
+        qc = 0,
+        GO = 1e3,
+        Cp, Sf, kp = 0,
+        Jo = 0,
+        am = 0,
+        yh = typeof performance == "object" && performance.now ? performance : Date,
+        WO = typeof window == "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(e) {
             setTimeout(e, 17)
         };
 
-    function o_() {
-        return ul || (DF(CG), ul = Th.now() + Cm)
+    function kx() {
+        return Jo || (WO(Rj), Jo = yh.now() + am)
     }
 
-    function CG() {
-        ul = 0
+    function Rj() {
+        Jo = 0
     }
 
-    function Hp() {
+    function Ap() {
         this._call = this._time = this._next = null
     }
-    Hp.prototype = RF.prototype = {
-        constructor: Hp,
+    Ap.prototype = qO.prototype = {
+        constructor: Ap,
         restart: function(e, t, n) {
             if (typeof e != "function") throw new TypeError("callback is not a function");
-            n = (n == null ? o_() : +n) + (t == null ? 0 : +t), !this._next && Pf !== this && (Pf ? Pf._next = this : qp = this, Pf = this), this._call = e, this._time = n, Ib()
+            n = (n == null ? kx() : +n) + (t == null ? 0 : +t), !this._next && Sf !== this && (Sf ? Sf._next = this : Cp = this, Sf = this), this._call = e, this._time = n, hb()
         },
         stop: function() {
-            this._call && (this._call = null, this._time = 1 / 0, Ib())
+            this._call && (this._call = null, this._time = 1 / 0, hb())
         }
     };
 
-    function RF(e, t, n) {
-        var i = new Hp;
+    function qO(e, t, n) {
+        var i = new Ap;
         return i.restart(e, t, n), i
     }
 
-    function kG() {
-        o_(), ++Uu;
-        for (var e = qp, t; e;)(t = ul - e._time) >= 0 && e._call.call(void 0, t), e = e._next;
-        --Uu
+    function Dj() {
+        kx(), ++Fu;
+        for (var e = Cp, t; e;)(t = Jo - e._time) >= 0 && e._call.call(void 0, t), e = e._next;
+        --Fu
     }
 
-    function Ok() {
-        ul = (Wp = Th.now()) + Cm, Uu = Rf = 0;
+    function zk() {
+        Jo = (kp = yh.now()) + am, Fu = wf = 0;
         try {
-            kG()
+            Dj()
         } finally {
-            Uu = 0, TG(), ul = 0
+            Fu = 0, Pj(), Jo = 0
         }
     }
 
-    function AG() {
-        var e = Th.now(),
-            t = e - Wp;
-        t > FF && (Cm -= t, Wp = e)
+    function Nj() {
+        var e = yh.now(),
+            t = e - kp;
+        t > GO && (am -= t, kp = e)
     }
 
-    function TG() {
-        for (var e, t = qp, n, i = 1 / 0; t;) t._call ? (i > t._time && (i = t._time), e = t, t = t._next) : (n = t._next, t._next = null, t = e ? e._next = n : qp = n);
-        Pf = e, Ib(i)
+    function Pj() {
+        for (var e, t = Cp, n, i = 1 / 0; t;) t._call ? (i > t._time && (i = t._time), e = t, t = t._next) : (n = t._next, t._next = null, t = e ? e._next = n : Cp = n);
+        Sf = e, hb(i)
     }
 
-    function Ib(e) {
-        if (!Uu) {
-            Rf && (Rf = clearTimeout(Rf));
-            var t = e - ul;
-            t > 24 ? (e < 1 / 0 && (Rf = setTimeout(Ok, e - Th.now() - Cm)), af && (af = clearInterval(af))) : (af || (Wp = Th.now(), af = setInterval(AG, FF)), Uu = 1, DF(Ok))
+    function hb(e) {
+        if (!Fu) {
+            wf && (wf = clearTimeout(wf));
+            var t = e - Jo;
+            t > 24 ? (e < 1 / 0 && (wf = setTimeout(zk, e - yh.now() - am)), qc && (qc = clearInterval(qc))) : (qc || (kp = yh.now(), qc = setInterval(Nj, GO)), Fu = 1, WO(zk))
         }
     }
 
-    function $G(e, t, n) {
-        var i = new Hp,
+    function Lj(e, t, n) {
+        var i = new Ap,
             r = t;
-        return t == null ? (i.restart(e, t, n), i) : (i._restart = i.restart, i.restart = function(a, s, o) {
-            s = +s, o = o == null ? o_() : +o, i._restart(function l(u) {
-                u += r, i._restart(l, r += s, o), a(u)
-            }, s, o)
+        return t == null ? (i.restart(e, t, n), i) : (i._restart = i.restart, i.restart = function(s, a, o) {
+            a = +a, o = o == null ? kx() : +o, i._restart(function l(u) {
+                u += r, i._restart(l, r += a, o), s(u)
+            }, a, o)
         }, i.restart(e, t, n), i)
     }
-    const jb = Math.PI,
-        zb = 2 * jb,
-        No = 1e-6,
-        MG = zb - No;
+    const db = Math.PI,
+        gb = 2 * db,
+        Eo = 1e-6,
+        Ij = gb - Eo;
 
-    function PF(e) {
+    function HO(e) {
         this._ += e[0];
         for (let t = 1, n = e.length; t < n; ++t) this._ += arguments[t] + e[t]
     }
 
-    function FG(e) {
+    function zj(e) {
         let t = Math.floor(e);
         if (!(t >= 0)) throw new Error(`invalid digits: ${e}`);
-        if (t > 15) return PF;
+        if (t > 15) return HO;
         const n = 10 ** t;
         return function(i) {
             this._ += i[0];
-            for (let r = 1, a = i.length; r < a; ++r) this._ += Math.round(arguments[r] * n) / n + i[r]
+            for (let r = 1, s = i.length; r < s; ++r) this._ += Math.round(arguments[r] * n) / n + i[r]
         }
     }
-    let l_ = class {
+    let Ax = class {
         constructor(t) {
-            this._x0 = this._y0 = this._x1 = this._y1 = null, this._ = "", this._append = t == null ? PF : FG(t)
+            this._x0 = this._y0 = this._x1 = this._y1 = null, this._ = "", this._append = t == null ? HO : zj(t)
         }
         moveTo(t, n) {
             this._append`M${this._x0=this._x1=+t},${this._y0=this._y1=+n}`
         }
         closePath() {
             this._x1 !== null && (this._x1 = this._x0, this._y1 = this._y0, this._append`Z`)
         }
         lineTo(t, n) {
             this._append`L${this._x1=+t},${this._y1=+n}`
         }
         quadraticCurveTo(t, n, i, r) {
             this._append`Q${+t},${+n},${this._x1=+i},${this._y1=+r}`
         }
-        bezierCurveTo(t, n, i, r, a, s) {
-            this._append`C${+t},${+n},${+i},${+r},${this._x1=+a},${this._y1=+s}`
+        bezierCurveTo(t, n, i, r, s, a) {
+            this._append`C${+t},${+n},${+i},${+r},${this._x1=+s},${this._y1=+a}`
         }
-        arcTo(t, n, i, r, a) {
-            if (t = +t, n = +n, i = +i, r = +r, a = +a, a < 0) throw new Error(`negative radius: ${a}`);
-            let s = this._x1,
+        arcTo(t, n, i, r, s) {
+            if (t = +t, n = +n, i = +i, r = +r, s = +s, s < 0) throw new Error(`negative radius: ${s}`);
+            let a = this._x1,
                 o = this._y1,
                 l = i - t,
                 u = r - n,
-                c = s - t,
+                c = a - t,
                 f = o - n,
                 h = c * c + f * f;
             if (this._x1 === null) this._append`M${this._x1=t},${this._y1=n}`;
-            else if (h > No)
-                if (!(Math.abs(f * l - u * c) > No) || !a) this._append`L${this._x1=t},${this._y1=n}`;
+            else if (h > Eo)
+                if (!(Math.abs(f * l - u * c) > Eo) || !s) this._append`L${this._x1=t},${this._y1=n}`;
                 else {
-                    let d = i - s,
+                    let d = i - a,
                         g = r - o,
                         p = l * l + u * u,
                         m = d * d + g * g,
                         y = Math.sqrt(p),
                         v = Math.sqrt(h),
-                        b = a * Math.tan((jb - Math.acos((p + h - m) / (2 * y * v))) / 2),
+                        b = s * Math.tan((db - Math.acos((p + h - m) / (2 * y * v))) / 2),
                         x = b / v,
                         _ = b / y;
-                    Math.abs(x - 1) > No && this._append`L${t+x*c},${n+x*f}`, this._append`A${a},${a},0,0,${+(f*d>c*g)},${this._x1=t+_*l},${this._y1=n+_*u}`
+                    Math.abs(x - 1) > Eo && this._append`L${t+x*c},${n+x*f}`, this._append`A${s},${s},0,0,${+(f*d>c*g)},${this._x1=t+_*l},${this._y1=n+_*u}`
                 }
         }
-        arc(t, n, i, r, a, s) {
-            if (t = +t, n = +n, i = +i, s = !!s, i < 0) throw new Error(`negative radius: ${i}`);
+        arc(t, n, i, r, s, a) {
+            if (t = +t, n = +n, i = +i, a = !!a, i < 0) throw new Error(`negative radius: ${i}`);
             let o = i * Math.cos(r),
                 l = i * Math.sin(r),
                 u = t + o,
                 c = n + l,
-                f = 1 ^ s,
-                h = s ? r - a : a - r;
-            this._x1 === null ? this._append`M${u},${c}` : (Math.abs(this._x1 - u) > No || Math.abs(this._y1 - c) > No) && this._append`L${u},${c}`, i && (h < 0 && (h = h % zb + zb), h > MG ? this._append`A${i},${i},0,1,${f},${t-o},${n-l}A${i},${i},0,1,${f},${this._x1=u},${this._y1=c}` : h > No && this._append`A${i},${i},0,${+(h>=jb)},${f},${this._x1=t+i*Math.cos(a)},${this._y1=n+i*Math.sin(a)}`)
+                f = 1 ^ a,
+                h = a ? r - s : s - r;
+            this._x1 === null ? this._append`M${u},${c}` : (Math.abs(this._x1 - u) > Eo || Math.abs(this._y1 - c) > Eo) && this._append`L${u},${c}`, i && (h < 0 && (h = h % gb + gb), h > Ij ? this._append`A${i},${i},0,1,${f},${t-o},${n-l}A${i},${i},0,1,${f},${this._x1=u},${this._y1=c}` : h > Eo && this._append`A${i},${i},0,${+(h>=db)},${f},${this._x1=t+i*Math.cos(s)},${this._y1=n+i*Math.sin(s)}`)
         }
         rect(t, n, i, r) {
             this._append`M${this._x0=this._x1=+t},${this._y0=this._y1=+n}h${i=+i}v${+r}h${-i}Z`
         }
         toString() {
             return this._
         }
     };
 
-    function km() {
-        return new l_
+    function om() {
+        return new Ax
     }
-    km.prototype = l_.prototype;
-    const za = 11102230246251565e-32,
-        on = 134217729,
-        DG = (3 + 8 * za) * za;
+    om.prototype = Ax.prototype;
+    const Ms = 11102230246251565e-32,
+        sn = 134217729,
+        Bj = (3 + 8 * Ms) * Ms;
 
-    function Hy(e, t, n, i, r) {
-        let a, s, o, l, u = t[0],
+    function Ey(e, t, n, i, r) {
+        let s, a, o, l, u = t[0],
             c = i[0],
             f = 0,
             h = 0;
-        c > u == c > -u ? (a = u, u = t[++f]) : (a = c, c = i[++h]);
+        c > u == c > -u ? (s = u, u = t[++f]) : (s = c, c = i[++h]);
         let d = 0;
         if (f < e && h < n)
-            for (c > u == c > -u ? (s = u + a, o = a - (s - u), u = t[++f]) : (s = c + a, o = a - (s - c), c = i[++h]), a = s, o !== 0 && (r[d++] = o); f < e && h < n;) c > u == c > -u ? (s = a + u, l = s - a, o = a - (s - l) + (u - l), u = t[++f]) : (s = a + c, l = s - a, o = a - (s - l) + (c - l), c = i[++h]), a = s, o !== 0 && (r[d++] = o);
-        for (; f < e;) s = a + u, l = s - a, o = a - (s - l) + (u - l), u = t[++f], a = s, o !== 0 && (r[d++] = o);
-        for (; h < n;) s = a + c, l = s - a, o = a - (s - l) + (c - l), c = i[++h], a = s, o !== 0 && (r[d++] = o);
-        return (a !== 0 || d === 0) && (r[d++] = a), d
+            for (c > u == c > -u ? (a = u + s, o = s - (a - u), u = t[++f]) : (a = c + s, o = s - (a - c), c = i[++h]), s = a, o !== 0 && (r[d++] = o); f < e && h < n;) c > u == c > -u ? (a = s + u, l = a - s, o = s - (a - l) + (u - l), u = t[++f]) : (a = s + c, l = a - s, o = s - (a - l) + (c - l), c = i[++h]), s = a, o !== 0 && (r[d++] = o);
+        for (; f < e;) a = s + u, l = a - s, o = s - (a - l) + (u - l), u = t[++f], s = a, o !== 0 && (r[d++] = o);
+        for (; h < n;) a = s + c, l = a - s, o = s - (a - l) + (c - l), c = i[++h], s = a, o !== 0 && (r[d++] = o);
+        return (s !== 0 || d === 0) && (r[d++] = s), d
     }
 
-    function RG(e, t) {
+    function jj(e, t) {
         let n = t[0];
         for (let i = 1; i < e; i++) n += t[i];
         return n
     }
 
-    function hd(e) {
+    function ed(e) {
         return new Float64Array(e)
     }
-    const PG = (3 + 16 * za) * za,
-        NG = (2 + 12 * za) * za,
-        LG = (9 + 64 * za) * za * za,
-        nu = hd(4),
-        Ck = hd(8),
-        kk = hd(12),
-        Ak = hd(16),
-        kn = hd(4);
-
-    function IG(e, t, n, i, r, a, s) {
-        let o, l, u, c, f, h, d, g, p, m, y, v, b, x, _, S, w, O;
-        const k = e - r,
+    const Uj = (3 + 16 * Ms) * Ms,
+        Gj = (2 + 12 * Ms) * Ms,
+        Wj = (9 + 64 * Ms) * Ms * Ms,
+        ql = ed(4),
+        Bk = ed(8),
+        jk = ed(12),
+        Uk = ed(16),
+        En = ed(4);
+
+    function qj(e, t, n, i, r, s, a) {
+        let o, l, u, c, f, h, d, g, p, m, y, v, b, x, _, S, w, E;
+        const A = e - r,
             C = n - r,
-            E = t - a,
-            T = i - a;
-        x = k * T, h = on * k, d = h - (h - k), g = k - d, h = on * T, p = h - (h - T), m = T - p, _ = g * m - (x - d * p - g * p - d * m), S = E * C, h = on * E, d = h - (h - E), g = E - d, h = on * C, p = h - (h - C), m = C - p, w = g * m - (S - d * p - g * p - d * m), y = _ - w, f = _ - y, nu[0] = _ - (y + f) + (f - w), v = x + y, f = v - x, b = x - (v - f) + (y - f), y = b - S, f = b - y, nu[1] = b - (y + f) + (f - S), O = v + y, f = O - v, nu[2] = v - (O - f) + (y - f), nu[3] = O;
-        let A = RG(4, nu),
-            F = NG * s;
-        if (A >= F || -A >= F || (f = e - k, o = e - (k + f) + (f - r), f = n - C, u = n - (C + f) + (f - r), f = t - E, l = t - (E + f) + (f - a), f = i - T, c = i - (T + f) + (f - a), o === 0 && l === 0 && u === 0 && c === 0) || (F = LG * s + DG * Math.abs(A), A += k * c + T * o - (E * u + C * l), A >= F || -A >= F)) return A;
-        x = o * T, h = on * o, d = h - (h - o), g = o - d, h = on * T, p = h - (h - T), m = T - p, _ = g * m - (x - d * p - g * p - d * m), S = l * C, h = on * l, d = h - (h - l), g = l - d, h = on * C, p = h - (h - C), m = C - p, w = g * m - (S - d * p - g * p - d * m), y = _ - w, f = _ - y, kn[0] = _ - (y + f) + (f - w), v = x + y, f = v - x, b = x - (v - f) + (y - f), y = b - S, f = b - y, kn[1] = b - (y + f) + (f - S), O = v + y, f = O - v, kn[2] = v - (O - f) + (y - f), kn[3] = O;
-        const $ = Hy(4, nu, 4, kn, Ck);
-        x = k * c, h = on * k, d = h - (h - k), g = k - d, h = on * c, p = h - (h - c), m = c - p, _ = g * m - (x - d * p - g * p - d * m), S = E * u, h = on * E, d = h - (h - E), g = E - d, h = on * u, p = h - (h - u), m = u - p, w = g * m - (S - d * p - g * p - d * m), y = _ - w, f = _ - y, kn[0] = _ - (y + f) + (f - w), v = x + y, f = v - x, b = x - (v - f) + (y - f), y = b - S, f = b - y, kn[1] = b - (y + f) + (f - S), O = v + y, f = O - v, kn[2] = v - (O - f) + (y - f), kn[3] = O;
-        const D = Hy($, Ck, 4, kn, kk);
-        x = o * c, h = on * o, d = h - (h - o), g = o - d, h = on * c, p = h - (h - c), m = c - p, _ = g * m - (x - d * p - g * p - d * m), S = l * u, h = on * l, d = h - (h - l), g = l - d, h = on * u, p = h - (h - u), m = u - p, w = g * m - (S - d * p - g * p - d * m), y = _ - w, f = _ - y, kn[0] = _ - (y + f) + (f - w), v = x + y, f = v - x, b = x - (v - f) + (y - f), y = b - S, f = b - y, kn[1] = b - (y + f) + (f - S), O = v + y, f = O - v, kn[2] = v - (O - f) + (y - f), kn[3] = O;
-        const P = Hy(D, kk, 4, kn, Ak);
-        return Ak[P - 1]
-    }
-
-    function yg(e, t, n, i, r, a) {
-        const s = (t - a) * (n - r),
-            o = (e - r) * (i - a),
-            l = s - o;
-        if (s === 0 || o === 0 || s > 0 != o > 0) return l;
-        const u = Math.abs(s + o);
-        return Math.abs(l) >= PG * u ? l : -IG(e, t, n, i, r, a, u)
-    }
-    const Tk = Math.pow(2, -52),
-        vg = new Uint32Array(512);
-    class Yp {
-        static from(t, n = UG, i = qG) {
+            k = t - s,
+            R = i - s;
+        x = A * R, h = sn * A, d = h - (h - A), g = A - d, h = sn * R, p = h - (h - R), m = R - p, _ = g * m - (x - d * p - g * p - d * m), S = k * C, h = sn * k, d = h - (h - k), g = k - d, h = sn * C, p = h - (h - C), m = C - p, w = g * m - (S - d * p - g * p - d * m), y = _ - w, f = _ - y, ql[0] = _ - (y + f) + (f - w), v = x + y, f = v - x, b = x - (v - f) + (y - f), y = b - S, f = b - y, ql[1] = b - (y + f) + (f - S), E = v + y, f = E - v, ql[2] = v - (E - f) + (y - f), ql[3] = E;
+        let $ = jj(4, ql),
+            T = Gj * a;
+        if ($ >= T || -$ >= T || (f = e - A, o = e - (A + f) + (f - r), f = n - C, u = n - (C + f) + (f - r), f = t - k, l = t - (k + f) + (f - s), f = i - R, c = i - (R + f) + (f - s), o === 0 && l === 0 && u === 0 && c === 0) || (T = Wj * a + Bj * Math.abs($), $ += A * c + R * o - (k * u + C * l), $ >= T || -$ >= T)) return $;
+        x = o * R, h = sn * o, d = h - (h - o), g = o - d, h = sn * R, p = h - (h - R), m = R - p, _ = g * m - (x - d * p - g * p - d * m), S = l * C, h = sn * l, d = h - (h - l), g = l - d, h = sn * C, p = h - (h - C), m = C - p, w = g * m - (S - d * p - g * p - d * m), y = _ - w, f = _ - y, En[0] = _ - (y + f) + (f - w), v = x + y, f = v - x, b = x - (v - f) + (y - f), y = b - S, f = b - y, En[1] = b - (y + f) + (f - S), E = v + y, f = E - v, En[2] = v - (E - f) + (y - f), En[3] = E;
+        const M = Ey(4, ql, 4, En, Bk);
+        x = A * c, h = sn * A, d = h - (h - A), g = A - d, h = sn * c, p = h - (h - c), m = c - p, _ = g * m - (x - d * p - g * p - d * m), S = k * u, h = sn * k, d = h - (h - k), g = k - d, h = sn * u, p = h - (h - u), m = u - p, w = g * m - (S - d * p - g * p - d * m), y = _ - w, f = _ - y, En[0] = _ - (y + f) + (f - w), v = x + y, f = v - x, b = x - (v - f) + (y - f), y = b - S, f = b - y, En[1] = b - (y + f) + (f - S), E = v + y, f = E - v, En[2] = v - (E - f) + (y - f), En[3] = E;
+        const F = Ey(M, Bk, 4, En, jk);
+        x = o * c, h = sn * o, d = h - (h - o), g = o - d, h = sn * c, p = h - (h - c), m = c - p, _ = g * m - (x - d * p - g * p - d * m), S = l * u, h = sn * l, d = h - (h - l), g = l - d, h = sn * u, p = h - (h - u), m = u - p, w = g * m - (S - d * p - g * p - d * m), y = _ - w, f = _ - y, En[0] = _ - (y + f) + (f - w), v = x + y, f = v - x, b = x - (v - f) + (y - f), y = b - S, f = b - y, En[1] = b - (y + f) + (f - S), E = v + y, f = E - v, En[2] = v - (E - f) + (y - f), En[3] = E;
+        const N = Ey(F, jk, 4, En, Uk);
+        return Uk[N - 1]
+    }
+
+    function ng(e, t, n, i, r, s) {
+        const a = (t - s) * (n - r),
+            o = (e - r) * (i - s),
+            l = a - o;
+        if (a === 0 || o === 0 || a > 0 != o > 0) return l;
+        const u = Math.abs(a + o);
+        return Math.abs(l) >= Uj * u ? l : -qj(e, t, n, i, r, s, u)
+    }
+    const Gk = Math.pow(2, -52),
+        ig = new Uint32Array(512);
+    class $p {
+        static from(t, n = Kj, i = Jj) {
             const r = t.length,
-                a = new Float64Array(r * 2);
-            for (let s = 0; s < r; s++) {
-                const o = t[s];
-                a[2 * s] = n(o), a[2 * s + 1] = i(o)
+                s = new Float64Array(r * 2);
+            for (let a = 0; a < r; a++) {
+                const o = t[a];
+                s[2 * a] = n(o), s[2 * a + 1] = i(o)
             }
-            return new Yp(a)
+            return new $p(s)
         }
         constructor(t) {
             const n = t.length >> 1;
             if (n > 0 && typeof t[0] != "number") throw new Error("Expected coords to contain numbers.");
             this.coords = t;
             const i = Math.max(2 * n - 5, 0);
             this._triangles = new Uint32Array(i * 3), this._halfedges = new Int32Array(i * 3), this._hashSize = Math.ceil(Math.sqrt(n)), this._hullPrev = new Uint32Array(n), this._hullNext = new Uint32Array(n), this._hullTri = new Uint32Array(n), this._hullHash = new Int32Array(this._hashSize).fill(-1), this._ids = new Uint32Array(n), this._dists = new Float64Array(n), this.update()
         }
         update() {
             const {
                 coords: t,
                 _hullPrev: n,
                 _hullNext: i,
                 _hullTri: r,
-                _hullHash: a
-            } = this, s = t.length >> 1;
+                _hullHash: s
+            } = this, a = t.length >> 1;
             let o = 1 / 0,
                 l = 1 / 0,
                 u = -1 / 0,
                 c = -1 / 0;
-            for (let C = 0; C < s; C++) {
-                const E = t[2 * C],
-                    T = t[2 * C + 1];
-                E < o && (o = E), T < l && (l = T), E > u && (u = E), T > c && (c = T), this._ids[C] = C
+            for (let C = 0; C < a; C++) {
+                const k = t[2 * C],
+                    R = t[2 * C + 1];
+                k < o && (o = k), R < l && (l = R), k > u && (u = k), R > c && (c = R), this._ids[C] = C
             }
             const f = (o + u) / 2,
                 h = (l + c) / 2;
             let d = 1 / 0,
                 g, p, m;
-            for (let C = 0; C < s; C++) {
-                const E = Yy(f, h, t[2 * C], t[2 * C + 1]);
-                E < d && (g = C, d = E)
+            for (let C = 0; C < a; C++) {
+                const k = Cy(f, h, t[2 * C], t[2 * C + 1]);
+                k < d && (g = C, d = k)
             }
             const y = t[2 * g],
                 v = t[2 * g + 1];
             d = 1 / 0;
-            for (let C = 0; C < s; C++) {
+            for (let C = 0; C < a; C++) {
                 if (C === g) continue;
-                const E = Yy(y, v, t[2 * C], t[2 * C + 1]);
-                E < d && E > 0 && (p = C, d = E)
+                const k = Cy(y, v, t[2 * C], t[2 * C + 1]);
+                k < d && k > 0 && (p = C, d = k)
             }
             let b = t[2 * p],
                 x = t[2 * p + 1],
                 _ = 1 / 0;
-            for (let C = 0; C < s; C++) {
+            for (let C = 0; C < a; C++) {
                 if (C === g || C === p) continue;
-                const E = BG(y, v, b, x, t[2 * C], t[2 * C + 1]);
-                E < _ && (m = C, _ = E)
+                const k = Xj(y, v, b, x, t[2 * C], t[2 * C + 1]);
+                k < _ && (m = C, _ = k)
             }
             let S = t[2 * m],
                 w = t[2 * m + 1];
             if (_ === 1 / 0) {
-                for (let T = 0; T < s; T++) this._dists[T] = t[2 * T] - t[0] || t[2 * T + 1] - t[1];
-                xu(this._ids, this._dists, 0, s - 1);
-                const C = new Uint32Array(s);
-                let E = 0;
-                for (let T = 0, A = -1 / 0; T < s; T++) {
-                    const F = this._ids[T];
-                    this._dists[F] > A && (C[E++] = F, A = this._dists[F])
+                for (let R = 0; R < a; R++) this._dists[R] = t[2 * R] - t[0] || t[2 * R + 1] - t[1];
+                uu(this._ids, this._dists, 0, a - 1);
+                const C = new Uint32Array(a);
+                let k = 0;
+                for (let R = 0, $ = -1 / 0; R < a; R++) {
+                    const T = this._ids[R];
+                    this._dists[T] > $ && (C[k++] = T, $ = this._dists[T])
                 }
-                this.hull = C.subarray(0, E), this.triangles = new Uint32Array(0), this.halfedges = new Uint32Array(0);
+                this.hull = C.subarray(0, k), this.triangles = new Uint32Array(0), this.halfedges = new Uint32Array(0);
                 return
             }
-            if (yg(y, v, b, x, S, w) < 0) {
+            if (ng(y, v, b, x, S, w) < 0) {
                 const C = p,
-                    E = b,
-                    T = x;
-                p = m, b = S, x = w, m = C, S = E, w = T
-            }
-            const O = GG(y, v, b, x, S, w);
-            this._cx = O.x, this._cy = O.y;
-            for (let C = 0; C < s; C++) this._dists[C] = Yy(t[2 * C], t[2 * C + 1], O.x, O.y);
-            xu(this._ids, this._dists, 0, s - 1), this._hullStart = g;
-            let k = 3;
-            i[g] = n[m] = p, i[p] = n[g] = m, i[m] = n[p] = g, r[g] = 0, r[p] = 1, r[m] = 2, a.fill(-1), a[this._hashKey(y, v)] = g, a[this._hashKey(b, x)] = p, a[this._hashKey(S, w)] = m, this.trianglesLen = 0, this._addTriangle(g, p, m, -1, -1, -1);
-            for (let C = 0, E, T; C < this._ids.length; C++) {
-                const A = this._ids[C],
-                    F = t[2 * A],
-                    $ = t[2 * A + 1];
-                if (C > 0 && Math.abs(F - E) <= Tk && Math.abs($ - T) <= Tk || (E = F, T = $, A === g || A === p || A === m)) continue;
-                let D = 0;
-                for (let ae = 0, ye = this._hashKey(F, $); ae < this._hashSize && (D = a[(ye + ae) % this._hashSize], !(D !== -1 && D !== i[D])); ae++);
-                D = n[D];
-                let P = D,
-                    N;
-                for (; N = i[P], yg(F, $, t[2 * P], t[2 * P + 1], t[2 * N], t[2 * N + 1]) >= 0;)
-                    if (P = N, P === D) {
-                        P = -1;
+                    k = b,
+                    R = x;
+                p = m, b = S, x = w, m = C, S = k, w = R
+            }
+            const E = Vj(y, v, b, x, S, w);
+            this._cx = E.x, this._cy = E.y;
+            for (let C = 0; C < a; C++) this._dists[C] = Cy(t[2 * C], t[2 * C + 1], E.x, E.y);
+            uu(this._ids, this._dists, 0, a - 1), this._hullStart = g;
+            let A = 3;
+            i[g] = n[m] = p, i[p] = n[g] = m, i[m] = n[p] = g, r[g] = 0, r[p] = 1, r[m] = 2, s.fill(-1), s[this._hashKey(y, v)] = g, s[this._hashKey(b, x)] = p, s[this._hashKey(S, w)] = m, this.trianglesLen = 0, this._addTriangle(g, p, m, -1, -1, -1);
+            for (let C = 0, k, R; C < this._ids.length; C++) {
+                const $ = this._ids[C],
+                    T = t[2 * $],
+                    M = t[2 * $ + 1];
+                if (C > 0 && Math.abs(T - k) <= Gk && Math.abs(M - R) <= Gk || (k = T, R = M, $ === g || $ === p || $ === m)) continue;
+                let F = 0;
+                for (let Q = 0, oe = this._hashKey(T, M); Q < this._hashSize && (F = s[(oe + Q) % this._hashSize], !(F !== -1 && F !== i[F])); Q++);
+                F = n[F];
+                let N = F,
+                    P;
+                for (; P = i[N], ng(T, M, t[2 * N], t[2 * N + 1], t[2 * P], t[2 * P + 1]) >= 0;)
+                    if (N = P, N === F) {
+                        N = -1;
                         break
-                    } if (P === -1) continue;
-                let z = this._addTriangle(P, A, i[P], -1, -1, r[P]);
-                r[A] = this._legalize(z + 2), r[P] = z, k++;
-                let I = i[P];
-                for (; N = i[I], yg(F, $, t[2 * I], t[2 * I + 1], t[2 * N], t[2 * N + 1]) < 0;) z = this._addTriangle(I, A, N, r[A], -1, r[I]), r[A] = this._legalize(z + 2), i[I] = I, k--, I = N;
-                if (P === D)
-                    for (; N = n[P], yg(F, $, t[2 * N], t[2 * N + 1], t[2 * P], t[2 * P + 1]) < 0;) z = this._addTriangle(N, A, P, -1, r[P], r[N]), this._legalize(z + 2), r[N] = z, i[P] = P, k--, P = N;
-                this._hullStart = n[A] = P, i[P] = n[I] = A, i[A] = I, a[this._hashKey(F, $)] = A, a[this._hashKey(t[2 * P], t[2 * P + 1])] = P
+                    } if (N === -1) continue;
+                let z = this._addTriangle(N, $, i[N], -1, -1, r[N]);
+                r[$] = this._legalize(z + 2), r[N] = z, A++;
+                let I = i[N];
+                for (; P = i[I], ng(T, M, t[2 * I], t[2 * I + 1], t[2 * P], t[2 * P + 1]) < 0;) z = this._addTriangle(I, $, P, r[$], -1, r[I]), r[$] = this._legalize(z + 2), i[I] = I, A--, I = P;
+                if (N === F)
+                    for (; P = n[N], ng(T, M, t[2 * P], t[2 * P + 1], t[2 * N], t[2 * N + 1]) < 0;) z = this._addTriangle(P, $, N, -1, r[N], r[P]), this._legalize(z + 2), r[P] = z, i[N] = N, A--, N = P;
+                this._hullStart = n[$] = N, i[N] = n[I] = $, i[$] = I, s[this._hashKey(T, M)] = $, s[this._hashKey(t[2 * N], t[2 * N + 1])] = N
             }
-            this.hull = new Uint32Array(k);
-            for (let C = 0, E = this._hullStart; C < k; C++) this.hull[C] = E, E = i[E];
+            this.hull = new Uint32Array(A);
+            for (let C = 0, k = this._hullStart; C < A; C++) this.hull[C] = k, k = i[k];
             this.triangles = this._triangles.subarray(0, this.trianglesLen), this.halfedges = this._halfedges.subarray(0, this.trianglesLen)
         }
         _hashKey(t, n) {
-            return Math.floor(jG(t - this._cx, n - this._cy) * this._hashSize) % this._hashSize
+            return Math.floor(Hj(t - this._cx, n - this._cy) * this._hashSize) % this._hashSize
         }
         _legalize(t) {
             const {
                 _triangles: n,
                 _halfedges: i,
                 coords: r
             } = this;
-            let a = 0,
-                s = 0;
+            let s = 0,
+                a = 0;
             for (;;) {
                 const o = i[t],
                     l = t - t % 3;
-                if (s = l + (t + 2) % 3, o === -1) {
-                    if (a === 0) break;
-                    t = vg[--a];
+                if (a = l + (t + 2) % 3, o === -1) {
+                    if (s === 0) break;
+                    t = ig[--s];
                     continue
                 }
                 const u = o - o % 3,
                     c = l + (t + 1) % 3,
                     f = u + (o + 2) % 3,
-                    h = n[s],
+                    h = n[a],
                     d = n[t],
                     g = n[c],
                     p = n[f];
-                if (zG(r[2 * h], r[2 * h + 1], r[2 * d], r[2 * d + 1], r[2 * g], r[2 * g + 1], r[2 * p], r[2 * p + 1])) {
+                if (Yj(r[2 * h], r[2 * h + 1], r[2 * d], r[2 * d + 1], r[2 * g], r[2 * g + 1], r[2 * p], r[2 * p + 1])) {
                     n[t] = p, n[o] = h;
                     const y = i[f];
                     if (y === -1) {
                         let b = this._hullStart;
                         do {
                             if (this._hullTri[b] === f) {
                                 this._hullTri[b] = t;
                                 break
                             }
                             b = this._hullPrev[b]
                         } while (b !== this._hullStart)
                     }
-                    this._link(t, y), this._link(o, i[s]), this._link(s, f);
+                    this._link(t, y), this._link(o, i[a]), this._link(a, f);
                     const v = u + (o + 1) % 3;
-                    a < vg.length && (vg[a++] = v)
+                    s < ig.length && (ig[s++] = v)
                 } else {
-                    if (a === 0) break;
-                    t = vg[--a]
+                    if (s === 0) break;
+                    t = ig[--s]
                 }
             }
-            return s
+            return a
         }
         _link(t, n) {
             this._halfedges[t] = n, n !== -1 && (this._halfedges[n] = t)
         }
-        _addTriangle(t, n, i, r, a, s) {
+        _addTriangle(t, n, i, r, s, a) {
             const o = this.trianglesLen;
-            return this._triangles[o] = t, this._triangles[o + 1] = n, this._triangles[o + 2] = i, this._link(o, r), this._link(o + 1, a), this._link(o + 2, s), this.trianglesLen += 3, o
+            return this._triangles[o] = t, this._triangles[o + 1] = n, this._triangles[o + 2] = i, this._link(o, r), this._link(o + 1, s), this._link(o + 2, a), this.trianglesLen += 3, o
         }
     }
 
-    function jG(e, t) {
+    function Hj(e, t) {
         const n = e / (Math.abs(e) + Math.abs(t));
         return (t > 0 ? 3 - n : 1 + n) / 4
     }
 
-    function Yy(e, t, n, i) {
+    function Cy(e, t, n, i) {
         const r = e - n,
-            a = t - i;
-        return r * r + a * a
+            s = t - i;
+        return r * r + s * s
     }
 
-    function zG(e, t, n, i, r, a, s, o) {
-        const l = e - s,
+    function Yj(e, t, n, i, r, s, a, o) {
+        const l = e - a,
             u = t - o,
-            c = n - s,
+            c = n - a,
             f = i - o,
-            h = r - s,
-            d = a - o,
+            h = r - a,
+            d = s - o,
             g = l * l + u * u,
             p = c * c + f * f,
             m = h * h + d * d;
         return l * (f * m - p * d) - u * (c * m - p * h) + g * (c * d - f * h) < 0
     }
 
-    function BG(e, t, n, i, r, a) {
-        const s = n - e,
+    function Xj(e, t, n, i, r, s) {
+        const a = n - e,
             o = i - t,
             l = r - e,
-            u = a - t,
-            c = s * s + o * o,
+            u = s - t,
+            c = a * a + o * o,
             f = l * l + u * u,
-            h = .5 / (s * u - o * l),
+            h = .5 / (a * u - o * l),
             d = (u * c - o * f) * h,
-            g = (s * f - l * c) * h;
+            g = (a * f - l * c) * h;
         return d * d + g * g
     }
 
-    function GG(e, t, n, i, r, a) {
-        const s = n - e,
+    function Vj(e, t, n, i, r, s) {
+        const a = n - e,
             o = i - t,
             l = r - e,
-            u = a - t,
-            c = s * s + o * o,
+            u = s - t,
+            c = a * a + o * o,
             f = l * l + u * u,
-            h = .5 / (s * u - o * l),
+            h = .5 / (a * u - o * l),
             d = e + (u * c - o * f) * h,
-            g = t + (s * f - l * c) * h;
+            g = t + (a * f - l * c) * h;
         return {
             x: d,
             y: g
         }
     }
 
-    function xu(e, t, n, i) {
+    function uu(e, t, n, i) {
         if (i - n <= 20)
             for (let r = n + 1; r <= i; r++) {
-                const a = e[r],
-                    s = t[a];
+                const s = e[r],
+                    a = t[s];
                 let o = r - 1;
-                for (; o >= n && t[e[o]] > s;) e[o + 1] = e[o--];
-                e[o + 1] = a
+                for (; o >= n && t[e[o]] > a;) e[o + 1] = e[o--];
+                e[o + 1] = s
             } else {
                 const r = n + i >> 1;
-                let a = n + 1,
-                    s = i;
-                sf(e, r, a), t[e[n]] > t[e[i]] && sf(e, n, i), t[e[a]] > t[e[i]] && sf(e, a, i), t[e[n]] > t[e[a]] && sf(e, n, a);
-                const o = e[a],
+                let s = n + 1,
+                    a = i;
+                Hc(e, r, s), t[e[n]] > t[e[i]] && Hc(e, n, i), t[e[s]] > t[e[i]] && Hc(e, s, i), t[e[n]] > t[e[s]] && Hc(e, n, s);
+                const o = e[s],
                     l = t[o];
                 for (;;) {
-                    do a++; while (t[e[a]] < l);
-                    do s--; while (t[e[s]] > l);
-                    if (s < a) break;
-                    sf(e, a, s)
+                    do s++; while (t[e[s]] < l);
+                    do a--; while (t[e[a]] > l);
+                    if (a < s) break;
+                    Hc(e, s, a)
                 }
-                e[n + 1] = e[s], e[s] = o, i - a + 1 >= s - n ? (xu(e, t, a, i), xu(e, t, n, s - 1)) : (xu(e, t, n, s - 1), xu(e, t, a, i))
+                e[n + 1] = e[a], e[a] = o, i - s + 1 >= a - n ? (uu(e, t, s, i), uu(e, t, n, a - 1)) : (uu(e, t, n, a - 1), uu(e, t, s, i))
             }
     }
 
-    function sf(e, t, n) {
+    function Hc(e, t, n) {
         const i = e[t];
         e[t] = e[n], e[n] = i
     }
 
-    function UG(e) {
+    function Kj(e) {
         return e[0]
     }
 
-    function qG(e) {
+    function Jj(e) {
         return e[1]
     }
-    const $k = 1e-6;
-    class Yo {
+    const Wk = 1e-6;
+    class No {
         constructor() {
             this._x0 = this._y0 = this._x1 = this._y1 = null, this._ = ""
         }
         moveTo(t, n) {
             this._ += `M${this._x0=this._x1=+t},${this._y0=this._y1=+n}`
         }
         closePath() {
@@ -9042,26 +9042,26 @@
         }
         lineTo(t, n) {
             this._ += `L${this._x1=+t},${this._y1=+n}`
         }
         arc(t, n, i) {
             t = +t, n = +n, i = +i;
             const r = t + i,
-                a = n;
+                s = n;
             if (i < 0) throw new Error("negative radius");
-            this._x1 === null ? this._ += `M${r},${a}` : (Math.abs(this._x1 - r) > $k || Math.abs(this._y1 - a) > $k) && (this._ += "L" + r + "," + a), i && (this._ += `A${i},${i},0,1,1,${t-i},${n}A${i},${i},0,1,1,${this._x1=r},${this._y1=a}`)
+            this._x1 === null ? this._ += `M${r},${s}` : (Math.abs(this._x1 - r) > Wk || Math.abs(this._y1 - s) > Wk) && (this._ += "L" + r + "," + s), i && (this._ += `A${i},${i},0,1,1,${t-i},${n}A${i},${i},0,1,1,${this._x1=r},${this._y1=s}`)
         }
         rect(t, n, i, r) {
             this._ += `M${this._x0=this._x1=+t},${this._y0=this._y1=+n}h${+i}v${+r}h${-i}Z`
         }
         value() {
             return this._ || null
         }
     }
-    class Bb {
+    class pb {
         constructor() {
             this._ = []
         }
         moveTo(t, n) {
             this._.push([t, n])
         }
         closePath() {
@@ -9070,273 +9070,273 @@
         lineTo(t, n) {
             this._.push([t, n])
         }
         value() {
             return this._.length ? this._ : null
         }
     }
-    let WG = class {
-        constructor(t, [n, i, r, a] = [0, 0, 960, 500]) {
-            if (!((r = +r) >= (n = +n)) || !((a = +a) >= (i = +i))) throw new Error("invalid bounds");
-            this.delaunay = t, this._circumcenters = new Float64Array(t.points.length * 2), this.vectors = new Float64Array(t.points.length * 2), this.xmax = r, this.xmin = n, this.ymax = a, this.ymin = i, this._init()
+    let Qj = class {
+        constructor(t, [n, i, r, s] = [0, 0, 960, 500]) {
+            if (!((r = +r) >= (n = +n)) || !((s = +s) >= (i = +i))) throw new Error("invalid bounds");
+            this.delaunay = t, this._circumcenters = new Float64Array(t.points.length * 2), this.vectors = new Float64Array(t.points.length * 2), this.xmax = r, this.xmin = n, this.ymax = s, this.ymin = i, this._init()
         }
         update() {
             return this.delaunay.update(), this._init(), this
         }
         _init() {
             const {
                 delaunay: {
                     points: t,
                     hull: n,
                     triangles: i
                 },
                 vectors: r
             } = this;
-            let a, s;
+            let s, a;
             const o = this.circumcenters = this._circumcenters.subarray(0, i.length / 3 * 2);
             for (let p = 0, m = 0, y = i.length, v, b; p < y; p += 3, m += 2) {
                 const x = i[p] * 2,
                     _ = i[p + 1] * 2,
                     S = i[p + 2] * 2,
                     w = t[x],
-                    O = t[x + 1],
-                    k = t[_],
+                    E = t[x + 1],
+                    A = t[_],
                     C = t[_ + 1],
-                    E = t[S],
-                    T = t[S + 1],
-                    A = k - w,
-                    F = C - O,
-                    $ = E - w,
-                    D = T - O,
-                    P = (A * D - F * $) * 2;
-                if (Math.abs(P) < 1e-9) {
-                    if (a === void 0) {
-                        a = s = 0;
-                        for (const z of n) a += t[z * 2], s += t[z * 2 + 1];
-                        a /= n.length, s /= n.length
+                    k = t[S],
+                    R = t[S + 1],
+                    $ = A - w,
+                    T = C - E,
+                    M = k - w,
+                    F = R - E,
+                    N = ($ * F - T * M) * 2;
+                if (Math.abs(N) < 1e-9) {
+                    if (s === void 0) {
+                        s = a = 0;
+                        for (const z of n) s += t[z * 2], a += t[z * 2 + 1];
+                        s /= n.length, a /= n.length
                     }
-                    const N = 1e9 * Math.sign((a - w) * D - (s - O) * $);
-                    v = (w + E) / 2 - N * D, b = (O + T) / 2 + N * $
+                    const P = 1e9 * Math.sign((s - w) * F - (a - E) * M);
+                    v = (w + k) / 2 - P * F, b = (E + R) / 2 + P * M
                 } else {
-                    const N = 1 / P,
-                        z = A * A + F * F,
-                        I = $ * $ + D * D;
-                    v = w + (D * z - F * I) * N, b = O + (A * I - $ * z) * N
+                    const P = 1 / N,
+                        z = $ * $ + T * T,
+                        I = M * M + F * F;
+                    v = w + (F * z - T * I) * P, b = E + ($ * I - M * z) * P
                 }
                 o[m] = v, o[m + 1] = b
             }
             let l = n[n.length - 1],
                 u, c = l * 4,
                 f, h = t[2 * l],
                 d, g = t[2 * l + 1];
             r.fill(0);
             for (let p = 0; p < n.length; ++p) l = n[p], u = c, f = h, d = g, c = l * 4, h = t[2 * l], g = t[2 * l + 1], r[u + 2] = r[c] = d - g, r[u + 3] = r[c + 1] = h - f
         }
         render(t) {
-            const n = t == null ? t = new Yo : void 0,
+            const n = t == null ? t = new No : void 0,
                 {
                     delaunay: {
                         halfedges: i,
                         inedges: r,
-                        hull: a
+                        hull: s
                     },
-                    circumcenters: s,
+                    circumcenters: a,
                     vectors: o
                 } = this;
-            if (a.length <= 1) return null;
+            if (s.length <= 1) return null;
             for (let c = 0, f = i.length; c < f; ++c) {
                 const h = i[c];
                 if (h < c) continue;
                 const d = Math.floor(c / 3) * 2,
                     g = Math.floor(h / 3) * 2,
-                    p = s[d],
-                    m = s[d + 1],
-                    y = s[g],
-                    v = s[g + 1];
+                    p = a[d],
+                    m = a[d + 1],
+                    y = a[g],
+                    v = a[g + 1];
                 this._renderSegment(p, m, y, v, t)
             }
-            let l, u = a[a.length - 1];
-            for (let c = 0; c < a.length; ++c) {
-                l = u, u = a[c];
+            let l, u = s[s.length - 1];
+            for (let c = 0; c < s.length; ++c) {
+                l = u, u = s[c];
                 const f = Math.floor(r[u] / 3) * 2,
-                    h = s[f],
-                    d = s[f + 1],
+                    h = a[f],
+                    d = a[f + 1],
                     g = l * 4,
                     p = this._project(h, d, o[g + 2], o[g + 3]);
                 p && this._renderSegment(h, d, p[0], p[1], t)
             }
             return n && n.value()
         }
         renderBounds(t) {
-            const n = t == null ? t = new Yo : void 0;
+            const n = t == null ? t = new No : void 0;
             return t.rect(this.xmin, this.ymin, this.xmax - this.xmin, this.ymax - this.ymin), n && n.value()
         }
         renderCell(t, n) {
-            const i = n == null ? n = new Yo : void 0,
+            const i = n == null ? n = new No : void 0,
                 r = this._clip(t);
             if (r === null || !r.length) return;
             n.moveTo(r[0], r[1]);
-            let a = r.length;
-            for (; r[0] === r[a - 2] && r[1] === r[a - 1] && a > 1;) a -= 2;
-            for (let s = 2; s < a; s += 2)(r[s] !== r[s - 2] || r[s + 1] !== r[s - 1]) && n.lineTo(r[s], r[s + 1]);
+            let s = r.length;
+            for (; r[0] === r[s - 2] && r[1] === r[s - 1] && s > 1;) s -= 2;
+            for (let a = 2; a < s; a += 2)(r[a] !== r[a - 2] || r[a + 1] !== r[a - 1]) && n.lineTo(r[a], r[a + 1]);
             return n.closePath(), i && i.value()
         }* cellPolygons() {
             const {
                 delaunay: {
                     points: t
                 }
             } = this;
             for (let n = 0, i = t.length / 2; n < i; ++n) {
                 const r = this.cellPolygon(n);
                 r && (r.index = n, yield r)
             }
         }
         cellPolygon(t) {
-            const n = new Bb;
+            const n = new pb;
             return this.renderCell(t, n), n.value()
         }
-        _renderSegment(t, n, i, r, a) {
-            let s;
+        _renderSegment(t, n, i, r, s) {
+            let a;
             const o = this._regioncode(t, n),
                 l = this._regioncode(i, r);
-            o === 0 && l === 0 ? (a.moveTo(t, n), a.lineTo(i, r)) : (s = this._clipSegment(t, n, i, r, o, l)) && (a.moveTo(s[0], s[1]), a.lineTo(s[2], s[3]))
+            o === 0 && l === 0 ? (s.moveTo(t, n), s.lineTo(i, r)) : (a = this._clipSegment(t, n, i, r, o, l)) && (s.moveTo(a[0], a[1]), s.lineTo(a[2], a[3]))
         }
         contains(t, n, i) {
             return n = +n, n !== n || (i = +i, i !== i) ? !1 : this.delaunay._step(t, n, i) === t
         }* neighbors(t) {
             const n = this._clip(t);
             if (n)
                 for (const i of this.delaunay.neighbors(t)) {
                     const r = this._clip(i);
                     if (r) {
-                        e: for (let a = 0, s = n.length; a < s; a += 2)
+                        e: for (let s = 0, a = n.length; s < a; s += 2)
                             for (let o = 0, l = r.length; o < l; o += 2)
-                                if (n[a] === r[o] && n[a + 1] === r[o + 1] && n[(a + 2) % s] === r[(o + l - 2) % l] && n[(a + 3) % s] === r[(o + l - 1) % l]) {
+                                if (n[s] === r[o] && n[s + 1] === r[o + 1] && n[(s + 2) % a] === r[(o + l - 2) % l] && n[(s + 3) % a] === r[(o + l - 1) % l]) {
                                     yield i;
                                     break e
                                 }
                     }
                 }
         }
         _cell(t) {
             const {
                 circumcenters: n,
                 delaunay: {
                     inedges: i,
                     halfedges: r,
-                    triangles: a
+                    triangles: s
                 }
-            } = this, s = i[t];
-            if (s === -1) return null;
+            } = this, a = i[t];
+            if (a === -1) return null;
             const o = [];
-            let l = s;
+            let l = a;
             do {
                 const u = Math.floor(l / 3);
-                if (o.push(n[u * 2], n[u * 2 + 1]), l = l % 3 === 2 ? l - 2 : l + 1, a[l] !== t) break;
+                if (o.push(n[u * 2], n[u * 2 + 1]), l = l % 3 === 2 ? l - 2 : l + 1, s[l] !== t) break;
                 l = r[l]
-            } while (l !== s && l !== -1);
+            } while (l !== a && l !== -1);
             return o
         }
         _clip(t) {
             if (t === 0 && this.delaunay.hull.length === 1) return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];
             const n = this._cell(t);
             if (n === null) return null;
             const {
                 vectors: i
             } = this, r = t * 4;
             return this._simplify(i[r] || i[r + 1] ? this._clipInfinite(t, n, i[r], i[r + 1], i[r + 2], i[r + 3]) : this._clipFinite(t, n))
         }
         _clipFinite(t, n) {
             const i = n.length;
             let r = null,
-                a, s, o = n[i - 2],
+                s, a, o = n[i - 2],
                 l = n[i - 1],
                 u, c = this._regioncode(o, l),
                 f, h = 0;
             for (let d = 0; d < i; d += 2)
-                if (a = o, s = l, o = n[d], l = n[d + 1], u = c, c = this._regioncode(o, l), u === 0 && c === 0) f = h, h = 0, r ? r.push(o, l) : r = [o, l];
+                if (s = o, a = l, o = n[d], l = n[d + 1], u = c, c = this._regioncode(o, l), u === 0 && c === 0) f = h, h = 0, r ? r.push(o, l) : r = [o, l];
                 else {
                     let g, p, m, y, v;
                     if (u === 0) {
-                        if ((g = this._clipSegment(a, s, o, l, u, c)) === null) continue;
+                        if ((g = this._clipSegment(s, a, o, l, u, c)) === null) continue;
                         [p, m, y, v] = g
                     } else {
-                        if ((g = this._clipSegment(o, l, a, s, c, u)) === null) continue;
+                        if ((g = this._clipSegment(o, l, s, a, c, u)) === null) continue;
                         [y, v, p, m] = g, f = h, h = this._edgecode(p, m), f && h && this._edge(t, f, h, r, r.length), r ? r.push(p, m) : r = [p, m]
                     }
                     f = h, h = this._edgecode(y, v), f && h && this._edge(t, f, h, r, r.length), r ? r.push(y, v) : r = [y, v]
                 } if (r) f = h, h = this._edgecode(r[0], r[1]), f && h && this._edge(t, f, h, r, r.length);
             else if (this.contains(t, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2)) return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];
             return r
         }
-        _clipSegment(t, n, i, r, a, s) {
-            const o = a < s;
-            for (o && ([t, n, i, r, a, s] = [i, r, t, n, s, a]);;) {
-                if (a === 0 && s === 0) return o ? [i, r, t, n] : [t, n, i, r];
-                if (a & s) return null;
-                let l, u, c = a || s;
-                c & 8 ? (l = t + (i - t) * (this.ymax - n) / (r - n), u = this.ymax) : c & 4 ? (l = t + (i - t) * (this.ymin - n) / (r - n), u = this.ymin) : c & 2 ? (u = n + (r - n) * (this.xmax - t) / (i - t), l = this.xmax) : (u = n + (r - n) * (this.xmin - t) / (i - t), l = this.xmin), a ? (t = l, n = u, a = this._regioncode(t, n)) : (i = l, r = u, s = this._regioncode(i, r))
+        _clipSegment(t, n, i, r, s, a) {
+            const o = s < a;
+            for (o && ([t, n, i, r, s, a] = [i, r, t, n, a, s]);;) {
+                if (s === 0 && a === 0) return o ? [i, r, t, n] : [t, n, i, r];
+                if (s & a) return null;
+                let l, u, c = s || a;
+                c & 8 ? (l = t + (i - t) * (this.ymax - n) / (r - n), u = this.ymax) : c & 4 ? (l = t + (i - t) * (this.ymin - n) / (r - n), u = this.ymin) : c & 2 ? (u = n + (r - n) * (this.xmax - t) / (i - t), l = this.xmax) : (u = n + (r - n) * (this.xmin - t) / (i - t), l = this.xmin), s ? (t = l, n = u, s = this._regioncode(t, n)) : (i = l, r = u, a = this._regioncode(i, r))
             }
         }
-        _clipInfinite(t, n, i, r, a, s) {
+        _clipInfinite(t, n, i, r, s, a) {
             let o = Array.from(n),
                 l;
-            if ((l = this._project(o[0], o[1], i, r)) && o.unshift(l[0], l[1]), (l = this._project(o[o.length - 2], o[o.length - 1], a, s)) && o.push(l[0], l[1]), o = this._clipFinite(t, o))
+            if ((l = this._project(o[0], o[1], i, r)) && o.unshift(l[0], l[1]), (l = this._project(o[o.length - 2], o[o.length - 1], s, a)) && o.push(l[0], l[1]), o = this._clipFinite(t, o))
                 for (let u = 0, c = o.length, f, h = this._edgecode(o[c - 2], o[c - 1]); u < c; u += 2) f = h, h = this._edgecode(o[u], o[u + 1]), f && h && (u = this._edge(t, f, h, o, u), c = o.length);
             else this.contains(t, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2) && (o = [this.xmin, this.ymin, this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax]);
             return o
         }
-        _edge(t, n, i, r, a) {
+        _edge(t, n, i, r, s) {
             for (; n !== i;) {
-                let s, o;
+                let a, o;
                 switch (n) {
                     case 5:
                         n = 4;
                         continue;
                     case 4:
-                        n = 6, s = this.xmax, o = this.ymin;
+                        n = 6, a = this.xmax, o = this.ymin;
                         break;
                     case 6:
                         n = 2;
                         continue;
                     case 2:
-                        n = 10, s = this.xmax, o = this.ymax;
+                        n = 10, a = this.xmax, o = this.ymax;
                         break;
                     case 10:
                         n = 8;
                         continue;
                     case 8:
-                        n = 9, s = this.xmin, o = this.ymax;
+                        n = 9, a = this.xmin, o = this.ymax;
                         break;
                     case 9:
                         n = 1;
                         continue;
                     case 1:
-                        n = 5, s = this.xmin, o = this.ymin;
+                        n = 5, a = this.xmin, o = this.ymin;
                         break
-                }(r[a] !== s || r[a + 1] !== o) && this.contains(t, s, o) && (r.splice(a, 0, s, o), a += 2)
+                }(r[s] !== a || r[s + 1] !== o) && this.contains(t, a, o) && (r.splice(s, 0, a, o), s += 2)
             }
-            return a
+            return s
         }
         _project(t, n, i, r) {
-            let a = 1 / 0,
-                s, o, l;
+            let s = 1 / 0,
+                a, o, l;
             if (r < 0) {
                 if (n <= this.ymin) return null;
-                (s = (this.ymin - n) / r) < a && (l = this.ymin, o = t + (a = s) * i)
+                (a = (this.ymin - n) / r) < s && (l = this.ymin, o = t + (s = a) * i)
             } else if (r > 0) {
                 if (n >= this.ymax) return null;
-                (s = (this.ymax - n) / r) < a && (l = this.ymax, o = t + (a = s) * i)
+                (a = (this.ymax - n) / r) < s && (l = this.ymax, o = t + (s = a) * i)
             }
             if (i > 0) {
                 if (t >= this.xmax) return null;
-                (s = (this.xmax - t) / i) < a && (o = this.xmax, l = n + (a = s) * r)
+                (a = (this.xmax - t) / i) < s && (o = this.xmax, l = n + (s = a) * r)
             } else if (i < 0) {
                 if (t <= this.xmin) return null;
-                (s = (this.xmin - t) / i) < a && (o = this.xmin, l = n + (a = s) * r)
+                (a = (this.xmin - t) / i) < s && (o = this.xmin, l = n + (s = a) * r)
             }
             return [o, l]
         }
         _edgecode(t, n) {
             return (t === this.xmin ? 1 : t === this.xmax ? 2 : 0) | (n === this.ymin ? 4 : n === this.ymax ? 8 : 0)
         }
         _regioncode(t, n) {
@@ -9350,664 +9350,664 @@
                     (t[n] === t[i] && t[i] === t[r] || t[n + 1] === t[i + 1] && t[i + 1] === t[r + 1]) && (t.splice(i, 2), n -= 2)
                 }
                 t.length || (t = null)
             }
             return t
         }
     };
-    const HG = 2 * Math.PI,
-        iu = Math.pow;
+    const Zj = 2 * Math.PI,
+        Hl = Math.pow;
 
-    function YG(e) {
+    function eU(e) {
         return e[0]
     }
 
-    function XG(e) {
+    function tU(e) {
         return e[1]
     }
 
-    function VG(e) {
+    function nU(e) {
         const {
             triangles: t,
             coords: n
         } = e;
         for (let i = 0; i < t.length; i += 3) {
             const r = 2 * t[i],
-                a = 2 * t[i + 1],
-                s = 2 * t[i + 2];
-            if ((n[s] - n[r]) * (n[a + 1] - n[r + 1]) - (n[a] - n[r]) * (n[s + 1] - n[r + 1]) > 1e-10) return !1
+                s = 2 * t[i + 1],
+                a = 2 * t[i + 2];
+            if ((n[a] - n[r]) * (n[s + 1] - n[r + 1]) - (n[s] - n[r]) * (n[a + 1] - n[r + 1]) > 1e-10) return !1
         }
         return !0
     }
 
-    function KG(e, t, n) {
+    function iU(e, t, n) {
         return [e + Math.sin(e + t) * n, t + Math.cos(e - t) * n]
     }
-    class u_ {
-        static from(t, n = YG, i = XG, r) {
-            return new u_("length" in t ? JG(t, n, i, r) : Float64Array.from(QG(t, n, i, r)))
+    class $x {
+        static from(t, n = eU, i = tU, r) {
+            return new $x("length" in t ? rU(t, n, i, r) : Float64Array.from(sU(t, n, i, r)))
         }
         constructor(t) {
-            this._delaunator = new Yp(t), this.inedges = new Int32Array(t.length / 2), this._hullIndex = new Int32Array(t.length / 2), this.points = this._delaunator.coords, this._init()
+            this._delaunator = new $p(t), this.inedges = new Int32Array(t.length / 2), this._hullIndex = new Int32Array(t.length / 2), this.points = this._delaunator.coords, this._init()
         }
         update() {
             return this._delaunator.update(), this._init(), this
         }
         _init() {
             const t = this._delaunator,
                 n = this.points;
-            if (t.hull && t.hull.length > 2 && VG(t)) {
+            if (t.hull && t.hull.length > 2 && nU(t)) {
                 this.collinear = Int32Array.from({
                     length: n.length / 2
                 }, (h, d) => d).sort((h, d) => n[2 * h] - n[2 * d] || n[2 * h + 1] - n[2 * d + 1]);
                 const l = this.collinear[0],
                     u = this.collinear[this.collinear.length - 1],
                     c = [n[2 * l], n[2 * l + 1], n[2 * u], n[2 * u + 1]],
                     f = 1e-8 * Math.hypot(c[3] - c[1], c[2] - c[0]);
                 for (let h = 0, d = n.length / 2; h < d; ++h) {
-                    const g = KG(n[2 * h], n[2 * h + 1], f);
+                    const g = iU(n[2 * h], n[2 * h + 1], f);
                     n[2 * h] = g[0], n[2 * h + 1] = g[1]
                 }
-                this._delaunator = new Yp(n)
+                this._delaunator = new $p(n)
             } else delete this.collinear;
             const i = this.halfedges = this._delaunator.halfedges,
                 r = this.hull = this._delaunator.hull,
-                a = this.triangles = this._delaunator.triangles,
-                s = this.inedges.fill(-1),
+                s = this.triangles = this._delaunator.triangles,
+                a = this.inedges.fill(-1),
                 o = this._hullIndex.fill(-1);
             for (let l = 0, u = i.length; l < u; ++l) {
-                const c = a[l % 3 === 2 ? l - 2 : l + 1];
-                (i[l] === -1 || s[c] === -1) && (s[c] = l)
+                const c = s[l % 3 === 2 ? l - 2 : l + 1];
+                (i[l] === -1 || a[c] === -1) && (a[c] = l)
             }
             for (let l = 0, u = r.length; l < u; ++l) o[r[l]] = l;
-            r.length <= 2 && r.length > 0 && (this.triangles = new Int32Array(3).fill(-1), this.halfedges = new Int32Array(3).fill(-1), this.triangles[0] = r[0], s[r[0]] = 1, r.length === 2 && (s[r[1]] = 0, this.triangles[1] = r[1], this.triangles[2] = r[1]))
+            r.length <= 2 && r.length > 0 && (this.triangles = new Int32Array(3).fill(-1), this.halfedges = new Int32Array(3).fill(-1), this.triangles[0] = r[0], a[r[0]] = 1, r.length === 2 && (a[r[1]] = 0, this.triangles[1] = r[1], this.triangles[2] = r[1]))
         }
         voronoi(t) {
-            return new WG(this, t)
+            return new Qj(this, t)
         }* neighbors(t) {
             const {
                 inedges: n,
                 hull: i,
                 _hullIndex: r,
-                halfedges: a,
-                triangles: s,
+                halfedges: s,
+                triangles: a,
                 collinear: o
             } = this;
             if (o) {
                 const f = o.indexOf(t);
                 f > 0 && (yield o[f - 1]), f < o.length - 1 && (yield o[f + 1]);
                 return
             }
             const l = n[t];
             if (l === -1) return;
             let u = l,
                 c = -1;
             do {
-                if (yield c = s[u], u = u % 3 === 2 ? u - 2 : u + 1, s[u] !== t) return;
-                if (u = a[u], u === -1) {
+                if (yield c = a[u], u = u % 3 === 2 ? u - 2 : u + 1, a[u] !== t) return;
+                if (u = s[u], u === -1) {
                     const f = i[(r[t] + 1) % i.length];
                     f !== c && (yield f);
                     return
                 }
             } while (u !== l)
         }
         find(t, n, i = 0) {
             if (t = +t, t !== t || (n = +n, n !== n)) return -1;
             const r = i;
-            let a;
+            let s;
             for (;
-                (a = this._step(i, t, n)) >= 0 && a !== i && a !== r;) i = a;
-            return a
+                (s = this._step(i, t, n)) >= 0 && s !== i && s !== r;) i = s;
+            return s
         }
         _step(t, n, i) {
             const {
                 inedges: r,
-                hull: a,
-                _hullIndex: s,
+                hull: s,
+                _hullIndex: a,
                 halfedges: o,
                 triangles: l,
                 points: u
             } = this;
             if (r[t] === -1 || !u.length) return (t + 1) % (u.length >> 1);
             let c = t,
-                f = iu(n - u[t * 2], 2) + iu(i - u[t * 2 + 1], 2);
+                f = Hl(n - u[t * 2], 2) + Hl(i - u[t * 2 + 1], 2);
             const h = r[t];
             let d = h;
             do {
                 let g = l[d];
-                const p = iu(n - u[g * 2], 2) + iu(i - u[g * 2 + 1], 2);
+                const p = Hl(n - u[g * 2], 2) + Hl(i - u[g * 2 + 1], 2);
                 if (p < f && (f = p, c = g), d = d % 3 === 2 ? d - 2 : d + 1, l[d] !== t) break;
                 if (d = o[d], d === -1) {
-                    if (d = a[(s[t] + 1) % a.length], d !== g && iu(n - u[d * 2], 2) + iu(i - u[d * 2 + 1], 2) < f) return d;
+                    if (d = s[(a[t] + 1) % s.length], d !== g && Hl(n - u[d * 2], 2) + Hl(i - u[d * 2 + 1], 2) < f) return d;
                     break
                 }
             } while (d !== h);
             return c
         }
         render(t) {
-            const n = t == null ? t = new Yo : void 0,
+            const n = t == null ? t = new No : void 0,
                 {
                     points: i,
                     halfedges: r,
-                    triangles: a
+                    triangles: s
                 } = this;
-            for (let s = 0, o = r.length; s < o; ++s) {
-                const l = r[s];
-                if (l < s) continue;
-                const u = a[s] * 2,
-                    c = a[l] * 2;
+            for (let a = 0, o = r.length; a < o; ++a) {
+                const l = r[a];
+                if (l < a) continue;
+                const u = s[a] * 2,
+                    c = s[l] * 2;
                 t.moveTo(i[u], i[u + 1]), t.lineTo(i[c], i[c + 1])
             }
             return this.renderHull(t), n && n.value()
         }
         renderPoints(t, n) {
             n === void 0 && (!t || typeof t.moveTo != "function") && (n = t, t = null), n = n == null ? 2 : +n;
-            const i = t == null ? t = new Yo : void 0,
+            const i = t == null ? t = new No : void 0,
                 {
                     points: r
                 } = this;
-            for (let a = 0, s = r.length; a < s; a += 2) {
-                const o = r[a],
-                    l = r[a + 1];
-                t.moveTo(o + n, l), t.arc(o, l, n, 0, HG)
+            for (let s = 0, a = r.length; s < a; s += 2) {
+                const o = r[s],
+                    l = r[s + 1];
+                t.moveTo(o + n, l), t.arc(o, l, n, 0, Zj)
             }
             return i && i.value()
         }
         renderHull(t) {
-            const n = t == null ? t = new Yo : void 0,
+            const n = t == null ? t = new No : void 0,
                 {
                     hull: i,
                     points: r
                 } = this,
-                a = i[0] * 2,
-                s = i.length;
-            t.moveTo(r[a], r[a + 1]);
-            for (let o = 1; o < s; ++o) {
+                s = i[0] * 2,
+                a = i.length;
+            t.moveTo(r[s], r[s + 1]);
+            for (let o = 1; o < a; ++o) {
                 const l = 2 * i[o];
                 t.lineTo(r[l], r[l + 1])
             }
             return t.closePath(), n && n.value()
         }
         hullPolygon() {
-            const t = new Bb;
+            const t = new pb;
             return this.renderHull(t), t.value()
         }
         renderTriangle(t, n) {
-            const i = n == null ? n = new Yo : void 0,
+            const i = n == null ? n = new No : void 0,
                 {
                     points: r,
-                    triangles: a
+                    triangles: s
                 } = this,
-                s = a[t *= 3] * 2,
-                o = a[t + 1] * 2,
-                l = a[t + 2] * 2;
-            return n.moveTo(r[s], r[s + 1]), n.lineTo(r[o], r[o + 1]), n.lineTo(r[l], r[l + 1]), n.closePath(), i && i.value()
+                a = s[t *= 3] * 2,
+                o = s[t + 1] * 2,
+                l = s[t + 2] * 2;
+            return n.moveTo(r[a], r[a + 1]), n.lineTo(r[o], r[o + 1]), n.lineTo(r[l], r[l + 1]), n.closePath(), i && i.value()
         }* trianglePolygons() {
             const {
                 triangles: t
             } = this;
             for (let n = 0, i = t.length / 3; n < i; ++n) yield this.trianglePolygon(n)
         }
         trianglePolygon(t) {
-            const n = new Bb;
+            const n = new pb;
             return this.renderTriangle(t, n), n.value()
         }
     }
 
-    function JG(e, t, n, i) {
+    function rU(e, t, n, i) {
         const r = e.length,
-            a = new Float64Array(r * 2);
-        for (let s = 0; s < r; ++s) {
-            const o = e[s];
-            a[s * 2] = t.call(i, o, s, e), a[s * 2 + 1] = n.call(i, o, s, e)
+            s = new Float64Array(r * 2);
+        for (let a = 0; a < r; ++a) {
+            const o = e[a];
+            s[a * 2] = t.call(i, o, a, e), s[a * 2 + 1] = n.call(i, o, a, e)
         }
-        return a
+        return s
     }
 
-    function* QG(e, t, n, i) {
+    function* sU(e, t, n, i) {
         let r = 0;
-        for (const a of e) yield t.call(i, a, r, e), yield n.call(i, a, r, e), ++r
+        for (const s of e) yield t.call(i, s, r, e), yield n.call(i, s, r, e), ++r
     }
-    var Mk = {},
-        Xy = {},
-        Vy = 34,
-        of = 10,
-        Ky = 13;
+    var qk = {},
+        ky = {},
+        Ay = 34,
+        Yc = 10,
+        $y = 13;
 
-    function NF(e) {
+    function YO(e) {
         return new Function("d", "return {" + e.map(function(t, n) {
             return JSON.stringify(t) + ": d[" + n + '] || ""'
         }).join(",") + "}")
     }
 
-    function ZG(e, t) {
-        var n = NF(e);
+    function aU(e, t) {
+        var n = YO(e);
         return function(i, r) {
             return t(n(i), r, e)
         }
     }
 
-    function Fk(e) {
+    function Hk(e) {
         var t = Object.create(null),
             n = [];
         return e.forEach(function(i) {
             for (var r in i) r in t || n.push(t[r] = r)
         }), n
     }
 
-    function Wn(e, t) {
+    function Gn(e, t) {
         var n = e + "",
             i = n.length;
         return i < t ? new Array(t - i + 1).join(0) + n : n
     }
 
-    function eU(e) {
-        return e < 0 ? "-" + Wn(-e, 6) : e > 9999 ? "+" + Wn(e, 6) : Wn(e, 4)
+    function oU(e) {
+        return e < 0 ? "-" + Gn(-e, 6) : e > 9999 ? "+" + Gn(e, 6) : Gn(e, 4)
     }
 
-    function tU(e) {
+    function lU(e) {
         var t = e.getUTCHours(),
             n = e.getUTCMinutes(),
             i = e.getUTCSeconds(),
             r = e.getUTCMilliseconds();
-        return isNaN(e) ? "Invalid Date" : eU(e.getUTCFullYear()) + "-" + Wn(e.getUTCMonth() + 1, 2) + "-" + Wn(e.getUTCDate(), 2) + (r ? "T" + Wn(t, 2) + ":" + Wn(n, 2) + ":" + Wn(i, 2) + "." + Wn(r, 3) + "Z" : i ? "T" + Wn(t, 2) + ":" + Wn(n, 2) + ":" + Wn(i, 2) + "Z" : n || t ? "T" + Wn(t, 2) + ":" + Wn(n, 2) + "Z" : "")
+        return isNaN(e) ? "Invalid Date" : oU(e.getUTCFullYear()) + "-" + Gn(e.getUTCMonth() + 1, 2) + "-" + Gn(e.getUTCDate(), 2) + (r ? "T" + Gn(t, 2) + ":" + Gn(n, 2) + ":" + Gn(i, 2) + "." + Gn(r, 3) + "Z" : i ? "T" + Gn(t, 2) + ":" + Gn(n, 2) + ":" + Gn(i, 2) + "Z" : n || t ? "T" + Gn(t, 2) + ":" + Gn(n, 2) + "Z" : "")
     }
 
-    function nU(e) {
+    function uU(e) {
         var t = new RegExp('["' + e + `
 \r]`),
             n = e.charCodeAt(0);
 
         function i(f, h) {
             var d, g, p = r(f, function(m, y) {
                 if (d) return d(m, y - 1);
-                g = m, d = h ? ZG(m, h) : NF(m)
+                g = m, d = h ? aU(m, h) : YO(m)
             });
             return p.columns = g || [], p
         }
 
         function r(f, h) {
             var d = [],
                 g = f.length,
                 p = 0,
                 m = 0,
                 y, v = g <= 0,
                 b = !1;
-            f.charCodeAt(g - 1) === of && --g, f.charCodeAt(g - 1) === Ky && --g;
+            f.charCodeAt(g - 1) === Yc && --g, f.charCodeAt(g - 1) === $y && --g;
 
             function x() {
-                if (v) return Xy;
-                if (b) return b = !1, Mk;
+                if (v) return ky;
+                if (b) return b = !1, qk;
                 var S, w = p,
-                    O;
-                if (f.charCodeAt(w) === Vy) {
-                    for (; p++ < g && f.charCodeAt(p) !== Vy || f.charCodeAt(++p) === Vy;);
-                    return (S = p) >= g ? v = !0 : (O = f.charCodeAt(p++)) === of ? b = !0 : O === Ky && (b = !0, f.charCodeAt(p) === of && ++p), f.slice(w + 1, S - 1).replace(/""/g, '"')
+                    E;
+                if (f.charCodeAt(w) === Ay) {
+                    for (; p++ < g && f.charCodeAt(p) !== Ay || f.charCodeAt(++p) === Ay;);
+                    return (S = p) >= g ? v = !0 : (E = f.charCodeAt(p++)) === Yc ? b = !0 : E === $y && (b = !0, f.charCodeAt(p) === Yc && ++p), f.slice(w + 1, S - 1).replace(/""/g, '"')
                 }
                 for (; p < g;) {
-                    if ((O = f.charCodeAt(S = p++)) === of) b = !0;
-                    else if (O === Ky) b = !0, f.charCodeAt(p) === of && ++p;
-                    else if (O !== n) continue;
+                    if ((E = f.charCodeAt(S = p++)) === Yc) b = !0;
+                    else if (E === $y) b = !0, f.charCodeAt(p) === Yc && ++p;
+                    else if (E !== n) continue;
                     return f.slice(w, S)
                 }
                 return v = !0, f.slice(w, g)
             }
             for (;
-                (y = x()) !== Xy;) {
-                for (var _ = []; y !== Mk && y !== Xy;) _.push(y), y = x();
+                (y = x()) !== ky;) {
+                for (var _ = []; y !== qk && y !== ky;) _.push(y), y = x();
                 h && (_ = h(_, m++)) == null || d.push(_)
             }
             return d
         }
 
-        function a(f, h) {
+        function s(f, h) {
             return f.map(function(d) {
                 return h.map(function(g) {
                     return c(d[g])
                 }).join(e)
             })
         }
 
-        function s(f, h) {
-            return h == null && (h = Fk(f)), [h.map(c).join(e)].concat(a(f, h)).join(`
+        function a(f, h) {
+            return h == null && (h = Hk(f)), [h.map(c).join(e)].concat(s(f, h)).join(`
 `)
         }
 
         function o(f, h) {
-            return h == null && (h = Fk(f)), a(f, h).join(`
+            return h == null && (h = Hk(f)), s(f, h).join(`
 `)
         }
 
         function l(f) {
             return f.map(u).join(`
 `)
         }
 
         function u(f) {
             return f.map(c).join(e)
         }
 
         function c(f) {
-            return f == null ? "" : f instanceof Date ? tU(f) : t.test(f += "") ? '"' + f.replace(/"/g, '""') + '"' : f
+            return f == null ? "" : f instanceof Date ? lU(f) : t.test(f += "") ? '"' + f.replace(/"/g, '""') + '"' : f
         }
         return {
             parse: i,
             parseRows: r,
-            format: s,
+            format: a,
             formatBody: o,
             formatRows: l,
             formatRow: u,
             formatValue: c
         }
     }
 
-    function iU(e, t) {
+    function cU(e, t) {
         var n, i = 1;
         e == null && (e = 0), t == null && (t = 0);
 
         function r() {
-            var a, s = n.length,
+            var s, a = n.length,
                 o, l = 0,
                 u = 0;
-            for (a = 0; a < s; ++a) o = n[a], l += o.x, u += o.y;
-            for (l = (l / s - e) * i, u = (u / s - t) * i, a = 0; a < s; ++a) o = n[a], o.x -= l, o.y -= u
+            for (s = 0; s < a; ++s) o = n[s], l += o.x, u += o.y;
+            for (l = (l / a - e) * i, u = (u / a - t) * i, s = 0; s < a; ++s) o = n[s], o.x -= l, o.y -= u
         }
-        return r.initialize = function(a) {
-            n = a
-        }, r.x = function(a) {
-            return arguments.length ? (e = +a, r) : e
-        }, r.y = function(a) {
-            return arguments.length ? (t = +a, r) : t
-        }, r.strength = function(a) {
-            return arguments.length ? (i = +a, r) : i
+        return r.initialize = function(s) {
+            n = s
+        }, r.x = function(s) {
+            return arguments.length ? (e = +s, r) : e
+        }, r.y = function(s) {
+            return arguments.length ? (t = +s, r) : t
+        }, r.strength = function(s) {
+            return arguments.length ? (i = +s, r) : i
         }, r
     }
 
-    function rU(e) {
+    function fU(e) {
         const t = +this._x.call(null, e),
             n = +this._y.call(null, e);
-        return LF(this.cover(t, n), t, n, e)
+        return XO(this.cover(t, n), t, n, e)
     }
 
-    function LF(e, t, n, i) {
+    function XO(e, t, n, i) {
         if (isNaN(t) || isNaN(n)) return e;
-        var r, a = e._root,
-            s = {
+        var r, s = e._root,
+            a = {
                 data: i
             },
             o = e._x0,
             l = e._y0,
             u = e._x1,
             c = e._y1,
             f, h, d, g, p, m, y, v;
-        if (!a) return e._root = s, e;
-        for (; a.length;)
-            if ((p = t >= (f = (o + u) / 2)) ? o = f : u = f, (m = n >= (h = (l + c) / 2)) ? l = h : c = h, r = a, !(a = a[y = m << 1 | p])) return r[y] = s, e;
-        if (d = +e._x.call(null, a.data), g = +e._y.call(null, a.data), t === d && n === g) return s.next = a, r ? r[y] = s : e._root = s, e;
+        if (!s) return e._root = a, e;
+        for (; s.length;)
+            if ((p = t >= (f = (o + u) / 2)) ? o = f : u = f, (m = n >= (h = (l + c) / 2)) ? l = h : c = h, r = s, !(s = s[y = m << 1 | p])) return r[y] = a, e;
+        if (d = +e._x.call(null, s.data), g = +e._y.call(null, s.data), t === d && n === g) return a.next = s, r ? r[y] = a : e._root = a, e;
         do r = r ? r[y] = new Array(4) : e._root = new Array(4), (p = t >= (f = (o + u) / 2)) ? o = f : u = f, (m = n >= (h = (l + c) / 2)) ? l = h : c = h; while ((y = m << 1 | p) === (v = (g >= h) << 1 | d >= f));
-        return r[v] = a, r[y] = s, e
+        return r[v] = s, r[y] = a, e
     }
 
-    function aU(e) {
+    function hU(e) {
         var t, n, i = e.length,
-            r, a, s = new Array(i),
+            r, s, a = new Array(i),
             o = new Array(i),
             l = 1 / 0,
             u = 1 / 0,
             c = -1 / 0,
             f = -1 / 0;
-        for (n = 0; n < i; ++n) isNaN(r = +this._x.call(null, t = e[n])) || isNaN(a = +this._y.call(null, t)) || (s[n] = r, o[n] = a, r < l && (l = r), r > c && (c = r), a < u && (u = a), a > f && (f = a));
+        for (n = 0; n < i; ++n) isNaN(r = +this._x.call(null, t = e[n])) || isNaN(s = +this._y.call(null, t)) || (a[n] = r, o[n] = s, r < l && (l = r), r > c && (c = r), s < u && (u = s), s > f && (f = s));
         if (l > c || u > f) return this;
-        for (this.cover(l, u).cover(c, f), n = 0; n < i; ++n) LF(this, s[n], o[n], e[n]);
+        for (this.cover(l, u).cover(c, f), n = 0; n < i; ++n) XO(this, a[n], o[n], e[n]);
         return this
     }
 
-    function sU(e, t) {
+    function dU(e, t) {
         if (isNaN(e = +e) || isNaN(t = +t)) return this;
         var n = this._x0,
             i = this._y0,
             r = this._x1,
-            a = this._y1;
-        if (isNaN(n)) r = (n = Math.floor(e)) + 1, a = (i = Math.floor(t)) + 1;
+            s = this._y1;
+        if (isNaN(n)) r = (n = Math.floor(e)) + 1, s = (i = Math.floor(t)) + 1;
         else {
-            for (var s = r - n || 1, o = this._root, l, u; n > e || e >= r || i > t || t >= a;) switch (u = (t < i) << 1 | e < n, l = new Array(4), l[u] = o, o = l, s *= 2, u) {
+            for (var a = r - n || 1, o = this._root, l, u; n > e || e >= r || i > t || t >= s;) switch (u = (t < i) << 1 | e < n, l = new Array(4), l[u] = o, o = l, a *= 2, u) {
                 case 0:
-                    r = n + s, a = i + s;
+                    r = n + a, s = i + a;
                     break;
                 case 1:
-                    n = r - s, a = i + s;
+                    n = r - a, s = i + a;
                     break;
                 case 2:
-                    r = n + s, i = a - s;
+                    r = n + a, i = s - a;
                     break;
                 case 3:
-                    n = r - s, i = a - s;
+                    n = r - a, i = s - a;
                     break
             }
             this._root && this._root.length && (this._root = o)
         }
-        return this._x0 = n, this._y0 = i, this._x1 = r, this._y1 = a, this
+        return this._x0 = n, this._y0 = i, this._x1 = r, this._y1 = s, this
     }
 
-    function oU() {
+    function gU() {
         var e = [];
         return this.visit(function(t) {
             if (!t.length)
                 do e.push(t.data); while (t = t.next)
         }), e
     }
 
-    function lU(e) {
+    function pU(e) {
         return arguments.length ? this.cover(+e[0][0], +e[0][1]).cover(+e[1][0], +e[1][1]) : isNaN(this._x0) ? void 0 : [
             [this._x0, this._y0],
             [this._x1, this._y1]
         ]
     }
 
-    function Rn(e, t, n, i, r) {
+    function On(e, t, n, i, r) {
         this.node = e, this.x0 = t, this.y0 = n, this.x1 = i, this.y1 = r
     }
 
-    function uU(e, t, n) {
+    function mU(e, t, n) {
         var i, r = this._x0,
-            a = this._y0,
-            s, o, l, u, c = this._x1,
+            s = this._y0,
+            a, o, l, u, c = this._x1,
             f = this._y1,
             h = [],
             d = this._root,
             g, p;
-        for (d && h.push(new Rn(d, r, a, c, f)), n == null ? n = 1 / 0 : (r = e - n, a = t - n, c = e + n, f = t + n, n *= n); g = h.pop();)
-            if (!(!(d = g.node) || (s = g.x0) > c || (o = g.y0) > f || (l = g.x1) < r || (u = g.y1) < a))
+        for (d && h.push(new On(d, r, s, c, f)), n == null ? n = 1 / 0 : (r = e - n, s = t - n, c = e + n, f = t + n, n *= n); g = h.pop();)
+            if (!(!(d = g.node) || (a = g.x0) > c || (o = g.y0) > f || (l = g.x1) < r || (u = g.y1) < s))
                 if (d.length) {
-                    var m = (s + l) / 2,
+                    var m = (a + l) / 2,
                         y = (o + u) / 2;
-                    h.push(new Rn(d[3], m, y, l, u), new Rn(d[2], s, y, m, u), new Rn(d[1], m, o, l, y), new Rn(d[0], s, o, m, y)), (p = (t >= y) << 1 | e >= m) && (g = h[h.length - 1], h[h.length - 1] = h[h.length - 1 - p], h[h.length - 1 - p] = g)
+                    h.push(new On(d[3], m, y, l, u), new On(d[2], a, y, m, u), new On(d[1], m, o, l, y), new On(d[0], a, o, m, y)), (p = (t >= y) << 1 | e >= m) && (g = h[h.length - 1], h[h.length - 1] = h[h.length - 1 - p], h[h.length - 1 - p] = g)
                 } else {
                     var v = e - +this._x.call(null, d.data),
                         b = t - +this._y.call(null, d.data),
                         x = v * v + b * b;
                     if (x < n) {
                         var _ = Math.sqrt(n = x);
-                        r = e - _, a = t - _, c = e + _, f = t + _, i = d.data
+                        r = e - _, s = t - _, c = e + _, f = t + _, i = d.data
                     }
                 } return i
     }
 
-    function cU(e) {
+    function yU(e) {
         if (isNaN(c = +this._x.call(null, e)) || isNaN(f = +this._y.call(null, e))) return this;
         var t, n = this._root,
-            i, r, a, s = this._x0,
+            i, r, s, a = this._x0,
             o = this._y0,
             l = this._x1,
             u = this._y1,
             c, f, h, d, g, p, m, y;
         if (!n) return this;
         if (n.length)
             for (;;) {
-                if ((g = c >= (h = (s + l) / 2)) ? s = h : l = h, (p = f >= (d = (o + u) / 2)) ? o = d : u = d, t = n, !(n = n[m = p << 1 | g])) return this;
+                if ((g = c >= (h = (a + l) / 2)) ? a = h : l = h, (p = f >= (d = (o + u) / 2)) ? o = d : u = d, t = n, !(n = n[m = p << 1 | g])) return this;
                 if (!n.length) break;
                 (t[m + 1 & 3] || t[m + 2 & 3] || t[m + 3 & 3]) && (i = t, y = m)
             }
         for (; n.data !== e;)
             if (r = n, !(n = n.next)) return this;
-        return (a = n.next) && delete n.next, r ? (a ? r.next = a : delete r.next, this) : t ? (a ? t[m] = a : delete t[m], (n = t[0] || t[1] || t[2] || t[3]) && n === (t[3] || t[2] || t[1] || t[0]) && !n.length && (i ? i[y] = n : this._root = n), this) : (this._root = a, this)
+        return (s = n.next) && delete n.next, r ? (s ? r.next = s : delete r.next, this) : t ? (s ? t[m] = s : delete t[m], (n = t[0] || t[1] || t[2] || t[3]) && n === (t[3] || t[2] || t[1] || t[0]) && !n.length && (i ? i[y] = n : this._root = n), this) : (this._root = s, this)
     }
 
-    function fU(e) {
+    function vU(e) {
         for (var t = 0, n = e.length; t < n; ++t) this.remove(e[t]);
         return this
     }
 
-    function hU() {
+    function bU() {
         return this._root
     }
 
-    function dU() {
+    function xU() {
         var e = 0;
         return this.visit(function(t) {
             if (!t.length)
                 do ++e; while (t = t.next)
         }), e
     }
 
-    function gU(e) {
+    function _U(e) {
         var t = [],
             n, i = this._root,
-            r, a, s, o, l;
-        for (i && t.push(new Rn(i, this._x0, this._y0, this._x1, this._y1)); n = t.pop();)
-            if (!e(i = n.node, a = n.x0, s = n.y0, o = n.x1, l = n.y1) && i.length) {
-                var u = (a + o) / 2,
-                    c = (s + l) / 2;
-                (r = i[3]) && t.push(new Rn(r, u, c, o, l)), (r = i[2]) && t.push(new Rn(r, a, c, u, l)), (r = i[1]) && t.push(new Rn(r, u, s, o, c)), (r = i[0]) && t.push(new Rn(r, a, s, u, c))
+            r, s, a, o, l;
+        for (i && t.push(new On(i, this._x0, this._y0, this._x1, this._y1)); n = t.pop();)
+            if (!e(i = n.node, s = n.x0, a = n.y0, o = n.x1, l = n.y1) && i.length) {
+                var u = (s + o) / 2,
+                    c = (a + l) / 2;
+                (r = i[3]) && t.push(new On(r, u, c, o, l)), (r = i[2]) && t.push(new On(r, s, c, u, l)), (r = i[1]) && t.push(new On(r, u, a, o, c)), (r = i[0]) && t.push(new On(r, s, a, u, c))
             } return this
     }
 
-    function pU(e) {
+    function wU(e) {
         var t = [],
             n = [],
             i;
-        for (this._root && t.push(new Rn(this._root, this._x0, this._y0, this._x1, this._y1)); i = t.pop();) {
+        for (this._root && t.push(new On(this._root, this._x0, this._y0, this._x1, this._y1)); i = t.pop();) {
             var r = i.node;
             if (r.length) {
-                var a, s = i.x0,
+                var s, a = i.x0,
                     o = i.y0,
                     l = i.x1,
                     u = i.y1,
-                    c = (s + l) / 2,
+                    c = (a + l) / 2,
                     f = (o + u) / 2;
-                (a = r[0]) && t.push(new Rn(a, s, o, c, f)), (a = r[1]) && t.push(new Rn(a, c, o, l, f)), (a = r[2]) && t.push(new Rn(a, s, f, c, u)), (a = r[3]) && t.push(new Rn(a, c, f, l, u))
+                (s = r[0]) && t.push(new On(s, a, o, c, f)), (s = r[1]) && t.push(new On(s, c, o, l, f)), (s = r[2]) && t.push(new On(s, a, f, c, u)), (s = r[3]) && t.push(new On(s, c, f, l, u))
             }
             n.push(i)
         }
         for (; i = n.pop();) e(i.node, i.x0, i.y0, i.x1, i.y1);
         return this
     }
 
-    function mU(e) {
+    function SU(e) {
         return e[0]
     }
 
-    function yU(e) {
+    function EU(e) {
         return arguments.length ? (this._x = e, this) : this._x
     }
 
-    function vU(e) {
+    function CU(e) {
         return e[1]
     }
 
-    function bU(e) {
+    function kU(e) {
         return arguments.length ? (this._y = e, this) : this._y
     }
 
-    function c_(e, t, n) {
-        var i = new f_(t ?? mU, n ?? vU, NaN, NaN, NaN, NaN);
+    function Tx(e, t, n) {
+        var i = new Mx(t ?? SU, n ?? CU, NaN, NaN, NaN, NaN);
         return e == null ? i : i.addAll(e)
     }
 
-    function f_(e, t, n, i, r, a) {
-        this._x = e, this._y = t, this._x0 = n, this._y0 = i, this._x1 = r, this._y1 = a, this._root = void 0
+    function Mx(e, t, n, i, r, s) {
+        this._x = e, this._y = t, this._x0 = n, this._y0 = i, this._x1 = r, this._y1 = s, this._root = void 0
     }
 
-    function Dk(e) {
+    function Yk(e) {
         for (var t = {
                 data: e.data
             }, n = t; e = e.next;) n = n.next = {
             data: e.data
         };
         return t
     }
-    var Gn = c_.prototype = f_.prototype;
-    Gn.copy = function() {
-        var e = new f_(this._x, this._y, this._x0, this._y0, this._x1, this._y1),
+    var Bn = Tx.prototype = Mx.prototype;
+    Bn.copy = function() {
+        var e = new Mx(this._x, this._y, this._x0, this._y0, this._x1, this._y1),
             t = this._root,
             n, i;
         if (!t) return e;
-        if (!t.length) return e._root = Dk(t), e;
+        if (!t.length) return e._root = Yk(t), e;
         for (n = [{
                 source: t,
                 target: e._root = new Array(4)
             }]; t = n.pop();)
             for (var r = 0; r < 4; ++r)(i = t.source[r]) && (i.length ? n.push({
                 source: i,
                 target: t.target[r] = new Array(4)
-            }) : t.target[r] = Dk(i));
+            }) : t.target[r] = Yk(i));
         return e
     };
-    Gn.add = rU;
-    Gn.addAll = aU;
-    Gn.cover = sU;
-    Gn.data = oU;
-    Gn.extent = lU;
-    Gn.find = uU;
-    Gn.remove = cU;
-    Gn.removeAll = fU;
-    Gn.root = hU;
-    Gn.size = dU;
-    Gn.visit = gU;
-    Gn.visitAfter = pU;
-    Gn.x = yU;
-    Gn.y = bU;
+    Bn.add = fU;
+    Bn.addAll = hU;
+    Bn.cover = dU;
+    Bn.data = gU;
+    Bn.extent = pU;
+    Bn.find = mU;
+    Bn.remove = yU;
+    Bn.removeAll = vU;
+    Bn.root = bU;
+    Bn.size = xU;
+    Bn.visit = _U;
+    Bn.visitAfter = wU;
+    Bn.x = EU;
+    Bn.y = kU;
 
-    function Pn(e) {
+    function Fn(e) {
         return function() {
             return e
         }
     }
 
-    function Ss(e) {
+    function da(e) {
         return (e() - .5) * 1e-6
     }
 
-    function xU(e) {
+    function AU(e) {
         return e.x + e.vx
     }
 
-    function _U(e) {
+    function $U(e) {
         return e.y + e.vy
     }
 
-    function wU(e) {
+    function TU(e) {
         var t, n, i, r = 1,
-            a = 1;
-        typeof e != "function" && (e = Pn(e == null ? 1 : +e));
+            s = 1;
+        typeof e != "function" && (e = Fn(e == null ? 1 : +e));
 
-        function s() {
-            for (var u, c = t.length, f, h, d, g, p, m, y = 0; y < a; ++y)
-                for (f = c_(t, xU, _U).visitAfter(o), u = 0; u < c; ++u) h = t[u], p = n[h.index], m = p * p, d = h.x + h.vx, g = h.y + h.vy, f.visit(v);
+        function a() {
+            for (var u, c = t.length, f, h, d, g, p, m, y = 0; y < s; ++y)
+                for (f = Tx(t, AU, $U).visitAfter(o), u = 0; u < c; ++u) h = t[u], p = n[h.index], m = p * p, d = h.x + h.vx, g = h.y + h.vy, f.visit(v);
 
             function v(b, x, _, S, w) {
-                var O = b.data,
-                    k = b.r,
-                    C = p + k;
-                if (O) {
-                    if (O.index > h.index) {
-                        var E = d - O.x - O.vx,
-                            T = g - O.y - O.vy,
-                            A = E * E + T * T;
-                        A < C * C && (E === 0 && (E = Ss(i), A += E * E), T === 0 && (T = Ss(i), A += T * T), A = (C - (A = Math.sqrt(A))) / A * r, h.vx += (E *= A) * (C = (k *= k) / (m + k)), h.vy += (T *= A) * C, O.vx -= E * (C = 1 - C), O.vy -= T * C)
+                var E = b.data,
+                    A = b.r,
+                    C = p + A;
+                if (E) {
+                    if (E.index > h.index) {
+                        var k = d - E.x - E.vx,
+                            R = g - E.y - E.vy,
+                            $ = k * k + R * R;
+                        $ < C * C && (k === 0 && (k = da(i), $ += k * k), R === 0 && (R = da(i), $ += R * R), $ = (C - ($ = Math.sqrt($))) / $ * r, h.vx += (k *= $) * (C = (A *= A) / (m + A)), h.vy += (R *= $) * C, E.vx -= k * (C = 1 - C), E.vy -= R * C)
                     }
                     return
                 }
                 return x > d + C || S < d - C || _ > g + C || w < g - C
             }
         }
 
@@ -10019,137 +10019,137 @@
         function l() {
             if (t) {
                 var u, c = t.length,
                     f;
                 for (n = new Array(c), u = 0; u < c; ++u) f = t[u], n[f.index] = +e(f, u, t)
             }
         }
-        return s.initialize = function(u, c) {
+        return a.initialize = function(u, c) {
             t = u, i = c, l()
-        }, s.iterations = function(u) {
-            return arguments.length ? (a = +u, s) : a
-        }, s.strength = function(u) {
-            return arguments.length ? (r = +u, s) : r
-        }, s.radius = function(u) {
-            return arguments.length ? (e = typeof u == "function" ? u : Pn(+u), l(), s) : e
-        }, s
+        }, a.iterations = function(u) {
+            return arguments.length ? (s = +u, a) : s
+        }, a.strength = function(u) {
+            return arguments.length ? (r = +u, a) : r
+        }, a.radius = function(u) {
+            return arguments.length ? (e = typeof u == "function" ? u : Fn(+u), l(), a) : e
+        }, a
     }
 
-    function SU(e) {
+    function MU(e) {
         return e.index
     }
 
-    function Rk(e, t) {
+    function Xk(e, t) {
         var n = e.get(t);
         if (!n) throw new Error("node not found: " + t);
         return n
     }
 
-    function EU(e) {
-        var t = SU,
+    function OU(e) {
+        var t = MU,
             n = f,
-            i, r = Pn(30),
-            a, s, o, l, u, c = 1;
+            i, r = Fn(30),
+            s, a, o, l, u, c = 1;
         e == null && (e = []);
 
         function f(m) {
             return 1 / Math.min(o[m.source.index], o[m.target.index])
         }
 
         function h(m) {
             for (var y = 0, v = e.length; y < c; ++y)
-                for (var b = 0, x, _, S, w, O, k, C; b < v; ++b) x = e[b], _ = x.source, S = x.target, w = S.x + S.vx - _.x - _.vx || Ss(u), O = S.y + S.vy - _.y - _.vy || Ss(u), k = Math.sqrt(w * w + O * O), k = (k - a[b]) / k * m * i[b], w *= k, O *= k, S.vx -= w * (C = l[b]), S.vy -= O * C, _.vx += w * (C = 1 - C), _.vy += O * C
+                for (var b = 0, x, _, S, w, E, A, C; b < v; ++b) x = e[b], _ = x.source, S = x.target, w = S.x + S.vx - _.x - _.vx || da(u), E = S.y + S.vy - _.y - _.vy || da(u), A = Math.sqrt(w * w + E * E), A = (A - s[b]) / A * m * i[b], w *= A, E *= A, S.vx -= w * (C = l[b]), S.vy -= E * C, _.vx += w * (C = 1 - C), _.vy += E * C
         }
 
         function d() {
-            if (s) {
-                var m, y = s.length,
+            if (a) {
+                var m, y = a.length,
                     v = e.length,
-                    b = new Map(s.map((_, S) => [t(_, S, s), _])),
+                    b = new Map(a.map((_, S) => [t(_, S, a), _])),
                     x;
-                for (m = 0, o = new Array(y); m < v; ++m) x = e[m], x.index = m, typeof x.source != "object" && (x.source = Rk(b, x.source)), typeof x.target != "object" && (x.target = Rk(b, x.target)), o[x.source.index] = (o[x.source.index] || 0) + 1, o[x.target.index] = (o[x.target.index] || 0) + 1;
+                for (m = 0, o = new Array(y); m < v; ++m) x = e[m], x.index = m, typeof x.source != "object" && (x.source = Xk(b, x.source)), typeof x.target != "object" && (x.target = Xk(b, x.target)), o[x.source.index] = (o[x.source.index] || 0) + 1, o[x.target.index] = (o[x.target.index] || 0) + 1;
                 for (m = 0, l = new Array(v); m < v; ++m) x = e[m], l[m] = o[x.source.index] / (o[x.source.index] + o[x.target.index]);
-                i = new Array(v), g(), a = new Array(v), p()
+                i = new Array(v), g(), s = new Array(v), p()
             }
         }
 
         function g() {
-            if (s)
+            if (a)
                 for (var m = 0, y = e.length; m < y; ++m) i[m] = +n(e[m], m, e)
         }
 
         function p() {
-            if (s)
-                for (var m = 0, y = e.length; m < y; ++m) a[m] = +r(e[m], m, e)
+            if (a)
+                for (var m = 0, y = e.length; m < y; ++m) s[m] = +r(e[m], m, e)
         }
         return h.initialize = function(m, y) {
-            s = m, u = y, d()
+            a = m, u = y, d()
         }, h.links = function(m) {
             return arguments.length ? (e = m, d(), h) : e
         }, h.id = function(m) {
             return arguments.length ? (t = m, h) : t
         }, h.iterations = function(m) {
             return arguments.length ? (c = +m, h) : c
         }, h.strength = function(m) {
-            return arguments.length ? (n = typeof m == "function" ? m : Pn(+m), g(), h) : n
+            return arguments.length ? (n = typeof m == "function" ? m : Fn(+m), g(), h) : n
         }, h.distance = function(m) {
-            return arguments.length ? (r = typeof m == "function" ? m : Pn(+m), p(), h) : r
+            return arguments.length ? (r = typeof m == "function" ? m : Fn(+m), p(), h) : r
         }, h
     }
-    const OU = 1664525,
-        CU = 1013904223,
-        Pk = 4294967296;
+    const FU = 1664525,
+        RU = 1013904223,
+        Vk = 4294967296;
 
-    function kU() {
+    function DU() {
         let e = 1;
-        return () => (e = (OU * e + CU) % Pk) / Pk
+        return () => (e = (FU * e + RU) % Vk) / Vk
     }
 
-    function AU(e) {
+    function NU(e) {
         return e.x
     }
 
-    function TU(e) {
+    function PU(e) {
         return e.y
     }
-    var $U = 10,
-        MU = Math.PI * (3 - Math.sqrt(5));
+    var LU = 10,
+        IU = Math.PI * (3 - Math.sqrt(5));
 
-    function FU(e) {
+    function zU(e) {
         var t, n = 1,
             i = .001,
             r = 1 - Math.pow(i, 1 / 300),
-            a = 0,
-            s = .6,
+            s = 0,
+            a = .6,
             o = new Map,
-            l = RF(f),
-            u = MF("tick", "end"),
-            c = kU();
+            l = qO(f),
+            u = UO("tick", "end"),
+            c = DU();
         e == null && (e = []);
 
         function f() {
             h(), u.call("tick", t), n < i && (l.stop(), u.call("end", t))
         }
 
         function h(p) {
             var m, y = e.length,
                 v;
             p === void 0 && (p = 1);
             for (var b = 0; b < p; ++b)
-                for (n += (a - n) * r, o.forEach(function(x) {
+                for (n += (s - n) * r, o.forEach(function(x) {
                         x(n)
-                    }), m = 0; m < y; ++m) v = e[m], v.fx == null ? v.x += v.vx *= s : (v.x = v.fx, v.vx = 0), v.fy == null ? v.y += v.vy *= s : (v.y = v.fy, v.vy = 0);
+                    }), m = 0; m < y; ++m) v = e[m], v.fx == null ? v.x += v.vx *= a : (v.x = v.fx, v.vx = 0), v.fy == null ? v.y += v.vy *= a : (v.y = v.fy, v.vy = 0);
             return t
         }
 
         function d() {
             for (var p = 0, m = e.length, y; p < m; ++p) {
                 if (y = e[p], y.index = p, y.fx != null && (y.x = y.fx), y.fy != null && (y.y = y.fy), isNaN(y.x) || isNaN(y.y)) {
-                    var v = $U * Math.sqrt(.5 + p),
-                        b = p * MU;
+                    var v = LU * Math.sqrt(.5 + p),
+                        b = p * IU;
                     y.x = v * Math.cos(b), y.y = v * Math.sin(b)
                 }(isNaN(y.vx) || isNaN(y.vy)) && (y.vx = y.vy = 0)
             }
         }
 
         function g(p) {
             return p.initialize && p.initialize(e, c), p
@@ -10171,829 +10171,829 @@
             alphaMin: function(p) {
                 return arguments.length ? (i = +p, t) : i
             },
             alphaDecay: function(p) {
                 return arguments.length ? (r = +p, t) : +r
             },
             alphaTarget: function(p) {
-                return arguments.length ? (a = +p, t) : a
+                return arguments.length ? (s = +p, t) : s
             },
             velocityDecay: function(p) {
-                return arguments.length ? (s = 1 - p, t) : 1 - s
+                return arguments.length ? (a = 1 - p, t) : 1 - a
             },
             randomSource: function(p) {
                 return arguments.length ? (c = p, o.forEach(g), t) : c
             },
             force: function(p, m) {
                 return arguments.length > 1 ? (m == null ? o.delete(p) : o.set(p, g(m)), t) : o.get(p)
             },
             find: function(p, m, y) {
                 var v = 0,
                     b = e.length,
-                    x, _, S, w, O;
-                for (y == null ? y = 1 / 0 : y *= y, v = 0; v < b; ++v) w = e[v], x = p - w.x, _ = m - w.y, S = x * x + _ * _, S < y && (O = w, y = S);
-                return O
+                    x, _, S, w, E;
+                for (y == null ? y = 1 / 0 : y *= y, v = 0; v < b; ++v) w = e[v], x = p - w.x, _ = m - w.y, S = x * x + _ * _, S < y && (E = w, y = S);
+                return E
             },
             on: function(p, m) {
                 return arguments.length > 1 ? (u.on(p, m), t) : u.on(p)
             }
         }
     }
 
-    function DU() {
-        var e, t, n, i, r = Pn(-30),
-            a, s = 1,
+    function BU() {
+        var e, t, n, i, r = Fn(-30),
+            s, a = 1,
             o = 1 / 0,
             l = .81;
 
         function u(d) {
             var g, p = e.length,
-                m = c_(e, AU, TU).visitAfter(f);
+                m = Tx(e, NU, PU).visitAfter(f);
             for (i = d, g = 0; g < p; ++g) t = e[g], m.visit(h)
         }
 
         function c() {
             if (e) {
                 var d, g = e.length,
                     p;
-                for (a = new Array(g), d = 0; d < g; ++d) p = e[d], a[p.index] = +r(p, d, e)
+                for (s = new Array(g), d = 0; d < g; ++d) p = e[d], s[p.index] = +r(p, d, e)
             }
         }
 
         function f(d) {
             var g = 0,
                 p, m, y = 0,
                 v, b, x;
             if (d.length) {
                 for (v = b = x = 0; x < 4; ++x)(p = d[x]) && (m = Math.abs(p.value)) && (g += p.value, y += m, v += m * p.x, b += m * p.y);
                 d.x = v / y, d.y = b / y
             } else {
                 p = d, p.x = p.data.x, p.y = p.data.y;
-                do g += a[p.data.index]; while (p = p.next)
+                do g += s[p.data.index]; while (p = p.next)
             }
             d.value = g
         }
 
         function h(d, g, p, m) {
             if (!d.value) return !0;
             var y = d.x - t.x,
                 v = d.y - t.y,
                 b = m - g,
                 x = y * y + v * v;
-            if (b * b / l < x) return x < o && (y === 0 && (y = Ss(n), x += y * y), v === 0 && (v = Ss(n), x += v * v), x < s && (x = Math.sqrt(s * x)), t.vx += y * d.value * i / x, t.vy += v * d.value * i / x), !0;
+            if (b * b / l < x) return x < o && (y === 0 && (y = da(n), x += y * y), v === 0 && (v = da(n), x += v * v), x < a && (x = Math.sqrt(a * x)), t.vx += y * d.value * i / x, t.vy += v * d.value * i / x), !0;
             if (d.length || x >= o) return;
-            (d.data !== t || d.next) && (y === 0 && (y = Ss(n), x += y * y), v === 0 && (v = Ss(n), x += v * v), x < s && (x = Math.sqrt(s * x)));
-            do d.data !== t && (b = a[d.data.index] * i / x, t.vx += y * b, t.vy += v * b); while (d = d.next)
+            (d.data !== t || d.next) && (y === 0 && (y = da(n), x += y * y), v === 0 && (v = da(n), x += v * v), x < a && (x = Math.sqrt(a * x)));
+            do d.data !== t && (b = s[d.data.index] * i / x, t.vx += y * b, t.vy += v * b); while (d = d.next)
         }
         return u.initialize = function(d, g) {
             e = d, n = g, c()
         }, u.strength = function(d) {
-            return arguments.length ? (r = typeof d == "function" ? d : Pn(+d), c(), u) : r
+            return arguments.length ? (r = typeof d == "function" ? d : Fn(+d), c(), u) : r
         }, u.distanceMin = function(d) {
-            return arguments.length ? (s = d * d, u) : Math.sqrt(s)
+            return arguments.length ? (a = d * d, u) : Math.sqrt(a)
         }, u.distanceMax = function(d) {
             return arguments.length ? (o = d * d, u) : Math.sqrt(o)
         }, u.theta = function(d) {
             return arguments.length ? (l = d * d, u) : Math.sqrt(l)
         }, u
     }
 
-    function RU(e) {
-        var t = Pn(.1),
+    function jU(e) {
+        var t = Fn(.1),
             n, i, r;
-        typeof e != "function" && (e = Pn(e == null ? 0 : +e));
+        typeof e != "function" && (e = Fn(e == null ? 0 : +e));
 
-        function a(o) {
+        function s(o) {
             for (var l = 0, u = n.length, c; l < u; ++l) c = n[l], c.vx += (r[l] - c.x) * i[l] * o
         }
 
-        function s() {
+        function a() {
             if (n) {
                 var o, l = n.length;
                 for (i = new Array(l), r = new Array(l), o = 0; o < l; ++o) i[o] = isNaN(r[o] = +e(n[o], o, n)) ? 0 : +t(n[o], o, n)
             }
         }
-        return a.initialize = function(o) {
-            n = o, s()
-        }, a.strength = function(o) {
-            return arguments.length ? (t = typeof o == "function" ? o : Pn(+o), s(), a) : t
-        }, a.x = function(o) {
-            return arguments.length ? (e = typeof o == "function" ? o : Pn(+o), s(), a) : e
-        }, a
+        return s.initialize = function(o) {
+            n = o, a()
+        }, s.strength = function(o) {
+            return arguments.length ? (t = typeof o == "function" ? o : Fn(+o), a(), s) : t
+        }, s.x = function(o) {
+            return arguments.length ? (e = typeof o == "function" ? o : Fn(+o), a(), s) : e
+        }, s
     }
 
-    function PU(e) {
-        var t = Pn(.1),
+    function UU(e) {
+        var t = Fn(.1),
             n, i, r;
-        typeof e != "function" && (e = Pn(e == null ? 0 : +e));
+        typeof e != "function" && (e = Fn(e == null ? 0 : +e));
 
-        function a(o) {
+        function s(o) {
             for (var l = 0, u = n.length, c; l < u; ++l) c = n[l], c.vy += (r[l] - c.y) * i[l] * o
         }
 
-        function s() {
+        function a() {
             if (n) {
                 var o, l = n.length;
                 for (i = new Array(l), r = new Array(l), o = 0; o < l; ++o) i[o] = isNaN(r[o] = +e(n[o], o, n)) ? 0 : +t(n[o], o, n)
             }
         }
-        return a.initialize = function(o) {
-            n = o, s()
-        }, a.strength = function(o) {
-            return arguments.length ? (t = typeof o == "function" ? o : Pn(+o), s(), a) : t
-        }, a.y = function(o) {
-            return arguments.length ? (e = typeof o == "function" ? o : Pn(+o), s(), a) : e
-        }, a
+        return s.initialize = function(o) {
+            n = o, a()
+        }, s.strength = function(o) {
+            return arguments.length ? (t = typeof o == "function" ? o : Fn(+o), a(), s) : t
+        }, s.y = function(o) {
+            return arguments.length ? (e = typeof o == "function" ? o : Fn(+o), a(), s) : e
+        }, s
     }
 
-    function NU(e) {
+    function GU(e) {
         return Math.abs(e = Math.round(e)) >= 1e21 ? e.toLocaleString("en").replace(/,/g, "") : e.toString(10)
     }
 
-    function Xp(e, t) {
+    function Tp(e, t) {
         if ((n = (e = t ? e.toExponential(t - 1) : e.toExponential()).indexOf("e")) < 0) return null;
         var n, i = e.slice(0, n);
         return [i.length > 1 ? i[0] + i.slice(2) : i, +e.slice(n + 1)]
     }
 
-    function qu(e) {
-        return e = Xp(Math.abs(e)), e ? e[1] : NaN
+    function Ru(e) {
+        return e = Tp(Math.abs(e)), e ? e[1] : NaN
     }
 
-    function LU(e, t) {
+    function WU(e, t) {
         return function(n, i) {
-            for (var r = n.length, a = [], s = 0, o = e[0], l = 0; r > 0 && o > 0 && (l + o + 1 > i && (o = Math.max(1, i - l)), a.push(n.substring(r -= o, r + o)), !((l += o + 1) > i));) o = e[s = (s + 1) % e.length];
-            return a.reverse().join(t)
+            for (var r = n.length, s = [], a = 0, o = e[0], l = 0; r > 0 && o > 0 && (l + o + 1 > i && (o = Math.max(1, i - l)), s.push(n.substring(r -= o, r + o)), !((l += o + 1) > i));) o = e[a = (a + 1) % e.length];
+            return s.reverse().join(t)
         }
     }
 
-    function IU(e) {
+    function qU(e) {
         return function(t) {
             return t.replace(/[0-9]/g, function(n) {
                 return e[+n]
             })
         }
     }
-    var jU = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
+    var HU = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
 
-    function cl(e) {
-        if (!(t = jU.exec(e))) throw new Error("invalid format: " + e);
+    function Qo(e) {
+        if (!(t = HU.exec(e))) throw new Error("invalid format: " + e);
         var t;
-        return new h_({
+        return new Ox({
             fill: t[1],
             align: t[2],
             sign: t[3],
             symbol: t[4],
             zero: t[5],
             width: t[6],
             comma: t[7],
             precision: t[8] && t[8].slice(1),
             trim: t[9],
             type: t[10]
         })
     }
-    cl.prototype = h_.prototype;
+    Qo.prototype = Ox.prototype;
 
-    function h_(e) {
+    function Ox(e) {
         this.fill = e.fill === void 0 ? " " : e.fill + "", this.align = e.align === void 0 ? ">" : e.align + "", this.sign = e.sign === void 0 ? "-" : e.sign + "", this.symbol = e.symbol === void 0 ? "" : e.symbol + "", this.zero = !!e.zero, this.width = e.width === void 0 ? void 0 : +e.width, this.comma = !!e.comma, this.precision = e.precision === void 0 ? void 0 : +e.precision, this.trim = !!e.trim, this.type = e.type === void 0 ? "" : e.type + ""
     }
-    h_.prototype.toString = function() {
+    Ox.prototype.toString = function() {
         return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type
     };
 
-    function zU(e) {
+    function YU(e) {
         e: for (var t = e.length, n = 1, i = -1, r; n < t; ++n) switch (e[n]) {
             case ".":
                 i = r = n;
                 break;
             case "0":
                 i === 0 && (i = n), r = n;
                 break;
             default:
                 if (!+e[n]) break e;
                 i > 0 && (i = 0);
                 break
         }
         return i > 0 ? e.slice(0, i) + e.slice(r + 1) : e
     }
-    var IF;
+    var VO;
 
-    function BU(e, t) {
-        var n = Xp(e, t);
+    function XU(e, t) {
+        var n = Tp(e, t);
         if (!n) return e + "";
         var i = n[0],
             r = n[1],
-            a = r - (IF = Math.max(-8, Math.min(8, Math.floor(r / 3))) * 3) + 1,
-            s = i.length;
-        return a === s ? i : a > s ? i + new Array(a - s + 1).join("0") : a > 0 ? i.slice(0, a) + "." + i.slice(a) : "0." + new Array(1 - a).join("0") + Xp(e, Math.max(0, t + a - 1))[0]
+            s = r - (VO = Math.max(-8, Math.min(8, Math.floor(r / 3))) * 3) + 1,
+            a = i.length;
+        return s === a ? i : s > a ? i + new Array(s - a + 1).join("0") : s > 0 ? i.slice(0, s) + "." + i.slice(s) : "0." + new Array(1 - s).join("0") + Tp(e, Math.max(0, t + s - 1))[0]
     }
 
-    function Nk(e, t) {
-        var n = Xp(e, t);
+    function Kk(e, t) {
+        var n = Tp(e, t);
         if (!n) return e + "";
         var i = n[0],
             r = n[1];
         return r < 0 ? "0." + new Array(-r).join("0") + i : i.length > r + 1 ? i.slice(0, r + 1) + "." + i.slice(r + 1) : i + new Array(r - i.length + 2).join("0")
     }
-    const Lk = {
+    const Jk = {
         "%": (e, t) => (e * 100).toFixed(t),
         b: e => Math.round(e).toString(2),
         c: e => e + "",
-        d: NU,
+        d: GU,
         e: (e, t) => e.toExponential(t),
         f: (e, t) => e.toFixed(t),
         g: (e, t) => e.toPrecision(t),
         o: e => Math.round(e).toString(8),
-        p: (e, t) => Nk(e * 100, t),
-        r: Nk,
-        s: BU,
+        p: (e, t) => Kk(e * 100, t),
+        r: Kk,
+        s: XU,
         X: e => Math.round(e).toString(16).toUpperCase(),
         x: e => Math.round(e).toString(16)
     };
 
-    function Ik(e) {
+    function Qk(e) {
         return e
     }
-    var jk = Array.prototype.map,
-        zk = ["y", "z", "a", "f", "p", "n", "µ", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
+    var Zk = Array.prototype.map,
+        eA = ["y", "z", "a", "f", "p", "n", "µ", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
 
-    function jF(e) {
-        var t = e.grouping === void 0 || e.thousands === void 0 ? Ik : LU(jk.call(e.grouping, Number), e.thousands + ""),
+    function KO(e) {
+        var t = e.grouping === void 0 || e.thousands === void 0 ? Qk : WU(Zk.call(e.grouping, Number), e.thousands + ""),
             n = e.currency === void 0 ? "" : e.currency[0] + "",
             i = e.currency === void 0 ? "" : e.currency[1] + "",
             r = e.decimal === void 0 ? "." : e.decimal + "",
-            a = e.numerals === void 0 ? Ik : IU(jk.call(e.numerals, String)),
-            s = e.percent === void 0 ? "%" : e.percent + "",
+            s = e.numerals === void 0 ? Qk : qU(Zk.call(e.numerals, String)),
+            a = e.percent === void 0 ? "%" : e.percent + "",
             o = e.minus === void 0 ? "−" : e.minus + "",
             l = e.nan === void 0 ? "NaN" : e.nan + "";
 
         function u(f) {
-            f = cl(f);
+            f = Qo(f);
             var h = f.fill,
                 d = f.align,
                 g = f.sign,
                 p = f.symbol,
                 m = f.zero,
                 y = f.width,
                 v = f.comma,
                 b = f.precision,
                 x = f.trim,
                 _ = f.type;
-            _ === "n" ? (v = !0, _ = "g") : Lk[_] || (b === void 0 && (b = 12), x = !0, _ = "g"), (m || h === "0" && d === "=") && (m = !0, h = "0", d = "=");
+            _ === "n" ? (v = !0, _ = "g") : Jk[_] || (b === void 0 && (b = 12), x = !0, _ = "g"), (m || h === "0" && d === "=") && (m = !0, h = "0", d = "=");
             var S = p === "$" ? n : p === "#" && /[boxX]/.test(_) ? "0" + _.toLowerCase() : "",
-                w = p === "$" ? i : /[%p]/.test(_) ? s : "",
-                O = Lk[_],
-                k = /[defgprs%]/.test(_);
+                w = p === "$" ? i : /[%p]/.test(_) ? a : "",
+                E = Jk[_],
+                A = /[defgprs%]/.test(_);
             b = b === void 0 ? 6 : /[gprs]/.test(_) ? Math.max(1, Math.min(21, b)) : Math.max(0, Math.min(20, b));
 
-            function C(E) {
-                var T = S,
-                    A = w,
-                    F, $, D;
-                if (_ === "c") A = O(E) + A, E = "";
+            function C(k) {
+                var R = S,
+                    $ = w,
+                    T, M, F;
+                if (_ === "c") $ = E(k) + $, k = "";
                 else {
-                    E = +E;
-                    var P = E < 0 || 1 / E < 0;
-                    if (E = isNaN(E) ? l : O(Math.abs(E), b), x && (E = zU(E)), P && +E == 0 && g !== "+" && (P = !1), T = (P ? g === "(" ? g : o : g === "-" || g === "(" ? "" : g) + T, A = (_ === "s" ? zk[8 + IF / 3] : "") + A + (P && g === "(" ? ")" : ""), k) {
-                        for (F = -1, $ = E.length; ++F < $;)
-                            if (D = E.charCodeAt(F), 48 > D || D > 57) {
-                                A = (D === 46 ? r + E.slice(F + 1) : E.slice(F)) + A, E = E.slice(0, F);
+                    k = +k;
+                    var N = k < 0 || 1 / k < 0;
+                    if (k = isNaN(k) ? l : E(Math.abs(k), b), x && (k = YU(k)), N && +k == 0 && g !== "+" && (N = !1), R = (N ? g === "(" ? g : o : g === "-" || g === "(" ? "" : g) + R, $ = (_ === "s" ? eA[8 + VO / 3] : "") + $ + (N && g === "(" ? ")" : ""), A) {
+                        for (T = -1, M = k.length; ++T < M;)
+                            if (F = k.charCodeAt(T), 48 > F || F > 57) {
+                                $ = (F === 46 ? r + k.slice(T + 1) : k.slice(T)) + $, k = k.slice(0, T);
                                 break
                             }
                     }
                 }
-                v && !m && (E = t(E, 1 / 0));
-                var N = T.length + E.length + A.length,
-                    z = N < y ? new Array(y - N + 1).join(h) : "";
-                switch (v && m && (E = t(z + E, z.length ? y - A.length : 1 / 0), z = ""), d) {
+                v && !m && (k = t(k, 1 / 0));
+                var P = R.length + k.length + $.length,
+                    z = P < y ? new Array(y - P + 1).join(h) : "";
+                switch (v && m && (k = t(z + k, z.length ? y - $.length : 1 / 0), z = ""), d) {
                     case "<":
-                        E = T + E + A + z;
+                        k = R + k + $ + z;
                         break;
                     case "=":
-                        E = T + z + E + A;
+                        k = R + z + k + $;
                         break;
                     case "^":
-                        E = z.slice(0, N = z.length >> 1) + T + E + A + z.slice(N);
+                        k = z.slice(0, P = z.length >> 1) + R + k + $ + z.slice(P);
                         break;
                     default:
-                        E = z + T + E + A;
+                        k = z + R + k + $;
                         break
                 }
-                return a(E)
+                return s(k)
             }
             return C.toString = function() {
                 return f + ""
             }, C
         }
 
         function c(f, h) {
-            var d = u((f = cl(f), f.type = "f", f)),
-                g = Math.max(-8, Math.min(8, Math.floor(qu(h) / 3))) * 3,
+            var d = u((f = Qo(f), f.type = "f", f)),
+                g = Math.max(-8, Math.min(8, Math.floor(Ru(h) / 3))) * 3,
                 p = Math.pow(10, -g),
-                m = zk[8 + g / 3];
+                m = eA[8 + g / 3];
             return function(y) {
                 return d(p * y) + m
             }
         }
         return {
             format: u,
             formatPrefix: c
         }
     }
-    var bg, Am, d_;
-    GU({
+    var rg, lm, Fx;
+    VU({
         thousands: ",",
         grouping: [3],
         currency: ["$", ""]
     });
 
-    function GU(e) {
-        return bg = jF(e), Am = bg.format, d_ = bg.formatPrefix, bg
+    function VU(e) {
+        return rg = KO(e), lm = rg.format, Fx = rg.formatPrefix, rg
     }
 
-    function zF(e) {
-        return Math.max(0, -qu(Math.abs(e)))
+    function JO(e) {
+        return Math.max(0, -Ru(Math.abs(e)))
     }
 
-    function BF(e, t) {
-        return Math.max(0, Math.max(-8, Math.min(8, Math.floor(qu(t) / 3))) * 3 - qu(Math.abs(e)))
+    function QO(e, t) {
+        return Math.max(0, Math.max(-8, Math.min(8, Math.floor(Ru(t) / 3))) * 3 - Ru(Math.abs(e)))
     }
 
-    function GF(e, t) {
-        return e = Math.abs(e), t = Math.abs(t) - e, Math.max(0, qu(t) - qu(e)) + 1
+    function ZO(e, t) {
+        return e = Math.abs(e), t = Math.abs(t) - e, Math.max(0, Ru(t) - Ru(e)) + 1
     }
     var ve = 1e-6,
-        Vp = 1e-12,
-        De = Math.PI,
-        _t = De / 2,
-        Kp = De / 4,
-        zn = De * 2,
-        Ct = 180 / De,
-        Me = De / 180,
-        Ne = Math.abs,
-        kc = Math.atan,
-        Li = Math.atan2,
-        be = Math.cos,
-        xg = Math.ceil,
-        UF = Math.exp,
-        Gb = Math.hypot,
-        Jp = Math.log,
-        Jy = Math.pow,
-        ge = Math.sin,
-        Mi = Math.sign || function(e) {
+        Mp = 1e-12,
+        Oe = Math.PI,
+        vt = Oe / 2,
+        Op = Oe / 4,
+        Ln = Oe * 2,
+        St = 180 / Oe,
+        Me = Oe / 180,
+        Re = Math.abs,
+        pc = Math.atan,
+        Fi = Math.atan2,
+        xe = Math.cos,
+        sg = Math.ceil,
+        eF = Math.exp,
+        mb = Math.hypot,
+        Fp = Math.log,
+        Ty = Math.pow,
+        pe = Math.sin,
+        ki = Math.sign || function(e) {
             return e > 0 ? 1 : e < 0 ? -1 : 0
         },
-        Bn = Math.sqrt,
-        g_ = Math.tan;
+        In = Math.sqrt,
+        Rx = Math.tan;
 
-    function qF(e) {
-        return e > 1 ? 0 : e < -1 ? De : Math.acos(e)
+    function tF(e) {
+        return e > 1 ? 0 : e < -1 ? Oe : Math.acos(e)
     }
 
-    function ii(e) {
-        return e > 1 ? _t : e < -1 ? -_t : Math.asin(e)
+    function ti(e) {
+        return e > 1 ? vt : e < -1 ? -vt : Math.asin(e)
     }
 
-    function Zt() {}
+    function Vt() {}
 
-    function Qp(e, t) {
-        e && Gk.hasOwnProperty(e.type) && Gk[e.type](e, t)
+    function Rp(e, t) {
+        e && nA.hasOwnProperty(e.type) && nA[e.type](e, t)
     }
-    var Bk = {
+    var tA = {
             Feature: function(e, t) {
-                Qp(e.geometry, t)
+                Rp(e.geometry, t)
             },
             FeatureCollection: function(e, t) {
-                for (var n = e.features, i = -1, r = n.length; ++i < r;) Qp(n[i].geometry, t)
+                for (var n = e.features, i = -1, r = n.length; ++i < r;) Rp(n[i].geometry, t)
             }
         },
-        Gk = {
+        nA = {
             Sphere: function(e, t) {
                 t.sphere()
             },
             Point: function(e, t) {
                 e = e.coordinates, t.point(e[0], e[1], e[2])
             },
             MultiPoint: function(e, t) {
                 for (var n = e.coordinates, i = -1, r = n.length; ++i < r;) e = n[i], t.point(e[0], e[1], e[2])
             },
             LineString: function(e, t) {
-                Ub(e.coordinates, t, 0)
+                yb(e.coordinates, t, 0)
             },
             MultiLineString: function(e, t) {
-                for (var n = e.coordinates, i = -1, r = n.length; ++i < r;) Ub(n[i], t, 0)
+                for (var n = e.coordinates, i = -1, r = n.length; ++i < r;) yb(n[i], t, 0)
             },
             Polygon: function(e, t) {
-                Uk(e.coordinates, t)
+                iA(e.coordinates, t)
             },
             MultiPolygon: function(e, t) {
-                for (var n = e.coordinates, i = -1, r = n.length; ++i < r;) Uk(n[i], t)
+                for (var n = e.coordinates, i = -1, r = n.length; ++i < r;) iA(n[i], t)
             },
             GeometryCollection: function(e, t) {
-                for (var n = e.geometries, i = -1, r = n.length; ++i < r;) Qp(n[i], t)
+                for (var n = e.geometries, i = -1, r = n.length; ++i < r;) Rp(n[i], t)
             }
         };
 
-    function Ub(e, t, n) {
+    function yb(e, t, n) {
         var i = -1,
             r = e.length - n,
-            a;
-        for (t.lineStart(); ++i < r;) a = e[i], t.point(a[0], a[1], a[2]);
+            s;
+        for (t.lineStart(); ++i < r;) s = e[i], t.point(s[0], s[1], s[2]);
         t.lineEnd()
     }
 
-    function Uk(e, t) {
+    function iA(e, t) {
         var n = -1,
             i = e.length;
-        for (t.polygonStart(); ++n < i;) Ub(e[n], t, 1);
+        for (t.polygonStart(); ++n < i;) yb(e[n], t, 1);
         t.polygonEnd()
     }
 
-    function Fa(e, t) {
-        e && Bk.hasOwnProperty(e.type) ? Bk[e.type](e, t) : Qp(e, t)
+    function ws(e, t) {
+        e && tA.hasOwnProperty(e.type) ? tA[e.type](e, t) : Rp(e, t)
     }
-    var Zp = new Nn,
-        e0 = new Nn,
-        WF, HF, qb, Wb, Hb, Kr = {
-            point: Zt,
-            lineStart: Zt,
-            lineEnd: Zt,
+    var Dp = new Rn,
+        Np = new Rn,
+        nF, iF, vb, bb, xb, Gr = {
+            point: Vt,
+            lineStart: Vt,
+            lineEnd: Vt,
             polygonStart: function() {
-                Zp = new Nn, Kr.lineStart = UU, Kr.lineEnd = qU
+                Dp = new Rn, Gr.lineStart = KU, Gr.lineEnd = JU
             },
             polygonEnd: function() {
-                var e = +Zp;
-                e0.add(e < 0 ? zn + e : e), this.lineStart = this.lineEnd = this.point = Zt
+                var e = +Dp;
+                Np.add(e < 0 ? Ln + e : e), this.lineStart = this.lineEnd = this.point = Vt
             },
             sphere: function() {
-                e0.add(zn)
+                Np.add(Ln)
             }
         };
 
-    function UU() {
-        Kr.point = WU
+    function KU() {
+        Gr.point = QU
     }
 
-    function qU() {
-        YF(WF, HF)
+    function JU() {
+        rF(nF, iF)
     }
 
-    function WU(e, t) {
-        Kr.point = YF, WF = e, HF = t, e *= Me, t *= Me, qb = e, Wb = be(t = t / 2 + Kp), Hb = ge(t)
+    function QU(e, t) {
+        Gr.point = rF, nF = e, iF = t, e *= Me, t *= Me, vb = e, bb = xe(t = t / 2 + Op), xb = pe(t)
     }
 
-    function YF(e, t) {
-        e *= Me, t *= Me, t = t / 2 + Kp;
-        var n = e - qb,
+    function rF(e, t) {
+        e *= Me, t *= Me, t = t / 2 + Op;
+        var n = e - vb,
             i = n >= 0 ? 1 : -1,
             r = i * n,
-            a = be(t),
-            s = ge(t),
-            o = Hb * s,
-            l = Wb * a + o * be(r),
-            u = o * i * ge(r);
-        Zp.add(Li(u, l)), qb = e, Wb = a, Hb = s
+            s = xe(t),
+            a = pe(t),
+            o = xb * a,
+            l = bb * s + o * xe(r),
+            u = o * i * pe(r);
+        Dp.add(Fi(u, l)), vb = e, bb = s, xb = a
     }
 
-    function HU(e) {
-        return e0 = new Nn, Fa(e, Kr), e0 * 2
+    function ZU(e) {
+        return Np = new Rn, ws(e, Gr), Np * 2
     }
 
-    function t0(e) {
-        return [Li(e[1], e[0]), ii(e[2])]
+    function Pp(e) {
+        return [Fi(e[1], e[0]), ti(e[2])]
     }
 
-    function fl(e) {
+    function Zo(e) {
         var t = e[0],
             n = e[1],
-            i = be(n);
-        return [i * be(t), i * ge(t), ge(n)]
+            i = xe(n);
+        return [i * xe(t), i * pe(t), pe(n)]
     }
 
-    function _g(e, t) {
+    function ag(e, t) {
         return e[0] * t[0] + e[1] * t[1] + e[2] * t[2]
     }
 
-    function Wu(e, t) {
+    function Du(e, t) {
         return [e[1] * t[2] - e[2] * t[1], e[2] * t[0] - e[0] * t[2], e[0] * t[1] - e[1] * t[0]]
     }
 
-    function Qy(e, t) {
+    function My(e, t) {
         e[0] += t[0], e[1] += t[1], e[2] += t[2]
     }
 
-    function wg(e, t) {
+    function og(e, t) {
         return [e[0] * t, e[1] * t, e[2] * t]
     }
 
-    function n0(e) {
-        var t = Bn(e[0] * e[0] + e[1] * e[1] + e[2] * e[2]);
+    function Lp(e) {
+        var t = In(e[0] * e[0] + e[1] * e[1] + e[2] * e[2]);
         e[0] /= t, e[1] /= t, e[2] /= t
     }
-    var gt, Yn, bt, gi, Lo, XF, VF, Fu, lh, ms, Ha, Ta = {
-        point: Yb,
-        lineStart: qk,
-        lineEnd: Wk,
+    var dt, qn, mt, hi, Co, sF, aF, _u, Kf, aa, Ls, bs = {
+        point: _b,
+        lineStart: rA,
+        lineEnd: sA,
         polygonStart: function() {
-            Ta.point = JF, Ta.lineStart = YU, Ta.lineEnd = XU, lh = new Nn, Kr.polygonStart()
+            bs.point = lF, bs.lineStart = eG, bs.lineEnd = tG, Kf = new Rn, Gr.polygonStart()
         },
         polygonEnd: function() {
-            Kr.polygonEnd(), Ta.point = Yb, Ta.lineStart = qk, Ta.lineEnd = Wk, Zp < 0 ? (gt = -(bt = 180), Yn = -(gi = 90)) : lh > ve ? gi = 90 : lh < -ve && (Yn = -90), Ha[0] = gt, Ha[1] = bt
+            Gr.polygonEnd(), bs.point = _b, bs.lineStart = rA, bs.lineEnd = sA, Dp < 0 ? (dt = -(mt = 180), qn = -(hi = 90)) : Kf > ve ? hi = 90 : Kf < -ve && (qn = -90), Ls[0] = dt, Ls[1] = mt
         },
         sphere: function() {
-            gt = -(bt = 180), Yn = -(gi = 90)
+            dt = -(mt = 180), qn = -(hi = 90)
         }
     };
 
-    function Yb(e, t) {
-        ms.push(Ha = [gt = e, bt = e]), t < Yn && (Yn = t), t > gi && (gi = t)
+    function _b(e, t) {
+        aa.push(Ls = [dt = e, mt = e]), t < qn && (qn = t), t > hi && (hi = t)
     }
 
-    function KF(e, t) {
-        var n = fl([e * Me, t * Me]);
-        if (Fu) {
-            var i = Wu(Fu, n),
+    function oF(e, t) {
+        var n = Zo([e * Me, t * Me]);
+        if (_u) {
+            var i = Du(_u, n),
                 r = [i[1], -i[0], 0],
-                a = Wu(r, i);
-            n0(a), a = t0(a);
-            var s = e - Lo,
-                o = s > 0 ? 1 : -1,
-                l = a[0] * Ct * o,
-                u, c = Ne(s) > 180;
-            c ^ (o * Lo < l && l < o * e) ? (u = a[1] * Ct, u > gi && (gi = u)) : (l = (l + 360) % 360 - 180, c ^ (o * Lo < l && l < o * e) ? (u = -a[1] * Ct, u < Yn && (Yn = u)) : (t < Yn && (Yn = t), t > gi && (gi = t))), c ? e < Lo ? di(gt, e) > di(gt, bt) && (bt = e) : di(e, bt) > di(gt, bt) && (gt = e) : bt >= gt ? (e < gt && (gt = e), e > bt && (bt = e)) : e > Lo ? di(gt, e) > di(gt, bt) && (bt = e) : di(e, bt) > di(gt, bt) && (gt = e)
-        } else ms.push(Ha = [gt = e, bt = e]);
-        t < Yn && (Yn = t), t > gi && (gi = t), Fu = n, Lo = e
+                s = Du(r, i);
+            Lp(s), s = Pp(s);
+            var a = e - Co,
+                o = a > 0 ? 1 : -1,
+                l = s[0] * St * o,
+                u, c = Re(a) > 180;
+            c ^ (o * Co < l && l < o * e) ? (u = s[1] * St, u > hi && (hi = u)) : (l = (l + 360) % 360 - 180, c ^ (o * Co < l && l < o * e) ? (u = -s[1] * St, u < qn && (qn = u)) : (t < qn && (qn = t), t > hi && (hi = t))), c ? e < Co ? fi(dt, e) > fi(dt, mt) && (mt = e) : fi(e, mt) > fi(dt, mt) && (dt = e) : mt >= dt ? (e < dt && (dt = e), e > mt && (mt = e)) : e > Co ? fi(dt, e) > fi(dt, mt) && (mt = e) : fi(e, mt) > fi(dt, mt) && (dt = e)
+        } else aa.push(Ls = [dt = e, mt = e]);
+        t < qn && (qn = t), t > hi && (hi = t), _u = n, Co = e
     }
 
-    function qk() {
-        Ta.point = KF
+    function rA() {
+        bs.point = oF
     }
 
-    function Wk() {
-        Ha[0] = gt, Ha[1] = bt, Ta.point = Yb, Fu = null
+    function sA() {
+        Ls[0] = dt, Ls[1] = mt, bs.point = _b, _u = null
     }
 
-    function JF(e, t) {
-        if (Fu) {
-            var n = e - Lo;
-            lh.add(Ne(n) > 180 ? n + (n > 0 ? 360 : -360) : n)
-        } else XF = e, VF = t;
-        Kr.point(e, t), KF(e, t)
+    function lF(e, t) {
+        if (_u) {
+            var n = e - Co;
+            Kf.add(Re(n) > 180 ? n + (n > 0 ? 360 : -360) : n)
+        } else sF = e, aF = t;
+        Gr.point(e, t), oF(e, t)
     }
 
-    function YU() {
-        Kr.lineStart()
+    function eG() {
+        Gr.lineStart()
     }
 
-    function XU() {
-        JF(XF, VF), Kr.lineEnd(), Ne(lh) > ve && (gt = -(bt = 180)), Ha[0] = gt, Ha[1] = bt, Fu = null
+    function tG() {
+        lF(sF, aF), Gr.lineEnd(), Re(Kf) > ve && (dt = -(mt = 180)), Ls[0] = dt, Ls[1] = mt, _u = null
     }
 
-    function di(e, t) {
+    function fi(e, t) {
         return (t -= e) < 0 ? t + 360 : t
     }
 
-    function VU(e, t) {
+    function nG(e, t) {
         return e[0] - t[0]
     }
 
-    function Hk(e, t) {
+    function aA(e, t) {
         return e[0] <= e[1] ? e[0] <= t && t <= e[1] : t < e[0] || e[1] < t
     }
 
-    function KU(e) {
-        var t, n, i, r, a, s, o;
-        if (gi = bt = -(gt = Yn = 1 / 0), ms = [], Fa(e, Ta), n = ms.length) {
-            for (ms.sort(VU), t = 1, i = ms[0], a = [i]; t < n; ++t) r = ms[t], Hk(i, r[0]) || Hk(i, r[1]) ? (di(i[0], r[1]) > di(i[0], i[1]) && (i[1] = r[1]), di(r[0], i[1]) > di(i[0], i[1]) && (i[0] = r[0])) : a.push(i = r);
-            for (s = -1 / 0, n = a.length - 1, t = 0, i = a[n]; t <= n; i = r, ++t) r = a[t], (o = di(i[1], r[0])) > s && (s = o, gt = r[0], bt = i[1])
+    function iG(e) {
+        var t, n, i, r, s, a, o;
+        if (hi = mt = -(dt = qn = 1 / 0), aa = [], ws(e, bs), n = aa.length) {
+            for (aa.sort(nG), t = 1, i = aa[0], s = [i]; t < n; ++t) r = aa[t], aA(i, r[0]) || aA(i, r[1]) ? (fi(i[0], r[1]) > fi(i[0], i[1]) && (i[1] = r[1]), fi(r[0], i[1]) > fi(i[0], i[1]) && (i[0] = r[0])) : s.push(i = r);
+            for (a = -1 / 0, n = s.length - 1, t = 0, i = s[n]; t <= n; i = r, ++t) r = s[t], (o = fi(i[1], r[0])) > a && (a = o, dt = r[0], mt = i[1])
         }
-        return ms = Ha = null, gt === 1 / 0 || Yn === 1 / 0 ? [
+        return aa = Ls = null, dt === 1 / 0 || qn === 1 / 0 ? [
             [NaN, NaN],
             [NaN, NaN]
         ] : [
-            [gt, Yn],
-            [bt, gi]
+            [dt, qn],
+            [mt, hi]
         ]
     }
-    var Nf, i0, r0, a0, s0, o0, l0, u0, Xb, Vb, Kb, QF, ZF, Mn, Fn, Dn, ur = {
-        sphere: Zt,
-        point: p_,
-        lineStart: Yk,
-        lineEnd: Xk,
+    var Ef, Ip, zp, Bp, jp, Up, Gp, Wp, wb, Sb, Eb, uF, cF, $n, Tn, Mn, tr = {
+        sphere: Vt,
+        point: Dx,
+        lineStart: oA,
+        lineEnd: lA,
         polygonStart: function() {
-            ur.lineStart = ZU, ur.lineEnd = eq
+            tr.lineStart = aG, tr.lineEnd = oG
         },
         polygonEnd: function() {
-            ur.lineStart = Yk, ur.lineEnd = Xk
+            tr.lineStart = oA, tr.lineEnd = lA
         }
     };
 
-    function p_(e, t) {
+    function Dx(e, t) {
         e *= Me, t *= Me;
-        var n = be(t);
-        dd(n * be(e), n * ge(e), ge(t))
+        var n = xe(t);
+        td(n * xe(e), n * pe(e), pe(t))
     }
 
-    function dd(e, t, n) {
-        ++Nf, r0 += (e - r0) / Nf, a0 += (t - a0) / Nf, s0 += (n - s0) / Nf
+    function td(e, t, n) {
+        ++Ef, zp += (e - zp) / Ef, Bp += (t - Bp) / Ef, jp += (n - jp) / Ef
     }
 
-    function Yk() {
-        ur.point = JU
+    function oA() {
+        tr.point = rG
     }
 
-    function JU(e, t) {
+    function rG(e, t) {
         e *= Me, t *= Me;
-        var n = be(t);
-        Mn = n * be(e), Fn = n * ge(e), Dn = ge(t), ur.point = QU, dd(Mn, Fn, Dn)
+        var n = xe(t);
+        $n = n * xe(e), Tn = n * pe(e), Mn = pe(t), tr.point = sG, td($n, Tn, Mn)
     }
 
-    function QU(e, t) {
+    function sG(e, t) {
         e *= Me, t *= Me;
-        var n = be(t),
-            i = n * be(e),
-            r = n * ge(e),
-            a = ge(t),
-            s = Li(Bn((s = Fn * a - Dn * r) * s + (s = Dn * i - Mn * a) * s + (s = Mn * r - Fn * i) * s), Mn * i + Fn * r + Dn * a);
-        i0 += s, o0 += s * (Mn + (Mn = i)), l0 += s * (Fn + (Fn = r)), u0 += s * (Dn + (Dn = a)), dd(Mn, Fn, Dn)
+        var n = xe(t),
+            i = n * xe(e),
+            r = n * pe(e),
+            s = pe(t),
+            a = Fi(In((a = Tn * s - Mn * r) * a + (a = Mn * i - $n * s) * a + (a = $n * r - Tn * i) * a), $n * i + Tn * r + Mn * s);
+        Ip += a, Up += a * ($n + ($n = i)), Gp += a * (Tn + (Tn = r)), Wp += a * (Mn + (Mn = s)), td($n, Tn, Mn)
     }
 
-    function Xk() {
-        ur.point = p_
+    function lA() {
+        tr.point = Dx
     }
 
-    function ZU() {
-        ur.point = tq
+    function aG() {
+        tr.point = lG
     }
 
-    function eq() {
-        eD(QF, ZF), ur.point = p_
+    function oG() {
+        fF(uF, cF), tr.point = Dx
     }
 
-    function tq(e, t) {
-        QF = e, ZF = t, e *= Me, t *= Me, ur.point = eD;
-        var n = be(t);
-        Mn = n * be(e), Fn = n * ge(e), Dn = ge(t), dd(Mn, Fn, Dn)
+    function lG(e, t) {
+        uF = e, cF = t, e *= Me, t *= Me, tr.point = fF;
+        var n = xe(t);
+        $n = n * xe(e), Tn = n * pe(e), Mn = pe(t), td($n, Tn, Mn)
     }
 
-    function eD(e, t) {
+    function fF(e, t) {
         e *= Me, t *= Me;
-        var n = be(t),
-            i = n * be(e),
-            r = n * ge(e),
-            a = ge(t),
-            s = Fn * a - Dn * r,
-            o = Dn * i - Mn * a,
-            l = Mn * r - Fn * i,
-            u = Gb(s, o, l),
-            c = ii(u),
+        var n = xe(t),
+            i = n * xe(e),
+            r = n * pe(e),
+            s = pe(t),
+            a = Tn * s - Mn * r,
+            o = Mn * i - $n * s,
+            l = $n * r - Tn * i,
+            u = mb(a, o, l),
+            c = ti(u),
             f = u && -c / u;
-        Xb.add(f * s), Vb.add(f * o), Kb.add(f * l), i0 += c, o0 += c * (Mn + (Mn = i)), l0 += c * (Fn + (Fn = r)), u0 += c * (Dn + (Dn = a)), dd(Mn, Fn, Dn)
+        wb.add(f * a), Sb.add(f * o), Eb.add(f * l), Ip += c, Up += c * ($n + ($n = i)), Gp += c * (Tn + (Tn = r)), Wp += c * (Mn + (Mn = s)), td($n, Tn, Mn)
     }
 
-    function nq(e) {
-        Nf = i0 = r0 = a0 = s0 = o0 = l0 = u0 = 0, Xb = new Nn, Vb = new Nn, Kb = new Nn, Fa(e, ur);
-        var t = +Xb,
-            n = +Vb,
-            i = +Kb,
-            r = Gb(t, n, i);
-        return r < Vp && (t = o0, n = l0, i = u0, i0 < ve && (t = r0, n = a0, i = s0), r = Gb(t, n, i), r < Vp) ? [NaN, NaN] : [Li(n, t) * Ct, ii(i / r) * Ct]
+    function uG(e) {
+        Ef = Ip = zp = Bp = jp = Up = Gp = Wp = 0, wb = new Rn, Sb = new Rn, Eb = new Rn, ws(e, tr);
+        var t = +wb,
+            n = +Sb,
+            i = +Eb,
+            r = mb(t, n, i);
+        return r < Mp && (t = Up, n = Gp, i = Wp, Ip < ve && (t = zp, n = Bp, i = jp), r = mb(t, n, i), r < Mp) ? [NaN, NaN] : [Fi(n, t) * St, ti(i / r) * St]
     }
 
-    function Jb(e, t) {
+    function Cb(e, t) {
         function n(i, r) {
             return i = e(i, r), t(i[0], i[1])
         }
         return e.invert && t.invert && (n.invert = function(i, r) {
             return i = t.invert(i, r), i && e.invert(i[0], i[1])
         }), n
     }
 
-    function Qb(e, t) {
-        return Ne(e) > De && (e -= Math.round(e / zn) * zn), [e, t]
+    function kb(e, t) {
+        return Re(e) > Oe && (e -= Math.round(e / Ln) * Ln), [e, t]
     }
-    Qb.invert = Qb;
+    kb.invert = kb;
 
-    function tD(e, t, n) {
-        return (e %= zn) ? t || n ? Jb(Kk(e), Jk(t, n)) : Kk(e) : t || n ? Jk(t, n) : Qb
+    function hF(e, t, n) {
+        return (e %= Ln) ? t || n ? Cb(cA(e), fA(t, n)) : cA(e) : t || n ? fA(t, n) : kb
     }
 
-    function Vk(e) {
+    function uA(e) {
         return function(t, n) {
-            return t += e, Ne(t) > De && (t -= Math.round(t / zn) * zn), [t, n]
+            return t += e, Re(t) > Oe && (t -= Math.round(t / Ln) * Ln), [t, n]
         }
     }
 
-    function Kk(e) {
-        var t = Vk(e);
-        return t.invert = Vk(-e), t
+    function cA(e) {
+        var t = uA(e);
+        return t.invert = uA(-e), t
     }
 
-    function Jk(e, t) {
-        var n = be(e),
-            i = ge(e),
-            r = be(t),
-            a = ge(t);
+    function fA(e, t) {
+        var n = xe(e),
+            i = pe(e),
+            r = xe(t),
+            s = pe(t);
 
-        function s(o, l) {
-            var u = be(l),
-                c = be(o) * u,
-                f = ge(o) * u,
-                h = ge(l),
+        function a(o, l) {
+            var u = xe(l),
+                c = xe(o) * u,
+                f = pe(o) * u,
+                h = pe(l),
                 d = h * n + c * i;
-            return [Li(f * r - d * a, c * n - h * i), ii(d * r + f * a)]
+            return [Fi(f * r - d * s, c * n - h * i), ti(d * r + f * s)]
         }
-        return s.invert = function(o, l) {
-            var u = be(l),
-                c = be(o) * u,
-                f = ge(o) * u,
-                h = ge(l),
-                d = h * r - f * a;
-            return [Li(f * r + h * a, c * n + d * i), ii(d * n - c * i)]
-        }, s
+        return a.invert = function(o, l) {
+            var u = xe(l),
+                c = xe(o) * u,
+                f = pe(o) * u,
+                h = pe(l),
+                d = h * r - f * s;
+            return [Fi(f * r + h * s, c * n + d * i), ti(d * n - c * i)]
+        }, a
     }
 
-    function iq(e) {
-        e = tD(e[0] * Me, e[1] * Me, e.length > 2 ? e[2] * Me : 0);
+    function cG(e) {
+        e = hF(e[0] * Me, e[1] * Me, e.length > 2 ? e[2] * Me : 0);
 
         function t(n) {
-            return n = e(n[0] * Me, n[1] * Me), n[0] *= Ct, n[1] *= Ct, n
+            return n = e(n[0] * Me, n[1] * Me), n[0] *= St, n[1] *= St, n
         }
         return t.invert = function(n) {
-            return n = e.invert(n[0] * Me, n[1] * Me), n[0] *= Ct, n[1] *= Ct, n
+            return n = e.invert(n[0] * Me, n[1] * Me), n[0] *= St, n[1] *= St, n
         }, t
     }
 
-    function rq(e, t, n, i, r, a) {
+    function fG(e, t, n, i, r, s) {
         if (n) {
-            var s = be(t),
-                o = ge(t),
+            var a = xe(t),
+                o = pe(t),
                 l = i * n;
-            r == null ? (r = t + i * zn, a = t - l / 2) : (r = Qk(s, r), a = Qk(s, a), (i > 0 ? r < a : r > a) && (r += i * zn));
-            for (var u, c = r; i > 0 ? c > a : c < a; c -= l) u = t0([s, -o * be(c), -o * ge(c)]), e.point(u[0], u[1])
+            r == null ? (r = t + i * Ln, s = t - l / 2) : (r = hA(a, r), s = hA(a, s), (i > 0 ? r < s : r > s) && (r += i * Ln));
+            for (var u, c = r; i > 0 ? c > s : c < s; c -= l) u = Pp([a, -o * xe(c), -o * pe(c)]), e.point(u[0], u[1])
         }
     }
 
-    function Qk(e, t) {
-        t = fl(t), t[0] -= e, n0(t);
-        var n = qF(-t[1]);
-        return ((-t[2] < 0 ? -n : n) + zn - ve) % zn
+    function hA(e, t) {
+        t = Zo(t), t[0] -= e, Lp(t);
+        var n = tF(-t[1]);
+        return ((-t[2] < 0 ? -n : n) + Ln - ve) % Ln
     }
 
-    function nD() {
+    function dF() {
         var e = [],
             t;
         return {
             point: function(n, i, r) {
                 t.push([n, i, r])
             },
             lineStart: function() {
                 e.push(t = [])
             },
-            lineEnd: Zt,
+            lineEnd: Vt,
             rejoin: function() {
                 e.length > 1 && e.push(e.pop().concat(e.shift()))
             },
             result: function() {
                 var n = e;
                 return e = [], t = null, n
             }
         }
     }
 
-    function cp(e, t) {
-        return Ne(e[0] - t[0]) < ve && Ne(e[1] - t[1]) < ve
+    function Hg(e, t) {
+        return Re(e[0] - t[0]) < ve && Re(e[1] - t[1]) < ve
     }
 
-    function Sg(e, t, n, i) {
+    function lg(e, t, n, i) {
         this.x = e, this.z = t, this.o = n, this.e = i, this.v = !1, this.n = this.p = null
     }
 
-    function iD(e, t, n, i, r) {
-        var a = [],
-            s = [],
+    function gF(e, t, n, i, r) {
+        var s = [],
+            a = [],
             o, l;
         if (e.forEach(function(g) {
                 if (!((p = g.length - 1) <= 0)) {
                     var p, m = g[0],
                         y = g[p],
                         v;
-                    if (cp(m, y)) {
+                    if (Hg(m, y)) {
                         if (!m[2] && !y[2]) {
                             for (r.lineStart(), o = 0; o < p; ++o) r.point((m = g[o])[0], m[1]);
                             r.lineEnd();
                             return
                         }
                         y[0] += 2 * ve
                     }
-                    a.push(v = new Sg(m, g, null, !0)), s.push(v.o = new Sg(m, null, v, !1)), a.push(v = new Sg(y, g, null, !1)), s.push(v.o = new Sg(y, null, v, !0))
+                    s.push(v = new lg(m, g, null, !0)), a.push(v.o = new lg(m, null, v, !1)), s.push(v = new lg(y, g, null, !1)), a.push(v.o = new lg(y, null, v, !0))
                 }
-            }), !!a.length) {
-            for (s.sort(t), Zk(a), Zk(s), o = 0, l = s.length; o < l; ++o) s[o].e = n = !n;
-            for (var u = a[0], c, f;;) {
+            }), !!s.length) {
+            for (a.sort(t), dA(s), dA(a), o = 0, l = a.length; o < l; ++o) a[o].e = n = !n;
+            for (var u = s[0], c, f;;) {
                 for (var h = u, d = !0; h.v;)
                     if ((h = h.n) === u) return;
                 c = h.z, r.lineStart();
                 do {
                     if (h.v = h.o.v = !0, h.e) {
                         if (d)
                             for (o = 0, l = c.length; o < l; ++o) r.point((f = c[o])[0], f[1]);
@@ -11008,281 +11008,281 @@
                     h = h.o, c = h.z, d = !d
                 } while (!h.v);
                 r.lineEnd()
             }
         }
     }
 
-    function Zk(e) {
+    function dA(e) {
         if (t = e.length) {
             for (var t, n = 0, i = e[0], r; ++n < t;) i.n = r = e[n], r.p = i, i = r;
             i.n = r = e[0], r.p = i
         }
     }
 
-    function Zy(e) {
-        return Ne(e[0]) <= De ? e[0] : Mi(e[0]) * ((Ne(e[0]) + De) % zn - De)
+    function Oy(e) {
+        return Re(e[0]) <= Oe ? e[0] : ki(e[0]) * ((Re(e[0]) + Oe) % Ln - Oe)
     }
 
-    function aq(e, t) {
-        var n = Zy(t),
+    function hG(e, t) {
+        var n = Oy(t),
             i = t[1],
-            r = ge(i),
-            a = [ge(n), -be(n), 0],
-            s = 0,
+            r = pe(i),
+            s = [pe(n), -xe(n), 0],
+            a = 0,
             o = 0,
-            l = new Nn;
-        r === 1 ? i = _t + ve : r === -1 && (i = -_t - ve);
+            l = new Rn;
+        r === 1 ? i = vt + ve : r === -1 && (i = -vt - ve);
         for (var u = 0, c = e.length; u < c; ++u)
             if (h = (f = e[u]).length)
-                for (var f, h, d = f[h - 1], g = Zy(d), p = d[1] / 2 + Kp, m = ge(p), y = be(p), v = 0; v < h; ++v, g = x, m = S, y = w, d = b) {
+                for (var f, h, d = f[h - 1], g = Oy(d), p = d[1] / 2 + Op, m = pe(p), y = xe(p), v = 0; v < h; ++v, g = x, m = S, y = w, d = b) {
                     var b = f[v],
-                        x = Zy(b),
-                        _ = b[1] / 2 + Kp,
-                        S = ge(_),
-                        w = be(_),
-                        O = x - g,
-                        k = O >= 0 ? 1 : -1,
-                        C = k * O,
-                        E = C > De,
-                        T = m * S;
-                    if (l.add(Li(T * k * ge(C), y * w + T * be(C))), s += E ? O + k * zn : O, E ^ g >= n ^ x >= n) {
-                        var A = Wu(fl(d), fl(b));
-                        n0(A);
-                        var F = Wu(a, A);
-                        n0(F);
-                        var $ = (E ^ O >= 0 ? -1 : 1) * ii(F[2]);
-                        (i > $ || i === $ && (A[0] || A[1])) && (o += E ^ O >= 0 ? 1 : -1)
+                        x = Oy(b),
+                        _ = b[1] / 2 + Op,
+                        S = pe(_),
+                        w = xe(_),
+                        E = x - g,
+                        A = E >= 0 ? 1 : -1,
+                        C = A * E,
+                        k = C > Oe,
+                        R = m * S;
+                    if (l.add(Fi(R * A * pe(C), y * w + R * xe(C))), a += k ? E + A * Ln : E, k ^ g >= n ^ x >= n) {
+                        var $ = Du(Zo(d), Zo(b));
+                        Lp($);
+                        var T = Du(s, $);
+                        Lp(T);
+                        var M = (k ^ E >= 0 ? -1 : 1) * ti(T[2]);
+                        (i > M || i === M && ($[0] || $[1])) && (o += k ^ E >= 0 ? 1 : -1)
                     }
                 }
-        return (s < -ve || s < ve && l < -Vp) ^ o & 1
+        return (a < -ve || a < ve && l < -Mp) ^ o & 1
     }
 
-    function rD(e, t, n, i) {
+    function pF(e, t, n, i) {
         return function(r) {
-            var a = t(r),
-                s = nD(),
-                o = t(s),
+            var s = t(r),
+                a = dF(),
+                o = t(a),
                 l = !1,
                 u, c, f, h = {
                     point: d,
                     lineStart: p,
                     lineEnd: m,
                     polygonStart: function() {
                         h.point = y, h.lineStart = v, h.lineEnd = b, c = [], u = []
                     },
                     polygonEnd: function() {
-                        h.point = d, h.lineStart = p, h.lineEnd = m, c = TF(c);
-                        var x = aq(u, i);
-                        c.length ? (l || (r.polygonStart(), l = !0), iD(c, oq, x, n, r)) : x && (l || (r.polygonStart(), l = !0), r.lineStart(), n(null, null, 1, r), r.lineEnd()), l && (r.polygonEnd(), l = !1), c = u = null
+                        h.point = d, h.lineStart = p, h.lineEnd = m, c = BO(c);
+                        var x = hG(u, i);
+                        c.length ? (l || (r.polygonStart(), l = !0), gF(c, gG, x, n, r)) : x && (l || (r.polygonStart(), l = !0), r.lineStart(), n(null, null, 1, r), r.lineEnd()), l && (r.polygonEnd(), l = !1), c = u = null
                     },
                     sphere: function() {
                         r.polygonStart(), r.lineStart(), n(null, null, 1, r), r.lineEnd(), r.polygonEnd()
                     }
                 };
 
             function d(x, _) {
                 e(x, _) && r.point(x, _)
             }
 
             function g(x, _) {
-                a.point(x, _)
+                s.point(x, _)
             }
 
             function p() {
-                h.point = g, a.lineStart()
+                h.point = g, s.lineStart()
             }
 
             function m() {
-                h.point = d, a.lineEnd()
+                h.point = d, s.lineEnd()
             }
 
             function y(x, _) {
                 f.push([x, _]), o.point(x, _)
             }
 
             function v() {
                 o.lineStart(), f = []
             }
 
             function b() {
                 y(f[0][0], f[0][1]), o.lineEnd();
                 var x = o.clean(),
-                    _ = s.result(),
+                    _ = a.result(),
                     S, w = _.length,
-                    O, k, C;
+                    E, A, C;
                 if (f.pop(), u.push(f), f = null, !!w) {
                     if (x & 1) {
-                        if (k = _[0], (O = k.length - 1) > 0) {
-                            for (l || (r.polygonStart(), l = !0), r.lineStart(), S = 0; S < O; ++S) r.point((C = k[S])[0], C[1]);
+                        if (A = _[0], (E = A.length - 1) > 0) {
+                            for (l || (r.polygonStart(), l = !0), r.lineStart(), S = 0; S < E; ++S) r.point((C = A[S])[0], C[1]);
                             r.lineEnd()
                         }
                         return
                     }
-                    w > 1 && x & 2 && _.push(_.pop().concat(_.shift())), c.push(_.filter(sq))
+                    w > 1 && x & 2 && _.push(_.pop().concat(_.shift())), c.push(_.filter(dG))
                 }
             }
             return h
         }
     }
 
-    function sq(e) {
+    function dG(e) {
         return e.length > 1
     }
 
-    function oq(e, t) {
-        return ((e = e.x)[0] < 0 ? e[1] - _t - ve : _t - e[1]) - ((t = t.x)[0] < 0 ? t[1] - _t - ve : _t - t[1])
+    function gG(e, t) {
+        return ((e = e.x)[0] < 0 ? e[1] - vt - ve : vt - e[1]) - ((t = t.x)[0] < 0 ? t[1] - vt - ve : vt - t[1])
     }
-    const eA = rD(function() {
+    const gA = pF(function() {
         return !0
-    }, lq, cq, [-De, -_t]);
+    }, pG, yG, [-Oe, -vt]);
 
-    function lq(e) {
+    function pG(e) {
         var t = NaN,
             n = NaN,
             i = NaN,
             r;
         return {
             lineStart: function() {
                 e.lineStart(), r = 1
             },
-            point: function(a, s) {
-                var o = a > 0 ? De : -De,
-                    l = Ne(a - t);
-                Ne(l - De) < ve ? (e.point(t, n = (n + s) / 2 > 0 ? _t : -_t), e.point(i, n), e.lineEnd(), e.lineStart(), e.point(o, n), e.point(a, n), r = 0) : i !== o && l >= De && (Ne(t - i) < ve && (t -= i * ve), Ne(a - o) < ve && (a -= o * ve), n = uq(t, n, a, s), e.point(i, n), e.lineEnd(), e.lineStart(), e.point(o, n), r = 0), e.point(t = a, n = s), i = o
+            point: function(s, a) {
+                var o = s > 0 ? Oe : -Oe,
+                    l = Re(s - t);
+                Re(l - Oe) < ve ? (e.point(t, n = (n + a) / 2 > 0 ? vt : -vt), e.point(i, n), e.lineEnd(), e.lineStart(), e.point(o, n), e.point(s, n), r = 0) : i !== o && l >= Oe && (Re(t - i) < ve && (t -= i * ve), Re(s - o) < ve && (s -= o * ve), n = mG(t, n, s, a), e.point(i, n), e.lineEnd(), e.lineStart(), e.point(o, n), r = 0), e.point(t = s, n = a), i = o
             },
             lineEnd: function() {
                 e.lineEnd(), t = n = NaN
             },
             clean: function() {
                 return 2 - r
             }
         }
     }
 
-    function uq(e, t, n, i) {
-        var r, a, s = ge(e - n);
-        return Ne(s) > ve ? kc((ge(t) * (a = be(i)) * ge(n) - ge(i) * (r = be(t)) * ge(e)) / (r * a * s)) : (t + i) / 2
+    function mG(e, t, n, i) {
+        var r, s, a = pe(e - n);
+        return Re(a) > ve ? pc((pe(t) * (s = xe(i)) * pe(n) - pe(i) * (r = xe(t)) * pe(e)) / (r * s * a)) : (t + i) / 2
     }
 
-    function cq(e, t, n, i) {
+    function yG(e, t, n, i) {
         var r;
-        if (e == null) r = n * _t, i.point(-De, r), i.point(0, r), i.point(De, r), i.point(De, 0), i.point(De, -r), i.point(0, -r), i.point(-De, -r), i.point(-De, 0), i.point(-De, r);
-        else if (Ne(e[0] - t[0]) > ve) {
-            var a = e[0] < t[0] ? De : -De;
-            r = n * a / 2, i.point(-a, r), i.point(0, r), i.point(a, r)
+        if (e == null) r = n * vt, i.point(-Oe, r), i.point(0, r), i.point(Oe, r), i.point(Oe, 0), i.point(Oe, -r), i.point(0, -r), i.point(-Oe, -r), i.point(-Oe, 0), i.point(-Oe, r);
+        else if (Re(e[0] - t[0]) > ve) {
+            var s = e[0] < t[0] ? Oe : -Oe;
+            r = n * s / 2, i.point(-s, r), i.point(0, r), i.point(s, r)
         } else i.point(t[0], t[1])
     }
 
-    function fq(e) {
-        var t = be(e),
+    function vG(e) {
+        var t = xe(e),
             n = 6 * Me,
             i = t > 0,
-            r = Ne(t) > ve;
+            r = Re(t) > ve;
 
-        function a(c, f, h, d) {
-            rq(d, e, n, h, c, f)
+        function s(c, f, h, d) {
+            fG(d, e, n, h, c, f)
         }
 
-        function s(c, f) {
-            return be(c) * be(f) > t
+        function a(c, f) {
+            return xe(c) * xe(f) > t
         }
 
         function o(c) {
             var f, h, d, g, p;
             return {
                 lineStart: function() {
                     g = d = !1, p = 1
                 },
                 point: function(m, y) {
                     var v = [m, y],
-                        b, x = s(m, y),
-                        _ = i ? x ? 0 : u(m, y) : x ? u(m + (m < 0 ? De : -De), y) : 0;
-                    if (!f && (g = d = x) && c.lineStart(), x !== d && (b = l(f, v), (!b || cp(f, b) || cp(v, b)) && (v[2] = 1)), x !== d) p = 0, x ? (c.lineStart(), b = l(v, f), c.point(b[0], b[1])) : (b = l(f, v), c.point(b[0], b[1], 2), c.lineEnd()), f = b;
+                        b, x = a(m, y),
+                        _ = i ? x ? 0 : u(m, y) : x ? u(m + (m < 0 ? Oe : -Oe), y) : 0;
+                    if (!f && (g = d = x) && c.lineStart(), x !== d && (b = l(f, v), (!b || Hg(f, b) || Hg(v, b)) && (v[2] = 1)), x !== d) p = 0, x ? (c.lineStart(), b = l(v, f), c.point(b[0], b[1])) : (b = l(f, v), c.point(b[0], b[1], 2), c.lineEnd()), f = b;
                     else if (r && f && i ^ x) {
                         var S;
                         !(_ & h) && (S = l(v, f, !0)) && (p = 0, i ? (c.lineStart(), c.point(S[0][0], S[0][1]), c.point(S[1][0], S[1][1]), c.lineEnd()) : (c.point(S[1][0], S[1][1]), c.lineEnd(), c.lineStart(), c.point(S[0][0], S[0][1], 3)))
                     }
-                    x && (!f || !cp(f, v)) && c.point(v[0], v[1]), f = v, d = x, h = _
+                    x && (!f || !Hg(f, v)) && c.point(v[0], v[1]), f = v, d = x, h = _
                 },
                 lineEnd: function() {
                     d && c.lineEnd(), f = null
                 },
                 clean: function() {
                     return p | (g && d) << 1
                 }
             }
         }
 
         function l(c, f, h) {
-            var d = fl(c),
-                g = fl(f),
+            var d = Zo(c),
+                g = Zo(f),
                 p = [1, 0, 0],
-                m = Wu(d, g),
-                y = _g(m, m),
+                m = Du(d, g),
+                y = ag(m, m),
                 v = m[0],
                 b = y - v * v;
             if (!b) return !h && c;
             var x = t * y / b,
                 _ = -t * v / b,
-                S = Wu(p, m),
-                w = wg(p, x),
-                O = wg(m, _);
-            Qy(w, O);
-            var k = S,
-                C = _g(w, k),
-                E = _g(k, k),
-                T = C * C - E * (_g(w, w) - 1);
-            if (!(T < 0)) {
-                var A = Bn(T),
-                    F = wg(k, (-C - A) / E);
-                if (Qy(F, w), F = t0(F), !h) return F;
-                var $ = c[0],
-                    D = f[0],
-                    P = c[1],
-                    N = f[1],
+                S = Du(p, m),
+                w = og(p, x),
+                E = og(m, _);
+            My(w, E);
+            var A = S,
+                C = ag(w, A),
+                k = ag(A, A),
+                R = C * C - k * (ag(w, w) - 1);
+            if (!(R < 0)) {
+                var $ = In(R),
+                    T = og(A, (-C - $) / k);
+                if (My(T, w), T = Pp(T), !h) return T;
+                var M = c[0],
+                    F = f[0],
+                    N = c[1],
+                    P = f[1],
                     z;
-                D < $ && (z = $, $ = D, D = z);
-                var I = D - $,
-                    ae = Ne(I - De) < ve,
-                    ye = ae || I < ve;
-                if (!ae && N < P && (z = P, P = N, N = z), ye ? ae ? P + N > 0 ^ F[1] < (Ne(F[0] - $) < ve ? P : N) : P <= F[1] && F[1] <= N : I > De ^ ($ <= F[0] && F[0] <= D)) {
-                    var we = wg(k, (-C + A) / E);
-                    return Qy(we, w), [F, t0(we)]
+                F < M && (z = M, M = F, F = z);
+                var I = F - M,
+                    Q = Re(I - Oe) < ve,
+                    oe = Q || I < ve;
+                if (!Q && P < N && (z = N, N = P, P = z), oe ? Q ? N + P > 0 ^ T[1] < (Re(T[0] - M) < ve ? N : P) : N <= T[1] && T[1] <= P : I > Oe ^ (M <= T[0] && T[0] <= F)) {
+                    var Se = og(A, (-C + $) / k);
+                    return My(Se, w), [T, Pp(Se)]
                 }
             }
         }
 
         function u(c, f) {
-            var h = i ? e : De - e,
+            var h = i ? e : Oe - e,
                 d = 0;
             return c < -h ? d |= 1 : c > h && (d |= 2), f < -h ? d |= 4 : f > h && (d |= 8), d
         }
-        return rD(s, o, a, i ? [0, -e] : [-De, e - De])
+        return pF(a, o, s, i ? [0, -e] : [-Oe, e - Oe])
     }
 
-    function hq(e, t, n, i, r, a) {
-        var s = e[0],
+    function bG(e, t, n, i, r, s) {
+        var a = e[0],
             o = e[1],
             l = t[0],
             u = t[1],
             c = 0,
             f = 1,
-            h = l - s,
+            h = l - a,
             d = u - o,
             g;
-        if (g = n - s, !(!h && g > 0)) {
+        if (g = n - a, !(!h && g > 0)) {
             if (g /= h, h < 0) {
                 if (g < c) return;
                 g < f && (f = g)
             } else if (h > 0) {
                 if (g > f) return;
                 g > c && (c = g)
             }
-            if (g = r - s, !(!h && g < 0)) {
+            if (g = r - a, !(!h && g < 0)) {
                 if (g /= h, h < 0) {
                     if (g > f) return;
                     g > c && (c = g)
                 } else if (h > 0) {
                     if (g < c) return;
                     g < f && (f = g)
                 }
@@ -11290,321 +11290,321 @@
                     if (g /= d, d < 0) {
                         if (g < c) return;
                         g < f && (f = g)
                     } else if (d > 0) {
                         if (g > f) return;
                         g > c && (c = g)
                     }
-                    if (g = a - o, !(!d && g < 0)) {
+                    if (g = s - o, !(!d && g < 0)) {
                         if (g /= d, d < 0) {
                             if (g > f) return;
                             g > c && (c = g)
                         } else if (d > 0) {
                             if (g < c) return;
                             g < f && (f = g)
                         }
-                        return c > 0 && (e[0] = s + c * h, e[1] = o + c * d), f < 1 && (t[0] = s + f * h, t[1] = o + f * d), !0
+                        return c > 0 && (e[0] = a + c * h, e[1] = o + c * d), f < 1 && (t[0] = a + f * h, t[1] = o + f * d), !0
                     }
                 }
             }
         }
     }
-    var Lf = 1e9,
-        Eg = -Lf;
+    var Cf = 1e9,
+        ug = -Cf;
 
-    function aD(e, t, n, i) {
+    function mF(e, t, n, i) {
         function r(u, c) {
             return e <= u && u <= n && t <= c && c <= i
         }
 
-        function a(u, c, f, h) {
+        function s(u, c, f, h) {
             var d = 0,
                 g = 0;
-            if (u == null || (d = s(u, f)) !== (g = s(c, f)) || l(u, c) < 0 ^ f > 0)
+            if (u == null || (d = a(u, f)) !== (g = a(c, f)) || l(u, c) < 0 ^ f > 0)
                 do h.point(d === 0 || d === 3 ? e : n, d > 1 ? i : t); while ((d = (d + f + 4) % 4) !== g);
             else h.point(c[0], c[1])
         }
 
-        function s(u, c) {
-            return Ne(u[0] - e) < ve ? c > 0 ? 0 : 3 : Ne(u[0] - n) < ve ? c > 0 ? 2 : 1 : Ne(u[1] - t) < ve ? c > 0 ? 1 : 0 : c > 0 ? 3 : 2
+        function a(u, c) {
+            return Re(u[0] - e) < ve ? c > 0 ? 0 : 3 : Re(u[0] - n) < ve ? c > 0 ? 2 : 1 : Re(u[1] - t) < ve ? c > 0 ? 1 : 0 : c > 0 ? 3 : 2
         }
 
         function o(u, c) {
             return l(u.x, c.x)
         }
 
         function l(u, c) {
-            var f = s(u, 1),
-                h = s(c, 1);
+            var f = a(u, 1),
+                h = a(c, 1);
             return f !== h ? f - h : f === 0 ? c[1] - u[1] : f === 1 ? u[0] - c[0] : f === 2 ? u[1] - c[1] : c[0] - u[0]
         }
         return function(u) {
             var c = u,
-                f = nD(),
+                f = dF(),
                 h, d, g, p, m, y, v, b, x, _, S, w = {
-                    point: O,
-                    lineStart: T,
-                    lineEnd: A,
+                    point: E,
+                    lineStart: R,
+                    lineEnd: $,
                     polygonStart: C,
-                    polygonEnd: E
+                    polygonEnd: k
                 };
 
-            function O($, D) {
-                r($, D) && c.point($, D)
+            function E(M, F) {
+                r(M, F) && c.point(M, F)
             }
 
-            function k() {
-                for (var $ = 0, D = 0, P = d.length; D < P; ++D)
-                    for (var N = d[D], z = 1, I = N.length, ae = N[0], ye, we, $e = ae[0], Oe = ae[1]; z < I; ++z) ye = $e, we = Oe, ae = N[z], $e = ae[0], Oe = ae[1], we <= i ? Oe > i && ($e - ye) * (i - we) > (Oe - we) * (e - ye) && ++$ : Oe <= i && ($e - ye) * (i - we) < (Oe - we) * (e - ye) && --$;
-                return $
+            function A() {
+                for (var M = 0, F = 0, N = d.length; F < N; ++F)
+                    for (var P = d[F], z = 1, I = P.length, Q = P[0], oe, Se, ye = Q[0], Pe = Q[1]; z < I; ++z) oe = ye, Se = Pe, Q = P[z], ye = Q[0], Pe = Q[1], Se <= i ? Pe > i && (ye - oe) * (i - Se) > (Pe - Se) * (e - oe) && ++M : Pe <= i && (ye - oe) * (i - Se) < (Pe - Se) * (e - oe) && --M;
+                return M
             }
 
             function C() {
                 c = f, h = [], d = [], S = !0
             }
 
-            function E() {
-                var $ = k(),
-                    D = S && $,
-                    P = (h = TF(h)).length;
-                (D || P) && (u.polygonStart(), D && (u.lineStart(), a(null, null, 1, u), u.lineEnd()), P && iD(h, o, $, a, u), u.polygonEnd()), c = u, h = d = g = null
+            function k() {
+                var M = A(),
+                    F = S && M,
+                    N = (h = BO(h)).length;
+                (F || N) && (u.polygonStart(), F && (u.lineStart(), s(null, null, 1, u), u.lineEnd()), N && gF(h, o, M, s, u), u.polygonEnd()), c = u, h = d = g = null
             }
 
-            function T() {
-                w.point = F, d && d.push(g = []), _ = !0, x = !1, v = b = NaN
+            function R() {
+                w.point = T, d && d.push(g = []), _ = !0, x = !1, v = b = NaN
             }
 
-            function A() {
-                h && (F(p, m), y && x && f.rejoin(), h.push(f.result())), w.point = O, x && c.lineEnd()
+            function $() {
+                h && (T(p, m), y && x && f.rejoin(), h.push(f.result())), w.point = E, x && c.lineEnd()
             }
 
-            function F($, D) {
-                var P = r($, D);
-                if (d && g.push([$, D]), _) p = $, m = D, y = P, _ = !1, P && (c.lineStart(), c.point($, D));
-                else if (P && x) c.point($, D);
+            function T(M, F) {
+                var N = r(M, F);
+                if (d && g.push([M, F]), _) p = M, m = F, y = N, _ = !1, N && (c.lineStart(), c.point(M, F));
+                else if (N && x) c.point(M, F);
                 else {
-                    var N = [v = Math.max(Eg, Math.min(Lf, v)), b = Math.max(Eg, Math.min(Lf, b))],
-                        z = [$ = Math.max(Eg, Math.min(Lf, $)), D = Math.max(Eg, Math.min(Lf, D))];
-                    hq(N, z, e, t, n, i) ? (x || (c.lineStart(), c.point(N[0], N[1])), c.point(z[0], z[1]), P || c.lineEnd(), S = !1) : P && (c.lineStart(), c.point($, D), S = !1)
+                    var P = [v = Math.max(ug, Math.min(Cf, v)), b = Math.max(ug, Math.min(Cf, b))],
+                        z = [M = Math.max(ug, Math.min(Cf, M)), F = Math.max(ug, Math.min(Cf, F))];
+                    bG(P, z, e, t, n, i) ? (x || (c.lineStart(), c.point(P[0], P[1])), c.point(z[0], z[1]), N || c.lineEnd(), S = !1) : N && (c.lineStart(), c.point(M, F), S = !1)
                 }
-                v = $, b = D, x = P
+                v = M, b = F, x = N
             }
             return w
         }
     }
 
-    function tA(e, t, n) {
-        var i = mi(e, t - ve, n).concat(t);
+    function pA(e, t, n) {
+        var i = gi(e, t - ve, n).concat(t);
         return function(r) {
-            return i.map(function(a) {
-                return [r, a]
+            return i.map(function(s) {
+                return [r, s]
             })
         }
     }
 
-    function nA(e, t, n) {
-        var i = mi(e, t - ve, n).concat(t);
+    function mA(e, t, n) {
+        var i = gi(e, t - ve, n).concat(t);
         return function(r) {
-            return i.map(function(a) {
-                return [a, r]
+            return i.map(function(s) {
+                return [s, r]
             })
         }
     }
 
-    function dq() {
-        var e, t, n, i, r, a, s, o, l = 10,
+    function xG() {
+        var e, t, n, i, r, s, a, o, l = 10,
             u = l,
             c = 90,
             f = 360,
             h, d, g, p, m = 2.5;
 
         function y() {
             return {
                 type: "MultiLineString",
                 coordinates: v()
             }
         }
 
         function v() {
-            return mi(xg(i / c) * c, n, c).map(g).concat(mi(xg(o / f) * f, s, f).map(p)).concat(mi(xg(t / l) * l, e, l).filter(function(b) {
-                return Ne(b % c) > ve
-            }).map(h)).concat(mi(xg(a / u) * u, r, u).filter(function(b) {
-                return Ne(b % f) > ve
+            return gi(sg(i / c) * c, n, c).map(g).concat(gi(sg(o / f) * f, a, f).map(p)).concat(gi(sg(t / l) * l, e, l).filter(function(b) {
+                return Re(b % c) > ve
+            }).map(h)).concat(gi(sg(s / u) * u, r, u).filter(function(b) {
+                return Re(b % f) > ve
             }).map(d))
         }
         return y.lines = function() {
             return v().map(function(b) {
                 return {
                     type: "LineString",
                     coordinates: b
                 }
             })
         }, y.outline = function() {
             return {
                 type: "Polygon",
-                coordinates: [g(i).concat(p(s).slice(1), g(n).reverse().slice(1), p(o).reverse().slice(1))]
+                coordinates: [g(i).concat(p(a).slice(1), g(n).reverse().slice(1), p(o).reverse().slice(1))]
             }
         }, y.extent = function(b) {
             return arguments.length ? y.extentMajor(b).extentMinor(b) : y.extentMinor()
         }, y.extentMajor = function(b) {
-            return arguments.length ? (i = +b[0][0], n = +b[1][0], o = +b[0][1], s = +b[1][1], i > n && (b = i, i = n, n = b), o > s && (b = o, o = s, s = b), y.precision(m)) : [
+            return arguments.length ? (i = +b[0][0], n = +b[1][0], o = +b[0][1], a = +b[1][1], i > n && (b = i, i = n, n = b), o > a && (b = o, o = a, a = b), y.precision(m)) : [
                 [i, o],
-                [n, s]
+                [n, a]
             ]
         }, y.extentMinor = function(b) {
-            return arguments.length ? (t = +b[0][0], e = +b[1][0], a = +b[0][1], r = +b[1][1], t > e && (b = t, t = e, e = b), a > r && (b = a, a = r, r = b), y.precision(m)) : [
-                [t, a],
+            return arguments.length ? (t = +b[0][0], e = +b[1][0], s = +b[0][1], r = +b[1][1], t > e && (b = t, t = e, e = b), s > r && (b = s, s = r, r = b), y.precision(m)) : [
+                [t, s],
                 [e, r]
             ]
         }, y.step = function(b) {
             return arguments.length ? y.stepMajor(b).stepMinor(b) : y.stepMinor()
         }, y.stepMajor = function(b) {
             return arguments.length ? (c = +b[0], f = +b[1], y) : [c, f]
         }, y.stepMinor = function(b) {
             return arguments.length ? (l = +b[0], u = +b[1], y) : [l, u]
         }, y.precision = function(b) {
-            return arguments.length ? (m = +b, h = tA(a, r, 90), d = nA(t, e, m), g = tA(o, s, 90), p = nA(i, n, m), y) : m
+            return arguments.length ? (m = +b, h = pA(s, r, 90), d = mA(t, e, m), g = pA(o, a, 90), p = mA(i, n, m), y) : m
         }, y.extentMajor([
             [-180, -90 + ve],
             [180, 90 - ve]
         ]).extentMinor([
             [-180, -80 - ve],
             [180, 80 + ve]
         ])
     }
-    const $h = e => e;
-    var ev = new Nn,
-        Zb = new Nn,
-        sD, oD, e2, t2, _s = {
-            point: Zt,
-            lineStart: Zt,
-            lineEnd: Zt,
+    const vh = e => e;
+    var Fy = new Rn,
+        Ab = new Rn,
+        yF, vF, $b, Tb, fa = {
+            point: Vt,
+            lineStart: Vt,
+            lineEnd: Vt,
             polygonStart: function() {
-                _s.lineStart = gq, _s.lineEnd = mq
+                fa.lineStart = _G, fa.lineEnd = SG
             },
             polygonEnd: function() {
-                _s.lineStart = _s.lineEnd = _s.point = Zt, ev.add(Ne(Zb)), Zb = new Nn
+                fa.lineStart = fa.lineEnd = fa.point = Vt, Fy.add(Re(Ab)), Ab = new Rn
             },
             result: function() {
-                var e = ev / 2;
-                return ev = new Nn, e
+                var e = Fy / 2;
+                return Fy = new Rn, e
             }
         };
 
-    function gq() {
-        _s.point = pq
+    function _G() {
+        fa.point = wG
     }
 
-    function pq(e, t) {
-        _s.point = lD, sD = e2 = e, oD = t2 = t
+    function wG(e, t) {
+        fa.point = bF, yF = $b = e, vF = Tb = t
     }
 
-    function lD(e, t) {
-        Zb.add(t2 * e - e2 * t), e2 = e, t2 = t
+    function bF(e, t) {
+        Ab.add(Tb * e - $b * t), $b = e, Tb = t
     }
 
-    function mq() {
-        lD(sD, oD)
+    function SG() {
+        bF(yF, vF)
     }
-    const iA = _s;
-    var Hu = 1 / 0,
-        c0 = Hu,
-        Mh = -Hu,
-        f0 = Mh,
-        yq = {
-            point: vq,
-            lineStart: Zt,
-            lineEnd: Zt,
-            polygonStart: Zt,
-            polygonEnd: Zt,
+    const yA = fa;
+    var Nu = 1 / 0,
+        qp = Nu,
+        bh = -Nu,
+        Hp = bh,
+        EG = {
+            point: CG,
+            lineStart: Vt,
+            lineEnd: Vt,
+            polygonStart: Vt,
+            polygonEnd: Vt,
             result: function() {
                 var e = [
-                    [Hu, c0],
-                    [Mh, f0]
+                    [Nu, qp],
+                    [bh, Hp]
                 ];
-                return Mh = f0 = -(c0 = Hu = 1 / 0), e
+                return bh = Hp = -(qp = Nu = 1 / 0), e
             }
         };
 
-    function vq(e, t) {
-        e < Hu && (Hu = e), e > Mh && (Mh = e), t < c0 && (c0 = t), t > f0 && (f0 = t)
+    function CG(e, t) {
+        e < Nu && (Nu = e), e > bh && (bh = e), t < qp && (qp = t), t > Hp && (Hp = t)
     }
-    const h0 = yq;
-    var n2 = 0,
-        i2 = 0,
-        If = 0,
-        d0 = 0,
-        g0 = 0,
-        _u = 0,
-        r2 = 0,
-        a2 = 0,
-        jf = 0,
-        uD, cD, Lr, Ir, ar = {
-            point: hl,
-            lineStart: rA,
-            lineEnd: aA,
+    const Yp = EG;
+    var Mb = 0,
+        Ob = 0,
+        kf = 0,
+        Xp = 0,
+        Vp = 0,
+        cu = 0,
+        Fb = 0,
+        Rb = 0,
+        Af = 0,
+        xF, _F, Fr, Rr, Qi = {
+            point: el,
+            lineStart: vA,
+            lineEnd: bA,
             polygonStart: function() {
-                ar.lineStart = _q, ar.lineEnd = wq
+                Qi.lineStart = $G, Qi.lineEnd = TG
             },
             polygonEnd: function() {
-                ar.point = hl, ar.lineStart = rA, ar.lineEnd = aA
+                Qi.point = el, Qi.lineStart = vA, Qi.lineEnd = bA
             },
             result: function() {
-                var e = jf ? [r2 / jf, a2 / jf] : _u ? [d0 / _u, g0 / _u] : If ? [n2 / If, i2 / If] : [NaN, NaN];
-                return n2 = i2 = If = d0 = g0 = _u = r2 = a2 = jf = 0, e
+                var e = Af ? [Fb / Af, Rb / Af] : cu ? [Xp / cu, Vp / cu] : kf ? [Mb / kf, Ob / kf] : [NaN, NaN];
+                return Mb = Ob = kf = Xp = Vp = cu = Fb = Rb = Af = 0, e
             }
         };
 
-    function hl(e, t) {
-        n2 += e, i2 += t, ++If
+    function el(e, t) {
+        Mb += e, Ob += t, ++kf
     }
 
-    function rA() {
-        ar.point = bq
+    function vA() {
+        Qi.point = kG
     }
 
-    function bq(e, t) {
-        ar.point = xq, hl(Lr = e, Ir = t)
+    function kG(e, t) {
+        Qi.point = AG, el(Fr = e, Rr = t)
     }
 
-    function xq(e, t) {
-        var n = e - Lr,
-            i = t - Ir,
-            r = Bn(n * n + i * i);
-        d0 += r * (Lr + e) / 2, g0 += r * (Ir + t) / 2, _u += r, hl(Lr = e, Ir = t)
+    function AG(e, t) {
+        var n = e - Fr,
+            i = t - Rr,
+            r = In(n * n + i * i);
+        Xp += r * (Fr + e) / 2, Vp += r * (Rr + t) / 2, cu += r, el(Fr = e, Rr = t)
     }
 
-    function aA() {
-        ar.point = hl
+    function bA() {
+        Qi.point = el
     }
 
-    function _q() {
-        ar.point = Sq
+    function $G() {
+        Qi.point = MG
     }
 
-    function wq() {
-        fD(uD, cD)
+    function TG() {
+        wF(xF, _F)
     }
 
-    function Sq(e, t) {
-        ar.point = fD, hl(uD = Lr = e, cD = Ir = t)
+    function MG(e, t) {
+        Qi.point = wF, el(xF = Fr = e, _F = Rr = t)
     }
 
-    function fD(e, t) {
-        var n = e - Lr,
-            i = t - Ir,
-            r = Bn(n * n + i * i);
-        d0 += r * (Lr + e) / 2, g0 += r * (Ir + t) / 2, _u += r, r = Ir * e - Lr * t, r2 += r * (Lr + e), a2 += r * (Ir + t), jf += r * 3, hl(Lr = e, Ir = t)
+    function wF(e, t) {
+        var n = e - Fr,
+            i = t - Rr,
+            r = In(n * n + i * i);
+        Xp += r * (Fr + e) / 2, Vp += r * (Rr + t) / 2, cu += r, r = Rr * e - Fr * t, Fb += r * (Fr + e), Rb += r * (Rr + t), Af += r * 3, el(Fr = e, Rr = t)
     }
-    const sA = ar;
+    const xA = Qi;
 
-    function hD(e) {
+    function SF(e) {
         this._context = e
     }
-    hD.prototype = {
+    SF.prototype = {
         _radius: 4.5,
         pointRadius: function(e) {
             return this._radius = e, this
         },
         polygonStart: function() {
             this._line = 0
         },
@@ -11624,54 +11624,54 @@
                     break
                 }
                 case 1: {
                     this._context.lineTo(e, t);
                     break
                 }
                 default: {
-                    this._context.moveTo(e + this._radius, t), this._context.arc(e, t, this._radius, 0, zn);
+                    this._context.moveTo(e + this._radius, t), this._context.arc(e, t, this._radius, 0, Ln);
                     break
                 }
             }
         },
-        result: Zt
+        result: Vt
     };
-    var s2 = new Nn,
-        tv, dD, gD, zf, Bf, p0 = {
-            point: Zt,
+    var Db = new Rn,
+        Ry, EF, CF, $f, Tf, Kp = {
+            point: Vt,
             lineStart: function() {
-                p0.point = Eq
+                Kp.point = OG
             },
             lineEnd: function() {
-                tv && pD(dD, gD), p0.point = Zt
+                Ry && kF(EF, CF), Kp.point = Vt
             },
             polygonStart: function() {
-                tv = !0
+                Ry = !0
             },
             polygonEnd: function() {
-                tv = null
+                Ry = null
             },
             result: function() {
-                var e = +s2;
-                return s2 = new Nn, e
+                var e = +Db;
+                return Db = new Rn, e
             }
         };
 
-    function Eq(e, t) {
-        p0.point = pD, dD = zf = e, gD = Bf = t
+    function OG(e, t) {
+        Kp.point = kF, EF = $f = e, CF = Tf = t
     }
 
-    function pD(e, t) {
-        zf -= e, Bf -= t, s2.add(Bn(zf * zf + Bf * Bf)), zf = e, Bf = t
+    function kF(e, t) {
+        $f -= e, Tf -= t, Db.add(In($f * $f + Tf * Tf)), $f = e, Tf = t
     }
-    const oA = p0;
-    let lA, m0, uA, cA;
-    class fA {
+    const _A = Kp;
+    let wA, Jp, SA, EA;
+    class CA {
         constructor(t) {
-            this._append = t == null ? mD : Oq(t), this._radius = 4.5, this._ = ""
+            this._append = t == null ? AF : FG(t), this._radius = 4.5, this._ = ""
         }
         pointRadius(t) {
             return this._radius = +t, this
         }
         polygonStart() {
             this._line = 0
         }
@@ -11691,96 +11691,96 @@
                     break
                 }
                 case 1: {
                     this._append`L${t},${n}`;
                     break
                 }
                 default: {
-                    if (this._append`M${t},${n}`, this._radius !== uA || this._append !== m0) {
+                    if (this._append`M${t},${n}`, this._radius !== SA || this._append !== Jp) {
                         const i = this._radius,
                             r = this._;
-                        this._ = "", this._append`m0,${i}a${i},${i} 0 1,1 0,${-2*i}a${i},${i} 0 1,1 0,${2*i}z`, uA = i, m0 = this._append, cA = this._, this._ = r
+                        this._ = "", this._append`m0,${i}a${i},${i} 0 1,1 0,${-2*i}a${i},${i} 0 1,1 0,${2*i}z`, SA = i, Jp = this._append, EA = this._, this._ = r
                     }
-                    this._ += cA;
+                    this._ += EA;
                     break
                 }
             }
         }
         result() {
             const t = this._;
             return this._ = "", t.length ? t : null
         }
     }
 
-    function mD(e) {
+    function AF(e) {
         let t = 1;
         this._ += e[0];
         for (const n = e.length; t < n; ++t) this._ += arguments[t] + e[t]
     }
 
-    function Oq(e) {
+    function FG(e) {
         const t = Math.floor(e);
         if (!(t >= 0)) throw new RangeError(`invalid digits: ${e}`);
-        if (t > 15) return mD;
-        if (t !== lA) {
+        if (t > 15) return AF;
+        if (t !== wA) {
             const n = 10 ** t;
-            lA = t, m0 = function(r) {
-                let a = 1;
+            wA = t, Jp = function(r) {
+                let s = 1;
                 this._ += r[0];
-                for (const s = r.length; a < s; ++a) this._ += Math.round(arguments[a] * n) / n + r[a]
+                for (const a = r.length; s < a; ++s) this._ += Math.round(arguments[s] * n) / n + r[s]
             }
         }
-        return m0
+        return Jp
     }
 
-    function yD(e, t) {
+    function $F(e, t) {
         let n = 3,
             i = 4.5,
-            r, a;
+            r, s;
 
-        function s(o) {
-            return o && (typeof i == "function" && a.pointRadius(+i.apply(this, arguments)), Fa(o, r(a))), a.result()
+        function a(o) {
+            return o && (typeof i == "function" && s.pointRadius(+i.apply(this, arguments)), ws(o, r(s))), s.result()
         }
-        return s.area = function(o) {
-            return Fa(o, r(iA)), iA.result()
-        }, s.measure = function(o) {
-            return Fa(o, r(oA)), oA.result()
-        }, s.bounds = function(o) {
-            return Fa(o, r(h0)), h0.result()
-        }, s.centroid = function(o) {
-            return Fa(o, r(sA)), sA.result()
-        }, s.projection = function(o) {
-            return arguments.length ? (r = o == null ? (e = null, $h) : (e = o).stream, s) : e
-        }, s.context = function(o) {
-            return arguments.length ? (a = o == null ? (t = null, new fA(n)) : new hD(t = o), typeof i != "function" && a.pointRadius(i), s) : t
-        }, s.pointRadius = function(o) {
-            return arguments.length ? (i = typeof o == "function" ? o : (a.pointRadius(+o), +o), s) : i
-        }, s.digits = function(o) {
+        return a.area = function(o) {
+            return ws(o, r(yA)), yA.result()
+        }, a.measure = function(o) {
+            return ws(o, r(_A)), _A.result()
+        }, a.bounds = function(o) {
+            return ws(o, r(Yp)), Yp.result()
+        }, a.centroid = function(o) {
+            return ws(o, r(xA)), xA.result()
+        }, a.projection = function(o) {
+            return arguments.length ? (r = o == null ? (e = null, vh) : (e = o).stream, a) : e
+        }, a.context = function(o) {
+            return arguments.length ? (s = o == null ? (t = null, new CA(n)) : new SF(t = o), typeof i != "function" && s.pointRadius(i), a) : t
+        }, a.pointRadius = function(o) {
+            return arguments.length ? (i = typeof o == "function" ? o : (s.pointRadius(+o), +o), a) : i
+        }, a.digits = function(o) {
             if (!arguments.length) return n;
             if (o == null) n = null;
             else {
                 const l = Math.floor(o);
                 if (!(l >= 0)) throw new RangeError(`invalid digits: ${o}`);
                 n = l
             }
-            return t === null && (a = new fA(n)), s
-        }, s.projection(e).digits(n).context(t)
+            return t === null && (s = new CA(n)), a
+        }, a.projection(e).digits(n).context(t)
     }
 
-    function Tm(e) {
+    function um(e) {
         return function(t) {
-            var n = new o2;
+            var n = new Nb;
             for (var i in e) n[i] = e[i];
             return n.stream = t, n
         }
     }
 
-    function o2() {}
-    o2.prototype = {
-        constructor: o2,
+    function Nb() {}
+    Nb.prototype = {
+        constructor: Nb,
         point: function(e, t) {
             this.stream.point(e, t)
         },
         sphere: function() {
             this.stream.sphere()
         },
         lineStart: function() {
@@ -11793,312 +11793,312 @@
             this.stream.polygonStart()
         },
         polygonEnd: function() {
             this.stream.polygonEnd()
         }
     };
 
-    function m_(e, t, n) {
+    function Nx(e, t, n) {
         var i = e.clipExtent && e.clipExtent();
-        return e.scale(150).translate([0, 0]), i != null && e.clipExtent(null), Fa(n, e.stream(h0)), t(h0.result()), i != null && e.clipExtent(i), e
+        return e.scale(150).translate([0, 0]), i != null && e.clipExtent(null), ws(n, e.stream(Yp)), t(Yp.result()), i != null && e.clipExtent(i), e
     }
 
-    function $m(e, t, n) {
-        return m_(e, function(i) {
+    function cm(e, t, n) {
+        return Nx(e, function(i) {
             var r = t[1][0] - t[0][0],
-                a = t[1][1] - t[0][1],
-                s = Math.min(r / (i[1][0] - i[0][0]), a / (i[1][1] - i[0][1])),
-                o = +t[0][0] + (r - s * (i[1][0] + i[0][0])) / 2,
-                l = +t[0][1] + (a - s * (i[1][1] + i[0][1])) / 2;
-            e.scale(150 * s).translate([o, l])
+                s = t[1][1] - t[0][1],
+                a = Math.min(r / (i[1][0] - i[0][0]), s / (i[1][1] - i[0][1])),
+                o = +t[0][0] + (r - a * (i[1][0] + i[0][0])) / 2,
+                l = +t[0][1] + (s - a * (i[1][1] + i[0][1])) / 2;
+            e.scale(150 * a).translate([o, l])
         }, n)
     }
 
-    function y_(e, t, n) {
-        return $m(e, [
+    function Px(e, t, n) {
+        return cm(e, [
             [0, 0], t
         ], n)
     }
 
-    function v_(e, t, n) {
-        return m_(e, function(i) {
+    function Lx(e, t, n) {
+        return Nx(e, function(i) {
             var r = +t,
-                a = r / (i[1][0] - i[0][0]),
-                s = (r - a * (i[1][0] + i[0][0])) / 2,
-                o = -a * i[0][1];
-            e.scale(150 * a).translate([s, o])
+                s = r / (i[1][0] - i[0][0]),
+                a = (r - s * (i[1][0] + i[0][0])) / 2,
+                o = -s * i[0][1];
+            e.scale(150 * s).translate([a, o])
         }, n)
     }
 
-    function b_(e, t, n) {
-        return m_(e, function(i) {
+    function Ix(e, t, n) {
+        return Nx(e, function(i) {
             var r = +t,
-                a = r / (i[1][1] - i[0][1]),
-                s = -a * i[0][0],
-                o = (r - a * (i[1][1] + i[0][1])) / 2;
-            e.scale(150 * a).translate([s, o])
+                s = r / (i[1][1] - i[0][1]),
+                a = -s * i[0][0],
+                o = (r - s * (i[1][1] + i[0][1])) / 2;
+            e.scale(150 * s).translate([a, o])
         }, n)
     }
-    var hA = 16,
-        Cq = be(30 * Me);
+    var kA = 16,
+        RG = xe(30 * Me);
 
-    function dA(e, t) {
-        return +t ? Aq(e, t) : kq(e)
+    function AA(e, t) {
+        return +t ? NG(e, t) : DG(e)
     }
 
-    function kq(e) {
-        return Tm({
+    function DG(e) {
+        return um({
             point: function(t, n) {
                 t = e(t, n), this.stream.point(t[0], t[1])
             }
         })
     }
 
-    function Aq(e, t) {
-        function n(i, r, a, s, o, l, u, c, f, h, d, g, p, m) {
+    function NG(e, t) {
+        function n(i, r, s, a, o, l, u, c, f, h, d, g, p, m) {
             var y = u - i,
                 v = c - r,
                 b = y * y + v * v;
             if (b > 4 * t && p--) {
-                var x = s + h,
+                var x = a + h,
                     _ = o + d,
                     S = l + g,
-                    w = Bn(x * x + _ * _ + S * S),
-                    O = ii(S /= w),
-                    k = Ne(Ne(S) - 1) < ve || Ne(a - f) < ve ? (a + f) / 2 : Li(_, x),
-                    C = e(k, O),
-                    E = C[0],
-                    T = C[1],
-                    A = E - i,
-                    F = T - r,
-                    $ = v * A - y * F;
-                ($ * $ / b > t || Ne((y * A + v * F) / b - .5) > .3 || s * h + o * d + l * g < Cq) && (n(i, r, a, s, o, l, E, T, k, x /= w, _ /= w, S, p, m), m.point(E, T), n(E, T, k, x, _, S, u, c, f, h, d, g, p, m))
+                    w = In(x * x + _ * _ + S * S),
+                    E = ti(S /= w),
+                    A = Re(Re(S) - 1) < ve || Re(s - f) < ve ? (s + f) / 2 : Fi(_, x),
+                    C = e(A, E),
+                    k = C[0],
+                    R = C[1],
+                    $ = k - i,
+                    T = R - r,
+                    M = v * $ - y * T;
+                (M * M / b > t || Re((y * $ + v * T) / b - .5) > .3 || a * h + o * d + l * g < RG) && (n(i, r, s, a, o, l, k, R, A, x /= w, _ /= w, S, p, m), m.point(k, R), n(k, R, A, x, _, S, u, c, f, h, d, g, p, m))
             }
         }
         return function(i) {
-            var r, a, s, o, l, u, c, f, h, d, g, p, m = {
+            var r, s, a, o, l, u, c, f, h, d, g, p, m = {
                 point: y,
                 lineStart: v,
                 lineEnd: x,
                 polygonStart: function() {
                     i.polygonStart(), m.lineStart = _
                 },
                 polygonEnd: function() {
                     i.polygonEnd(), m.lineStart = v
                 }
             };
 
-            function y(O, k) {
-                O = e(O, k), i.point(O[0], O[1])
+            function y(E, A) {
+                E = e(E, A), i.point(E[0], E[1])
             }
 
             function v() {
                 f = NaN, m.point = b, i.lineStart()
             }
 
-            function b(O, k) {
-                var C = fl([O, k]),
-                    E = e(O, k);
-                n(f, h, c, d, g, p, f = E[0], h = E[1], c = O, d = C[0], g = C[1], p = C[2], hA, i), i.point(f, h)
+            function b(E, A) {
+                var C = Zo([E, A]),
+                    k = e(E, A);
+                n(f, h, c, d, g, p, f = k[0], h = k[1], c = E, d = C[0], g = C[1], p = C[2], kA, i), i.point(f, h)
             }
 
             function x() {
                 m.point = y, i.lineEnd()
             }
 
             function _() {
                 v(), m.point = S, m.lineEnd = w
             }
 
-            function S(O, k) {
-                b(r = O, k), a = f, s = h, o = d, l = g, u = p, m.point = b
+            function S(E, A) {
+                b(r = E, A), s = f, a = h, o = d, l = g, u = p, m.point = b
             }
 
             function w() {
-                n(f, h, c, d, g, p, a, s, r, o, l, u, hA, i), m.lineEnd = x, x()
+                n(f, h, c, d, g, p, s, a, r, o, l, u, kA, i), m.lineEnd = x, x()
             }
             return m
         }
     }
-    var Tq = Tm({
+    var PG = um({
         point: function(e, t) {
             this.stream.point(e * Me, t * Me)
         }
     });
 
-    function $q(e) {
-        return Tm({
+    function LG(e) {
+        return um({
             point: function(t, n) {
                 var i = e(t, n);
                 return this.stream.point(i[0], i[1])
             }
         })
     }
 
-    function Mq(e, t, n, i, r) {
-        function a(s, o) {
-            return s *= i, o *= r, [t + e * s, n - e * o]
+    function IG(e, t, n, i, r) {
+        function s(a, o) {
+            return a *= i, o *= r, [t + e * a, n - e * o]
         }
-        return a.invert = function(s, o) {
-            return [(s - t) / e * i, (n - o) / e * r]
-        }, a
+        return s.invert = function(a, o) {
+            return [(a - t) / e * i, (n - o) / e * r]
+        }, s
     }
 
-    function gA(e, t, n, i, r, a) {
-        if (!a) return Mq(e, t, n, i, r);
-        var s = be(a),
-            o = ge(a),
-            l = s * e,
+    function $A(e, t, n, i, r, s) {
+        if (!s) return IG(e, t, n, i, r);
+        var a = xe(s),
+            o = pe(s),
+            l = a * e,
             u = o * e,
-            c = s / e,
+            c = a / e,
             f = o / e,
-            h = (o * n - s * t) / e,
-            d = (o * t + s * n) / e;
+            h = (o * n - a * t) / e,
+            d = (o * t + a * n) / e;
 
         function g(p, m) {
             return p *= i, m *= r, [l * p - u * m + t, n - u * p - l * m]
         }
         return g.invert = function(p, m) {
             return [i * (c * p - f * m + h), r * (d - f * p - c * m)]
         }, g
     }
 
-    function la(e) {
-        return vD(function() {
+    function es(e) {
+        return TF(function() {
             return e
         })()
     }
 
-    function vD(e) {
+    function TF(e) {
         var t, n = 150,
             i = 480,
             r = 250,
-            a = 0,
             s = 0,
+            a = 0,
             o = 0,
             l = 0,
             u = 0,
             c, f = 0,
             h = 1,
             d = 1,
             g = null,
-            p = eA,
+            p = gA,
             m = null,
-            y, v, b, x = $h,
+            y, v, b, x = vh,
             _ = .5,
-            S, w, O, k, C;
+            S, w, E, A, C;
 
-        function E($) {
-            return O($[0] * Me, $[1] * Me)
+        function k(M) {
+            return E(M[0] * Me, M[1] * Me)
         }
 
-        function T($) {
-            return $ = O.invert($[0], $[1]), $ && [$[0] * Ct, $[1] * Ct]
+        function R(M) {
+            return M = E.invert(M[0], M[1]), M && [M[0] * St, M[1] * St]
         }
-        E.stream = function($) {
-            return k && C === $ ? k : k = Tq($q(c)(p(S(x(C = $)))))
-        }, E.preclip = function($) {
-            return arguments.length ? (p = $, g = void 0, F()) : p
-        }, E.postclip = function($) {
-            return arguments.length ? (x = $, m = y = v = b = null, F()) : x
-        }, E.clipAngle = function($) {
-            return arguments.length ? (p = +$ ? fq(g = $ * Me) : (g = null, eA), F()) : g * Ct
-        }, E.clipExtent = function($) {
-            return arguments.length ? (x = $ == null ? (m = y = v = b = null, $h) : aD(m = +$[0][0], y = +$[0][1], v = +$[1][0], b = +$[1][1]), F()) : m == null ? null : [
+        k.stream = function(M) {
+            return A && C === M ? A : A = PG(LG(c)(p(S(x(C = M)))))
+        }, k.preclip = function(M) {
+            return arguments.length ? (p = M, g = void 0, T()) : p
+        }, k.postclip = function(M) {
+            return arguments.length ? (x = M, m = y = v = b = null, T()) : x
+        }, k.clipAngle = function(M) {
+            return arguments.length ? (p = +M ? vG(g = M * Me) : (g = null, gA), T()) : g * St
+        }, k.clipExtent = function(M) {
+            return arguments.length ? (x = M == null ? (m = y = v = b = null, vh) : mF(m = +M[0][0], y = +M[0][1], v = +M[1][0], b = +M[1][1]), T()) : m == null ? null : [
                 [m, y],
                 [v, b]
             ]
-        }, E.scale = function($) {
-            return arguments.length ? (n = +$, A()) : n
-        }, E.translate = function($) {
-            return arguments.length ? (i = +$[0], r = +$[1], A()) : [i, r]
-        }, E.center = function($) {
-            return arguments.length ? (a = $[0] % 360 * Me, s = $[1] % 360 * Me, A()) : [a * Ct, s * Ct]
-        }, E.rotate = function($) {
-            return arguments.length ? (o = $[0] % 360 * Me, l = $[1] % 360 * Me, u = $.length > 2 ? $[2] % 360 * Me : 0, A()) : [o * Ct, l * Ct, u * Ct]
-        }, E.angle = function($) {
-            return arguments.length ? (f = $ % 360 * Me, A()) : f * Ct
-        }, E.reflectX = function($) {
-            return arguments.length ? (h = $ ? -1 : 1, A()) : h < 0
-        }, E.reflectY = function($) {
-            return arguments.length ? (d = $ ? -1 : 1, A()) : d < 0
-        }, E.precision = function($) {
-            return arguments.length ? (S = dA(w, _ = $ * $), F()) : Bn(_)
-        }, E.fitExtent = function($, D) {
-            return $m(E, $, D)
-        }, E.fitSize = function($, D) {
-            return y_(E, $, D)
-        }, E.fitWidth = function($, D) {
-            return v_(E, $, D)
-        }, E.fitHeight = function($, D) {
-            return b_(E, $, D)
-        };
-
-        function A() {
-            var $ = gA(n, 0, 0, h, d, f).apply(null, t(a, s)),
-                D = gA(n, i - $[0], r - $[1], h, d, f);
-            return c = tD(o, l, u), w = Jb(t, D), O = Jb(c, w), S = dA(w, _), F()
+        }, k.scale = function(M) {
+            return arguments.length ? (n = +M, $()) : n
+        }, k.translate = function(M) {
+            return arguments.length ? (i = +M[0], r = +M[1], $()) : [i, r]
+        }, k.center = function(M) {
+            return arguments.length ? (s = M[0] % 360 * Me, a = M[1] % 360 * Me, $()) : [s * St, a * St]
+        }, k.rotate = function(M) {
+            return arguments.length ? (o = M[0] % 360 * Me, l = M[1] % 360 * Me, u = M.length > 2 ? M[2] % 360 * Me : 0, $()) : [o * St, l * St, u * St]
+        }, k.angle = function(M) {
+            return arguments.length ? (f = M % 360 * Me, $()) : f * St
+        }, k.reflectX = function(M) {
+            return arguments.length ? (h = M ? -1 : 1, $()) : h < 0
+        }, k.reflectY = function(M) {
+            return arguments.length ? (d = M ? -1 : 1, $()) : d < 0
+        }, k.precision = function(M) {
+            return arguments.length ? (S = AA(w, _ = M * M), T()) : In(_)
+        }, k.fitExtent = function(M, F) {
+            return cm(k, M, F)
+        }, k.fitSize = function(M, F) {
+            return Px(k, M, F)
+        }, k.fitWidth = function(M, F) {
+            return Lx(k, M, F)
+        }, k.fitHeight = function(M, F) {
+            return Ix(k, M, F)
+        };
+
+        function $() {
+            var M = $A(n, 0, 0, h, d, f).apply(null, t(s, a)),
+                F = $A(n, i - M[0], r - M[1], h, d, f);
+            return c = hF(o, l, u), w = Cb(t, F), E = Cb(c, w), S = AA(w, _), T()
         }
 
-        function F() {
-            return k = C = null, E
+        function T() {
+            return A = C = null, k
         }
         return function() {
-            return t = e.apply(this, arguments), E.invert = t.invert && T, A()
+            return t = e.apply(this, arguments), k.invert = t.invert && R, $()
         }
     }
 
-    function x_(e) {
+    function zx(e) {
         var t = 0,
-            n = De / 3,
-            i = vD(e),
+            n = Oe / 3,
+            i = TF(e),
             r = i(t, n);
-        return r.parallels = function(a) {
-            return arguments.length ? i(t = a[0] * Me, n = a[1] * Me) : [t * Ct, n * Ct]
+        return r.parallels = function(s) {
+            return arguments.length ? i(t = s[0] * Me, n = s[1] * Me) : [t * St, n * St]
         }, r
     }
 
-    function Fq(e) {
-        var t = be(e);
+    function zG(e) {
+        var t = xe(e);
 
         function n(i, r) {
-            return [i * t, ge(r) / t]
+            return [i * t, pe(r) / t]
         }
         return n.invert = function(i, r) {
-            return [i / t, ii(r * t)]
+            return [i / t, ti(r * t)]
         }, n
     }
 
-    function Dq(e, t) {
-        var n = ge(e),
-            i = (n + ge(t)) / 2;
-        if (Ne(i) < ve) return Fq(e);
+    function BG(e, t) {
+        var n = pe(e),
+            i = (n + pe(t)) / 2;
+        if (Re(i) < ve) return zG(e);
         var r = 1 + n * (2 * i - n),
-            a = Bn(r) / i;
+            s = In(r) / i;
 
-        function s(o, l) {
-            var u = Bn(r - 2 * i * ge(l)) / i;
-            return [u * ge(o *= i), a - u * be(o)]
-        }
-        return s.invert = function(o, l) {
-            var u = a - l,
-                c = Li(o, Ne(u)) * Mi(u);
-            return u * i < 0 && (c -= De * Mi(o) * Mi(u)), [c / i, ii((r - (o * o + u * u) * i * i) / (2 * i))]
-        }, s
+        function a(o, l) {
+            var u = In(r - 2 * i * pe(l)) / i;
+            return [u * pe(o *= i), s - u * xe(o)]
+        }
+        return a.invert = function(o, l) {
+            var u = s - l,
+                c = Fi(o, Re(u)) * ki(u);
+            return u * i < 0 && (c -= Oe * ki(o) * ki(u)), [c / i, ti((r - (o * o + u * u) * i * i) / (2 * i))]
+        }, a
     }
 
-    function y0() {
-        return x_(Dq).scale(155.424).center([0, 33.6442])
+    function Qp() {
+        return zx(BG).scale(155.424).center([0, 33.6442])
     }
 
-    function bD() {
-        return y0().parallels([29.5, 45.5]).scale(1070).translate([480, 250]).rotate([96, 0]).center([-.6, 38.7])
+    function MF() {
+        return Qp().parallels([29.5, 45.5]).scale(1070).translate([480, 250]).rotate([96, 0]).center([-.6, 38.7])
     }
 
-    function Rq(e) {
+    function jG(e) {
         var t = e.length;
         return {
             point: function(n, i) {
                 for (var r = -1; ++r < t;) e[r].point(n, i)
             },
             sphere: function() {
                 for (var n = -1; ++n < t;) e[n].sphere()
@@ -12114,1020 +12114,1020 @@
             },
             polygonEnd: function() {
                 for (var n = -1; ++n < t;) e[n].polygonEnd()
             }
         }
     }
 
-    function Pq() {
-        var e, t, n = bD(),
-            i, r = y0().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]),
-            a, s = y0().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]),
+    function UG() {
+        var e, t, n = MF(),
+            i, r = Qp().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]),
+            s, a = Qp().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]),
             o, l, u = {
                 point: function(h, d) {
                     l = [h, d]
                 }
             };
 
         function c(h) {
             var d = h[0],
                 g = h[1];
-            return l = null, i.point(d, g), l || (a.point(d, g), l) || (o.point(d, g), l)
+            return l = null, i.point(d, g), l || (s.point(d, g), l) || (o.point(d, g), l)
         }
         c.invert = function(h) {
             var d = n.scale(),
                 g = n.translate(),
                 p = (h[0] - g[0]) / d,
                 m = (h[1] - g[1]) / d;
-            return (m >= .12 && m < .234 && p >= -.425 && p < -.214 ? r : m >= .166 && m < .234 && p >= -.214 && p < -.115 ? s : n).invert(h)
+            return (m >= .12 && m < .234 && p >= -.425 && p < -.214 ? r : m >= .166 && m < .234 && p >= -.214 && p < -.115 ? a : n).invert(h)
         }, c.stream = function(h) {
-            return e && t === h ? e : e = Rq([n.stream(t = h), r.stream(h), s.stream(h)])
+            return e && t === h ? e : e = jG([n.stream(t = h), r.stream(h), a.stream(h)])
         }, c.precision = function(h) {
-            return arguments.length ? (n.precision(h), r.precision(h), s.precision(h), f()) : n.precision()
+            return arguments.length ? (n.precision(h), r.precision(h), a.precision(h), f()) : n.precision()
         }, c.scale = function(h) {
-            return arguments.length ? (n.scale(h), r.scale(h * .35), s.scale(h), c.translate(n.translate())) : n.scale()
+            return arguments.length ? (n.scale(h), r.scale(h * .35), a.scale(h), c.translate(n.translate())) : n.scale()
         }, c.translate = function(h) {
             if (!arguments.length) return n.translate();
             var d = n.scale(),
                 g = +h[0],
                 p = +h[1];
             return i = n.translate(h).clipExtent([
                 [g - .455 * d, p - .238 * d],
                 [g + .455 * d, p + .238 * d]
-            ]).stream(u), a = r.translate([g - .307 * d, p + .201 * d]).clipExtent([
+            ]).stream(u), s = r.translate([g - .307 * d, p + .201 * d]).clipExtent([
                 [g - .425 * d + ve, p + .12 * d + ve],
                 [g - .214 * d - ve, p + .234 * d - ve]
-            ]).stream(u), o = s.translate([g - .205 * d, p + .212 * d]).clipExtent([
+            ]).stream(u), o = a.translate([g - .205 * d, p + .212 * d]).clipExtent([
                 [g - .214 * d + ve, p + .166 * d + ve],
                 [g - .115 * d - ve, p + .234 * d - ve]
             ]).stream(u), f()
         }, c.fitExtent = function(h, d) {
-            return $m(c, h, d)
+            return cm(c, h, d)
         }, c.fitSize = function(h, d) {
-            return y_(c, h, d)
+            return Px(c, h, d)
         }, c.fitWidth = function(h, d) {
-            return v_(c, h, d)
+            return Lx(c, h, d)
         }, c.fitHeight = function(h, d) {
-            return b_(c, h, d)
+            return Ix(c, h, d)
         };
 
         function f() {
             return e = t = null, c
         }
         return c.scale(1070)
     }
 
-    function xD(e) {
+    function OF(e) {
         return function(t, n) {
-            var i = be(t),
-                r = be(n),
-                a = e(i * r);
-            return a === 1 / 0 ? [2, 0] : [a * r * ge(t), a * ge(n)]
+            var i = xe(t),
+                r = xe(n),
+                s = e(i * r);
+            return s === 1 / 0 ? [2, 0] : [s * r * pe(t), s * pe(n)]
         }
     }
 
-    function gd(e) {
+    function nd(e) {
         return function(t, n) {
-            var i = Bn(t * t + n * n),
+            var i = In(t * t + n * n),
                 r = e(i),
-                a = ge(r),
-                s = be(r);
-            return [Li(t * a, i * s), ii(i && n * a / i)]
+                s = pe(r),
+                a = xe(r);
+            return [Fi(t * s, i * a), ti(i && n * s / i)]
         }
     }
-    var _D = xD(function(e) {
-        return Bn(2 / (1 + e))
+    var FF = OF(function(e) {
+        return In(2 / (1 + e))
     });
-    _D.invert = gd(function(e) {
-        return 2 * ii(e / 2)
+    FF.invert = nd(function(e) {
+        return 2 * ti(e / 2)
     });
 
-    function Nq() {
-        return la(_D).scale(124.75).clipAngle(180 - .001)
+    function GG() {
+        return es(FF).scale(124.75).clipAngle(180 - .001)
     }
-    var wD = xD(function(e) {
-        return (e = qF(e)) && e / ge(e)
+    var RF = OF(function(e) {
+        return (e = tF(e)) && e / pe(e)
     });
-    wD.invert = gd(function(e) {
+    RF.invert = nd(function(e) {
         return e
     });
 
-    function Lq() {
-        return la(wD).scale(79.4188).clipAngle(180 - .001)
+    function WG() {
+        return es(RF).scale(79.4188).clipAngle(180 - .001)
     }
 
-    function Mm(e, t) {
-        return [e, Jp(g_((_t + t) / 2))]
+    function fm(e, t) {
+        return [e, Fp(Rx((vt + t) / 2))]
     }
-    Mm.invert = function(e, t) {
-        return [e, 2 * kc(UF(t)) - _t]
+    fm.invert = function(e, t) {
+        return [e, 2 * pc(eF(t)) - vt]
     };
 
-    function Iq() {
-        return SD(Mm).scale(961 / zn)
+    function qG() {
+        return DF(fm).scale(961 / Ln)
     }
 
-    function SD(e) {
-        var t = la(e),
+    function DF(e) {
+        var t = es(e),
             n = t.center,
             i = t.scale,
             r = t.translate,
-            a = t.clipExtent,
-            s = null,
+            s = t.clipExtent,
+            a = null,
             o, l, u;
         t.scale = function(f) {
             return arguments.length ? (i(f), c()) : i()
         }, t.translate = function(f) {
             return arguments.length ? (r(f), c()) : r()
         }, t.center = function(f) {
             return arguments.length ? (n(f), c()) : n()
         }, t.clipExtent = function(f) {
-            return arguments.length ? (f == null ? s = o = l = u = null : (s = +f[0][0], o = +f[0][1], l = +f[1][0], u = +f[1][1]), c()) : s == null ? null : [
-                [s, o],
+            return arguments.length ? (f == null ? a = o = l = u = null : (a = +f[0][0], o = +f[0][1], l = +f[1][0], u = +f[1][1]), c()) : a == null ? null : [
+                [a, o],
                 [l, u]
             ]
         };
 
         function c() {
-            var f = De * i(),
-                h = t(iq(t.rotate()).invert([0, 0]));
-            return a(s == null ? [
+            var f = Oe * i(),
+                h = t(cG(t.rotate()).invert([0, 0]));
+            return s(a == null ? [
                 [h[0] - f, h[1] - f],
                 [h[0] + f, h[1] + f]
-            ] : e === Mm ? [
-                [Math.max(h[0] - f, s), o],
+            ] : e === fm ? [
+                [Math.max(h[0] - f, a), o],
                 [Math.min(h[0] + f, l), u]
             ] : [
-                [s, Math.max(h[1] - f, o)],
+                [a, Math.max(h[1] - f, o)],
                 [l, Math.min(h[1] + f, u)]
             ])
         }
         return c()
     }
 
-    function Og(e) {
-        return g_((_t + e) / 2)
+    function cg(e) {
+        return Rx((vt + e) / 2)
     }
 
-    function jq(e, t) {
-        var n = be(e),
-            i = e === t ? ge(e) : Jp(n / be(t)) / Jp(Og(t) / Og(e)),
-            r = n * Jy(Og(e), i) / i;
-        if (!i) return Mm;
-
-        function a(s, o) {
-            r > 0 ? o < -_t + ve && (o = -_t + ve) : o > _t - ve && (o = _t - ve);
-            var l = r / Jy(Og(o), i);
-            return [l * ge(i * s), r - l * be(i * s)]
+    function HG(e, t) {
+        var n = xe(e),
+            i = e === t ? pe(e) : Fp(n / xe(t)) / Fp(cg(t) / cg(e)),
+            r = n * Ty(cg(e), i) / i;
+        if (!i) return fm;
+
+        function s(a, o) {
+            r > 0 ? o < -vt + ve && (o = -vt + ve) : o > vt - ve && (o = vt - ve);
+            var l = r / Ty(cg(o), i);
+            return [l * pe(i * a), r - l * xe(i * a)]
         }
-        return a.invert = function(s, o) {
+        return s.invert = function(a, o) {
             var l = r - o,
-                u = Mi(i) * Bn(s * s + l * l),
-                c = Li(s, Ne(l)) * Mi(l);
-            return l * i < 0 && (c -= De * Mi(s) * Mi(l)), [c / i, 2 * kc(Jy(r / u, 1 / i)) - _t]
-        }, a
+                u = ki(i) * In(a * a + l * l),
+                c = Fi(a, Re(l)) * ki(l);
+            return l * i < 0 && (c -= Oe * ki(a) * ki(l)), [c / i, 2 * pc(Ty(r / u, 1 / i)) - vt]
+        }, s
     }
 
-    function zq() {
-        return x_(jq).scale(109.5).parallels([30, 30])
+    function YG() {
+        return zx(HG).scale(109.5).parallels([30, 30])
     }
 
-    function v0(e, t) {
+    function Zp(e, t) {
         return [e, t]
     }
-    v0.invert = v0;
+    Zp.invert = Zp;
 
-    function Bq() {
-        return la(v0).scale(152.63)
+    function XG() {
+        return es(Zp).scale(152.63)
     }
 
-    function Gq(e, t) {
-        var n = be(e),
-            i = e === t ? ge(e) : (n - be(t)) / (t - e),
+    function VG(e, t) {
+        var n = xe(e),
+            i = e === t ? pe(e) : (n - xe(t)) / (t - e),
             r = n / i + e;
-        if (Ne(i) < ve) return v0;
+        if (Re(i) < ve) return Zp;
 
-        function a(s, o) {
+        function s(a, o) {
             var l = r - o,
-                u = i * s;
-            return [l * ge(u), r - l * be(u)]
+                u = i * a;
+            return [l * pe(u), r - l * xe(u)]
         }
-        return a.invert = function(s, o) {
+        return s.invert = function(a, o) {
             var l = r - o,
-                u = Li(s, Ne(l)) * Mi(l);
-            return l * i < 0 && (u -= De * Mi(s) * Mi(l)), [u / i, r - Mi(i) * Bn(s * s + l * l)]
-        }, a
+                u = Fi(a, Re(l)) * ki(l);
+            return l * i < 0 && (u -= Oe * ki(a) * ki(l)), [u / i, r - ki(i) * In(a * a + l * l)]
+        }, s
     }
 
-    function Uq() {
-        return x_(Gq).scale(131.154).center([0, 13.9389])
+    function KG() {
+        return zx(VG).scale(131.154).center([0, 13.9389])
     }
-    var uh = 1.340264,
-        ch = -.081106,
-        fh = 893e-6,
-        hh = .003796,
-        b0 = Bn(3) / 2,
-        qq = 12;
+    var Jf = 1.340264,
+        Qf = -.081106,
+        Zf = 893e-6,
+        eh = .003796,
+        e0 = In(3) / 2,
+        JG = 12;
 
-    function ED(e, t) {
-        var n = ii(b0 * ge(t)),
+    function NF(e, t) {
+        var n = ti(e0 * pe(t)),
             i = n * n,
             r = i * i * i;
-        return [e * be(n) / (b0 * (uh + 3 * ch * i + r * (7 * fh + 9 * hh * i))), n * (uh + ch * i + r * (fh + hh * i))]
+        return [e * xe(n) / (e0 * (Jf + 3 * Qf * i + r * (7 * Zf + 9 * eh * i))), n * (Jf + Qf * i + r * (Zf + eh * i))]
     }
-    ED.invert = function(e, t) {
-        for (var n = t, i = n * n, r = i * i * i, a = 0, s, o, l; a < qq && (o = n * (uh + ch * i + r * (fh + hh * i)) - t, l = uh + 3 * ch * i + r * (7 * fh + 9 * hh * i), n -= s = o / l, i = n * n, r = i * i * i, !(Ne(s) < Vp)); ++a);
-        return [b0 * e * (uh + 3 * ch * i + r * (7 * fh + 9 * hh * i)) / be(n), ii(ge(n) / b0)]
+    NF.invert = function(e, t) {
+        for (var n = t, i = n * n, r = i * i * i, s = 0, a, o, l; s < JG && (o = n * (Jf + Qf * i + r * (Zf + eh * i)) - t, l = Jf + 3 * Qf * i + r * (7 * Zf + 9 * eh * i), n -= a = o / l, i = n * n, r = i * i * i, !(Re(a) < Mp)); ++s);
+        return [e0 * e * (Jf + 3 * Qf * i + r * (7 * Zf + 9 * eh * i)) / xe(n), ti(pe(n) / e0)]
     };
 
-    function Wq() {
-        return la(ED).scale(177.158)
+    function QG() {
+        return es(NF).scale(177.158)
     }
 
-    function OD(e, t) {
-        var n = be(t),
-            i = be(e) * n;
-        return [n * ge(e) / i, ge(t) / i]
+    function PF(e, t) {
+        var n = xe(t),
+            i = xe(e) * n;
+        return [n * pe(e) / i, pe(t) / i]
     }
-    OD.invert = gd(kc);
+    PF.invert = nd(pc);
 
-    function Hq() {
-        return la(OD).scale(144.049).clipAngle(60)
+    function ZG() {
+        return es(PF).scale(144.049).clipAngle(60)
     }
 
-    function Yq() {
+    function eW() {
         var e = 1,
             t = 0,
             n = 0,
             i = 1,
             r = 1,
-            a = 0,
-            s, o, l = null,
+            s = 0,
+            a, o, l = null,
             u, c, f, h = 1,
             d = 1,
-            g = Tm({
+            g = um({
                 point: function(x, _) {
                     var S = b([x, _]);
                     this.stream.point(S[0], S[1])
                 }
             }),
-            p = $h,
+            p = vh,
             m, y;
 
         function v() {
             return h = e * i, d = e * r, m = y = null, b
         }
 
         function b(x) {
             var _ = x[0] * h,
                 S = x[1] * d;
-            if (a) {
-                var w = S * s - _ * o;
-                _ = _ * s + S * o, S = w
+            if (s) {
+                var w = S * a - _ * o;
+                _ = _ * a + S * o, S = w
             }
             return [_ + t, S + n]
         }
         return b.invert = function(x) {
             var _ = x[0] - t,
                 S = x[1] - n;
-            if (a) {
-                var w = S * s + _ * o;
-                _ = _ * s - S * o, S = w
+            if (s) {
+                var w = S * a + _ * o;
+                _ = _ * a - S * o, S = w
             }
             return [_ / h, S / d]
         }, b.stream = function(x) {
             return m && y === x ? m : m = g(p(y = x))
         }, b.postclip = function(x) {
             return arguments.length ? (p = x, l = u = c = f = null, v()) : p
         }, b.clipExtent = function(x) {
-            return arguments.length ? (p = x == null ? (l = u = c = f = null, $h) : aD(l = +x[0][0], u = +x[0][1], c = +x[1][0], f = +x[1][1]), v()) : l == null ? null : [
+            return arguments.length ? (p = x == null ? (l = u = c = f = null, vh) : mF(l = +x[0][0], u = +x[0][1], c = +x[1][0], f = +x[1][1]), v()) : l == null ? null : [
                 [l, u],
                 [c, f]
             ]
         }, b.scale = function(x) {
             return arguments.length ? (e = +x, v()) : e
         }, b.translate = function(x) {
             return arguments.length ? (t = +x[0], n = +x[1], v()) : [t, n]
         }, b.angle = function(x) {
-            return arguments.length ? (a = x % 360 * Me, o = ge(a), s = be(a), v()) : a * Ct
+            return arguments.length ? (s = x % 360 * Me, o = pe(s), a = xe(s), v()) : s * St
         }, b.reflectX = function(x) {
             return arguments.length ? (i = x ? -1 : 1, v()) : i < 0
         }, b.reflectY = function(x) {
             return arguments.length ? (r = x ? -1 : 1, v()) : r < 0
         }, b.fitExtent = function(x, _) {
-            return $m(b, x, _)
+            return cm(b, x, _)
         }, b.fitSize = function(x, _) {
-            return y_(b, x, _)
+            return Px(b, x, _)
         }, b.fitWidth = function(x, _) {
-            return v_(b, x, _)
+            return Lx(b, x, _)
         }, b.fitHeight = function(x, _) {
-            return b_(b, x, _)
+            return Ix(b, x, _)
         }, b
     }
 
-    function CD(e, t) {
+    function LF(e, t) {
         var n = t * t,
             i = n * n;
         return [e * (.8707 - .131979 * n + i * (-.013791 + i * (.003971 * n - .001529 * i))), t * (1.007226 + n * (.015085 + i * (-.044475 + .028874 * n - .005916 * i)))]
     }
-    CD.invert = function(e, t) {
+    LF.invert = function(e, t) {
         var n = t,
             i = 25,
             r;
         do {
-            var a = n * n,
-                s = a * a;
-            n -= r = (n * (1.007226 + a * (.015085 + s * (-.044475 + .028874 * a - .005916 * s))) - t) / (1.007226 + a * (.015085 * 3 + s * (-.044475 * 7 + .028874 * 9 * a - .005916 * 11 * s)))
-        } while (Ne(r) > ve && --i > 0);
-        return [e / (.8707 + (a = n * n) * (-.131979 + a * (-.013791 + a * a * a * (.003971 - .001529 * a)))), n]
+            var s = n * n,
+                a = s * s;
+            n -= r = (n * (1.007226 + s * (.015085 + a * (-.044475 + .028874 * s - .005916 * a))) - t) / (1.007226 + s * (.015085 * 3 + a * (-.044475 * 7 + .028874 * 9 * s - .005916 * 11 * a)))
+        } while (Re(r) > ve && --i > 0);
+        return [e / (.8707 + (s = n * n) * (-.131979 + s * (-.013791 + s * s * s * (.003971 - .001529 * s)))), n]
     };
 
-    function Xq() {
-        return la(CD).scale(175.295)
+    function tW() {
+        return es(LF).scale(175.295)
     }
 
-    function kD(e, t) {
-        return [be(t) * ge(e), ge(t)]
+    function IF(e, t) {
+        return [xe(t) * pe(e), pe(t)]
     }
-    kD.invert = gd(ii);
+    IF.invert = nd(ti);
 
-    function Vq() {
-        return la(kD).scale(249.5).clipAngle(90 + ve)
+    function nW() {
+        return es(IF).scale(249.5).clipAngle(90 + ve)
     }
 
-    function AD(e, t) {
-        var n = be(t),
-            i = 1 + be(e) * n;
-        return [n * ge(e) / i, ge(t) / i]
+    function zF(e, t) {
+        var n = xe(t),
+            i = 1 + xe(e) * n;
+        return [n * pe(e) / i, pe(t) / i]
     }
-    AD.invert = gd(function(e) {
-        return 2 * kc(e)
+    zF.invert = nd(function(e) {
+        return 2 * pc(e)
     });
 
-    function Kq() {
-        return la(AD).scale(250).clipAngle(142)
+    function iW() {
+        return es(zF).scale(250).clipAngle(142)
     }
 
-    function TD(e, t) {
-        return [Jp(g_((_t + t) / 2)), -e]
+    function BF(e, t) {
+        return [Fp(Rx((vt + t) / 2)), -e]
     }
-    TD.invert = function(e, t) {
-        return [-t, 2 * kc(UF(e)) - _t]
+    BF.invert = function(e, t) {
+        return [-t, 2 * pc(eF(e)) - vt]
     };
 
-    function Jq() {
-        var e = SD(TD),
+    function rW() {
+        var e = DF(BF),
             t = e.center,
             n = e.rotate;
         return e.center = function(i) {
             return arguments.length ? t([-i[1], i[0]]) : (i = t(), [i[1], -i[0]])
         }, e.rotate = function(i) {
             return arguments.length ? n([i[0], i[1], i.length > 2 ? i[2] + 90 : 90]) : (i = n(), [i[0], i[1], i[2] - 90])
         }, n([0, 0, 90]).scale(159.155)
     }
 
-    function Qq(e, t) {
+    function sW(e, t) {
         return e.parent === t.parent ? 1 : 2
     }
 
-    function Zq(e) {
-        return e.reduce(eW, 0) / e.length
+    function aW(e) {
+        return e.reduce(oW, 0) / e.length
     }
 
-    function eW(e, t) {
+    function oW(e, t) {
         return e + t.x
     }
 
-    function tW(e) {
-        return 1 + e.reduce(nW, 0)
+    function lW(e) {
+        return 1 + e.reduce(uW, 0)
     }
 
-    function nW(e, t) {
+    function uW(e, t) {
         return Math.max(e, t.y)
     }
 
-    function iW(e) {
+    function cW(e) {
         for (var t; t = e.children;) e = t[0];
         return e
     }
 
-    function rW(e) {
+    function fW(e) {
         for (var t; t = e.children;) e = t[t.length - 1];
         return e
     }
 
-    function aW() {
-        var e = Qq,
+    function hW() {
+        var e = sW,
             t = 1,
             n = 1,
             i = !1;
 
-        function r(a) {
-            var s, o = 0;
-            a.eachAfter(function(h) {
+        function r(s) {
+            var a, o = 0;
+            s.eachAfter(function(h) {
                 var d = h.children;
-                d ? (h.x = Zq(d), h.y = tW(d)) : (h.x = s ? o += e(h, s) : 0, h.y = 0, s = h)
+                d ? (h.x = aW(d), h.y = lW(d)) : (h.x = a ? o += e(h, a) : 0, h.y = 0, a = h)
             });
-            var l = iW(a),
-                u = rW(a),
+            var l = cW(s),
+                u = fW(s),
                 c = l.x - e(l, u) / 2,
                 f = u.x + e(u, l) / 2;
-            return a.eachAfter(i ? function(h) {
-                h.x = (h.x - a.x) * t, h.y = (a.y - h.y) * n
+            return s.eachAfter(i ? function(h) {
+                h.x = (h.x - s.x) * t, h.y = (s.y - h.y) * n
             } : function(h) {
-                h.x = (h.x - c) / (f - c) * t, h.y = (1 - (a.y ? h.y / a.y : 1)) * n
+                h.x = (h.x - c) / (f - c) * t, h.y = (1 - (s.y ? h.y / s.y : 1)) * n
             })
         }
-        return r.separation = function(a) {
-            return arguments.length ? (e = a, r) : e
-        }, r.size = function(a) {
-            return arguments.length ? (i = !1, t = +a[0], n = +a[1], r) : i ? null : [t, n]
-        }, r.nodeSize = function(a) {
-            return arguments.length ? (i = !0, t = +a[0], n = +a[1], r) : i ? [t, n] : null
+        return r.separation = function(s) {
+            return arguments.length ? (e = s, r) : e
+        }, r.size = function(s) {
+            return arguments.length ? (i = !1, t = +s[0], n = +s[1], r) : i ? null : [t, n]
+        }, r.nodeSize = function(s) {
+            return arguments.length ? (i = !0, t = +s[0], n = +s[1], r) : i ? [t, n] : null
         }, r
     }
 
-    function sW(e) {
+    function dW(e) {
         var t = 0,
             n = e.children,
             i = n && n.length;
         if (!i) t = 1;
         else
             for (; --i >= 0;) t += n[i].value;
         e.value = t
     }
 
-    function oW() {
-        return this.eachAfter(sW)
+    function gW() {
+        return this.eachAfter(dW)
     }
 
-    function lW(e, t) {
+    function pW(e, t) {
         let n = -1;
         for (const i of this) e.call(t, i, ++n, this);
         return this
     }
 
-    function uW(e, t) {
-        for (var n = this, i = [n], r, a, s = -1; n = i.pop();)
-            if (e.call(t, n, ++s, this), r = n.children)
-                for (a = r.length - 1; a >= 0; --a) i.push(r[a]);
+    function mW(e, t) {
+        for (var n = this, i = [n], r, s, a = -1; n = i.pop();)
+            if (e.call(t, n, ++a, this), r = n.children)
+                for (s = r.length - 1; s >= 0; --s) i.push(r[s]);
         return this
     }
 
-    function cW(e, t) {
-        for (var n = this, i = [n], r = [], a, s, o, l = -1; n = i.pop();)
-            if (r.push(n), a = n.children)
-                for (s = 0, o = a.length; s < o; ++s) i.push(a[s]);
+    function yW(e, t) {
+        for (var n = this, i = [n], r = [], s, a, o, l = -1; n = i.pop();)
+            if (r.push(n), s = n.children)
+                for (a = 0, o = s.length; a < o; ++a) i.push(s[a]);
         for (; n = r.pop();) e.call(t, n, ++l, this);
         return this
     }
 
-    function fW(e, t) {
+    function vW(e, t) {
         let n = -1;
         for (const i of this)
             if (e.call(t, i, ++n, this)) return i
     }
 
-    function hW(e) {
+    function bW(e) {
         return this.eachAfter(function(t) {
             for (var n = +e(t.data) || 0, i = t.children, r = i && i.length; --r >= 0;) n += i[r].value;
             t.value = n
         })
     }
 
-    function dW(e) {
+    function xW(e) {
         return this.eachBefore(function(t) {
             t.children && t.children.sort(e)
         })
     }
 
-    function gW(e) {
-        for (var t = this, n = pW(t, e), i = [t]; t !== n;) t = t.parent, i.push(t);
+    function _W(e) {
+        for (var t = this, n = wW(t, e), i = [t]; t !== n;) t = t.parent, i.push(t);
         for (var r = i.length; e !== n;) i.splice(r, 0, e), e = e.parent;
         return i
     }
 
-    function pW(e, t) {
+    function wW(e, t) {
         if (e === t) return e;
         var n = e.ancestors(),
             i = t.ancestors(),
             r = null;
         for (e = n.pop(), t = i.pop(); e === t;) r = e, e = n.pop(), t = i.pop();
         return r
     }
 
-    function mW() {
+    function SW() {
         for (var e = this, t = [e]; e = e.parent;) t.push(e);
         return t
     }
 
-    function yW() {
+    function EW() {
         return Array.from(this)
     }
 
-    function vW() {
+    function CW() {
         var e = [];
         return this.eachBefore(function(t) {
             t.children || e.push(t)
         }), e
     }
 
-    function bW() {
+    function kW() {
         var e = this,
             t = [];
         return e.each(function(n) {
             n !== e && t.push({
                 source: n.parent,
                 target: n
             })
         }), t
     }
 
-    function* xW() {
+    function* AW() {
         var e = this,
             t, n = [e],
-            i, r, a;
+            i, r, s;
         do
             for (t = n.reverse(), n = []; e = t.pop();)
                 if (yield e, i = e.children)
-                    for (r = 0, a = i.length; r < a; ++r) n.push(i[r]); while (n.length)
+                    for (r = 0, s = i.length; r < s; ++r) n.push(i[r]); while (n.length)
     }
 
-    function __(e, t) {
-        e instanceof Map ? (e = [void 0, e], t === void 0 && (t = SW)) : t === void 0 && (t = wW);
-        for (var n = new Yu(e), i, r = [n], a, s, o, l; i = r.pop();)
-            if ((s = t(i.data)) && (l = (s = Array.from(s)).length))
-                for (i.children = s, o = l - 1; o >= 0; --o) r.push(a = s[o] = new Yu(s[o])), a.parent = i, a.depth = i.depth + 1;
-        return n.eachBefore($D)
+    function Bx(e, t) {
+        e instanceof Map ? (e = [void 0, e], t === void 0 && (t = MW)) : t === void 0 && (t = TW);
+        for (var n = new Pu(e), i, r = [n], s, a, o, l; i = r.pop();)
+            if ((a = t(i.data)) && (l = (a = Array.from(a)).length))
+                for (i.children = a, o = l - 1; o >= 0; --o) r.push(s = a[o] = new Pu(a[o])), s.parent = i, s.depth = i.depth + 1;
+        return n.eachBefore(jF)
     }
 
-    function _W() {
-        return __(this).eachBefore(EW)
+    function $W() {
+        return Bx(this).eachBefore(OW)
     }
 
-    function wW(e) {
+    function TW(e) {
         return e.children
     }
 
-    function SW(e) {
+    function MW(e) {
         return Array.isArray(e) ? e[1] : null
     }
 
-    function EW(e) {
+    function OW(e) {
         e.data.value !== void 0 && (e.value = e.data.value), e.data = e.data.data
     }
 
-    function $D(e) {
+    function jF(e) {
         var t = 0;
         do e.height = t; while ((e = e.parent) && e.height < ++t)
     }
 
-    function Yu(e) {
+    function Pu(e) {
         this.data = e, this.depth = this.height = 0, this.parent = null
     }
-    Yu.prototype = __.prototype = {
-        constructor: Yu,
-        count: oW,
-        each: lW,
-        eachAfter: cW,
-        eachBefore: uW,
-        find: fW,
-        sum: hW,
-        sort: dW,
-        path: gW,
-        ancestors: mW,
-        descendants: yW,
-        leaves: vW,
-        links: bW,
-        copy: _W,
-        [Symbol.iterator]: xW
+    Pu.prototype = Bx.prototype = {
+        constructor: Pu,
+        count: gW,
+        each: pW,
+        eachAfter: yW,
+        eachBefore: mW,
+        find: vW,
+        sum: bW,
+        sort: xW,
+        path: _W,
+        ancestors: SW,
+        descendants: EW,
+        leaves: CW,
+        links: kW,
+        copy: $W,
+        [Symbol.iterator]: AW
     };
 
-    function fp(e) {
-        return e == null ? null : MD(e)
+    function Yg(e) {
+        return e == null ? null : UF(e)
     }
 
-    function MD(e) {
+    function UF(e) {
         if (typeof e != "function") throw new Error;
         return e
     }
 
-    function jo() {
+    function Ao() {
         return 0
     }
 
-    function yu(e) {
+    function au(e) {
         return function() {
             return e
         }
     }
-    const OW = 1664525,
-        CW = 1013904223,
-        pA = 4294967296;
+    const FW = 1664525,
+        RW = 1013904223,
+        TA = 4294967296;
 
-    function kW() {
+    function DW() {
         let e = 1;
-        return () => (e = (OW * e + CW) % pA) / pA
+        return () => (e = (FW * e + RW) % TA) / TA
     }
 
-    function AW(e) {
+    function NW(e) {
         return typeof e == "object" && "length" in e ? e : Array.from(e)
     }
 
-    function TW(e, t) {
+    function PW(e, t) {
         let n = e.length,
             i, r;
         for (; n;) r = t() * n-- | 0, i = e[n], e[n] = e[r], e[r] = i;
         return e
     }
 
-    function $W(e, t) {
-        for (var n = 0, i = (e = TW(Array.from(e), t)).length, r = [], a, s; n < i;) a = e[n], s && FD(s, a) ? ++n : (s = FW(r = MW(r, a)), n = 0);
-        return s
+    function LW(e, t) {
+        for (var n = 0, i = (e = PW(Array.from(e), t)).length, r = [], s, a; n < i;) s = e[n], a && GF(a, s) ? ++n : (a = zW(r = IW(r, s)), n = 0);
+        return a
     }
 
-    function MW(e, t) {
+    function IW(e, t) {
         var n, i;
-        if (nv(t, e)) return [t];
+        if (Dy(t, e)) return [t];
         for (n = 0; n < e.length; ++n)
-            if (Cg(t, e[n]) && nv(Gf(e[n], t), e)) return [e[n], t];
+            if (fg(t, e[n]) && Dy(Mf(e[n], t), e)) return [e[n], t];
         for (n = 0; n < e.length - 1; ++n)
             for (i = n + 1; i < e.length; ++i)
-                if (Cg(Gf(e[n], e[i]), t) && Cg(Gf(e[n], t), e[i]) && Cg(Gf(e[i], t), e[n]) && nv(DD(e[n], e[i], t), e)) return [e[n], e[i], t];
+                if (fg(Mf(e[n], e[i]), t) && fg(Mf(e[n], t), e[i]) && fg(Mf(e[i], t), e[n]) && Dy(WF(e[n], e[i], t), e)) return [e[n], e[i], t];
         throw new Error
     }
 
-    function Cg(e, t) {
+    function fg(e, t) {
         var n = e.r - t.r,
             i = t.x - e.x,
             r = t.y - e.y;
         return n < 0 || n * n < i * i + r * r
     }
 
-    function FD(e, t) {
+    function GF(e, t) {
         var n = e.r - t.r + Math.max(e.r, t.r, 1) * 1e-9,
             i = t.x - e.x,
             r = t.y - e.y;
         return n > 0 && n * n > i * i + r * r
     }
 
-    function nv(e, t) {
+    function Dy(e, t) {
         for (var n = 0; n < t.length; ++n)
-            if (!FD(e, t[n])) return !1;
+            if (!GF(e, t[n])) return !1;
         return !0
     }
 
-    function FW(e) {
+    function zW(e) {
         switch (e.length) {
             case 1:
-                return DW(e[0]);
+                return BW(e[0]);
             case 2:
-                return Gf(e[0], e[1]);
+                return Mf(e[0], e[1]);
             case 3:
-                return DD(e[0], e[1], e[2])
+                return WF(e[0], e[1], e[2])
         }
     }
 
-    function DW(e) {
+    function BW(e) {
         return {
             x: e.x,
             y: e.y,
             r: e.r
         }
     }
 
-    function Gf(e, t) {
+    function Mf(e, t) {
         var n = e.x,
             i = e.y,
             r = e.r,
-            a = t.x,
-            s = t.y,
+            s = t.x,
+            a = t.y,
             o = t.r,
-            l = a - n,
-            u = s - i,
+            l = s - n,
+            u = a - i,
             c = o - r,
             f = Math.sqrt(l * l + u * u);
         return {
-            x: (n + a + l / f * c) / 2,
-            y: (i + s + u / f * c) / 2,
+            x: (n + s + l / f * c) / 2,
+            y: (i + a + u / f * c) / 2,
             r: (f + r + o) / 2
         }
     }
 
-    function DD(e, t, n) {
+    function WF(e, t, n) {
         var i = e.x,
             r = e.y,
-            a = e.r,
-            s = t.x,
+            s = e.r,
+            a = t.x,
             o = t.y,
             l = t.r,
             u = n.x,
             c = n.y,
             f = n.r,
-            h = i - s,
+            h = i - a,
             d = i - u,
             g = r - o,
             p = r - c,
-            m = l - a,
-            y = f - a,
-            v = i * i + r * r - a * a,
-            b = v - s * s - o * o + l * l,
+            m = l - s,
+            y = f - s,
+            v = i * i + r * r - s * s,
+            b = v - a * a - o * o + l * l,
             x = v - u * u - c * c + f * f,
             _ = d * g - h * p,
             S = (g * x - p * b) / (_ * 2) - i,
             w = (p * m - g * y) / _,
-            O = (d * b - h * x) / (_ * 2) - r,
-            k = (h * y - d * m) / _,
-            C = w * w + k * k - 1,
-            E = 2 * (a + S * w + O * k),
-            T = S * S + O * O - a * a,
-            A = -(Math.abs(C) > 1e-6 ? (E + Math.sqrt(E * E - 4 * C * T)) / (2 * C) : T / E);
-        return {
-            x: i + S + w * A,
-            y: r + O + k * A,
-            r: A
+            E = (d * b - h * x) / (_ * 2) - r,
+            A = (h * y - d * m) / _,
+            C = w * w + A * A - 1,
+            k = 2 * (s + S * w + E * A),
+            R = S * S + E * E - s * s,
+            $ = -(Math.abs(C) > 1e-6 ? (k + Math.sqrt(k * k - 4 * C * R)) / (2 * C) : R / k);
+        return {
+            x: i + S + w * $,
+            y: r + E + A * $,
+            r: $
         }
     }
 
-    function mA(e, t, n) {
+    function MA(e, t, n) {
         var i = e.x - t.x,
-            r, a, s = e.y - t.y,
-            o, l, u = i * i + s * s;
-        u ? (a = t.r + n.r, a *= a, l = e.r + n.r, l *= l, a > l ? (r = (u + l - a) / (2 * u), o = Math.sqrt(Math.max(0, l / u - r * r)), n.x = e.x - r * i - o * s, n.y = e.y - r * s + o * i) : (r = (u + a - l) / (2 * u), o = Math.sqrt(Math.max(0, a / u - r * r)), n.x = t.x + r * i - o * s, n.y = t.y + r * s + o * i)) : (n.x = t.x + n.r, n.y = t.y)
+            r, s, a = e.y - t.y,
+            o, l, u = i * i + a * a;
+        u ? (s = t.r + n.r, s *= s, l = e.r + n.r, l *= l, s > l ? (r = (u + l - s) / (2 * u), o = Math.sqrt(Math.max(0, l / u - r * r)), n.x = e.x - r * i - o * a, n.y = e.y - r * a + o * i) : (r = (u + s - l) / (2 * u), o = Math.sqrt(Math.max(0, s / u - r * r)), n.x = t.x + r * i - o * a, n.y = t.y + r * a + o * i)) : (n.x = t.x + n.r, n.y = t.y)
     }
 
-    function yA(e, t) {
+    function OA(e, t) {
         var n = e.r + t.r - 1e-6,
             i = t.x - e.x,
             r = t.y - e.y;
         return n > 0 && n * n > i * i + r * r
     }
 
-    function vA(e) {
+    function FA(e) {
         var t = e._,
             n = e.next._,
             i = t.r + n.r,
             r = (t.x * n.r + n.x * t.r) / i,
-            a = (t.y * n.r + n.y * t.r) / i;
-        return r * r + a * a
+            s = (t.y * n.r + n.y * t.r) / i;
+        return r * r + s * s
     }
 
-    function kg(e) {
+    function hg(e) {
         this._ = e, this.next = null, this.previous = null
     }
 
-    function RW(e, t) {
-        if (!(a = (e = AW(e)).length)) return 0;
-        var n, i, r, a, s, o, l, u, c, f, h;
-        if (n = e[0], n.x = 0, n.y = 0, !(a > 1)) return n.r;
-        if (i = e[1], n.x = -i.r, i.x = n.r, i.y = 0, !(a > 2)) return n.r + i.r;
-        mA(i, n, r = e[2]), n = new kg(n), i = new kg(i), r = new kg(r), n.next = r.previous = i, i.next = n.previous = r, r.next = i.previous = n;
-        e: for (l = 3; l < a; ++l) {
-            mA(n._, i._, r = e[l]), r = new kg(r), u = i.next, c = n.previous, f = i._.r, h = n._.r;
+    function jW(e, t) {
+        if (!(s = (e = NW(e)).length)) return 0;
+        var n, i, r, s, a, o, l, u, c, f, h;
+        if (n = e[0], n.x = 0, n.y = 0, !(s > 1)) return n.r;
+        if (i = e[1], n.x = -i.r, i.x = n.r, i.y = 0, !(s > 2)) return n.r + i.r;
+        MA(i, n, r = e[2]), n = new hg(n), i = new hg(i), r = new hg(r), n.next = r.previous = i, i.next = n.previous = r, r.next = i.previous = n;
+        e: for (l = 3; l < s; ++l) {
+            MA(n._, i._, r = e[l]), r = new hg(r), u = i.next, c = n.previous, f = i._.r, h = n._.r;
             do
                 if (f <= h) {
-                    if (yA(u._, r._)) {
+                    if (OA(u._, r._)) {
                         i = u, n.next = i, i.previous = n, --l;
                         continue e
                     }
                     f += u._.r, u = u.next
                 } else {
-                    if (yA(c._, r._)) {
+                    if (OA(c._, r._)) {
                         n = c, n.next = i, i.previous = n, --l;
                         continue e
                     }
                     h += c._.r, c = c.previous
                 } while (u !== c.next);
-            for (r.previous = n, r.next = i, n.next = i.previous = i = r, s = vA(n);
-                (r = r.next) !== i;)(o = vA(r)) < s && (n = r, s = o);
+            for (r.previous = n, r.next = i, n.next = i.previous = i = r, a = FA(n);
+                (r = r.next) !== i;)(o = FA(r)) < a && (n = r, a = o);
             i = n.next
         }
         for (n = [i._], r = i;
             (r = r.next) !== i;) n.push(r._);
-        for (r = $W(n, t), l = 0; l < a; ++l) n = e[l], n.x -= r.x, n.y -= r.y;
+        for (r = LW(n, t), l = 0; l < s; ++l) n = e[l], n.x -= r.x, n.y -= r.y;
         return r.r
     }
 
-    function PW(e) {
+    function UW(e) {
         return Math.sqrt(e.value)
     }
 
-    function NW() {
+    function GW() {
         var e = null,
             t = 1,
             n = 1,
-            i = jo;
+            i = Ao;
 
-        function r(a) {
-            const s = kW();
-            return a.x = t / 2, a.y = n / 2, e ? a.eachBefore(bA(e)).eachAfter(iv(i, .5, s)).eachBefore(xA(1)) : a.eachBefore(bA(PW)).eachAfter(iv(jo, 1, s)).eachAfter(iv(i, a.r / Math.min(t, n), s)).eachBefore(xA(Math.min(t, n) / (2 * a.r))), a
+        function r(s) {
+            const a = DW();
+            return s.x = t / 2, s.y = n / 2, e ? s.eachBefore(RA(e)).eachAfter(Ny(i, .5, a)).eachBefore(DA(1)) : s.eachBefore(RA(UW)).eachAfter(Ny(Ao, 1, a)).eachAfter(Ny(i, s.r / Math.min(t, n), a)).eachBefore(DA(Math.min(t, n) / (2 * s.r))), s
         }
-        return r.radius = function(a) {
-            return arguments.length ? (e = fp(a), r) : e
-        }, r.size = function(a) {
-            return arguments.length ? (t = +a[0], n = +a[1], r) : [t, n]
-        }, r.padding = function(a) {
-            return arguments.length ? (i = typeof a == "function" ? a : yu(+a), r) : i
+        return r.radius = function(s) {
+            return arguments.length ? (e = Yg(s), r) : e
+        }, r.size = function(s) {
+            return arguments.length ? (t = +s[0], n = +s[1], r) : [t, n]
+        }, r.padding = function(s) {
+            return arguments.length ? (i = typeof s == "function" ? s : au(+s), r) : i
         }, r
     }
 
-    function bA(e) {
+    function RA(e) {
         return function(t) {
             t.children || (t.r = Math.max(0, +e(t) || 0))
         }
     }
 
-    function iv(e, t, n) {
+    function Ny(e, t, n) {
         return function(i) {
             if (r = i.children) {
-                var r, a, s = r.length,
+                var r, s, a = r.length,
                     o = e(i) * t || 0,
                     l;
                 if (o)
-                    for (a = 0; a < s; ++a) r[a].r += o;
-                if (l = RW(r, n), o)
-                    for (a = 0; a < s; ++a) r[a].r -= o;
+                    for (s = 0; s < a; ++s) r[s].r += o;
+                if (l = jW(r, n), o)
+                    for (s = 0; s < a; ++s) r[s].r -= o;
                 i.r = l + o
             }
         }
     }
 
-    function xA(e) {
+    function DA(e) {
         return function(t) {
             var n = t.parent;
             t.r *= e, n && (t.x = n.x + e * t.x, t.y = n.y + e * t.y)
         }
     }
 
-    function RD(e) {
+    function qF(e) {
         e.x0 = Math.round(e.x0), e.y0 = Math.round(e.y0), e.x1 = Math.round(e.x1), e.y1 = Math.round(e.y1)
     }
 
-    function pd(e, t, n, i, r) {
-        for (var a = e.children, s, o = -1, l = a.length, u = e.value && (i - t) / e.value; ++o < l;) s = a[o], s.y0 = n, s.y1 = r, s.x0 = t, s.x1 = t += s.value * u
+    function id(e, t, n, i, r) {
+        for (var s = e.children, a, o = -1, l = s.length, u = e.value && (i - t) / e.value; ++o < l;) a = s[o], a.y0 = n, a.y1 = r, a.x0 = t, a.x1 = t += a.value * u
     }
 
-    function LW() {
+    function WW() {
         var e = 1,
             t = 1,
             n = 0,
             i = !1;
 
-        function r(s) {
-            var o = s.height + 1;
-            return s.x0 = s.y0 = n, s.x1 = e, s.y1 = t / o, s.eachBefore(a(t, o)), i && s.eachBefore(RD), s
+        function r(a) {
+            var o = a.height + 1;
+            return a.x0 = a.y0 = n, a.x1 = e, a.y1 = t / o, a.eachBefore(s(t, o)), i && a.eachBefore(qF), a
         }
 
-        function a(s, o) {
+        function s(a, o) {
             return function(l) {
-                l.children && pd(l, l.x0, s * (l.depth + 1) / o, l.x1, s * (l.depth + 2) / o);
+                l.children && id(l, l.x0, a * (l.depth + 1) / o, l.x1, a * (l.depth + 2) / o);
                 var u = l.x0,
                     c = l.y0,
                     f = l.x1 - n,
                     h = l.y1 - n;
                 f < u && (u = f = (u + f) / 2), h < c && (c = h = (c + h) / 2), l.x0 = u, l.y0 = c, l.x1 = f, l.y1 = h
             }
         }
-        return r.round = function(s) {
-            return arguments.length ? (i = !!s, r) : i
-        }, r.size = function(s) {
-            return arguments.length ? (e = +s[0], t = +s[1], r) : [e, t]
-        }, r.padding = function(s) {
-            return arguments.length ? (n = +s, r) : n
+        return r.round = function(a) {
+            return arguments.length ? (i = !!a, r) : i
+        }, r.size = function(a) {
+            return arguments.length ? (e = +a[0], t = +a[1], r) : [e, t]
+        }, r.padding = function(a) {
+            return arguments.length ? (n = +a, r) : n
         }, r
     }
-    var IW = {
+    var qW = {
             depth: -1
         },
-        _A = {},
-        rv = {};
+        NA = {},
+        Py = {};
 
-    function jW(e) {
+    function HW(e) {
         return e.id
     }
 
-    function zW(e) {
+    function YW(e) {
         return e.parentId
     }
 
-    function wA() {
-        var e = jW,
-            t = zW,
+    function PA() {
+        var e = HW,
+            t = YW,
             n;
 
         function i(r) {
-            var a = Array.from(r),
-                s = e,
+            var s = Array.from(r),
+                a = e,
                 o = t,
                 l, u, c, f, h, d, g, p, m = new Map;
             if (n != null) {
-                const y = a.map((x, _) => BW(n(x, _, r))),
-                    v = y.map(SA),
+                const y = s.map((x, _) => XW(n(x, _, r))),
+                    v = y.map(LA),
                     b = new Set(y).add("");
-                for (const x of v) b.has(x) || (b.add(x), y.push(x), v.push(SA(x)), a.push(rv));
-                s = (x, _) => y[_], o = (x, _) => v[_]
+                for (const x of v) b.has(x) || (b.add(x), y.push(x), v.push(LA(x)), s.push(Py));
+                a = (x, _) => y[_], o = (x, _) => v[_]
             }
-            for (c = 0, l = a.length; c < l; ++c) u = a[c], d = a[c] = new Yu(u), (g = s(u, c, r)) != null && (g += "") && (p = d.id = g, m.set(p, m.has(p) ? _A : d)), (g = o(u, c, r)) != null && (g += "") && (d.parent = g);
+            for (c = 0, l = s.length; c < l; ++c) u = s[c], d = s[c] = new Pu(u), (g = a(u, c, r)) != null && (g += "") && (p = d.id = g, m.set(p, m.has(p) ? NA : d)), (g = o(u, c, r)) != null && (g += "") && (d.parent = g);
             for (c = 0; c < l; ++c)
-                if (d = a[c], g = d.parent) {
+                if (d = s[c], g = d.parent) {
                     if (h = m.get(g), !h) throw new Error("missing: " + g);
-                    if (h === _A) throw new Error("ambiguous: " + g);
+                    if (h === NA) throw new Error("ambiguous: " + g);
                     h.children ? h.children.push(d) : h.children = [d], d.parent = h
                 } else {
                     if (f) throw new Error("multiple roots");
                     f = d
                 } if (!f) throw new Error("no root");
             if (n != null) {
-                for (; f.data === rv && f.children.length === 1;) f = f.children[0], --l;
-                for (let y = a.length - 1; y >= 0 && (d = a[y], d.data === rv); --y) d.data = null
+                for (; f.data === Py && f.children.length === 1;) f = f.children[0], --l;
+                for (let y = s.length - 1; y >= 0 && (d = s[y], d.data === Py); --y) d.data = null
             }
-            if (f.parent = IW, f.eachBefore(function(y) {
+            if (f.parent = qW, f.eachBefore(function(y) {
                     y.depth = y.parent.depth + 1, --l
-                }).eachBefore($D), f.parent = null, l > 0) throw new Error("cycle");
+                }).eachBefore(jF), f.parent = null, l > 0) throw new Error("cycle");
             return f
         }
         return i.id = function(r) {
-            return arguments.length ? (e = fp(r), i) : e
+            return arguments.length ? (e = Yg(r), i) : e
         }, i.parentId = function(r) {
-            return arguments.length ? (t = fp(r), i) : t
+            return arguments.length ? (t = Yg(r), i) : t
         }, i.path = function(r) {
-            return arguments.length ? (n = fp(r), i) : n
+            return arguments.length ? (n = Yg(r), i) : n
         }, i
     }
 
-    function BW(e) {
+    function XW(e) {
         e = `${e}`;
         let t = e.length;
-        return l2(e, t - 1) && !l2(e, t - 2) && (e = e.slice(0, -1)), e[0] === "/" ? e : `/${e}`
+        return Pb(e, t - 1) && !Pb(e, t - 2) && (e = e.slice(0, -1)), e[0] === "/" ? e : `/${e}`
     }
 
-    function SA(e) {
+    function LA(e) {
         let t = e.length;
         if (t < 2) return "";
-        for (; --t > 1 && !l2(e, t););
+        for (; --t > 1 && !Pb(e, t););
         return e.slice(0, t)
     }
 
-    function l2(e, t) {
+    function Pb(e, t) {
         if (e[t] === "/") {
             let n = 0;
             for (; t > 0 && e[--t] === "\\";) ++n;
             if (!(n & 1)) return !0
         }
         return !1
     }
 
-    function GW(e, t) {
+    function VW(e, t) {
         return e.parent === t.parent ? 1 : 2
     }
 
-    function av(e) {
+    function Ly(e) {
         var t = e.children;
         return t ? t[0] : e.t
     }
 
-    function sv(e) {
+    function Iy(e) {
         var t = e.children;
         return t ? t[t.length - 1] : e.t
     }
 
-    function UW(e, t, n) {
+    function KW(e, t, n) {
         var i = n / (t.i - e.i);
         t.c -= i, t.s += n, e.c += i, t.z += n, t.m += n
     }
 
-    function qW(e) {
-        for (var t = 0, n = 0, i = e.children, r = i.length, a; --r >= 0;) a = i[r], a.z += t, a.m += t, t += a.s + (n += a.c)
+    function JW(e) {
+        for (var t = 0, n = 0, i = e.children, r = i.length, s; --r >= 0;) s = i[r], s.z += t, s.m += t, t += s.s + (n += s.c)
     }
 
-    function WW(e, t, n) {
+    function QW(e, t, n) {
         return e.a.parent === t.parent ? e.a : n
     }
 
-    function hp(e, t) {
+    function Xg(e, t) {
         this._ = e, this.parent = null, this.children = null, this.A = null, this.a = this, this.z = 0, this.m = 0, this.c = 0, this.s = 0, this.t = null, this.i = t
     }
-    hp.prototype = Object.create(Yu.prototype);
+    Xg.prototype = Object.create(Pu.prototype);
 
-    function HW(e) {
-        for (var t = new hp(e, 0), n, i = [t], r, a, s, o; n = i.pop();)
-            if (a = n._.children)
-                for (n.children = new Array(o = a.length), s = o - 1; s >= 0; --s) i.push(r = n.children[s] = new hp(a[s], s)), r.parent = n;
-        return (t.parent = new hp(null, 0)).children = [t], t
+    function ZW(e) {
+        for (var t = new Xg(e, 0), n, i = [t], r, s, a, o; n = i.pop();)
+            if (s = n._.children)
+                for (n.children = new Array(o = s.length), a = o - 1; a >= 0; --a) i.push(r = n.children[a] = new Xg(s[a], a)), r.parent = n;
+        return (t.parent = new Xg(null, 0)).children = [t], t
     }
 
-    function YW() {
-        var e = GW,
+    function eq() {
+        var e = VW,
             t = 1,
             n = 1,
             i = null;
 
         function r(u) {
-            var c = HW(u);
-            if (c.eachAfter(a), c.parent.m = -c.z, c.eachBefore(s), i) u.eachBefore(l);
+            var c = ZW(u);
+            if (c.eachAfter(s), c.parent.m = -c.z, c.eachBefore(a), i) u.eachBefore(l);
             else {
                 var f = u,
                     h = u,
                     d = u;
                 u.eachBefore(function(v) {
                     v.x < f.x && (f = v), v.x > h.x && (h = v), v.depth > d.depth && (d = v)
                 });
@@ -13138,34 +13138,34 @@
                 u.eachBefore(function(v) {
                     v.x = (v.x + p) * m, v.y = v.depth * y
                 })
             }
             return u
         }
 
-        function a(u) {
+        function s(u) {
             var c = u.children,
                 f = u.parent.children,
                 h = u.i ? f[u.i - 1] : null;
             if (c) {
-                qW(u);
+                JW(u);
                 var d = (c[0].z + c[c.length - 1].z) / 2;
                 h ? (u.z = h.z + e(u._, h._), u.m = u.z - d) : u.z = d
             } else h && (u.z = h.z + e(u._, h._));
             u.parent.A = o(u, h, u.parent.A || f[0])
         }
 
-        function s(u) {
+        function a(u) {
             u._.x = u.z + u.parent.m, u.m += u.parent.m
         }
 
         function o(u, c, f) {
             if (c) {
-                for (var h = u, d = u, g = c, p = h.parent.children[0], m = h.m, y = d.m, v = g.m, b = p.m, x; g = sv(g), h = av(h), g && h;) p = av(p), d = sv(d), d.a = u, x = g.z + v - h.z - m + e(g._, h._), x > 0 && (UW(WW(g, u, f), u, x), m += x, y += x), v += g.m, m += h.m, b += p.m, y += d.m;
-                g && !sv(d) && (d.t = g, d.m += v - y), h && !av(p) && (p.t = h, p.m += m - b, f = u)
+                for (var h = u, d = u, g = c, p = h.parent.children[0], m = h.m, y = d.m, v = g.m, b = p.m, x; g = Iy(g), h = Ly(h), g && h;) p = Ly(p), d = Iy(d), d.a = u, x = g.z + v - h.z - m + e(g._, h._), x > 0 && (KW(QW(g, u, f), u, x), m += x, y += x), v += g.m, m += h.m, b += p.m, y += d.m;
+                g && !Iy(d) && (d.t = g, d.m += v - y), h && !Ly(p) && (p.t = h, p.m += m - b, f = u)
             }
             return f
         }
 
         function l(u) {
             u.x *= t, u.y = u.depth * n
         }
@@ -13174,423 +13174,423 @@
         }, r.size = function(u) {
             return arguments.length ? (i = !1, t = +u[0], n = +u[1], r) : i ? null : [t, n]
         }, r.nodeSize = function(u) {
             return arguments.length ? (i = !0, t = +u[0], n = +u[1], r) : i ? [t, n] : null
         }, r
     }
 
-    function Fm(e, t, n, i, r) {
-        for (var a = e.children, s, o = -1, l = a.length, u = e.value && (r - n) / e.value; ++o < l;) s = a[o], s.x0 = t, s.x1 = i, s.y0 = n, s.y1 = n += s.value * u
+    function hm(e, t, n, i, r) {
+        for (var s = e.children, a, o = -1, l = s.length, u = e.value && (r - n) / e.value; ++o < l;) a = s[o], a.x0 = t, a.x1 = i, a.y0 = n, a.y1 = n += a.value * u
     }
-    var PD = (1 + Math.sqrt(5)) / 2;
+    var HF = (1 + Math.sqrt(5)) / 2;
 
-    function ND(e, t, n, i, r, a) {
-        for (var s = [], o = t.children, l, u, c = 0, f = 0, h = o.length, d, g, p = t.value, m, y, v, b, x, _, S; c < h;) {
-            d = r - n, g = a - i;
+    function YF(e, t, n, i, r, s) {
+        for (var a = [], o = t.children, l, u, c = 0, f = 0, h = o.length, d, g, p = t.value, m, y, v, b, x, _, S; c < h;) {
+            d = r - n, g = s - i;
             do m = o[f++].value; while (!m && f < h);
             for (y = v = m, _ = Math.max(g / d, d / g) / (p * e), S = m * m * _, x = Math.max(v / S, S / y); f < h; ++f) {
                 if (m += u = o[f].value, u < y && (y = u), u > v && (v = u), S = m * m * _, b = Math.max(v / S, S / y), b > x) {
                     m -= u;
                     break
                 }
                 x = b
             }
-            s.push(l = {
+            a.push(l = {
                 value: m,
                 dice: d < g,
                 children: o.slice(c, f)
-            }), l.dice ? pd(l, n, i, r, p ? i += g * m / p : a) : Fm(l, n, i, p ? n += d * m / p : r, a), p -= m, c = f
+            }), l.dice ? id(l, n, i, r, p ? i += g * m / p : s) : hm(l, n, i, p ? n += d * m / p : r, s), p -= m, c = f
         }
-        return s
+        return a
     }
-    const LD = function e(t) {
-        function n(i, r, a, s, o) {
-            ND(t, i, r, a, s, o)
+    const XF = function e(t) {
+        function n(i, r, s, a, o) {
+            YF(t, i, r, s, a, o)
         }
         return n.ratio = function(i) {
             return e((i = +i) > 1 ? i : 1)
         }, n
-    }(PD);
+    }(HF);
 
-    function XW() {
-        var e = LD,
+    function tq() {
+        var e = XF,
             t = !1,
             n = 1,
             i = 1,
             r = [0],
-            a = jo,
-            s = jo,
-            o = jo,
-            l = jo,
-            u = jo;
+            s = Ao,
+            a = Ao,
+            o = Ao,
+            l = Ao,
+            u = Ao;
 
         function c(h) {
-            return h.x0 = h.y0 = 0, h.x1 = n, h.y1 = i, h.eachBefore(f), r = [0], t && h.eachBefore(RD), h
+            return h.x0 = h.y0 = 0, h.x1 = n, h.y1 = i, h.eachBefore(f), r = [0], t && h.eachBefore(qF), h
         }
 
         function f(h) {
             var d = r[h.depth],
                 g = h.x0 + d,
                 p = h.y0 + d,
                 m = h.x1 - d,
                 y = h.y1 - d;
-            m < g && (g = m = (g + m) / 2), y < p && (p = y = (p + y) / 2), h.x0 = g, h.y0 = p, h.x1 = m, h.y1 = y, h.children && (d = r[h.depth + 1] = a(h) / 2, g += u(h) - d, p += s(h) - d, m -= o(h) - d, y -= l(h) - d, m < g && (g = m = (g + m) / 2), y < p && (p = y = (p + y) / 2), e(h, g, p, m, y))
+            m < g && (g = m = (g + m) / 2), y < p && (p = y = (p + y) / 2), h.x0 = g, h.y0 = p, h.x1 = m, h.y1 = y, h.children && (d = r[h.depth + 1] = s(h) / 2, g += u(h) - d, p += a(h) - d, m -= o(h) - d, y -= l(h) - d, m < g && (g = m = (g + m) / 2), y < p && (p = y = (p + y) / 2), e(h, g, p, m, y))
         }
         return c.round = function(h) {
             return arguments.length ? (t = !!h, c) : t
         }, c.size = function(h) {
             return arguments.length ? (n = +h[0], i = +h[1], c) : [n, i]
         }, c.tile = function(h) {
-            return arguments.length ? (e = MD(h), c) : e
+            return arguments.length ? (e = UF(h), c) : e
         }, c.padding = function(h) {
             return arguments.length ? c.paddingInner(h).paddingOuter(h) : c.paddingInner()
         }, c.paddingInner = function(h) {
-            return arguments.length ? (a = typeof h == "function" ? h : yu(+h), c) : a
+            return arguments.length ? (s = typeof h == "function" ? h : au(+h), c) : s
         }, c.paddingOuter = function(h) {
             return arguments.length ? c.paddingTop(h).paddingRight(h).paddingBottom(h).paddingLeft(h) : c.paddingTop()
         }, c.paddingTop = function(h) {
-            return arguments.length ? (s = typeof h == "function" ? h : yu(+h), c) : s
+            return arguments.length ? (a = typeof h == "function" ? h : au(+h), c) : a
         }, c.paddingRight = function(h) {
-            return arguments.length ? (o = typeof h == "function" ? h : yu(+h), c) : o
+            return arguments.length ? (o = typeof h == "function" ? h : au(+h), c) : o
         }, c.paddingBottom = function(h) {
-            return arguments.length ? (l = typeof h == "function" ? h : yu(+h), c) : l
+            return arguments.length ? (l = typeof h == "function" ? h : au(+h), c) : l
         }, c.paddingLeft = function(h) {
-            return arguments.length ? (u = typeof h == "function" ? h : yu(+h), c) : u
+            return arguments.length ? (u = typeof h == "function" ? h : au(+h), c) : u
         }, c
     }
 
-    function VW(e, t, n, i, r) {
-        var a = e.children,
-            s, o = a.length,
+    function nq(e, t, n, i, r) {
+        var s = e.children,
+            a, o = s.length,
             l, u = new Array(o + 1);
-        for (u[0] = l = s = 0; s < o; ++s) u[s + 1] = l += a[s].value;
+        for (u[0] = l = a = 0; a < o; ++a) u[a + 1] = l += s[a].value;
         c(0, o, e.value, t, n, i, r);
 
         function c(f, h, d, g, p, m, y) {
             if (f >= h - 1) {
-                var v = a[f];
+                var v = s[f];
                 v.x0 = g, v.y0 = p, v.x1 = m, v.y1 = y;
                 return
             }
             for (var b = u[f], x = d / 2 + b, _ = f + 1, S = h - 1; _ < S;) {
                 var w = _ + S >>> 1;
                 u[w] < x ? _ = w + 1 : S = w
             }
             x - u[_ - 1] < u[_] - x && f + 1 < _ && --_;
-            var O = u[_] - b,
-                k = d - O;
+            var E = u[_] - b,
+                A = d - E;
             if (m - g > y - p) {
-                var C = d ? (g * k + m * O) / d : m;
-                c(f, _, O, g, p, C, y), c(_, h, k, C, p, m, y)
+                var C = d ? (g * A + m * E) / d : m;
+                c(f, _, E, g, p, C, y), c(_, h, A, C, p, m, y)
             } else {
-                var E = d ? (p * k + y * O) / d : y;
-                c(f, _, O, g, p, m, E), c(_, h, k, g, E, m, y)
+                var k = d ? (p * A + y * E) / d : y;
+                c(f, _, E, g, p, m, k), c(_, h, A, g, k, m, y)
             }
         }
     }
 
-    function KW(e, t, n, i, r) {
-        (e.depth & 1 ? Fm : pd)(e, t, n, i, r)
+    function iq(e, t, n, i, r) {
+        (e.depth & 1 ? hm : id)(e, t, n, i, r)
     }
-    const JW = function e(t) {
-        function n(i, r, a, s, o) {
+    const rq = function e(t) {
+        function n(i, r, s, a, o) {
             if ((l = i._squarify) && l.ratio === t)
                 for (var l, u, c, f, h = -1, d, g = l.length, p = i.value; ++h < g;) {
                     for (u = l[h], c = u.children, f = u.value = 0, d = c.length; f < d; ++f) u.value += c[f].value;
-                    u.dice ? pd(u, r, a, s, p ? a += (o - a) * u.value / p : o) : Fm(u, r, a, p ? r += (s - r) * u.value / p : s, o), p -= u.value
-                } else i._squarify = l = ND(t, i, r, a, s, o), l.ratio = t
+                    u.dice ? id(u, r, s, a, p ? s += (o - s) * u.value / p : o) : hm(u, r, s, p ? r += (a - r) * u.value / p : a, o), p -= u.value
+                } else i._squarify = l = YF(t, i, r, s, a, o), l.ratio = t
         }
         return n.ratio = function(i) {
             return e((i = +i) > 1 ? i : 1)
         }, n
-    }(PD);
+    }(HF);
 
-    function ua(e, t) {
+    function ts(e, t) {
         switch (arguments.length) {
             case 0:
                 break;
             case 1:
                 this.range(e);
                 break;
             default:
                 this.range(t).domain(e);
                 break
         }
         return this
     }
 
-    function lo(e, t) {
+    function Ja(e, t) {
         switch (arguments.length) {
             case 0:
                 break;
             case 1: {
                 typeof e == "function" ? this.interpolator(e) : this.range(e);
                 break
             }
             default: {
                 this.domain(e), typeof t == "function" ? this.interpolator(t) : this.range(t);
                 break
             }
         }
         return this
     }
-    const u2 = Symbol("implicit");
+    const Lb = Symbol("implicit");
 
-    function Dm() {
-        var e = new Sk,
+    function dm() {
+        var e = new Lk,
             t = [],
             n = [],
-            i = u2;
+            i = Lb;
 
-        function r(a) {
-            let s = e.get(a);
-            if (s === void 0) {
-                if (i !== u2) return i;
-                e.set(a, s = t.push(a) - 1)
+        function r(s) {
+            let a = e.get(s);
+            if (a === void 0) {
+                if (i !== Lb) return i;
+                e.set(s, a = t.push(s) - 1)
             }
-            return n[s % n.length]
+            return n[a % n.length]
         }
-        return r.domain = function(a) {
+        return r.domain = function(s) {
             if (!arguments.length) return t.slice();
-            t = [], e = new Sk;
-            for (const s of a) e.has(s) || e.set(s, t.push(s) - 1);
+            t = [], e = new Lk;
+            for (const a of s) e.has(a) || e.set(a, t.push(a) - 1);
             return r
-        }, r.range = function(a) {
-            return arguments.length ? (n = Array.from(a), r) : n.slice()
-        }, r.unknown = function(a) {
-            return arguments.length ? (i = a, r) : i
+        }, r.range = function(s) {
+            return arguments.length ? (n = Array.from(s), r) : n.slice()
+        }, r.unknown = function(s) {
+            return arguments.length ? (i = s, r) : i
         }, r.copy = function() {
-            return Dm(t, n).unknown(i)
-        }, ua.apply(r, arguments), r
+            return dm(t, n).unknown(i)
+        }, ts.apply(r, arguments), r
     }
 
-    function QW(e) {
+    function sq(e) {
         return function() {
             return e
         }
     }
 
-    function c2(e) {
+    function Ib(e) {
         return +e
     }
-    var EA = [0, 1];
+    var IA = [0, 1];
 
-    function Jn(e) {
+    function Vn(e) {
         return e
     }
 
-    function f2(e, t) {
+    function zb(e, t) {
         return (t -= e = +e) ? function(n) {
             return (n - e) / t
-        } : QW(isNaN(t) ? NaN : .5)
+        } : sq(isNaN(t) ? NaN : .5)
     }
 
-    function ZW(e, t) {
+    function aq(e, t) {
         var n;
         return e > t && (n = e, e = t, t = n),
             function(i) {
                 return Math.max(e, Math.min(t, i))
             }
     }
 
-    function eH(e, t, n) {
+    function oq(e, t, n) {
         var i = e[0],
             r = e[1],
-            a = t[0],
-            s = t[1];
-        return r < i ? (i = f2(r, i), a = n(s, a)) : (i = f2(i, r), a = n(a, s)),
+            s = t[0],
+            a = t[1];
+        return r < i ? (i = zb(r, i), s = n(a, s)) : (i = zb(i, r), s = n(s, a)),
             function(o) {
-                return a(i(o))
+                return s(i(o))
             }
     }
 
-    function tH(e, t, n) {
+    function lq(e, t, n) {
         var i = Math.min(e.length, t.length) - 1,
             r = new Array(i),
-            a = new Array(i),
-            s = -1;
-        for (e[i] < e[0] && (e = e.slice().reverse(), t = t.slice().reverse()); ++s < i;) r[s] = f2(e[s], e[s + 1]), a[s] = n(t[s], t[s + 1]);
+            s = new Array(i),
+            a = -1;
+        for (e[i] < e[0] && (e = e.slice().reverse(), t = t.slice().reverse()); ++a < i;) r[a] = zb(e[a], e[a + 1]), s[a] = n(t[a], t[a + 1]);
         return function(o) {
-            var l = fd(e, o, 1, i) - 1;
-            return a[l](r[l](o))
+            var l = Zh(e, o, 1, i) - 1;
+            return s[l](r[l](o))
         }
     }
 
-    function md(e, t) {
+    function rd(e, t) {
         return t.domain(e.domain()).range(e.range()).interpolate(e.interpolate()).clamp(e.clamp()).unknown(e.unknown())
     }
 
-    function Rm() {
-        var e = EA,
-            t = EA,
-            n = oo,
-            i, r, a, s = Jn,
+    function gm() {
+        var e = IA,
+            t = IA,
+            n = Ka,
+            i, r, s, a = Vn,
             o, l, u;
 
         function c() {
             var h = Math.min(e.length, t.length);
-            return s !== Jn && (s = ZW(e[0], e[h - 1])), o = h > 2 ? tH : eH, l = u = null, f
+            return a !== Vn && (a = aq(e[0], e[h - 1])), o = h > 2 ? lq : oq, l = u = null, f
         }
 
         function f(h) {
-            return h == null || isNaN(h = +h) ? a : (l || (l = o(e.map(i), t, n)))(i(s(h)))
+            return h == null || isNaN(h = +h) ? s : (l || (l = o(e.map(i), t, n)))(i(a(h)))
         }
         return f.invert = function(h) {
-                return s(r((u || (u = o(t, e.map(i), tr)))(h)))
+                return a(r((u || (u = o(t, e.map(i), Xi)))(h)))
             }, f.domain = function(h) {
-                return arguments.length ? (e = Array.from(h, c2), c()) : e.slice()
+                return arguments.length ? (e = Array.from(h, Ib), c()) : e.slice()
             }, f.range = function(h) {
                 return arguments.length ? (t = Array.from(h), c()) : t.slice()
             }, f.rangeRound = function(h) {
-                return t = Array.from(h), n = ud, c()
+                return t = Array.from(h), n = Jh, c()
             }, f.clamp = function(h) {
-                return arguments.length ? (s = h ? !0 : Jn, c()) : s !== Jn
+                return arguments.length ? (a = h ? !0 : Vn, c()) : a !== Vn
             }, f.interpolate = function(h) {
                 return arguments.length ? (n = h, c()) : n
             }, f.unknown = function(h) {
-                return arguments.length ? (a = h, f) : a
+                return arguments.length ? (s = h, f) : s
             },
             function(h, d) {
                 return i = h, r = d, c()
             }
     }
 
-    function ID() {
-        return Rm()(Jn, Jn)
+    function VF() {
+        return gm()(Vn, Vn)
     }
 
-    function jD(e, t, n, i) {
-        var r = Bs(e, t, n),
-            a;
-        switch (i = cl(i ?? ",f"), i.type) {
+    function KF(e, t, n, i) {
+        var r = Oa(e, t, n),
+            s;
+        switch (i = Qo(i ?? ",f"), i.type) {
             case "s": {
-                var s = Math.max(Math.abs(e), Math.abs(t));
-                return i.precision == null && !isNaN(a = BF(r, s)) && (i.precision = a), d_(i, s)
+                var a = Math.max(Math.abs(e), Math.abs(t));
+                return i.precision == null && !isNaN(s = QO(r, a)) && (i.precision = s), Fx(i, a)
             }
             case "":
             case "e":
             case "g":
             case "p":
             case "r": {
-                i.precision == null && !isNaN(a = GF(r, Math.max(Math.abs(e), Math.abs(t)))) && (i.precision = a - (i.type === "e"));
+                i.precision == null && !isNaN(s = ZO(r, Math.max(Math.abs(e), Math.abs(t)))) && (i.precision = s - (i.type === "e"));
                 break
             }
             case "f":
             case "%": {
-                i.precision == null && !isNaN(a = zF(r)) && (i.precision = a - (i.type === "%") * 2);
+                i.precision == null && !isNaN(s = JO(r)) && (i.precision = s - (i.type === "%") * 2);
                 break
             }
         }
-        return Am(i)
+        return lm(i)
     }
 
-    function Nl(e) {
+    function Cl(e) {
         var t = e.domain;
         return e.ticks = function(n) {
             var i = t();
-            return Rb(i[0], i[i.length - 1], n ?? 10)
+            return lb(i[0], i[i.length - 1], n ?? 10)
         }, e.tickFormat = function(n, i) {
             var r = t();
-            return jD(r[0], r[r.length - 1], n ?? 10, i)
+            return KF(r[0], r[r.length - 1], n ?? 10, i)
         }, e.nice = function(n) {
             n == null && (n = 10);
             var i = t(),
                 r = 0,
-                a = i.length - 1,
-                s = i[r],
-                o = i[a],
+                s = i.length - 1,
+                a = i[r],
+                o = i[s],
                 l, u, c = 10;
-            for (o < s && (u = s, s = o, o = u, u = r, r = a, a = u); c-- > 0;) {
-                if (u = Pb(s, o, n), u === l) return i[r] = s, i[a] = o, t(i);
-                if (u > 0) s = Math.floor(s / u) * u, o = Math.ceil(o / u) * u;
-                else if (u < 0) s = Math.ceil(s * u) / u, o = Math.floor(o * u) / u;
+            for (o < a && (u = a, a = o, o = u, u = r, r = s, s = u); c-- > 0;) {
+                if (u = ub(a, o, n), u === l) return i[r] = a, i[s] = o, t(i);
+                if (u > 0) a = Math.floor(a / u) * u, o = Math.ceil(o / u) * u;
+                else if (u < 0) a = Math.ceil(a * u) / u, o = Math.floor(o * u) / u;
                 else break;
                 l = u
             }
             return e
         }, e
     }
 
-    function zD() {
-        var e = ID();
+    function JF() {
+        var e = VF();
         return e.copy = function() {
-            return md(e, zD())
-        }, ua.apply(e, arguments), Nl(e)
+            return rd(e, JF())
+        }, ts.apply(e, arguments), Cl(e)
     }
 
-    function BD(e) {
+    function QF(e) {
         var t;
 
         function n(i) {
             return i == null || isNaN(i = +i) ? t : i
         }
         return n.invert = n, n.domain = n.range = function(i) {
-            return arguments.length ? (e = Array.from(i, c2), n) : e.slice()
+            return arguments.length ? (e = Array.from(i, Ib), n) : e.slice()
         }, n.unknown = function(i) {
             return arguments.length ? (t = i, n) : t
         }, n.copy = function() {
-            return BD(e).unknown(t)
-        }, e = arguments.length ? Array.from(e, c2) : [0, 1], Nl(n)
+            return QF(e).unknown(t)
+        }, e = arguments.length ? Array.from(e, Ib) : [0, 1], Cl(n)
     }
 
-    function GD(e, t) {
+    function ZF(e, t) {
         e = e.slice();
         var n = 0,
             i = e.length - 1,
             r = e[n],
-            a = e[i],
-            s;
-        return a < r && (s = n, n = i, i = s, s = r, r = a, a = s), e[n] = t.floor(r), e[i] = t.ceil(a), e
+            s = e[i],
+            a;
+        return s < r && (a = n, n = i, i = a, a = r, r = s, s = a), e[n] = t.floor(r), e[i] = t.ceil(s), e
     }
 
-    function OA(e) {
+    function zA(e) {
         return Math.log(e)
     }
 
-    function CA(e) {
+    function BA(e) {
         return Math.exp(e)
     }
 
-    function nH(e) {
+    function uq(e) {
         return -Math.log(-e)
     }
 
-    function iH(e) {
+    function cq(e) {
         return -Math.exp(-e)
     }
 
-    function rH(e) {
+    function fq(e) {
         return isFinite(e) ? +("1e" + e) : e < 0 ? 0 : e
     }
 
-    function aH(e) {
-        return e === 10 ? rH : e === Math.E ? Math.exp : t => Math.pow(e, t)
+    function hq(e) {
+        return e === 10 ? fq : e === Math.E ? Math.exp : t => Math.pow(e, t)
     }
 
-    function sH(e) {
+    function dq(e) {
         return e === Math.E ? Math.log : e === 10 && Math.log10 || e === 2 && Math.log2 || (e = Math.log(e), t => Math.log(t) / e)
     }
 
-    function kA(e) {
+    function jA(e) {
         return (t, n) => -e(-t, n)
     }
 
-    function w_(e) {
-        const t = e(OA, CA),
+    function jx(e) {
+        const t = e(zA, BA),
             n = t.domain;
         let i = 10,
-            r, a;
+            r, s;
 
-        function s() {
-            return r = sH(i), a = aH(i), n()[0] < 0 ? (r = kA(r), a = kA(a), e(nH, iH)) : e(OA, CA), t
+        function a() {
+            return r = dq(i), s = hq(i), n()[0] < 0 ? (r = jA(r), s = jA(s), e(uq, cq)) : e(zA, BA), t
         }
         return t.base = function(o) {
-            return arguments.length ? (i = +o, s()) : i
+            return arguments.length ? (i = +o, a()) : i
         }, t.domain = function(o) {
-            return arguments.length ? (n(o), s()) : n()
+            return arguments.length ? (n(o), a()) : n()
         }, t.ticks = o => {
             const l = n();
             let u = l[0],
                 c = l[l.length - 1];
             const f = c < u;
             f && ([u, c] = [c, u]);
             let h = r(u),
@@ -13598,1412 +13598,1412 @@
                 g, p;
             const m = o == null ? 10 : +o;
             let y = [];
             if (!(i % 1) && d - h < m) {
                 if (h = Math.floor(h), d = Math.ceil(d), u > 0) {
                     for (; h <= d; ++h)
                         for (g = 1; g < i; ++g)
-                            if (p = h < 0 ? g / a(-h) : g * a(h), !(p < u)) {
+                            if (p = h < 0 ? g / s(-h) : g * s(h), !(p < u)) {
                                 if (p > c) break;
                                 y.push(p)
                             }
                 } else
                     for (; h <= d; ++h)
                         for (g = i - 1; g >= 1; --g)
-                            if (p = h > 0 ? g / a(-h) : g * a(h), !(p < u)) {
+                            if (p = h > 0 ? g / s(-h) : g * s(h), !(p < u)) {
                                 if (p > c) break;
                                 y.push(p)
-                            } y.length * 2 < m && (y = Rb(u, c, m))
-            } else y = Rb(h, d, Math.min(d - h, m)).map(a);
+                            } y.length * 2 < m && (y = lb(u, c, m))
+            } else y = lb(h, d, Math.min(d - h, m)).map(s);
             return f ? y.reverse() : y
         }, t.tickFormat = (o, l) => {
-            if (o == null && (o = 10), l == null && (l = i === 10 ? "s" : ","), typeof l != "function" && (!(i % 1) && (l = cl(l)).precision == null && (l.trim = !0), l = Am(l)), o === 1 / 0) return l;
+            if (o == null && (o = 10), l == null && (l = i === 10 ? "s" : ","), typeof l != "function" && (!(i % 1) && (l = Qo(l)).precision == null && (l.trim = !0), l = lm(l)), o === 1 / 0) return l;
             const u = Math.max(1, i * o / t.ticks().length);
             return c => {
-                let f = c / a(Math.round(r(c)));
+                let f = c / s(Math.round(r(c)));
                 return f * i < i - .5 && (f *= i), f <= u ? l(c) : ""
             }
-        }, t.nice = () => n(GD(n(), {
-            floor: o => a(Math.floor(r(o))),
-            ceil: o => a(Math.ceil(r(o)))
+        }, t.nice = () => n(ZF(n(), {
+            floor: o => s(Math.floor(r(o))),
+            ceil: o => s(Math.ceil(r(o)))
         })), t
     }
 
-    function UD() {
-        const e = w_(Rm()).domain([1, 10]);
-        return e.copy = () => md(e, UD()).base(e.base()), ua.apply(e, arguments), e
+    function eR() {
+        const e = jx(gm()).domain([1, 10]);
+        return e.copy = () => rd(e, eR()).base(e.base()), ts.apply(e, arguments), e
     }
 
-    function AA(e) {
+    function UA(e) {
         return function(t) {
             return Math.sign(t) * Math.log1p(Math.abs(t / e))
         }
     }
 
-    function TA(e) {
+    function GA(e) {
         return function(t) {
             return Math.sign(t) * Math.expm1(Math.abs(t)) * e
         }
     }
 
-    function S_(e) {
+    function Ux(e) {
         var t = 1,
-            n = e(AA(t), TA(t));
+            n = e(UA(t), GA(t));
         return n.constant = function(i) {
-            return arguments.length ? e(AA(t = +i), TA(t)) : t
-        }, Nl(n)
+            return arguments.length ? e(UA(t = +i), GA(t)) : t
+        }, Cl(n)
     }
 
-    function qD() {
-        var e = S_(Rm());
+    function tR() {
+        var e = Ux(gm());
         return e.copy = function() {
-            return md(e, qD()).constant(e.constant())
-        }, ua.apply(e, arguments)
+            return rd(e, tR()).constant(e.constant())
+        }, ts.apply(e, arguments)
     }
 
-    function $A(e) {
+    function WA(e) {
         return function(t) {
             return t < 0 ? -Math.pow(-t, e) : Math.pow(t, e)
         }
     }
 
-    function oH(e) {
+    function gq(e) {
         return e < 0 ? -Math.sqrt(-e) : Math.sqrt(e)
     }
 
-    function lH(e) {
+    function pq(e) {
         return e < 0 ? -e * e : e * e
     }
 
-    function E_(e) {
-        var t = e(Jn, Jn),
+    function Gx(e) {
+        var t = e(Vn, Vn),
             n = 1;
 
         function i() {
-            return n === 1 ? e(Jn, Jn) : n === .5 ? e(oH, lH) : e($A(n), $A(1 / n))
+            return n === 1 ? e(Vn, Vn) : n === .5 ? e(gq, pq) : e(WA(n), WA(1 / n))
         }
         return t.exponent = function(r) {
             return arguments.length ? (n = +r, i()) : n
-        }, Nl(t)
+        }, Cl(t)
     }
 
-    function O_() {
-        var e = E_(Rm());
+    function Wx() {
+        var e = Gx(gm());
         return e.copy = function() {
-            return md(e, O_()).exponent(e.exponent())
-        }, ua.apply(e, arguments), e
+            return rd(e, Wx()).exponent(e.exponent())
+        }, ts.apply(e, arguments), e
     }
 
-    function uH() {
-        return O_.apply(null, arguments).exponent(.5)
+    function mq() {
+        return Wx.apply(null, arguments).exponent(.5)
     }
 
-    function WD() {
+    function nR() {
         var e = [],
             t = [],
             n = [],
             i;
 
         function r() {
-            var s = 0,
+            var a = 0,
                 o = Math.max(1, t.length);
-            for (n = new Array(o - 1); ++s < o;) n[s - 1] = kF(e, s / o);
-            return a
+            for (n = new Array(o - 1); ++a < o;) n[a - 1] = IO(e, a / o);
+            return s
         }
 
-        function a(s) {
-            return s == null || isNaN(s = +s) ? i : t[fd(n, s)]
+        function s(a) {
+            return a == null || isNaN(a = +a) ? i : t[Zh(n, a)]
         }
-        return a.invertExtent = function(s) {
-            var o = t.indexOf(s);
+        return s.invertExtent = function(a) {
+            var o = t.indexOf(a);
             return o < 0 ? [NaN, NaN] : [o > 0 ? n[o - 1] : e[0], o < n.length ? n[o] : e[e.length - 1]]
-        }, a.domain = function(s) {
+        }, s.domain = function(a) {
             if (!arguments.length) return e.slice();
             e = [];
-            for (let o of s) o != null && !isNaN(o = +o) && e.push(o);
-            return e.sort(ja), r()
-        }, a.range = function(s) {
-            return arguments.length ? (t = Array.from(s), r()) : t.slice()
-        }, a.unknown = function(s) {
-            return arguments.length ? (i = s, a) : i
-        }, a.quantiles = function() {
+            for (let o of a) o != null && !isNaN(o = +o) && e.push(o);
+            return e.sort(Ts), r()
+        }, s.range = function(a) {
+            return arguments.length ? (t = Array.from(a), r()) : t.slice()
+        }, s.unknown = function(a) {
+            return arguments.length ? (i = a, s) : i
+        }, s.quantiles = function() {
             return n.slice()
-        }, a.copy = function() {
-            return WD().domain(e).range(t).unknown(i)
-        }, ua.apply(a, arguments)
+        }, s.copy = function() {
+            return nR().domain(e).range(t).unknown(i)
+        }, ts.apply(s, arguments)
     }
 
-    function HD() {
+    function iR() {
         var e = 0,
             t = 1,
             n = 1,
             i = [.5],
             r = [0, 1],
-            a;
+            s;
 
-        function s(l) {
-            return l != null && l <= l ? r[fd(i, l, 0, n)] : a
+        function a(l) {
+            return l != null && l <= l ? r[Zh(i, l, 0, n)] : s
         }
 
         function o() {
             var l = -1;
             for (i = new Array(n); ++l < n;) i[l] = ((l + 1) * t - (l - n) * e) / (n + 1);
-            return s
+            return a
         }
-        return s.domain = function(l) {
+        return a.domain = function(l) {
             return arguments.length ? ([e, t] = l, e = +e, t = +t, o()) : [e, t]
-        }, s.range = function(l) {
+        }, a.range = function(l) {
             return arguments.length ? (n = (r = Array.from(l)).length - 1, o()) : r.slice()
-        }, s.invertExtent = function(l) {
+        }, a.invertExtent = function(l) {
             var u = r.indexOf(l);
             return u < 0 ? [NaN, NaN] : u < 1 ? [e, i[0]] : u >= n ? [i[n - 1], t] : [i[u - 1], i[u]]
-        }, s.unknown = function(l) {
-            return arguments.length && (a = l), s
-        }, s.thresholds = function() {
+        }, a.unknown = function(l) {
+            return arguments.length && (s = l), a
+        }, a.thresholds = function() {
             return i.slice()
-        }, s.copy = function() {
-            return HD().domain([e, t]).range(r).unknown(a)
-        }, ua.apply(Nl(s), arguments)
+        }, a.copy = function() {
+            return iR().domain([e, t]).range(r).unknown(s)
+        }, ts.apply(Cl(a), arguments)
     }
 
-    function YD() {
+    function rR() {
         var e = [.5],
             t = [0, 1],
             n, i = 1;
 
-        function r(a) {
-            return a != null && a <= a ? t[fd(e, a, 0, i)] : n
+        function r(s) {
+            return s != null && s <= s ? t[Zh(e, s, 0, i)] : n
         }
-        return r.domain = function(a) {
-            return arguments.length ? (e = Array.from(a), i = Math.min(e.length, t.length - 1), r) : e.slice()
-        }, r.range = function(a) {
-            return arguments.length ? (t = Array.from(a), i = Math.min(e.length, t.length - 1), r) : t.slice()
-        }, r.invertExtent = function(a) {
-            var s = t.indexOf(a);
-            return [e[s - 1], e[s]]
-        }, r.unknown = function(a) {
-            return arguments.length ? (n = a, r) : n
+        return r.domain = function(s) {
+            return arguments.length ? (e = Array.from(s), i = Math.min(e.length, t.length - 1), r) : e.slice()
+        }, r.range = function(s) {
+            return arguments.length ? (t = Array.from(s), i = Math.min(e.length, t.length - 1), r) : t.slice()
+        }, r.invertExtent = function(s) {
+            var a = t.indexOf(s);
+            return [e[a - 1], e[a]]
+        }, r.unknown = function(s) {
+            return arguments.length ? (n = s, r) : n
         }, r.copy = function() {
-            return YD().domain(e).range(t).unknown(n)
-        }, ua.apply(r, arguments)
+            return rR().domain(e).range(t).unknown(n)
+        }, ts.apply(r, arguments)
     }
-    const ov = new Date,
-        lv = new Date;
+    const zy = new Date,
+        By = new Date;
 
-    function It(e, t, n, i) {
-        function r(a) {
-            return e(a = arguments.length === 0 ? new Date : new Date(+a)), a
+    function Dt(e, t, n, i) {
+        function r(s) {
+            return e(s = arguments.length === 0 ? new Date : new Date(+s)), s
         }
-        return r.floor = a => (e(a = new Date(+a)), a), r.ceil = a => (e(a = new Date(a - 1)), t(a, 1), e(a), a), r.round = a => {
-            const s = r(a),
-                o = r.ceil(a);
-            return a - s < o - a ? s : o
-        }, r.offset = (a, s) => (t(a = new Date(+a), s == null ? 1 : Math.floor(s)), a), r.range = (a, s, o) => {
+        return r.floor = s => (e(s = new Date(+s)), s), r.ceil = s => (e(s = new Date(s - 1)), t(s, 1), e(s), s), r.round = s => {
+            const a = r(s),
+                o = r.ceil(s);
+            return s - a < o - s ? a : o
+        }, r.offset = (s, a) => (t(s = new Date(+s), a == null ? 1 : Math.floor(a)), s), r.range = (s, a, o) => {
             const l = [];
-            if (a = r.ceil(a), o = o == null ? 1 : Math.floor(o), !(a < s) || !(o > 0)) return l;
+            if (s = r.ceil(s), o = o == null ? 1 : Math.floor(o), !(s < a) || !(o > 0)) return l;
             let u;
-            do l.push(u = new Date(+a)), t(a, o), e(a); while (u < a && a < s);
+            do l.push(u = new Date(+s)), t(s, o), e(s); while (u < s && s < a);
             return l
-        }, r.filter = a => It(s => {
-            if (s >= s)
-                for (; e(s), !a(s);) s.setTime(s - 1)
-        }, (s, o) => {
-            if (s >= s)
+        }, r.filter = s => Dt(a => {
+            if (a >= a)
+                for (; e(a), !s(a);) a.setTime(a - 1)
+        }, (a, o) => {
+            if (a >= a)
                 if (o < 0)
                     for (; ++o <= 0;)
-                        for (; t(s, -1), !a(s););
+                        for (; t(a, -1), !s(a););
                 else
                     for (; --o >= 0;)
-                        for (; t(s, 1), !a(s););
-        }), n && (r.count = (a, s) => (ov.setTime(+a), lv.setTime(+s), e(ov), e(lv), Math.floor(n(ov, lv))), r.every = a => (a = Math.floor(a), !isFinite(a) || !(a > 0) ? null : a > 1 ? r.filter(i ? s => i(s) % a === 0 : s => r.count(0, s) % a === 0) : r)), r
+                        for (; t(a, 1), !s(a););
+        }), n && (r.count = (s, a) => (zy.setTime(+s), By.setTime(+a), e(zy), e(By), Math.floor(n(zy, By))), r.every = s => (s = Math.floor(s), !isFinite(s) || !(s > 0) ? null : s > 1 ? r.filter(i ? a => i(a) % s === 0 : a => r.count(0, a) % s === 0) : r)), r
     }
-    const Xu = It(() => {}, (e, t) => {
+    const Lu = Dt(() => {}, (e, t) => {
         e.setTime(+e + t)
     }, (e, t) => t - e);
-    Xu.every = e => (e = Math.floor(e), !isFinite(e) || !(e > 0) ? null : e > 1 ? It(t => {
+    Lu.every = e => (e = Math.floor(e), !isFinite(e) || !(e > 0) ? null : e > 1 ? Dt(t => {
         t.setTime(Math.floor(t / e) * e)
     }, (t, n) => {
         t.setTime(+t + n * e)
-    }, (t, n) => (n - t) / e) : Xu);
-    Xu.range;
-    const Ra = 1e3,
-        Fi = Ra * 60,
-        Pa = Fi * 60,
-        Ya = Pa * 24,
-        C_ = Ya * 7,
-        MA = Ya * 30,
-        uv = Ya * 365,
-        Na = It(e => {
+    }, (t, n) => (n - t) / e) : Lu);
+    Lu.range;
+    const Es = 1e3,
+        Ai = Es * 60,
+        Cs = Ai * 60,
+        Is = Cs * 24,
+        qx = Is * 7,
+        qA = Is * 30,
+        jy = Is * 365,
+        ks = Dt(e => {
             e.setTime(e - e.getMilliseconds())
         }, (e, t) => {
-            e.setTime(+e + t * Ra)
-        }, (e, t) => (t - e) / Ra, e => e.getUTCSeconds());
-    Na.range;
-    const Pm = It(e => {
-        e.setTime(e - e.getMilliseconds() - e.getSeconds() * Ra)
+            e.setTime(+e + t * Es)
+        }, (e, t) => (t - e) / Es, e => e.getUTCSeconds());
+    ks.range;
+    const pm = Dt(e => {
+        e.setTime(e - e.getMilliseconds() - e.getSeconds() * Es)
     }, (e, t) => {
-        e.setTime(+e + t * Fi)
-    }, (e, t) => (t - e) / Fi, e => e.getMinutes());
-    Pm.range;
-    const Nm = It(e => {
+        e.setTime(+e + t * Ai)
+    }, (e, t) => (t - e) / Ai, e => e.getMinutes());
+    pm.range;
+    const mm = Dt(e => {
         e.setUTCSeconds(0, 0)
     }, (e, t) => {
-        e.setTime(+e + t * Fi)
-    }, (e, t) => (t - e) / Fi, e => e.getUTCMinutes());
-    Nm.range;
-    const Lm = It(e => {
-        e.setTime(e - e.getMilliseconds() - e.getSeconds() * Ra - e.getMinutes() * Fi)
+        e.setTime(+e + t * Ai)
+    }, (e, t) => (t - e) / Ai, e => e.getUTCMinutes());
+    mm.range;
+    const ym = Dt(e => {
+        e.setTime(e - e.getMilliseconds() - e.getSeconds() * Es - e.getMinutes() * Ai)
     }, (e, t) => {
-        e.setTime(+e + t * Pa)
-    }, (e, t) => (t - e) / Pa, e => e.getHours());
-    Lm.range;
-    const Im = It(e => {
+        e.setTime(+e + t * Cs)
+    }, (e, t) => (t - e) / Cs, e => e.getHours());
+    ym.range;
+    const vm = Dt(e => {
         e.setUTCMinutes(0, 0, 0)
     }, (e, t) => {
-        e.setTime(+e + t * Pa)
-    }, (e, t) => (t - e) / Pa, e => e.getUTCHours());
-    Im.range;
-    const Ba = It(e => e.setHours(0, 0, 0, 0), (e, t) => e.setDate(e.getDate() + t), (e, t) => (t - e - (t.getTimezoneOffset() - e.getTimezoneOffset()) * Fi) / Ya, e => e.getDate() - 1);
-    Ba.range;
-    const Fs = It(e => {
+        e.setTime(+e + t * Cs)
+    }, (e, t) => (t - e) / Cs, e => e.getUTCHours());
+    vm.range;
+    const Os = Dt(e => e.setHours(0, 0, 0, 0), (e, t) => e.setDate(e.getDate() + t), (e, t) => (t - e - (t.getTimezoneOffset() - e.getTimezoneOffset()) * Ai) / Is, e => e.getDate() - 1);
+    Os.range;
+    const Sa = Dt(e => {
         e.setUTCHours(0, 0, 0, 0)
     }, (e, t) => {
         e.setUTCDate(e.getUTCDate() + t)
-    }, (e, t) => (t - e) / Ya, e => e.getUTCDate() - 1);
-    Fs.range;
-    const XD = It(e => {
+    }, (e, t) => (t - e) / Is, e => e.getUTCDate() - 1);
+    Sa.range;
+    const sR = Dt(e => {
         e.setUTCHours(0, 0, 0, 0)
     }, (e, t) => {
         e.setUTCDate(e.getUTCDate() + t)
-    }, (e, t) => (t - e) / Ya, e => Math.floor(e / Ya));
-    XD.range;
+    }, (e, t) => (t - e) / Is, e => Math.floor(e / Is));
+    sR.range;
 
-    function Ll(e) {
-        return It(t => {
+    function kl(e) {
+        return Dt(t => {
             t.setDate(t.getDate() - (t.getDay() + 7 - e) % 7), t.setHours(0, 0, 0, 0)
         }, (t, n) => {
             t.setDate(t.getDate() + n * 7)
-        }, (t, n) => (n - t - (n.getTimezoneOffset() - t.getTimezoneOffset()) * Fi) / C_)
+        }, (t, n) => (n - t - (n.getTimezoneOffset() - t.getTimezoneOffset()) * Ai) / qx)
     }
-    const Ac = Ll(0),
-        x0 = Ll(1),
-        cH = Ll(2),
-        fH = Ll(3),
-        Vu = Ll(4),
-        hH = Ll(5),
-        dH = Ll(6);
-    Ac.range;
-    x0.range;
-    cH.range;
-    fH.range;
-    Vu.range;
-    hH.range;
-    dH.range;
+    const mc = kl(0),
+        t0 = kl(1),
+        yq = kl(2),
+        vq = kl(3),
+        Iu = kl(4),
+        bq = kl(5),
+        xq = kl(6);
+    mc.range;
+    t0.range;
+    yq.range;
+    vq.range;
+    Iu.range;
+    bq.range;
+    xq.range;
 
-    function Il(e) {
-        return It(t => {
+    function Al(e) {
+        return Dt(t => {
             t.setUTCDate(t.getUTCDate() - (t.getUTCDay() + 7 - e) % 7), t.setUTCHours(0, 0, 0, 0)
         }, (t, n) => {
             t.setUTCDate(t.getUTCDate() + n * 7)
-        }, (t, n) => (n - t) / C_)
+        }, (t, n) => (n - t) / qx)
     }
-    const Tc = Il(0),
-        _0 = Il(1),
-        gH = Il(2),
-        pH = Il(3),
-        Ku = Il(4),
-        mH = Il(5),
-        yH = Il(6);
-    Tc.range;
-    _0.range;
-    gH.range;
-    pH.range;
-    Ku.range;
-    mH.range;
-    yH.range;
-    const Fh = It(e => {
+    const yc = Al(0),
+        n0 = Al(1),
+        _q = Al(2),
+        wq = Al(3),
+        zu = Al(4),
+        Sq = Al(5),
+        Eq = Al(6);
+    yc.range;
+    n0.range;
+    _q.range;
+    wq.range;
+    zu.range;
+    Sq.range;
+    Eq.range;
+    const xh = Dt(e => {
         e.setDate(1), e.setHours(0, 0, 0, 0)
     }, (e, t) => {
         e.setMonth(e.getMonth() + t)
     }, (e, t) => t.getMonth() - e.getMonth() + (t.getFullYear() - e.getFullYear()) * 12, e => e.getMonth());
-    Fh.range;
-    const Dh = It(e => {
+    xh.range;
+    const _h = Dt(e => {
         e.setUTCDate(1), e.setUTCHours(0, 0, 0, 0)
     }, (e, t) => {
         e.setUTCMonth(e.getUTCMonth() + t)
     }, (e, t) => t.getUTCMonth() - e.getUTCMonth() + (t.getUTCFullYear() - e.getUTCFullYear()) * 12, e => e.getUTCMonth());
-    Dh.range;
-    const Jr = It(e => {
+    _h.range;
+    const Wr = Dt(e => {
         e.setMonth(0, 1), e.setHours(0, 0, 0, 0)
     }, (e, t) => {
         e.setFullYear(e.getFullYear() + t)
     }, (e, t) => t.getFullYear() - e.getFullYear(), e => e.getFullYear());
-    Jr.every = e => !isFinite(e = Math.floor(e)) || !(e > 0) ? null : It(t => {
+    Wr.every = e => !isFinite(e = Math.floor(e)) || !(e > 0) ? null : Dt(t => {
         t.setFullYear(Math.floor(t.getFullYear() / e) * e), t.setMonth(0, 1), t.setHours(0, 0, 0, 0)
     }, (t, n) => {
         t.setFullYear(t.getFullYear() + n * e)
     });
-    Jr.range;
-    const Qr = It(e => {
+    Wr.range;
+    const qr = Dt(e => {
         e.setUTCMonth(0, 1), e.setUTCHours(0, 0, 0, 0)
     }, (e, t) => {
         e.setUTCFullYear(e.getUTCFullYear() + t)
     }, (e, t) => t.getUTCFullYear() - e.getUTCFullYear(), e => e.getUTCFullYear());
-    Qr.every = e => !isFinite(e = Math.floor(e)) || !(e > 0) ? null : It(t => {
+    qr.every = e => !isFinite(e = Math.floor(e)) || !(e > 0) ? null : Dt(t => {
         t.setUTCFullYear(Math.floor(t.getUTCFullYear() / e) * e), t.setUTCMonth(0, 1), t.setUTCHours(0, 0, 0, 0)
     }, (t, n) => {
         t.setUTCFullYear(t.getUTCFullYear() + n * e)
     });
-    Qr.range;
+    qr.range;
 
-    function VD(e, t, n, i, r, a) {
-        const s = [
-            [Na, 1, Ra],
-            [Na, 5, 5 * Ra],
-            [Na, 15, 15 * Ra],
-            [Na, 30, 30 * Ra],
-            [a, 1, Fi],
-            [a, 5, 5 * Fi],
-            [a, 15, 15 * Fi],
-            [a, 30, 30 * Fi],
-            [r, 1, Pa],
-            [r, 3, 3 * Pa],
-            [r, 6, 6 * Pa],
-            [r, 12, 12 * Pa],
-            [i, 1, Ya],
-            [i, 2, 2 * Ya],
-            [n, 1, C_],
-            [t, 1, MA],
-            [t, 3, 3 * MA],
-            [e, 1, uv]
+    function aR(e, t, n, i, r, s) {
+        const a = [
+            [ks, 1, Es],
+            [ks, 5, 5 * Es],
+            [ks, 15, 15 * Es],
+            [ks, 30, 30 * Es],
+            [s, 1, Ai],
+            [s, 5, 5 * Ai],
+            [s, 15, 15 * Ai],
+            [s, 30, 30 * Ai],
+            [r, 1, Cs],
+            [r, 3, 3 * Cs],
+            [r, 6, 6 * Cs],
+            [r, 12, 12 * Cs],
+            [i, 1, Is],
+            [i, 2, 2 * Is],
+            [n, 1, qx],
+            [t, 1, qA],
+            [t, 3, 3 * qA],
+            [e, 1, jy]
         ];
 
         function o(u, c, f) {
             const h = c < u;
             h && ([u, c] = [c, u]);
             const d = f && typeof f.range == "function" ? f : l(u, c, f),
                 g = d ? d.range(u, +c + 1) : [];
             return h ? g.reverse() : g
         }
 
         function l(u, c, f) {
             const h = Math.abs(c - u) / f,
-                d = cd(([, , m]) => m).right(s, h);
-            if (d === s.length) return e.every(Bs(u / uv, c / uv, f));
-            if (d === 0) return Xu.every(Math.max(Bs(u, c, f), 1));
-            const [g, p] = s[h / s[d - 1][2] < s[d][2] / h ? d - 1 : d];
+                d = Qh(([, , m]) => m).right(a, h);
+            if (d === a.length) return e.every(Oa(u / jy, c / jy, f));
+            if (d === 0) return Lu.every(Math.max(Oa(u, c, f), 1));
+            const [g, p] = a[h / a[d - 1][2] < a[d][2] / h ? d - 1 : d];
             return g.every(p)
         }
         return [o, l]
     }
-    const [vH, bH] = VD(Qr, Dh, Tc, XD, Im, Nm), [xH, _H] = VD(Jr, Fh, Ac, Ba, Lm, Pm);
+    const [Cq, kq] = aR(qr, _h, yc, sR, vm, mm), [Aq, $q] = aR(Wr, xh, mc, Os, ym, pm);
 
-    function cv(e) {
+    function Uy(e) {
         if (0 <= e.y && e.y < 100) {
             var t = new Date(-1, e.m, e.d, e.H, e.M, e.S, e.L);
             return t.setFullYear(e.y), t
         }
         return new Date(e.y, e.m, e.d, e.H, e.M, e.S, e.L)
     }
 
-    function fv(e) {
+    function Gy(e) {
         if (0 <= e.y && e.y < 100) {
             var t = new Date(Date.UTC(-1, e.m, e.d, e.H, e.M, e.S, e.L));
             return t.setUTCFullYear(e.y), t
         }
         return new Date(Date.UTC(e.y, e.m, e.d, e.H, e.M, e.S, e.L))
     }
 
-    function lf(e, t, n) {
+    function Xc(e, t, n) {
         return {
             y: e,
             m: t,
             d: n,
             H: 0,
             M: 0,
             S: 0,
             L: 0
         }
     }
 
-    function KD(e) {
+    function oR(e) {
         var t = e.dateTime,
             n = e.date,
             i = e.time,
             r = e.periods,
-            a = e.days,
-            s = e.shortDays,
+            s = e.days,
+            a = e.shortDays,
             o = e.months,
             l = e.shortMonths,
-            u = uf(r),
-            c = cf(r),
-            f = uf(a),
-            h = cf(a),
-            d = uf(s),
-            g = cf(s),
-            p = uf(o),
-            m = cf(o),
-            y = uf(l),
-            v = cf(l),
+            u = Vc(r),
+            c = Kc(r),
+            f = Vc(s),
+            h = Kc(s),
+            d = Vc(a),
+            g = Kc(a),
+            p = Vc(o),
+            m = Kc(o),
+            y = Vc(l),
+            v = Kc(l),
             b = {
-                a: P,
-                A: N,
+                a: N,
+                A: P,
                 b: z,
                 B: I,
                 c: null,
-                d: LA,
-                e: LA,
-                f: qH,
-                g: eY,
-                G: nY,
-                H: BH,
-                I: GH,
-                j: UH,
-                L: JD,
-                m: WH,
-                M: HH,
-                p: ae,
-                q: ye,
-                Q: zA,
-                s: BA,
-                S: YH,
-                u: XH,
-                U: VH,
-                V: KH,
-                w: JH,
-                W: QH,
+                d: JA,
+                e: JA,
+                f: Jq,
+                g: oH,
+                G: uH,
+                H: Xq,
+                I: Vq,
+                j: Kq,
+                L: lR,
+                m: Qq,
+                M: Zq,
+                p: Q,
+                q: oe,
+                Q: e$,
+                s: t$,
+                S: eH,
+                u: tH,
+                U: nH,
+                V: iH,
+                w: rH,
+                W: sH,
                 x: null,
                 X: null,
-                y: ZH,
-                Y: tY,
-                Z: iY,
-                "%": jA
+                y: aH,
+                Y: lH,
+                Z: cH,
+                "%": ZA
             },
             x = {
-                a: we,
-                A: $e,
-                b: Oe,
-                B: Ye,
+                a: Se,
+                A: ye,
+                b: Pe,
+                B: xt,
                 c: null,
-                d: IA,
-                e: IA,
-                f: oY,
-                g: yY,
-                G: bY,
-                H: rY,
-                I: aY,
-                j: sY,
-                L: ZD,
-                m: lY,
-                M: uY,
-                p: St,
-                q: dt,
-                Q: zA,
-                s: BA,
-                S: cY,
-                u: fY,
-                U: hY,
-                V: dY,
-                w: gY,
-                W: pY,
+                d: QA,
+                e: QA,
+                f: gH,
+                g: EH,
+                G: kH,
+                H: fH,
+                I: hH,
+                j: dH,
+                L: cR,
+                m: pH,
+                M: mH,
+                p: rn,
+                q: Un,
+                Q: e$,
+                s: t$,
+                S: yH,
+                u: vH,
+                U: bH,
+                V: xH,
+                w: _H,
+                W: wH,
                 x: null,
                 X: null,
-                y: mY,
-                Y: vY,
-                Z: xY,
-                "%": jA
+                y: SH,
+                Y: CH,
+                Z: AH,
+                "%": ZA
             },
             _ = {
                 a: C,
-                A: E,
-                b: T,
-                B: A,
-                c: F,
-                d: PA,
-                e: PA,
-                f: LH,
-                g: RA,
-                G: DA,
-                H: NA,
-                I: NA,
-                j: DH,
-                L: NH,
-                m: FH,
-                M: RH,
-                p: k,
-                q: MH,
-                Q: jH,
-                s: zH,
-                S: PH,
-                u: CH,
-                U: kH,
-                V: AH,
-                w: OH,
-                W: TH,
-                x: $,
-                X: D,
-                y: RA,
-                Y: DA,
-                Z: $H,
-                "%": IH
+                A: k,
+                b: R,
+                B: $,
+                c: T,
+                d: VA,
+                e: VA,
+                f: Wq,
+                g: XA,
+                G: YA,
+                H: KA,
+                I: KA,
+                j: Bq,
+                L: Gq,
+                m: zq,
+                M: jq,
+                p: A,
+                q: Iq,
+                Q: Hq,
+                s: Yq,
+                S: Uq,
+                u: Rq,
+                U: Dq,
+                V: Nq,
+                w: Fq,
+                W: Pq,
+                x: M,
+                X: F,
+                y: XA,
+                Y: YA,
+                Z: Lq,
+                "%": qq
             };
         b.x = S(n, b), b.X = S(i, b), b.c = S(t, b), x.x = S(n, x), x.X = S(i, x), x.c = S(t, x);
 
-        function S(H, oe) {
-            return function(me) {
-                var W = [],
-                    Fe = -1,
-                    ue = 0,
-                    Re = H.length,
-                    vt, Oi, us;
-                for (me instanceof Date || (me = new Date(+me)); ++Fe < Re;) H.charCodeAt(Fe) === 37 && (W.push(H.slice(ue, Fe)), (Oi = FA[vt = H.charAt(++Fe)]) != null ? vt = H.charAt(++Fe) : Oi = vt === "e" ? " " : "0", (us = oe[vt]) && (vt = us(me, Oi)), W.push(vt), ue = Fe + 1);
-                return W.push(H.slice(ue, Fe)), W.join("")
+        function S(Y, ue) {
+            return function(be) {
+                var q = [],
+                    ze = -1,
+                    fe = 0,
+                    Be = Y.length,
+                    Sn, co, YC;
+                for (be instanceof Date || (be = new Date(+be)); ++ze < Be;) Y.charCodeAt(ze) === 37 && (q.push(Y.slice(fe, ze)), (co = HA[Sn = Y.charAt(++ze)]) != null ? Sn = Y.charAt(++ze) : co = Sn === "e" ? " " : "0", (YC = ue[Sn]) && (Sn = YC(be, co)), q.push(Sn), fe = ze + 1);
+                return q.push(Y.slice(fe, ze)), q.join("")
             }
         }
 
-        function w(H, oe) {
-            return function(me) {
-                var W = lf(1900, void 0, 1),
-                    Fe = O(W, H, me += "", 0),
-                    ue, Re;
-                if (Fe != me.length) return null;
-                if ("Q" in W) return new Date(W.Q);
-                if ("s" in W) return new Date(W.s * 1e3 + ("L" in W ? W.L : 0));
-                if (oe && !("Z" in W) && (W.Z = 0), "p" in W && (W.H = W.H % 12 + W.p * 12), W.m === void 0 && (W.m = "q" in W ? W.q : 0), "V" in W) {
-                    if (W.V < 1 || W.V > 53) return null;
-                    "w" in W || (W.w = 1), "Z" in W ? (ue = fv(lf(W.y, 0, 1)), Re = ue.getUTCDay(), ue = Re > 4 || Re === 0 ? _0.ceil(ue) : _0(ue), ue = Fs.offset(ue, (W.V - 1) * 7), W.y = ue.getUTCFullYear(), W.m = ue.getUTCMonth(), W.d = ue.getUTCDate() + (W.w + 6) % 7) : (ue = cv(lf(W.y, 0, 1)), Re = ue.getDay(), ue = Re > 4 || Re === 0 ? x0.ceil(ue) : x0(ue), ue = Ba.offset(ue, (W.V - 1) * 7), W.y = ue.getFullYear(), W.m = ue.getMonth(), W.d = ue.getDate() + (W.w + 6) % 7)
-                } else("W" in W || "U" in W) && ("w" in W || (W.w = "u" in W ? W.u % 7 : "W" in W ? 1 : 0), Re = "Z" in W ? fv(lf(W.y, 0, 1)).getUTCDay() : cv(lf(W.y, 0, 1)).getDay(), W.m = 0, W.d = "W" in W ? (W.w + 6) % 7 + W.W * 7 - (Re + 5) % 7 : W.w + W.U * 7 - (Re + 6) % 7);
-                return "Z" in W ? (W.H += W.Z / 100 | 0, W.M += W.Z % 100, fv(W)) : cv(W)
+        function w(Y, ue) {
+            return function(be) {
+                var q = Xc(1900, void 0, 1),
+                    ze = E(q, Y, be += "", 0),
+                    fe, Be;
+                if (ze != be.length) return null;
+                if ("Q" in q) return new Date(q.Q);
+                if ("s" in q) return new Date(q.s * 1e3 + ("L" in q ? q.L : 0));
+                if (ue && !("Z" in q) && (q.Z = 0), "p" in q && (q.H = q.H % 12 + q.p * 12), q.m === void 0 && (q.m = "q" in q ? q.q : 0), "V" in q) {
+                    if (q.V < 1 || q.V > 53) return null;
+                    "w" in q || (q.w = 1), "Z" in q ? (fe = Gy(Xc(q.y, 0, 1)), Be = fe.getUTCDay(), fe = Be > 4 || Be === 0 ? n0.ceil(fe) : n0(fe), fe = Sa.offset(fe, (q.V - 1) * 7), q.y = fe.getUTCFullYear(), q.m = fe.getUTCMonth(), q.d = fe.getUTCDate() + (q.w + 6) % 7) : (fe = Uy(Xc(q.y, 0, 1)), Be = fe.getDay(), fe = Be > 4 || Be === 0 ? t0.ceil(fe) : t0(fe), fe = Os.offset(fe, (q.V - 1) * 7), q.y = fe.getFullYear(), q.m = fe.getMonth(), q.d = fe.getDate() + (q.w + 6) % 7)
+                } else("W" in q || "U" in q) && ("w" in q || (q.w = "u" in q ? q.u % 7 : "W" in q ? 1 : 0), Be = "Z" in q ? Gy(Xc(q.y, 0, 1)).getUTCDay() : Uy(Xc(q.y, 0, 1)).getDay(), q.m = 0, q.d = "W" in q ? (q.w + 6) % 7 + q.W * 7 - (Be + 5) % 7 : q.w + q.U * 7 - (Be + 6) % 7);
+                return "Z" in q ? (q.H += q.Z / 100 | 0, q.M += q.Z % 100, Gy(q)) : Uy(q)
             }
         }
 
-        function O(H, oe, me, W) {
-            for (var Fe = 0, ue = oe.length, Re = me.length, vt, Oi; Fe < ue;) {
-                if (W >= Re) return -1;
-                if (vt = oe.charCodeAt(Fe++), vt === 37) {
-                    if (vt = oe.charAt(Fe++), Oi = _[vt in FA ? oe.charAt(Fe++) : vt], !Oi || (W = Oi(H, me, W)) < 0) return -1
-                } else if (vt != me.charCodeAt(W++)) return -1
+        function E(Y, ue, be, q) {
+            for (var ze = 0, fe = ue.length, Be = be.length, Sn, co; ze < fe;) {
+                if (q >= Be) return -1;
+                if (Sn = ue.charCodeAt(ze++), Sn === 37) {
+                    if (Sn = ue.charAt(ze++), co = _[Sn in HA ? ue.charAt(ze++) : Sn], !co || (q = co(Y, be, q)) < 0) return -1
+                } else if (Sn != be.charCodeAt(q++)) return -1
             }
-            return W
+            return q
         }
 
-        function k(H, oe, me) {
-            var W = u.exec(oe.slice(me));
-            return W ? (H.p = c.get(W[0].toLowerCase()), me + W[0].length) : -1
+        function A(Y, ue, be) {
+            var q = u.exec(ue.slice(be));
+            return q ? (Y.p = c.get(q[0].toLowerCase()), be + q[0].length) : -1
         }
 
-        function C(H, oe, me) {
-            var W = d.exec(oe.slice(me));
-            return W ? (H.w = g.get(W[0].toLowerCase()), me + W[0].length) : -1
+        function C(Y, ue, be) {
+            var q = d.exec(ue.slice(be));
+            return q ? (Y.w = g.get(q[0].toLowerCase()), be + q[0].length) : -1
         }
 
-        function E(H, oe, me) {
-            var W = f.exec(oe.slice(me));
-            return W ? (H.w = h.get(W[0].toLowerCase()), me + W[0].length) : -1
+        function k(Y, ue, be) {
+            var q = f.exec(ue.slice(be));
+            return q ? (Y.w = h.get(q[0].toLowerCase()), be + q[0].length) : -1
         }
 
-        function T(H, oe, me) {
-            var W = y.exec(oe.slice(me));
-            return W ? (H.m = v.get(W[0].toLowerCase()), me + W[0].length) : -1
+        function R(Y, ue, be) {
+            var q = y.exec(ue.slice(be));
+            return q ? (Y.m = v.get(q[0].toLowerCase()), be + q[0].length) : -1
         }
 
-        function A(H, oe, me) {
-            var W = p.exec(oe.slice(me));
-            return W ? (H.m = m.get(W[0].toLowerCase()), me + W[0].length) : -1
+        function $(Y, ue, be) {
+            var q = p.exec(ue.slice(be));
+            return q ? (Y.m = m.get(q[0].toLowerCase()), be + q[0].length) : -1
         }
 
-        function F(H, oe, me) {
-            return O(H, t, oe, me)
+        function T(Y, ue, be) {
+            return E(Y, t, ue, be)
         }
 
-        function $(H, oe, me) {
-            return O(H, n, oe, me)
+        function M(Y, ue, be) {
+            return E(Y, n, ue, be)
         }
 
-        function D(H, oe, me) {
-            return O(H, i, oe, me)
+        function F(Y, ue, be) {
+            return E(Y, i, ue, be)
         }
 
-        function P(H) {
-            return s[H.getDay()]
+        function N(Y) {
+            return a[Y.getDay()]
         }
 
-        function N(H) {
-            return a[H.getDay()]
+        function P(Y) {
+            return s[Y.getDay()]
         }
 
-        function z(H) {
-            return l[H.getMonth()]
+        function z(Y) {
+            return l[Y.getMonth()]
         }
 
-        function I(H) {
-            return o[H.getMonth()]
+        function I(Y) {
+            return o[Y.getMonth()]
         }
 
-        function ae(H) {
-            return r[+(H.getHours() >= 12)]
+        function Q(Y) {
+            return r[+(Y.getHours() >= 12)]
         }
 
-        function ye(H) {
-            return 1 + ~~(H.getMonth() / 3)
+        function oe(Y) {
+            return 1 + ~~(Y.getMonth() / 3)
         }
 
-        function we(H) {
-            return s[H.getUTCDay()]
+        function Se(Y) {
+            return a[Y.getUTCDay()]
         }
 
-        function $e(H) {
-            return a[H.getUTCDay()]
+        function ye(Y) {
+            return s[Y.getUTCDay()]
         }
 
-        function Oe(H) {
-            return l[H.getUTCMonth()]
+        function Pe(Y) {
+            return l[Y.getUTCMonth()]
         }
 
-        function Ye(H) {
-            return o[H.getUTCMonth()]
+        function xt(Y) {
+            return o[Y.getUTCMonth()]
         }
 
-        function St(H) {
-            return r[+(H.getUTCHours() >= 12)]
+        function rn(Y) {
+            return r[+(Y.getUTCHours() >= 12)]
         }
 
-        function dt(H) {
-            return 1 + ~~(H.getUTCMonth() / 3)
+        function Un(Y) {
+            return 1 + ~~(Y.getUTCMonth() / 3)
         }
         return {
-            format: function(H) {
-                var oe = S(H += "", b);
-                return oe.toString = function() {
-                    return H
-                }, oe
+            format: function(Y) {
+                var ue = S(Y += "", b);
+                return ue.toString = function() {
+                    return Y
+                }, ue
             },
-            parse: function(H) {
-                var oe = w(H += "", !1);
-                return oe.toString = function() {
-                    return H
-                }, oe
+            parse: function(Y) {
+                var ue = w(Y += "", !1);
+                return ue.toString = function() {
+                    return Y
+                }, ue
             },
-            utcFormat: function(H) {
-                var oe = S(H += "", x);
-                return oe.toString = function() {
-                    return H
-                }, oe
+            utcFormat: function(Y) {
+                var ue = S(Y += "", x);
+                return ue.toString = function() {
+                    return Y
+                }, ue
             },
-            utcParse: function(H) {
-                var oe = w(H += "", !0);
-                return oe.toString = function() {
-                    return H
-                }, oe
+            utcParse: function(Y) {
+                var ue = w(Y += "", !0);
+                return ue.toString = function() {
+                    return Y
+                }, ue
             }
         }
     }
-    var FA = {
+    var HA = {
             "-": "",
             _: " ",
             0: "0"
         },
-        Kt = /^\s*\d+/,
-        wH = /^%/,
-        SH = /[\\^$*+?|[\]().{}]/g;
+        Ht = /^\s*\d+/,
+        Tq = /^%/,
+        Mq = /[\\^$*+?|[\]().{}]/g;
 
-    function Ue(e, t, n) {
+    function Ge(e, t, n) {
         var i = e < 0 ? "-" : "",
             r = (i ? -e : e) + "",
-            a = r.length;
-        return i + (a < n ? new Array(n - a + 1).join(t) + r : r)
+            s = r.length;
+        return i + (s < n ? new Array(n - s + 1).join(t) + r : r)
     }
 
-    function EH(e) {
-        return e.replace(SH, "\\$&")
+    function Oq(e) {
+        return e.replace(Mq, "\\$&")
     }
 
-    function uf(e) {
-        return new RegExp("^(?:" + e.map(EH).join("|") + ")", "i")
+    function Vc(e) {
+        return new RegExp("^(?:" + e.map(Oq).join("|") + ")", "i")
     }
 
-    function cf(e) {
+    function Kc(e) {
         return new Map(e.map((t, n) => [t.toLowerCase(), n]))
     }
 
-    function OH(e, t, n) {
-        var i = Kt.exec(t.slice(n, n + 1));
+    function Fq(e, t, n) {
+        var i = Ht.exec(t.slice(n, n + 1));
         return i ? (e.w = +i[0], n + i[0].length) : -1
     }
 
-    function CH(e, t, n) {
-        var i = Kt.exec(t.slice(n, n + 1));
+    function Rq(e, t, n) {
+        var i = Ht.exec(t.slice(n, n + 1));
         return i ? (e.u = +i[0], n + i[0].length) : -1
     }
 
-    function kH(e, t, n) {
-        var i = Kt.exec(t.slice(n, n + 2));
+    function Dq(e, t, n) {
+        var i = Ht.exec(t.slice(n, n + 2));
         return i ? (e.U = +i[0], n + i[0].length) : -1
     }
 
-    function AH(e, t, n) {
-        var i = Kt.exec(t.slice(n, n + 2));
+    function Nq(e, t, n) {
+        var i = Ht.exec(t.slice(n, n + 2));
         return i ? (e.V = +i[0], n + i[0].length) : -1
     }
 
-    function TH(e, t, n) {
-        var i = Kt.exec(t.slice(n, n + 2));
+    function Pq(e, t, n) {
+        var i = Ht.exec(t.slice(n, n + 2));
         return i ? (e.W = +i[0], n + i[0].length) : -1
     }
 
-    function DA(e, t, n) {
-        var i = Kt.exec(t.slice(n, n + 4));
+    function YA(e, t, n) {
+        var i = Ht.exec(t.slice(n, n + 4));
         return i ? (e.y = +i[0], n + i[0].length) : -1
     }
 
-    function RA(e, t, n) {
-        var i = Kt.exec(t.slice(n, n + 2));
+    function XA(e, t, n) {
+        var i = Ht.exec(t.slice(n, n + 2));
         return i ? (e.y = +i[0] + (+i[0] > 68 ? 1900 : 2e3), n + i[0].length) : -1
     }
 
-    function $H(e, t, n) {
+    function Lq(e, t, n) {
         var i = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(t.slice(n, n + 6));
         return i ? (e.Z = i[1] ? 0 : -(i[2] + (i[3] || "00")), n + i[0].length) : -1
     }
 
-    function MH(e, t, n) {
-        var i = Kt.exec(t.slice(n, n + 1));
+    function Iq(e, t, n) {
+        var i = Ht.exec(t.slice(n, n + 1));
         return i ? (e.q = i[0] * 3 - 3, n + i[0].length) : -1
     }
 
-    function FH(e, t, n) {
-        var i = Kt.exec(t.slice(n, n + 2));
+    function zq(e, t, n) {
+        var i = Ht.exec(t.slice(n, n + 2));
         return i ? (e.m = i[0] - 1, n + i[0].length) : -1
     }
 
-    function PA(e, t, n) {
-        var i = Kt.exec(t.slice(n, n + 2));
+    function VA(e, t, n) {
+        var i = Ht.exec(t.slice(n, n + 2));
         return i ? (e.d = +i[0], n + i[0].length) : -1
     }
 
-    function DH(e, t, n) {
-        var i = Kt.exec(t.slice(n, n + 3));
+    function Bq(e, t, n) {
+        var i = Ht.exec(t.slice(n, n + 3));
         return i ? (e.m = 0, e.d = +i[0], n + i[0].length) : -1
     }
 
-    function NA(e, t, n) {
-        var i = Kt.exec(t.slice(n, n + 2));
+    function KA(e, t, n) {
+        var i = Ht.exec(t.slice(n, n + 2));
         return i ? (e.H = +i[0], n + i[0].length) : -1
     }
 
-    function RH(e, t, n) {
-        var i = Kt.exec(t.slice(n, n + 2));
+    function jq(e, t, n) {
+        var i = Ht.exec(t.slice(n, n + 2));
         return i ? (e.M = +i[0], n + i[0].length) : -1
     }
 
-    function PH(e, t, n) {
-        var i = Kt.exec(t.slice(n, n + 2));
+    function Uq(e, t, n) {
+        var i = Ht.exec(t.slice(n, n + 2));
         return i ? (e.S = +i[0], n + i[0].length) : -1
     }
 
-    function NH(e, t, n) {
-        var i = Kt.exec(t.slice(n, n + 3));
+    function Gq(e, t, n) {
+        var i = Ht.exec(t.slice(n, n + 3));
         return i ? (e.L = +i[0], n + i[0].length) : -1
     }
 
-    function LH(e, t, n) {
-        var i = Kt.exec(t.slice(n, n + 6));
+    function Wq(e, t, n) {
+        var i = Ht.exec(t.slice(n, n + 6));
         return i ? (e.L = Math.floor(i[0] / 1e3), n + i[0].length) : -1
     }
 
-    function IH(e, t, n) {
-        var i = wH.exec(t.slice(n, n + 1));
+    function qq(e, t, n) {
+        var i = Tq.exec(t.slice(n, n + 1));
         return i ? n + i[0].length : -1
     }
 
-    function jH(e, t, n) {
-        var i = Kt.exec(t.slice(n));
+    function Hq(e, t, n) {
+        var i = Ht.exec(t.slice(n));
         return i ? (e.Q = +i[0], n + i[0].length) : -1
     }
 
-    function zH(e, t, n) {
-        var i = Kt.exec(t.slice(n));
+    function Yq(e, t, n) {
+        var i = Ht.exec(t.slice(n));
         return i ? (e.s = +i[0], n + i[0].length) : -1
     }
 
-    function LA(e, t) {
-        return Ue(e.getDate(), t, 2)
+    function JA(e, t) {
+        return Ge(e.getDate(), t, 2)
     }
 
-    function BH(e, t) {
-        return Ue(e.getHours(), t, 2)
+    function Xq(e, t) {
+        return Ge(e.getHours(), t, 2)
     }
 
-    function GH(e, t) {
-        return Ue(e.getHours() % 12 || 12, t, 2)
+    function Vq(e, t) {
+        return Ge(e.getHours() % 12 || 12, t, 2)
     }
 
-    function UH(e, t) {
-        return Ue(1 + Ba.count(Jr(e), e), t, 3)
+    function Kq(e, t) {
+        return Ge(1 + Os.count(Wr(e), e), t, 3)
     }
 
-    function JD(e, t) {
-        return Ue(e.getMilliseconds(), t, 3)
+    function lR(e, t) {
+        return Ge(e.getMilliseconds(), t, 3)
     }
 
-    function qH(e, t) {
-        return JD(e, t) + "000"
+    function Jq(e, t) {
+        return lR(e, t) + "000"
     }
 
-    function WH(e, t) {
-        return Ue(e.getMonth() + 1, t, 2)
+    function Qq(e, t) {
+        return Ge(e.getMonth() + 1, t, 2)
     }
 
-    function HH(e, t) {
-        return Ue(e.getMinutes(), t, 2)
+    function Zq(e, t) {
+        return Ge(e.getMinutes(), t, 2)
     }
 
-    function YH(e, t) {
-        return Ue(e.getSeconds(), t, 2)
+    function eH(e, t) {
+        return Ge(e.getSeconds(), t, 2)
     }
 
-    function XH(e) {
+    function tH(e) {
         var t = e.getDay();
         return t === 0 ? 7 : t
     }
 
-    function VH(e, t) {
-        return Ue(Ac.count(Jr(e) - 1, e), t, 2)
+    function nH(e, t) {
+        return Ge(mc.count(Wr(e) - 1, e), t, 2)
     }
 
-    function QD(e) {
+    function uR(e) {
         var t = e.getDay();
-        return t >= 4 || t === 0 ? Vu(e) : Vu.ceil(e)
+        return t >= 4 || t === 0 ? Iu(e) : Iu.ceil(e)
     }
 
-    function KH(e, t) {
-        return e = QD(e), Ue(Vu.count(Jr(e), e) + (Jr(e).getDay() === 4), t, 2)
+    function iH(e, t) {
+        return e = uR(e), Ge(Iu.count(Wr(e), e) + (Wr(e).getDay() === 4), t, 2)
     }
 
-    function JH(e) {
+    function rH(e) {
         return e.getDay()
     }
 
-    function QH(e, t) {
-        return Ue(x0.count(Jr(e) - 1, e), t, 2)
+    function sH(e, t) {
+        return Ge(t0.count(Wr(e) - 1, e), t, 2)
     }
 
-    function ZH(e, t) {
-        return Ue(e.getFullYear() % 100, t, 2)
+    function aH(e, t) {
+        return Ge(e.getFullYear() % 100, t, 2)
     }
 
-    function eY(e, t) {
-        return e = QD(e), Ue(e.getFullYear() % 100, t, 2)
+    function oH(e, t) {
+        return e = uR(e), Ge(e.getFullYear() % 100, t, 2)
     }
 
-    function tY(e, t) {
-        return Ue(e.getFullYear() % 1e4, t, 4)
+    function lH(e, t) {
+        return Ge(e.getFullYear() % 1e4, t, 4)
     }
 
-    function nY(e, t) {
+    function uH(e, t) {
         var n = e.getDay();
-        return e = n >= 4 || n === 0 ? Vu(e) : Vu.ceil(e), Ue(e.getFullYear() % 1e4, t, 4)
+        return e = n >= 4 || n === 0 ? Iu(e) : Iu.ceil(e), Ge(e.getFullYear() % 1e4, t, 4)
     }
 
-    function iY(e) {
+    function cH(e) {
         var t = e.getTimezoneOffset();
-        return (t > 0 ? "-" : (t *= -1, "+")) + Ue(t / 60 | 0, "0", 2) + Ue(t % 60, "0", 2)
+        return (t > 0 ? "-" : (t *= -1, "+")) + Ge(t / 60 | 0, "0", 2) + Ge(t % 60, "0", 2)
     }
 
-    function IA(e, t) {
-        return Ue(e.getUTCDate(), t, 2)
+    function QA(e, t) {
+        return Ge(e.getUTCDate(), t, 2)
     }
 
-    function rY(e, t) {
-        return Ue(e.getUTCHours(), t, 2)
+    function fH(e, t) {
+        return Ge(e.getUTCHours(), t, 2)
     }
 
-    function aY(e, t) {
-        return Ue(e.getUTCHours() % 12 || 12, t, 2)
+    function hH(e, t) {
+        return Ge(e.getUTCHours() % 12 || 12, t, 2)
     }
 
-    function sY(e, t) {
-        return Ue(1 + Fs.count(Qr(e), e), t, 3)
+    function dH(e, t) {
+        return Ge(1 + Sa.count(qr(e), e), t, 3)
     }
 
-    function ZD(e, t) {
-        return Ue(e.getUTCMilliseconds(), t, 3)
+    function cR(e, t) {
+        return Ge(e.getUTCMilliseconds(), t, 3)
     }
 
-    function oY(e, t) {
-        return ZD(e, t) + "000"
+    function gH(e, t) {
+        return cR(e, t) + "000"
     }
 
-    function lY(e, t) {
-        return Ue(e.getUTCMonth() + 1, t, 2)
+    function pH(e, t) {
+        return Ge(e.getUTCMonth() + 1, t, 2)
     }
 
-    function uY(e, t) {
-        return Ue(e.getUTCMinutes(), t, 2)
+    function mH(e, t) {
+        return Ge(e.getUTCMinutes(), t, 2)
     }
 
-    function cY(e, t) {
-        return Ue(e.getUTCSeconds(), t, 2)
+    function yH(e, t) {
+        return Ge(e.getUTCSeconds(), t, 2)
     }
 
-    function fY(e) {
+    function vH(e) {
         var t = e.getUTCDay();
         return t === 0 ? 7 : t
     }
 
-    function hY(e, t) {
-        return Ue(Tc.count(Qr(e) - 1, e), t, 2)
+    function bH(e, t) {
+        return Ge(yc.count(qr(e) - 1, e), t, 2)
     }
 
-    function eR(e) {
+    function fR(e) {
         var t = e.getUTCDay();
-        return t >= 4 || t === 0 ? Ku(e) : Ku.ceil(e)
+        return t >= 4 || t === 0 ? zu(e) : zu.ceil(e)
     }
 
-    function dY(e, t) {
-        return e = eR(e), Ue(Ku.count(Qr(e), e) + (Qr(e).getUTCDay() === 4), t, 2)
+    function xH(e, t) {
+        return e = fR(e), Ge(zu.count(qr(e), e) + (qr(e).getUTCDay() === 4), t, 2)
     }
 
-    function gY(e) {
+    function _H(e) {
         return e.getUTCDay()
     }
 
-    function pY(e, t) {
-        return Ue(_0.count(Qr(e) - 1, e), t, 2)
+    function wH(e, t) {
+        return Ge(n0.count(qr(e) - 1, e), t, 2)
     }
 
-    function mY(e, t) {
-        return Ue(e.getUTCFullYear() % 100, t, 2)
+    function SH(e, t) {
+        return Ge(e.getUTCFullYear() % 100, t, 2)
     }
 
-    function yY(e, t) {
-        return e = eR(e), Ue(e.getUTCFullYear() % 100, t, 2)
+    function EH(e, t) {
+        return e = fR(e), Ge(e.getUTCFullYear() % 100, t, 2)
     }
 
-    function vY(e, t) {
-        return Ue(e.getUTCFullYear() % 1e4, t, 4)
+    function CH(e, t) {
+        return Ge(e.getUTCFullYear() % 1e4, t, 4)
     }
 
-    function bY(e, t) {
+    function kH(e, t) {
         var n = e.getUTCDay();
-        return e = n >= 4 || n === 0 ? Ku(e) : Ku.ceil(e), Ue(e.getUTCFullYear() % 1e4, t, 4)
+        return e = n >= 4 || n === 0 ? zu(e) : zu.ceil(e), Ge(e.getUTCFullYear() % 1e4, t, 4)
     }
 
-    function xY() {
+    function AH() {
         return "+0000"
     }
 
-    function jA() {
+    function ZA() {
         return "%"
     }
 
-    function zA(e) {
+    function e$(e) {
         return +e
     }
 
-    function BA(e) {
+    function t$(e) {
         return Math.floor(+e / 1e3)
     }
-    var ru, k_, tR, A_, nR;
-    _Y({
+    var Yl, Hx, hR, Yx, dR;
+    $H({
         dateTime: "%x, %X",
         date: "%-m/%-d/%Y",
         time: "%-I:%M:%S %p",
         periods: ["AM", "PM"],
         days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
         shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
         months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
         shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
     });
 
-    function _Y(e) {
-        return ru = KD(e), k_ = ru.format, tR = ru.parse, A_ = ru.utcFormat, nR = ru.utcParse, ru
+    function $H(e) {
+        return Yl = oR(e), Hx = Yl.format, hR = Yl.parse, Yx = Yl.utcFormat, dR = Yl.utcParse, Yl
     }
 
-    function wY(e) {
+    function TH(e) {
         return new Date(e)
     }
 
-    function SY(e) {
+    function MH(e) {
         return e instanceof Date ? +e : +new Date(+e)
     }
 
-    function T_(e, t, n, i, r, a, s, o, l, u) {
-        var c = ID(),
+    function Xx(e, t, n, i, r, s, a, o, l, u) {
+        var c = VF(),
             f = c.invert,
             h = c.domain,
             d = u(".%L"),
             g = u(":%S"),
             p = u("%I:%M"),
             m = u("%I %p"),
             y = u("%a %d"),
             v = u("%b %d"),
             b = u("%B"),
             x = u("%Y");
 
         function _(S) {
-            return (l(S) < S ? d : o(S) < S ? g : s(S) < S ? p : a(S) < S ? m : i(S) < S ? r(S) < S ? y : v : n(S) < S ? b : x)(S)
+            return (l(S) < S ? d : o(S) < S ? g : a(S) < S ? p : s(S) < S ? m : i(S) < S ? r(S) < S ? y : v : n(S) < S ? b : x)(S)
         }
         return c.invert = function(S) {
             return new Date(f(S))
         }, c.domain = function(S) {
-            return arguments.length ? h(Array.from(S, SY)) : h().map(wY)
+            return arguments.length ? h(Array.from(S, MH)) : h().map(TH)
         }, c.ticks = function(S) {
             var w = h();
             return e(w[0], w[w.length - 1], S ?? 10)
         }, c.tickFormat = function(S, w) {
             return w == null ? _ : u(w)
         }, c.nice = function(S) {
             var w = h();
-            return (!S || typeof S.range != "function") && (S = t(w[0], w[w.length - 1], S ?? 10)), S ? h(GD(w, S)) : c
+            return (!S || typeof S.range != "function") && (S = t(w[0], w[w.length - 1], S ?? 10)), S ? h(ZF(w, S)) : c
         }, c.copy = function() {
-            return md(c, T_(e, t, n, i, r, a, s, o, l, u))
+            return rd(c, Xx(e, t, n, i, r, s, a, o, l, u))
         }, c
     }
 
-    function EY() {
-        return ua.apply(T_(xH, _H, Jr, Fh, Ac, Ba, Lm, Pm, Na, k_).domain([new Date(2e3, 0, 1), new Date(2e3, 0, 2)]), arguments)
+    function OH() {
+        return ts.apply(Xx(Aq, $q, Wr, xh, mc, Os, ym, pm, ks, Hx).domain([new Date(2e3, 0, 1), new Date(2e3, 0, 2)]), arguments)
     }
 
-    function OY() {
-        return ua.apply(T_(vH, bH, Qr, Dh, Tc, Fs, Im, Nm, Na, A_).domain([Date.UTC(2e3, 0, 1), Date.UTC(2e3, 0, 2)]), arguments)
+    function FH() {
+        return ts.apply(Xx(Cq, kq, qr, _h, yc, Sa, vm, mm, ks, Yx).domain([Date.UTC(2e3, 0, 1), Date.UTC(2e3, 0, 2)]), arguments)
     }
 
-    function jm() {
+    function bm() {
         var e = 0,
             t = 1,
-            n, i, r, a, s = Jn,
+            n, i, r, s, a = Vn,
             o = !1,
             l;
 
         function u(f) {
-            return f == null || isNaN(f = +f) ? l : s(r === 0 ? .5 : (f = (a(f) - n) * r, o ? Math.max(0, Math.min(1, f)) : f))
+            return f == null || isNaN(f = +f) ? l : a(r === 0 ? .5 : (f = (s(f) - n) * r, o ? Math.max(0, Math.min(1, f)) : f))
         }
         u.domain = function(f) {
-            return arguments.length ? ([e, t] = f, n = a(e = +e), i = a(t = +t), r = n === i ? 0 : 1 / (i - n), u) : [e, t]
+            return arguments.length ? ([e, t] = f, n = s(e = +e), i = s(t = +t), r = n === i ? 0 : 1 / (i - n), u) : [e, t]
         }, u.clamp = function(f) {
             return arguments.length ? (o = !!f, u) : o
         }, u.interpolator = function(f) {
-            return arguments.length ? (s = f, u) : s
+            return arguments.length ? (a = f, u) : a
         };
 
         function c(f) {
             return function(h) {
                 var d, g;
-                return arguments.length ? ([d, g] = h, s = f(d, g), u) : [s(0), s(1)]
+                return arguments.length ? ([d, g] = h, a = f(d, g), u) : [a(0), a(1)]
             }
         }
-        return u.range = c(oo), u.rangeRound = c(ud), u.unknown = function(f) {
+        return u.range = c(Ka), u.rangeRound = c(Jh), u.unknown = function(f) {
                 return arguments.length ? (l = f, u) : l
             },
             function(f) {
-                return a = f, n = f(e), i = f(t), r = n === i ? 0 : 1 / (i - n), u
+                return s = f, n = f(e), i = f(t), r = n === i ? 0 : 1 / (i - n), u
             }
     }
 
-    function uo(e, t) {
+    function Qa(e, t) {
         return t.domain(e.domain()).interpolator(e.interpolator()).clamp(e.clamp()).unknown(e.unknown())
     }
 
-    function $_() {
-        var e = Nl(jm()(Jn));
+    function Vx() {
+        var e = Cl(bm()(Vn));
         return e.copy = function() {
-            return uo(e, $_())
-        }, lo.apply(e, arguments)
+            return Qa(e, Vx())
+        }, Ja.apply(e, arguments)
     }
 
-    function iR() {
-        var e = w_(jm()).domain([1, 10]);
+    function gR() {
+        var e = jx(bm()).domain([1, 10]);
         return e.copy = function() {
-            return uo(e, iR()).base(e.base())
-        }, lo.apply(e, arguments)
+            return Qa(e, gR()).base(e.base())
+        }, Ja.apply(e, arguments)
     }
 
-    function rR() {
-        var e = S_(jm());
+    function pR() {
+        var e = Ux(bm());
         return e.copy = function() {
-            return uo(e, rR()).constant(e.constant())
-        }, lo.apply(e, arguments)
+            return Qa(e, pR()).constant(e.constant())
+        }, Ja.apply(e, arguments)
     }
 
-    function M_() {
-        var e = E_(jm());
+    function Kx() {
+        var e = Gx(bm());
         return e.copy = function() {
-            return uo(e, M_()).exponent(e.exponent())
-        }, lo.apply(e, arguments)
+            return Qa(e, Kx()).exponent(e.exponent())
+        }, Ja.apply(e, arguments)
     }
 
-    function CY() {
-        return M_.apply(null, arguments).exponent(.5)
+    function RH() {
+        return Kx.apply(null, arguments).exponent(.5)
     }
 
-    function zm() {
+    function xm() {
         var e = 0,
             t = .5,
             n = 1,
             i = 1,
-            r, a, s, o, l, u = Jn,
+            r, s, a, o, l, u = Vn,
             c, f = !1,
             h;
 
         function d(p) {
-            return isNaN(p = +p) ? h : (p = .5 + ((p = +c(p)) - a) * (i * p < i * a ? o : l), u(f ? Math.max(0, Math.min(1, p)) : p))
+            return isNaN(p = +p) ? h : (p = .5 + ((p = +c(p)) - s) * (i * p < i * s ? o : l), u(f ? Math.max(0, Math.min(1, p)) : p))
         }
         d.domain = function(p) {
-            return arguments.length ? ([e, t, n] = p, r = c(e = +e), a = c(t = +t), s = c(n = +n), o = r === a ? 0 : .5 / (a - r), l = a === s ? 0 : .5 / (s - a), i = a < r ? -1 : 1, d) : [e, t, n]
+            return arguments.length ? ([e, t, n] = p, r = c(e = +e), s = c(t = +t), a = c(n = +n), o = r === s ? 0 : .5 / (s - r), l = s === a ? 0 : .5 / (a - s), i = s < r ? -1 : 1, d) : [e, t, n]
         }, d.clamp = function(p) {
             return arguments.length ? (f = !!p, d) : f
         }, d.interpolator = function(p) {
             return arguments.length ? (u = p, d) : u
         };
 
         function g(p) {
             return function(m) {
                 var y, v, b;
-                return arguments.length ? ([y, v, b] = m, u = s_(p, [y, v, b]), d) : [u(0), u(.5), u(1)]
+                return arguments.length ? ([y, v, b] = m, u = Cx(p, [y, v, b]), d) : [u(0), u(.5), u(1)]
             }
         }
-        return d.range = g(oo), d.rangeRound = g(ud), d.unknown = function(p) {
+        return d.range = g(Ka), d.rangeRound = g(Jh), d.unknown = function(p) {
                 return arguments.length ? (h = p, d) : h
             },
             function(p) {
-                return c = p, r = p(e), a = p(t), s = p(n), o = r === a ? 0 : .5 / (a - r), l = a === s ? 0 : .5 / (s - a), i = a < r ? -1 : 1, d
+                return c = p, r = p(e), s = p(t), a = p(n), o = r === s ? 0 : .5 / (s - r), l = s === a ? 0 : .5 / (a - s), i = s < r ? -1 : 1, d
             }
     }
 
-    function aR() {
-        var e = Nl(zm()(Jn));
+    function mR() {
+        var e = Cl(xm()(Vn));
         return e.copy = function() {
-            return uo(e, aR())
-        }, lo.apply(e, arguments)
+            return Qa(e, mR())
+        }, Ja.apply(e, arguments)
     }
 
-    function sR() {
-        var e = w_(zm()).domain([.1, 1, 10]);
+    function yR() {
+        var e = jx(xm()).domain([.1, 1, 10]);
         return e.copy = function() {
-            return uo(e, sR()).base(e.base())
-        }, lo.apply(e, arguments)
+            return Qa(e, yR()).base(e.base())
+        }, Ja.apply(e, arguments)
     }
 
-    function oR() {
-        var e = S_(zm());
+    function vR() {
+        var e = Ux(xm());
         return e.copy = function() {
-            return uo(e, oR()).constant(e.constant())
-        }, lo.apply(e, arguments)
+            return Qa(e, vR()).constant(e.constant())
+        }, Ja.apply(e, arguments)
     }
 
-    function F_() {
-        var e = E_(zm());
+    function Jx() {
+        var e = Gx(xm());
         return e.copy = function() {
-            return uo(e, F_()).exponent(e.exponent())
-        }, lo.apply(e, arguments)
+            return Qa(e, Jx()).exponent(e.exponent())
+        }, Ja.apply(e, arguments)
     }
 
-    function kY() {
-        return F_.apply(null, arguments).exponent(.5)
+    function DH() {
+        return Jx.apply(null, arguments).exponent(.5)
     }
 
-    function Xe(e) {
+    function Ye(e) {
         return function() {
             return e
         }
     }
-    const GA = Math.abs,
-        ln = Math.atan2,
-        Oo = Math.cos,
-        AY = Math.max,
-        hv = Math.min,
-        $r = Math.sin,
-        Xo = Math.sqrt,
-        un = 1e-12,
-        Ju = Math.PI,
-        w0 = Ju / 2,
-        lR = 2 * Ju;
-
-    function TY(e) {
-        return e > 1 ? 0 : e < -1 ? Ju : Math.acos(e)
+    const n$ = Math.abs,
+        an = Math.atan2,
+        ho = Math.cos,
+        NH = Math.max,
+        Wy = Math.min,
+        Cr = Math.sin,
+        Po = Math.sqrt,
+        on = 1e-12,
+        Bu = Math.PI,
+        i0 = Bu / 2,
+        bR = 2 * Bu;
+
+    function PH(e) {
+        return e > 1 ? 0 : e < -1 ? Bu : Math.acos(e)
     }
 
-    function UA(e) {
-        return e >= 1 ? w0 : e <= -1 ? -w0 : Math.asin(e)
+    function i$(e) {
+        return e >= 1 ? i0 : e <= -1 ? -i0 : Math.asin(e)
     }
 
-    function Bm(e) {
+    function _m(e) {
         let t = 3;
         return e.digits = function(n) {
             if (!arguments.length) return t;
             if (n == null) t = null;
             else {
                 const i = Math.floor(n);
                 if (!(i >= 0)) throw new RangeError(`invalid digits: ${n}`);
                 t = i
             }
             return e
-        }, () => new l_(t)
+        }, () => new Ax(t)
     }
 
-    function $Y(e) {
+    function LH(e) {
         return e.innerRadius
     }
 
-    function MY(e) {
+    function IH(e) {
         return e.outerRadius
     }
 
-    function FY(e) {
+    function zH(e) {
         return e.startAngle
     }
 
-    function DY(e) {
+    function BH(e) {
         return e.endAngle
     }
 
-    function RY(e) {
+    function jH(e) {
         return e && e.padAngle
     }
 
-    function PY(e, t, n, i, r, a, s, o) {
+    function UH(e, t, n, i, r, s, a, o) {
         var l = n - e,
             u = i - t,
-            c = s - r,
-            f = o - a,
+            c = a - r,
+            f = o - s,
             h = f * l - c * u;
-        if (!(h * h < un)) return h = (c * (t - a) - f * (e - r)) / h, [e + h * l, t + h * u]
+        if (!(h * h < on)) return h = (c * (t - s) - f * (e - r)) / h, [e + h * l, t + h * u]
     }
 
-    function Ag(e, t, n, i, r, a, s) {
+    function dg(e, t, n, i, r, s, a) {
         var o = e - n,
             l = t - i,
-            u = (s ? a : -a) / Xo(o * o + l * l),
+            u = (a ? s : -s) / Po(o * o + l * l),
             c = u * l,
             f = -u * o,
             h = e + c,
             d = t + f,
             g = n + c,
             p = i + f,
             m = (h + g) / 2,
             y = (d + p) / 2,
             v = g - h,
             b = p - d,
             x = v * v + b * b,
-            _ = r - a,
+            _ = r - s,
             S = h * p - g * d,
-            w = (b < 0 ? -1 : 1) * Xo(AY(0, _ * _ * x - S * S)),
-            O = (S * b - v * w) / x,
-            k = (-S * v - b * w) / x,
+            w = (b < 0 ? -1 : 1) * Po(NH(0, _ * _ * x - S * S)),
+            E = (S * b - v * w) / x,
+            A = (-S * v - b * w) / x,
             C = (S * b + v * w) / x,
-            E = (-S * v + b * w) / x,
-            T = O - m,
-            A = k - y,
-            F = C - m,
-            $ = E - y;
-        return T * T + A * A > F * F + $ * $ && (O = C, k = E), {
-            cx: O,
-            cy: k,
+            k = (-S * v + b * w) / x,
+            R = E - m,
+            $ = A - y,
+            T = C - m,
+            M = k - y;
+        return R * R + $ * $ > T * T + M * M && (E = C, A = k), {
+            cx: E,
+            cy: A,
             x01: -c,
             y01: -f,
-            x11: O * (r / _ - 1),
-            y11: k * (r / _ - 1)
+            x11: E * (r / _ - 1),
+            y11: A * (r / _ - 1)
         }
     }
 
-    function NY() {
-        var e = $Y,
-            t = MY,
-            n = Xe(0),
+    function GH() {
+        var e = LH,
+            t = IH,
+            n = Ye(0),
             i = null,
-            r = FY,
-            a = DY,
-            s = RY,
+            r = zH,
+            s = BH,
+            a = jH,
             o = null,
-            l = Bm(u);
+            l = _m(u);
 
         function u() {
             var c, f, h = +e.apply(this, arguments),
                 d = +t.apply(this, arguments),
-                g = r.apply(this, arguments) - w0,
-                p = a.apply(this, arguments) - w0,
-                m = GA(p - g),
+                g = r.apply(this, arguments) - i0,
+                p = s.apply(this, arguments) - i0,
+                m = n$(p - g),
                 y = p > g;
-            if (o || (o = c = l()), d < h && (f = d, d = h, h = f), !(d > un)) o.moveTo(0, 0);
-            else if (m > lR - un) o.moveTo(d * Oo(g), d * $r(g)), o.arc(0, 0, d, g, p, !y), h > un && (o.moveTo(h * Oo(p), h * $r(p)), o.arc(0, 0, h, p, g, y));
+            if (o || (o = c = l()), d < h && (f = d, d = h, h = f), !(d > on)) o.moveTo(0, 0);
+            else if (m > bR - on) o.moveTo(d * ho(g), d * Cr(g)), o.arc(0, 0, d, g, p, !y), h > on && (o.moveTo(h * ho(p), h * Cr(p)), o.arc(0, 0, h, p, g, y));
             else {
                 var v = g,
                     b = p,
                     x = g,
                     _ = p,
                     S = m,
                     w = m,
-                    O = s.apply(this, arguments) / 2,
-                    k = O > un && (i ? +i.apply(this, arguments) : Xo(h * h + d * d)),
-                    C = hv(GA(d - h) / 2, +n.apply(this, arguments)),
-                    E = C,
-                    T = C,
-                    A, F;
-                if (k > un) {
-                    var $ = UA(k / h * $r(O)),
-                        D = UA(k / d * $r(O));
-                    (S -= $ * 2) > un ? ($ *= y ? 1 : -1, x += $, _ -= $) : (S = 0, x = _ = (g + p) / 2), (w -= D * 2) > un ? (D *= y ? 1 : -1, v += D, b -= D) : (w = 0, v = b = (g + p) / 2)
-                }
-                var P = d * Oo(v),
-                    N = d * $r(v),
-                    z = h * Oo(_),
-                    I = h * $r(_);
-                if (C > un) {
-                    var ae = d * Oo(b),
-                        ye = d * $r(b),
-                        we = h * Oo(x),
-                        $e = h * $r(x),
-                        Oe;
-                    if (m < Ju)
-                        if (Oe = PY(P, N, we, $e, ae, ye, z, I)) {
-                            var Ye = P - Oe[0],
-                                St = N - Oe[1],
-                                dt = ae - Oe[0],
-                                H = ye - Oe[1],
-                                oe = 1 / $r(TY((Ye * dt + St * H) / (Xo(Ye * Ye + St * St) * Xo(dt * dt + H * H))) / 2),
-                                me = Xo(Oe[0] * Oe[0] + Oe[1] * Oe[1]);
-                            E = hv(C, (h - me) / (oe - 1)), T = hv(C, (d - me) / (oe + 1))
-                        } else E = T = 0
+                    E = a.apply(this, arguments) / 2,
+                    A = E > on && (i ? +i.apply(this, arguments) : Po(h * h + d * d)),
+                    C = Wy(n$(d - h) / 2, +n.apply(this, arguments)),
+                    k = C,
+                    R = C,
+                    $, T;
+                if (A > on) {
+                    var M = i$(A / h * Cr(E)),
+                        F = i$(A / d * Cr(E));
+                    (S -= M * 2) > on ? (M *= y ? 1 : -1, x += M, _ -= M) : (S = 0, x = _ = (g + p) / 2), (w -= F * 2) > on ? (F *= y ? 1 : -1, v += F, b -= F) : (w = 0, v = b = (g + p) / 2)
+                }
+                var N = d * ho(v),
+                    P = d * Cr(v),
+                    z = h * ho(_),
+                    I = h * Cr(_);
+                if (C > on) {
+                    var Q = d * ho(b),
+                        oe = d * Cr(b),
+                        Se = h * ho(x),
+                        ye = h * Cr(x),
+                        Pe;
+                    if (m < Bu)
+                        if (Pe = UH(N, P, Se, ye, Q, oe, z, I)) {
+                            var xt = N - Pe[0],
+                                rn = P - Pe[1],
+                                Un = Q - Pe[0],
+                                Y = oe - Pe[1],
+                                ue = 1 / Cr(PH((xt * Un + rn * Y) / (Po(xt * xt + rn * rn) * Po(Un * Un + Y * Y))) / 2),
+                                be = Po(Pe[0] * Pe[0] + Pe[1] * Pe[1]);
+                            k = Wy(C, (h - be) / (ue - 1)), R = Wy(C, (d - be) / (ue + 1))
+                        } else k = R = 0
                 }
-                w > un ? T > un ? (A = Ag(we, $e, P, N, d, T, y), F = Ag(ae, ye, z, I, d, T, y), o.moveTo(A.cx + A.x01, A.cy + A.y01), T < C ? o.arc(A.cx, A.cy, T, ln(A.y01, A.x01), ln(F.y01, F.x01), !y) : (o.arc(A.cx, A.cy, T, ln(A.y01, A.x01), ln(A.y11, A.x11), !y), o.arc(0, 0, d, ln(A.cy + A.y11, A.cx + A.x11), ln(F.cy + F.y11, F.cx + F.x11), !y), o.arc(F.cx, F.cy, T, ln(F.y11, F.x11), ln(F.y01, F.x01), !y))) : (o.moveTo(P, N), o.arc(0, 0, d, v, b, !y)) : o.moveTo(P, N), !(h > un) || !(S > un) ? o.lineTo(z, I) : E > un ? (A = Ag(z, I, ae, ye, h, -E, y), F = Ag(P, N, we, $e, h, -E, y), o.lineTo(A.cx + A.x01, A.cy + A.y01), E < C ? o.arc(A.cx, A.cy, E, ln(A.y01, A.x01), ln(F.y01, F.x01), !y) : (o.arc(A.cx, A.cy, E, ln(A.y01, A.x01), ln(A.y11, A.x11), !y), o.arc(0, 0, h, ln(A.cy + A.y11, A.cx + A.x11), ln(F.cy + F.y11, F.cx + F.x11), y), o.arc(F.cx, F.cy, E, ln(F.y11, F.x11), ln(F.y01, F.x01), !y))) : o.arc(0, 0, h, _, x, y)
+                w > on ? R > on ? ($ = dg(Se, ye, N, P, d, R, y), T = dg(Q, oe, z, I, d, R, y), o.moveTo($.cx + $.x01, $.cy + $.y01), R < C ? o.arc($.cx, $.cy, R, an($.y01, $.x01), an(T.y01, T.x01), !y) : (o.arc($.cx, $.cy, R, an($.y01, $.x01), an($.y11, $.x11), !y), o.arc(0, 0, d, an($.cy + $.y11, $.cx + $.x11), an(T.cy + T.y11, T.cx + T.x11), !y), o.arc(T.cx, T.cy, R, an(T.y11, T.x11), an(T.y01, T.x01), !y))) : (o.moveTo(N, P), o.arc(0, 0, d, v, b, !y)) : o.moveTo(N, P), !(h > on) || !(S > on) ? o.lineTo(z, I) : k > on ? ($ = dg(z, I, Q, oe, h, -k, y), T = dg(N, P, Se, ye, h, -k, y), o.lineTo($.cx + $.x01, $.cy + $.y01), k < C ? o.arc($.cx, $.cy, k, an($.y01, $.x01), an(T.y01, T.x01), !y) : (o.arc($.cx, $.cy, k, an($.y01, $.x01), an($.y11, $.x11), !y), o.arc(0, 0, h, an($.cy + $.y11, $.cx + $.x11), an(T.cy + T.y11, T.cx + T.x11), y), o.arc(T.cx, T.cy, k, an(T.y11, T.x11), an(T.y01, T.x01), !y))) : o.arc(0, 0, h, _, x, y)
             }
             if (o.closePath(), c) return o = null, c + "" || null
         }
         return u.centroid = function() {
             var c = (+e.apply(this, arguments) + +t.apply(this, arguments)) / 2,
-                f = (+r.apply(this, arguments) + +a.apply(this, arguments)) / 2 - Ju / 2;
-            return [Oo(f) * c, $r(f) * c]
+                f = (+r.apply(this, arguments) + +s.apply(this, arguments)) / 2 - Bu / 2;
+            return [ho(f) * c, Cr(f) * c]
         }, u.innerRadius = function(c) {
-            return arguments.length ? (e = typeof c == "function" ? c : Xe(+c), u) : e
+            return arguments.length ? (e = typeof c == "function" ? c : Ye(+c), u) : e
         }, u.outerRadius = function(c) {
-            return arguments.length ? (t = typeof c == "function" ? c : Xe(+c), u) : t
+            return arguments.length ? (t = typeof c == "function" ? c : Ye(+c), u) : t
         }, u.cornerRadius = function(c) {
-            return arguments.length ? (n = typeof c == "function" ? c : Xe(+c), u) : n
+            return arguments.length ? (n = typeof c == "function" ? c : Ye(+c), u) : n
         }, u.padRadius = function(c) {
-            return arguments.length ? (i = c == null ? null : typeof c == "function" ? c : Xe(+c), u) : i
+            return arguments.length ? (i = c == null ? null : typeof c == "function" ? c : Ye(+c), u) : i
         }, u.startAngle = function(c) {
-            return arguments.length ? (r = typeof c == "function" ? c : Xe(+c), u) : r
+            return arguments.length ? (r = typeof c == "function" ? c : Ye(+c), u) : r
         }, u.endAngle = function(c) {
-            return arguments.length ? (a = typeof c == "function" ? c : Xe(+c), u) : a
+            return arguments.length ? (s = typeof c == "function" ? c : Ye(+c), u) : s
         }, u.padAngle = function(c) {
-            return arguments.length ? (s = typeof c == "function" ? c : Xe(+c), u) : s
+            return arguments.length ? (a = typeof c == "function" ? c : Ye(+c), u) : a
         }, u.context = function(c) {
             return arguments.length ? (o = c ?? null, u) : o
         }, u
     }
 
-    function uR(e) {
+    function xR(e) {
         return typeof e == "object" && "length" in e ? e : Array.from(e)
     }
 
-    function cR(e) {
+    function _R(e) {
         this._context = e
     }
-    cR.prototype = {
+    _R.prototype = {
         areaStart: function() {
             this._line = 0
         },
         areaEnd: function() {
             this._line = NaN
         },
         lineStart: function() {
@@ -15022,156 +15022,156 @@
                 default:
                     this._context.lineTo(e, t);
                     break
             }
         }
     };
 
-    function D_(e) {
-        return new cR(e)
+    function Qx(e) {
+        return new _R(e)
     }
 
-    function fR(e) {
+    function wR(e) {
         return e[0]
     }
 
-    function hR(e) {
+    function SR(e) {
         return e[1]
     }
 
-    function dR(e, t) {
-        var n = Xe(!0),
+    function ER(e, t) {
+        var n = Ye(!0),
             i = null,
-            r = D_,
-            a = null,
-            s = Bm(o);
-        e = typeof e == "function" ? e : e === void 0 ? fR : Xe(e), t = typeof t == "function" ? t : t === void 0 ? hR : Xe(t);
+            r = Qx,
+            s = null,
+            a = _m(o);
+        e = typeof e == "function" ? e : e === void 0 ? wR : Ye(e), t = typeof t == "function" ? t : t === void 0 ? SR : Ye(t);
 
         function o(l) {
-            var u, c = (l = uR(l)).length,
+            var u, c = (l = xR(l)).length,
                 f, h = !1,
                 d;
-            for (i == null && (a = r(d = s())), u = 0; u <= c; ++u) !(u < c && n(f = l[u], u, l)) === h && ((h = !h) ? a.lineStart() : a.lineEnd()), h && a.point(+e(f, u, l), +t(f, u, l));
-            if (d) return a = null, d + "" || null
+            for (i == null && (s = r(d = a())), u = 0; u <= c; ++u) !(u < c && n(f = l[u], u, l)) === h && ((h = !h) ? s.lineStart() : s.lineEnd()), h && s.point(+e(f, u, l), +t(f, u, l));
+            if (d) return s = null, d + "" || null
         }
         return o.x = function(l) {
-            return arguments.length ? (e = typeof l == "function" ? l : Xe(+l), o) : e
+            return arguments.length ? (e = typeof l == "function" ? l : Ye(+l), o) : e
         }, o.y = function(l) {
-            return arguments.length ? (t = typeof l == "function" ? l : Xe(+l), o) : t
+            return arguments.length ? (t = typeof l == "function" ? l : Ye(+l), o) : t
         }, o.defined = function(l) {
-            return arguments.length ? (n = typeof l == "function" ? l : Xe(!!l), o) : n
+            return arguments.length ? (n = typeof l == "function" ? l : Ye(!!l), o) : n
         }, o.curve = function(l) {
-            return arguments.length ? (r = l, i != null && (a = r(i)), o) : r
+            return arguments.length ? (r = l, i != null && (s = r(i)), o) : r
         }, o.context = function(l) {
-            return arguments.length ? (l == null ? i = a = null : a = r(i = l), o) : i
+            return arguments.length ? (l == null ? i = s = null : s = r(i = l), o) : i
         }, o
     }
 
-    function gR(e, t, n) {
+    function CR(e, t, n) {
         var i = null,
-            r = Xe(!0),
-            a = null,
-            s = D_,
+            r = Ye(!0),
+            s = null,
+            a = Qx,
             o = null,
-            l = Bm(u);
-        e = typeof e == "function" ? e : e === void 0 ? fR : Xe(+e), t = typeof t == "function" ? t : Xe(t === void 0 ? 0 : +t), n = typeof n == "function" ? n : n === void 0 ? hR : Xe(+n);
+            l = _m(u);
+        e = typeof e == "function" ? e : e === void 0 ? wR : Ye(+e), t = typeof t == "function" ? t : Ye(t === void 0 ? 0 : +t), n = typeof n == "function" ? n : n === void 0 ? SR : Ye(+n);
 
         function u(f) {
-            var h, d, g, p = (f = uR(f)).length,
+            var h, d, g, p = (f = xR(f)).length,
                 m, y = !1,
                 v, b = new Array(p),
                 x = new Array(p);
-            for (a == null && (o = s(v = l())), h = 0; h <= p; ++h) {
+            for (s == null && (o = a(v = l())), h = 0; h <= p; ++h) {
                 if (!(h < p && r(m = f[h], h, f)) === y)
                     if (y = !y) d = h, o.areaStart(), o.lineStart();
                     else {
                         for (o.lineEnd(), o.lineStart(), g = h - 1; g >= d; --g) o.point(b[g], x[g]);
                         o.lineEnd(), o.areaEnd()
                     } y && (b[h] = +e(m, h, f), x[h] = +t(m, h, f), o.point(i ? +i(m, h, f) : b[h], n ? +n(m, h, f) : x[h]))
             }
             if (v) return o = null, v + "" || null
         }
 
         function c() {
-            return dR().defined(r).curve(s).context(a)
+            return ER().defined(r).curve(a).context(s)
         }
         return u.x = function(f) {
-            return arguments.length ? (e = typeof f == "function" ? f : Xe(+f), i = null, u) : e
+            return arguments.length ? (e = typeof f == "function" ? f : Ye(+f), i = null, u) : e
         }, u.x0 = function(f) {
-            return arguments.length ? (e = typeof f == "function" ? f : Xe(+f), u) : e
+            return arguments.length ? (e = typeof f == "function" ? f : Ye(+f), u) : e
         }, u.x1 = function(f) {
-            return arguments.length ? (i = f == null ? null : typeof f == "function" ? f : Xe(+f), u) : i
+            return arguments.length ? (i = f == null ? null : typeof f == "function" ? f : Ye(+f), u) : i
         }, u.y = function(f) {
-            return arguments.length ? (t = typeof f == "function" ? f : Xe(+f), n = null, u) : t
+            return arguments.length ? (t = typeof f == "function" ? f : Ye(+f), n = null, u) : t
         }, u.y0 = function(f) {
-            return arguments.length ? (t = typeof f == "function" ? f : Xe(+f), u) : t
+            return arguments.length ? (t = typeof f == "function" ? f : Ye(+f), u) : t
         }, u.y1 = function(f) {
-            return arguments.length ? (n = f == null ? null : typeof f == "function" ? f : Xe(+f), u) : n
+            return arguments.length ? (n = f == null ? null : typeof f == "function" ? f : Ye(+f), u) : n
         }, u.lineX0 = u.lineY0 = function() {
             return c().x(e).y(t)
         }, u.lineY1 = function() {
             return c().x(e).y(n)
         }, u.lineX1 = function() {
             return c().x(i).y(t)
         }, u.defined = function(f) {
-            return arguments.length ? (r = typeof f == "function" ? f : Xe(!!f), u) : r
+            return arguments.length ? (r = typeof f == "function" ? f : Ye(!!f), u) : r
         }, u.curve = function(f) {
-            return arguments.length ? (s = f, a != null && (o = s(a)), u) : s
+            return arguments.length ? (a = f, s != null && (o = a(s)), u) : a
         }, u.context = function(f) {
-            return arguments.length ? (f == null ? a = o = null : o = s(a = f), u) : a
+            return arguments.length ? (f == null ? s = o = null : o = a(s = f), u) : s
         }, u
     }
-    const LY = {
+    const WH = {
         draw(e, t) {
-            const n = Xo(t / Ju);
-            e.moveTo(n, 0), e.arc(0, 0, n, 0, lR)
+            const n = Po(t / Bu);
+            e.moveTo(n, 0), e.arc(0, 0, n, 0, bR)
         }
     };
 
-    function IY(e, t) {
+    function qH(e, t) {
         let n = null,
-            i = Bm(r);
-        e = typeof e == "function" ? e : Xe(e || LY), t = typeof t == "function" ? t : Xe(t === void 0 ? 64 : +t);
+            i = _m(r);
+        e = typeof e == "function" ? e : Ye(e || WH), t = typeof t == "function" ? t : Ye(t === void 0 ? 64 : +t);
 
         function r() {
-            let a;
-            if (n || (n = a = i()), e.apply(this, arguments).draw(n, +t.apply(this, arguments)), a) return n = null, a + "" || null
+            let s;
+            if (n || (n = s = i()), e.apply(this, arguments).draw(n, +t.apply(this, arguments)), s) return n = null, s + "" || null
         }
-        return r.type = function(a) {
-            return arguments.length ? (e = typeof a == "function" ? a : Xe(a), r) : e
-        }, r.size = function(a) {
-            return arguments.length ? (t = typeof a == "function" ? a : Xe(+a), r) : t
-        }, r.context = function(a) {
-            return arguments.length ? (n = a ?? null, r) : n
+        return r.type = function(s) {
+            return arguments.length ? (e = typeof s == "function" ? s : Ye(s), r) : e
+        }, r.size = function(s) {
+            return arguments.length ? (t = typeof s == "function" ? s : Ye(+s), r) : t
+        }, r.context = function(s) {
+            return arguments.length ? (n = s ?? null, r) : n
         }, r
     }
 
-    function Gs() {}
+    function Fa() {}
 
-    function S0(e, t, n) {
+    function r0(e, t, n) {
         e._context.bezierCurveTo((2 * e._x0 + e._x1) / 3, (2 * e._y0 + e._y1) / 3, (e._x0 + 2 * e._x1) / 3, (e._y0 + 2 * e._y1) / 3, (e._x0 + 4 * e._x1 + t) / 6, (e._y0 + 4 * e._y1 + n) / 6)
     }
 
-    function Gm(e) {
+    function wm(e) {
         this._context = e
     }
-    Gm.prototype = {
+    wm.prototype = {
         areaStart: function() {
             this._line = 0
         },
         areaEnd: function() {
             this._line = NaN
         },
         lineStart: function() {
             this._x0 = this._x1 = this._y0 = this._y1 = NaN, this._point = 0
         },
         lineEnd: function() {
             switch (this._point) {
                 case 3:
-                    S0(this, this._x1, this._y1);
+                    r0(this, this._x1, this._y1);
                 case 2:
                     this._context.lineTo(this._x1, this._y1);
                     break
             }(this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line
         },
         point: function(e, t) {
             switch (e = +e, t = +t, this._point) {
@@ -15180,31 +15180,31 @@
                     break;
                 case 1:
                     this._point = 2;
                     break;
                 case 2:
                     this._point = 3, this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6);
                 default:
-                    S0(this, e, t);
+                    r0(this, e, t);
                     break
             }
             this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t
         }
     };
 
-    function jY(e) {
-        return new Gm(e)
+    function HH(e) {
+        return new wm(e)
     }
 
-    function pR(e) {
+    function kR(e) {
         this._context = e
     }
-    pR.prototype = {
-        areaStart: Gs,
-        areaEnd: Gs,
+    kR.prototype = {
+        areaStart: Fa,
+        areaEnd: Fa,
         lineStart: function() {
             this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN, this._point = 0
         },
         lineEnd: function() {
             switch (this._point) {
                 case 1: {
                     this._context.moveTo(this._x2, this._y2), this._context.closePath();
@@ -15228,29 +15228,29 @@
                 case 1:
                     this._point = 2, this._x3 = e, this._y3 = t;
                     break;
                 case 2:
                     this._point = 3, this._x4 = e, this._y4 = t, this._context.moveTo((this._x0 + 4 * this._x1 + e) / 6, (this._y0 + 4 * this._y1 + t) / 6);
                     break;
                 default:
-                    S0(this, e, t);
+                    r0(this, e, t);
                     break
             }
             this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t
         }
     };
 
-    function zY(e) {
-        return new pR(e)
+    function YH(e) {
+        return new kR(e)
     }
 
-    function mR(e) {
+    function AR(e) {
         this._context = e
     }
-    mR.prototype = {
+    AR.prototype = {
         areaStart: function() {
             this._line = 0
         },
         areaEnd: function() {
             this._line = NaN
         },
         lineStart: function() {
@@ -15272,61 +15272,61 @@
                     var n = (this._x0 + 4 * this._x1 + e) / 6,
                         i = (this._y0 + 4 * this._y1 + t) / 6;
                     this._line ? this._context.lineTo(n, i) : this._context.moveTo(n, i);
                     break;
                 case 3:
                     this._point = 4;
                 default:
-                    S0(this, e, t);
+                    r0(this, e, t);
                     break
             }
             this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t
         }
     };
 
-    function BY(e) {
-        return new mR(e)
+    function XH(e) {
+        return new AR(e)
     }
 
-    function yR(e, t) {
-        this._basis = new Gm(e), this._beta = t
+    function $R(e, t) {
+        this._basis = new wm(e), this._beta = t
     }
-    yR.prototype = {
+    $R.prototype = {
         lineStart: function() {
             this._x = [], this._y = [], this._basis.lineStart()
         },
         lineEnd: function() {
             var e = this._x,
                 t = this._y,
                 n = e.length - 1;
             if (n > 0)
-                for (var i = e[0], r = t[0], a = e[n] - i, s = t[n] - r, o = -1, l; ++o <= n;) l = o / n, this._basis.point(this._beta * e[o] + (1 - this._beta) * (i + l * a), this._beta * t[o] + (1 - this._beta) * (r + l * s));
+                for (var i = e[0], r = t[0], s = e[n] - i, a = t[n] - r, o = -1, l; ++o <= n;) l = o / n, this._basis.point(this._beta * e[o] + (1 - this._beta) * (i + l * s), this._beta * t[o] + (1 - this._beta) * (r + l * a));
             this._x = this._y = null, this._basis.lineEnd()
         },
         point: function(e, t) {
             this._x.push(+e), this._y.push(+t)
         }
     };
-    const GY = function e(t) {
+    const VH = function e(t) {
         function n(i) {
-            return t === 1 ? new Gm(i) : new yR(i, t)
+            return t === 1 ? new wm(i) : new $R(i, t)
         }
         return n.beta = function(i) {
             return e(+i)
         }, n
     }(.85);
 
-    function E0(e, t, n) {
+    function s0(e, t, n) {
         e._context.bezierCurveTo(e._x1 + e._k * (e._x2 - e._x0), e._y1 + e._k * (e._y2 - e._y0), e._x2 + e._k * (e._x1 - t), e._y2 + e._k * (e._y1 - n), e._x2, e._y2)
     }
 
-    function R_(e, t) {
+    function Zx(e, t) {
         this._context = e, this._k = (1 - t) / 6
     }
-    R_.prototype = {
+    Zx.prototype = {
         areaStart: function() {
             this._line = 0
         },
         areaEnd: function() {
             this._line = NaN
         },
         lineStart: function() {
@@ -15334,50 +15334,50 @@
         },
         lineEnd: function() {
             switch (this._point) {
                 case 2:
                     this._context.lineTo(this._x2, this._y2);
                     break;
                 case 3:
-                    E0(this, this._x1, this._y1);
+                    s0(this, this._x1, this._y1);
                     break
             }(this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line
         },
         point: function(e, t) {
             switch (e = +e, t = +t, this._point) {
                 case 0:
                     this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
                     break;
                 case 1:
                     this._point = 2, this._x1 = e, this._y1 = t;
                     break;
                 case 2:
                     this._point = 3;
                 default:
-                    E0(this, e, t);
+                    s0(this, e, t);
                     break
             }
             this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t
         }
     };
-    const UY = function e(t) {
+    const KH = function e(t) {
         function n(i) {
-            return new R_(i, t)
+            return new Zx(i, t)
         }
         return n.tension = function(i) {
             return e(+i)
         }, n
     }(0);
 
-    function P_(e, t) {
+    function e_(e, t) {
         this._context = e, this._k = (1 - t) / 6
     }
-    P_.prototype = {
-        areaStart: Gs,
-        areaEnd: Gs,
+    e_.prototype = {
+        areaStart: Fa,
+        areaEnd: Fa,
         lineStart: function() {
             this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN, this._point = 0
         },
         lineEnd: function() {
             switch (this._point) {
                 case 1: {
                     this._context.moveTo(this._x3, this._y3), this._context.closePath();
@@ -15401,33 +15401,33 @@
                 case 1:
                     this._point = 2, this._context.moveTo(this._x4 = e, this._y4 = t);
                     break;
                 case 2:
                     this._point = 3, this._x5 = e, this._y5 = t;
                     break;
                 default:
-                    E0(this, e, t);
+                    s0(this, e, t);
                     break
             }
             this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t
         }
     };
-    const qY = function e(t) {
+    const JH = function e(t) {
         function n(i) {
-            return new P_(i, t)
+            return new e_(i, t)
         }
         return n.tension = function(i) {
             return e(+i)
         }, n
     }(0);
 
-    function N_(e, t) {
+    function t_(e, t) {
         this._context = e, this._k = (1 - t) / 6
     }
-    N_.prototype = {
+    t_.prototype = {
         areaStart: function() {
             this._line = 0
         },
         areaEnd: function() {
             this._line = NaN
         },
         lineStart: function() {
@@ -15446,51 +15446,51 @@
                     break;
                 case 2:
                     this._point = 3, this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
                     break;
                 case 3:
                     this._point = 4;
                 default:
-                    E0(this, e, t);
+                    s0(this, e, t);
                     break
             }
             this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t
         }
     };
-    const WY = function e(t) {
+    const QH = function e(t) {
         function n(i) {
-            return new N_(i, t)
+            return new t_(i, t)
         }
         return n.tension = function(i) {
             return e(+i)
         }, n
     }(0);
 
-    function L_(e, t, n) {
+    function n_(e, t, n) {
         var i = e._x1,
             r = e._y1,
-            a = e._x2,
-            s = e._y2;
-        if (e._l01_a > un) {
+            s = e._x2,
+            a = e._y2;
+        if (e._l01_a > on) {
             var o = 2 * e._l01_2a + 3 * e._l01_a * e._l12_a + e._l12_2a,
                 l = 3 * e._l01_a * (e._l01_a + e._l12_a);
             i = (i * o - e._x0 * e._l12_2a + e._x2 * e._l01_2a) / l, r = (r * o - e._y0 * e._l12_2a + e._y2 * e._l01_2a) / l
         }
-        if (e._l23_a > un) {
+        if (e._l23_a > on) {
             var u = 2 * e._l23_2a + 3 * e._l23_a * e._l12_a + e._l12_2a,
                 c = 3 * e._l23_a * (e._l23_a + e._l12_a);
-            a = (a * u + e._x1 * e._l23_2a - t * e._l12_2a) / c, s = (s * u + e._y1 * e._l23_2a - n * e._l12_2a) / c
+            s = (s * u + e._x1 * e._l23_2a - t * e._l12_2a) / c, a = (a * u + e._y1 * e._l23_2a - n * e._l12_2a) / c
         }
-        e._context.bezierCurveTo(i, r, a, s, e._x2, e._y2)
+        e._context.bezierCurveTo(i, r, s, a, e._x2, e._y2)
     }
 
-    function vR(e, t) {
+    function TR(e, t) {
         this._context = e, this._alpha = t
     }
-    vR.prototype = {
+    TR.prototype = {
         areaStart: function() {
             this._line = 0
         },
         areaEnd: function() {
             this._line = NaN
         },
         lineStart: function() {
@@ -15518,35 +15518,35 @@
                     break;
                 case 1:
                     this._point = 2;
                     break;
                 case 2:
                     this._point = 3;
                 default:
-                    L_(this, e, t);
+                    n_(this, e, t);
                     break
             }
             this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t
         }
     };
-    const HY = function e(t) {
+    const ZH = function e(t) {
         function n(i) {
-            return t ? new vR(i, t) : new R_(i, 0)
+            return t ? new TR(i, t) : new Zx(i, 0)
         }
         return n.alpha = function(i) {
             return e(+i)
         }, n
     }(.5);
 
-    function bR(e, t) {
+    function MR(e, t) {
         this._context = e, this._alpha = t
     }
-    bR.prototype = {
-        areaStart: Gs,
-        areaEnd: Gs,
+    MR.prototype = {
+        areaStart: Fa,
+        areaEnd: Fa,
         lineStart: function() {
             this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0
         },
         lineEnd: function() {
             switch (this._point) {
                 case 1: {
                     this._context.moveTo(this._x3, this._y3), this._context.closePath();
@@ -15575,33 +15575,33 @@
                 case 1:
                     this._point = 2, this._context.moveTo(this._x4 = e, this._y4 = t);
                     break;
                 case 2:
                     this._point = 3, this._x5 = e, this._y5 = t;
                     break;
                 default:
-                    L_(this, e, t);
+                    n_(this, e, t);
                     break
             }
             this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t
         }
     };
-    const YY = function e(t) {
+    const eY = function e(t) {
         function n(i) {
-            return t ? new bR(i, t) : new P_(i, 0)
+            return t ? new MR(i, t) : new e_(i, 0)
         }
         return n.alpha = function(i) {
             return e(+i)
         }, n
     }(.5);
 
-    function xR(e, t) {
+    function OR(e, t) {
         this._context = e, this._alpha = t
     }
-    xR.prototype = {
+    OR.prototype = {
         areaStart: function() {
             this._line = 0
         },
         areaEnd: function() {
             this._line = NaN
         },
         lineStart: function() {
@@ -15625,81 +15625,81 @@
                     break;
                 case 2:
                     this._point = 3, this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
                     break;
                 case 3:
                     this._point = 4;
                 default:
-                    L_(this, e, t);
+                    n_(this, e, t);
                     break
             }
             this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t
         }
     };
-    const XY = function e(t) {
+    const tY = function e(t) {
         function n(i) {
-            return t ? new xR(i, t) : new N_(i, 0)
+            return t ? new OR(i, t) : new t_(i, 0)
         }
         return n.alpha = function(i) {
             return e(+i)
         }, n
     }(.5);
 
-    function _R(e) {
+    function FR(e) {
         this._context = e
     }
-    _R.prototype = {
-        areaStart: Gs,
-        areaEnd: Gs,
+    FR.prototype = {
+        areaStart: Fa,
+        areaEnd: Fa,
         lineStart: function() {
             this._point = 0
         },
         lineEnd: function() {
             this._point && this._context.closePath()
         },
         point: function(e, t) {
             e = +e, t = +t, this._point ? this._context.lineTo(e, t) : (this._point = 1, this._context.moveTo(e, t))
         }
     };
 
-    function VY(e) {
-        return new _R(e)
+    function nY(e) {
+        return new FR(e)
     }
 
-    function qA(e) {
+    function r$(e) {
         return e < 0 ? -1 : 1
     }
 
-    function WA(e, t, n) {
+    function s$(e, t, n) {
         var i = e._x1 - e._x0,
             r = t - e._x1,
-            a = (e._y1 - e._y0) / (i || r < 0 && -0),
-            s = (n - e._y1) / (r || i < 0 && -0),
-            o = (a * r + s * i) / (i + r);
-        return (qA(a) + qA(s)) * Math.min(Math.abs(a), Math.abs(s), .5 * Math.abs(o)) || 0
+            s = (e._y1 - e._y0) / (i || r < 0 && -0),
+            a = (n - e._y1) / (r || i < 0 && -0),
+            o = (s * r + a * i) / (i + r);
+        return (r$(s) + r$(a)) * Math.min(Math.abs(s), Math.abs(a), .5 * Math.abs(o)) || 0
     }
 
-    function HA(e, t) {
+    function a$(e, t) {
         var n = e._x1 - e._x0;
         return n ? (3 * (e._y1 - e._y0) / n - t) / 2 : t
     }
 
-    function dv(e, t, n) {
+    function qy(e, t, n) {
         var i = e._x0,
             r = e._y0,
-            a = e._x1,
-            s = e._y1,
-            o = (a - i) / 3;
-        e._context.bezierCurveTo(i + o, r + o * t, a - o, s - o * n, a, s)
+            s = e._x1,
+            a = e._y1,
+            o = (s - i) / 3;
+        e._context.bezierCurveTo(i + o, r + o * t, s - o, a - o * n, s, a)
     }
 
-    function O0(e) {
+    function a0(e) {
         this._context = e
     }
-    O0.prototype = {
+    a0.prototype = {
         areaStart: function() {
             this._line = 0
         },
         areaEnd: function() {
             this._line = NaN
         },
         lineStart: function() {
@@ -15707,76 +15707,76 @@
         },
         lineEnd: function() {
             switch (this._point) {
                 case 2:
                     this._context.lineTo(this._x1, this._y1);
                     break;
                 case 3:
-                    dv(this, this._t0, HA(this, this._t0));
+                    qy(this, this._t0, a$(this, this._t0));
                     break
             }(this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line
         },
         point: function(e, t) {
             var n = NaN;
             if (e = +e, t = +t, !(e === this._x1 && t === this._y1)) {
                 switch (this._point) {
                     case 0:
                         this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
                         break;
                     case 1:
                         this._point = 2;
                         break;
                     case 2:
-                        this._point = 3, dv(this, HA(this, n = WA(this, e, t)), n);
+                        this._point = 3, qy(this, a$(this, n = s$(this, e, t)), n);
                         break;
                     default:
-                        dv(this, this._t0, n = WA(this, e, t));
+                        qy(this, this._t0, n = s$(this, e, t));
                         break
                 }
                 this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t, this._t0 = n
             }
         }
     };
 
-    function wR(e) {
-        this._context = new SR(e)
-    }(wR.prototype = Object.create(O0.prototype)).point = function(e, t) {
-        O0.prototype.point.call(this, t, e)
+    function RR(e) {
+        this._context = new DR(e)
+    }(RR.prototype = Object.create(a0.prototype)).point = function(e, t) {
+        a0.prototype.point.call(this, t, e)
     };
 
-    function SR(e) {
+    function DR(e) {
         this._context = e
     }
-    SR.prototype = {
+    DR.prototype = {
         moveTo: function(e, t) {
             this._context.moveTo(t, e)
         },
         closePath: function() {
             this._context.closePath()
         },
         lineTo: function(e, t) {
             this._context.lineTo(t, e)
         },
-        bezierCurveTo: function(e, t, n, i, r, a) {
-            this._context.bezierCurveTo(t, e, i, n, a, r)
+        bezierCurveTo: function(e, t, n, i, r, s) {
+            this._context.bezierCurveTo(t, e, i, n, s, r)
         }
     };
 
-    function KY(e) {
-        return new O0(e)
+    function iY(e) {
+        return new a0(e)
     }
 
-    function JY(e) {
-        return new wR(e)
+    function rY(e) {
+        return new RR(e)
     }
 
-    function ER(e) {
+    function NR(e) {
         this._context = e
     }
-    ER.prototype = {
+    NR.prototype = {
         areaStart: function() {
             this._line = 0
         },
         areaEnd: function() {
             this._line = NaN
         },
         lineStart: function() {
@@ -15785,42 +15785,42 @@
         lineEnd: function() {
             var e = this._x,
                 t = this._y,
                 n = e.length;
             if (n)
                 if (this._line ? this._context.lineTo(e[0], t[0]) : this._context.moveTo(e[0], t[0]), n === 2) this._context.lineTo(e[1], t[1]);
                 else
-                    for (var i = YA(e), r = YA(t), a = 0, s = 1; s < n; ++a, ++s) this._context.bezierCurveTo(i[0][a], r[0][a], i[1][a], r[1][a], e[s], t[s]);
+                    for (var i = o$(e), r = o$(t), s = 0, a = 1; a < n; ++s, ++a) this._context.bezierCurveTo(i[0][s], r[0][s], i[1][s], r[1][s], e[a], t[a]);
             (this._line || this._line !== 0 && n === 1) && this._context.closePath(), this._line = 1 - this._line, this._x = this._y = null
         },
         point: function(e, t) {
             this._x.push(+e), this._y.push(+t)
         }
     };
 
-    function YA(e) {
+    function o$(e) {
         var t, n = e.length - 1,
             i, r = new Array(n),
-            a = new Array(n),
-            s = new Array(n);
-        for (r[0] = 0, a[0] = 2, s[0] = e[0] + 2 * e[1], t = 1; t < n - 1; ++t) r[t] = 1, a[t] = 4, s[t] = 4 * e[t] + 2 * e[t + 1];
-        for (r[n - 1] = 2, a[n - 1] = 7, s[n - 1] = 8 * e[n - 1] + e[n], t = 1; t < n; ++t) i = r[t] / a[t - 1], a[t] -= i, s[t] -= i * s[t - 1];
-        for (r[n - 1] = s[n - 1] / a[n - 1], t = n - 2; t >= 0; --t) r[t] = (s[t] - r[t + 1]) / a[t];
-        for (a[n - 1] = (e[n] + r[n - 1]) / 2, t = 0; t < n - 1; ++t) a[t] = 2 * e[t + 1] - r[t + 1];
-        return [r, a]
+            s = new Array(n),
+            a = new Array(n);
+        for (r[0] = 0, s[0] = 2, a[0] = e[0] + 2 * e[1], t = 1; t < n - 1; ++t) r[t] = 1, s[t] = 4, a[t] = 4 * e[t] + 2 * e[t + 1];
+        for (r[n - 1] = 2, s[n - 1] = 7, a[n - 1] = 8 * e[n - 1] + e[n], t = 1; t < n; ++t) i = r[t] / s[t - 1], s[t] -= i, a[t] -= i * a[t - 1];
+        for (r[n - 1] = a[n - 1] / s[n - 1], t = n - 2; t >= 0; --t) r[t] = (a[t] - r[t + 1]) / s[t];
+        for (s[n - 1] = (e[n] + r[n - 1]) / 2, t = 0; t < n - 1; ++t) s[t] = 2 * e[t + 1] - r[t + 1];
+        return [r, s]
     }
 
-    function QY(e) {
-        return new ER(e)
+    function sY(e) {
+        return new NR(e)
     }
 
-    function Um(e, t) {
+    function Sm(e, t) {
         this._context = e, this._t = t
     }
-    Um.prototype = {
+    Sm.prototype = {
         areaStart: function() {
             this._line = 0
         },
         areaEnd: function() {
             this._line = NaN
         },
         lineStart: function() {
@@ -15845,36 +15845,36 @@
                     break
                 }
             }
             this._x = e, this._y = t
         }
     };
 
-    function ZY(e) {
-        return new Um(e, .5)
+    function aY(e) {
+        return new Sm(e, .5)
     }
 
-    function eX(e) {
-        return new Um(e, 0)
+    function oY(e) {
+        return new Sm(e, 0)
     }
 
-    function tX(e) {
-        return new Um(e, 1)
+    function lY(e) {
+        return new Sm(e, 1)
     }
 
-    function Uf(e, t, n) {
+    function Of(e, t, n) {
         this.k = e, this.x = t, this.y = n
     }
-    Uf.prototype = {
-        constructor: Uf,
+    Of.prototype = {
+        constructor: Of,
         scale: function(e) {
-            return e === 1 ? this : new Uf(this.k * e, this.x, this.y)
+            return e === 1 ? this : new Of(this.k * e, this.x, this.y)
         },
         translate: function(e, t) {
-            return e === 0 & t === 0 ? this : new Uf(this.k, this.x + this.k * e, this.y + this.k * t)
+            return e === 0 & t === 0 ? this : new Of(this.k, this.x + this.k * e, this.y + this.k * t)
         },
         apply: function(e) {
             return [e[0] * this.k + this.x, e[1] * this.k + this.y]
         },
         applyX: function(e) {
             return e * this.k + this.x
         },
@@ -15896,668 +15896,668 @@
         rescaleY: function(e) {
             return e.copy().domain(e.range().map(this.invertY, this).map(e.invert, e))
         },
         toString: function() {
             return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")"
         }
     };
-    Uf.prototype;
+    Of.prototype;
     /**
     @copyright CEA-LIST/DIASI/SIALV/LVA (2023)
     @author CEA-LIST/DIASI/SIALV/LVA <pixano@cea.fr>
     @license CECILL-C
 
     This software is a collaborative computer program whose purpose is to
     generate and explore labeled data for computer vision applications.
     This software is governed by the CeCILL-C license under French law and
     abiding by the rules of distribution of free software. You can use, 
     modify and/ or redistribute the software under the terms of the CeCILL-C
     license as circulated by CEA, CNRS and INRIA at the following URL
 
     http://www.cecill.info
     */
-    function nX(e) {
-        return Dm().domain(e).range(EB)
+    function uY(e) {
+        return dm().domain(e).range(OB)
     }
 
-    function XA(e, t, n) {
+    function l$(e, t, n) {
         const i = e.slice();
         return i[23] = t[n], i
     }
 
-    function VA(e, t, n) {
+    function u$(e, t, n) {
         const i = e.slice();
         return i[26] = t[n], i
     }
 
-    function KA(e) {
-        let t, n, i, r, a = e[0].id + "",
-            s;
+    function c$(e) {
+        let t, n, i, r, s = e[0].id + "",
+            a;
         return {
             c() {
-                t = K("div"), n = K("span"), n.textContent = "Id :", i = Se(), r = K("span"), s = Qe(a), B(n, "class", "font-bold")
+                t = J("div"), n = J("span"), n.textContent = "Id :", i = Ee(), r = J("span"), a = Je(s), j(n, "class", "font-bold")
             },
             m(o, l) {
-                _e(o, t, l), U(t, n), U(t, i), U(t, r), U(r, s)
+                we(o, t, l), G(t, n), G(t, i), G(t, r), G(r, a)
             },
             p(o, l) {
-                l & 1 && a !== (a = o[0].id + "") && Pt(s, a)
+                l & 1 && s !== (s = o[0].id + "") && Ot(a, s)
             },
             d(o) {
-                o && xe(t)
+                o && _e(t)
             }
         }
     }
 
-    function JA(e) {
-        let t, n, i, r, a = e[0].filename + "",
-            s;
+    function f$(e) {
+        let t, n, i, r, s = e[0].filename + "",
+            a;
         return {
             c() {
-                t = K("div"), n = K("span"), n.textContent = "Filename :", i = Se(), r = K("span"), s = Qe(a), B(n, "class", "font-bold")
+                t = J("div"), n = J("span"), n.textContent = "Filename :", i = Ee(), r = J("span"), a = Je(s), j(n, "class", "font-bold")
             },
             m(o, l) {
-                _e(o, t, l), U(t, n), U(t, i), U(t, r), U(r, s)
+                we(o, t, l), G(t, n), G(t, i), G(t, r), G(r, a)
             },
             p(o, l) {
-                l & 1 && a !== (a = o[0].filename + "") && Pt(s, a)
+                l & 1 && s !== (s = o[0].filename + "") && Ot(a, s)
             },
             d(o) {
-                o && xe(t)
+                o && _e(t)
             }
         }
     }
 
-    function QA(e) {
-        let t, n, i, r, a = e[0].width + "",
-            s, o, l = e[0].height + "",
+    function h$(e) {
+        let t, n, i, r, s = e[0].width + "",
+            a, o, l = e[0].height + "",
             u, c;
         return {
             c() {
-                t = K("div"), n = K("span"), n.textContent = "Size :", i = Se(), r = K("span"), s = Qe(a), o = Qe("x"), u = Qe(l), c = Qe("px"), B(n, "class", "font-bold")
+                t = J("div"), n = J("span"), n.textContent = "Size :", i = Ee(), r = J("span"), a = Je(s), o = Je("x"), u = Je(l), c = Je("px"), j(n, "class", "font-bold")
             },
             m(f, h) {
-                _e(f, t, h), U(t, n), U(t, i), U(t, r), U(r, s), U(r, o), U(r, u), U(r, c)
+                we(f, t, h), G(t, n), G(t, i), G(t, r), G(r, a), G(r, o), G(r, u), G(r, c)
             },
             p(f, h) {
-                h & 1 && a !== (a = f[0].width + "") && Pt(s, a), h & 1 && l !== (l = f[0].height + "") && Pt(u, l)
+                h & 1 && s !== (s = f[0].width + "") && Ot(a, s), h & 1 && l !== (l = f[0].height + "") && Ot(u, l)
             },
             d(f) {
-                f && xe(t)
+                f && _e(t)
             }
         }
     }
 
-    function ZA(e) {
+    function d$(e) {
         let t, n = e[0].categoryStats,
             i = [];
-        for (let r = 0; r < n.length; r += 1) i[r] = tT(VA(e, n, r));
+        for (let r = 0; r < n.length; r += 1) i[r] = p$(u$(e, n, r));
         return {
             c() {
                 for (let r = 0; r < i.length; r += 1) i[r].c();
-                t = $l()
+                t = bl()
             },
-            m(r, a) {
-                for (let s = 0; s < i.length; s += 1) i[s] && i[s].m(r, a);
-                _e(r, t, a)
+            m(r, s) {
+                for (let a = 0; a < i.length; a += 1) i[a] && i[a].m(r, s);
+                we(r, t, s)
             },
-            p(r, a) {
-                if (a & 67) {
+            p(r, s) {
+                if (s & 67) {
                     n = r[0].categoryStats;
-                    let s;
-                    for (s = 0; s < n.length; s += 1) {
-                        const o = VA(r, n, s);
-                        i[s] ? i[s].p(o, a) : (i[s] = tT(o), i[s].c(), i[s].m(t.parentNode, t))
+                    let a;
+                    for (a = 0; a < n.length; a += 1) {
+                        const o = u$(r, n, a);
+                        i[a] ? i[a].p(o, s) : (i[a] = p$(o), i[a].c(), i[a].m(t.parentNode, t))
                     }
-                    for (; s < i.length; s += 1) i[s].d(1);
+                    for (; a < i.length; a += 1) i[a].d(1);
                     i.length = n.length
                 }
             },
             d(r) {
-                ol(i, r), r && xe(t)
+                Vo(i, r), r && _e(t)
             }
         }
     }
 
-    function eT(e) {
+    function g$(e) {
         let t, n = e[26].count + "",
             i;
         return {
             c() {
-                t = K("span"), i = Qe(n), B(t, "class", "block absolute -right-3 -top-2 h-fit px-1 text-xs rounded-full bg-rose-500 text-white font-bold")
+                t = J("span"), i = Je(n), j(t, "class", "block absolute -right-3 -top-2 h-fit px-1 text-xs rounded-full bg-rose-500 text-white font-bold")
             },
-            m(r, a) {
-                _e(r, t, a), U(t, i)
+            m(r, s) {
+                we(r, t, s), G(t, i)
             },
-            p(r, a) {
-                a & 1 && n !== (n = r[26].count + "") && Pt(i, n)
+            p(r, s) {
+                s & 1 && n !== (n = r[26].count + "") && Ot(i, n)
             },
             d(r) {
-                r && xe(t)
+                r && _e(t)
             }
         }
     }
 
-    function tT(e) {
+    function p$(e) {
         let t, n = e[26].name + "",
-            i, r, a, s, o, l, u = e[26].count != 1 && eT(e);
+            i, r, s, a, o, l, u = e[26].count != 1 && g$(e);
 
         function c() {
             return e[14](e[26])
         }
         return {
             c() {
-                t = K("button"), i = Qe(n), r = Se(), u && u.c(), a = Se(), B(t, "class", "relative px-1 mb-2 mr-4 rounded-lg text-sm text-zinc-900 font-bold border-2 border-transparent hover:border-rose-500"), NC(t, "background-color", e[1](e[26].id)), B(t, "id", s = "cat-" + e[26].id)
+                t = J("button"), i = Je(n), r = Ee(), u && u.c(), s = Ee(), j(t, "class", "relative px-1 mb-2 mr-4 rounded-lg text-sm text-zinc-900 font-bold border-2 border-transparent hover:border-rose-500"), KC(t, "background-color", e[1](e[26].id)), j(t, "id", a = "cat-" + e[26].id)
             },
             m(f, h) {
-                _e(f, t, h), U(t, i), U(t, r), u && u.m(t, null), U(t, a), o || (l = Ot(t, "click", c), o = !0)
+                we(f, t, h), G(t, i), G(t, r), u && u.m(t, null), G(t, s), o || (l = wt(t, "click", c), o = !0)
             },
             p(f, h) {
-                e = f, h & 1 && n !== (n = e[26].name + "") && Pt(i, n), e[26].count != 1 ? u ? u.p(e, h) : (u = eT(e), u.c(), u.m(t, a)) : u && (u.d(1), u = null), h & 3 && NC(t, "background-color", e[1](e[26].id)), h & 1 && s !== (s = "cat-" + e[26].id) && B(t, "id", s)
+                e = f, h & 1 && n !== (n = e[26].name + "") && Ot(i, n), e[26].count != 1 ? u ? u.p(e, h) : (u = g$(e), u.c(), u.m(t, s)) : u && (u.d(1), u = null), h & 3 && KC(t, "background-color", e[1](e[26].id)), h & 1 && a !== (a = "cat-" + e[26].id) && j(t, "id", a)
             },
             d(f) {
-                f && xe(t), u && u.d(), o = !1, l()
+                f && _e(t), u && u.d(), o = !1, l()
             }
         }
     }
 
-    function nT(e) {
-        let t, n, i, r, a, s, o, l, u, c, f, h, d, g = e[1] != null && iT(e);
+    function m$(e) {
+        let t, n, i, r, s, a, o, l, u, c, f, h, d, g = e[1] != null && y$(e);
         return {
             c() {
-                t = K("div"), n = K("span"), n.textContent = "Views", i = Se(), r = K("div"), a = K("input"), s = Se(), o = K("label"), o.textContent = "Show all views", l = Se(), u = K("span"), u.textContent = "Views :", c = Se(), f = K("div"), g && g.c(), B(n, "class", "mb-2 self-center text-center text-sm text-zinc-500 font-medium uppercase dark:text-zinc-400"), B(a, "class", "cursor-pointer checked:accent-rose-500"), B(a, "type", "checkbox"), B(a, "id", "toggle-views"), a.checked = !0, B(o, "class", "font-bold cursor-pointer"), B(o, "for", "toggle-views"), B(r, "class", "mb-2 flex items-center space-x-2"), B(t, "class", "mt-2 pt-2 flex flex-col border-t dark:border-zinc-700"), B(u, "class", "font-bold"), B(f, "class", "flex flex-col")
+                t = J("div"), n = J("span"), n.textContent = "Views", i = Ee(), r = J("div"), s = J("input"), a = Ee(), o = J("label"), o.textContent = "Show all views", l = Ee(), u = J("span"), u.textContent = "Views :", c = Ee(), f = J("div"), g && g.c(), j(n, "class", "mb-2 self-center text-center text-sm text-zinc-500 font-medium uppercase dark:text-zinc-400"), j(s, "class", "cursor-pointer checked:accent-rose-500"), j(s, "type", "checkbox"), j(s, "id", "toggle-views"), s.checked = !0, j(o, "class", "font-bold cursor-pointer"), j(o, "for", "toggle-views"), j(r, "class", "mb-2 flex items-center space-x-2"), j(t, "class", "mt-2 pt-2 flex flex-col border-t dark:border-zinc-700"), j(u, "class", "font-bold"), j(f, "class", "flex flex-col")
             },
             m(p, m) {
-                _e(p, t, m), U(t, n), U(t, i), U(t, r), U(r, a), U(r, s), U(r, o), _e(p, l, m), _e(p, u, m), _e(p, c, m), _e(p, f, m), g && g.m(f, null), h || (d = Ot(a, "change", e[9]), h = !0)
+                we(p, t, m), G(t, n), G(t, i), G(t, r), G(r, s), G(r, a), G(r, o), we(p, l, m), we(p, u, m), we(p, c, m), we(p, f, m), g && g.m(f, null), h || (d = wt(s, "change", e[9]), h = !0)
             },
             p(p, m) {
-                p[1] != null ? g ? g.p(p, m) : (g = iT(p), g.c(), g.m(f, null)) : g && (g.d(1), g = null)
+                p[1] != null ? g ? g.p(p, m) : (g = y$(p), g.c(), g.m(f, null)) : g && (g.d(1), g = null)
             },
             d(p) {
-                p && xe(t), p && xe(l), p && xe(u), p && xe(c), p && xe(f), g && g.d(), h = !1, d()
+                p && _e(t), p && _e(l), p && _e(u), p && _e(c), p && _e(f), g && g.d(), h = !1, d()
             }
         }
     }
 
-    function iT(e) {
+    function y$(e) {
         let t, n = Object.keys(e[0].views),
             i = [];
-        for (let r = 0; r < n.length; r += 1) i[r] = rT(XA(e, n, r));
+        for (let r = 0; r < n.length; r += 1) i[r] = v$(l$(e, n, r));
         return {
             c() {
                 for (let r = 0; r < i.length; r += 1) i[r].c();
-                t = $l()
+                t = bl()
             },
-            m(r, a) {
-                for (let s = 0; s < i.length; s += 1) i[s] && i[s].m(r, a);
-                _e(r, t, a)
+            m(r, s) {
+                for (let a = 0; a < i.length; a += 1) i[a] && i[a].m(r, s);
+                we(r, t, s)
             },
-            p(r, a) {
-                if (a & 257) {
+            p(r, s) {
+                if (s & 257) {
                     n = Object.keys(r[0].views);
-                    let s;
-                    for (s = 0; s < n.length; s += 1) {
-                        const o = XA(r, n, s);
-                        i[s] ? i[s].p(o, a) : (i[s] = rT(o), i[s].c(), i[s].m(t.parentNode, t))
+                    let a;
+                    for (a = 0; a < n.length; a += 1) {
+                        const o = l$(r, n, a);
+                        i[a] ? i[a].p(o, s) : (i[a] = v$(o), i[a].c(), i[a].m(t.parentNode, t))
                     }
-                    for (; s < i.length; s += 1) i[s].d(1);
+                    for (; a < i.length; a += 1) i[a].d(1);
                     i.length = n.length
                 }
             },
             d(r) {
-                ol(i, r), r && xe(t)
+                Vo(i, r), r && _e(t)
             }
         }
     }
 
-    function rT(e) {
-        let t, n, i, r, a, s = e[23] + "",
+    function v$(e) {
+        let t, n, i, r, s, a = e[23] + "",
             o, l, u, c, f;
 
         function h() {
             return e[15](e[23])
         }
         return {
             c() {
-                t = K("div"), n = K("input"), r = Se(), a = K("label"), o = Qe(s), u = Se(), B(n, "class", "cursor-pointer checked:accent-rose-500"), B(n, "type", "checkbox"), B(n, "id", i = "view-" + e[23]), n.checked = !0, B(a, "class", "font-medium cursor-pointer"), B(a, "for", l = "view-" + e[23]), B(t, "class", "ml-1 flex items-center space-x-2")
+                t = J("div"), n = J("input"), r = Ee(), s = J("label"), o = Je(a), u = Ee(), j(n, "class", "cursor-pointer checked:accent-rose-500"), j(n, "type", "checkbox"), j(n, "id", i = "view-" + e[23]), n.checked = !0, j(s, "class", "font-medium cursor-pointer"), j(s, "for", l = "view-" + e[23]), j(t, "class", "ml-1 flex items-center space-x-2")
             },
             m(d, g) {
-                _e(d, t, g), U(t, n), U(t, r), U(t, a), U(a, o), U(t, u), c || (f = Ot(n, "change", h), c = !0)
+                we(d, t, g), G(t, n), G(t, r), G(t, s), G(s, o), G(t, u), c || (f = wt(n, "change", h), c = !0)
             },
             p(d, g) {
-                e = d, g & 1 && i !== (i = "view-" + e[23]) && B(n, "id", i), g & 1 && s !== (s = e[23] + "") && Pt(o, s), g & 1 && l !== (l = "view-" + e[23]) && B(a, "for", l)
+                e = d, g & 1 && i !== (i = "view-" + e[23]) && j(n, "id", i), g & 1 && a !== (a = e[23] + "") && Ot(o, a), g & 1 && l !== (l = "view-" + e[23]) && j(s, "for", l)
             },
             d(d) {
-                d && xe(t), c = !1, f()
+                d && _e(t), c = !1, f()
             }
         }
     }
 
-    function iX(e) {
-        let t, n, i, r, a, s, o, l, u, c, f, h, d, g, p, m, y, v, b, x, _, S, w, O, k, C = e[3] * 100 + "",
-            E, T, A, F, $, D, P, N, z, I, ae, ye, we, $e, Oe, Ye = Object.keys(e[0].views).length != 1,
-            St, dt, H = e[0].id && KA(e),
-            oe = e[0].filename && JA(e),
-            me = e[0].width && e[0].height && QA(e),
-            W = e[1] != null && ZA(e),
-            Fe = Ye && nT(e);
+    function cY(e) {
+        let t, n, i, r, s, a, o, l, u, c, f, h, d, g, p, m, y, v, b, x, _, S, w, E, A, C = e[3] * 100 + "",
+            k, R, $, T, M, F, N, P, z, I, Q, oe, Se, ye, Pe, xt = Object.keys(e[0].views).length != 1,
+            rn, Un, Y = e[0].id && c$(e),
+            ue = e[0].filename && f$(e),
+            be = e[0].width && e[0].height && h$(e),
+            q = e[1] != null && d$(e),
+            ze = xt && m$(e);
         return {
             c() {
-                t = K("div"), n = Se(), i = K("div"), r = K("div"), a = K("span"), a.textContent = "Data", s = Se(), o = K("div"), H && H.c(), l = Se(), oe && oe.c(), u = Se(), me && me.c(), c = Se(), f = K("div"), h = K("span"), h.textContent = "Tools", d = Se(), g = K("div"), p = K("input"), m = Se(), y = K("label"), y.textContent = "Show all items", v = Se(), b = K("div"), x = K("input"), _ = Se(), S = K("label"), S.textContent = "Show boxes", w = Se(), O = K("label"), k = Qe("Mask opacity : "), E = Qe(C), T = Qe("%"), A = Se(), F = K("input"), $ = Se(), D = K("label"), P = Qe("Minimum confidence : "), N = Qe(e[4]), z = Se(), I = K("input"), ae = Se(), ye = K("span"), ye.textContent = "Categories :", we = Se(), $e = K("div"), W && W.c(), Oe = Se(), Fe && Fe.c(), B(t, "class", "absolute top-0 left-0 w-full h-full bg-white dark:bg-zinc-800"), B(t, "id", "canvas"), B(a, "class", "mb-2 self-center text-sm text-zinc-500 font-medium uppercase dark:text-zinc-400"), B(o, "class", "flex flex-col"), B(r, "class", "flex flex-col"), B(h, "class", "mb-2 self-center text-center text-sm text-zinc-500 font-medium uppercase dark:text-zinc-400"), B(p, "class", "cursor-pointer checked:accent-rose-500"), B(p, "type", "checkbox"), B(p, "id", "toggle-items"), p.checked = !0, B(y, "class", "font-bold cursor-pointer"), B(y, "for", "toggle-items"), B(g, "class", "mb-2 flex items-center space-x-2"), B(x, "class", "cursor-pointer checked:accent-rose-500"), B(x, "type", "checkbox"), B(x, "id", "toggle-boxes"), B(S, "class", "font-bold cursor-pointer"), B(S, "for", "toggle-boxes"), B(b, "class", "mb-2 flex items-center space-x-2"), B(O, "class", "font-bold mt-2 mb-1"), B(O, "for", "slider"), B(F, "class", "cursor-pointer"), B(F, "type", "range"), B(F, "id", "slider"), B(F, "min", "0"), B(F, "max", "1"), B(F, "step", "0.1"), B(D, "class", "font-bold mt-2 mb-1"), B(D, "for", "slider"), B(I, "class", "cursor-pointer"), B(I, "type", "range"), B(I, "id", "slider"), B(I, "min", "0"), B(I, "max", "1"), B(I, "step", "0.01"), B(f, "class", "mt-2 pt-2 flex flex-col border-t dark:border-zinc-700"), B(ye, "class", "font-bold mb-2 mt-2"), B($e, "class", "flex flex-wrap"), B(i, "class", "absolute w-64 top-1/2 -translate-y-1/2 right-6 py-2 px-4 flex flex-col bg-white text-zinc-900 border rounded-lg shadow dark:text-zinc-300 dark:bg-zinc-900 dark:border-zinc-500")
+                t = J("div"), n = Ee(), i = J("div"), r = J("div"), s = J("span"), s.textContent = "Data", a = Ee(), o = J("div"), Y && Y.c(), l = Ee(), ue && ue.c(), u = Ee(), be && be.c(), c = Ee(), f = J("div"), h = J("span"), h.textContent = "Tools", d = Ee(), g = J("div"), p = J("input"), m = Ee(), y = J("label"), y.textContent = "Show all items", v = Ee(), b = J("div"), x = J("input"), _ = Ee(), S = J("label"), S.textContent = "Show boxes", w = Ee(), E = J("label"), A = Je("Mask opacity : "), k = Je(C), R = Je("%"), $ = Ee(), T = J("input"), M = Ee(), F = J("label"), N = Je("Minimum confidence : "), P = Je(e[4]), z = Ee(), I = J("input"), Q = Ee(), oe = J("span"), oe.textContent = "Categories :", Se = Ee(), ye = J("div"), q && q.c(), Pe = Ee(), ze && ze.c(), j(t, "class", "absolute top-0 left-0 w-full h-full bg-white dark:bg-zinc-800"), j(t, "id", "canvas"), j(s, "class", "mb-2 self-center text-sm text-zinc-500 font-medium uppercase dark:text-zinc-400"), j(o, "class", "flex flex-col"), j(r, "class", "flex flex-col"), j(h, "class", "mb-2 self-center text-center text-sm text-zinc-500 font-medium uppercase dark:text-zinc-400"), j(p, "class", "cursor-pointer checked:accent-rose-500"), j(p, "type", "checkbox"), j(p, "id", "toggle-items"), p.checked = !0, j(y, "class", "font-bold cursor-pointer"), j(y, "for", "toggle-items"), j(g, "class", "mb-2 flex items-center space-x-2"), j(x, "class", "cursor-pointer checked:accent-rose-500"), j(x, "type", "checkbox"), j(x, "id", "toggle-boxes"), j(S, "class", "font-bold cursor-pointer"), j(S, "for", "toggle-boxes"), j(b, "class", "mb-2 flex items-center space-x-2"), j(E, "class", "font-bold mt-2 mb-1"), j(E, "for", "slider"), j(T, "class", "cursor-pointer"), j(T, "type", "range"), j(T, "id", "slider"), j(T, "min", "0"), j(T, "max", "1"), j(T, "step", "0.1"), j(F, "class", "font-bold mt-2 mb-1"), j(F, "for", "slider"), j(I, "class", "cursor-pointer"), j(I, "type", "range"), j(I, "id", "slider"), j(I, "min", "0"), j(I, "max", "1"), j(I, "step", "0.01"), j(f, "class", "mt-2 pt-2 flex flex-col border-t dark:border-zinc-700"), j(oe, "class", "font-bold mb-2 mt-2"), j(ye, "class", "flex flex-wrap"), j(i, "class", "absolute w-64 top-1/2 -translate-y-1/2 right-6 py-2 px-4 flex flex-col bg-white text-zinc-900 border rounded-lg shadow dark:text-zinc-300 dark:bg-zinc-900 dark:border-zinc-500")
             },
-            m(ue, Re) {
-                _e(ue, t, Re), _e(ue, n, Re), _e(ue, i, Re), U(i, r), U(r, a), U(r, s), U(r, o), H && H.m(o, null), U(o, l), oe && oe.m(o, null), U(o, u), me && me.m(o, null), U(i, c), U(i, f), U(f, h), U(f, d), U(f, g), U(g, p), U(g, m), U(g, y), U(f, v), U(f, b), U(b, x), x.checked = e[2], U(b, _), U(b, S), U(f, w), U(f, O), U(O, k), U(O, E), U(O, T), U(f, A), U(f, F), ng(F, e[3]), U(f, $), U(f, D), U(D, P), U(D, N), U(f, z), U(f, I), ng(I, e[4]), U(i, ae), U(i, ye), U(i, we), U(i, $e), W && W.m($e, null), U(i, Oe), Fe && Fe.m(i, null), St || (dt = [Ot(p, "change", e[7]), Ot(x, "change", e[11]), Ot(x, "change", e[10]), Ot(F, "change", e[12]), Ot(F, "input", e[12]), Ot(F, "input", e[5]), Ot(I, "change", e[13]), Ot(I, "input", e[13]), Ot(I, "input", e[10])], St = !0)
+            m(fe, Be) {
+                we(fe, t, Be), we(fe, n, Be), we(fe, i, Be), G(i, r), G(r, s), G(r, a), G(r, o), Y && Y.m(o, null), G(o, l), ue && ue.m(o, null), G(o, u), be && be.m(o, null), G(i, c), G(i, f), G(f, h), G(f, d), G(f, g), G(g, p), G(g, m), G(g, y), G(f, v), G(f, b), G(b, x), x.checked = e[2], G(b, _), G(b, S), G(f, w), G(f, E), G(E, A), G(E, k), G(E, R), G(f, $), G(f, T), jd(T, e[3]), G(f, M), G(f, F), G(F, N), G(F, P), G(f, z), G(f, I), jd(I, e[4]), G(i, Q), G(i, oe), G(i, Se), G(i, ye), q && q.m(ye, null), G(i, Pe), ze && ze.m(i, null), rn || (Un = [wt(p, "change", e[7]), wt(x, "change", e[11]), wt(x, "change", e[10]), wt(T, "change", e[12]), wt(T, "input", e[12]), wt(T, "input", e[5]), wt(I, "change", e[13]), wt(I, "input", e[13]), wt(I, "input", e[10])], rn = !0)
             },
-            p(ue, [Re]) {
-                ue[0].id ? H ? H.p(ue, Re) : (H = KA(ue), H.c(), H.m(o, l)) : H && (H.d(1), H = null), ue[0].filename ? oe ? oe.p(ue, Re) : (oe = JA(ue), oe.c(), oe.m(o, u)) : oe && (oe.d(1), oe = null), ue[0].width && ue[0].height ? me ? me.p(ue, Re) : (me = QA(ue), me.c(), me.m(o, null)) : me && (me.d(1), me = null), Re & 4 && (x.checked = ue[2]), Re & 8 && C !== (C = ue[3] * 100 + "") && Pt(E, C), Re & 8 && ng(F, ue[3]), Re & 16 && Pt(N, ue[4]), Re & 16 && ng(I, ue[4]), ue[1] != null ? W ? W.p(ue, Re) : (W = ZA(ue), W.c(), W.m($e, null)) : W && (W.d(1), W = null), Re & 1 && (Ye = Object.keys(ue[0].views).length != 1), Ye ? Fe ? Fe.p(ue, Re) : (Fe = nT(ue), Fe.c(), Fe.m(i, null)) : Fe && (Fe.d(1), Fe = null)
+            p(fe, [Be]) {
+                fe[0].id ? Y ? Y.p(fe, Be) : (Y = c$(fe), Y.c(), Y.m(o, l)) : Y && (Y.d(1), Y = null), fe[0].filename ? ue ? ue.p(fe, Be) : (ue = f$(fe), ue.c(), ue.m(o, u)) : ue && (ue.d(1), ue = null), fe[0].width && fe[0].height ? be ? be.p(fe, Be) : (be = h$(fe), be.c(), be.m(o, null)) : be && (be.d(1), be = null), Be & 4 && (x.checked = fe[2]), Be & 8 && C !== (C = fe[3] * 100 + "") && Ot(k, C), Be & 8 && jd(T, fe[3]), Be & 16 && Ot(P, fe[4]), Be & 16 && jd(I, fe[4]), fe[1] != null ? q ? q.p(fe, Be) : (q = d$(fe), q.c(), q.m(ye, null)) : q && (q.d(1), q = null), Be & 1 && (xt = Object.keys(fe[0].views).length != 1), xt ? ze ? ze.p(fe, Be) : (ze = m$(fe), ze.c(), ze.m(i, null)) : ze && (ze.d(1), ze = null)
             },
-            i: Ke,
-            o: Ke,
-            d(ue) {
-                ue && xe(t), ue && xe(n), ue && xe(i), H && H.d(), oe && oe.d(), me && me.d(), W && W.d(), Fe && Fe.d(), St = !1, Ka(dt)
+            i: Ve,
+            o: Ve,
+            d(fe) {
+                fe && _e(t), fe && _e(n), fe && _e(i), Y && Y.d(), ue && ue.d(), be && be.d(), q && q.d(), ze && ze.d(), rn = !1, js(Un)
             }
         }
     }
 
-    function rX(e, t, n) {
+    function fY(e, t, n) {
         let {
             features: i
-        } = t, r, a = null, s, o = {
+        } = t, r, s = null, a, o = {
             rows: 0,
             cols: 0
         }, l = !0, u = .5, c = .5, f = [], h = [];
 
         function d() {
-            s.children.forEach(C => {
-                for (const E of C.children) E.name() === "masks" && _B(E, u)
+            a.children.forEach(C => {
+                for (const k of C.children) k.name() === "masks" && $B(k, u)
             })
         }
 
         function g(C) {
             if (f.includes(C)) {
-                const E = f.indexOf(C);
-                E > -1 && f.splice(E, 1)
+                const k = f.indexOf(C);
+                k > -1 && f.splice(k, 1)
             } else f.push(C);
             v()
         }
 
         function p() {
             f.length == 0 ? i.categoryStats.forEach(C => f.push(C.id)) : f = [], v()
         }
 
         function m(C) {
             if (h.includes(C)) {
-                const E = h.indexOf(C);
-                E > -1 && h.splice(E, 1)
+                const k = h.indexOf(C);
+                k > -1 && h.splice(k, 1)
             } else h.push(C);
             v()
         }
 
         function y() {
             h.length == 0 ? Object.keys(i.views).forEach(C => h.push(C)) : h = [], v()
         }
 
         function v() {
-            s.children.forEach(C => {
-                h.includes(C.name()) ? C.hide() : C.show(), C.children.forEach(E => {
-                    (E.name() == "boxes" || E.name() == "tooltips") && (l ? E.show() : E.hide()), E.children.forEach(T => {
-                        let A = T.id(),
-                            F = parseInt(A.replace("category-", "")),
-                            $ = parseFloat(A.replace("category-" + F + "-", ""));
-                        f.includes(F) || $ < c ? T.hide() : T.show()
+            a.children.forEach(C => {
+                h.includes(C.name()) ? C.hide() : C.show(), C.children.forEach(k => {
+                    (k.name() == "boxes" || k.name() == "tooltips") && (l ? k.show() : k.hide()), k.children.forEach(R => {
+                        let $ = R.id(),
+                            T = parseInt($.replace("category-", "")),
+                            M = parseFloat($.replace("category-" + T + "-", ""));
+                        f.includes(T) || M < c ? R.hide() : R.show()
                     })
                 })
             }), b()
         }
 
         function b() {
             document.getElementById("toggle-items").checked = f.length == 0, Object.keys(i.views).length > 1 && (document.getElementById("toggle-views").checked = h.length == 0, Object.keys(i.views).forEach(C => {
                 document.getElementById(`view-${C}`).checked = !h.includes(C)
             })), i.categoryStats.forEach(C => {
-                let E = document.getElementById(`cat-${C.id}`);
-                f.includes(C.id) ? E.classList.add("grayscale") : E.classList.remove("grayscale")
+                let k = document.getElementById(`cat-${C.id}`);
+                f.includes(C.id) ? k.classList.add("grayscale") : k.classList.remove("grayscale")
             })
         }
 
         function x() {
-            pB(s);
+            wB(a);
             let C = window.innerWidth / o.cols,
-                E = window.innerHeight / o.rows,
-                T = {
+                k = window.innerHeight / o.rows,
+                R = {
                     col: 0,
                     row: 0
                 };
-            for (const [A, F] of Object.entries(i.views)) {
-                let $;
-                for (const ae of s.children) A === ae.name() && ($ = ae);
-                let D = new hn.Group({
+            for (const [$, T] of Object.entries(i.views)) {
+                let M;
+                for (const Q of a.children) $ === Q.name() && (M = Q);
+                let F = new cn.Group({
                         name: "images"
                     }),
-                    P = new hn.Group({
+                    N = new cn.Group({
                         name: "boxes"
                     }),
-                    N = new hn.Group({
+                    P = new cn.Group({
                         name: "masks"
                     }),
-                    z = new hn.Group({
+                    z = new cn.Group({
                         name: "tooltips"
                     });
                 const I = new Image;
                 I.onload = () => {
-                    let ae = C / I.width,
-                        ye = E / I.height,
-                        we = Math.min(ae, ye),
-                        $e = {
-                            width: I.width * we,
-                            height: I.height * we
+                    let Q = C / I.width,
+                        oe = k / I.height,
+                        Se = Math.min(Q, oe),
+                        ye = {
+                            width: I.width * Se,
+                            height: I.height * Se
                         },
-                        Oe = {
-                            x: C * T.col + (C - I.width * we) / 2,
-                            y: E * T.row + (E - I.height * we) / 2
+                        Pe = {
+                            x: C * R.col + (C - I.width * Se) / 2,
+                            y: k * R.row + (k - I.height * Se) / 2
                         };
-                    bB(D, I, Oe, we);
-                    for (let Ye = 0; Ye < F.objects.boundingBox.length; ++Ye) {
-                        let St = F.objects.category[Ye],
-                            dt = `category-${St.id}-`;
-                        if (F.objects.boundingBox[Ye]) {
-                            let H = F.objects.boundingBox[Ye];
-                            if (H.width != 0 && H.height != 0) {
-                                let oe = dB(H, $e, Oe);
-                                yB(dt + (H.is_predict ? H.confidence : 1), P, oe, a(St.id), H.is_predict), mB(dt + (H.is_predict ? H.confidence : 1), z, St.name + (H.is_predict ? " " + H.confidence.toString() : ""), {
-                                    x: oe.x,
-                                    y: oe.y
-                                }, a(St.id))
+                    kB(F, I, Pe, Se);
+                    for (let xt = 0; xt < T.objects.boundingBox.length; ++xt) {
+                        let rn = T.objects.category[xt],
+                            Un = `category-${rn.id}-`;
+                        if (T.objects.boundingBox[xt]) {
+                            let Y = T.objects.boundingBox[xt];
+                            if (Y.width != 0 && Y.height != 0) {
+                                let ue = xB(Y, ye, Pe);
+                                EB(Un + (Y.is_predict ? Y.confidence : 1), N, ue, s(rn.id), Y.is_predict), SB(Un + (Y.is_predict ? Y.confidence : 1), z, rn.name + (Y.is_predict ? " " + Y.confidence.toString() : ""), {
+                                    x: ue.x,
+                                    y: ue.y
+                                }, s(rn.id))
                             }
                         }
-                        if (F.objects.segmentation[Ye]) {
-                            let H = F.objects.segmentation[Ye],
-                                oe = gB(H, $e, Oe);
-                            vB(dt + 1, N, oe, a(St.id))
+                        if (T.objects.segmentation[xt]) {
+                            let Y = T.objects.segmentation[xt],
+                                ue = _B(Y, ye, Pe);
+                            CB(Un + 1, P, ue, s(rn.id))
                         }
                     }
-                    $.add(D), $.add(P), $.add(z), $.add(N), xB($, A, Oe), s.draw(), T.col == o.cols - 1 ? (T.col = 0, T.row++) : T.col++, v()
-                }, I.src = F.image
+                    M.add(F), M.add(N), M.add(z), M.add(P), AB(M, $, Pe), a.draw(), R.col == o.cols - 1 ? (R.col = 0, R.row++) : R.col++, v()
+                }, I.src = T.image
             }
         }
-        bm(() => {
-            s = new hn.Stage({
+        Z0(() => {
+            a = new cn.Stage({
                 height: window.innerHeight,
                 width: window.innerWidth,
                 container: "canvas"
             }), Object.keys(i.views).forEach(C => {
-                let E = new hn.Layer({
+                let k = new cn.Layer({
                     name: C,
                     draggable: !0
                 });
-                E.on("dblclick", E.moveToTop), E.on("mouseenter", () => s.container().style.cursor = "move"), E.on("mouseleave", () => s.container().style.cursor = "default"), s.add(E)
-            }), s.on("wheel", C => {
+                k.on("dblclick", k.moveToTop), k.on("mouseenter", () => a.container().style.cursor = "move"), k.on("mouseleave", () => a.container().style.cursor = "default"), a.add(k)
+            }), a.on("wheel", C => {
                 C.evt.preventDefault();
-                let E = C.evt.deltaY < 0 ? 1 : -1;
-                C.evt.ctrlKey && (E = -E), wB(s, E)
+                let k = C.evt.deltaY < 0 ? 1 : -1;
+                C.evt.ctrlKey && (k = -k), TB(a, k)
             })
-        }), R8(() => {
+        }), j8(() => {
             if (i.id != r) {
-                n(1, a = nX(i.categoryStats.map(E => E.id)));
+                n(1, s = uY(i.categoryStats.map(k => k.id)));
                 let C = Object.keys(i.views).length;
                 o.cols = Math.ceil(Math.sqrt(C)), o.rows = Math.ceil(C / o.cols)
             }
-        }), P8(() => {
+        }), U8(() => {
             i.id != r && (r = i.id, x())
         });
 
         function _() {
             l = this.checked, n(2, l)
         }
 
         function S() {
-            u = PC(this.value), n(3, u)
+            u = VC(this.value), n(3, u)
         }
 
         function w() {
-            c = PC(this.value), n(4, c)
+            c = VC(this.value), n(4, c)
         }
-        const O = C => g(C.id),
-            k = C => m(C);
+        const E = C => g(C.id),
+            A = C => m(C);
         return e.$$set = C => {
             "features" in C && n(0, i = C.features)
-        }, [i, a, l, u, c, d, g, p, m, y, v, _, S, w, O, k]
+        }, [i, s, l, u, c, d, g, p, m, y, v, _, S, w, E, A]
     }
-    class aX extends Cn {
+    class hY extends wn {
         constructor(t) {
-            super(), On(this, t, rX, iX, rn, {
+            super(), _n(this, t, fY, cY, tn, {
                 features: 0
             })
         }
     }
 
-    function sX(e) {
+    function dY(e) {
         let t, n;
         return {
             c() {
-                t = K("div"), n = Qe(e[0]), B(t, "class", "pl-2 text-zinc-900 dark:text-zinc-50")
+                t = J("div"), n = Je(e[0]), j(t, "class", "pl-2 text-zinc-900 dark:text-zinc-50")
             },
             m(i, r) {
-                _e(i, t, r), U(t, n)
+                we(i, t, r), G(t, n)
             },
             p(i, [r]) {
-                r & 1 && Pt(n, i[0])
+                r & 1 && Ot(n, i[0])
             },
-            i: Ke,
-            o: Ke,
+            i: Ve,
+            o: Ve,
             d(i) {
-                i && xe(t)
+                i && _e(t)
             }
         }
     }
 
-    function oX(e, t, n) {
+    function gY(e, t, n) {
         let {
             value: i
         } = t;
         return e.$$set = r => {
             "value" in r && n(0, i = r.value)
         }, [i]
     }
-    class lX extends Cn {
+    class pY extends wn {
         constructor(t) {
-            super(), On(this, t, oX, sX, rn, {
+            super(), _n(this, t, gY, dY, tn, {
                 value: 0
             })
         }
     }
 
-    function uX(e) {
+    function mY(e) {
         let t, n;
         return {
             c() {
-                t = K("div"), n = Qe(e[0]), B(t, "class", "pl-2 text-zinc-900 dark:text-zinc-50")
+                t = J("div"), n = Je(e[0]), j(t, "class", "pl-2 text-zinc-900 dark:text-zinc-50")
             },
             m(i, r) {
-                _e(i, t, r), U(t, n)
+                we(i, t, r), G(t, n)
             },
             p(i, [r]) {
-                r & 1 && Pt(n, i[0])
+                r & 1 && Ot(n, i[0])
             },
-            i: Ke,
-            o: Ke,
+            i: Ve,
+            o: Ve,
             d(i) {
-                i && xe(t)
+                i && _e(t)
             }
         }
     }
 
-    function cX(e, t, n) {
+    function yY(e, t, n) {
         let {
             value: i
         } = t;
         return e.$$set = r => {
             "value" in r && n(0, i = r.value)
         }, [i]
     }
-    class fX extends Cn {
+    class vY extends wn {
         constructor(t) {
-            super(), On(this, t, cX, uX, rn, {
+            super(), _n(this, t, yY, mY, tn, {
                 value: 0
             })
         }
     }
 
-    function hX(e) {
+    function bY(e) {
         let t, n;
         return {
             c() {
-                t = K("img"), B(t, "class", "px-2 h-56 w-56 min-w-[14rem] object-cover"), Sh(t.src, n = e[0]) || B(t, "src", n), B(t, "alt", e[0])
+                t = J("img"), j(t, "class", "px-2 h-56 w-56 min-w-[14rem] object-cover"), fh(t.src, n = e[0]) || j(t, "src", n), j(t, "alt", e[0])
             },
             m(i, r) {
-                _e(i, t, r)
+                we(i, t, r)
             },
             p(i, [r]) {
-                r & 1 && !Sh(t.src, n = i[0]) && B(t, "src", n), r & 1 && B(t, "alt", i[0])
+                r & 1 && !fh(t.src, n = i[0]) && j(t, "src", n), r & 1 && j(t, "alt", i[0])
             },
-            i: Ke,
-            o: Ke,
+            i: Ve,
+            o: Ve,
             d(i) {
-                i && xe(t)
+                i && _e(t)
             }
         }
     }
 
-    function dX(e, t, n) {
+    function xY(e, t, n) {
         let {
             value: i
         } = t;
         return e.$$set = r => {
             "value" in r && n(0, i = r.value)
         }, [i]
     }
-    class gX extends Cn {
+    class _Y extends wn {
         constructor(t) {
-            super(), On(this, t, dX, hX, rn, {
+            super(), _n(this, t, xY, bY, tn, {
                 value: 0
             })
         }
     }
     /*!
      * https://github.com/Starcounter-Jack/JSON-Patch
      * (c) 2017-2022 Joachim Wester
      * MIT licensed
      */
-    var pX = globalThis && globalThis.__extends || function() {
+    var wY = globalThis && globalThis.__extends || function() {
             var e = function(t, n) {
                 return e = Object.setPrototypeOf || {
                     __proto__: []
                 }
                 instanceof Array && function(i, r) {
                     i.__proto__ = r
                 } || function(i, r) {
-                    for (var a in r) r.hasOwnProperty(a) && (i[a] = r[a])
+                    for (var s in r) r.hasOwnProperty(s) && (i[s] = r[s])
                 }, e(t, n)
             };
             return function(t, n) {
                 e(t, n);
 
                 function i() {
                     this.constructor = t
                 }
                 t.prototype = n === null ? Object.create(n) : (i.prototype = n.prototype, new i)
             }
         }(),
-        mX = Object.prototype.hasOwnProperty;
+        SY = Object.prototype.hasOwnProperty;
 
-    function h2(e, t) {
-        return mX.call(e, t)
+    function Bb(e, t) {
+        return SY.call(e, t)
     }
 
-    function d2(e) {
+    function jb(e) {
         if (Array.isArray(e)) {
             for (var t = new Array(e.length), n = 0; n < t.length; n++) t[n] = "" + n;
             return t
         }
         if (Object.keys) return Object.keys(e);
         var i = [];
-        for (var r in e) h2(e, r) && i.push(r);
+        for (var r in e) Bb(e, r) && i.push(r);
         return i
     }
 
-    function yi(e) {
+    function pi(e) {
         switch (typeof e) {
             case "object":
                 return JSON.parse(JSON.stringify(e));
             case "undefined":
                 return null;
             default:
                 return e
         }
     }
 
-    function g2(e) {
+    function Ub(e) {
         for (var t = 0, n = e.length, i; t < n;) {
             if (i = e.charCodeAt(t), i >= 48 && i <= 57) {
                 t++;
                 continue
             }
             return !1
         }
         return !0
     }
 
-    function Io(e) {
+    function ko(e) {
         return e.indexOf("/") === -1 && e.indexOf("~") === -1 ? e : e.replace(/~/g, "~0").replace(/\//g, "~1")
     }
 
-    function OR(e) {
+    function PR(e) {
         return e.replace(/~1/g, "/").replace(/~0/g, "~")
     }
 
-    function p2(e) {
+    function Gb(e) {
         if (e === void 0) return !0;
         if (e) {
             if (Array.isArray(e)) {
                 for (var t = 0, n = e.length; t < n; t++)
-                    if (p2(e[t])) return !0
+                    if (Gb(e[t])) return !0
             } else if (typeof e == "object") {
-                for (var i = d2(e), r = i.length, a = 0; a < r; a++)
-                    if (p2(e[i[a]])) return !0
+                for (var i = jb(e), r = i.length, s = 0; s < r; s++)
+                    if (Gb(e[i[s]])) return !0
             }
         }
         return !1
     }
 
-    function aT(e, t) {
+    function b$(e, t) {
         var n = [e];
         for (var i in t) {
             var r = typeof t[i] == "object" ? JSON.stringify(t[i], null, 2) : t[i];
             typeof r < "u" && n.push(i + ": " + r)
         }
         return n.join(`
 `)
     }
-    var CR = function(e) {
-            pX(t, e);
+    var LR = function(e) {
+            wY(t, e);
 
-            function t(n, i, r, a, s) {
+            function t(n, i, r, s, a) {
                 var o = this.constructor,
-                    l = e.call(this, aT(n, {
+                    l = e.call(this, b$(n, {
                         name: i,
                         index: r,
-                        operation: a,
-                        tree: s
+                        operation: s,
+                        tree: a
                     })) || this;
-                return l.name = i, l.index = r, l.operation = a, l.tree = s, Object.setPrototypeOf(l, o.prototype), l.message = aT(n, {
+                return l.name = i, l.index = r, l.operation = s, l.tree = a, Object.setPrototypeOf(l, o.prototype), l.message = b$(n, {
                     name: i,
                     index: r,
-                    operation: a,
-                    tree: s
+                    operation: s,
+                    tree: a
                 }), l
             }
             return t
         }(Error),
-        xt = CR,
-        yX = yi,
-        wu = {
+        yt = LR,
+        EY = pi,
+        fu = {
             add: function(e, t, n) {
                 return e[t] = this.value, {
                     newDocument: n
                 }
             },
             remove: function(e, t, n) {
                 var i = e[t];
@@ -16570,54 +16570,54 @@
                 var i = e[t];
                 return e[t] = this.value, {
                     newDocument: n,
                     removed: i
                 }
             },
             move: function(e, t, n) {
-                var i = C0(n, this.path);
-                i && (i = yi(i));
-                var r = tl(n, {
+                var i = o0(n, this.path);
+                i && (i = pi(i));
+                var r = Uo(n, {
                     op: "remove",
                     path: this.from
                 }).removed;
-                return tl(n, {
+                return Uo(n, {
                     op: "add",
                     path: this.path,
                     value: r
                 }), {
                     newDocument: n,
                     removed: i
                 }
             },
             copy: function(e, t, n) {
-                var i = C0(n, this.from);
-                return tl(n, {
+                var i = o0(n, this.from);
+                return Uo(n, {
                     op: "add",
                     path: this.path,
-                    value: yi(i)
+                    value: pi(i)
                 }), {
                     newDocument: n
                 }
             },
             test: function(e, t, n) {
                 return {
                     newDocument: n,
-                    test: Rh(e[t], this.value)
+                    test: wh(e[t], this.value)
                 }
             },
             _get: function(e, t, n) {
                 return this.value = e[t], {
                     newDocument: n
                 }
             }
         },
-        vX = {
+        CY = {
             add: function(e, t, n) {
-                return g2(t) ? e.splice(t, 0, this.value) : e[t] = this.value, {
+                return Ub(t) ? e.splice(t, 0, this.value) : e[t] = this.value, {
                     newDocument: n,
                     index: t
                 }
             },
             remove: function(e, t, n) {
                 var i = e.splice(t, 1);
                 return {
@@ -16628,925 +16628,930 @@
             replace: function(e, t, n) {
                 var i = e[t];
                 return e[t] = this.value, {
                     newDocument: n,
                     removed: i
                 }
             },
-            move: wu.move,
-            copy: wu.copy,
-            test: wu.test,
-            _get: wu._get
+            move: fu.move,
+            copy: fu.copy,
+            test: fu.test,
+            _get: fu._get
         };
 
-    function C0(e, t) {
+    function o0(e, t) {
         if (t == "") return e;
         var n = {
             op: "_get",
             path: t
         };
-        return tl(e, n), n.value
+        return Uo(e, n), n.value
     }
 
-    function tl(e, t, n, i, r, a) {
-        if (n === void 0 && (n = !1), i === void 0 && (i = !0), r === void 0 && (r = !0), a === void 0 && (a = 0), n && (typeof n == "function" ? n(t, 0, e, t.path) : k0(t, 0)), t.path === "") {
-            var s = {
+    function Uo(e, t, n, i, r, s) {
+        if (n === void 0 && (n = !1), i === void 0 && (i = !0), r === void 0 && (r = !0), s === void 0 && (s = 0), n && (typeof n == "function" ? n(t, 0, e, t.path) : l0(t, 0)), t.path === "") {
+            var a = {
                 newDocument: e
             };
-            if (t.op === "add") return s.newDocument = t.value, s;
-            if (t.op === "replace") return s.newDocument = t.value, s.removed = e, s;
-            if (t.op === "move" || t.op === "copy") return s.newDocument = C0(e, t.from), t.op === "move" && (s.removed = e), s;
+            if (t.op === "add") return a.newDocument = t.value, a;
+            if (t.op === "replace") return a.newDocument = t.value, a.removed = e, a;
+            if (t.op === "move" || t.op === "copy") return a.newDocument = o0(e, t.from), t.op === "move" && (a.removed = e), a;
             if (t.op === "test") {
-                if (s.test = Rh(e, t.value), s.test === !1) throw new xt("Test operation failed", "TEST_OPERATION_FAILED", a, t, e);
-                return s.newDocument = e, s
+                if (a.test = wh(e, t.value), a.test === !1) throw new yt("Test operation failed", "TEST_OPERATION_FAILED", s, t, e);
+                return a.newDocument = e, a
             } else {
-                if (t.op === "remove") return s.removed = e, s.newDocument = null, s;
-                if (t.op === "_get") return t.value = e, s;
-                if (n) throw new xt("Operation `op` property is not one of operations defined in RFC-6902", "OPERATION_OP_INVALID", a, t, e);
-                return s
+                if (t.op === "remove") return a.removed = e, a.newDocument = null, a;
+                if (t.op === "_get") return t.value = e, a;
+                if (n) throw new yt("Operation `op` property is not one of operations defined in RFC-6902", "OPERATION_OP_INVALID", s, t, e);
+                return a
             }
         } else {
-            i || (e = yi(e));
+            i || (e = pi(e));
             var o = t.path || "",
                 l = o.split("/"),
                 u = e,
                 c = 1,
                 f = l.length,
                 h = void 0,
                 d = void 0,
                 g = void 0;
-            for (typeof n == "function" ? g = n : g = k0;;) {
-                if (d = l[c], d && d.indexOf("~") != -1 && (d = OR(d)), r && (d == "__proto__" || d == "prototype" && c > 0 && l[c - 1] == "constructor")) throw new TypeError("JSON-Patch: modifying `__proto__` or `constructor/prototype` prop is banned for security reasons, if this was on purpose, please set `banPrototypeModifications` flag false and pass it to this function. More info in fast-json-patch README");
+            for (typeof n == "function" ? g = n : g = l0;;) {
+                if (d = l[c], d && d.indexOf("~") != -1 && (d = PR(d)), r && (d == "__proto__" || d == "prototype" && c > 0 && l[c - 1] == "constructor")) throw new TypeError("JSON-Patch: modifying `__proto__` or `constructor/prototype` prop is banned for security reasons, if this was on purpose, please set `banPrototypeModifications` flag false and pass it to this function. More info in fast-json-patch README");
                 if (n && h === void 0 && (u[d] === void 0 ? h = l.slice(0, c).join("/") : c == f - 1 && (h = t.path), h !== void 0 && g(t, 0, e, h)), c++, Array.isArray(u)) {
                     if (d === "-") d = u.length;
                     else {
-                        if (n && !g2(d)) throw new xt("Expected an unsigned base-10 integer value, making the new referenced value the array element with the zero-based index", "OPERATION_PATH_ILLEGAL_ARRAY_INDEX", a, t, e);
-                        g2(d) && (d = ~~d)
+                        if (n && !Ub(d)) throw new yt("Expected an unsigned base-10 integer value, making the new referenced value the array element with the zero-based index", "OPERATION_PATH_ILLEGAL_ARRAY_INDEX", s, t, e);
+                        Ub(d) && (d = ~~d)
                     }
                     if (c >= f) {
-                        if (n && t.op === "add" && d > u.length) throw new xt("The specified index MUST NOT be greater than the number of elements in the array", "OPERATION_VALUE_OUT_OF_BOUNDS", a, t, e);
-                        var s = vX[t.op].call(t, u, d, e);
-                        if (s.test === !1) throw new xt("Test operation failed", "TEST_OPERATION_FAILED", a, t, e);
-                        return s
+                        if (n && t.op === "add" && d > u.length) throw new yt("The specified index MUST NOT be greater than the number of elements in the array", "OPERATION_VALUE_OUT_OF_BOUNDS", s, t, e);
+                        var a = CY[t.op].call(t, u, d, e);
+                        if (a.test === !1) throw new yt("Test operation failed", "TEST_OPERATION_FAILED", s, t, e);
+                        return a
                     }
                 } else if (c >= f) {
-                    var s = wu[t.op].call(t, u, d, e);
-                    if (s.test === !1) throw new xt("Test operation failed", "TEST_OPERATION_FAILED", a, t, e);
-                    return s
+                    var a = fu[t.op].call(t, u, d, e);
+                    if (a.test === !1) throw new yt("Test operation failed", "TEST_OPERATION_FAILED", s, t, e);
+                    return a
                 }
-                if (u = u[d], n && c < f && (!u || typeof u != "object")) throw new xt("Cannot perform operation at the desired path", "OPERATION_PATH_UNRESOLVABLE", a, t, e)
+                if (u = u[d], n && c < f && (!u || typeof u != "object")) throw new yt("Cannot perform operation at the desired path", "OPERATION_PATH_UNRESOLVABLE", s, t, e)
             }
         }
     }
 
-    function qm(e, t, n, i, r) {
-        if (i === void 0 && (i = !0), r === void 0 && (r = !0), n && !Array.isArray(t)) throw new xt("Patch sequence must be an array", "SEQUENCE_NOT_AN_ARRAY");
-        i || (e = yi(e));
-        for (var a = new Array(t.length), s = 0, o = t.length; s < o; s++) a[s] = tl(e, t[s], n, !0, r, s), e = a[s].newDocument;
-        return a.newDocument = e, a
+    function Em(e, t, n, i, r) {
+        if (i === void 0 && (i = !0), r === void 0 && (r = !0), n && !Array.isArray(t)) throw new yt("Patch sequence must be an array", "SEQUENCE_NOT_AN_ARRAY");
+        i || (e = pi(e));
+        for (var s = new Array(t.length), a = 0, o = t.length; a < o; a++) s[a] = Uo(e, t[a], n, !0, r, a), e = s[a].newDocument;
+        return s.newDocument = e, s
     }
 
-    function bX(e, t, n) {
-        var i = tl(e, t);
-        if (i.test === !1) throw new xt("Test operation failed", "TEST_OPERATION_FAILED", n, t, e);
+    function kY(e, t, n) {
+        var i = Uo(e, t);
+        if (i.test === !1) throw new yt("Test operation failed", "TEST_OPERATION_FAILED", n, t, e);
         return i.newDocument
     }
 
-    function k0(e, t, n, i) {
-        if (typeof e != "object" || e === null || Array.isArray(e)) throw new xt("Operation is not an object", "OPERATION_NOT_AN_OBJECT", t, e, n);
-        if (wu[e.op]) {
-            if (typeof e.path != "string") throw new xt("Operation `path` property is not a string", "OPERATION_PATH_INVALID", t, e, n);
-            if (e.path.indexOf("/") !== 0 && e.path.length > 0) throw new xt('Operation `path` property must start with "/"', "OPERATION_PATH_INVALID", t, e, n);
-            if ((e.op === "move" || e.op === "copy") && typeof e.from != "string") throw new xt("Operation `from` property is not present (applicable in `move` and `copy` operations)", "OPERATION_FROM_REQUIRED", t, e, n);
-            if ((e.op === "add" || e.op === "replace" || e.op === "test") && e.value === void 0) throw new xt("Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)", "OPERATION_VALUE_REQUIRED", t, e, n);
-            if ((e.op === "add" || e.op === "replace" || e.op === "test") && p2(e.value)) throw new xt("Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)", "OPERATION_VALUE_CANNOT_CONTAIN_UNDEFINED", t, e, n);
+    function l0(e, t, n, i) {
+        if (typeof e != "object" || e === null || Array.isArray(e)) throw new yt("Operation is not an object", "OPERATION_NOT_AN_OBJECT", t, e, n);
+        if (fu[e.op]) {
+            if (typeof e.path != "string") throw new yt("Operation `path` property is not a string", "OPERATION_PATH_INVALID", t, e, n);
+            if (e.path.indexOf("/") !== 0 && e.path.length > 0) throw new yt('Operation `path` property must start with "/"', "OPERATION_PATH_INVALID", t, e, n);
+            if ((e.op === "move" || e.op === "copy") && typeof e.from != "string") throw new yt("Operation `from` property is not present (applicable in `move` and `copy` operations)", "OPERATION_FROM_REQUIRED", t, e, n);
+            if ((e.op === "add" || e.op === "replace" || e.op === "test") && e.value === void 0) throw new yt("Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)", "OPERATION_VALUE_REQUIRED", t, e, n);
+            if ((e.op === "add" || e.op === "replace" || e.op === "test") && Gb(e.value)) throw new yt("Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)", "OPERATION_VALUE_CANNOT_CONTAIN_UNDEFINED", t, e, n);
             if (n) {
                 if (e.op == "add") {
                     var r = e.path.split("/").length,
-                        a = i.split("/").length;
-                    if (r !== a + 1 && r !== a) throw new xt("Cannot perform an `add` operation at the desired path", "OPERATION_PATH_CANNOT_ADD", t, e, n)
+                        s = i.split("/").length;
+                    if (r !== s + 1 && r !== s) throw new yt("Cannot perform an `add` operation at the desired path", "OPERATION_PATH_CANNOT_ADD", t, e, n)
                 } else if (e.op === "replace" || e.op === "remove" || e.op === "_get") {
-                    if (e.path !== i) throw new xt("Cannot perform the operation at a path that does not exist", "OPERATION_PATH_UNRESOLVABLE", t, e, n)
+                    if (e.path !== i) throw new yt("Cannot perform the operation at a path that does not exist", "OPERATION_PATH_UNRESOLVABLE", t, e, n)
                 } else if (e.op === "move" || e.op === "copy") {
-                    var s = {
+                    var a = {
                             op: "_get",
                             path: e.from,
                             value: void 0
                         },
-                        o = kR([s], n);
-                    if (o && o.name === "OPERATION_PATH_UNRESOLVABLE") throw new xt("Cannot perform the operation from a path that does not exist", "OPERATION_FROM_UNRESOLVABLE", t, e, n)
+                        o = IR([a], n);
+                    if (o && o.name === "OPERATION_PATH_UNRESOLVABLE") throw new yt("Cannot perform the operation from a path that does not exist", "OPERATION_FROM_UNRESOLVABLE", t, e, n)
                 }
             }
-        } else throw new xt("Operation `op` property is not one of operations defined in RFC-6902", "OPERATION_OP_INVALID", t, e, n)
+        } else throw new yt("Operation `op` property is not one of operations defined in RFC-6902", "OPERATION_OP_INVALID", t, e, n)
     }
 
-    function kR(e, t, n) {
+    function IR(e, t, n) {
         try {
-            if (!Array.isArray(e)) throw new xt("Patch sequence must be an array", "SEQUENCE_NOT_AN_ARRAY");
-            if (t) qm(yi(t), yi(e), n || !0);
+            if (!Array.isArray(e)) throw new yt("Patch sequence must be an array", "SEQUENCE_NOT_AN_ARRAY");
+            if (t) Em(pi(t), pi(e), n || !0);
             else {
-                n = n || k0;
+                n = n || l0;
                 for (var i = 0; i < e.length; i++) n(e[i], i, t, void 0)
             }
         } catch (r) {
-            if (r instanceof xt) return r;
+            if (r instanceof yt) return r;
             throw r
         }
     }
 
-    function Rh(e, t) {
+    function wh(e, t) {
         if (e === t) return !0;
         if (e && t && typeof e == "object" && typeof t == "object") {
             var n = Array.isArray(e),
                 i = Array.isArray(t),
-                r, a, s;
+                r, s, a;
             if (n && i) {
-                if (a = e.length, a != t.length) return !1;
-                for (r = a; r-- !== 0;)
-                    if (!Rh(e[r], t[r])) return !1;
+                if (s = e.length, s != t.length) return !1;
+                for (r = s; r-- !== 0;)
+                    if (!wh(e[r], t[r])) return !1;
                 return !0
             }
             if (n != i) return !1;
             var o = Object.keys(e);
-            if (a = o.length, a !== Object.keys(t).length) return !1;
-            for (r = a; r-- !== 0;)
+            if (s = o.length, s !== Object.keys(t).length) return !1;
+            for (r = s; r-- !== 0;)
                 if (!t.hasOwnProperty(o[r])) return !1;
-            for (r = a; r-- !== 0;)
-                if (s = o[r], !Rh(e[s], t[s])) return !1;
+            for (r = s; r-- !== 0;)
+                if (a = o[r], !wh(e[a], t[a])) return !1;
             return !0
         }
         return e !== e && t !== t
     }
-    const xX = Object.freeze(Object.defineProperty({
+    const AY = Object.freeze(Object.defineProperty({
         __proto__: null,
-        JsonPatchError: xt,
-        _areEquals: Rh,
-        applyOperation: tl,
-        applyPatch: qm,
-        applyReducer: bX,
-        deepClone: yX,
-        getValueByPointer: C0,
-        validate: kR,
-        validator: k0
+        JsonPatchError: yt,
+        _areEquals: wh,
+        applyOperation: Uo,
+        applyPatch: Em,
+        applyReducer: kY,
+        deepClone: EY,
+        getValueByPointer: o0,
+        validate: IR,
+        validator: l0
     }, Symbol.toStringTag, {
         value: "Module"
     }));
     /*!
      * https://github.com/Starcounter-Jack/JSON-Patch
      * (c) 2017-2021 Joachim Wester
      * MIT license
      */
-    var I_ = new WeakMap,
-        _X = function() {
+    var i_ = new WeakMap,
+        $Y = function() {
             function e(t) {
                 this.observers = new Map, this.obj = t
             }
             return e
         }(),
-        wX = function() {
+        TY = function() {
             function e(t, n) {
                 this.callback = t, this.observer = n
             }
             return e
         }();
 
-    function SX(e) {
-        return I_.get(e)
+    function MY(e) {
+        return i_.get(e)
     }
 
-    function EX(e, t) {
+    function OY(e, t) {
         return e.observers.get(t)
     }
 
-    function OX(e, t) {
+    function FY(e, t) {
         e.observers.delete(t.callback)
     }
 
-    function CX(e, t) {
+    function RY(e, t) {
         t.unobserve()
     }
 
-    function kX(e, t) {
+    function DY(e, t) {
         var n = [],
-            i, r = SX(e);
-        if (!r) r = new _X(e), I_.set(e, r);
+            i, r = MY(e);
+        if (!r) r = new $Y(e), i_.set(e, r);
         else {
-            var a = EX(r, t);
-            i = a && a.observer
+            var s = OY(r, t);
+            i = s && s.observer
         }
         if (i) return i;
-        if (i = {}, r.value = yi(e), t) {
+        if (i = {}, r.value = pi(e), t) {
             i.callback = t, i.next = null;
-            var s = function() {
-                    m2(i)
+            var a = function() {
+                    Wb(i)
                 },
                 o = function() {
-                    clearTimeout(i.next), i.next = setTimeout(s)
+                    clearTimeout(i.next), i.next = setTimeout(a)
                 };
             typeof window < "u" && (window.addEventListener("mouseup", o), window.addEventListener("keyup", o), window.addEventListener("mousedown", o), window.addEventListener("keydown", o), window.addEventListener("change", o))
         }
         return i.patches = n, i.object = e, i.unobserve = function() {
-            m2(i), clearTimeout(i.next), OX(r, i), typeof window < "u" && (window.removeEventListener("mouseup", o), window.removeEventListener("keyup", o), window.removeEventListener("mousedown", o), window.removeEventListener("keydown", o), window.removeEventListener("change", o))
-        }, r.observers.set(t, new wX(t, i)), i
+            Wb(i), clearTimeout(i.next), FY(r, i), typeof window < "u" && (window.removeEventListener("mouseup", o), window.removeEventListener("keyup", o), window.removeEventListener("mousedown", o), window.removeEventListener("keydown", o), window.removeEventListener("change", o))
+        }, r.observers.set(t, new TY(t, i)), i
     }
 
-    function m2(e, t) {
+    function Wb(e, t) {
         t === void 0 && (t = !1);
-        var n = I_.get(e.object);
-        j_(n.value, e.object, e.patches, "", t), e.patches.length && qm(n.value, e.patches);
+        var n = i_.get(e.object);
+        r_(n.value, e.object, e.patches, "", t), e.patches.length && Em(n.value, e.patches);
         var i = e.patches;
         return i.length > 0 && (e.patches = [], e.callback && e.callback(i)), i
     }
 
-    function j_(e, t, n, i, r) {
+    function r_(e, t, n, i, r) {
         if (t !== e) {
             typeof t.toJSON == "function" && (t = t.toJSON());
-            for (var a = d2(t), s = d2(e), o = !1, l = s.length - 1; l >= 0; l--) {
-                var u = s[l],
+            for (var s = jb(t), a = jb(e), o = !1, l = a.length - 1; l >= 0; l--) {
+                var u = a[l],
                     c = e[u];
-                if (h2(t, u) && !(t[u] === void 0 && c !== void 0 && Array.isArray(t) === !1)) {
+                if (Bb(t, u) && !(t[u] === void 0 && c !== void 0 && Array.isArray(t) === !1)) {
                     var f = t[u];
-                    typeof c == "object" && c != null && typeof f == "object" && f != null && Array.isArray(c) === Array.isArray(f) ? j_(c, f, n, i + "/" + Io(u), r) : c !== f && (r && n.push({
+                    typeof c == "object" && c != null && typeof f == "object" && f != null && Array.isArray(c) === Array.isArray(f) ? r_(c, f, n, i + "/" + ko(u), r) : c !== f && (r && n.push({
                         op: "test",
-                        path: i + "/" + Io(u),
-                        value: yi(c)
+                        path: i + "/" + ko(u),
+                        value: pi(c)
                     }), n.push({
                         op: "replace",
-                        path: i + "/" + Io(u),
-                        value: yi(f)
+                        path: i + "/" + ko(u),
+                        value: pi(f)
                     }))
                 } else Array.isArray(e) === Array.isArray(t) ? (r && n.push({
                     op: "test",
-                    path: i + "/" + Io(u),
-                    value: yi(c)
+                    path: i + "/" + ko(u),
+                    value: pi(c)
                 }), n.push({
                     op: "remove",
-                    path: i + "/" + Io(u)
+                    path: i + "/" + ko(u)
                 }), o = !0) : (r && n.push({
                     op: "test",
                     path: i,
                     value: e
                 }), n.push({
                     op: "replace",
                     path: i,
                     value: t
                 }))
             }
-            if (!(!o && a.length == s.length))
-                for (var l = 0; l < a.length; l++) {
-                    var u = a[l];
-                    !h2(e, u) && t[u] !== void 0 && n.push({
+            if (!(!o && s.length == a.length))
+                for (var l = 0; l < s.length; l++) {
+                    var u = s[l];
+                    !Bb(e, u) && t[u] !== void 0 && n.push({
                         op: "add",
-                        path: i + "/" + Io(u),
-                        value: yi(t[u])
+                        path: i + "/" + ko(u),
+                        value: pi(t[u])
                     })
                 }
         }
     }
 
-    function AX(e, t, n) {
+    function NY(e, t, n) {
         n === void 0 && (n = !1);
         var i = [];
-        return j_(e, t, i, "", n), i
+        return r_(e, t, i, "", n), i
     }
-    const TX = Object.freeze(Object.defineProperty({
+    const PY = Object.freeze(Object.defineProperty({
         __proto__: null,
-        compare: AX,
-        generate: m2,
-        observe: kX,
-        unobserve: CX
+        compare: NY,
+        generate: Wb,
+        observe: DY,
+        unobserve: RY
     }, Symbol.toStringTag, {
         value: "Module"
     }));
-    Object.assign({}, xX, TX, {
-        JsonPatchError: CR,
-        deepClone: yi,
-        escapePathComponent: Io,
-        unescapePathComponent: OR
-    });
-    var $X = /("(?:[^\\"]|\\.)*")|[:,]/g,
-        gv = function(t, n) {
-            var i, r, a;
-            return n = n || {}, i = JSON.stringify([1], void 0, n.indent === void 0 ? 2 : n.indent).slice(2, -3), r = i === "" ? 1 / 0 : n.maxLength === void 0 ? 80 : n.maxLength, a = n.replacer,
-                function s(o, l, u) {
+    Object.assign({}, AY, PY, {
+        JsonPatchError: LR,
+        deepClone: pi,
+        escapePathComponent: ko,
+        unescapePathComponent: PR
+    });
+
+    function Cm(e) {
+        return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e
+    }
+    var LY = /("(?:[^\\"]|\\.)*")|[:,]/g,
+        IY = function(t, n) {
+            var i, r, s;
+            return n = n || {}, i = JSON.stringify([1], void 0, n.indent === void 0 ? 2 : n.indent).slice(2, -3), r = i === "" ? 1 / 0 : n.maxLength === void 0 ? 80 : n.maxLength, s = n.replacer,
+                function a(o, l, u) {
                     var c, f, h, d, g, p, m, y, v, b, x, _;
-                    if (o && typeof o.toJSON == "function" && (o = o.toJSON()), x = JSON.stringify(o, a), x === void 0) return x;
-                    if (m = r - l.length - u, x.length <= m && (v = x.replace($X, function(S, w) {
+                    if (o && typeof o.toJSON == "function" && (o = o.toJSON()), x = JSON.stringify(o, s), x === void 0) return x;
+                    if (m = r - l.length - u, x.length <= m && (v = x.replace(LY, function(S, w) {
                             return w || S + " "
                         }), v.length <= m)) return v;
-                    if (a != null && (o = JSON.parse(x), a = void 0), typeof o == "object" && o !== null) {
+                    if (s != null && (o = JSON.parse(x), s = void 0), typeof o == "object" && o !== null) {
                         if (y = l + i, h = [], f = 0, Array.isArray(o))
-                            for (b = "[", c = "]", m = o.length; f < m; f++) h.push(s(o[f], y, f === m - 1 ? 0 : 1) || "null");
+                            for (b = "[", c = "]", m = o.length; f < m; f++) h.push(a(o[f], y, f === m - 1 ? 0 : 1) || "null");
                         else
-                            for (b = "{", c = "}", p = Object.keys(o), m = p.length; f < m; f++) d = p[f], g = JSON.stringify(d) + ": ", _ = s(o[d], y, g.length + (f === m - 1 ? 0 : 1)), _ !== void 0 && h.push(g + _);
+                            for (b = "{", c = "}", p = Object.keys(o), m = p.length; f < m; f++) d = p[f], g = JSON.stringify(d) + ": ", _ = a(o[d], y, g.length + (f === m - 1 ? 0 : 1)), _ !== void 0 && h.push(g + _);
                         if (h.length > 0) return [b, i + h.join(`,
 ` + y), c].join(`
 ` + l)
                     }
                     return x
                 }(t, "", 0)
         };
+    const Hy = Cm(IY);
 
-    function ci(e, t, n) {
+    function li(e, t, n) {
         return e.fields = t || [], e.fname = n, e
     }
 
-    function wt(e) {
+    function bt(e) {
         return e == null ? null : e.fname
     }
 
-    function yn(e) {
+    function pn(e) {
         return e == null ? null : e.fields
     }
 
-    function AR(e) {
-        return e.length === 1 ? MX(e[0]) : FX(e)
+    function zR(e) {
+        return e.length === 1 ? zY(e[0]) : BY(e)
     }
-    const MX = e => function(t) {
+    const zY = e => function(t) {
             return t[e]
         },
-        FX = e => {
+        BY = e => {
             const t = e.length;
             return function(n) {
                 for (let i = 0; i < t; ++i) n = n[e[i]];
                 return n
             }
         };
 
-    function G(e) {
+    function U(e) {
         throw Error(e)
     }
 
-    function ca(e) {
+    function ns(e) {
         const t = [],
             n = e.length;
         let i = null,
             r = 0,
-            a = "",
-            s, o, l;
+            s = "",
+            a, o, l;
         e = e + "";
 
         function u() {
-            t.push(a + e.substring(s, o)), a = "", s = o + 1
+            t.push(s + e.substring(a, o)), s = "", a = o + 1
         }
-        for (s = o = 0; o < n; ++o)
-            if (l = e[o], l === "\\") a += e.substring(s, o), a += e.substring(++o, ++o), s = o;
+        for (a = o = 0; o < n; ++o)
+            if (l = e[o], l === "\\") s += e.substring(a, o++), a = o;
             else if (l === i) u(), i = null, r = -1;
         else {
             if (i) continue;
-            s === r && l === '"' || s === r && l === "'" ? (s = o + 1, i = l) : l === "." && !r ? o > s ? u() : s = o + 1 : l === "[" ? (o > s && u(), r = s = o + 1) : l === "]" && (r || G("Access path missing open bracket: " + e), r > 0 && u(), r = 0, s = o + 1)
+            a === r && l === '"' || a === r && l === "'" ? (a = o + 1, i = l) : l === "." && !r ? o > a ? u() : a = o + 1 : l === "[" ? (o > a && u(), r = a = o + 1) : l === "]" && (r || U("Access path missing open bracket: " + e), r > 0 && u(), r = 0, a = o + 1)
         }
-        return r && G("Access path missing closing bracket: " + e), i && G("Access path missing closing quote: " + e), o > s && (o++, u()), t
+        return r && U("Access path missing closing bracket: " + e), i && U("Access path missing closing quote: " + e), o > a && (o++, u()), t
     }
 
-    function ri(e, t, n) {
-        const i = ca(e);
-        return e = i.length === 1 ? i[0] : e, ci((n && n.get || AR)(i), [e], t || e)
+    function ni(e, t, n) {
+        const i = ns(e);
+        return e = i.length === 1 ? i[0] : e, li((n && n.get || zR)(i), [e], t || e)
     }
-    const yd = ri("id"),
-        wn = ci(e => e, [], "identity"),
-        ws = ci(() => 0, [], "zero"),
-        $c = ci(() => 1, [], "one"),
-        Ii = ci(() => !0, [], "true"),
-        ds = ci(() => !1, [], "false");
+    const sd = ni("id"),
+        bn = li(e => e, [], "identity"),
+        ha = li(() => 0, [], "zero"),
+        vc = li(() => 1, [], "one"),
+        Ri = li(() => !0, [], "true"),
+        ia = li(() => !1, [], "false");
 
-    function DX(e, t, n) {
+    function jY(e, t, n) {
         const i = [t].concat([].slice.call(n));
         console[e].apply(console, i)
     }
-    const TR = 0,
-        z_ = 1,
-        B_ = 2,
-        $R = 3,
-        MR = 4;
-
-    function G_(e, t) {
-        let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : DX,
-            i = e || TR;
+    const BR = 0,
+        s_ = 1,
+        a_ = 2,
+        jR = 3,
+        UR = 4;
+
+    function o_(e, t) {
+        let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : jY,
+            i = e || BR;
         return {
             level(r) {
                 return arguments.length ? (i = +r, this) : i
             },
             error() {
-                return i >= z_ && n(t || "error", "ERROR", arguments), this
+                return i >= s_ && n(t || "error", "ERROR", arguments), this
             },
             warn() {
-                return i >= B_ && n(t || "warn", "WARN", arguments), this
+                return i >= a_ && n(t || "warn", "WARN", arguments), this
             },
             info() {
-                return i >= $R && n(t || "log", "INFO", arguments), this
+                return i >= jR && n(t || "log", "INFO", arguments), this
             },
             debug() {
-                return i >= MR && n(t || "log", "DEBUG", arguments), this
+                return i >= UR && n(t || "log", "DEBUG", arguments), this
             }
         }
     }
-    var q = Array.isArray;
+    var W = Array.isArray;
 
-    function se(e) {
+    function ae(e) {
         return e === Object(e)
     }
-    const sT = e => e !== "__proto__";
+    const x$ = e => e !== "__proto__";
 
-    function Mc() {
+    function bc() {
         for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];
         return t.reduce((i, r) => {
-            for (const a in r)
-                if (a === "signals") i.signals = RX(i.signals, r.signals);
+            for (const s in r)
+                if (s === "signals") i.signals = UY(i.signals, r.signals);
                 else {
-                    const s = a === "legend" ? {
+                    const a = s === "legend" ? {
                         layout: 1
-                    } : a === "style" ? !0 : null;
-                    Fc(i, a, r[a], s)
+                    } : s === "style" ? !0 : null;
+                    xc(i, s, r[s], a)
                 } return i
         }, {})
     }
 
-    function Fc(e, t, n, i) {
-        if (!sT(t)) return;
-        let r, a;
-        if (se(n) && !q(n)) {
-            a = se(e[t]) ? e[t] : e[t] = {};
-            for (r in n) i && (i === !0 || i[r]) ? Fc(a, r, n[r]) : sT(r) && (a[r] = n[r])
+    function xc(e, t, n, i) {
+        if (!x$(t)) return;
+        let r, s;
+        if (ae(n) && !W(n)) {
+            s = ae(e[t]) ? e[t] : e[t] = {};
+            for (r in n) i && (i === !0 || i[r]) ? xc(s, r, n[r]) : x$(r) && (s[r] = n[r])
         } else e[t] = n
     }
 
-    function RX(e, t) {
+    function UY(e, t) {
         if (e == null) return t;
         const n = {},
             i = [];
 
-        function r(a) {
-            n[a.name] || (n[a.name] = 1, i.push(a))
+        function r(s) {
+            n[s.name] || (n[s.name] = 1, i.push(s))
         }
         return t.forEach(r), e.forEach(r), i
     }
 
-    function Le(e) {
+    function De(e) {
         return e[e.length - 1]
     }
 
-    function gn(e) {
+    function hn(e) {
         return e == null || e === "" ? null : +e
     }
-    const FR = e => t => e * Math.exp(t),
-        DR = e => t => Math.log(e * t),
-        RR = e => t => Math.sign(t) * Math.log1p(Math.abs(t / e)),
-        PR = e => t => Math.sign(t) * Math.expm1(Math.abs(t)) * e,
-        A0 = e => t => t < 0 ? -Math.pow(-t, e) : Math.pow(t, e);
+    const GR = e => t => e * Math.exp(t),
+        WR = e => t => Math.log(e * t),
+        qR = e => t => Math.sign(t) * Math.log1p(Math.abs(t / e)),
+        HR = e => t => Math.sign(t) * Math.expm1(Math.abs(t)) * e,
+        u0 = e => t => t < 0 ? -Math.pow(-t, e) : Math.pow(t, e);
 
-    function Wm(e, t, n, i) {
+    function km(e, t, n, i) {
         const r = n(e[0]),
-            a = n(Le(e)),
-            s = (a - r) * t;
-        return [i(r - s), i(a - s)]
+            s = n(De(e)),
+            a = (s - r) * t;
+        return [i(r - a), i(s - a)]
     }
 
-    function NR(e, t) {
-        return Wm(e, t, gn, wn)
+    function YR(e, t) {
+        return km(e, t, hn, bn)
     }
 
-    function LR(e, t) {
+    function XR(e, t) {
         var n = Math.sign(e[0]);
-        return Wm(e, t, DR(n), FR(n))
+        return km(e, t, WR(n), GR(n))
     }
 
-    function IR(e, t, n) {
-        return Wm(e, t, A0(n), A0(1 / n))
+    function VR(e, t, n) {
+        return km(e, t, u0(n), u0(1 / n))
     }
 
-    function jR(e, t, n) {
-        return Wm(e, t, RR(n), PR(n))
+    function KR(e, t, n) {
+        return km(e, t, qR(n), HR(n))
     }
 
-    function Hm(e, t, n, i, r) {
-        const a = i(e[0]),
-            s = i(Le(e)),
-            o = t != null ? i(t) : (a + s) / 2;
-        return [r(o + (a - o) * n), r(o + (s - o) * n)]
+    function Am(e, t, n, i, r) {
+        const s = i(e[0]),
+            a = i(De(e)),
+            o = t != null ? i(t) : (s + a) / 2;
+        return [r(o + (s - o) * n), r(o + (a - o) * n)]
     }
 
-    function U_(e, t, n) {
-        return Hm(e, t, n, gn, wn)
+    function l_(e, t, n) {
+        return Am(e, t, n, hn, bn)
     }
 
-    function q_(e, t, n) {
+    function u_(e, t, n) {
         const i = Math.sign(e[0]);
-        return Hm(e, t, n, DR(i), FR(i))
+        return Am(e, t, n, WR(i), GR(i))
     }
 
-    function T0(e, t, n, i) {
-        return Hm(e, t, n, A0(i), A0(1 / i))
+    function c0(e, t, n, i) {
+        return Am(e, t, n, u0(i), u0(1 / i))
     }
 
-    function W_(e, t, n, i) {
-        return Hm(e, t, n, RR(i), PR(i))
+    function c_(e, t, n, i) {
+        return Am(e, t, n, qR(i), HR(i))
     }
 
-    function zR(e) {
+    function JR(e) {
         return 1 + ~~(new Date(e).getMonth() / 3)
     }
 
-    function BR(e) {
+    function QR(e) {
         return 1 + ~~(new Date(e).getUTCMonth() / 3)
     }
 
-    function ie(e) {
-        return e != null ? q(e) ? e : [e] : []
+    function se(e) {
+        return e != null ? W(e) ? e : [e] : []
     }
 
-    function GR(e, t, n) {
+    function ZR(e, t, n) {
         let i = e[0],
             r = e[1],
-            a;
-        return r < i && (a = r, r = i, i = a), a = r - i, a >= n - t ? [t, n] : [i = Math.min(Math.max(i, t), n - a), i + a]
+            s;
+        return r < i && (s = r, r = i, i = s), s = r - i, s >= n - t ? [t, n] : [i = Math.min(Math.max(i, t), n - s), i + s]
     }
 
-    function Ae(e) {
+    function $e(e) {
         return typeof e == "function"
     }
-    const PX = "descending";
+    const GY = "descending";
 
-    function H_(e, t, n) {
-        n = n || {}, t = ie(t) || [];
+    function f_(e, t, n) {
+        n = n || {}, t = se(t) || [];
         const i = [],
             r = [],
-            a = {},
-            s = n.comparator || NX;
-        return ie(e).forEach((o, l) => {
-            o != null && (i.push(t[l] === PX ? -1 : 1), r.push(o = Ae(o) ? o : ri(o, null, n)), (yn(o) || []).forEach(u => a[u] = 1))
-        }), r.length === 0 ? null : ci(s(r, i), Object.keys(a))
-    }
-    const Ym = (e, t) => (e < t || e == null) && t != null ? -1 : (e > t || t == null) && e != null ? 1 : (t = t instanceof Date ? +t : t, (e = e instanceof Date ? +e : e) !== e && t === t ? -1 : t !== t && e === e ? 1 : 0),
-        NX = (e, t) => e.length === 1 ? LX(e[0], t[0]) : IX(e, t, e.length),
-        LX = (e, t) => function(n, i) {
-            return Ym(e(n), e(i)) * t
+            s = {},
+            a = n.comparator || WY;
+        return se(e).forEach((o, l) => {
+            o != null && (i.push(t[l] === GY ? -1 : 1), r.push(o = $e(o) ? o : ni(o, null, n)), (pn(o) || []).forEach(u => s[u] = 1))
+        }), r.length === 0 ? null : li(a(r, i), Object.keys(s))
+    }
+    const $m = (e, t) => (e < t || e == null) && t != null ? -1 : (e > t || t == null) && e != null ? 1 : (t = t instanceof Date ? +t : t, (e = e instanceof Date ? +e : e) !== e && t === t ? -1 : t !== t && e === e ? 1 : 0),
+        WY = (e, t) => e.length === 1 ? qY(e[0], t[0]) : HY(e, t, e.length),
+        qY = (e, t) => function(n, i) {
+            return $m(e(n), e(i)) * t
         },
-        IX = (e, t, n) => (t.push(0), function(i, r) {
-            let a, s = 0,
+        HY = (e, t, n) => (t.push(0), function(i, r) {
+            let s, a = 0,
                 o = -1;
-            for (; s === 0 && ++o < n;) a = e[o], s = Ym(a(i), a(r));
-            return s * t[o]
+            for (; a === 0 && ++o < n;) s = e[o], a = $m(s(i), s(r));
+            return a * t[o]
         });
 
-    function Sn(e) {
-        return Ae(e) ? e : () => e
+    function xn(e) {
+        return $e(e) ? e : () => e
     }
 
-    function Y_(e, t) {
+    function h_(e, t) {
         let n;
         return i => {
             n && clearTimeout(n), n = setTimeout(() => (t(i), n = null), e)
         }
     }
 
-    function ke(e) {
+    function Ae(e) {
         for (let t, n, i = 1, r = arguments.length; i < r; ++i) {
             t = arguments[i];
             for (n in t) e[n] = t[n]
         }
         return e
     }
 
-    function Zr(e, t) {
+    function Hr(e, t) {
         let n = 0,
-            i, r, a, s;
+            i, r, s, a;
         if (e && (i = e.length))
             if (t == null) {
                 for (r = e[n]; n < i && (r == null || r !== r); r = e[++n]);
-                for (a = s = r; n < i; ++n) r = e[n], r != null && (r < a && (a = r), r > s && (s = r))
+                for (s = a = r; n < i; ++n) r = e[n], r != null && (r < s && (s = r), r > a && (a = r))
             } else {
                 for (r = t(e[n]); n < i && (r == null || r !== r); r = t(e[++n]));
-                for (a = s = r; n < i; ++n) r = t(e[n]), r != null && (r < a && (a = r), r > s && (s = r))
-            } return [a, s]
+                for (s = a = r; n < i; ++n) r = t(e[n]), r != null && (r < s && (s = r), r > a && (a = r))
+            } return [s, a]
     }
 
-    function UR(e, t) {
+    function eD(e, t) {
         const n = e.length;
         let i = -1,
-            r, a, s, o, l;
+            r, s, a, o, l;
         if (t == null) {
             for (; ++i < n;)
-                if (a = e[i], a != null && a >= a) {
-                    r = s = a;
+                if (s = e[i], s != null && s >= s) {
+                    r = a = s;
                     break
                 } if (i === n) return [-1, -1];
-            for (o = l = i; ++i < n;) a = e[i], a != null && (r > a && (r = a, o = i), s < a && (s = a, l = i))
+            for (o = l = i; ++i < n;) s = e[i], s != null && (r > s && (r = s, o = i), a < s && (a = s, l = i))
         } else {
             for (; ++i < n;)
-                if (a = t(e[i], i, e), a != null && a >= a) {
-                    r = s = a;
+                if (s = t(e[i], i, e), s != null && s >= s) {
+                    r = a = s;
                     break
                 } if (i === n) return [-1, -1];
-            for (o = l = i; ++i < n;) a = t(e[i], i, e), a != null && (r > a && (r = a, o = i), s < a && (s = a, l = i))
+            for (o = l = i; ++i < n;) s = t(e[i], i, e), s != null && (r > s && (r = s, o = i), a < s && (a = s, l = i))
         }
         return [o, l]
     }
-    const jX = Object.prototype.hasOwnProperty;
+    const YY = Object.prototype.hasOwnProperty;
 
-    function pe(e, t) {
-        return jX.call(e, t)
+    function me(e, t) {
+        return YY.call(e, t)
     }
-    const Tg = {};
+    const gg = {};
 
-    function Dc(e) {
+    function _c(e) {
         let t = {},
             n;
 
-        function i(a) {
-            return pe(t, a) && t[a] !== Tg
+        function i(s) {
+            return me(t, s) && t[s] !== gg
         }
         const r = {
             size: 0,
             empty: 0,
             object: t,
             has: i,
-            get(a) {
-                return i(a) ? t[a] : void 0
+            get(s) {
+                return i(s) ? t[s] : void 0
             },
-            set(a, s) {
-                return i(a) || (++r.size, t[a] === Tg && --r.empty), t[a] = s, this
+            set(s, a) {
+                return i(s) || (++r.size, t[s] === gg && --r.empty), t[s] = a, this
             },
-            delete(a) {
-                return i(a) && (--r.size, ++r.empty, t[a] = Tg), this
+            delete(s) {
+                return i(s) && (--r.size, ++r.empty, t[s] = gg), this
             },
             clear() {
                 r.size = r.empty = 0, r.object = t = {}
             },
-            test(a) {
-                return arguments.length ? (n = a, r) : n
+            test(s) {
+                return arguments.length ? (n = s, r) : n
             },
             clean() {
-                const a = {};
-                let s = 0;
+                const s = {};
+                let a = 0;
                 for (const o in t) {
                     const l = t[o];
-                    l !== Tg && (!n || !n(l)) && (a[o] = l, ++s)
+                    l !== gg && (!n || !n(l)) && (s[o] = l, ++a)
                 }
-                r.size = s, r.empty = 0, r.object = t = a
+                r.size = a, r.empty = 0, r.object = t = s
             }
         };
-        return e && Object.keys(e).forEach(a => {
-            r.set(a, e[a])
+        return e && Object.keys(e).forEach(s => {
+            r.set(s, e[s])
         }), r
     }
 
-    function qR(e, t, n, i, r, a) {
-        if (!n && n !== 0) return a;
-        const s = +n;
+    function tD(e, t, n, i, r, s) {
+        if (!n && n !== 0) return s;
+        const a = +n;
         let o = e[0],
-            l = Le(e),
+            l = De(e),
             u;
         l < o && (u = o, o = l, l = u), u = Math.abs(t - o);
         const c = Math.abs(l - t);
-        return u < c && u <= s ? i : c <= s ? r : a
+        return u < c && u <= a ? i : c <= a ? r : s
     }
 
-    function Q(e, t, n) {
+    function ee(e, t, n) {
         const i = e.prototype = Object.create(t.prototype);
         return Object.defineProperty(i, "constructor", {
             value: e,
             writable: !0,
             enumerable: !0,
             configurable: !0
-        }), ke(i, n)
+        }), Ae(i, n)
     }
 
-    function Su(e, t, n, i) {
+    function hu(e, t, n, i) {
         let r = t[0],
-            a = t[t.length - 1],
-            s;
-        return r > a && (s = r, r = a, a = s), n = n === void 0 || n, i = i === void 0 || i, (n ? r <= e : r < e) && (i ? e <= a : e < a)
+            s = t[t.length - 1],
+            a;
+        return r > s && (a = r, r = s, s = a), n = n === void 0 || n, i = i === void 0 || i, (n ? r <= e : r < e) && (i ? e <= s : e < s)
     }
 
-    function co(e) {
+    function Za(e) {
         return typeof e == "boolean"
     }
 
-    function Ds(e) {
+    function Ea(e) {
         return Object.prototype.toString.call(e) === "[object Date]"
     }
 
-    function WR(e) {
-        return e && Ae(e[Symbol.iterator])
+    function nD(e) {
+        return e && $e(e[Symbol.iterator])
     }
 
-    function tt(e) {
+    function Ze(e) {
         return typeof e == "number"
     }
 
-    function HR(e) {
+    function iD(e) {
         return Object.prototype.toString.call(e) === "[object RegExp]"
     }
 
     function re(e) {
         return typeof e == "string"
     }
 
-    function X_(e, t, n) {
-        e && (e = t ? ie(e).map(o => o.replace(/\\(.)/g, "$1")) : ie(e));
+    function d_(e, t, n) {
+        e && (e = t ? se(e).map(o => o.replace(/\\(.)/g, "$1")) : se(e));
         const i = e && e.length,
-            r = n && n.get || AR,
-            a = o => r(t ? [o] : ca(o));
-        let s;
-        if (!i) s = function() {
+            r = n && n.get || zR,
+            s = o => r(t ? [o] : ns(o));
+        let a;
+        if (!i) a = function() {
             return ""
         };
         else if (i === 1) {
-            const o = a(e[0]);
-            s = function(l) {
+            const o = s(e[0]);
+            a = function(l) {
                 return "" + o(l)
             }
         } else {
-            const o = e.map(a);
-            s = function(l) {
+            const o = e.map(s);
+            a = function(l) {
                 let u = "" + o[0](l),
                     c = 0;
                 for (; ++c < i;) u += "|" + o[c](l);
                 return u
             }
         }
-        return ci(s, e, "key")
+        return li(a, e, "key")
     }
 
-    function YR(e, t) {
+    function rD(e, t) {
         const n = e[0],
-            i = Le(e),
+            i = De(e),
             r = +t;
         return r ? r === 1 ? i : n + r * (i - n) : n
     }
-    const zX = 1e4;
+    const XY = 1e4;
 
-    function XR(e) {
-        e = +e || zX;
+    function sD(e) {
+        e = +e || XY;
         let t, n, i;
         const r = () => {
                 t = {}, n = {}, i = 0
             },
-            a = (s, o) => (++i > e && (n = t, t = {}, i = 1), t[s] = o);
+            s = (a, o) => (++i > e && (n = t, t = {}, i = 1), t[a] = o);
         return r(), {
             clear: r,
-            has: s => pe(t, s) || pe(n, s),
-            get: s => pe(t, s) ? t[s] : pe(n, s) ? a(s, n[s]) : void 0,
-            set: (s, o) => pe(t, s) ? t[s] = o : a(s, o)
+            has: a => me(t, a) || me(n, a),
+            get: a => me(t, a) ? t[a] : me(n, a) ? s(a, n[a]) : void 0,
+            set: (a, o) => me(t, a) ? t[a] = o : s(a, o)
         }
     }
 
-    function VR(e, t, n, i) {
+    function aD(e, t, n, i) {
         const r = t.length,
-            a = n.length;
-        if (!a) return t;
+            s = n.length;
+        if (!s) return t;
         if (!r) return n;
-        const s = i || new t.constructor(r + a);
+        const a = i || new t.constructor(r + s);
         let o = 0,
             l = 0,
             u = 0;
-        for (; o < r && l < a; ++u) s[u] = e(t[o], n[l]) > 0 ? n[l++] : t[o++];
-        for (; o < r; ++o, ++u) s[u] = t[o];
-        for (; l < a; ++l, ++u) s[u] = n[l];
-        return s
+        for (; o < r && l < s; ++u) a[u] = e(t[o], n[l]) > 0 ? n[l++] : t[o++];
+        for (; o < r; ++o, ++u) a[u] = t[o];
+        for (; l < s; ++l, ++u) a[u] = n[l];
+        return a
     }
 
-    function qf(e, t) {
+    function Ff(e, t) {
         let n = "";
         for (; --t >= 0;) n += e;
         return n
     }
 
-    function KR(e, t, n, i) {
+    function oD(e, t, n, i) {
         const r = n || " ",
-            a = e + "",
-            s = t - a.length;
-        return s <= 0 ? a : i === "left" ? qf(r, s) + a : i === "center" ? qf(r, ~~(s / 2)) + a + qf(r, Math.ceil(s / 2)) : a + qf(r, s)
+            s = e + "",
+            a = t - s.length;
+        return a <= 0 ? s : i === "left" ? Ff(r, a) + s : i === "center" ? Ff(r, ~~(a / 2)) + s + Ff(r, Math.ceil(a / 2)) : s + Ff(r, a)
     }
 
-    function vd(e) {
-        return e && Le(e) - e[0] || 0
+    function ad(e) {
+        return e && De(e) - e[0] || 0
     }
 
     function Z(e) {
-        return q(e) ? "[" + e.map(Z) + "]" : se(e) || re(e) ? JSON.stringify(e).replace("\u2028", "\\u2028").replace("\u2029", "\\u2029") : e
+        return W(e) ? "[" + e.map(Z) + "]" : ae(e) || re(e) ? JSON.stringify(e).replace("\u2028", "\\u2028").replace("\u2029", "\\u2029") : e
     }
 
-    function V_(e) {
+    function g_(e) {
         return e == null || e === "" ? null : !e || e === "false" || e === "0" ? !1 : !!e
     }
-    const BX = e => tt(e) || Ds(e) ? e : Date.parse(e);
+    const VY = e => Ze(e) || Ea(e) ? e : Date.parse(e);
 
-    function K_(e, t) {
-        return t = t || BX, e == null || e === "" ? null : t(e)
+    function p_(e, t) {
+        return t = t || VY, e == null || e === "" ? null : t(e)
     }
 
-    function J_(e) {
+    function m_(e) {
         return e == null || e === "" ? null : e + ""
     }
 
-    function br(e) {
+    function fr(e) {
         const t = {},
             n = e.length;
         for (let i = 0; i < n; ++i) t[e[i]] = !0;
         return t
     }
 
-    function JR(e, t, n, i) {
+    function lD(e, t, n, i) {
         const r = i ?? "…",
-            a = e + "",
-            s = a.length,
+            s = e + "",
+            a = s.length,
             o = Math.max(0, t - r.length);
-        return s <= t ? a : n === "left" ? r + a.slice(s - o) : n === "center" ? a.slice(0, Math.ceil(o / 2)) + r + a.slice(s - ~~(o / 2)) : a.slice(0, o) + r
+        return a <= t ? s : n === "left" ? r + s.slice(a - o) : n === "center" ? s.slice(0, Math.ceil(o / 2)) + r + s.slice(a - ~~(o / 2)) : s.slice(0, o) + r
     }
 
-    function ys(e, t, n) {
+    function oa(e, t, n) {
         if (e)
             if (t) {
                 const i = e.length;
                 for (let r = 0; r < i; ++r) {
-                    const a = t(e[r]);
-                    a && n(a, r, e)
+                    const s = t(e[r]);
+                    s && n(s, r, e)
                 }
             } else e.forEach(n)
     }
 
-    function GX(e) {
+    function KY(e) {
         return e
     }
 
-    function UX(e) {
-        if (e == null) return GX;
+    function JY(e) {
+        if (e == null) return KY;
         var t, n, i = e.scale[0],
             r = e.scale[1],
-            a = e.translate[0],
-            s = e.translate[1];
+            s = e.translate[0],
+            a = e.translate[1];
         return function(o, l) {
             l || (t = n = 0);
             var u = 2,
                 c = o.length,
                 f = new Array(c);
-            for (f[0] = (t += o[0]) * i + a, f[1] = (n += o[1]) * r + s; u < c;) f[u] = o[u], ++u;
+            for (f[0] = (t += o[0]) * i + s, f[1] = (n += o[1]) * r + a; u < c;) f[u] = o[u], ++u;
             return f
         }
     }
 
-    function qX(e, t) {
+    function QY(e, t) {
         for (var n, i = e.length, r = i - t; r < --i;) n = e[r], e[r++] = e[i], e[i] = n
     }
 
-    function WX(e, t) {
+    function ZY(e, t) {
         return typeof t == "string" && (t = e.objects[t]), t.type === "GeometryCollection" ? {
             type: "FeatureCollection",
             features: t.geometries.map(function(n) {
-                return oT(e, n)
+                return _$(e, n)
             })
-        } : oT(e, t)
+        } : _$(e, t)
     }
 
-    function oT(e, t) {
+    function _$(e, t) {
         var n = t.id,
             i = t.bbox,
             r = t.properties == null ? {} : t.properties,
-            a = QR(e, t);
+            s = uD(e, t);
         return n == null && i == null ? {
             type: "Feature",
             properties: r,
-            geometry: a
+            geometry: s
         } : i == null ? {
             type: "Feature",
             id: n,
             properties: r,
-            geometry: a
+            geometry: s
         } : {
             type: "Feature",
             id: n,
             bbox: i,
             properties: r,
-            geometry: a
+            geometry: s
         }
     }
 
-    function QR(e, t) {
-        var n = UX(e.transform),
+    function uD(e, t) {
+        var n = JY(e.transform),
             i = e.arcs;
 
         function r(c, f) {
             f.length && f.pop();
             for (var h = i[c < 0 ? ~c : c], d = 0, g = h.length; d < g; ++d) f.push(n(h[d], d));
-            c < 0 && qX(f, g)
+            c < 0 && QY(f, g)
         }
 
-        function a(c) {
+        function s(c) {
             return n(c)
         }
 
-        function s(c) {
+        function a(c) {
             for (var f = [], h = 0, d = c.length; h < d; ++h) r(c[h], f);
             return f.length < 2 && f.push(f[0]), f
         }
 
         function o(c) {
-            for (var f = s(c); f.length < 4;) f.push(f[0]);
+            for (var f = a(c); f.length < 4;) f.push(f[0]);
             return f
         }
 
         function l(c) {
             return c.map(o)
         }
 
@@ -17555,24 +17560,24 @@
                 h;
             switch (f) {
                 case "GeometryCollection":
                     return {
                         type: f, geometries: c.geometries.map(u)
                     };
                 case "Point":
-                    h = a(c.coordinates);
+                    h = s(c.coordinates);
                     break;
                 case "MultiPoint":
-                    h = c.coordinates.map(a);
+                    h = c.coordinates.map(s);
                     break;
                 case "LineString":
-                    h = s(c.arcs);
+                    h = a(c.arcs);
                     break;
                 case "MultiLineString":
-                    h = c.arcs.map(s);
+                    h = c.arcs.map(a);
                     break;
                 case "Polygon":
                     h = l(c.arcs);
                     break;
                 case "MultiPolygon":
                     h = c.arcs.map(l);
                     break;
@@ -17583,24 +17588,24 @@
                 type: f,
                 coordinates: h
             }
         }
         return u(t)
     }
 
-    function HX(e, t) {
+    function eX(e, t) {
         var n = {},
             i = {},
             r = {},
-            a = [],
-            s = -1;
+            s = [],
+            a = -1;
         t.forEach(function(u, c) {
             var f = e.arcs[u < 0 ? ~u : u],
                 h;
-            f.length < 3 && !f[1][0] && !f[1][1] && (h = t[++s], t[s] = u, t[c] = h)
+            f.length < 3 && !f[1][0] && !f[1][1] && (h = t[++a], t[a] = u, t[c] = h)
         }), t.forEach(function(u) {
             var c = o(u),
                 f = c[0],
                 h = c[1],
                 d, g;
             if (d = r[f])
                 if (delete r[d.end], d.push(u), d.end = h, g = i[h]) {
@@ -17627,64 +17632,64 @@
         }
 
         function l(u, c) {
             for (var f in u) {
                 var h = u[f];
                 delete c[h.start], delete h.start, delete h.end, h.forEach(function(d) {
                     n[d < 0 ? ~d : d] = 1
-                }), a.push(h)
+                }), s.push(h)
             }
         }
         return l(r, i), l(i, r), t.forEach(function(u) {
-            n[u < 0 ? ~u : u] || a.push([u])
-        }), a
+            n[u < 0 ? ~u : u] || s.push([u])
+        }), s
     }
 
-    function YX(e) {
-        return QR(e, XX.apply(this, arguments))
+    function tX(e) {
+        return uD(e, nX.apply(this, arguments))
     }
 
-    function XX(e, t, n) {
-        var i, r, a;
-        if (arguments.length > 1) i = VX(e, t, n);
+    function nX(e, t, n) {
+        var i, r, s;
+        if (arguments.length > 1) i = iX(e, t, n);
         else
-            for (r = 0, i = new Array(a = e.arcs.length); r < a; ++r) i[r] = r;
+            for (r = 0, i = new Array(s = e.arcs.length); r < s; ++r) i[r] = r;
         return {
             type: "MultiLineString",
-            arcs: HX(e, i)
+            arcs: eX(e, i)
         }
     }
 
-    function VX(e, t, n) {
+    function iX(e, t, n) {
         var i = [],
             r = [],
-            a;
+            s;
 
-        function s(f) {
+        function a(f) {
             var h = f < 0 ? ~f : f;
             (r[h] || (r[h] = [])).push({
                 i: f,
-                g: a
+                g: s
             })
         }
 
         function o(f) {
-            f.forEach(s)
+            f.forEach(a)
         }
 
         function l(f) {
             f.forEach(o)
         }
 
         function u(f) {
             f.forEach(l)
         }
 
         function c(f) {
-            switch (a = f, f.type) {
+            switch (s = f, f.type) {
                 case "GeometryCollection":
                     f.geometries.forEach(c);
                     break;
                 case "LineString":
                     o(f.arcs);
                     break;
                 case "MultiLineString":
@@ -17698,861 +17703,861 @@
         }
         return c(t), r.forEach(n == null ? function(f) {
             i.push(f[0].i)
         } : function(f) {
             n(f[0].g, f[f.length - 1].g) && i.push(f[0].i)
         }), i
     }
-    const tn = "year",
-        ai = "quarter",
-        vn = "month",
-        Dt = "week",
-        si = "date",
-        dn = "day",
-        ea = "dayofyear",
-        xi = "hours",
-        _i = "minutes",
-        ji = "seconds",
-        xr = "milliseconds",
-        Q_ = [tn, ai, vn, Dt, si, dn, ea, xi, _i, ji, xr],
-        pv = Q_.reduce((e, t, n) => (e[t] = 1 + n, e), {});
+    const Jt = "year",
+        ii = "quarter",
+        mn = "month",
+        Tt = "week",
+        ri = "date",
+        fn = "day",
+        Yr = "dayofyear",
+        vi = "hours",
+        bi = "minutes",
+        Di = "seconds",
+        hr = "milliseconds",
+        y_ = [Jt, ii, mn, Tt, ri, fn, Yr, vi, bi, Di, hr],
+        Yy = y_.reduce((e, t, n) => (e[t] = 1 + n, e), {});
 
-    function Z_(e) {
-        const t = ie(e).slice(),
+    function v_(e) {
+        const t = se(e).slice(),
             n = {};
-        return t.length || G("Missing time unit."), t.forEach(r => {
-            pe(pv, r) ? n[r] = 1 : G(`Invalid time unit: ${r}.`)
-        }), (n[Dt] || n[dn] ? 1 : 0) + (n[ai] || n[vn] || n[si] ? 1 : 0) + (n[ea] ? 1 : 0) > 1 && G(`Incompatible time units: ${e}`), t.sort((r, a) => pv[r] - pv[a]), t
-    }
-    const KX = {
-        [tn]: "%Y ",
-        [ai]: "Q%q ",
-        [vn]: "%b ",
-        [si]: "%d ",
-        [Dt]: "W%U ",
-        [dn]: "%a ",
-        [ea]: "%j ",
-        [xi]: "%H:00",
-        [_i]: "00:%M",
-        [ji]: ":%S",
-        [xr]: ".%L",
-        [`${tn}-${vn}`]: "%Y-%m ",
-        [`${tn}-${vn}-${si}`]: "%Y-%m-%d ",
-        [`${xi}-${_i}`]: "%H:%M"
-    };
-
-    function ZR(e, t) {
-        const n = ke({}, KX, t),
-            i = Z_(e),
+        return t.length || U("Missing time unit."), t.forEach(r => {
+            me(Yy, r) ? n[r] = 1 : U(`Invalid time unit: ${r}.`)
+        }), (n[Tt] || n[fn] ? 1 : 0) + (n[ii] || n[mn] || n[ri] ? 1 : 0) + (n[Yr] ? 1 : 0) > 1 && U(`Incompatible time units: ${e}`), t.sort((r, s) => Yy[r] - Yy[s]), t
+    }
+    const rX = {
+        [Jt]: "%Y ",
+        [ii]: "Q%q ",
+        [mn]: "%b ",
+        [ri]: "%d ",
+        [Tt]: "W%U ",
+        [fn]: "%a ",
+        [Yr]: "%j ",
+        [vi]: "%H:00",
+        [bi]: "00:%M",
+        [Di]: ":%S",
+        [hr]: ".%L",
+        [`${Jt}-${mn}`]: "%Y-%m ",
+        [`${Jt}-${mn}-${ri}`]: "%Y-%m-%d ",
+        [`${vi}-${bi}`]: "%H:%M"
+    };
+
+    function cD(e, t) {
+        const n = Ae({}, rX, t),
+            i = v_(e),
             r = i.length;
-        let a = "",
-            s = 0,
+        let s = "",
+            a = 0,
             o, l;
-        for (s = 0; s < r;)
-            for (o = i.length; o > s; --o)
-                if (l = i.slice(s, o).join("-"), n[l] != null) {
-                    a += n[l], s = o;
+        for (a = 0; a < r;)
+            for (o = i.length; o > a; --o)
+                if (l = i.slice(a, o).join("-"), n[l] != null) {
+                    s += n[l], a = o;
                     break
-                } return a.trim()
+                } return s.trim()
     }
-    const zo = new Date;
+    const $o = new Date;
 
-    function ew(e) {
-        return zo.setFullYear(e), zo.setMonth(0), zo.setDate(1), zo.setHours(0, 0, 0, 0), zo
+    function b_(e) {
+        return $o.setFullYear(e), $o.setMonth(0), $o.setDate(1), $o.setHours(0, 0, 0, 0), $o
     }
 
-    function eP(e) {
-        return nP(new Date(e))
+    function fD(e) {
+        return dD(new Date(e))
     }
 
-    function tP(e) {
-        return y2(new Date(e))
+    function hD(e) {
+        return qb(new Date(e))
     }
 
-    function nP(e) {
-        return Ba.count(ew(e.getFullYear()) - 1, e)
+    function dD(e) {
+        return Os.count(b_(e.getFullYear()) - 1, e)
     }
 
-    function y2(e) {
-        return Ac.count(ew(e.getFullYear()) - 1, e)
+    function qb(e) {
+        return mc.count(b_(e.getFullYear()) - 1, e)
     }
 
-    function v2(e) {
-        return ew(e).getDay()
+    function Hb(e) {
+        return b_(e).getDay()
     }
 
-    function JX(e, t, n, i, r, a, s) {
+    function sX(e, t, n, i, r, s, a) {
         if (0 <= e && e < 100) {
-            const o = new Date(-1, t, n, i, r, a, s);
+            const o = new Date(-1, t, n, i, r, s, a);
             return o.setFullYear(e), o
         }
-        return new Date(e, t, n, i, r, a, s)
+        return new Date(e, t, n, i, r, s, a)
     }
 
-    function iP(e) {
-        return aP(new Date(e))
+    function gD(e) {
+        return mD(new Date(e))
     }
 
-    function rP(e) {
-        return b2(new Date(e))
+    function pD(e) {
+        return Yb(new Date(e))
     }
 
-    function aP(e) {
+    function mD(e) {
         const t = Date.UTC(e.getUTCFullYear(), 0, 1);
-        return Fs.count(t - 1, e)
+        return Sa.count(t - 1, e)
     }
 
-    function b2(e) {
+    function Yb(e) {
         const t = Date.UTC(e.getUTCFullYear(), 0, 1);
-        return Tc.count(t - 1, e)
+        return yc.count(t - 1, e)
     }
 
-    function x2(e) {
-        return zo.setTime(Date.UTC(e, 0, 1)), zo.getUTCDay()
+    function Xb(e) {
+        return $o.setTime(Date.UTC(e, 0, 1)), $o.getUTCDay()
     }
 
-    function QX(e, t, n, i, r, a, s) {
+    function aX(e, t, n, i, r, s, a) {
         if (0 <= e && e < 100) {
-            const o = new Date(Date.UTC(-1, t, n, i, r, a, s));
+            const o = new Date(Date.UTC(-1, t, n, i, r, s, a));
             return o.setUTCFullYear(n.y), o
         }
-        return new Date(Date.UTC(e, t, n, i, r, a, s))
+        return new Date(Date.UTC(e, t, n, i, r, s, a))
     }
 
-    function sP(e, t, n, i, r) {
-        const a = t || 1,
-            s = Le(e),
-            o = (y, v, b) => (b = b || y, ZX(n[b], i[b], y === s && a, v)),
+    function yD(e, t, n, i, r) {
+        const s = t || 1,
+            a = De(e),
+            o = (y, v, b) => (b = b || y, oX(n[b], i[b], y === a && s, v)),
             l = new Date,
-            u = br(e),
-            c = u[tn] ? o(tn) : Sn(2012),
-            f = u[vn] ? o(vn) : u[ai] ? o(ai) : ws,
-            h = u[Dt] && u[dn] ? o(dn, 1, Dt + dn) : u[Dt] ? o(Dt, 1) : u[dn] ? o(dn, 1) : u[si] ? o(si, 1) : u[ea] ? o(ea, 1) : $c,
-            d = u[xi] ? o(xi) : ws,
-            g = u[_i] ? o(_i) : ws,
-            p = u[ji] ? o(ji) : ws,
-            m = u[xr] ? o(xr) : ws;
+            u = fr(e),
+            c = u[Jt] ? o(Jt) : xn(2012),
+            f = u[mn] ? o(mn) : u[ii] ? o(ii) : ha,
+            h = u[Tt] && u[fn] ? o(fn, 1, Tt + fn) : u[Tt] ? o(Tt, 1) : u[fn] ? o(fn, 1) : u[ri] ? o(ri, 1) : u[Yr] ? o(Yr, 1) : vc,
+            d = u[vi] ? o(vi) : ha,
+            g = u[bi] ? o(bi) : ha,
+            p = u[Di] ? o(Di) : ha,
+            m = u[hr] ? o(hr) : ha;
         return function(y) {
             l.setTime(+y);
             const v = c(l);
             return r(v, f(l), h(l, v), d(l), g(l), p(l), m(l))
         }
     }
 
-    function ZX(e, t, n, i) {
-        const r = n <= 1 ? e : i ? (a, s) => i + n * Math.floor((e(a, s) - i) / n) : (a, s) => n * Math.floor(e(a, s) / n);
-        return t ? (a, s) => t(r(a, s), s) : r
+    function oX(e, t, n, i) {
+        const r = n <= 1 ? e : i ? (s, a) => i + n * Math.floor((e(s, a) - i) / n) : (s, a) => n * Math.floor(e(s, a) / n);
+        return t ? (s, a) => t(r(s, a), a) : r
     }
 
-    function Qu(e, t, n) {
+    function ju(e, t, n) {
         return t + e * 7 - (n + 6) % 7
     }
-    const eV = {
-            [tn]: e => e.getFullYear(),
-            [ai]: e => Math.floor(e.getMonth() / 3),
-            [vn]: e => e.getMonth(),
-            [si]: e => e.getDate(),
-            [xi]: e => e.getHours(),
-            [_i]: e => e.getMinutes(),
-            [ji]: e => e.getSeconds(),
-            [xr]: e => e.getMilliseconds(),
-            [ea]: e => nP(e),
-            [Dt]: e => y2(e),
-            [Dt + dn]: (e, t) => Qu(y2(e), e.getDay(), v2(t)),
-            [dn]: (e, t) => Qu(1, e.getDay(), v2(t))
-        },
-        tV = {
-            [ai]: e => 3 * e,
-            [Dt]: (e, t) => Qu(e, 0, v2(t))
-        };
-
-    function oP(e, t) {
-        return sP(e, t || 1, eV, tV, JX)
-    }
-    const nV = {
-            [tn]: e => e.getUTCFullYear(),
-            [ai]: e => Math.floor(e.getUTCMonth() / 3),
-            [vn]: e => e.getUTCMonth(),
-            [si]: e => e.getUTCDate(),
-            [xi]: e => e.getUTCHours(),
-            [_i]: e => e.getUTCMinutes(),
-            [ji]: e => e.getUTCSeconds(),
-            [xr]: e => e.getUTCMilliseconds(),
-            [ea]: e => aP(e),
-            [Dt]: e => b2(e),
-            [dn]: (e, t) => Qu(1, e.getUTCDay(), x2(t)),
-            [Dt + dn]: (e, t) => Qu(b2(e), e.getUTCDay(), x2(t))
-        },
-        iV = {
-            [ai]: e => 3 * e,
-            [Dt]: (e, t) => Qu(e, 0, x2(t))
-        };
-
-    function lP(e, t) {
-        return sP(e, t || 1, nV, iV, QX)
-    }
-    const rV = {
-            [tn]: Jr,
-            [ai]: Fh.every(3),
-            [vn]: Fh,
-            [Dt]: Ac,
-            [si]: Ba,
-            [dn]: Ba,
-            [ea]: Ba,
-            [xi]: Lm,
-            [_i]: Pm,
-            [ji]: Na,
-            [xr]: Xu
-        },
-        aV = {
-            [tn]: Qr,
-            [ai]: Dh.every(3),
-            [vn]: Dh,
-            [Dt]: Tc,
-            [si]: Fs,
-            [dn]: Fs,
-            [ea]: Fs,
-            [xi]: Im,
-            [_i]: Nm,
-            [ji]: Na,
-            [xr]: Xu
-        };
-
-    function Rc(e) {
-        return rV[e]
+    const lX = {
+            [Jt]: e => e.getFullYear(),
+            [ii]: e => Math.floor(e.getMonth() / 3),
+            [mn]: e => e.getMonth(),
+            [ri]: e => e.getDate(),
+            [vi]: e => e.getHours(),
+            [bi]: e => e.getMinutes(),
+            [Di]: e => e.getSeconds(),
+            [hr]: e => e.getMilliseconds(),
+            [Yr]: e => dD(e),
+            [Tt]: e => qb(e),
+            [Tt + fn]: (e, t) => ju(qb(e), e.getDay(), Hb(t)),
+            [fn]: (e, t) => ju(1, e.getDay(), Hb(t))
+        },
+        uX = {
+            [ii]: e => 3 * e,
+            [Tt]: (e, t) => ju(e, 0, Hb(t))
+        };
+
+    function vD(e, t) {
+        return yD(e, t || 1, lX, uX, sX)
+    }
+    const cX = {
+            [Jt]: e => e.getUTCFullYear(),
+            [ii]: e => Math.floor(e.getUTCMonth() / 3),
+            [mn]: e => e.getUTCMonth(),
+            [ri]: e => e.getUTCDate(),
+            [vi]: e => e.getUTCHours(),
+            [bi]: e => e.getUTCMinutes(),
+            [Di]: e => e.getUTCSeconds(),
+            [hr]: e => e.getUTCMilliseconds(),
+            [Yr]: e => mD(e),
+            [Tt]: e => Yb(e),
+            [fn]: (e, t) => ju(1, e.getUTCDay(), Xb(t)),
+            [Tt + fn]: (e, t) => ju(Yb(e), e.getUTCDay(), Xb(t))
+        },
+        fX = {
+            [ii]: e => 3 * e,
+            [Tt]: (e, t) => ju(e, 0, Xb(t))
+        };
+
+    function bD(e, t) {
+        return yD(e, t || 1, cX, fX, aX)
+    }
+    const hX = {
+            [Jt]: Wr,
+            [ii]: xh.every(3),
+            [mn]: xh,
+            [Tt]: mc,
+            [ri]: Os,
+            [fn]: Os,
+            [Yr]: Os,
+            [vi]: ym,
+            [bi]: pm,
+            [Di]: ks,
+            [hr]: Lu
+        },
+        dX = {
+            [Jt]: qr,
+            [ii]: _h.every(3),
+            [mn]: _h,
+            [Tt]: yc,
+            [ri]: Sa,
+            [fn]: Sa,
+            [Yr]: Sa,
+            [vi]: vm,
+            [bi]: mm,
+            [Di]: ks,
+            [hr]: Lu
+        };
+
+    function wc(e) {
+        return hX[e]
     }
 
-    function Pc(e) {
-        return aV[e]
+    function Sc(e) {
+        return dX[e]
     }
 
-    function uP(e, t, n) {
+    function xD(e, t, n) {
         return e ? e.offset(t, n) : void 0
     }
 
-    function cP(e, t, n) {
-        return uP(Rc(e), t, n)
+    function _D(e, t, n) {
+        return xD(wc(e), t, n)
     }
 
-    function fP(e, t, n) {
-        return uP(Pc(e), t, n)
+    function wD(e, t, n) {
+        return xD(Sc(e), t, n)
     }
 
-    function hP(e, t, n, i) {
+    function SD(e, t, n, i) {
         return e ? e.range(t, n, i) : void 0
     }
 
-    function dP(e, t, n, i) {
-        return hP(Rc(e), t, n, i)
+    function ED(e, t, n, i) {
+        return SD(wc(e), t, n, i)
     }
 
-    function gP(e, t, n, i) {
-        return hP(Pc(e), t, n, i)
+    function CD(e, t, n, i) {
+        return SD(Sc(e), t, n, i)
     }
-    const Wf = 1e3,
-        Hf = Wf * 60,
-        Yf = Hf * 60,
-        Xm = Yf * 24,
-        sV = Xm * 7,
-        lT = Xm * 30,
-        _2 = Xm * 365,
-        pP = [tn, vn, si, xi, _i, ji, xr],
-        Xf = pP.slice(0, -1),
-        Vf = Xf.slice(0, -1),
-        Kf = Vf.slice(0, -1),
-        oV = Kf.slice(0, -1),
-        lV = [tn, Dt],
-        uT = [tn, vn],
-        mP = [tn],
-        ff = [
-            [Xf, 1, Wf],
-            [Xf, 5, 5 * Wf],
-            [Xf, 15, 15 * Wf],
-            [Xf, 30, 30 * Wf],
-            [Vf, 1, Hf],
-            [Vf, 5, 5 * Hf],
-            [Vf, 15, 15 * Hf],
-            [Vf, 30, 30 * Hf],
-            [Kf, 1, Yf],
-            [Kf, 3, 3 * Yf],
-            [Kf, 6, 6 * Yf],
-            [Kf, 12, 12 * Yf],
-            [oV, 1, Xm],
-            [lV, 1, sV],
-            [uT, 1, lT],
-            [uT, 3, 3 * lT],
-            [mP, 1, _2]
+    const Rf = 1e3,
+        Df = Rf * 60,
+        Nf = Df * 60,
+        Tm = Nf * 24,
+        gX = Tm * 7,
+        w$ = Tm * 30,
+        Vb = Tm * 365,
+        kD = [Jt, mn, ri, vi, bi, Di, hr],
+        Pf = kD.slice(0, -1),
+        Lf = Pf.slice(0, -1),
+        If = Lf.slice(0, -1),
+        pX = If.slice(0, -1),
+        mX = [Jt, Tt],
+        S$ = [Jt, mn],
+        AD = [Jt],
+        Jc = [
+            [Pf, 1, Rf],
+            [Pf, 5, 5 * Rf],
+            [Pf, 15, 15 * Rf],
+            [Pf, 30, 30 * Rf],
+            [Lf, 1, Df],
+            [Lf, 5, 5 * Df],
+            [Lf, 15, 15 * Df],
+            [Lf, 30, 30 * Df],
+            [If, 1, Nf],
+            [If, 3, 3 * Nf],
+            [If, 6, 6 * Nf],
+            [If, 12, 12 * Nf],
+            [pX, 1, Tm],
+            [mX, 1, gX],
+            [S$, 1, w$],
+            [S$, 3, 3 * w$],
+            [AD, 1, Vb]
         ];
 
-    function yP(e) {
+    function $D(e) {
         const t = e.extent,
             n = e.maxbins || 40,
-            i = Math.abs(vd(t)) / n;
-        let r = cd(o => o[2]).right(ff, i),
-            a, s;
-        return r === ff.length ? (a = mP, s = Bs(t[0] / _2, t[1] / _2, n)) : r ? (r = ff[i / ff[r - 1][2] < ff[r][2] / i ? r - 1 : r], a = r[0], s = r[1]) : (a = pP, s = Math.max(Bs(t[0], t[1], n), 1)), {
-            units: a,
-            step: s
+            i = Math.abs(ad(t)) / n;
+        let r = Qh(o => o[2]).right(Jc, i),
+            s, a;
+        return r === Jc.length ? (s = AD, a = Oa(t[0] / Vb, t[1] / Vb, n)) : r ? (r = Jc[i / Jc[r - 1][2] < Jc[r][2] / i ? r - 1 : r], s = r[0], a = r[1]) : (s = kD, a = Math.max(Oa(t[0], t[1], n), 1)), {
+            units: s,
+            step: a
         }
     }
 
-    function Jf(e) {
+    function zf(e) {
         const t = {};
         return n => t[n] || (t[n] = e(n))
     }
 
-    function uV(e, t) {
+    function yX(e, t) {
         return n => {
             const i = e(n),
                 r = i.indexOf(t);
             if (r < 0) return i;
-            let a = cV(i, r);
-            const s = a < i.length ? i.slice(a) : "";
-            for (; --a > r;)
-                if (i[a] !== "0") {
-                    ++a;
+            let s = vX(i, r);
+            const a = s < i.length ? i.slice(s) : "";
+            for (; --s > r;)
+                if (i[s] !== "0") {
+                    ++s;
                     break
-                } return i.slice(0, a) + s
+                } return i.slice(0, s) + a
         }
     }
 
-    function cV(e, t) {
+    function vX(e, t) {
         let n = e.lastIndexOf("e"),
             i;
         if (n > 0) return n;
         for (n = e.length; --n > t;)
             if (i = e.charCodeAt(n), i >= 48 && i <= 57) return n + 1
     }
 
-    function vP(e) {
-        const t = Jf(e.format),
+    function TD(e) {
+        const t = zf(e.format),
             n = e.formatPrefix;
         return {
             format: t,
             formatPrefix: n,
             formatFloat(i) {
-                const r = cl(i || ",");
+                const r = Qo(i || ",");
                 if (r.precision == null) {
                     switch (r.precision = 12, r.type) {
                         case "%":
                             r.precision -= 2;
                             break;
                         case "e":
                             r.precision -= 1;
                             break
                     }
-                    return uV(t(r), t(".1f")(1)[1])
+                    return yX(t(r), t(".1f")(1)[1])
                 } else return t(r)
             },
-            formatSpan(i, r, a, s) {
-                s = cl(s ?? ",f");
-                const o = Bs(i, r, a),
+            formatSpan(i, r, s, a) {
+                a = Qo(a ?? ",f");
+                const o = Oa(i, r, s),
                     l = Math.max(Math.abs(i), Math.abs(r));
                 let u;
-                if (s.precision == null) switch (s.type) {
+                if (a.precision == null) switch (a.type) {
                     case "s":
-                        return isNaN(u = BF(o, l)) || (s.precision = u), n(s, l);
+                        return isNaN(u = QO(o, l)) || (a.precision = u), n(a, l);
                     case "":
                     case "e":
                     case "g":
                     case "p":
                     case "r": {
-                        isNaN(u = GF(o, l)) || (s.precision = u - (s.type === "e"));
+                        isNaN(u = ZO(o, l)) || (a.precision = u - (a.type === "e"));
                         break
                     }
                     case "f":
                     case "%": {
-                        isNaN(u = zF(o)) || (s.precision = u - (s.type === "%") * 2);
+                        isNaN(u = JO(o)) || (a.precision = u - (a.type === "%") * 2);
                         break
                     }
                 }
-                return t(s)
+                return t(a)
             }
         }
     }
-    let w2;
-    bP();
+    let Kb;
+    MD();
 
-    function bP() {
-        return w2 = vP({
-            format: Am,
-            formatPrefix: d_
+    function MD() {
+        return Kb = TD({
+            format: lm,
+            formatPrefix: Fx
         })
     }
 
-    function xP(e) {
-        return vP(jF(e))
-    }
-
-    function $0(e) {
-        return arguments.length ? w2 = xP(e) : w2
+    function OD(e) {
+        return TD(KO(e))
     }
 
-    function cT(e, t, n) {
-        n = n || {}, se(n) || G(`Invalid time multi-format specifier: ${n}`);
-        const i = t(ji),
-            r = t(_i),
-            a = t(xi),
-            s = t(si),
-            o = t(Dt),
-            l = t(vn),
-            u = t(ai),
-            c = t(tn),
-            f = e(n[xr] || ".%L"),
-            h = e(n[ji] || ":%S"),
-            d = e(n[_i] || "%I:%M"),
-            g = e(n[xi] || "%I %p"),
-            p = e(n[si] || n[dn] || "%a %d"),
-            m = e(n[Dt] || "%b %d"),
-            y = e(n[vn] || "%B"),
-            v = e(n[ai] || "%B"),
-            b = e(n[tn] || "%Y");
-        return x => (i(x) < x ? f : r(x) < x ? h : a(x) < x ? d : s(x) < x ? g : l(x) < x ? o(x) < x ? p : m : c(x) < x ? u(x) < x ? y : v : b)(x)
+    function f0(e) {
+        return arguments.length ? Kb = OD(e) : Kb
     }
 
-    function _P(e) {
-        const t = Jf(e.format),
-            n = Jf(e.utcFormat);
-        return {
-            timeFormat: i => re(i) ? t(i) : cT(t, Rc, i),
-            utcFormat: i => re(i) ? n(i) : cT(n, Pc, i),
-            timeParse: Jf(e.parse),
-            utcParse: Jf(e.utcParse)
-        }
-    }
-    let S2;
-    wP();
-
-    function wP() {
-        return S2 = _P({
-            format: k_,
-            parse: tR,
-            utcFormat: A_,
-            utcParse: nR
+    function E$(e, t, n) {
+        n = n || {}, ae(n) || U(`Invalid time multi-format specifier: ${n}`);
+        const i = t(Di),
+            r = t(bi),
+            s = t(vi),
+            a = t(ri),
+            o = t(Tt),
+            l = t(mn),
+            u = t(ii),
+            c = t(Jt),
+            f = e(n[hr] || ".%L"),
+            h = e(n[Di] || ":%S"),
+            d = e(n[bi] || "%I:%M"),
+            g = e(n[vi] || "%I %p"),
+            p = e(n[ri] || n[fn] || "%a %d"),
+            m = e(n[Tt] || "%b %d"),
+            y = e(n[mn] || "%B"),
+            v = e(n[ii] || "%B"),
+            b = e(n[Jt] || "%Y");
+        return x => (i(x) < x ? f : r(x) < x ? h : s(x) < x ? d : a(x) < x ? g : l(x) < x ? o(x) < x ? p : m : c(x) < x ? u(x) < x ? y : v : b)(x)
+    }
+
+    function FD(e) {
+        const t = zf(e.format),
+            n = zf(e.utcFormat);
+        return {
+            timeFormat: i => re(i) ? t(i) : E$(t, wc, i),
+            utcFormat: i => re(i) ? n(i) : E$(n, Sc, i),
+            timeParse: zf(e.parse),
+            utcParse: zf(e.utcParse)
+        }
+    }
+    let Jb;
+    RD();
+
+    function RD() {
+        return Jb = FD({
+            format: Hx,
+            parse: hR,
+            utcFormat: Yx,
+            utcParse: dR
         })
     }
 
-    function SP(e) {
-        return _P(KD(e))
+    function DD(e) {
+        return FD(oR(e))
     }
 
-    function Ph(e) {
-        return arguments.length ? S2 = SP(e) : S2
+    function Sh(e) {
+        return arguments.length ? Jb = DD(e) : Jb
     }
-    const E2 = (e, t) => ke({}, e, t);
+    const Qb = (e, t) => Ae({}, e, t);
 
-    function EP(e, t) {
-        const n = e ? xP(e) : $0(),
-            i = t ? SP(t) : Ph();
-        return E2(n, i)
+    function ND(e, t) {
+        const n = e ? OD(e) : f0(),
+            i = t ? DD(t) : Sh();
+        return Qb(n, i)
     }
 
-    function tw(e, t) {
+    function x_(e, t) {
         const n = arguments.length;
-        return n && n !== 2 && G("defaultLocale expects either zero or two arguments."), n ? E2($0(e), Ph(t)) : E2($0(), Ph())
+        return n && n !== 2 && U("defaultLocale expects either zero or two arguments."), n ? Qb(f0(e), Sh(t)) : Qb(f0(), Sh())
     }
 
-    function fV() {
-        return bP(), wP(), tw()
+    function bX() {
+        return MD(), RD(), x_()
     }
-    const hV = /^(data:|([A-Za-z]+:)?\/\/)/,
-        dV = /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp|file|data):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i,
-        gV = /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205f\u3000]/g,
-        fT = "file://";
+    const xX = /^(data:|([A-Za-z]+:)?\/\/)/,
+        _X = /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp|file|data):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i,
+        wX = /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205f\u3000]/g,
+        C$ = "file://";
 
-    function pV(e, t) {
+    function SX(e, t) {
         return n => ({
             options: n || {},
-            sanitize: yV,
-            load: mV,
+            sanitize: CX,
+            load: EX,
             fileAccess: !!t,
-            file: vV(t),
-            http: xV(e)
+            file: kX(t),
+            http: $X(e)
         })
     }
-    async function mV(e, t) {
+    async function EX(e, t) {
         const n = await this.sanitize(e, t),
             i = n.href;
         return n.localFile ? this.file(i) : this.http(i, t)
     }
-    async function yV(e, t) {
-        t = ke({}, this.options, t);
+    async function CX(e, t) {
+        t = Ae({}, this.options, t);
         const n = this.fileAccess,
             i = {
                 href: null
             };
-        let r, a, s;
-        const o = dV.test(e.replace(gV, ""));
-        (e == null || typeof e != "string" || !o) && G("Sanitize failure, invalid URI: " + Z(e));
-        const l = hV.test(e);
-        return (s = t.baseURL) && !l && (!e.startsWith("/") && !s.endsWith("/") && (e = "/" + e), e = s + e), a = (r = e.startsWith(fT)) || t.mode === "file" || t.mode !== "http" && !l && n, r ? e = e.slice(fT.length) : e.startsWith("//") && (t.defaultProtocol === "file" ? (e = e.slice(2), a = !0) : e = (t.defaultProtocol || "http") + ":" + e), Object.defineProperty(i, "localFile", {
-            value: !!a
+        let r, s, a;
+        const o = _X.test(e.replace(wX, ""));
+        (e == null || typeof e != "string" || !o) && U("Sanitize failure, invalid URI: " + Z(e));
+        const l = xX.test(e);
+        return (a = t.baseURL) && !l && (!e.startsWith("/") && !a.endsWith("/") && (e = "/" + e), e = a + e), s = (r = e.startsWith(C$)) || t.mode === "file" || t.mode !== "http" && !l && n, r ? e = e.slice(C$.length) : e.startsWith("//") && (t.defaultProtocol === "file" ? (e = e.slice(2), s = !0) : e = (t.defaultProtocol || "http") + ":" + e), Object.defineProperty(i, "localFile", {
+            value: !!s
         }), i.href = e, t.target && (i.target = t.target + ""), t.rel && (i.rel = t.rel + ""), t.context === "image" && t.crossOrigin && (i.crossOrigin = t.crossOrigin + ""), i
     }
 
-    function vV(e) {
+    function kX(e) {
         return e ? t => new Promise((n, i) => {
-            e.readFile(t, (r, a) => {
-                r ? i(r) : n(a)
+            e.readFile(t, (r, s) => {
+                r ? i(r) : n(s)
             })
-        }) : bV
+        }) : AX
     }
-    async function bV() {
-        G("No file system access.")
+    async function AX() {
+        U("No file system access.")
     }
 
-    function xV(e) {
+    function $X(e) {
         return e ? async function(t, n) {
-            const i = ke({}, this.options.http, n),
+            const i = Ae({}, this.options.http, n),
                 r = n && n.response,
-                a = await e(t, i);
-            return a.ok ? Ae(a[r]) ? a[r]() : a.text() : G(a.status + "" + a.statusText)
-        }: _V
-    }
-    async function _V() {
-        G("No HTTP fetch method available.")
-    }
-    const wV = e => e != null && e === e,
-        SV = e => e === "true" || e === "false" || e === !0 || e === !1,
-        EV = e => !Number.isNaN(Date.parse(e)),
-        OP = e => !Number.isNaN(+e) && !(e instanceof Date),
-        OV = e => OP(e) && Number.isInteger(+e),
-        O2 = {
-            boolean: V_,
-            integer: gn,
-            number: gn,
-            date: K_,
-            string: J_,
-            unknown: wn
+                s = await e(t, i);
+            return s.ok ? $e(s[r]) ? s[r]() : s.text() : U(s.status + "" + s.statusText)
+        }: TX
+    }
+    async function TX() {
+        U("No HTTP fetch method available.")
+    }
+    const MX = e => e != null && e === e,
+        OX = e => e === "true" || e === "false" || e === !0 || e === !1,
+        FX = e => !Number.isNaN(Date.parse(e)),
+        PD = e => !Number.isNaN(+e) && !(e instanceof Date),
+        RX = e => PD(e) && Number.isInteger(+e),
+        Zb = {
+            boolean: g_,
+            integer: hn,
+            number: hn,
+            date: p_,
+            string: m_,
+            unknown: bn
         },
-        $g = [SV, OV, OP, EV],
-        CV = ["boolean", "integer", "number", "date"];
+        pg = [OX, RX, PD, FX],
+        DX = ["boolean", "integer", "number", "date"];
 
-    function CP(e, t) {
+    function LD(e, t) {
         if (!e || !e.length) return "unknown";
         const n = e.length,
-            i = $g.length,
-            r = $g.map((a, s) => s + 1);
-        for (let a = 0, s = 0, o, l; a < n; ++a)
-            for (l = t ? e[a][t] : e[a], o = 0; o < i; ++o)
-                if (r[o] && wV(l) && !$g[o](l) && (r[o] = 0, ++s, s === $g.length)) return "string";
-        return CV[r.reduce((a, s) => a === 0 ? s : a, 0) - 1]
+            i = pg.length,
+            r = pg.map((s, a) => a + 1);
+        for (let s = 0, a = 0, o, l; s < n; ++s)
+            for (l = t ? e[s][t] : e[s], o = 0; o < i; ++o)
+                if (r[o] && MX(l) && !pg[o](l) && (r[o] = 0, ++a, a === pg.length)) return "string";
+        return DX[r.reduce((s, a) => s === 0 ? a : s, 0) - 1]
     }
 
-    function kP(e, t) {
-        return t.reduce((n, i) => (n[i] = CP(e, i), n), {})
+    function ID(e, t) {
+        return t.reduce((n, i) => (n[i] = LD(e, i), n), {})
     }
 
-    function hT(e) {
+    function k$(e) {
         const t = function(n, i) {
             const r = {
                 delimiter: e
             };
-            return nw(n, i ? ke(i, r) : r)
+            return __(n, i ? Ae(i, r) : r)
         };
         return t.responseType = "text", t
     }
 
-    function nw(e, t) {
+    function __(e, t) {
         return t.header && (e = t.header.map(Z).join(t.delimiter) + `
-` + e), nU(t.delimiter).parse(e + "")
+` + e), uU(t.delimiter).parse(e + "")
     }
-    nw.responseType = "text";
+    __.responseType = "text";
 
-    function kV(e) {
-        return typeof Buffer == "function" && Ae(Buffer.isBuffer) ? Buffer.isBuffer(e) : !1
+    function NX(e) {
+        return typeof Buffer == "function" && $e(Buffer.isBuffer) ? Buffer.isBuffer(e) : !1
     }
 
-    function iw(e, t) {
-        const n = t && t.property ? ri(t.property) : wn;
-        return se(e) && !kV(e) ? AV(n(e), t) : n(JSON.parse(e))
+    function w_(e, t) {
+        const n = t && t.property ? ni(t.property) : bn;
+        return ae(e) && !NX(e) ? PX(n(e), t) : n(JSON.parse(e))
     }
-    iw.responseType = "json";
+    w_.responseType = "json";
 
-    function AV(e, t) {
-        return !q(e) && WR(e) && (e = [...e]), t && t.copy ? JSON.parse(JSON.stringify(e)) : e
+    function PX(e, t) {
+        return !W(e) && nD(e) && (e = [...e]), t && t.copy ? JSON.parse(JSON.stringify(e)) : e
     }
-    const TV = {
+    const LX = {
         interior: (e, t) => e !== t,
         exterior: (e, t) => e === t
     };
 
-    function AP(e, t) {
-        let n, i, r, a;
-        return e = iw(e, t), t && t.feature ? (n = WX, r = t.feature) : t && t.mesh ? (n = YX, r = t.mesh, a = TV[t.filter]) : G("Missing TopoJSON feature or mesh parameter."), i = (i = e.objects[r]) ? n(e, i, a) : G("Invalid TopoJSON object: " + r), i && i.features || [i]
-    }
-    AP.responseType = "json";
-    const dp = {
-        dsv: nw,
-        csv: hT(","),
-        tsv: hT("	"),
-        json: iw,
-        topojson: AP
+    function zD(e, t) {
+        let n, i, r, s;
+        return e = w_(e, t), t && t.feature ? (n = ZY, r = t.feature) : t && t.mesh ? (n = tX, r = t.mesh, s = LX[t.filter]) : U("Missing TopoJSON feature or mesh parameter."), i = (i = e.objects[r]) ? n(e, i, s) : U("Invalid TopoJSON object: " + r), i && i.features || [i]
+    }
+    zD.responseType = "json";
+    const Vg = {
+        dsv: __,
+        csv: k$(","),
+        tsv: k$("	"),
+        json: w_,
+        topojson: zD
     };
 
-    function rw(e, t) {
-        return arguments.length > 1 ? (dp[e] = t, this) : pe(dp, e) ? dp[e] : null
+    function S_(e, t) {
+        return arguments.length > 1 ? (Vg[e] = t, this) : me(Vg, e) ? Vg[e] : null
     }
 
-    function TP(e) {
-        const t = rw(e);
+    function BD(e) {
+        const t = S_(e);
         return t && t.responseType || "text"
     }
 
-    function $P(e, t, n, i) {
+    function jD(e, t, n, i) {
         t = t || {};
-        const r = rw(t.type || "json");
-        return r || G("Unknown data format type: " + t.type), e = r(e, t), t.parse && $V(e, t.parse, n, i), pe(e, "columns") && delete e.columns, e
+        const r = S_(t.type || "json");
+        return r || U("Unknown data format type: " + t.type), e = r(e, t), t.parse && IX(e, t.parse, n, i), me(e, "columns") && delete e.columns, e
     }
 
-    function $V(e, t, n, i) {
+    function IX(e, t, n, i) {
         if (!e.length) return;
-        const r = Ph();
+        const r = Sh();
         n = n || r.timeParse, i = i || r.utcParse;
-        let a = e.columns || Object.keys(e[0]),
-            s, o, l, u, c, f;
-        t === "auto" && (t = kP(e, a)), a = Object.keys(t);
-        const h = a.map(d => {
+        let s = e.columns || Object.keys(e[0]),
+            a, o, l, u, c, f;
+        t === "auto" && (t = ID(e, s)), s = Object.keys(t);
+        const h = s.map(d => {
             const g = t[d];
             let p, m;
             if (g && (g.startsWith("date:") || g.startsWith("utc:"))) return p = g.split(/:(.+)?/, 2), m = p[1], (m[0] === "'" && m[m.length - 1] === "'" || m[0] === '"' && m[m.length - 1] === '"') && (m = m.slice(1, -1)), (p[0] === "utc" ? i : n)(m);
-            if (!O2[g]) throw Error("Illegal format pattern: " + d + ":" + g);
-            return O2[g]
+            if (!Zb[g]) throw Error("Illegal format pattern: " + d + ":" + g);
+            return Zb[g]
         });
-        for (l = 0, c = e.length, f = a.length; l < c; ++l)
-            for (s = e[l], u = 0; u < f; ++u) o = a[u], s[o] = h[u](s[o])
+        for (l = 0, c = e.length, f = s.length; l < c; ++l)
+            for (a = e[l], u = 0; u < f; ++u) o = s[u], a[o] = h[u](a[o])
     }
-    const Vm = pV(typeof fetch < "u" && fetch, null);
+    const Mm = SX(typeof fetch < "u" && fetch, null);
 
-    function Km(e) {
-        const t = e || wn,
+    function Om(e) {
+        const t = e || bn,
             n = [],
             i = {};
         return n.add = r => {
-            const a = t(r);
-            return i[a] || (i[a] = 1, n.push(r)), n
+            const s = t(r);
+            return i[s] || (i[s] = 1, n.push(r)), n
         }, n.remove = r => {
-            const a = t(r);
-            if (i[a]) {
-                i[a] = 0;
-                const s = n.indexOf(r);
-                s >= 0 && n.splice(s, 1)
+            const s = t(r);
+            if (i[s]) {
+                i[s] = 0;
+                const a = n.indexOf(r);
+                a >= 0 && n.splice(a, 1)
             }
             return n
         }, n
     }
-    async function gp(e, t) {
+    async function Kg(e, t) {
         try {
             await t(e)
         } catch (n) {
             e.error(n)
         }
     }
-    const MP = Symbol("vega_id");
-    let MV = 1;
+    const UD = Symbol("vega_id");
+    let zX = 1;
 
-    function Jm(e) {
-        return !!(e && de(e))
+    function Fm(e) {
+        return !!(e && ge(e))
     }
 
-    function de(e) {
-        return e[MP]
+    function ge(e) {
+        return e[UD]
     }
 
-    function FP(e, t) {
-        return e[MP] = t, e
+    function GD(e, t) {
+        return e[UD] = t, e
     }
 
     function He(e) {
         const t = e === Object(e) ? e : {
             data: e
         };
-        return de(t) ? t : FP(t, MV++)
+        return ge(t) ? t : GD(t, zX++)
     }
 
-    function aw(e) {
-        return Qm(e, He({}))
+    function E_(e) {
+        return Rm(e, He({}))
     }
 
-    function Qm(e, t) {
+    function Rm(e, t) {
         for (const n in e) t[n] = e[n];
         return t
     }
 
-    function DP(e, t) {
-        return FP(t, de(e))
+    function WD(e, t) {
+        return GD(t, ge(e))
     }
 
-    function jl(e, t) {
-        return e ? t ? (n, i) => e(n, i) || de(t(n)) - de(t(i)) : (n, i) => e(n, i) || de(n) - de(i) : null
+    function $l(e, t) {
+        return e ? t ? (n, i) => e(n, i) || ge(t(n)) - ge(t(i)) : (n, i) => e(n, i) || ge(n) - ge(i) : null
     }
 
-    function RP(e) {
-        return e && e.constructor === zl
+    function qD(e) {
+        return e && e.constructor === Tl
     }
 
-    function zl() {
+    function Tl() {
         const e = [],
             t = [],
             n = [],
             i = [],
             r = [];
-        let a = null,
-            s = !1;
+        let s = null,
+            a = !1;
         return {
-            constructor: zl,
+            constructor: Tl,
             insert(o) {
-                const l = ie(o),
+                const l = se(o),
                     u = l.length;
                 for (let c = 0; c < u; ++c) e.push(l[c]);
                 return this
             },
             remove(o) {
-                const l = Ae(o) ? i : t,
-                    u = ie(o),
+                const l = $e(o) ? i : t,
+                    u = se(o),
                     c = u.length;
                 for (let f = 0; f < c; ++f) l.push(u[f]);
                 return this
             },
             modify(o, l, u) {
                 const c = {
                     field: l,
-                    value: Sn(u)
+                    value: xn(u)
                 };
-                return Ae(o) ? (c.filter = o, r.push(c)) : (c.tuple = o, n.push(c)), this
+                return $e(o) ? (c.filter = o, r.push(c)) : (c.tuple = o, n.push(c)), this
             },
             encode(o, l) {
-                return Ae(o) ? r.push({
+                return $e(o) ? r.push({
                     filter: o,
                     field: l
                 }) : n.push({
                     tuple: o,
                     field: l
                 }), this
             },
             clean(o) {
-                return a = o, this
+                return s = o, this
             },
             reflow() {
-                return s = !0, this
+                return a = !0, this
             },
             pulse(o, l) {
                 const u = {},
                     c = {};
                 let f, h, d, g, p, m;
-                for (f = 0, h = l.length; f < h; ++f) u[de(l[f])] = 1;
-                for (f = 0, h = t.length; f < h; ++f) p = t[f], u[de(p)] = -1;
+                for (f = 0, h = l.length; f < h; ++f) u[ge(l[f])] = 1;
+                for (f = 0, h = t.length; f < h; ++f) p = t[f], u[ge(p)] = -1;
                 for (f = 0, h = i.length; f < h; ++f) g = i[f], l.forEach(v => {
-                    g(v) && (u[de(v)] = -1)
+                    g(v) && (u[ge(v)] = -1)
                 });
-                for (f = 0, h = e.length; f < h; ++f) p = e[f], m = de(p), u[m] ? u[m] = 1 : o.add.push(He(e[f]));
-                for (f = 0, h = l.length; f < h; ++f) p = l[f], u[de(p)] < 0 && o.rem.push(p);
+                for (f = 0, h = e.length; f < h; ++f) p = e[f], m = ge(p), u[m] ? u[m] = 1 : o.add.push(He(e[f]));
+                for (f = 0, h = l.length; f < h; ++f) p = l[f], u[ge(p)] < 0 && o.rem.push(p);
 
                 function y(v, b, x) {
-                    x ? v[b] = x(v) : o.encode = b, s || (c[de(v)] = v)
+                    x ? v[b] = x(v) : o.encode = b, a || (c[ge(v)] = v)
                 }
-                for (f = 0, h = n.length; f < h; ++f) d = n[f], p = d.tuple, g = d.field, m = u[de(p)], m > 0 && (y(p, g, d.value), o.modifies(g));
+                for (f = 0, h = n.length; f < h; ++f) d = n[f], p = d.tuple, g = d.field, m = u[ge(p)], m > 0 && (y(p, g, d.value), o.modifies(g));
                 for (f = 0, h = r.length; f < h; ++f) d = r[f], g = d.filter, l.forEach(v => {
-                    g(v) && u[de(v)] > 0 && y(v, d.field, d.value)
+                    g(v) && u[ge(v)] > 0 && y(v, d.field, d.value)
                 }), o.modifies(d.field);
-                if (s) o.mod = t.length || i.length ? l.filter(v => u[de(v)] > 0) : l.slice();
+                if (a) o.mod = t.length || i.length ? l.filter(v => u[ge(v)] > 0) : l.slice();
                 else
                     for (m in c) o.mod.push(c[m]);
-                return (a || a == null && (t.length || i.length)) && o.clean(!0), o
+                return (s || s == null && (t.length || i.length)) && o.clean(!0), o
             }
         }
     }
-    const pp = "_:mod:_";
+    const Jg = "_:mod:_";
 
-    function Zm() {
-        Object.defineProperty(this, pp, {
+    function Dm() {
+        Object.defineProperty(this, Jg, {
             writable: !0,
             value: {}
         })
     }
-    Zm.prototype = {
+    Dm.prototype = {
         set(e, t, n, i) {
             const r = this,
-                a = r[e],
-                s = r[pp];
-            return t != null && t >= 0 ? (a[t] !== n || i) && (a[t] = n, s[t + ":" + e] = -1, s[e] = -1) : (a !== n || i) && (r[e] = n, s[e] = q(n) ? 1 + n.length : -1), r
+                s = r[e],
+                a = r[Jg];
+            return t != null && t >= 0 ? (s[t] !== n || i) && (s[t] = n, a[t + ":" + e] = -1, a[e] = -1) : (s !== n || i) && (r[e] = n, a[e] = W(n) ? 1 + n.length : -1), r
         },
         modified(e, t) {
-            const n = this[pp];
+            const n = this[Jg];
             if (arguments.length) {
-                if (q(e)) {
+                if (W(e)) {
                     for (let i = 0; i < e.length; ++i)
                         if (n[e[i]]) return !0;
                     return !1
                 }
             } else {
                 for (const i in n)
                     if (n[i]) return !0;
                 return !1
             }
             return t != null && t >= 0 ? t + 1 < n[e] || !!n[t + ":" + e] : !!n[e]
         },
         clear() {
-            return this[pp] = {}, this
+            return this[Jg] = {}, this
         }
     };
-    let FV = 0;
-    const DV = "pulse",
-        RV = new Zm,
-        PV = 1,
-        NV = 2;
+    let BX = 0;
+    const jX = "pulse",
+        UX = new Dm,
+        GX = 1,
+        WX = 2;
 
-    function rt(e, t, n, i) {
-        this.id = ++FV, this.value = e, this.stamp = -1, this.rank = -1, this.qrank = -1, this.flags = 0, t && (this._update = t), n && this.parameters(n, i)
+    function it(e, t, n, i) {
+        this.id = ++BX, this.value = e, this.stamp = -1, this.rank = -1, this.qrank = -1, this.flags = 0, t && (this._update = t), n && this.parameters(n, i)
     }
 
-    function dT(e) {
+    function A$(e) {
         return function(t) {
             const n = this.flags;
             return arguments.length === 0 ? !!(n & e) : (this.flags = t ? n | e : n & ~e, this)
         }
     }
-    rt.prototype = {
+    it.prototype = {
         targets() {
-            return this._targets || (this._targets = Km(yd))
+            return this._targets || (this._targets = Om(sd))
         },
         set(e) {
             return this.value !== e ? (this.value = e, 1) : 0
         },
-        skip: dT(PV),
-        modified: dT(NV),
+        skip: A$(GX),
+        modified: A$(WX),
         parameters(e, t, n) {
             t = t !== !1;
-            const i = this._argval = this._argval || new Zm,
+            const i = this._argval = this._argval || new Dm,
                 r = this._argops = this._argops || [],
-                a = [];
-            let s, o, l, u;
+                s = [];
+            let a, o, l, u;
             const c = (f, h, d) => {
-                d instanceof rt ? (d !== this && (t && d.targets().add(this), a.push(d)), r.push({
+                d instanceof it ? (d !== this && (t && d.targets().add(this), s.push(d)), r.push({
                     op: d,
                     name: f,
                     index: h
                 })) : i.set(f, h, d)
             };
-            for (s in e)
-                if (o = e[s], s === DV) ie(o).forEach(f => {
-                    f instanceof rt ? f !== this && (f.targets().add(this), a.push(f)) : G("Pulse parameters must be operator instances.")
+            for (a in e)
+                if (o = e[a], a === jX) se(o).forEach(f => {
+                    f instanceof it ? f !== this && (f.targets().add(this), s.push(f)) : U("Pulse parameters must be operator instances.")
                 }), this.source = o;
-                else if (q(o))
-                for (i.set(s, -1, Array(l = o.length)), u = 0; u < l; ++u) c(s, u, o[u]);
-            else c(s, -1, o);
-            return this.marshall().clear(), n && (r.initonly = !0), a
+                else if (W(o))
+                for (i.set(a, -1, Array(l = o.length)), u = 0; u < l; ++u) c(a, u, o[u]);
+            else c(a, -1, o);
+            return this.marshall().clear(), n && (r.initonly = !0), s
         },
         marshall(e) {
-            const t = this._argval || RV,
+            const t = this._argval || UX,
                 n = this._argops;
-            let i, r, a, s;
+            let i, r, s, a;
             if (n) {
                 const o = n.length;
-                for (r = 0; r < o; ++r) i = n[r], a = i.op, s = a.modified() && a.stamp === e, t.set(i.name, i.index, a.value, s);
+                for (r = 0; r < o; ++r) i = n[r], s = i.op, a = s.modified() && s.stamp === e, t.set(i.name, i.index, s.value, a);
                 if (n.initonly) {
                     for (r = 0; r < o; ++r) i = n[r], i.op.targets().remove(this);
                     this._argops = null, this._update = null
                 }
             }
             return t
         },
@@ -18575,1246 +18580,1261 @@
         run(e) {
             if (e.stamp < this.stamp) return e.StopPropagation;
             let t;
             return this.skip() ? (this.skip(!1), t = 0) : t = this.evaluate(e), this.pulse = t || e
         }
     };
 
-    function LV(e, t, n, i) {
+    function qX(e, t, n, i) {
         let r = 1,
-            a;
-        return e instanceof rt ? a = e : e && e.prototype instanceof rt ? a = new e : Ae(e) ? a = new rt(null, e) : (r = 0, a = new rt(e, t)), this.rank(a), r && (i = n, n = t), n && this.connect(a, a.parameters(n, i)), this.touch(a), a
+            s;
+        return e instanceof it ? s = e : e && e.prototype instanceof it ? s = new e : $e(e) ? s = new it(null, e) : (r = 0, s = new it(e, t)), this.rank(s), r && (i = n, n = t), n && this.connect(s, s.parameters(n, i)), this.touch(s), s
     }
 
-    function IV(e, t) {
+    function HX(e, t) {
         const n = e.rank,
             i = t.length;
         for (let r = 0; r < i; ++r)
             if (n < t[r].rank) {
                 this.rerank(e);
                 return
             }
     }
-    let jV = 0;
+    let YX = 0;
 
-    function e1(e, t, n) {
-        this.id = ++jV, this.value = null, n && (this.receive = n), e && (this._filter = e), t && (this._apply = t)
+    function Nm(e, t, n) {
+        this.id = ++YX, this.value = null, n && (this.receive = n), e && (this._filter = e), t && (this._apply = t)
     }
 
-    function gs(e, t, n) {
-        return new e1(e, t, n)
+    function ra(e, t, n) {
+        return new Nm(e, t, n)
     }
-    e1.prototype = {
-        _filter: Ii,
-        _apply: wn,
+    Nm.prototype = {
+        _filter: Ri,
+        _apply: bn,
         targets() {
-            return this._targets || (this._targets = Km(yd))
+            return this._targets || (this._targets = Om(sd))
         },
         consume(e) {
             return arguments.length ? (this._consume = !!e, this) : !!this._consume
         },
         receive(e) {
             if (this._filter(e)) {
                 const t = this.value = this._apply(e),
                     n = this._targets,
                     i = n ? n.length : 0;
                 for (let r = 0; r < i; ++r) n[r].receive(t);
                 this._consume && (e.preventDefault(), e.stopPropagation())
             }
         },
         filter(e) {
-            const t = gs(e);
+            const t = ra(e);
             return this.targets().add(t), t
         },
         apply(e) {
-            const t = gs(null, e);
+            const t = ra(null, e);
             return this.targets().add(t), t
         },
         merge() {
-            const e = gs();
+            const e = ra();
             this.targets().add(e);
             for (let t = 0, n = arguments.length; t < n; ++t) arguments[t].targets().add(e);
             return e
         },
         throttle(e) {
             let t = -1;
             return this.filter(() => {
                 const n = Date.now();
                 return n - t > e ? (t = n, 1) : 0
             })
         },
         debounce(e) {
-            const t = gs();
-            return this.targets().add(gs(null, null, Y_(e, n => {
+            const t = ra();
+            return this.targets().add(ra(null, null, h_(e, n => {
                 const i = n.dataflow;
                 t.receive(n), i && i.run && i.run()
             }))), t
         },
         between(e, t) {
             let n = !1;
-            return e.targets().add(gs(null, null, () => n = !0)), t.targets().add(gs(null, null, () => n = !1)), this.filter(() => n)
+            return e.targets().add(ra(null, null, () => n = !0)), t.targets().add(ra(null, null, () => n = !1)), this.filter(() => n)
         },
         detach() {
-            this._filter = Ii, this._targets = null
+            this._filter = Ri, this._targets = null
         }
     };
 
-    function zV(e, t, n, i) {
+    function XX(e, t, n, i) {
         const r = this,
-            a = gs(n, i),
-            s = function(u) {
+            s = ra(n, i),
+            a = function(u) {
                 u.dataflow = r;
                 try {
-                    a.receive(u)
+                    s.receive(u)
                 } catch (c) {
                     r.error(c)
                 } finally {
                     r.run()
                 }
             };
         let o;
-        typeof e == "string" && typeof document < "u" ? o = document.querySelectorAll(e) : o = ie(e);
+        typeof e == "string" && typeof document < "u" ? o = document.querySelectorAll(e) : o = se(e);
         const l = o.length;
-        for (let u = 0; u < l; ++u) o[u].addEventListener(t, s);
-        return a
+        for (let u = 0; u < l; ++u) o[u].addEventListener(t, a);
+        return s
     }
 
-    function BV(e, t) {
+    function VX(e, t) {
         const n = this.locale();
-        return $P(e, t, n.timeParse, n.utcParse)
+        return jD(e, t, n.timeParse, n.utcParse)
     }
 
-    function GV(e, t, n) {
+    function KX(e, t, n) {
         return t = this.parse(t, n), this.pulse(e, this.changeset().insert(t))
     }
-    async function UV(e, t) {
+    async function JX(e, t) {
         const n = this;
         let i = 0,
             r;
         try {
             r = await n.loader().load(e, {
                 context: "dataflow",
-                response: TP(t && t.type)
+                response: BD(t && t.type)
             });
             try {
                 r = n.parse(r, t)
-            } catch (a) {
-                i = -2, n.warn("Data ingestion failed", e, a)
+            } catch (s) {
+                i = -2, n.warn("Data ingestion failed", e, s)
             }
-        } catch (a) {
-            i = -1, n.warn("Loading failed", e, a)
+        } catch (s) {
+            i = -1, n.warn("Loading failed", e, s)
         }
         return {
             data: r,
             status: i
         }
     }
-    async function qV(e, t, n) {
+    async function QX(e, t, n) {
         const i = this,
-            r = i._pending || WV(i);
+            r = i._pending || ZX(i);
         r.requests += 1;
-        const a = await i.request(t, n);
-        return i.pulse(e, i.changeset().remove(Ii).insert(a.data || [])), r.done(), a
+        const s = await i.request(t, n);
+        return i.pulse(e, i.changeset().remove(Ri).insert(s.data || [])), r.done(), s
     }
 
-    function WV(e) {
+    function ZX(e) {
         let t;
         const n = new Promise(i => t = i);
         return n.requests = 0, n.done = () => {
             --n.requests === 0 && (e._pending = null, t(e))
         }, e._pending = n
     }
-    const HV = {
+    const eV = {
         skip: !0
     };
 
-    function YV(e, t, n, i, r) {
-        return (e instanceof rt ? VV : XV)(this, e, t, n, i, r), this
+    function tV(e, t, n, i, r) {
+        return (e instanceof it ? iV : nV)(this, e, t, n, i, r), this
     }
 
-    function XV(e, t, n, i, r, a) {
-        const s = ke({}, a, HV);
+    function nV(e, t, n, i, r, s) {
+        const a = Ae({}, s, eV);
         let o, l;
-        Ae(n) || (n = Sn(n)), i === void 0 ? o = u => e.touch(n(u)) : Ae(i) ? (l = new rt(null, i, r, !1), o = u => {
+        $e(n) || (n = xn(n)), i === void 0 ? o = u => e.touch(n(u)) : $e(i) ? (l = new it(null, i, r, !1), o = u => {
             l.evaluate(u);
             const c = n(u),
                 f = l.value;
-            RP(f) ? e.pulse(c, f, a) : e.update(c, f, s)
-        }) : o = u => e.update(n(u), i, s), t.apply(o)
+            qD(f) ? e.pulse(c, f, s) : e.update(c, f, a)
+        }) : o = u => e.update(n(u), i, a), t.apply(o)
     }
 
-    function VV(e, t, n, i, r, a) {
+    function iV(e, t, n, i, r, s) {
         if (i === void 0) t.targets().add(n);
         else {
-            const s = a || {},
-                o = new rt(null, KV(n, i), r, !1);
-            o.modified(s.force), o.rank = t.rank, t.targets().add(o), n && (o.skip(!0), o.value = n.value, o.targets().add(n), e.connect(n, [o]))
+            const a = s || {},
+                o = new it(null, rV(n, i), r, !1);
+            o.modified(a.force), o.rank = t.rank, t.targets().add(o), n && (o.skip(!0), o.value = n.value, o.targets().add(n), e.connect(n, [o]))
         }
     }
 
-    function KV(e, t) {
-        return t = Ae(t) ? t : Sn(t), e ? function(n, i) {
+    function rV(e, t) {
+        return t = $e(t) ? t : xn(t), e ? function(n, i) {
             const r = t(n, i);
             return e.skip() || (e.skip(r !== this.value).value = r), r
         } : t
     }
 
-    function JV(e) {
+    function sV(e) {
         e.rank = ++this._rank
     }
 
-    function QV(e) {
+    function aV(e) {
         const t = [e];
         let n, i, r;
         for (; t.length;)
             if (this.rank(n = t.pop()), i = n._targets)
-                for (r = i.length; --r >= 0;) t.push(n = i[r]), n === e && G("Cycle detected in dataflow graph.")
+                for (r = i.length; --r >= 0;) t.push(n = i[r]), n === e && U("Cycle detected in dataflow graph.")
     }
-    const M0 = {},
-        Rr = 1 << 0,
-        vs = 1 << 1,
-        ka = 1 << 2,
-        ZV = Rr | vs,
-        gT = Rr | ka,
-        au = Rr | vs | ka,
-        pT = 1 << 3,
-        hf = 1 << 4,
-        mT = 1 << 5,
-        yT = 1 << 6;
+    const h0 = {},
+        Tr = 1,
+        la = 2,
+        ys = 4,
+        oV = Tr | la,
+        $$ = Tr | ys,
+        Xl = Tr | la | ys,
+        T$ = 8,
+        Qc = 16,
+        M$ = 32,
+        O$ = 64;
 
-    function Rs(e, t, n) {
+    function Ca(e, t, n) {
         this.dataflow = e, this.stamp = t ?? -1, this.add = [], this.rem = [], this.mod = [], this.fields = null, this.encode = n || null
     }
 
-    function mv(e, t) {
+    function Xy(e, t) {
         const n = [];
-        return ys(e, t, i => n.push(i)), n
+        return oa(e, t, i => n.push(i)), n
     }
 
-    function vT(e, t) {
+    function F$(e, t) {
         const n = {};
         return e.visit(t, i => {
-            n[de(i)] = 1
-        }), i => n[de(i)] ? null : i
+            n[ge(i)] = 1
+        }), i => n[ge(i)] ? null : i
     }
 
-    function Mg(e, t) {
+    function mg(e, t) {
         return e ? (n, i) => e(n, i) && t(n, i) : t
     }
-    Rs.prototype = {
-        StopPropagation: M0,
-        ADD: Rr,
-        REM: vs,
-        MOD: ka,
-        ADD_REM: ZV,
-        ADD_MOD: gT,
-        ALL: au,
-        REFLOW: pT,
-        SOURCE: hf,
-        NO_SOURCE: mT,
-        NO_FIELDS: yT,
+    Ca.prototype = {
+        StopPropagation: h0,
+        ADD: Tr,
+        REM: la,
+        MOD: ys,
+        ADD_REM: oV,
+        ADD_MOD: $$,
+        ALL: Xl,
+        REFLOW: T$,
+        SOURCE: Qc,
+        NO_SOURCE: M$,
+        NO_FIELDS: O$,
         fork(e) {
-            return new Rs(this.dataflow).init(this, e)
+            return new Ca(this.dataflow).init(this, e)
         },
         clone() {
-            const e = this.fork(au);
-            return e.add = e.add.slice(), e.rem = e.rem.slice(), e.mod = e.mod.slice(), e.source && (e.source = e.source.slice()), e.materialize(au | hf)
+            const e = this.fork(Xl);
+            return e.add = e.add.slice(), e.rem = e.rem.slice(), e.mod = e.mod.slice(), e.source && (e.source = e.source.slice()), e.materialize(Xl | Qc)
         },
         addAll() {
             let e = this;
-            return !e.source || e.add === e.rem || !e.rem.length && e.source.length === e.add.length || (e = new Rs(this.dataflow).init(this), e.add = e.source, e.rem = []), e
+            return !e.source || e.add === e.rem || !e.rem.length && e.source.length === e.add.length || (e = new Ca(this.dataflow).init(this), e.add = e.source, e.rem = []), e
         },
         init(e, t) {
             const n = this;
-            return n.stamp = e.stamp, n.encode = e.encode, e.fields && !(t & yT) && (n.fields = e.fields), t & Rr ? (n.addF = e.addF, n.add = e.add) : (n.addF = null, n.add = []), t & vs ? (n.remF = e.remF, n.rem = e.rem) : (n.remF = null, n.rem = []), t & ka ? (n.modF = e.modF, n.mod = e.mod) : (n.modF = null, n.mod = []), t & mT ? (n.srcF = null, n.source = null) : (n.srcF = e.srcF, n.source = e.source, e.cleans && (n.cleans = e.cleans)), n
+            return n.stamp = e.stamp, n.encode = e.encode, e.fields && !(t & O$) && (n.fields = e.fields), t & Tr ? (n.addF = e.addF, n.add = e.add) : (n.addF = null, n.add = []), t & la ? (n.remF = e.remF, n.rem = e.rem) : (n.remF = null, n.rem = []), t & ys ? (n.modF = e.modF, n.mod = e.mod) : (n.modF = null, n.mod = []), t & M$ ? (n.srcF = null, n.source = null) : (n.srcF = e.srcF, n.source = e.source, e.cleans && (n.cleans = e.cleans)), n
         },
         runAfter(e) {
             this.dataflow.runAfter(e)
         },
         changed(e) {
-            const t = e || au;
-            return t & Rr && this.add.length || t & vs && this.rem.length || t & ka && this.mod.length
+            const t = e || Xl;
+            return t & Tr && this.add.length || t & la && this.rem.length || t & ys && this.mod.length
         },
         reflow(e) {
-            if (e) return this.fork(au).reflow();
+            if (e) return this.fork(Xl).reflow();
             const t = this.add.length,
                 n = this.source && this.source.length;
-            return n && n !== t && (this.mod = this.source, t && this.filter(ka, vT(this, Rr))), this
+            return n && n !== t && (this.mod = this.source, t && this.filter(ys, F$(this, Tr))), this
         },
         clean(e) {
             return arguments.length ? (this.cleans = !!e, this) : this.cleans
         },
         modifies(e) {
             const t = this.fields || (this.fields = {});
-            return q(e) ? e.forEach(n => t[n] = !0) : t[e] = !0, this
+            return W(e) ? e.forEach(n => t[n] = !0) : t[e] = !0, this
         },
         modified(e, t) {
             const n = this.fields;
-            return (t || this.mod.length) && n ? arguments.length ? q(e) ? e.some(i => n[i]) : n[e] : !!n : !1
+            return (t || this.mod.length) && n ? arguments.length ? W(e) ? e.some(i => n[i]) : n[e] : !!n : !1
         },
         filter(e, t) {
             const n = this;
-            return e & Rr && (n.addF = Mg(n.addF, t)), e & vs && (n.remF = Mg(n.remF, t)), e & ka && (n.modF = Mg(n.modF, t)), e & hf && (n.srcF = Mg(n.srcF, t)), n
+            return e & Tr && (n.addF = mg(n.addF, t)), e & la && (n.remF = mg(n.remF, t)), e & ys && (n.modF = mg(n.modF, t)), e & Qc && (n.srcF = mg(n.srcF, t)), n
         },
         materialize(e) {
-            e = e || au;
+            e = e || Xl;
             const t = this;
-            return e & Rr && t.addF && (t.add = mv(t.add, t.addF), t.addF = null), e & vs && t.remF && (t.rem = mv(t.rem, t.remF), t.remF = null), e & ka && t.modF && (t.mod = mv(t.mod, t.modF), t.modF = null), e & hf && t.srcF && (t.source = t.source.filter(t.srcF), t.srcF = null), t
+            return e & Tr && t.addF && (t.add = Xy(t.add, t.addF), t.addF = null), e & la && t.remF && (t.rem = Xy(t.rem, t.remF), t.remF = null), e & ys && t.modF && (t.mod = Xy(t.mod, t.modF), t.modF = null), e & Qc && t.srcF && (t.source = t.source.filter(t.srcF), t.srcF = null), t
         },
         visit(e, t) {
             const n = this,
                 i = t;
-            if (e & hf) return ys(n.source, n.srcF, i), n;
-            e & Rr && ys(n.add, n.addF, i), e & vs && ys(n.rem, n.remF, i), e & ka && ys(n.mod, n.modF, i);
+            if (e & Qc) return oa(n.source, n.srcF, i), n;
+            e & Tr && oa(n.add, n.addF, i), e & la && oa(n.rem, n.remF, i), e & ys && oa(n.mod, n.modF, i);
             const r = n.source;
-            if (e & pT && r) {
-                const a = n.add.length + n.mod.length;
-                a === r.length || (a ? ys(r, vT(n, gT), i) : ys(r, n.srcF, i))
+            if (e & T$ && r) {
+                const s = n.add.length + n.mod.length;
+                s === r.length || (s ? oa(r, F$(n, $$), i) : oa(r, n.srcF, i))
             }
             return n
         }
     };
 
-    function sw(e, t, n, i) {
+    function C_(e, t, n, i) {
         const r = this;
-        let a = 0;
+        let s = 0;
         this.dataflow = e, this.stamp = t, this.fields = null, this.encode = i || null, this.pulses = n;
-        for (const s of n)
-            if (s.stamp === t) {
-                if (s.fields) {
+        for (const a of n)
+            if (a.stamp === t) {
+                if (a.fields) {
                     const o = r.fields || (r.fields = {});
-                    for (const l in s.fields) o[l] = 1
+                    for (const l in a.fields) o[l] = 1
                 }
-                s.changed(r.ADD) && (a |= r.ADD), s.changed(r.REM) && (a |= r.REM), s.changed(r.MOD) && (a |= r.MOD)
-            } this.changes = a
+                a.changed(r.ADD) && (s |= r.ADD), a.changed(r.REM) && (s |= r.REM), a.changed(r.MOD) && (s |= r.MOD)
+            } this.changes = s
     }
-    Q(sw, Rs, {
+    ee(C_, Ca, {
         fork(e) {
-            const t = new Rs(this.dataflow).init(this, e & this.NO_FIELDS);
+            const t = new Ca(this.dataflow).init(this, e & this.NO_FIELDS);
             return e !== void 0 && (e & t.ADD && this.visit(t.ADD, n => t.add.push(n)), e & t.REM && this.visit(t.REM, n => t.rem.push(n)), e & t.MOD && this.visit(t.MOD, n => t.mod.push(n))), t
         },
         changed(e) {
             return this.changes & e
         },
         modified(e) {
             const t = this,
                 n = t.fields;
-            return n && t.changes & t.MOD ? q(e) ? e.some(i => n[i]) : n[e] : 0
+            return n && t.changes & t.MOD ? W(e) ? e.some(i => n[i]) : n[e] : 0
         },
         filter() {
-            G("MultiPulse does not support filtering.")
+            U("MultiPulse does not support filtering.")
         },
         materialize() {
-            G("MultiPulse does not support materialization.")
+            U("MultiPulse does not support materialization.")
         },
         visit(e, t) {
             const n = this,
                 i = n.pulses,
                 r = i.length;
-            let a = 0;
+            let s = 0;
             if (e & n.SOURCE)
-                for (; a < r; ++a) i[a].visit(e, t);
+                for (; s < r; ++s) i[s].visit(e, t);
             else
-                for (; a < r; ++a) i[a].stamp === n.stamp && i[a].visit(e, t);
+                for (; s < r; ++s) i[s].stamp === n.stamp && i[s].visit(e, t);
             return n
         }
     });
-    async function eK(e, t, n) {
+    async function lV(e, t, n) {
         const i = this,
             r = [];
-        if (i._pulse) return PP(i);
-        if (i._pending && await i._pending, t && await gp(i, t), !i._touched.length) return i.debug("Dataflow invoked, but nothing to do."), i;
-        const a = ++i._clock;
-        i._pulse = new Rs(i, a, e), i._touched.forEach(c => i._enqueue(c, !0)), i._touched = Km(yd);
-        let s = 0,
+        if (i._pulse) return HD(i);
+        if (i._pending && await i._pending, t && await Kg(i, t), !i._touched.length) return i.debug("Dataflow invoked, but nothing to do."), i;
+        const s = ++i._clock;
+        i._pulse = new Ca(i, s, e), i._touched.forEach(c => i._enqueue(c, !0)), i._touched = Om(sd);
+        let a = 0,
             o, l, u;
         try {
             for (; i._heap.size() > 0;) {
                 if (o = i._heap.pop(), o.rank !== o.qrank) {
                     i._enqueue(o, !0);
                     continue
                 }
-                l = o.run(i._getPulse(o, e)), l.then ? l = await l : l.async && (r.push(l.async), l = M0), l !== M0 && o._targets && o._targets.forEach(c => i._enqueue(c)), ++s
+                l = o.run(i._getPulse(o, e)), l.then ? l = await l : l.async && (r.push(l.async), l = h0), l !== h0 && o._targets && o._targets.forEach(c => i._enqueue(c)), ++a
             }
         } catch (c) {
             i._heap.clear(), u = c
         }
-        if (i._input = {}, i._pulse = null, i.debug(`Pulse ${a}: ${s} operators`), u && (i._postrun = [], i.error(u)), i._postrun.length) {
+        if (i._input = {}, i._pulse = null, i.debug(`Pulse ${s}: ${a} operators`), u && (i._postrun = [], i.error(u)), i._postrun.length) {
             const c = i._postrun.sort((f, h) => h.priority - f.priority);
             i._postrun = [];
-            for (let f = 0; f < c.length; ++f) await gp(i, c[f].callback)
+            for (let f = 0; f < c.length; ++f) await Kg(i, c[f].callback)
         }
-        return n && await gp(i, n), r.length && Promise.all(r).then(c => i.runAsync(null, () => {
+        return n && await Kg(i, n), r.length && Promise.all(r).then(c => i.runAsync(null, () => {
             c.forEach(f => {
                 try {
                     f(i)
                 } catch (h) {
                     i.error(h)
                 }
             })
         })), i
     }
-    async function tK(e, t, n) {
+    async function uV(e, t, n) {
         for (; this._running;) await this._running;
         const i = () => this._running = null;
         return (this._running = this.evaluate(e, t, n)).then(i, i), this._running
     }
 
-    function nK(e, t, n) {
-        return this._pulse ? PP(this) : (this.evaluate(e, t, n), this)
+    function cV(e, t, n) {
+        return this._pulse ? HD(this) : (this.evaluate(e, t, n), this)
     }
 
-    function iK(e, t, n) {
+    function fV(e, t, n) {
         if (this._pulse || t) this._postrun.push({
             priority: n || 0,
             callback: e
         });
         else try {
             e(this)
         } catch (i) {
             this.error(i)
         }
     }
 
-    function PP(e) {
+    function HD(e) {
         return e.error("Dataflow already running. Use runAsync() to chain invocations."), e
     }
 
-    function rK(e, t) {
+    function hV(e, t) {
         const n = e.stamp < this._clock;
         n && (e.stamp = this._clock), (n || t) && (e.qrank = e.rank, this._heap.push(e))
     }
 
-    function aK(e, t) {
+    function dV(e, t) {
         const n = e.source,
             i = this._clock;
-        return n && q(n) ? new sw(this, i, n.map(r => r.pulse), t) : this._input[e.id] || sK(this._pulse, n && n.pulse)
+        return n && W(n) ? new C_(this, i, n.map(r => r.pulse), t) : this._input[e.id] || gV(this._pulse, n && n.pulse)
     }
 
-    function sK(e, t) {
-        return t && t.stamp === e.stamp ? t : (e = e.fork(), t && t !== M0 && (e.source = t.source), e)
+    function gV(e, t) {
+        return t && t.stamp === e.stamp ? t : (e = e.fork(), t && t !== h0 && (e.source = t.source), e)
     }
-    const ow = {
+    const k_ = {
         skip: !1,
         force: !1
     };
 
-    function oK(e, t) {
-        const n = t || ow;
+    function pV(e, t) {
+        const n = t || k_;
         return this._pulse ? this._enqueue(e) : this._touched.add(e), n.skip && e.skip(!0), this
     }
 
-    function lK(e, t, n) {
-        const i = n || ow;
+    function mV(e, t, n) {
+        const i = n || k_;
         return (e.set(t) || i.force) && this.touch(e, i), this
     }
 
-    function uK(e, t, n) {
-        this.touch(e, n || ow);
-        const i = new Rs(this, this._clock + (this._pulse ? 0 : 1)),
+    function yV(e, t, n) {
+        this.touch(e, n || k_);
+        const i = new Ca(this, this._clock + (this._pulse ? 0 : 1)),
             r = e.pulse && e.pulse.source || [];
         return i.target = e, this._input[e.id] = t.pulse(i, r), this
     }
 
-    function cK(e) {
+    function vV(e) {
         let t = [];
         return {
             clear: () => t = [],
             size: () => t.length,
             peek: () => t[0],
-            push: n => (t.push(n), NP(t, 0, t.length - 1, e)),
+            push: n => (t.push(n), YD(t, 0, t.length - 1, e)),
             pop: () => {
                 const n = t.pop();
                 let i;
-                return t.length ? (i = t[0], t[0] = n, fK(t, 0, e)) : i = n, i
+                return t.length ? (i = t[0], t[0] = n, bV(t, 0, e)) : i = n, i
             }
         }
     }
 
-    function NP(e, t, n, i) {
-        let r, a;
-        const s = e[n];
+    function YD(e, t, n, i) {
+        let r, s;
+        const a = e[n];
         for (; n > t;) {
-            if (a = n - 1 >> 1, r = e[a], i(s, r) < 0) {
-                e[n] = r, n = a;
+            if (s = n - 1 >> 1, r = e[s], i(a, r) < 0) {
+                e[n] = r, n = s;
                 continue
             }
             break
         }
-        return e[n] = s
+        return e[n] = a
     }
 
-    function fK(e, t, n) {
+    function bV(e, t, n) {
         const i = t,
             r = e.length,
-            a = e[t];
-        let s = (t << 1) + 1,
+            s = e[t];
+        let a = (t << 1) + 1,
             o;
-        for (; s < r;) o = s + 1, o < r && n(e[s], e[o]) >= 0 && (s = o), e[t] = e[s], t = s, s = (t << 1) + 1;
-        return e[t] = a, NP(e, i, t, n)
+        for (; a < r;) o = a + 1, o < r && n(e[a], e[o]) >= 0 && (a = o), e[t] = e[a], t = a, a = (t << 1) + 1;
+        return e[t] = s, YD(e, i, t, n)
     }
 
-    function Du() {
-        this.logger(G_()), this.logLevel(z_), this._clock = 0, this._rank = 0, this._locale = tw();
+    function wu() {
+        this.logger(o_()), this.logLevel(s_), this._clock = 0, this._rank = 0, this._locale = x_();
         try {
-            this._loader = Vm()
+            this._loader = Mm()
         } catch {}
-        this._touched = Km(yd), this._input = {}, this._pulse = null, this._heap = cK((e, t) => e.qrank - t.qrank), this._postrun = []
+        this._touched = Om(sd), this._input = {}, this._pulse = null, this._heap = vV((e, t) => e.qrank - t.qrank), this._postrun = []
     }
 
-    function df(e) {
+    function Zc(e) {
         return function() {
             return this._log[e].apply(this, arguments)
         }
     }
-    Du.prototype = {
+    wu.prototype = {
         stamp() {
             return this._clock
         },
         loader(e) {
             return arguments.length ? (this._loader = e, this) : this._loader
         },
         locale(e) {
             return arguments.length ? (this._locale = e, this) : this._locale
         },
         logger(e) {
             return arguments.length ? (this._log = e, this) : this._log
         },
-        error: df("error"),
-        warn: df("warn"),
-        info: df("info"),
-        debug: df("debug"),
-        logLevel: df("level"),
+        error: Zc("error"),
+        warn: Zc("warn"),
+        info: Zc("info"),
+        debug: Zc("debug"),
+        logLevel: Zc("level"),
         cleanThreshold: 1e4,
-        add: LV,
-        connect: IV,
-        rank: JV,
-        rerank: QV,
-        pulse: uK,
-        touch: oK,
-        update: lK,
-        changeset: zl,
-        ingest: GV,
-        parse: BV,
-        preload: qV,
-        request: UV,
-        events: zV,
-        on: YV,
-        evaluate: eK,
-        run: nK,
-        runAsync: tK,
-        runAfter: iK,
-        _enqueue: rK,
-        _getPulse: aK
+        add: qX,
+        connect: HX,
+        rank: sV,
+        rerank: aV,
+        pulse: yV,
+        touch: pV,
+        update: mV,
+        changeset: Tl,
+        ingest: KX,
+        parse: VX,
+        preload: QX,
+        request: JX,
+        events: XX,
+        on: tV,
+        evaluate: lV,
+        run: cV,
+        runAsync: uV,
+        runAfter: fV,
+        _enqueue: hV,
+        _getPulse: dV
     };
 
     function L(e, t) {
-        rt.call(this, e, null, t)
+        it.call(this, e, null, t)
     }
-    Q(L, rt, {
+    ee(L, it, {
         run(e) {
             if (e.stamp < this.stamp) return e.StopPropagation;
             let t;
             return this.skip() ? this.skip(!1) : t = this.evaluate(e), t = t || e, t.then ? t = t.then(n => this.pulse = n) : t !== e.StopPropagation && (this.pulse = t), t
         },
         evaluate(e) {
             const t = this.marshall(e.stamp),
                 n = this.transform(t, e);
             return t.clear(), n
         },
         transform() {}
     });
-    const Zu = {};
+    const Uu = {};
 
-    function LP(e) {
-        const t = IP(e);
+    function XD(e) {
+        const t = VD(e);
         return t && t.Definition || null
     }
 
-    function IP(e) {
-        return e = e && e.toLowerCase(), pe(Zu, e) ? Zu[e] : null
+    function VD(e) {
+        return e = e && e.toLowerCase(), me(Uu, e) ? Uu[e] : null
     }
 
-    function* jP(e, t) {
+    function* KD(e, t) {
         if (t == null)
             for (let n of e) n != null && n !== "" && (n = +n) >= n && (yield n);
         else {
             let n = -1;
             for (let i of e) i = t(i, ++n, e), i != null && i !== "" && (i = +i) >= i && (yield i)
         }
     }
 
-    function lw(e, t, n) {
-        const i = Float64Array.from(jP(e, n));
-        return i.sort(ja), t.map(r => kF(i, r))
+    function A_(e, t, n) {
+        const i = Float64Array.from(KD(e, n));
+        return i.sort(Ts), t.map(r => IO(i, r))
     }
 
-    function uw(e, t) {
-        return lw(e, [.25, .5, .75], t)
+    function $_(e, t) {
+        return A_(e, [.25, .5, .75], t)
     }
 
-    function cw(e, t) {
+    function T_(e, t) {
         const n = e.length,
-            i = pG(e, t),
-            r = uw(e, t),
-            a = (r[2] - r[0]) / 1.34;
-        return 1.06 * (Math.min(i, a) || i || Math.abs(r[0]) || 1) * Math.pow(n, -.2)
+            i = wj(e, t),
+            r = $_(e, t),
+            s = (r[2] - r[0]) / 1.34;
+        return 1.06 * (Math.min(i, s) || i || Math.abs(r[0]) || 1) * Math.pow(n, -.2)
     }
 
-    function zP(e) {
+    function JD(e) {
         const t = e.maxbins || 20,
             n = e.base || 10,
             i = Math.log(n),
             r = e.divide || [5, 2];
-        let a = e.extent[0],
-            s = e.extent[1],
+        let s = e.extent[0],
+            a = e.extent[1],
             o, l, u, c, f, h;
-        const d = e.span || s - a || Math.abs(a) || 1;
+        const d = e.span || a - s || Math.abs(s) || 1;
         if (e.step) o = e.step;
         else if (e.steps) {
             for (c = d / t, f = 0, h = e.steps.length; f < h && e.steps[f] < c; ++f);
             o = e.steps[Math.max(0, f - 1)]
         } else {
             for (l = Math.ceil(Math.log(t) / i), u = e.minstep || 0, o = Math.max(u, Math.pow(n, Math.round(Math.log(d) / i) - l)); Math.ceil(d / o) > t;) o *= n;
             for (f = 0, h = r.length; f < h; ++f) c = o / r[f], c >= u && d / c <= t && (o = c)
         }
         c = Math.log(o);
         const g = c >= 0 ? 0 : ~~(-c / i) + 1,
             p = Math.pow(n, -g - 1);
-        return (e.nice || e.nice === void 0) && (c = Math.floor(a / o + p) * o, a = a < c ? c - o : c, s = Math.ceil(s / o) * o), {
-            start: a,
-            stop: s === a ? a + o : s,
+        return (e.nice || e.nice === void 0) && (c = Math.floor(s / o + p) * o, s = s < c ? c - o : c, a = Math.ceil(a / o) * o), {
+            start: s,
+            stop: a === s ? s + o : a,
             step: o
         }
     }
-    var zi = Math.random;
+    var Ni = Math.random;
 
-    function hK(e) {
-        zi = e
+    function xV(e) {
+        Ni = e
     }
 
-    function BP(e, t, n, i) {
+    function QD(e, t, n, i) {
         if (!e.length) return [void 0, void 0];
-        const r = Float64Array.from(jP(e, i)),
-            a = r.length,
-            s = t;
+        const r = Float64Array.from(KD(e, i)),
+            s = r.length,
+            a = t;
         let o, l, u, c;
-        for (u = 0, c = Array(s); u < s; ++u) {
-            for (o = 0, l = 0; l < a; ++l) o += r[~~(zi() * a)];
-            c[u] = o / a
+        for (u = 0, c = Array(a); u < a; ++u) {
+            for (o = 0, l = 0; l < s; ++l) o += r[~~(Ni() * s)];
+            c[u] = o / s
         }
-        return c.sort(ja), [Lb(c, n / 2), Lb(c, 1 - n / 2)]
+        return c.sort(Ts), [fb(c, n / 2), fb(c, 1 - n / 2)]
     }
 
-    function GP(e, t, n, i) {
+    function ZD(e, t, n, i) {
         i = i || (h => h);
         const r = e.length,
-            a = new Float64Array(r);
-        let s = 0,
+            s = new Float64Array(r);
+        let a = 0,
             o = 1,
             l = i(e[0]),
             u = l,
             c = l + t,
             f;
         for (; o < r; ++o) {
             if (f = i(e[o]), f >= c) {
-                for (u = (l + u) / 2; s < o; ++s) a[s] = u;
+                for (u = (l + u) / 2; a < o; ++a) s[a] = u;
                 c = f + t, l = f
             }
             u = f
         }
-        for (u = (l + u) / 2; s < o; ++s) a[s] = u;
-        return n ? dK(a, t + t / 4) : a
+        for (u = (l + u) / 2; a < o; ++a) s[a] = u;
+        return n ? _V(s, t + t / 4) : s
     }
 
-    function dK(e, t) {
+    function _V(e, t) {
         const n = e.length;
         let i = 0,
             r = 1,
-            a, s;
+            s, a;
         for (; e[i] === e[r];) ++r;
         for (; r < n;) {
-            for (a = r + 1; e[r] === e[a];) ++a;
+            for (s = r + 1; e[r] === e[s];) ++s;
             if (e[r] - e[r - 1] < t) {
-                for (s = r + (i + a - r - r >> 1); s < r;) e[s++] = e[r];
-                for (; s > r;) e[s--] = e[i]
+                for (a = r + (i + s - r - r >> 1); a < r;) e[a++] = e[r];
+                for (; a > r;) e[a--] = e[i]
             }
-            i = r, r = a
+            i = r, r = s
         }
         return e
     }
 
-    function gK(e) {
+    function wV(e) {
         return function() {
             return e = (1103515245 * e + 12345) % 2147483647, e / 2147483647
         }
     }
 
-    function pK(e, t) {
+    function SV(e, t) {
         t == null && (t = e, e = 0);
         let n, i, r;
-        const a = {
-            min(s) {
-                return arguments.length ? (n = s || 0, r = i - n, a) : n
+        const s = {
+            min(a) {
+                return arguments.length ? (n = a || 0, r = i - n, s) : n
             },
-            max(s) {
-                return arguments.length ? (i = s || 0, r = i - n, a) : i
+            max(a) {
+                return arguments.length ? (i = a || 0, r = i - n, s) : i
             },
             sample() {
-                return n + Math.floor(r * zi())
+                return n + Math.floor(r * Ni())
             },
-            pdf(s) {
-                return s === Math.floor(s) && s >= n && s < i ? 1 / r : 0
+            pdf(a) {
+                return a === Math.floor(a) && a >= n && a < i ? 1 / r : 0
             },
-            cdf(s) {
-                const o = Math.floor(s);
+            cdf(a) {
+                const o = Math.floor(a);
                 return o < n ? 0 : o >= i ? 1 : (o - n + 1) / r
             },
-            icdf(s) {
-                return s >= 0 && s <= 1 ? n - 1 + Math.floor(s * r) : NaN
+            icdf(a) {
+                return a >= 0 && a <= 1 ? n - 1 + Math.floor(a * r) : NaN
             }
         };
-        return a.min(e).max(t)
+        return s.min(e).max(t)
     }
-    const UP = Math.sqrt(2 * Math.PI),
-        mK = Math.SQRT2;
-    let gf = NaN;
+    const eN = Math.sqrt(2 * Math.PI),
+        EV = Math.SQRT2;
+    let ef = NaN;
 
-    function t1(e, t) {
+    function Pm(e, t) {
         e = e || 0, t = t ?? 1;
         let n = 0,
             i = 0,
-            r, a;
-        if (gf === gf) n = gf, gf = NaN;
+            r, s;
+        if (ef === ef) n = ef, ef = NaN;
         else {
-            do n = zi() * 2 - 1, i = zi() * 2 - 1, r = n * n + i * i; while (r === 0 || r > 1);
-            a = Math.sqrt(-2 * Math.log(r) / r), n *= a, gf = i * a
+            do n = Ni() * 2 - 1, i = Ni() * 2 - 1, r = n * n + i * i; while (r === 0 || r > 1);
+            s = Math.sqrt(-2 * Math.log(r) / r), n *= s, ef = i * s
         }
         return e + n * t
     }
 
-    function fw(e, t, n) {
+    function M_(e, t, n) {
         n = n ?? 1;
         const i = (e - (t || 0)) / n;
-        return Math.exp(-.5 * i * i) / (n * UP)
+        return Math.exp(-.5 * i * i) / (n * eN)
     }
 
-    function n1(e, t, n) {
+    function Lm(e, t, n) {
         t = t || 0, n = n ?? 1;
         const i = (e - t) / n,
             r = Math.abs(i);
-        let a;
-        if (r > 37) a = 0;
+        let s;
+        if (r > 37) s = 0;
         else {
-            const s = Math.exp(-r * r / 2);
+            const a = Math.exp(-r * r / 2);
             let o;
-            r < 7.07106781186547 ? (o = .0352624965998911 * r + .700383064443688, o = o * r + 6.37396220353165, o = o * r + 33.912866078383, o = o * r + 112.079291497871, o = o * r + 221.213596169931, o = o * r + 220.206867912376, a = s * o, o = .0883883476483184 * r + 1.75566716318264, o = o * r + 16.064177579207, o = o * r + 86.7807322029461, o = o * r + 296.564248779674, o = o * r + 637.333633378831, o = o * r + 793.826512519948, o = o * r + 440.413735824752, a = a / o) : (o = r + .65, o = r + 4 / o, o = r + 3 / o, o = r + 2 / o, o = r + 1 / o, a = s / o / 2.506628274631)
+            r < 7.07106781186547 ? (o = .0352624965998911 * r + .700383064443688, o = o * r + 6.37396220353165, o = o * r + 33.912866078383, o = o * r + 112.079291497871, o = o * r + 221.213596169931, o = o * r + 220.206867912376, s = a * o, o = .0883883476483184 * r + 1.75566716318264, o = o * r + 16.064177579207, o = o * r + 86.7807322029461, o = o * r + 296.564248779674, o = o * r + 637.333633378831, o = o * r + 793.826512519948, o = o * r + 440.413735824752, s = s / o) : (o = r + .65, o = r + 4 / o, o = r + 3 / o, o = r + 2 / o, o = r + 1 / o, s = a / o / 2.506628274631)
         }
-        return i > 0 ? 1 - a : a
+        return i > 0 ? 1 - s : s
     }
 
-    function i1(e, t, n) {
-        return e < 0 || e > 1 ? NaN : (t || 0) + (n ?? 1) * mK * yK(2 * e - 1)
+    function Im(e, t, n) {
+        return e < 0 || e > 1 ? NaN : (t || 0) + (n ?? 1) * EV * CV(2 * e - 1)
     }
 
-    function yK(e) {
+    function CV(e) {
         let t = -Math.log((1 - e) * (1 + e)),
             n;
         return t < 6.25 ? (t -= 3.125, n = -364441206401782e-35, n = -16850591381820166e-35 + n * t, n = 128584807152564e-32 + n * t, n = 11157877678025181e-33 + n * t, n = -1333171662854621e-31 + n * t, n = 20972767875968562e-33 + n * t, n = 6637638134358324e-30 + n * t, n = -4054566272975207e-29 + n * t, n = -8151934197605472e-29 + n * t, n = 26335093153082323e-28 + n * t, n = -12975133253453532e-27 + n * t, n = -5415412054294628e-26 + n * t, n = 10512122733215323e-25 + n * t, n = -4112633980346984e-24 + n * t, n = -29070369957882005e-24 + n * t, n = 42347877827932404e-23 + n * t, n = -13654692000834679e-22 + n * t, n = -13882523362786469e-21 + n * t, n = .00018673420803405714 + n * t, n = -.000740702534166267 + n * t, n = -.006033670871430149 + n * t, n = .24015818242558962 + n * t, n = 1.6536545626831027 + n * t) : t < 16 ? (t = Math.sqrt(t) - 3.25, n = 22137376921775787e-25, n = 9075656193888539e-23 + n * t, n = -27517406297064545e-23 + n * t, n = 18239629214389228e-24 + n * t, n = 15027403968909828e-22 + n * t, n = -4013867526981546e-21 + n * t, n = 29234449089955446e-22 + n * t, n = 12475304481671779e-21 + n * t, n = -47318229009055734e-21 + n * t, n = 6828485145957318e-20 + n * t, n = 24031110387097894e-21 + n * t, n = -.0003550375203628475 + n * t, n = .0009532893797373805 + n * t, n = -.0016882755560235047 + n * t, n = .002491442096107851 + n * t, n = -.003751208507569241 + n * t, n = .005370914553590064 + n * t, n = 1.0052589676941592 + n * t, n = 3.0838856104922208 + n * t) : Number.isFinite(t) ? (t = Math.sqrt(t) - 5, n = -27109920616438573e-27, n = -2555641816996525e-25 + n * t, n = 15076572693500548e-25 + n * t, n = -3789465440126737e-24 + n * t, n = 761570120807834e-23 + n * t, n = -1496002662714924e-23 + n * t, n = 2914795345090108e-23 + n * t, n = -6771199775845234e-23 + n * t, n = 22900482228026655e-23 + n * t, n = -99298272942317e-20 + n * t, n = 4526062597223154e-21 + n * t, n = -1968177810553167e-20 + n * t, n = 7599527703001776e-20 + n * t, n = -.00021503011930044477 + n * t, n = -.00013871931833623122 + n * t, n = 1.0103004648645344 + n * t, n = 4.849906401408584 + n * t) : n = 1 / 0, n * e
     }
 
-    function hw(e, t) {
+    function O_(e, t) {
         let n, i;
         const r = {
-            mean(a) {
-                return arguments.length ? (n = a || 0, r) : n
+            mean(s) {
+                return arguments.length ? (n = s || 0, r) : n
             },
-            stdev(a) {
-                return arguments.length ? (i = a ?? 1, r) : i
+            stdev(s) {
+                return arguments.length ? (i = s ?? 1, r) : i
             },
-            sample: () => t1(n, i),
-            pdf: a => fw(a, n, i),
-            cdf: a => n1(a, n, i),
-            icdf: a => i1(a, n, i)
+            sample: () => Pm(n, i),
+            pdf: s => M_(s, n, i),
+            cdf: s => Lm(s, n, i),
+            icdf: s => Im(s, n, i)
         };
         return r.mean(e).stdev(t)
     }
 
-    function dw(e, t) {
-        const n = hw();
+    function F_(e, t) {
+        const n = O_();
         let i = 0;
         const r = {
-            data(a) {
-                return arguments.length ? (e = a, i = a ? a.length : 0, r.bandwidth(t)) : e
+            data(s) {
+                return arguments.length ? (e = s, i = s ? s.length : 0, r.bandwidth(t)) : e
             },
-            bandwidth(a) {
-                return arguments.length ? (t = a, !t && e && (t = cw(e)), r) : t
+            bandwidth(s) {
+                return arguments.length ? (t = s, !t && e && (t = T_(e)), r) : t
             },
             sample() {
-                return e[~~(zi() * i)] + t * n.sample()
+                return e[~~(Ni() * i)] + t * n.sample()
             },
-            pdf(a) {
-                let s = 0,
+            pdf(s) {
+                let a = 0,
                     o = 0;
-                for (; o < i; ++o) s += n.pdf((a - e[o]) / t);
-                return s / t / i
+                for (; o < i; ++o) a += n.pdf((s - e[o]) / t);
+                return a / t / i
             },
-            cdf(a) {
-                let s = 0,
+            cdf(s) {
+                let a = 0,
                     o = 0;
-                for (; o < i; ++o) s += n.cdf((a - e[o]) / t);
-                return s / i
+                for (; o < i; ++o) a += n.cdf((s - e[o]) / t);
+                return a / i
             },
             icdf() {
                 throw Error("KDE icdf not supported.")
             }
         };
         return r.data(e)
     }
 
-    function gw(e, t) {
-        return e = e || 0, t = t ?? 1, Math.exp(e + t1() * t)
+    function R_(e, t) {
+        return e = e || 0, t = t ?? 1, Math.exp(e + Pm() * t)
     }
 
-    function pw(e, t, n) {
+    function D_(e, t, n) {
         if (e <= 0) return 0;
         t = t || 0, n = n ?? 1;
         const i = (Math.log(e) - t) / n;
-        return Math.exp(-.5 * i * i) / (n * UP * e)
+        return Math.exp(-.5 * i * i) / (n * eN * e)
     }
 
-    function mw(e, t, n) {
-        return n1(Math.log(e), t, n)
+    function N_(e, t, n) {
+        return Lm(Math.log(e), t, n)
     }
 
-    function yw(e, t, n) {
-        return Math.exp(i1(e, t, n))
+    function P_(e, t, n) {
+        return Math.exp(Im(e, t, n))
     }
 
-    function qP(e, t) {
+    function tN(e, t) {
         let n, i;
         const r = {
-            mean(a) {
-                return arguments.length ? (n = a || 0, r) : n
+            mean(s) {
+                return arguments.length ? (n = s || 0, r) : n
             },
-            stdev(a) {
-                return arguments.length ? (i = a ?? 1, r) : i
+            stdev(s) {
+                return arguments.length ? (i = s ?? 1, r) : i
             },
-            sample: () => gw(n, i),
-            pdf: a => pw(a, n, i),
-            cdf: a => mw(a, n, i),
-            icdf: a => yw(a, n, i)
+            sample: () => R_(n, i),
+            pdf: s => D_(s, n, i),
+            cdf: s => N_(s, n, i),
+            icdf: s => P_(s, n, i)
         };
         return r.mean(e).stdev(t)
     }
 
-    function WP(e, t) {
+    function nN(e, t) {
         let n = 0,
             i;
 
-        function r(s) {
+        function r(a) {
             const o = [];
             let l = 0,
                 u;
-            for (u = 0; u < n; ++u) l += o[u] = s[u] == null ? 1 : +s[u];
+            for (u = 0; u < n; ++u) l += o[u] = a[u] == null ? 1 : +a[u];
             for (u = 0; u < n; ++u) o[u] /= l;
             return o
         }
-        const a = {
-            weights(s) {
-                return arguments.length ? (i = r(t = s || []), a) : t
+        const s = {
+            weights(a) {
+                return arguments.length ? (i = r(t = a || []), s) : t
             },
-            distributions(s) {
-                return arguments.length ? (s ? (n = s.length, e = s) : (n = 0, e = []), a.weights(t)) : e
+            distributions(a) {
+                return arguments.length ? (a ? (n = a.length, e = a) : (n = 0, e = []), s.weights(t)) : e
             },
             sample() {
-                const s = zi();
+                const a = Ni();
                 let o = e[n - 1],
                     l = i[0],
                     u = 0;
                 for (; u < n - 1; l += i[++u])
-                    if (s < l) {
+                    if (a < l) {
                         o = e[u];
                         break
                     } return o.sample()
             },
-            pdf(s) {
+            pdf(a) {
                 let o = 0,
                     l = 0;
-                for (; l < n; ++l) o += i[l] * e[l].pdf(s);
+                for (; l < n; ++l) o += i[l] * e[l].pdf(a);
                 return o
             },
-            cdf(s) {
+            cdf(a) {
                 let o = 0,
                     l = 0;
-                for (; l < n; ++l) o += i[l] * e[l].cdf(s);
+                for (; l < n; ++l) o += i[l] * e[l].cdf(a);
                 return o
             },
             icdf() {
                 throw Error("Mixture icdf not supported.")
             }
         };
-        return a.distributions(e).weights(t)
+        return s.distributions(e).weights(t)
     }
 
-    function vw(e, t) {
-        return t == null && (t = e ?? 1, e = 0), e + (t - e) * zi()
+    function L_(e, t) {
+        return t == null && (t = e ?? 1, e = 0), e + (t - e) * Ni()
     }
 
-    function bw(e, t, n) {
+    function I_(e, t, n) {
         return n == null && (n = t ?? 1, t = 0), e >= t && e <= n ? 1 / (n - t) : 0
     }
 
-    function xw(e, t, n) {
+    function z_(e, t, n) {
         return n == null && (n = t ?? 1, t = 0), e < t ? 0 : e > n ? 1 : (e - t) / (n - t)
     }
 
-    function _w(e, t, n) {
+    function B_(e, t, n) {
         return n == null && (n = t ?? 1, t = 0), e >= 0 && e <= 1 ? t + e * (n - t) : NaN
     }
 
-    function HP(e, t) {
+    function iN(e, t) {
         let n, i;
         const r = {
-            min(a) {
-                return arguments.length ? (n = a || 0, r) : n
+            min(s) {
+                return arguments.length ? (n = s || 0, r) : n
             },
-            max(a) {
-                return arguments.length ? (i = a ?? 1, r) : i
+            max(s) {
+                return arguments.length ? (i = s ?? 1, r) : i
             },
-            sample: () => vw(n, i),
-            pdf: a => bw(a, n, i),
-            cdf: a => xw(a, n, i),
-            icdf: a => _w(a, n, i)
+            sample: () => L_(n, i),
+            pdf: s => I_(s, n, i),
+            cdf: s => z_(s, n, i),
+            icdf: s => B_(s, n, i)
         };
         return t == null && (t = e ?? 1, e = 0), r.min(e).max(t)
     }
 
-    function bd(e, t, n, i) {
+    function j_(e, t, n) {
+        let i = 0,
+            r = 0;
+        for (const s of e) {
+            const a = n(s);
+            t(s) == null || a == null || isNaN(a) || (i += (a - i) / ++r)
+        }
+        return {
+            coef: [i],
+            predict: () => i,
+            rSquared: 0
+        }
+    }
+
+    function od(e, t, n, i) {
         const r = i - e * e,
-            a = Math.abs(r) < 1e-24 ? 0 : (n - e * t) / r;
-        return [t - a * e, a]
+            s = Math.abs(r) < 1e-24 ? 0 : (n - e * t) / r;
+        return [t - s * e, s]
     }
 
-    function r1(e, t, n, i) {
+    function zm(e, t, n, i) {
         e = e.filter(d => {
             let g = t(d),
                 p = n(d);
             return g != null && (g = +g) >= g && p != null && (p = +p) >= p
         }), i && e.sort((d, g) => t(d) - t(g));
         const r = e.length,
-            a = new Float64Array(r),
-            s = new Float64Array(r);
+            s = new Float64Array(r),
+            a = new Float64Array(r);
         let o = 0,
             l = 0,
             u = 0,
             c, f, h;
-        for (h of e) a[o] = c = +t(h), s[o] = f = +n(h), ++o, l += (c - l) / o, u += (f - u) / o;
-        for (o = 0; o < r; ++o) a[o] -= l, s[o] -= u;
-        return [a, s, l, u]
+        for (h of e) s[o] = c = +t(h), a[o] = f = +n(h), ++o, l += (c - l) / o, u += (f - u) / o;
+        for (o = 0; o < r; ++o) s[o] -= l, a[o] -= u;
+        return [s, a, l, u]
     }
 
-    function xd(e, t, n, i) {
+    function ld(e, t, n, i) {
         let r = -1,
-            a, s;
-        for (const o of e) a = t(o), s = n(o), a != null && (a = +a) >= a && s != null && (s = +s) >= s && i(a, s, ++r)
+            s, a;
+        for (const o of e) s = t(o), a = n(o), s != null && (s = +s) >= s && a != null && (a = +a) >= a && i(s, a, ++r)
     }
 
-    function Nc(e, t, n, i, r) {
-        let a = 0,
-            s = 0;
-        return xd(e, t, n, (o, l) => {
+    function Ec(e, t, n, i, r) {
+        let s = 0,
+            a = 0;
+        return ld(e, t, n, (o, l) => {
             const u = l - r(o),
                 c = l - i;
-            a += u * u, s += c * c
-        }), 1 - a / s
+            s += u * u, a += c * c
+        }), 1 - s / a
     }
 
-    function ww(e, t, n) {
+    function U_(e, t, n) {
         let i = 0,
             r = 0,
-            a = 0,
             s = 0,
+            a = 0,
             o = 0;
-        xd(e, t, n, (c, f) => {
-            ++o, i += (c - i) / o, r += (f - r) / o, a += (c * f - a) / o, s += (c * c - s) / o
+        ld(e, t, n, (c, f) => {
+            ++o, i += (c - i) / o, r += (f - r) / o, s += (c * f - s) / o, a += (c * c - a) / o
         });
-        const l = bd(i, r, a, s),
+        const l = od(i, r, s, a),
             u = c => l[0] + l[1] * c;
         return {
             coef: l,
             predict: u,
-            rSquared: Nc(e, t, n, r, u)
+            rSquared: Ec(e, t, n, r, u)
         }
     }
 
-    function YP(e, t, n) {
+    function rN(e, t, n) {
         let i = 0,
             r = 0,
-            a = 0,
             s = 0,
+            a = 0,
             o = 0;
-        xd(e, t, n, (c, f) => {
-            ++o, c = Math.log(c), i += (c - i) / o, r += (f - r) / o, a += (c * f - a) / o, s += (c * c - s) / o
+        ld(e, t, n, (c, f) => {
+            ++o, c = Math.log(c), i += (c - i) / o, r += (f - r) / o, s += (c * f - s) / o, a += (c * c - a) / o
         });
-        const l = bd(i, r, a, s),
+        const l = od(i, r, s, a),
             u = c => l[0] + l[1] * Math.log(c);
         return {
             coef: l,
             predict: u,
-            rSquared: Nc(e, t, n, r, u)
+            rSquared: Ec(e, t, n, r, u)
         }
     }
 
-    function XP(e, t, n) {
-        const [i, r, a, s] = r1(e, t, n);
+    function sN(e, t, n) {
+        const [i, r, s, a] = zm(e, t, n);
         let o = 0,
             l = 0,
             u = 0,
             c = 0,
             f = 0,
             h, d, g;
-        xd(e, t, n, (v, b) => {
+        ld(e, t, n, (v, b) => {
             h = i[f++], d = Math.log(b), g = h * b, o += (b * d - o) / f, l += (g - l) / f, u += (g * d - u) / f, c += (h * g - c) / f
         });
-        const [p, m] = bd(l / s, o / s, u / s, c / s), y = v => Math.exp(p + m * (v - a));
+        const [p, m] = od(l / a, o / a, u / a, c / a), y = v => Math.exp(p + m * (v - s));
         return {
-            coef: [Math.exp(p - m * a), m],
+            coef: [Math.exp(p - m * s), m],
             predict: y,
-            rSquared: Nc(e, t, n, s, y)
+            rSquared: Ec(e, t, n, a, y)
         }
     }
 
-    function VP(e, t, n) {
+    function aN(e, t, n) {
         let i = 0,
             r = 0,
-            a = 0,
             s = 0,
+            a = 0,
             o = 0,
             l = 0;
-        xd(e, t, n, (f, h) => {
+        ld(e, t, n, (f, h) => {
             const d = Math.log(f),
                 g = Math.log(h);
-            ++l, i += (d - i) / l, r += (g - r) / l, a += (d * g - a) / l, s += (d * d - s) / l, o += (h - o) / l
+            ++l, i += (d - i) / l, r += (g - r) / l, s += (d * g - s) / l, a += (d * d - a) / l, o += (h - o) / l
         });
-        const u = bd(i, r, a, s),
+        const u = od(i, r, s, a),
             c = f => u[0] * Math.pow(f, u[1]);
         return u[0] = Math.exp(u[0]), {
             coef: u,
             predict: c,
-            rSquared: Nc(e, t, n, o, c)
+            rSquared: Ec(e, t, n, o, c)
         }
     }
 
-    function Sw(e, t, n) {
-        const [i, r, a, s] = r1(e, t, n), o = i.length;
+    function G_(e, t, n) {
+        const [i, r, s, a] = zm(e, t, n), o = i.length;
         let l = 0,
             u = 0,
             c = 0,
             f = 0,
             h = 0,
             d, g, p, m;
         for (d = 0; d < o;) g = i[d], p = r[d++], m = g * g, l += (m - l) / d, u += (m * g - u) / d, c += (m * m - c) / d, f += (g * p - f) / d, h += (m * p - h) / d;
         const y = c - l * l,
             v = l * y - u * u,
             b = (h * l - f * u) / v,
             x = (f * y - h * u) / v,
             _ = -b * l,
-            S = w => (w = w - a, b * w * w + x * w + _ + s);
+            S = w => (w = w - s, b * w * w + x * w + _ + a);
         return {
-            coef: [_ - x * a + b * a * a + s, x - 2 * b * a, b],
+            coef: [_ - x * s + b * s * s + a, x - 2 * b * s, b],
             predict: S,
-            rSquared: Nc(e, t, n, s, S)
+            rSquared: Ec(e, t, n, a, S)
         }
     }
 
-    function KP(e, t, n, i) {
-        if (i === 1) return ww(e, t, n);
-        if (i === 2) return Sw(e, t, n);
-        const [r, a, s, o] = r1(e, t, n), l = r.length, u = [], c = [], f = i + 1;
+    function oN(e, t, n, i) {
+        if (i === 0) return j_(e, t, n);
+        if (i === 1) return U_(e, t, n);
+        if (i === 2) return G_(e, t, n);
+        const [r, s, a, o] = zm(e, t, n), l = r.length, u = [], c = [], f = i + 1;
         let h, d, g, p, m;
         for (h = 0; h < f; ++h) {
-            for (g = 0, p = 0; g < l; ++g) p += Math.pow(r[g], h) * a[g];
+            for (g = 0, p = 0; g < l; ++g) p += Math.pow(r[g], h) * s[g];
             for (u.push(p), m = new Float64Array(f), d = 0; d < f; ++d) {
                 for (g = 0, p = 0; g < l; ++g) p += Math.pow(r[g], h + d);
                 m[d] = p
             }
             c.push(m)
         }
         c.push(u);
-        const y = bK(c),
+        const y = AV(c),
             v = b => {
-                b -= s;
+                b -= a;
                 let x = o + y[0] + y[1] * b + y[2] * b * b;
                 for (h = 3; h < f; ++h) x += y[h] * Math.pow(b, h);
                 return x
             };
         return {
-            coef: vK(f, y, -s, o),
+            coef: kV(f, y, -a, o),
             predict: v,
-            rSquared: Nc(e, t, n, o, v)
+            rSquared: Ec(e, t, n, o, v)
         }
     }
 
-    function vK(e, t, n, i) {
+    function kV(e, t, n, i) {
         const r = Array(e);
-        let a, s, o, l;
-        for (a = 0; a < e; ++a) r[a] = 0;
-        for (a = e - 1; a >= 0; --a)
-            for (o = t[a], l = 1, r[a] += o, s = 1; s <= a; ++s) l *= (a + 1 - s) / s, r[a - s] += o * Math.pow(n, s) * l;
+        let s, a, o, l;
+        for (s = 0; s < e; ++s) r[s] = 0;
+        for (s = e - 1; s >= 0; --s)
+            for (o = t[s], l = 1, r[s] += o, a = 1; a <= s; ++a) l *= (s + 1 - a) / a, r[s - a] += o * Math.pow(n, a) * l;
         return r[0] += i, r
     }
 
-    function bK(e) {
+    function AV(e) {
         const t = e.length - 1,
             n = [];
-        let i, r, a, s, o;
+        let i, r, s, a, o;
         for (i = 0; i < t; ++i) {
-            for (s = i, r = i + 1; r < t; ++r) Math.abs(e[i][r]) > Math.abs(e[i][s]) && (s = r);
-            for (a = i; a < t + 1; ++a) o = e[a][i], e[a][i] = e[a][s], e[a][s] = o;
+            for (a = i, r = i + 1; r < t; ++r) Math.abs(e[i][r]) > Math.abs(e[i][a]) && (a = r);
+            for (s = i; s < t + 1; ++s) o = e[s][i], e[s][i] = e[s][a], e[s][a] = o;
             for (r = i + 1; r < t; ++r)
-                for (a = t; a >= i; a--) e[a][r] -= e[a][i] * e[i][r] / e[i][i]
+                for (s = t; s >= i; s--) e[s][r] -= e[s][i] * e[i][r] / e[i][i]
         }
         for (r = t - 1; r >= 0; --r) {
-            for (o = 0, a = r + 1; a < t; ++a) o += e[a][r] * n[a];
+            for (o = 0, s = r + 1; s < t; ++s) o += e[s][r] * n[s];
             n[r] = (e[t][r] - o) / e[r][r]
         }
         return n
     }
-    const bT = 2,
-        xT = 1e-12;
+    const R$ = 2,
+        D$ = 1e-12;
 
-    function JP(e, t, n, i) {
-        const [r, a, s, o] = r1(e, t, n, !0), l = r.length, u = Math.max(2, ~~(i * l)), c = new Float64Array(l), f = new Float64Array(l), h = new Float64Array(l).fill(1);
-        for (let d = -1; ++d <= bT;) {
+    function lN(e, t, n, i) {
+        const [r, s, a, o] = zm(e, t, n, !0), l = r.length, u = Math.max(2, ~~(i * l)), c = new Float64Array(l), f = new Float64Array(l), h = new Float64Array(l).fill(1);
+        for (let d = -1; ++d <= R$;) {
             const g = [0, u - 1];
             for (let m = 0; m < l; ++m) {
                 const y = r[m],
                     v = g[0],
                     b = g[1],
                     x = y - r[v] > r[b] - y ? v : b;
                 let _ = 0,
                     S = 0,
                     w = 0,
-                    O = 0,
-                    k = 0;
+                    E = 0,
+                    A = 0;
                 const C = 1 / Math.abs(r[x] - y || 1);
-                for (let A = v; A <= b; ++A) {
-                    const F = r[A],
-                        $ = a[A],
-                        D = xK(Math.abs(y - F) * C) * h[A],
-                        P = F * D;
-                    _ += D, S += P, w += $ * D, O += $ * P, k += F * P
+                for (let $ = v; $ <= b; ++$) {
+                    const T = r[$],
+                        M = s[$],
+                        F = $V(Math.abs(y - T) * C) * h[$],
+                        N = T * F;
+                    _ += F, S += N, w += M * F, E += M * N, A += T * N
                 }
-                const [E, T] = bd(S / _, w / _, O / _, k / _);
-                c[m] = E + T * y, f[m] = Math.abs(a[m] - c[m]), _K(r, m + 1, g)
+                const [k, R] = od(S / _, w / _, E / _, A / _);
+                c[m] = k + R * y, f[m] = Math.abs(s[m] - c[m]), TV(r, m + 1, g)
             }
-            if (d === bT) break;
-            const p = AF(f);
-            if (Math.abs(p) < xT) break;
-            for (let m = 0, y, v; m < l; ++m) y = f[m] / (6 * p), h[m] = y >= 1 ? xT : (v = 1 - y * y) * v
+            if (d === R$) break;
+            const p = zO(f);
+            if (Math.abs(p) < D$) break;
+            for (let m = 0, y, v; m < l; ++m) y = f[m] / (6 * p), h[m] = y >= 1 ? D$ : (v = 1 - y * y) * v
         }
-        return wK(r, c, s, o)
+        return MV(r, c, a, o)
     }
 
-    function xK(e) {
+    function $V(e) {
         return (e = 1 - e * e * e) * e * e
     }
 
-    function _K(e, t, n) {
+    function TV(e, t, n) {
         const i = e[t];
         let r = n[0],
-            a = n[1] + 1;
-        if (!(a >= e.length))
-            for (; t > r && e[a] - i <= i - e[r];) n[0] = ++r, n[1] = a, ++a
+            s = n[1] + 1;
+        if (!(s >= e.length))
+            for (; t > r && e[s] - i <= i - e[r];) n[0] = ++r, n[1] = s, ++s
     }
 
-    function wK(e, t, n, i) {
+    function MV(e, t, n, i) {
         const r = e.length,
-            a = [];
-        let s = 0,
+            s = [];
+        let a = 0,
             o = 0,
             l = [],
             u;
-        for (; s < r; ++s) u = e[s] + n, l[0] === u ? l[1] += (t[s] - l[1]) / ++o : (o = 0, l[1] += i, l = [u, t[s]], a.push(l));
-        return l[1] += i, a
+        for (; a < r; ++a) u = e[a] + n, l[0] === u ? l[1] += (t[a] - l[1]) / ++o : (o = 0, l[1] += i, l = [u, t[a]], s.push(l));
+        return l[1] += i, s
     }
-    const SK = .5 * Math.PI / 180;
+    const OV = .5 * Math.PI / 180;
 
-    function a1(e, t, n, i) {
+    function Bm(e, t, n, i) {
         n = n || 25, i = Math.max(n, i || 200);
         const r = p => [p, e(p)],
-            a = t[0],
-            s = t[1],
-            o = s - a,
+            s = t[0],
+            a = t[1],
+            o = a - s,
             l = o / i,
-            u = [r(a)],
+            u = [r(s)],
             c = [];
         if (n === i) {
-            for (let p = 1; p < i; ++p) u.push(r(a + p / n * o));
-            return u.push(r(s)), u
+            for (let p = 1; p < i; ++p) u.push(r(s + p / n * o));
+            return u.push(r(a)), u
         } else {
-            c.push(r(s));
-            for (let p = n; --p > 0;) c.push(r(a + p / n * o))
+            c.push(r(a));
+            for (let p = n; --p > 0;) c.push(r(s + p / n * o))
         }
         let f = u[0],
             h = c[c.length - 1];
         const d = 1 / o,
-            g = EK(f[1], c);
+            g = FV(f[1], c);
         for (; h;) {
             const p = r((f[0] + h[0]) / 2);
-            p[0] - f[0] >= l && OK(f, p, h, d, g) > SK ? c.push(p) : (f = h, u.push(h), c.pop()), h = c[c.length - 1]
+            p[0] - f[0] >= l && RV(f, p, h, d, g) > OV ? c.push(p) : (f = h, u.push(h), c.pop()), h = c[c.length - 1]
         }
         return u
     }
 
-    function EK(e, t) {
+    function FV(e, t) {
         let n = e,
             i = e;
         const r = t.length;
-        for (let a = 0; a < r; ++a) {
-            const s = t[a][1];
-            s < n && (n = s), s > i && (i = s)
+        for (let s = 0; s < r; ++s) {
+            const a = t[s][1];
+            a < n && (n = a), a > i && (i = a)
         }
         return 1 / (i - n)
     }
 
-    function OK(e, t, n, i, r) {
-        const a = Math.atan2(r * (n[1] - e[1]), i * (n[0] - e[0])),
-            s = Math.atan2(r * (t[1] - e[1]), i * (t[0] - e[0]));
-        return Math.abs(a - s)
+    function RV(e, t, n, i, r) {
+        const s = Math.atan2(r * (n[1] - e[1]), i * (n[0] - e[0])),
+            a = Math.atan2(r * (t[1] - e[1]), i * (t[0] - e[0]));
+        return Math.abs(s - a)
     }
 
-    function CK(e) {
+    function DV(e) {
         return t => {
             const n = e.length;
             let i = 1,
                 r = String(e[0](t));
             for (; i < n; ++i) r += "|" + e[i](t);
             return r
         }
     }
 
-    function C2(e) {
+    function e2(e) {
         return !e || !e.length ? function() {
             return ""
-        } : e.length === 1 ? e[0] : CK(e)
+        } : e.length === 1 ? e[0] : DV(e)
     }
 
-    function QP(e, t, n) {
+    function uN(e, t, n) {
         return n || e + (t ? "_" + t : "")
     }
-    const yv = () => {},
-        kK = {
-            init: yv,
-            add: yv,
-            rem: yv,
+    const Vy = () => {},
+        NV = {
+            init: Vy,
+            add: Vy,
+            rem: Vy,
             idx: 0
         },
-        Nh = {
+        Eh = {
             values: {
                 init: e => e.cell.store = !0,
                 value: e => e.cell.data.values(),
                 idx: -1
             },
             count: {
                 value: e => e.cell.num
@@ -19954,177 +19974,177 @@
                 rem: (e, t) => {
                     t >= e.max && (e.argmax = void 0)
                 },
                 req: ["max", "values"],
                 idx: 3
             }
         },
-        _d = Object.keys(Nh).filter(e => e !== "__count__");
+        ud = Object.keys(Eh).filter(e => e !== "__count__");
 
-    function AK(e, t) {
-        return n => ke({
+    function PV(e, t) {
+        return n => Ae({
             name: e,
             out: n || e
-        }, kK, t)
-    } [..._d, "__count__"].forEach(e => {
-        Nh[e] = AK(e, Nh[e])
+        }, NV, t)
+    } [...ud, "__count__"].forEach(e => {
+        Eh[e] = PV(e, Eh[e])
     });
 
-    function ZP(e, t) {
-        return Nh[e](t)
+    function cN(e, t) {
+        return Eh[e](t)
     }
 
-    function eN(e, t) {
+    function fN(e, t) {
         return e.idx - t.idx
     }
 
-    function TK(e) {
+    function LV(e) {
         const t = {};
         e.forEach(i => t[i.name] = i);
         const n = i => {
             i.req && i.req.forEach(r => {
-                t[r] || n(t[r] = Nh[r]())
+                t[r] || n(t[r] = Eh[r]())
             })
         };
-        return e.forEach(n), Object.values(t).sort(eN)
+        return e.forEach(n), Object.values(t).sort(fN)
     }
 
-    function $K() {
+    function IV() {
         this.valid = 0, this.missing = 0, this._ops.forEach(e => e.init(this))
     }
 
-    function MK(e, t) {
+    function zV(e, t) {
         if (e == null || e === "") {
             ++this.missing;
             return
         }
         e === e && (++this.valid, this._ops.forEach(n => n.add(this, e, t)))
     }
 
-    function FK(e, t) {
+    function BV(e, t) {
         if (e == null || e === "") {
             --this.missing;
             return
         }
         e === e && (--this.valid, this._ops.forEach(n => n.rem(this, e, t)))
     }
 
-    function DK(e) {
+    function jV(e) {
         return this._out.forEach(t => e[t.out] = t.value(this)), e
     }
 
-    function tN(e, t) {
-        const n = t || wn,
-            i = TK(e),
-            r = e.slice().sort(eN);
+    function hN(e, t) {
+        const n = t || bn,
+            i = LV(e),
+            r = e.slice().sort(fN);
 
-        function a(s) {
-            this._ops = i, this._out = r, this.cell = s, this.init()
+        function s(a) {
+            this._ops = i, this._out = r, this.cell = a, this.init()
         }
-        return a.prototype.init = $K, a.prototype.add = MK, a.prototype.rem = FK, a.prototype.set = DK, a.prototype.get = n, a.fields = e.map(s => s.out), a
+        return s.prototype.init = IV, s.prototype.add = zV, s.prototype.rem = BV, s.prototype.set = jV, s.prototype.get = n, s.fields = e.map(a => a.out), s
     }
 
-    function Ew(e) {
-        this._key = e ? ri(e) : de, this.reset()
+    function W_(e) {
+        this._key = e ? ni(e) : ge, this.reset()
     }
-    const an = Ew.prototype;
-    an.reset = function() {
+    const nn = W_.prototype;
+    nn.reset = function() {
         this._add = [], this._rem = [], this._ext = null, this._get = null, this._q = null
     };
-    an.add = function(e) {
+    nn.add = function(e) {
         this._add.push(e)
     };
-    an.rem = function(e) {
+    nn.rem = function(e) {
         this._rem.push(e)
     };
-    an.values = function() {
+    nn.values = function() {
         if (this._get = null, this._rem.length === 0) return this._add;
         const e = this._add,
             t = this._rem,
             n = this._key,
             i = e.length,
             r = t.length,
-            a = Array(i - r),
-            s = {};
+            s = Array(i - r),
+            a = {};
         let o, l, u;
-        for (o = 0; o < r; ++o) s[n(t[o])] = 1;
-        for (o = 0, l = 0; o < i; ++o) s[n(u = e[o])] ? s[n(u)] = 0 : a[l++] = u;
-        return this._rem = [], this._add = a
+        for (o = 0; o < r; ++o) a[n(t[o])] = 1;
+        for (o = 0, l = 0; o < i; ++o) a[n(u = e[o])] ? a[n(u)] = 0 : s[l++] = u;
+        return this._rem = [], this._add = s
     };
-    an.distinct = function(e) {
+    nn.distinct = function(e) {
         const t = this.values(),
             n = {};
         let i = t.length,
             r = 0,
-            a;
-        for (; --i >= 0;) a = e(t[i]) + "", pe(n, a) || (n[a] = 1, ++r);
+            s;
+        for (; --i >= 0;) s = e(t[i]) + "", me(n, s) || (n[s] = 1, ++r);
         return r
     };
-    an.extent = function(e) {
+    nn.extent = function(e) {
         if (this._get !== e || !this._ext) {
             const t = this.values(),
-                n = UR(t, e);
+                n = eD(t, e);
             this._ext = [t[n[0]], t[n[1]]], this._get = e
         }
         return this._ext
     };
-    an.argmin = function(e) {
+    nn.argmin = function(e) {
         return this.extent(e)[0] || {}
     };
-    an.argmax = function(e) {
+    nn.argmax = function(e) {
         return this.extent(e)[1] || {}
     };
-    an.min = function(e) {
+    nn.min = function(e) {
         const t = this.extent(e)[0];
         return t != null ? e(t) : void 0
     };
-    an.max = function(e) {
+    nn.max = function(e) {
         const t = this.extent(e)[1];
         return t != null ? e(t) : void 0
     };
-    an.quartile = function(e) {
-        return (this._get !== e || !this._q) && (this._q = uw(this.values(), e), this._get = e), this._q
+    nn.quartile = function(e) {
+        return (this._get !== e || !this._q) && (this._q = $_(this.values(), e), this._get = e), this._q
     };
-    an.q1 = function(e) {
+    nn.q1 = function(e) {
         return this.quartile(e)[0]
     };
-    an.q2 = function(e) {
+    nn.q2 = function(e) {
         return this.quartile(e)[1]
     };
-    an.q3 = function(e) {
+    nn.q3 = function(e) {
         return this.quartile(e)[2]
     };
-    an.ci = function(e) {
-        return (this._get !== e || !this._ci) && (this._ci = BP(this.values(), 1e3, .05, e), this._get = e), this._ci
+    nn.ci = function(e) {
+        return (this._get !== e || !this._ci) && (this._ci = QD(this.values(), 1e3, .05, e), this._get = e), this._ci
     };
-    an.ci0 = function(e) {
+    nn.ci0 = function(e) {
         return this.ci(e)[0]
     };
-    an.ci1 = function(e) {
+    nn.ci1 = function(e) {
         return this.ci(e)[1]
     };
 
-    function Us(e) {
+    function Ra(e) {
         L.call(this, null, e), this._adds = [], this._mods = [], this._alen = 0, this._mlen = 0, this._drop = !0, this._cross = !1, this._dims = [], this._dnames = [], this._measures = [], this._countOnly = !1, this._counts = null, this._prev = null, this._inputs = null, this._outputs = null
     }
-    Us.Definition = {
+    Ra.Definition = {
         type: "Aggregate",
         metadata: {
             generates: !0,
             changes: !0
         },
         params: [{
             name: "groupby",
             type: "field",
             array: !0
         }, {
             name: "ops",
             type: "enum",
             array: !0,
-            values: _d
+            values: ud
         }, {
             name: "fields",
             type: "field",
             null: !0,
             array: !0
         }, {
             name: "as",
@@ -20140,77 +20160,77 @@
             type: "boolean",
             default: !1
         }, {
             name: "key",
             type: "field"
         }]
     };
-    Q(Us, L, {
+    ee(Ra, L, {
         transform(e, t) {
             const n = this,
                 i = t.fork(t.NO_SOURCE | t.NO_FIELDS),
                 r = e.modified();
-            return n.stamp = i.stamp, n.value && (r || t.modified(n._inputs, !0)) ? (n._prev = n.value, n.value = r ? n.init(e) : {}, t.visit(t.SOURCE, a => n.add(a))) : (n.value = n.value || n.init(e), t.visit(t.REM, a => n.rem(a)), t.visit(t.ADD, a => n.add(a))), i.modifies(n._outputs), n._drop = e.drop !== !1, e.cross && n._dims.length > 1 && (n._drop = !1, n.cross()), t.clean() && n._drop && i.clean(!0).runAfter(() => this.clean()), n.changes(i)
+            return n.stamp = i.stamp, n.value && (r || t.modified(n._inputs, !0)) ? (n._prev = n.value, n.value = r ? n.init(e) : Object.create(null), t.visit(t.SOURCE, s => n.add(s))) : (n.value = n.value || n.init(e), t.visit(t.REM, s => n.rem(s)), t.visit(t.ADD, s => n.add(s))), i.modifies(n._outputs), n._drop = e.drop !== !1, e.cross && n._dims.length > 1 && (n._drop = !1, n.cross()), t.clean() && n._drop && i.clean(!0).runAfter(() => this.clean()), n.changes(i)
         },
         cross() {
             const e = this,
                 t = e.value,
                 n = e._dnames,
                 i = n.map(() => ({})),
                 r = n.length;
 
-            function a(o) {
+            function s(o) {
                 let l, u, c, f;
                 for (l in o)
                     for (c = o[l].tuple, u = 0; u < r; ++u) i[u][f = c[n[u]]] = f
             }
-            a(e._prev), a(t);
+            s(e._prev), s(t);
 
-            function s(o, l, u) {
+            function a(o, l, u) {
                 const c = n[u],
                     f = i[u++];
                 for (const h in f) {
                     const d = o ? o + "|" + h : h;
-                    l[c] = f[h], u < r ? s(d, l, u) : t[d] || e.cell(d, l)
+                    l[c] = f[h], u < r ? a(d, l, u) : t[d] || e.cell(d, l)
                 }
             }
-            s("", {}, 0)
+            a("", {}, 0)
         },
         init(e) {
             const t = this._inputs = [],
                 n = this._outputs = [],
                 i = {};
 
             function r(m) {
-                const y = ie(yn(m)),
+                const y = se(pn(m)),
                     v = y.length;
                 let b = 0,
                     x;
                 for (; b < v; ++b) i[x = y[b]] || (i[x] = 1, t.push(x))
             }
-            this._dims = ie(e.groupby), this._dnames = this._dims.map(m => {
-                const y = wt(m);
+            this._dims = se(e.groupby), this._dnames = this._dims.map(m => {
+                const y = bt(m);
                 return r(m), n.push(y), y
-            }), this.cellkey = e.key ? e.key : C2(this._dims), this._countOnly = !0, this._counts = [], this._measures = [];
-            const a = e.fields || [null],
-                s = e.ops || ["count"],
+            }), this.cellkey = e.key ? e.key : e2(this._dims), this._countOnly = !0, this._counts = [], this._measures = [];
+            const s = e.fields || [null],
+                a = e.ops || ["count"],
                 o = e.as || [],
-                l = a.length,
+                l = s.length,
                 u = {};
             let c, f, h, d, g, p;
-            for (l !== s.length && G("Unmatched number of fields and aggregate ops."), p = 0; p < l; ++p) {
-                if (c = a[p], f = s[p], c == null && f !== "count" && G("Null aggregate field specified."), d = wt(c), g = QP(f, d, o[p]), n.push(g), f === "count") {
+            for (l !== a.length && U("Unmatched number of fields and aggregate ops."), p = 0; p < l; ++p) {
+                if (c = s[p], f = a[p], c == null && f !== "count" && U("Null aggregate field specified."), d = bt(c), g = uN(f, d, o[p]), n.push(g), f === "count") {
                     this._counts.push(g);
                     continue
                 }
-                h = u[d], h || (r(c), h = u[d] = [], h.field = c, this._measures.push(h)), f !== "count" && (this._countOnly = !1), h.push(ZP(f, g))
+                h = u[d], h || (r(c), h = u[d] = [], h.field = c, this._measures.push(h)), f !== "count" && (this._countOnly = !1), h.push(cN(f, g))
             }
-            return this._measures = this._measures.map(m => tN(m, m.field)), {}
+            return this._measures = this._measures.map(m => hN(m, m.field)), Object.create(null)
         },
-        cellkey: C2(),
+        cellkey: e2(),
         cell(e, t) {
             let n = this.value[e];
             return n ? n.num === 0 && this._drop && n.stamp < this.stamp ? (n.stamp = this.stamp, this._adds[this._alen++] = n) : n.stamp < this.stamp && (n.stamp = this.stamp, this._mods[this._mlen++] = n) : (n = this.value[e] = this.newcell(e, t), this._adds[this._alen++] = n), n
         },
         newcell(e, t) {
             const n = {
                 key: e,
@@ -20220,79 +20240,79 @@
                 stamp: this.stamp,
                 store: !1
             };
             if (!this._countOnly) {
                 const i = this._measures,
                     r = i.length;
                 n.agg = Array(r);
-                for (let a = 0; a < r; ++a) n.agg[a] = new i[a](n)
+                for (let s = 0; s < r; ++s) n.agg[s] = new i[s](n)
             }
-            return n.store && (n.data = new Ew), n
+            return n.store && (n.data = new W_), n
         },
         newtuple(e, t) {
             const n = this._dnames,
                 i = this._dims,
                 r = i.length,
-                a = {};
-            for (let s = 0; s < r; ++s) a[n[s]] = i[s](e);
-            return t ? DP(t.tuple, a) : He(a)
+                s = {};
+            for (let a = 0; a < r; ++a) s[n[a]] = i[a](e);
+            return t ? WD(t.tuple, s) : He(s)
         },
         clean() {
             const e = this.value;
             for (const t in e) e[t].num === 0 && delete e[t]
         },
         add(e) {
             const t = this.cellkey(e),
                 n = this.cell(t, e);
             if (n.num += 1, this._countOnly) return;
             n.store && n.data.add(e);
             const i = n.agg;
-            for (let r = 0, a = i.length; r < a; ++r) i[r].add(i[r].get(e), e)
+            for (let r = 0, s = i.length; r < s; ++r) i[r].add(i[r].get(e), e)
         },
         rem(e) {
             const t = this.cellkey(e),
                 n = this.cell(t, e);
             if (n.num -= 1, this._countOnly) return;
             n.store && n.data.rem(e);
             const i = n.agg;
-            for (let r = 0, a = i.length; r < a; ++r) i[r].rem(i[r].get(e), e)
+            for (let r = 0, s = i.length; r < s; ++r) i[r].rem(i[r].get(e), e)
         },
         celltuple(e) {
             const t = e.tuple,
                 n = this._counts;
             e.store && e.data.values();
             for (let i = 0, r = n.length; i < r; ++i) t[n[i]] = e.num;
             if (!this._countOnly) {
                 const i = e.agg;
-                for (let r = 0, a = i.length; r < a; ++r) i[r].set(t)
+                for (let r = 0, s = i.length; r < s; ++r) i[r].set(t)
             }
             return t
         },
         changes(e) {
             const t = this._adds,
                 n = this._mods,
                 i = this._prev,
                 r = this._drop,
-                a = e.add,
-                s = e.rem,
+                s = e.add,
+                a = e.rem,
                 o = e.mod;
             let l, u, c, f;
             if (i)
-                for (u in i) l = i[u], (!r || l.num) && s.push(l.tuple);
-            for (c = 0, f = this._alen; c < f; ++c) a.push(this.celltuple(t[c])), t[c] = null;
-            for (c = 0, f = this._mlen; c < f; ++c) l = n[c], (l.num === 0 && r ? s : o).push(this.celltuple(l)), n[c] = null;
+                for (u in i) l = i[u], (!r || l.num) && a.push(l.tuple);
+            for (c = 0, f = this._alen; c < f; ++c) s.push(this.celltuple(t[c])), t[c] = null;
+            for (c = 0, f = this._mlen; c < f; ++c) l = n[c], (l.num === 0 && r ? a : o).push(this.celltuple(l)), n[c] = null;
             return this._alen = this._mlen = 0, this._prev = null, e
         }
     });
-    const RK = 1e-14;
+    const UV = 1e-14;
 
-    function Ow(e) {
+    function q_(e) {
         L.call(this, null, e)
     }
-    Ow.Definition = {
+    q_.Definition = {
         type: "Bin",
         metadata: {
             modifies: !0
         },
         params: [{
             name: "field",
             type: "field",
@@ -20348,96 +20368,96 @@
             name: "as",
             type: "string",
             array: !0,
             length: 2,
             default: ["bin0", "bin1"]
         }]
     };
-    Q(Ow, L, {
+    ee(q_, L, {
         transform(e, t) {
             const n = e.interval !== !1,
                 i = this._bins(e),
                 r = i.start,
-                a = i.step,
-                s = e.as || ["bin0", "bin1"],
-                o = s[0],
-                l = s[1];
+                s = i.step,
+                a = e.as || ["bin0", "bin1"],
+                o = a[0],
+                l = a[1];
             let u;
-            return e.modified() ? (t = t.reflow(!0), u = t.SOURCE) : u = t.modified(yn(e.field)) ? t.ADD_MOD : t.ADD, t.visit(u, n ? c => {
+            return e.modified() ? (t = t.reflow(!0), u = t.SOURCE) : u = t.modified(pn(e.field)) ? t.ADD_MOD : t.ADD, t.visit(u, n ? c => {
                 const f = i(c);
-                c[o] = f, c[l] = f == null ? null : r + a * (1 + (f - r) / a)
-            } : c => c[o] = i(c)), t.modifies(n ? s : o)
+                c[o] = f, c[l] = f == null ? null : r + s * (1 + (f - r) / s)
+            } : c => c[o] = i(c)), t.modifies(n ? a : o)
         },
         _bins(e) {
             if (this.value && !e.modified()) return this.value;
             const t = e.field,
-                n = zP(e),
+                n = JD(e),
                 i = n.step;
             let r = n.start,
-                a = r + Math.ceil((n.stop - r) / i) * i,
-                s, o;
-            (s = e.anchor) != null && (o = s - (r + i * Math.floor((s - r) / i)), r += o, a += o);
+                s = r + Math.ceil((n.stop - r) / i) * i,
+                a, o;
+            (a = e.anchor) != null && (o = a - (r + i * Math.floor((a - r) / i)), r += o, s += o);
             const l = function(u) {
-                let c = gn(t(u));
-                return c == null ? null : c < r ? -1 / 0 : c > a ? 1 / 0 : (c = Math.max(r, Math.min(c, a - i)), r + i * Math.floor(RK + (c - r) / i))
+                let c = hn(t(u));
+                return c == null ? null : c < r ? -1 / 0 : c > s ? 1 / 0 : (c = Math.max(r, Math.min(c, s - i)), r + i * Math.floor(UV + (c - r) / i))
             };
-            return l.start = r, l.stop = n.stop, l.step = i, this.value = ci(l, yn(t), e.name || "bin_" + wt(t))
+            return l.start = r, l.stop = n.stop, l.step = i, this.value = li(l, pn(t), e.name || "bin_" + bt(t))
         }
     });
 
-    function nN(e, t, n) {
+    function dN(e, t, n) {
         const i = e;
         let r = t || [],
-            a = n || [],
-            s = {},
+            s = n || [],
+            a = {},
             o = 0;
         return {
-            add: l => a.push(l),
-            remove: l => s[i(l)] = ++o,
+            add: l => s.push(l),
+            remove: l => a[i(l)] = ++o,
             size: () => r.length,
-            data: (l, u) => (o && (r = r.filter(c => !s[i(c)]), s = {}, o = 0), u && l && r.sort(l), a.length && (r = l ? VR(l, r, a.sort(l)) : r.concat(a), a = []), r)
+            data: (l, u) => (o && (r = r.filter(c => !a[i(c)]), a = {}, o = 0), u && l && r.sort(l), s.length && (r = l ? aD(l, r, s.sort(l)) : r.concat(s), s = []), r)
         }
     }
 
-    function Cw(e) {
+    function H_(e) {
         L.call(this, [], e)
     }
-    Cw.Definition = {
+    H_.Definition = {
         type: "Collect",
         metadata: {
             source: !0
         },
         params: [{
             name: "sort",
             type: "compare"
         }]
     };
-    Q(Cw, L, {
+    ee(H_, L, {
         transform(e, t) {
             const n = t.fork(t.ALL),
-                i = nN(de, this.value, n.materialize(n.ADD).add),
+                i = dN(ge, this.value, n.materialize(n.ADD).add),
                 r = e.sort,
-                a = t.changed() || r && (e.modified("sort") || t.modified(r.fields));
-            return n.visit(n.REM, i.remove), this.modified(a), this.value = n.source = i.data(jl(r), a), t.source && t.source.root && (this.value.root = t.source.root), n
+                s = t.changed() || r && (e.modified("sort") || t.modified(r.fields));
+            return n.visit(n.REM, i.remove), this.modified(s), this.value = n.source = i.data($l(r), s), t.source && t.source.root && (this.value.root = t.source.root), n
         }
     });
 
-    function iN(e) {
-        rt.call(this, null, PK, e)
+    function gN(e) {
+        it.call(this, null, GV, e)
     }
-    Q(iN, rt);
+    ee(gN, it);
 
-    function PK(e) {
-        return this.value && !e.modified() ? this.value : H_(e.fields, e.orders)
+    function GV(e) {
+        return this.value && !e.modified() ? this.value : f_(e.fields, e.orders)
     }
 
-    function kw(e) {
+    function Y_(e) {
         L.call(this, null, e)
     }
-    kw.Definition = {
+    Y_.Definition = {
         type: "CountPattern",
         metadata: {
             generates: !0,
             changes: !0
         },
         params: [{
             name: "field",
@@ -20461,60 +20481,60 @@
             type: "string",
             array: !0,
             length: 2,
             default: ["text", "count"]
         }]
     };
 
-    function NK(e, t, n) {
+    function WV(e, t, n) {
         switch (t) {
             case "upper":
                 e = e.toUpperCase();
                 break;
             case "lower":
                 e = e.toLowerCase();
                 break
         }
         return e.match(n)
     }
-    Q(kw, L, {
+    ee(Y_, L, {
         transform(e, t) {
             const n = f => h => {
-                    for (var d = NK(o(h), e.case, a) || [], g, p = 0, m = d.length; p < m; ++p) s.test(g = d[p]) || f(g)
+                    for (var d = WV(o(h), e.case, s) || [], g, p = 0, m = d.length; p < m; ++p) a.test(g = d[p]) || f(g)
                 },
                 i = this._parameterCheck(e, t),
                 r = this._counts,
-                a = this._match,
-                s = this._stop,
+                s = this._match,
+                a = this._stop,
                 o = e.field,
                 l = e.as || ["text", "count"],
                 u = n(f => r[f] = 1 + (r[f] || 0)),
                 c = n(f => r[f] -= 1);
             return i ? t.visit(t.SOURCE, u) : (t.visit(t.ADD, u), t.visit(t.REM, c)), this._finish(t, l)
         },
         _parameterCheck(e, t) {
             let n = !1;
             return (e.modified("stopwords") || !this._stop) && (this._stop = new RegExp("^" + (e.stopwords || "") + "$", "i"), n = !0), (e.modified("pattern") || !this._match) && (this._match = new RegExp(e.pattern || "[\\w']+", "g"), n = !0), (e.modified("field") || t.modified(e.field.fields)) && (n = !0), n && (this._counts = {}), n
         },
         _finish(e, t) {
             const n = this._counts,
                 i = this._tuples || (this._tuples = {}),
                 r = t[0],
-                a = t[1],
-                s = e.fork(e.NO_SOURCE | e.NO_FIELDS);
+                s = t[1],
+                a = e.fork(e.NO_SOURCE | e.NO_FIELDS);
             let o, l, u;
-            for (o in n) l = i[o], u = n[o] || 0, !l && u ? (i[o] = l = He({}), l[r] = o, l[a] = u, s.add.push(l)) : u === 0 ? (l && s.rem.push(l), n[o] = null, i[o] = null) : l[a] !== u && (l[a] = u, s.mod.push(l));
-            return s.modifies(t)
+            for (o in n) l = i[o], u = n[o] || 0, !l && u ? (i[o] = l = He({}), l[r] = o, l[s] = u, a.add.push(l)) : u === 0 ? (l && a.rem.push(l), n[o] = null, i[o] = null) : l[s] !== u && (l[s] = u, a.mod.push(l));
+            return a.modifies(t)
         }
     });
 
-    function Aw(e) {
+    function X_(e) {
         L.call(this, null, e)
     }
-    Aw.Definition = {
+    X_.Definition = {
         type: "Cross",
         metadata: {
             generates: !0
         },
         params: [{
             name: "filter",
             type: "expr"
@@ -20522,54 +20542,54 @@
             name: "as",
             type: "string",
             array: !0,
             length: 2,
             default: ["a", "b"]
         }]
     };
-    Q(Aw, L, {
+    ee(X_, L, {
         transform(e, t) {
             const n = t.fork(t.NO_SOURCE),
                 i = e.as || ["a", "b"],
                 r = i[0],
-                a = i[1],
-                s = !this.value || t.changed(t.ADD_REM) || e.modified("as") || e.modified("filter");
+                s = i[1],
+                a = !this.value || t.changed(t.ADD_REM) || e.modified("as") || e.modified("filter");
             let o = this.value;
-            return s ? (o && (n.rem = o), o = t.materialize(t.SOURCE).source, n.add = this.value = LK(o, r, a, e.filter || Ii)) : n.mod = o, n.source = this.value, n.modifies(i)
+            return a ? (o && (n.rem = o), o = t.materialize(t.SOURCE).source, n.add = this.value = qV(o, r, s, e.filter || Ri)) : n.mod = o, n.source = this.value, n.modifies(i)
         }
     });
 
-    function LK(e, t, n, i) {
-        for (var r = [], a = {}, s = e.length, o = 0, l, u; o < s; ++o)
-            for (a[t] = u = e[o], l = 0; l < s; ++l) a[n] = e[l], i(a) && (r.push(He(a)), a = {}, a[t] = u);
+    function qV(e, t, n, i) {
+        for (var r = [], s = {}, a = e.length, o = 0, l, u; o < a; ++o)
+            for (s[t] = u = e[o], l = 0; l < a; ++l) s[n] = e[l], i(s) && (r.push(He(s)), s = {}, s[t] = u);
         return r
     }
-    const _T = {
-            kde: dw,
-            mixture: WP,
-            normal: hw,
-            lognormal: qP,
-            uniform: HP
-        },
-        IK = "distributions",
-        wT = "function",
-        jK = "field";
-
-    function rN(e, t) {
-        const n = e[wT];
-        pe(_T, n) || G("Unknown distribution function: " + n);
-        const i = _T[n]();
-        for (const r in e) r === jK ? i.data((e.from || t()).map(e[r])) : r === IK ? i[r](e[r].map(a => rN(a, t))) : typeof i[r] === wT && i[r](e[r]);
+    const N$ = {
+            kde: F_,
+            mixture: nN,
+            normal: O_,
+            lognormal: tN,
+            uniform: iN
+        },
+        HV = "distributions",
+        P$ = "function",
+        YV = "field";
+
+    function pN(e, t) {
+        const n = e[P$];
+        me(N$, n) || U("Unknown distribution function: " + n);
+        const i = N$[n]();
+        for (const r in e) r === YV ? i.data((e.from || t()).map(e[r])) : r === HV ? i[r](e[r].map(s => pN(s, t))) : typeof i[r] === P$ && i[r](e[r]);
         return i
     }
 
-    function Tw(e) {
+    function V_(e) {
         L.call(this, null, e)
     }
-    const aN = [{
+    const mN = [{
             key: {
                 function: "normal"
             },
             params: [{
                 name: "mean",
                 type: "number",
                 default: 0
@@ -20617,30 +20637,30 @@
                 type: "data"
             }, {
                 name: "bandwidth",
                 type: "number",
                 default: 0
             }]
         }],
-        zK = {
+        XV = {
             key: {
                 function: "mixture"
             },
             params: [{
                 name: "distributions",
                 type: "param",
                 array: !0,
-                params: aN
+                params: mN
             }, {
                 name: "weights",
                 type: "number",
                 array: !0
             }]
         };
-    Tw.Definition = {
+    V_.Definition = {
         type: "Density",
         metadata: {
             generates: !0
         },
         params: [{
             name: "extent",
             type: "number",
@@ -20661,66 +20681,66 @@
             name: "method",
             type: "string",
             default: "pdf",
             values: ["pdf", "cdf"]
         }, {
             name: "distribution",
             type: "param",
-            params: aN.concat(zK)
+            params: mN.concat(XV)
         }, {
             name: "as",
             type: "string",
             array: !0,
             default: ["value", "density"]
         }]
     };
-    Q(Tw, L, {
+    ee(V_, L, {
         transform(e, t) {
             const n = t.fork(t.NO_SOURCE | t.NO_FIELDS);
             if (!this.value || t.changed() || e.modified()) {
-                const i = rN(e.distribution, BK(t)),
+                const i = pN(e.distribution, VV(t)),
                     r = e.steps || e.minsteps || 25,
-                    a = e.steps || e.maxsteps || 200;
-                let s = e.method || "pdf";
-                s !== "pdf" && s !== "cdf" && G("Invalid density method: " + s), !e.extent && !i.data && G("Missing density extent parameter."), s = i[s];
+                    s = e.steps || e.maxsteps || 200;
+                let a = e.method || "pdf";
+                a !== "pdf" && a !== "cdf" && U("Invalid density method: " + a), !e.extent && !i.data && U("Missing density extent parameter."), a = i[a];
                 const o = e.as || ["value", "density"],
-                    l = e.extent || Zr(i.data()),
-                    u = a1(s, l, r, a).map(c => {
+                    l = e.extent || Hr(i.data()),
+                    u = Bm(a, l, r, s).map(c => {
                         const f = {};
                         return f[o[0]] = c[0], f[o[1]] = c[1], He(f)
                     });
                 this.value && (n.rem = this.value), this.value = n.add = n.source = u
             }
             return n
         }
     });
 
-    function BK(e) {
+    function VV(e) {
         return () => e.materialize(e.SOURCE).source
     }
 
-    function sN(e, t) {
-        return e ? e.map((n, i) => t[i] || wt(n)) : null
+    function yN(e, t) {
+        return e ? e.map((n, i) => t[i] || bt(n)) : null
     }
 
-    function $w(e, t, n) {
+    function K_(e, t, n) {
         const i = [],
             r = f => f(l);
-        let a, s, o, l, u, c;
+        let s, a, o, l, u, c;
         if (t == null) i.push(e.map(n));
         else
-            for (a = {}, s = 0, o = e.length; s < o; ++s) l = e[s], u = t.map(r), c = a[u], c || (a[u] = c = [], c.dims = u, i.push(c)), c.push(n(l));
+            for (s = {}, a = 0, o = e.length; a < o; ++a) l = e[a], u = t.map(r), c = s[u], c || (s[u] = c = [], c.dims = u, i.push(c)), c.push(n(l));
         return i
     }
-    const oN = "bin";
+    const vN = "bin";
 
-    function Mw(e) {
+    function J_(e) {
         L.call(this, null, e)
     }
-    Mw.Definition = {
+    J_.Definition = {
         type: "DotBin",
         metadata: {
             modifies: !0
         },
         params: [{
             name: "field",
             type: "field",
@@ -20735,90 +20755,90 @@
         }, {
             name: "smooth",
             type: "boolean",
             default: !1
         }, {
             name: "as",
             type: "string",
-            default: oN
+            default: vN
         }]
     };
-    const GK = (e, t) => vd(Zr(e, t)) / 30;
-    Q(Mw, L, {
+    const KV = (e, t) => ad(Hr(e, t)) / 30;
+    ee(J_, L, {
         transform(e, t) {
             if (this.value && !(e.modified() || t.changed())) return t;
             const n = t.materialize(t.SOURCE).source,
-                i = $w(t.source, e.groupby, wn),
+                i = K_(t.source, e.groupby, bn),
                 r = e.smooth || !1,
-                a = e.field,
-                s = e.step || GK(n, a),
-                o = jl((g, p) => a(g) - a(p)),
-                l = e.as || oN,
+                s = e.field,
+                a = e.step || KV(n, s),
+                o = $l((g, p) => s(g) - s(p)),
+                l = e.as || vN,
                 u = i.length;
             let c = 1 / 0,
                 f = -1 / 0,
                 h = 0,
                 d;
             for (; h < u; ++h) {
                 const g = i[h].sort(o);
                 d = -1;
-                for (const p of GP(g, s, r, a)) p < c && (c = p), p > f && (f = p), g[++d][l] = p
+                for (const p of ZD(g, a, r, s)) p < c && (c = p), p > f && (f = p), g[++d][l] = p
             }
             return this.value = {
                 start: c,
                 stop: f,
-                step: s
+                step: a
             }, t.reflow(!0).modifies(l)
         }
     });
 
-    function lN(e) {
-        rt.call(this, null, UK, e), this.modified(!0)
+    function bN(e) {
+        it.call(this, null, JV, e), this.modified(!0)
     }
-    Q(lN, rt);
+    ee(bN, it);
 
-    function UK(e) {
+    function JV(e) {
         const t = e.expr;
-        return this.value && !e.modified("expr") ? this.value : ci(n => t(n, e), yn(t), wt(t))
+        return this.value && !e.modified("expr") ? this.value : li(n => t(n, e), pn(t), bt(t))
     }
 
-    function Fw(e) {
+    function Q_(e) {
         L.call(this, [void 0, void 0], e)
     }
-    Fw.Definition = {
+    Q_.Definition = {
         type: "Extent",
         metadata: {},
         params: [{
             name: "field",
             type: "field",
             required: !0
         }]
     };
-    Q(Fw, L, {
+    ee(Q_, L, {
         transform(e, t) {
             const n = this.value,
                 i = e.field,
                 r = t.changed() || t.modified(i.fields) || e.modified("field");
-            let a = n[0],
-                s = n[1];
-            if ((r || a == null) && (a = 1 / 0, s = -1 / 0), t.visit(r ? t.SOURCE : t.ADD, o => {
-                    const l = gn(i(o));
-                    l != null && (l < a && (a = l), l > s && (s = l))
-                }), !Number.isFinite(a) || !Number.isFinite(s)) {
-                let o = wt(i);
-                o && (o = ` for field "${o}"`), t.dataflow.warn(`Infinite extent${o}: [${a}, ${s}]`), a = s = void 0
+            let s = n[0],
+                a = n[1];
+            if ((r || s == null) && (s = 1 / 0, a = -1 / 0), t.visit(r ? t.SOURCE : t.ADD, o => {
+                    const l = hn(i(o));
+                    l != null && (l < s && (s = l), l > a && (a = l))
+                }), !Number.isFinite(s) || !Number.isFinite(a)) {
+                let o = bt(i);
+                o && (o = ` for field "${o}"`), t.dataflow.warn(`Infinite extent${o}: [${s}, ${a}]`), s = a = void 0
             }
-            this.value = [a, s]
+            this.value = [s, a]
         }
     });
 
-    function Dw(e, t) {
-        rt.call(this, e), this.parent = t, this.count = 0
+    function Z_(e, t) {
+        it.call(this, e), this.parent = t, this.count = 0
     }
-    Q(Dw, rt, {
+    ee(Z_, it, {
         connect(e) {
             return this.detachSubflow = e.detachSubflow, this.targets().add(e), e.source = this
         },
         add(e) {
             this.count += 1, this.value.add.push(e)
         },
         rem(e) {
@@ -20831,30 +20851,30 @@
             this.value.init(e, e.NO_SOURCE)
         },
         evaluate() {
             return this.value
         }
     });
 
-    function s1(e) {
-        L.call(this, {}, e), this._keys = Dc();
+    function jm(e) {
+        L.call(this, {}, e), this._keys = _c();
         const t = this._targets = [];
         t.active = 0, t.forEach = n => {
             for (let i = 0, r = t.active; i < r; ++i) n(t[i], i, t)
         }
     }
-    Q(s1, L, {
+    ee(jm, L, {
         activate(e) {
             this._targets[this._targets.active++] = e
         },
         subflow(e, t, n, i) {
             const r = this.value;
-            let a = pe(r, e) && r[e],
-                s, o;
-            return a ? a.value.stamp < n.stamp && (a.init(n), this.activate(a)) : (o = i || (o = this._group[e]) && o.tuple, s = n.dataflow, a = new Dw(n.fork(n.NO_SOURCE), this), s.add(a).connect(t(s, e, o)), r[e] = a, this.activate(a)), a
+            let s = me(r, e) && r[e],
+                a, o;
+            return s ? s.value.stamp < n.stamp && (s.init(n), this.activate(s)) : (o = i || (o = this._group[e]) && o.tuple, a = n.dataflow, s = new Z_(n.fork(n.NO_SOURCE), this), a.add(s).connect(t(a, e, o)), r[e] = s, this.activate(s)), s
         },
         clean() {
             const e = this.value;
             let t = 0;
             for (const n in e)
                 if (e[n].count === 0) {
                     const i = e[n].detachSubflow;
@@ -20873,96 +20893,96 @@
             for (; r < n && t[r] != null; ++r) t[r] = null;
             t.active = i
         },
         transform(e, t) {
             const n = t.dataflow,
                 i = e.key,
                 r = e.subflow,
-                a = this._keys,
-                s = e.modified("key"),
+                s = this._keys,
+                a = e.modified("key"),
                 o = l => this.subflow(l, r, t);
             return this._group = e.group || {}, this.initTargets(), t.visit(t.REM, l => {
-                const u = de(l),
-                    c = a.get(u);
-                c !== void 0 && (a.delete(u), o(c).rem(l))
+                const u = ge(l),
+                    c = s.get(u);
+                c !== void 0 && (s.delete(u), o(c).rem(l))
             }), t.visit(t.ADD, l => {
                 const u = i(l);
-                a.set(de(l), u), o(u).add(l)
-            }), s || t.modified(i.fields) ? t.visit(t.MOD, l => {
-                const u = de(l),
-                    c = a.get(u),
+                s.set(ge(l), u), o(u).add(l)
+            }), a || t.modified(i.fields) ? t.visit(t.MOD, l => {
+                const u = ge(l),
+                    c = s.get(u),
                     f = i(l);
-                c === f ? o(f).mod(l) : (a.set(u, f), o(c).rem(l), o(f).add(l))
+                c === f ? o(f).mod(l) : (s.set(u, f), o(c).rem(l), o(f).add(l))
             }) : t.changed(t.MOD) && t.visit(t.MOD, l => {
-                o(a.get(de(l))).mod(l)
-            }), s && t.visit(t.REFLOW, l => {
-                const u = de(l),
-                    c = a.get(u),
+                o(s.get(ge(l))).mod(l)
+            }), a && t.visit(t.REFLOW, l => {
+                const u = ge(l),
+                    c = s.get(u),
                     f = i(l);
-                c !== f && (a.set(u, f), o(c).rem(l), o(f).add(l))
+                c !== f && (s.set(u, f), o(c).rem(l), o(f).add(l))
             }), t.clean() ? n.runAfter(() => {
-                this.clean(), a.clean()
-            }) : a.empty > n.cleanThreshold && n.runAfter(a.clean), t
+                this.clean(), s.clean()
+            }) : s.empty > n.cleanThreshold && n.runAfter(s.clean), t
         }
     });
 
-    function uN(e) {
-        rt.call(this, null, qK, e)
+    function xN(e) {
+        it.call(this, null, QV, e)
     }
-    Q(uN, rt);
+    ee(xN, it);
 
-    function qK(e) {
-        return this.value && !e.modified() ? this.value : q(e.name) ? ie(e.name).map(t => ri(t)) : ri(e.name, e.as)
+    function QV(e) {
+        return this.value && !e.modified() ? this.value : W(e.name) ? se(e.name).map(t => ni(t)) : ni(e.name, e.as)
     }
 
-    function Rw(e) {
-        L.call(this, Dc(), e)
+    function ew(e) {
+        L.call(this, _c(), e)
     }
-    Rw.Definition = {
+    ew.Definition = {
         type: "Filter",
         metadata: {
             changes: !0
         },
         params: [{
             name: "expr",
             type: "expr",
             required: !0
         }]
     };
-    Q(Rw, L, {
+    ee(ew, L, {
         transform(e, t) {
             const n = t.dataflow,
                 i = this.value,
                 r = t.fork(),
-                a = r.add,
-                s = r.rem,
+                s = r.add,
+                a = r.rem,
                 o = r.mod,
                 l = e.expr;
             let u = !0;
             t.visit(t.REM, f => {
-                const h = de(f);
-                i.has(h) ? i.delete(h) : s.push(f)
+                const h = ge(f);
+                i.has(h) ? i.delete(h) : a.push(f)
             }), t.visit(t.ADD, f => {
-                l(f, e) ? a.push(f) : i.set(de(f), 1)
+                l(f, e) ? s.push(f) : i.set(ge(f), 1)
             });
 
             function c(f) {
-                const h = de(f),
+                const h = ge(f),
                     d = l(f, e),
                     g = i.get(h);
-                d && g ? (i.delete(h), a.push(f)) : !d && !g ? (i.set(h, 1), s.push(f)) : u && d && !g && o.push(f)
+                d && g ? (i.delete(h), s.push(f)) : !d && !g ? (i.set(h, 1), a.push(f)) : u && d && !g && o.push(f)
             }
             return t.visit(t.MOD, c), e.modified() && (u = !1, t.visit(t.REFLOW, c)), i.empty > n.cleanThreshold && n.runAfter(i.clean), r
         }
     });
 
-    function Pw(e) {
+    function tw(e) {
         L.call(this, [], e)
     }
-    Pw.Definition = {
+    tw.Definition = {
         type: "Flatten",
         metadata: {
             generates: !0
         },
         params: [{
             name: "fields",
             type: "field",
@@ -20973,38 +20993,38 @@
             type: "string"
         }, {
             name: "as",
             type: "string",
             array: !0
         }]
     };
-    Q(Pw, L, {
+    ee(tw, L, {
         transform(e, t) {
             const n = t.fork(t.NO_SOURCE),
                 i = e.fields,
-                r = sN(i, e.as || []),
-                a = e.index || null,
-                s = r.length;
+                r = yN(i, e.as || []),
+                s = e.index || null,
+                a = r.length;
             return n.rem = this.value, t.visit(t.SOURCE, o => {
                 const l = i.map(g => g(o)),
                     u = l.reduce((g, p) => Math.max(g, p.length), 0);
                 let c = 0,
                     f, h, d;
                 for (; c < u; ++c) {
-                    for (h = aw(o), f = 0; f < s; ++f) h[r[f]] = (d = l[f][c]) == null ? null : d;
-                    a && (h[a] = c), n.add.push(h)
+                    for (h = E_(o), f = 0; f < a; ++f) h[r[f]] = (d = l[f][c]) == null ? null : d;
+                    s && (h[s] = c), n.add.push(h)
                 }
-            }), this.value = n.source = n.add, a && n.modifies(a), n.modifies(r)
+            }), this.value = n.source = n.add, s && n.modifies(s), n.modifies(r)
         }
     });
 
-    function Nw(e) {
+    function nw(e) {
         L.call(this, [], e)
     }
-    Nw.Definition = {
+    nw.Definition = {
         type: "Fold",
         metadata: {
             generates: !0
         },
         params: [{
             name: "fields",
             type: "field",
@@ -21014,33 +21034,33 @@
             name: "as",
             type: "string",
             array: !0,
             length: 2,
             default: ["key", "value"]
         }]
     };
-    Q(Nw, L, {
+    ee(nw, L, {
         transform(e, t) {
             const n = t.fork(t.NO_SOURCE),
                 i = e.fields,
-                r = i.map(wt),
-                a = e.as || ["key", "value"],
-                s = a[0],
-                o = a[1],
+                r = i.map(bt),
+                s = e.as || ["key", "value"],
+                a = s[0],
+                o = s[1],
                 l = i.length;
             return n.rem = this.value, t.visit(t.SOURCE, u => {
-                for (let c = 0, f; c < l; ++c) f = aw(u), f[s] = r[c], f[o] = i[c](u), n.add.push(f)
-            }), this.value = n.source = n.add, n.modifies(a)
+                for (let c = 0, f; c < l; ++c) f = E_(u), f[a] = r[c], f[o] = i[c](u), n.add.push(f)
+            }), this.value = n.source = n.add, n.modifies(s)
         }
     });
 
-    function Lw(e) {
+    function iw(e) {
         L.call(this, null, e)
     }
-    Lw.Definition = {
+    iw.Definition = {
         type: "Formula",
         metadata: {
             modifies: !0
         },
         params: [{
             name: "expr",
             type: "expr",
@@ -21050,54 +21070,54 @@
             type: "string",
             required: !0
         }, {
             name: "initonly",
             type: "boolean"
         }]
     };
-    Q(Lw, L, {
+    ee(iw, L, {
         transform(e, t) {
             const n = e.expr,
                 i = e.as,
                 r = e.modified(),
-                a = e.initonly ? t.ADD : r ? t.SOURCE : t.modified(n.fields) || t.modified(i) ? t.ADD_MOD : t.ADD;
-            return r && (t = t.materialize().reflow(!0)), e.initonly || t.modifies(i), t.visit(a, s => s[i] = n(s, e))
+                s = e.initonly ? t.ADD : r ? t.SOURCE : t.modified(n.fields) || t.modified(i) ? t.ADD_MOD : t.ADD;
+            return r && (t = t.materialize().reflow(!0)), e.initonly || t.modifies(i), t.visit(s, a => a[i] = n(a, e))
         }
     });
 
-    function cN(e) {
+    function _N(e) {
         L.call(this, [], e)
     }
-    Q(cN, L, {
+    ee(_N, L, {
         transform(e, t) {
             const n = t.fork(t.ALL),
                 i = e.generator;
             let r = this.value,
-                a = e.size - r.length,
-                s, o, l;
-            if (a > 0) {
-                for (s = []; --a >= 0;) s.push(l = He(i(e))), r.push(l);
-                n.add = n.add.length ? n.materialize(n.ADD).add.concat(s) : s
-            } else o = r.slice(0, -a), n.rem = n.rem.length ? n.materialize(n.REM).rem.concat(o) : o, r = r.slice(-a);
+                s = e.size - r.length,
+                a, o, l;
+            if (s > 0) {
+                for (a = []; --s >= 0;) a.push(l = He(i(e))), r.push(l);
+                n.add = n.add.length ? n.materialize(n.ADD).add.concat(a) : a
+            } else o = r.slice(0, -s), n.rem = n.rem.length ? n.materialize(n.REM).rem.concat(o) : o, r = r.slice(-s);
             return n.source = this.value = r, n
         }
     });
-    const Fg = {
+    const yg = {
             value: "value",
-            median: AF,
-            mean: _G,
-            min: Nb,
-            max: el
+            median: zO,
+            mean: $j,
+            min: cb,
+            max: jo
         },
-        WK = [];
+        ZV = [];
 
-    function Iw(e) {
+    function rw(e) {
         L.call(this, [], e)
     }
-    Iw.Definition = {
+    rw.Definition = {
         type: "Impute",
         metadata: {
             changes: !0
         },
         params: [{
             name: "field",
             type: "field",
@@ -21120,64 +21140,64 @@
             values: ["value", "mean", "median", "max", "min"]
         }, {
             name: "value",
             default: 0
         }]
     };
 
-    function HK(e) {
-        var t = e.method || Fg.value,
+    function eK(e) {
+        var t = e.method || yg.value,
             n;
-        if (Fg[t] == null) G("Unrecognized imputation method: " + t);
-        else return t === Fg.value ? (n = e.value !== void 0 ? e.value : 0, () => n) : Fg[t]
+        if (yg[t] == null) U("Unrecognized imputation method: " + t);
+        else return t === yg.value ? (n = e.value !== void 0 ? e.value : 0, () => n) : yg[t]
     }
 
-    function YK(e) {
+    function tK(e) {
         const t = e.field;
         return n => n ? t(n) : NaN
     }
-    Q(Iw, L, {
+    ee(rw, L, {
         transform(e, t) {
             var n = t.fork(t.ALL),
-                i = HK(e),
-                r = YK(e),
-                a = wt(e.field),
-                s = wt(e.key),
-                o = (e.groupby || []).map(wt),
-                l = XK(t.source, e.groupby, e.key, e.keyvals),
+                i = eK(e),
+                r = tK(e),
+                s = bt(e.field),
+                a = bt(e.key),
+                o = (e.groupby || []).map(bt),
+                l = nK(t.source, e.groupby, e.key, e.keyvals),
                 u = [],
                 c = this.value,
                 f = l.domain.length,
                 h, d, g, p, m, y, v, b, x, _;
             for (m = 0, b = l.length; m < b; ++m)
                 for (h = l[m], g = h.values, d = NaN, v = 0; v < f; ++v)
                     if (h[v] == null) {
                         for (p = l.domain[v], _ = {
                                 _impute: !0
                             }, y = 0, x = g.length; y < x; ++y) _[o[y]] = g[y];
-                        _[s] = p, _[a] = Number.isNaN(d) ? d = i(h, r) : d, u.push(He(_))
+                        _[a] = p, _[s] = Number.isNaN(d) ? d = i(h, r) : d, u.push(He(_))
                     } return u.length && (n.add = n.materialize(n.ADD).add.concat(u)), c.length && (n.rem = n.materialize(n.REM).rem.concat(c)), this.value = u, n
         }
     });
 
-    function XK(e, t, n, i) {
+    function nK(e, t, n, i) {
         var r = y => y(m),
-            a = [],
-            s = i ? i.slice() : [],
+            s = [],
+            a = i ? i.slice() : [],
             o = {},
             l = {},
             u, c, f, h, d, g, p, m;
-        for (s.forEach((y, v) => o[y] = v + 1), h = 0, p = e.length; h < p; ++h) m = e[h], g = n(m), d = o[g] || (o[g] = s.push(g)), c = (u = t ? t.map(r) : WK) + "", (f = l[c]) || (f = l[c] = [], a.push(f), f.values = u), f[d - 1] = m;
-        return a.domain = s, a
+        for (a.forEach((y, v) => o[y] = v + 1), h = 0, p = e.length; h < p; ++h) m = e[h], g = n(m), d = o[g] || (o[g] = a.push(g)), c = (u = t ? t.map(r) : ZV) + "", (f = l[c]) || (f = l[c] = [], s.push(f), f.values = u), f[d - 1] = m;
+        return s.domain = a, s
     }
 
-    function jw(e) {
-        Us.call(this, e)
+    function sw(e) {
+        Ra.call(this, e)
     }
-    jw.Definition = {
+    sw.Definition = {
         type: "JoinAggregate",
         metadata: {
             modifies: !0
         },
         params: [{
             name: "groupby",
             type: "field",
@@ -21187,48 +21207,48 @@
             type: "field",
             null: !0,
             array: !0
         }, {
             name: "ops",
             type: "enum",
             array: !0,
-            values: _d
+            values: ud
         }, {
             name: "as",
             type: "string",
             null: !0,
             array: !0
         }, {
             name: "key",
             type: "field"
         }]
     };
-    Q(jw, Us, {
+    ee(sw, Ra, {
         transform(e, t) {
             const n = this,
                 i = e.modified();
             let r;
-            return n.value && (i || t.modified(n._inputs, !0)) ? (r = n.value = i ? n.init(e) : {}, t.visit(t.SOURCE, a => n.add(a))) : (r = n.value = n.value || this.init(e), t.visit(t.REM, a => n.rem(a)), t.visit(t.ADD, a => n.add(a))), n.changes(), t.visit(t.SOURCE, a => {
-                ke(a, r[n.cellkey(a)].tuple)
+            return n.value && (i || t.modified(n._inputs, !0)) ? (r = n.value = i ? n.init(e) : {}, t.visit(t.SOURCE, s => n.add(s))) : (r = n.value = n.value || this.init(e), t.visit(t.REM, s => n.rem(s)), t.visit(t.ADD, s => n.add(s))), n.changes(), t.visit(t.SOURCE, s => {
+                Ae(s, r[n.cellkey(s)].tuple)
             }), t.reflow(i).modifies(this._outputs)
         },
         changes() {
             const e = this._adds,
                 t = this._mods;
             let n, i;
             for (n = 0, i = this._alen; n < i; ++n) this.celltuple(e[n]), e[n] = null;
             for (n = 0, i = this._mlen; n < i; ++n) this.celltuple(t[n]), t[n] = null;
             this._alen = this._mlen = 0
         }
     });
 
-    function zw(e) {
+    function aw(e) {
         L.call(this, null, e)
     }
-    zw.Definition = {
+    aw.Definition = {
         type: "KDE",
         metadata: {
             generates: !0
         },
         params: [{
             name: "groupby",
             type: "field",
@@ -21273,78 +21293,78 @@
         }, {
             name: "as",
             type: "string",
             array: !0,
             default: ["value", "density"]
         }]
     };
-    Q(zw, L, {
+    ee(aw, L, {
         transform(e, t) {
             const n = t.fork(t.NO_SOURCE | t.NO_FIELDS);
             if (!this.value || t.changed() || e.modified()) {
                 const i = t.materialize(t.SOURCE).source,
-                    r = $w(i, e.groupby, e.field),
-                    a = (e.groupby || []).map(wt),
-                    s = e.bandwidth,
+                    r = K_(i, e.groupby, e.field),
+                    s = (e.groupby || []).map(bt),
+                    a = e.bandwidth,
                     o = e.cumulative ? "cdf" : "pdf",
                     l = e.as || ["value", "density"],
                     u = [];
                 let c = e.extent,
                     f = e.steps || e.minsteps || 25,
                     h = e.steps || e.maxsteps || 200;
-                o !== "pdf" && o !== "cdf" && G("Invalid density method: " + o), e.resolve === "shared" && (c || (c = Zr(i, e.field)), f = h = e.steps || h), r.forEach(d => {
-                    const g = dw(d, s)[o],
+                o !== "pdf" && o !== "cdf" && U("Invalid density method: " + o), e.resolve === "shared" && (c || (c = Hr(i, e.field)), f = h = e.steps || h), r.forEach(d => {
+                    const g = F_(d, a)[o],
                         p = e.counts ? d.length : 1,
-                        m = c || Zr(d);
-                    a1(g, m, f, h).forEach(y => {
+                        m = c || Hr(d);
+                    Bm(g, m, f, h).forEach(y => {
                         const v = {};
-                        for (let b = 0; b < a.length; ++b) v[a[b]] = d.dims[b];
+                        for (let b = 0; b < s.length; ++b) v[s[b]] = d.dims[b];
                         v[l[0]] = y[0], v[l[1]] = y[1] * p, u.push(He(v))
                     })
                 }), this.value && (n.rem = this.value), this.value = n.add = n.source = u
             }
             return n
         }
     });
 
-    function fN(e) {
-        rt.call(this, null, VK, e)
+    function wN(e) {
+        it.call(this, null, iK, e)
     }
-    Q(fN, rt);
+    ee(wN, it);
 
-    function VK(e) {
-        return this.value && !e.modified() ? this.value : X_(e.fields, e.flat)
+    function iK(e) {
+        return this.value && !e.modified() ? this.value : d_(e.fields, e.flat)
     }
 
-    function hN(e) {
+    function SN(e) {
         L.call(this, [], e), this._pending = null
     }
-    Q(hN, L, {
+    ee(SN, L, {
         transform(e, t) {
             const n = t.dataflow;
-            return this._pending ? vv(this, t, this._pending) : KK(e) ? t.StopPropagation : e.values ? vv(this, t, n.parse(e.values, e.format)) : e.async ? {
-                async: n.request(e.url, e.format).then(r => (this._pending = ie(r.data), a => a.touch(this)))
-            } : n.request(e.url, e.format).then(i => vv(this, t, ie(i.data)))
+            return this._pending ? Ky(this, t, this._pending) : rK(e) ? t.StopPropagation : e.values ? Ky(this, t, n.parse(e.values, e.format)) : e.async ? {
+                async: n.request(e.url, e.format).then(r => (this._pending = se(r.data), s => s.touch(this)))
+            } : n.request(e.url, e.format).then(i => Ky(this, t, se(i.data)))
         }
     });
 
-    function KK(e) {
+    function rK(e) {
         return e.modified("async") && !(e.modified("values") || e.modified("url") || e.modified("format"))
     }
 
-    function vv(e, t, n) {
+    function Ky(e, t, n) {
         n.forEach(He);
         const i = t.fork(t.NO_FIELDS & t.NO_SOURCE);
         return i.rem = e.value, e.value = i.source = i.add = n, e._pending = null, i.rem.length && i.clean(!0), i
     }
 
-    function Bw(e) {
+    function ow(e) {
         L.call(this, {}, e)
     }
-    Bw.Definition = {
+    ow.Definition = {
         type: "Lookup",
         metadata: {
             modifies: !0
         },
         params: [{
             name: "index",
             type: "index",
@@ -21371,76 +21391,76 @@
             type: "string",
             array: !0
         }, {
             name: "default",
             default: null
         }]
     };
-    Q(Bw, L, {
+    ee(ow, L, {
         transform(e, t) {
             const n = e.fields,
                 i = e.index,
                 r = e.values,
-                a = e.default == null ? null : e.default,
-                s = e.modified(),
+                s = e.default == null ? null : e.default,
+                a = e.modified(),
                 o = n.length;
-            let l = s ? t.SOURCE : t.ADD,
+            let l = a ? t.SOURCE : t.ADD,
                 u = t,
                 c = e.as,
                 f, h, d;
-            return r ? (h = r.length, o > 1 && !c && G('Multi-field lookup requires explicit "as" parameter.'), c && c.length !== o * h && G('The "as" parameter has too few output field names.'), c = c || r.map(wt), f = function(g) {
+            return r ? (h = r.length, o > 1 && !c && U('Multi-field lookup requires explicit "as" parameter.'), c && c.length !== o * h && U('The "as" parameter has too few output field names.'), c = c || r.map(bt), f = function(g) {
                 for (var p = 0, m = 0, y, v; p < o; ++p)
                     if (v = i.get(n[p](g)), v == null)
-                        for (y = 0; y < h; ++y, ++m) g[c[m]] = a;
+                        for (y = 0; y < h; ++y, ++m) g[c[m]] = s;
                     else
                         for (y = 0; y < h; ++y, ++m) g[c[m]] = r[y](v)
-            }) : (c || G("Missing output field names."), f = function(g) {
-                for (var p = 0, m; p < o; ++p) m = i.get(n[p](g)), g[c[p]] = m ?? a
-            }), s ? u = t.reflow(!0) : (d = n.some(g => t.modified(g.fields)), l |= d ? t.MOD : 0), t.visit(l, f), u.modifies(c)
+            }) : (c || U("Missing output field names."), f = function(g) {
+                for (var p = 0, m; p < o; ++p) m = i.get(n[p](g)), g[c[p]] = m ?? s
+            }), a ? u = t.reflow(!0) : (d = n.some(g => t.modified(g.fields)), l |= d ? t.MOD : 0), t.visit(l, f), u.modifies(c)
         }
     });
 
-    function dN(e) {
-        rt.call(this, null, JK, e)
+    function EN(e) {
+        it.call(this, null, sK, e)
     }
-    Q(dN, rt);
+    ee(EN, it);
 
-    function JK(e) {
+    function sK(e) {
         if (this.value && !e.modified()) return this.value;
         const t = e.extents,
             n = t.length;
         let i = 1 / 0,
             r = -1 / 0,
-            a, s;
-        for (a = 0; a < n; ++a) s = t[a], s[0] < i && (i = s[0]), s[1] > r && (r = s[1]);
+            s, a;
+        for (s = 0; s < n; ++s) a = t[s], a[0] < i && (i = a[0]), a[1] > r && (r = a[1]);
         return [i, r]
     }
 
-    function gN(e) {
-        rt.call(this, null, QK, e)
+    function CN(e) {
+        it.call(this, null, aK, e)
     }
-    Q(gN, rt);
+    ee(CN, it);
 
-    function QK(e) {
+    function aK(e) {
         return this.value && !e.modified() ? this.value : e.values.reduce((t, n) => t.concat(n), [])
     }
 
-    function pN(e) {
+    function kN(e) {
         L.call(this, null, e)
     }
-    Q(pN, L, {
+    ee(kN, L, {
         transform(e, t) {
             return this.modified(e.modified()), this.value = e, t.fork(t.NO_SOURCE | t.NO_FIELDS)
         }
     });
 
-    function Gw(e) {
-        Us.call(this, e)
+    function lw(e) {
+        Ra.call(this, e)
     }
-    Gw.Definition = {
+    lw.Definition = {
         type: "Pivot",
         metadata: {
             generates: !0,
             changes: !0
         },
         params: [{
             name: "groupby",
@@ -21453,86 +21473,86 @@
         }, {
             name: "value",
             type: "field",
             required: !0
         }, {
             name: "op",
             type: "enum",
-            values: _d,
+            values: ud,
             default: "sum"
         }, {
             name: "limit",
             type: "number",
             default: 0
         }, {
             name: "key",
             type: "field"
         }]
     };
-    Q(Gw, Us, {
-        _transform: Us.prototype.transform,
+    ee(lw, Ra, {
+        _transform: Ra.prototype.transform,
         transform(e, t) {
-            return this._transform(ZK(e, t), t)
+            return this._transform(oK(e, t), t)
         }
     });
 
-    function ZK(e, t) {
+    function oK(e, t) {
         const n = e.field,
             i = e.value,
             r = (e.op === "count" ? "__count__" : e.op) || "sum",
-            a = yn(n).concat(yn(i)),
-            s = tJ(n, e.limit || 0, t);
+            s = pn(n).concat(pn(i)),
+            a = uK(n, e.limit || 0, t);
         return t.changed() && e.set("__pivot__", null, null, !0), {
             key: e.key,
             groupby: e.groupby,
-            ops: s.map(() => r),
-            fields: s.map(o => eJ(o, n, i, a)),
-            as: s.map(o => o + ""),
+            ops: a.map(() => r),
+            fields: a.map(o => lK(o, n, i, s)),
+            as: a.map(o => o + ""),
             modified: e.modified.bind(e)
         }
     }
 
-    function eJ(e, t, n, i) {
-        return ci(r => t(r) === e ? n(r) : NaN, i, e + "")
+    function lK(e, t, n, i) {
+        return li(r => t(r) === e ? n(r) : NaN, i, e + "")
     }
 
-    function tJ(e, t, n) {
+    function uK(e, t, n) {
         const i = {},
             r = [];
-        return n.visit(n.SOURCE, a => {
-            const s = e(a);
-            i[s] || (i[s] = 1, r.push(s))
-        }), r.sort(Ym), t ? r.slice(0, t) : r
+        return n.visit(n.SOURCE, s => {
+            const a = e(s);
+            i[a] || (i[a] = 1, r.push(a))
+        }), r.sort($m), t ? r.slice(0, t) : r
     }
 
-    function mN(e) {
-        s1.call(this, e)
+    function AN(e) {
+        jm.call(this, e)
     }
-    Q(mN, s1, {
+    ee(AN, jm, {
         transform(e, t) {
             const n = e.subflow,
                 i = e.field,
-                r = a => this.subflow(de(a), n, t, a);
-            return (e.modified("field") || i && t.modified(yn(i))) && G("PreFacet does not support field modification."), this.initTargets(), i ? (t.visit(t.MOD, a => {
-                const s = r(a);
-                i(a).forEach(o => s.mod(o))
-            }), t.visit(t.ADD, a => {
-                const s = r(a);
-                i(a).forEach(o => s.add(He(o)))
-            }), t.visit(t.REM, a => {
-                const s = r(a);
-                i(a).forEach(o => s.rem(o))
-            })) : (t.visit(t.MOD, a => r(a).mod(a)), t.visit(t.ADD, a => r(a).add(a)), t.visit(t.REM, a => r(a).rem(a))), t.clean() && t.runAfter(() => this.clean()), t
+                r = s => this.subflow(ge(s), n, t, s);
+            return (e.modified("field") || i && t.modified(pn(i))) && U("PreFacet does not support field modification."), this.initTargets(), i ? (t.visit(t.MOD, s => {
+                const a = r(s);
+                i(s).forEach(o => a.mod(o))
+            }), t.visit(t.ADD, s => {
+                const a = r(s);
+                i(s).forEach(o => a.add(He(o)))
+            }), t.visit(t.REM, s => {
+                const a = r(s);
+                i(s).forEach(o => a.rem(o))
+            })) : (t.visit(t.MOD, s => r(s).mod(s)), t.visit(t.ADD, s => r(s).add(s)), t.visit(t.REM, s => r(s).rem(s))), t.clean() && t.runAfter(() => this.clean()), t
         }
     });
 
-    function Uw(e) {
+    function uw(e) {
         L.call(this, null, e)
     }
-    Uw.Definition = {
+    uw.Definition = {
         type: "Project",
         metadata: {
             generates: !0,
             changes: !0
         },
         params: [{
             name: "fields",
@@ -21541,51 +21561,51 @@
         }, {
             name: "as",
             type: "string",
             null: !0,
             array: !0
         }]
     };
-    Q(Uw, L, {
+    ee(uw, L, {
         transform(e, t) {
             const n = t.fork(t.NO_SOURCE),
                 i = e.fields,
-                r = sN(e.fields, e.as || []),
-                a = i ? (o, l) => nJ(o, l, i, r) : Qm;
-            let s;
-            return this.value ? s = this.value : (t = t.addAll(), s = this.value = {}), t.visit(t.REM, o => {
-                const l = de(o);
-                n.rem.push(s[l]), s[l] = null
+                r = yN(e.fields, e.as || []),
+                s = i ? (o, l) => cK(o, l, i, r) : Rm;
+            let a;
+            return this.value ? a = this.value : (t = t.addAll(), a = this.value = {}), t.visit(t.REM, o => {
+                const l = ge(o);
+                n.rem.push(a[l]), a[l] = null
             }), t.visit(t.ADD, o => {
-                const l = a(o, He({}));
-                s[de(o)] = l, n.add.push(l)
+                const l = s(o, He({}));
+                a[ge(o)] = l, n.add.push(l)
             }), t.visit(t.MOD, o => {
-                n.mod.push(a(o, s[de(o)]))
+                n.mod.push(s(o, a[ge(o)]))
             }), n
         }
     });
 
-    function nJ(e, t, n, i) {
-        for (let r = 0, a = n.length; r < a; ++r) t[i[r]] = n[r](e);
+    function cK(e, t, n, i) {
+        for (let r = 0, s = n.length; r < s; ++r) t[i[r]] = n[r](e);
         return t
     }
 
-    function yN(e) {
+    function $N(e) {
         L.call(this, null, e)
     }
-    Q(yN, L, {
+    ee($N, L, {
         transform(e, t) {
             return this.value = e.value, e.modified("value") ? t.fork(t.NO_SOURCE | t.NO_FIELDS) : t.StopPropagation
         }
     });
 
-    function qw(e) {
+    function cw(e) {
         L.call(this, null, e)
     }
-    qw.Definition = {
+    cw.Definition = {
         type: "Quantile",
         metadata: {
             generates: !0,
             changes: !0
         },
         params: [{
             name: "groupby",
@@ -21606,104 +21626,104 @@
         }, {
             name: "as",
             type: "string",
             array: !0,
             default: ["prob", "value"]
         }]
     };
-    const iJ = 1e-14;
-    Q(qw, L, {
+    const fK = 1e-14;
+    ee(cw, L, {
         transform(e, t) {
             const n = t.fork(t.NO_SOURCE | t.NO_FIELDS),
                 i = e.as || ["prob", "value"];
             if (this.value && !e.modified() && !t.changed()) return n.source = this.value, n;
             const r = t.materialize(t.SOURCE).source,
-                a = $w(r, e.groupby, e.field),
-                s = (e.groupby || []).map(wt),
+                s = K_(r, e.groupby, e.field),
+                a = (e.groupby || []).map(bt),
                 o = [],
                 l = e.step || .01,
-                u = e.probs || mi(l / 2, 1 - iJ, l),
+                u = e.probs || gi(l / 2, 1 - fK, l),
                 c = u.length;
-            return a.forEach(f => {
-                const h = lw(f, u);
+            return s.forEach(f => {
+                const h = A_(f, u);
                 for (let d = 0; d < c; ++d) {
                     const g = {};
-                    for (let p = 0; p < s.length; ++p) g[s[p]] = f.dims[p];
+                    for (let p = 0; p < a.length; ++p) g[a[p]] = f.dims[p];
                     g[i[0]] = u[d], g[i[1]] = h[d], o.push(He(g))
                 }
             }), this.value && (n.rem = this.value), this.value = n.add = n.source = o, n
         }
     });
 
-    function vN(e) {
+    function TN(e) {
         L.call(this, null, e)
     }
-    Q(vN, L, {
+    ee(TN, L, {
         transform(e, t) {
             let n, i;
             return this.value ? i = this.value : (n = t = t.addAll(), i = this.value = {}), e.derive && (n = t.fork(t.NO_SOURCE), t.visit(t.REM, r => {
-                const a = de(r);
-                n.rem.push(i[a]), i[a] = null
+                const s = ge(r);
+                n.rem.push(i[s]), i[s] = null
             }), t.visit(t.ADD, r => {
-                const a = aw(r);
-                i[de(r)] = a, n.add.push(a)
+                const s = E_(r);
+                i[ge(r)] = s, n.add.push(s)
             }), t.visit(t.MOD, r => {
-                const a = i[de(r)];
-                for (const s in r) a[s] = r[s], n.modifies(s);
-                n.mod.push(a)
+                const s = i[ge(r)];
+                for (const a in r) s[a] = r[a], n.modifies(a);
+                n.mod.push(s)
             })), n
         }
     });
 
-    function Ww(e) {
+    function fw(e) {
         L.call(this, [], e), this.count = 0
     }
-    Ww.Definition = {
+    fw.Definition = {
         type: "Sample",
         metadata: {},
         params: [{
             name: "size",
             type: "number",
             default: 1e3
         }]
     };
-    Q(Ww, L, {
+    ee(fw, L, {
         transform(e, t) {
             const n = t.fork(t.NO_SOURCE),
                 i = e.modified("size"),
                 r = e.size,
-                a = this.value.reduce((c, f) => (c[de(f)] = 1, c), {});
-            let s = this.value,
+                s = this.value.reduce((c, f) => (c[ge(f)] = 1, c), {});
+            let a = this.value,
                 o = this.count,
                 l = 0;
 
             function u(c) {
                 let f, h;
-                s.length < r ? s.push(c) : (h = ~~((o + 1) * zi()), h < s.length && h >= l && (f = s[h], a[de(f)] && n.rem.push(f), s[h] = c)), ++o
+                a.length < r ? a.push(c) : (h = ~~((o + 1) * Ni()), h < a.length && h >= l && (f = a[h], s[ge(f)] && n.rem.push(f), a[h] = c)), ++o
             }
             if (t.rem.length && (t.visit(t.REM, c => {
-                    const f = de(c);
-                    a[f] && (a[f] = -1, n.rem.push(c)), --o
-                }), s = s.filter(c => a[de(c)] !== -1)), (t.rem.length || i) && s.length < r && t.source && (l = o = s.length, t.visit(t.SOURCE, c => {
-                    a[de(c)] || u(c)
-                }), l = -1), i && s.length > r) {
-                const c = s.length - r;
-                for (let f = 0; f < c; ++f) a[de(s[f])] = -1, n.rem.push(s[f]);
-                s = s.slice(c)
+                    const f = ge(c);
+                    s[f] && (s[f] = -1, n.rem.push(c)), --o
+                }), a = a.filter(c => s[ge(c)] !== -1)), (t.rem.length || i) && a.length < r && t.source && (l = o = a.length, t.visit(t.SOURCE, c => {
+                    s[ge(c)] || u(c)
+                }), l = -1), i && a.length > r) {
+                const c = a.length - r;
+                for (let f = 0; f < c; ++f) s[ge(a[f])] = -1, n.rem.push(a[f]);
+                a = a.slice(c)
             }
             return t.mod.length && t.visit(t.MOD, c => {
-                a[de(c)] && n.mod.push(c)
-            }), t.add.length && t.visit(t.ADD, u), (t.add.length || l < 0) && (n.add = s.filter(c => !a[de(c)])), this.count = o, this.value = n.source = s, n
+                s[ge(c)] && n.mod.push(c)
+            }), t.add.length && t.visit(t.ADD, u), (t.add.length || l < 0) && (n.add = a.filter(c => !s[ge(c)])), this.count = o, this.value = n.source = a, n
         }
     });
 
-    function Hw(e) {
+    function hw(e) {
         L.call(this, null, e)
     }
-    Hw.Definition = {
+    hw.Definition = {
         type: "Sequence",
         metadata: {
             generates: !0,
             changes: !0
         },
         params: [{
             name: "start",
@@ -21719,40 +21739,40 @@
             default: 1
         }, {
             name: "as",
             type: "string",
             default: "data"
         }]
     };
-    Q(Hw, L, {
+    ee(hw, L, {
         transform(e, t) {
             if (this.value && !e.modified()) return;
             const n = t.materialize().fork(t.MOD),
                 i = e.as || "data";
-            return n.rem = this.value ? t.rem.concat(this.value) : t.rem, this.value = mi(e.start, e.stop, e.step || 1).map(r => {
-                const a = {};
-                return a[i] = r, He(a)
+            return n.rem = this.value ? t.rem.concat(this.value) : t.rem, this.value = gi(e.start, e.stop, e.step || 1).map(r => {
+                const s = {};
+                return s[i] = r, He(s)
             }), n.add = t.add.concat(this.value), n
         }
     });
 
-    function bN(e) {
+    function MN(e) {
         L.call(this, null, e), this.modified(!0)
     }
-    Q(bN, L, {
+    ee(MN, L, {
         transform(e, t) {
             return this.value = t.source, t.changed() ? t.fork(t.NO_SOURCE | t.NO_FIELDS) : t.StopPropagation
         }
     });
 
-    function Yw(e) {
+    function dw(e) {
         L.call(this, null, e)
     }
-    const xN = ["unit0", "unit1"];
-    Yw.Definition = {
+    const ON = ["unit0", "unit1"];
+    dw.Definition = {
         type: "TimeUnit",
         metadata: {
             modifies: !0
         },
         params: [{
             name: "field",
             type: "field",
@@ -21760,15 +21780,15 @@
         }, {
             name: "interval",
             type: "boolean",
             default: !0
         }, {
             name: "units",
             type: "enum",
-            values: Q_,
+            values: y_,
             array: !0
         }, {
             name: "step",
             type: "number",
             default: 1
         }, {
             name: "maxbins",
@@ -21784,89 +21804,89 @@
             default: "local",
             values: ["local", "utc"]
         }, {
             name: "as",
             type: "string",
             array: !0,
             length: 2,
-            default: xN
+            default: ON
         }]
     };
-    Q(Yw, L, {
+    ee(dw, L, {
         transform(e, t) {
             const n = e.field,
                 i = e.interval !== !1,
                 r = e.timezone === "utc",
-                a = this._floor(e, t),
-                s = (r ? Pc : Rc)(a.unit).offset,
-                o = e.as || xN,
+                s = this._floor(e, t),
+                a = (r ? Sc : wc)(s.unit).offset,
+                o = e.as || ON,
                 l = o[0],
                 u = o[1],
-                c = a.step;
-            let f = a.start || 1 / 0,
-                h = a.stop || -1 / 0,
+                c = s.step;
+            let f = s.start || 1 / 0,
+                h = s.stop || -1 / 0,
                 d = t.ADD;
-            return (e.modified() || t.changed(t.REM) || t.modified(yn(n))) && (t = t.reflow(!0), d = t.SOURCE, f = 1 / 0, h = -1 / 0), t.visit(d, g => {
+            return (e.modified() || t.changed(t.REM) || t.modified(pn(n))) && (t = t.reflow(!0), d = t.SOURCE, f = 1 / 0, h = -1 / 0), t.visit(d, g => {
                 const p = n(g);
                 let m, y;
-                p == null ? (g[l] = null, i && (g[u] = null)) : (g[l] = m = y = a(p), i && (g[u] = y = s(m, c)), m < f && (f = m), y > h && (h = y))
-            }), a.start = f, a.stop = h, t.modifies(i ? o : l)
+                p == null ? (g[l] = null, i && (g[u] = null)) : (g[l] = m = y = s(p), i && (g[u] = y = a(m, c)), m < f && (f = m), y > h && (h = y))
+            }), s.start = f, s.stop = h, t.modifies(i ? o : l)
         },
         _floor(e, t) {
             const n = e.timezone === "utc",
                 {
                     units: i,
                     step: r
                 } = e.units ? {
                     units: e.units,
                     step: e.step || 1
-                } : yP({
-                    extent: e.extent || Zr(t.materialize(t.SOURCE).source, e.field),
+                } : $D({
+                    extent: e.extent || Hr(t.materialize(t.SOURCE).source, e.field),
                     maxbins: e.maxbins
                 }),
-                a = Z_(i),
-                s = this.value || {},
-                o = (n ? lP : oP)(a, r);
-            return o.unit = Le(a), o.units = a, o.step = r, o.start = s.start, o.stop = s.stop, this.value = o
+                s = v_(i),
+                a = this.value || {},
+                o = (n ? bD : vD)(s, r);
+            return o.unit = De(s), o.units = s, o.step = r, o.start = a.start, o.stop = a.stop, this.value = o
         }
     });
 
-    function _N(e) {
-        L.call(this, Dc(), e)
+    function FN(e) {
+        L.call(this, _c(), e)
     }
-    Q(_N, L, {
+    ee(FN, L, {
         transform(e, t) {
             const n = t.dataflow,
                 i = e.field,
                 r = this.value,
-                a = o => r.set(i(o), o);
-            let s = !0;
-            return e.modified("field") || t.modified(i.fields) ? (r.clear(), t.visit(t.SOURCE, a)) : t.changed() ? (t.visit(t.REM, o => r.delete(i(o))), t.visit(t.ADD, a)) : s = !1, this.modified(s), r.empty > n.cleanThreshold && n.runAfter(r.clean), t.fork()
+                s = o => r.set(i(o), o);
+            let a = !0;
+            return e.modified("field") || t.modified(i.fields) ? (r.clear(), t.visit(t.SOURCE, s)) : t.changed() ? (t.visit(t.REM, o => r.delete(i(o))), t.visit(t.ADD, s)) : a = !1, this.modified(a), r.empty > n.cleanThreshold && n.runAfter(r.clean), t.fork()
         }
     });
 
-    function wN(e) {
+    function RN(e) {
         L.call(this, null, e)
     }
-    Q(wN, L, {
+    ee(RN, L, {
         transform(e, t) {
-            (!this.value || e.modified("field") || e.modified("sort") || t.changed() || e.sort && t.modified(e.sort.fields)) && (this.value = (e.sort ? t.source.slice().sort(jl(e.sort)) : t.source).map(e.field))
+            (!this.value || e.modified("field") || e.modified("sort") || t.changed() || e.sort && t.modified(e.sort.fields)) && (this.value = (e.sort ? t.source.slice().sort($l(e.sort)) : t.source).map(e.field))
         }
     });
 
-    function rJ(e, t, n, i) {
-        const r = Lh[e](t, n);
+    function hK(e, t, n, i) {
+        const r = Ch[e](t, n);
         return {
-            init: r.init || ws,
-            update: function(a, s) {
-                s[i] = r.next(a)
+            init: r.init || ha,
+            update: function(s, a) {
+                a[i] = r.next(s)
             }
         }
     }
-    const Lh = {
+    const Ch = {
         row_number: function() {
             return {
                 next: e => e.index + 1
             }
         },
         rank: function() {
             let e;
@@ -21887,15 +21907,15 @@
                     const n = t.index,
                         i = t.data;
                     return n && t.compare(i[n - 1], i[n]) ? ++e : e
                 }
             }
         },
         percent_rank: function() {
-            const e = Lh.rank(),
+            const e = Ch.rank(),
                 t = e.next;
             return {
                 init: e.init,
                 next: n => (t(n) - 1) / (n.data.length - 1)
             }
         },
         cume_dist: function() {
@@ -21911,16 +21931,16 @@
                         e = r
                     }
                     return (1 + e) / n.length
                 }
             }
         },
         ntile: function(e, t) {
-            t = +t, t > 0 || G("ntile num must be greater than zero.");
-            const n = Lh.cume_dist(),
+            t = +t, t > 0 || U("ntile num must be greater than zero.");
+            const n = Ch.cume_dist(),
                 i = n.next;
             return {
                 init: n.init,
                 next: r => Math.ceil(t * i(r))
             }
         },
         lag: function(e, t) {
@@ -21947,15 +21967,15 @@
         },
         last_value: function(e) {
             return {
                 next: t => e(t.data[t.i1 - 1])
             }
         },
         nth_value: function(e, t) {
-            return t = +t, t > 0 || G("nth_value nth must be greater than zero."), {
+            return t = +t, t > 0 || U("nth_value nth must be greater than zero."), {
                 next: n => {
                     const i = n.i0 + (t - 1);
                     return i < n.i1 ? e(n.data[i]) : null
                 }
             }
         },
         prev_value: function(e) {
@@ -21970,113 +21990,113 @@
         },
         next_value: function(e) {
             let t, n;
             return {
                 init: () => (t = null, n = -1),
                 next: i => {
                     const r = i.data;
-                    return i.index <= n ? t : (n = aJ(e, r, i.index)) < 0 ? (n = r.length, t = null) : t = e(r[n])
+                    return i.index <= n ? t : (n = dK(e, r, i.index)) < 0 ? (n = r.length, t = null) : t = e(r[n])
                 }
             }
         }
     };
 
-    function aJ(e, t, n) {
+    function dK(e, t, n) {
         for (let i = t.length; n < i; ++n)
             if (e(t[n]) != null) return n;
         return -1
     }
-    const sJ = Object.keys(Lh);
+    const gK = Object.keys(Ch);
 
-    function SN(e) {
-        const t = ie(e.ops),
-            n = ie(e.fields),
-            i = ie(e.params),
-            r = ie(e.as),
-            a = this.outputs = [],
-            s = this.windows = [],
+    function DN(e) {
+        const t = se(e.ops),
+            n = se(e.fields),
+            i = se(e.params),
+            r = se(e.as),
+            s = this.outputs = [],
+            a = this.windows = [],
             o = {},
             l = {},
             u = [],
             c = [];
         let f = !0;
 
         function h(d) {
-            ie(yn(d)).forEach(g => o[g] = 1)
+            se(pn(d)).forEach(g => o[g] = 1)
         }
         h(e.sort), t.forEach((d, g) => {
             const p = n[g],
-                m = wt(p),
-                y = QP(d, m, r[g]);
-            if (h(p), a.push(y), pe(Lh, d)) s.push(rJ(d, n[g], i[g], y));
+                m = bt(p),
+                y = uN(d, m, r[g]);
+            if (h(p), s.push(y), me(Ch, d)) a.push(hK(d, n[g], i[g], y));
             else {
-                if (p == null && d !== "count" && G("Null aggregate field specified."), d === "count") {
+                if (p == null && d !== "count" && U("Null aggregate field specified."), d === "count") {
                     u.push(y);
                     return
                 }
                 f = !1;
                 let v = l[m];
-                v || (v = l[m] = [], v.field = p, c.push(v)), v.push(ZP(d, y))
+                v || (v = l[m] = [], v.field = p, c.push(v)), v.push(cN(d, y))
             }
-        }), (u.length || c.length) && (this.cell = oJ(c, u, f)), this.inputs = Object.keys(o)
+        }), (u.length || c.length) && (this.cell = pK(c, u, f)), this.inputs = Object.keys(o)
     }
-    const EN = SN.prototype;
-    EN.init = function() {
+    const NN = DN.prototype;
+    NN.init = function() {
         this.windows.forEach(e => e.init()), this.cell && this.cell.init()
     };
-    EN.update = function(e, t) {
+    NN.update = function(e, t) {
         const n = this.cell,
             i = this.windows,
             r = e.data,
-            a = i && i.length;
-        let s;
+            s = i && i.length;
+        let a;
         if (n) {
-            for (s = e.p0; s < e.i0; ++s) n.rem(r[s]);
-            for (s = e.p1; s < e.i1; ++s) n.add(r[s]);
+            for (a = e.p0; a < e.i0; ++a) n.rem(r[a]);
+            for (a = e.p1; a < e.i1; ++a) n.add(r[a]);
             n.set(t)
         }
-        for (s = 0; s < a; ++s) i[s].update(e, t)
+        for (a = 0; a < s; ++a) i[a].update(e, t)
     };
 
-    function oJ(e, t, n) {
-        e = e.map(l => tN(l, l.field));
+    function pK(e, t, n) {
+        e = e.map(l => hN(l, l.field));
         const i = {
             num: 0,
             agg: null,
             store: !1,
             count: t
         };
         if (!n)
-            for (var r = e.length, a = i.agg = Array(r), s = 0; s < r; ++s) a[s] = new e[s](i);
-        if (i.store) var o = i.data = new Ew;
+            for (var r = e.length, s = i.agg = Array(r), a = 0; a < r; ++a) s[a] = new e[a](i);
+        if (i.store) var o = i.data = new W_;
         return i.add = function(l) {
             if (i.num += 1, !n) {
                 o && o.add(l);
-                for (let u = 0; u < r; ++u) a[u].add(a[u].get(l), l)
+                for (let u = 0; u < r; ++u) s[u].add(s[u].get(l), l)
             }
         }, i.rem = function(l) {
             if (i.num -= 1, !n) {
                 o && o.rem(l);
-                for (let u = 0; u < r; ++u) a[u].rem(a[u].get(l), l)
+                for (let u = 0; u < r; ++u) s[u].rem(s[u].get(l), l)
             }
         }, i.set = function(l) {
             let u, c;
             for (o && o.values(), u = 0, c = t.length; u < c; ++u) l[t[u]] = i.num;
             if (!n)
-                for (u = 0, c = a.length; u < c; ++u) a[u].set(l)
+                for (u = 0, c = s.length; u < c; ++u) s[u].set(l)
         }, i.init = function() {
             i.num = 0, o && o.reset();
-            for (let l = 0; l < r; ++l) a[l].init()
+            for (let l = 0; l < r; ++l) s[l].init()
         }, i
     }
 
-    function Xw(e) {
+    function gw(e) {
         L.call(this, {}, e), this._mlen = 0, this._mods = []
     }
-    Xw.Definition = {
+    gw.Definition = {
         type: "Window",
         metadata: {
             modifies: !0
         },
         params: [{
             name: "sort",
             type: "compare"
@@ -22084,15 +22104,15 @@
             name: "groupby",
             type: "field",
             array: !0
         }, {
             name: "ops",
             type: "enum",
             array: !0,
-            values: sJ.concat(_d)
+            values: gK.concat(ud)
         }, {
             name: "params",
             type: "number",
             null: !0,
             array: !0
         }, {
             name: "fields",
@@ -22113,200 +22133,200 @@
             default: [null, 0]
         }, {
             name: "ignorePeers",
             type: "boolean",
             default: !1
         }]
     };
-    Q(Xw, L, {
+    ee(gw, L, {
         transform(e, t) {
             this.stamp = t.stamp;
             const n = e.modified(),
-                i = jl(e.sort),
-                r = C2(e.groupby),
-                a = o => this.group(r(o));
-            let s = this.state;
-            (!s || n) && (s = this.state = new SN(e)), n || t.modified(s.inputs) ? (this.value = {}, t.visit(t.SOURCE, o => a(o).add(o))) : (t.visit(t.REM, o => a(o).remove(o)), t.visit(t.ADD, o => a(o).add(o)));
-            for (let o = 0, l = this._mlen; o < l; ++o) lJ(this._mods[o], s, i, e);
-            return this._mlen = 0, this._mods = [], t.reflow(n).modifies(s.outputs)
+                i = $l(e.sort),
+                r = e2(e.groupby),
+                s = o => this.group(r(o));
+            let a = this.state;
+            (!a || n) && (a = this.state = new DN(e)), n || t.modified(a.inputs) ? (this.value = {}, t.visit(t.SOURCE, o => s(o).add(o))) : (t.visit(t.REM, o => s(o).remove(o)), t.visit(t.ADD, o => s(o).add(o)));
+            for (let o = 0, l = this._mlen; o < l; ++o) mK(this._mods[o], a, i, e);
+            return this._mlen = 0, this._mods = [], t.reflow(n).modifies(a.outputs)
         },
         group(e) {
             let t = this.value[e];
-            return t || (t = this.value[e] = nN(de), t.stamp = -1), t.stamp < this.stamp && (t.stamp = this.stamp, this._mods[this._mlen++] = t), t
+            return t || (t = this.value[e] = dN(ge), t.stamp = -1), t.stamp < this.stamp && (t.stamp = this.stamp, this._mods[this._mlen++] = t), t
         }
     });
 
-    function lJ(e, t, n, i) {
+    function mK(e, t, n, i) {
         const r = i.sort,
-            a = r && !i.ignorePeers,
-            s = i.frame || [null, 0],
+            s = r && !i.ignorePeers,
+            a = i.frame || [null, 0],
             o = e.data(n),
             l = o.length,
-            u = a ? cd(r) : null,
+            u = s ? Qh(r) : null,
             c = {
                 i0: 0,
                 i1: 0,
                 p0: 0,
                 p1: 0,
                 index: 0,
                 data: o,
-                compare: r || Sn(-1)
+                compare: r || xn(-1)
             };
         t.init();
-        for (let f = 0; f < l; ++f) uJ(c, s, f, l), a && cJ(c, u), t.update(c, o[f])
+        for (let f = 0; f < l; ++f) yK(c, a, f, l), s && vK(c, u), t.update(c, o[f])
     }
 
-    function uJ(e, t, n, i) {
+    function yK(e, t, n, i) {
         e.p0 = e.i0, e.p1 = e.i1, e.i0 = t[0] == null ? 0 : Math.max(0, n - Math.abs(t[0])), e.i1 = t[1] == null ? i : Math.min(i, n + Math.abs(t[1]) + 1), e.index = n
     }
 
-    function cJ(e, t) {
+    function vK(e, t) {
         const n = e.i0,
             i = e.i1 - 1,
             r = e.compare,
-            a = e.data,
-            s = a.length - 1;
-        n > 0 && !r(a[n], a[n - 1]) && (e.i0 = t.left(a, a[n])), i < s && !r(a[i], a[i + 1]) && (e.i1 = t.right(a, a[i]))
+            s = e.data,
+            a = s.length - 1;
+        n > 0 && !r(s[n], s[n - 1]) && (e.i0 = t.left(s, s[n])), i < a && !r(s[i], s[i + 1]) && (e.i1 = t.right(s, s[i]))
     }
-    const fJ = Object.freeze(Object.defineProperty({
+    const bK = Object.freeze(Object.defineProperty({
         __proto__: null,
-        aggregate: Us,
-        bin: Ow,
-        collect: Cw,
-        compare: iN,
-        countpattern: kw,
-        cross: Aw,
-        density: Tw,
-        dotbin: Mw,
-        expression: lN,
-        extent: Fw,
-        facet: s1,
-        field: uN,
-        filter: Rw,
-        flatten: Pw,
-        fold: Nw,
-        formula: Lw,
-        generate: cN,
-        impute: Iw,
-        joinaggregate: jw,
-        kde: zw,
-        key: fN,
-        load: hN,
-        lookup: Bw,
-        multiextent: dN,
-        multivalues: gN,
-        params: pN,
-        pivot: Gw,
-        prefacet: mN,
-        project: Uw,
-        proxy: yN,
-        quantile: qw,
-        relay: vN,
-        sample: Ww,
-        sequence: Hw,
-        sieve: bN,
-        subflow: Dw,
-        timeunit: Yw,
-        tupleindex: _N,
-        values: wN,
-        window: Xw
+        aggregate: Ra,
+        bin: q_,
+        collect: H_,
+        compare: gN,
+        countpattern: Y_,
+        cross: X_,
+        density: V_,
+        dotbin: J_,
+        expression: bN,
+        extent: Q_,
+        facet: jm,
+        field: xN,
+        filter: ew,
+        flatten: tw,
+        fold: nw,
+        formula: iw,
+        generate: _N,
+        impute: rw,
+        joinaggregate: sw,
+        kde: aw,
+        key: wN,
+        load: SN,
+        lookup: ow,
+        multiextent: EN,
+        multivalues: CN,
+        params: kN,
+        pivot: lw,
+        prefacet: AN,
+        project: uw,
+        proxy: $N,
+        quantile: cw,
+        relay: TN,
+        sample: fw,
+        sequence: hw,
+        sieve: MN,
+        subflow: Z_,
+        timeunit: dw,
+        tupleindex: FN,
+        values: RN,
+        window: gw
     }, Symbol.toStringTag, {
         value: "Module"
     }));
 
-    function Ps(e, t) {
+    function ka(e, t) {
         if (typeof document < "u" && document.createElement) {
             const n = document.createElement("canvas");
             if (n && n.getContext) return n.width = e, n.height = t, n
         }
         return null
     }
-    const hJ = () => typeof Image < "u" ? Image : null;
+    const xK = () => typeof Image < "u" ? Image : null;
 
-    function Vw(e, t, n) {
+    function pw(e, t, n) {
         const i = e - t + n * 2;
         return e ? i > 0 ? i : 1 : 0
     }
-    const dJ = "identity",
-        ec = "linear",
-        Xa = "log",
-        wd = "pow",
-        Sd = "sqrt",
-        o1 = "symlog",
-        dl = "time",
-        gl = "utc",
-        Hr = "sequential",
-        Lc = "diverging",
-        tc = "quantile",
-        l1 = "quantize",
-        u1 = "threshold",
-        Kw = "ordinal",
-        k2 = "point",
-        ON = "band",
-        Jw = "bin-ordinal",
-        jt = "continuous",
-        Ed = "discrete",
-        Od = "discretizing",
-        qi = "interpolating",
-        Qw = "temporal";
+    const _K = "identity",
+        Gu = "linear",
+        zs = "log",
+        cd = "pow",
+        fd = "sqrt",
+        Um = "symlog",
+        tl = "time",
+        nl = "utc",
+        zr = "sequential",
+        Cc = "diverging",
+        Wu = "quantile",
+        Gm = "quantize",
+        Wm = "threshold",
+        mw = "ordinal",
+        t2 = "point",
+        PN = "band",
+        yw = "bin-ordinal",
+        Nt = "continuous",
+        hd = "discrete",
+        dd = "discretizing",
+        Ii = "interpolating",
+        vw = "temporal";
 
-    function gJ(e) {
+    function wK(e) {
         return function(t) {
             let n = t[0],
                 i = t[1],
                 r;
             return i < n && (r = n, n = i, i = r), [e.invert(n), e.invert(i)]
         }
     }
 
-    function pJ(e) {
+    function SK(e) {
         return function(t) {
             const n = e.range();
             let i = t[0],
                 r = t[1],
-                a = -1,
-                s, o, l, u;
-            for (r < i && (o = i, i = r, r = o), l = 0, u = n.length; l < u; ++l) n[l] >= i && n[l] <= r && (a < 0 && (a = l), s = l);
-            if (!(a < 0)) return i = e.invertExtent(n[a]), r = e.invertExtent(n[s]), [i[0] === void 0 ? i[1] : i[0], r[1] === void 0 ? r[0] : r[1]]
+                s = -1,
+                a, o, l, u;
+            for (r < i && (o = i, i = r, r = o), l = 0, u = n.length; l < u; ++l) n[l] >= i && n[l] <= r && (s < 0 && (s = l), a = l);
+            if (!(s < 0)) return i = e.invertExtent(n[s]), r = e.invertExtent(n[a]), [i[0] === void 0 ? i[1] : i[0], r[1] === void 0 ? r[0] : r[1]]
         }
     }
 
-    function Zw() {
-        const e = Dm().unknown(void 0),
+    function bw() {
+        const e = dm().unknown(void 0),
             t = e.domain,
             n = e.range;
         let i = [0, 1],
-            r, a, s = !1,
+            r, s, a = !1,
             o = 0,
             l = 0,
             u = .5;
         delete e.unknown;
 
         function c() {
             const f = t().length,
                 h = i[1] < i[0],
                 d = i[1 - h],
-                g = Vw(f, o, l);
+                g = pw(f, o, l);
             let p = i[h - 0];
-            r = (d - p) / (g || 1), s && (r = Math.floor(r)), p += (d - p - r * (f - o)) * u, a = r * (1 - o), s && (p = Math.round(p), a = Math.round(a));
-            const m = mi(f).map(y => p + r * y);
+            r = (d - p) / (g || 1), a && (r = Math.floor(r)), p += (d - p - r * (f - o)) * u, s = r * (1 - o), a && (p = Math.round(p), s = Math.round(s));
+            const m = gi(f).map(y => p + r * y);
             return n(h ? m.reverse() : m)
         }
         return e.domain = function(f) {
             return arguments.length ? (t(f), c()) : t()
         }, e.range = function(f) {
             return arguments.length ? (i = [+f[0], +f[1]], c()) : i.slice()
         }, e.rangeRound = function(f) {
-            return i = [+f[0], +f[1]], s = !0, c()
+            return i = [+f[0], +f[1]], a = !0, c()
         }, e.bandwidth = function() {
-            return a
+            return s
         }, e.step = function() {
             return r
         }, e.round = function(f) {
-            return arguments.length ? (s = !!f, c()) : s
+            return arguments.length ? (a = !!f, c()) : a
         }, e.padding = function(f) {
             return arguments.length ? (l = Math.max(0, Math.min(1, f)), o = l, c()) : o
         }, e.paddingInner = function(f) {
             return arguments.length ? (o = Math.max(0, Math.min(1, f)), c()) : o
         }, e.paddingOuter = function(f) {
             return arguments.length ? (l = Math.max(0, Math.min(1, f)), c()) : l
         }, e.align = function(f) {
@@ -22315,178 +22335,178 @@
             if (f[0] == null || f[1] == null) return;
             const h = i[1] < i[0],
                 d = h ? n().reverse() : n(),
                 g = d.length - 1;
             let p = +f[0],
                 m = +f[1],
                 y, v, b;
-            if (!(p !== p || m !== m) && (m < p && (b = p, p = m, m = b), !(m < d[0] || p > i[1 - h]))) return y = Math.max(0, Bp(d, p) - 1), v = p === m ? y : Bp(d, m) - 1, p - d[y] > a + 1e-10 && ++y, h && (b = y, y = g - v, v = g - b), y > v ? void 0 : t().slice(y, v + 1)
+            if (!(p !== p || m !== m) && (m < p && (b = p, p = m, m = b), !(m < d[0] || p > i[1 - h]))) return y = Math.max(0, wp(d, p) - 1), v = p === m ? y : wp(d, m) - 1, p - d[y] > s + 1e-10 && ++y, h && (b = y, y = g - v, v = g - b), y > v ? void 0 : t().slice(y, v + 1)
         }, e.invert = function(f) {
             const h = e.invertRange([f, f]);
             return h && h[0]
         }, e.copy = function() {
-            return Zw().domain(t()).range(i).round(s).paddingInner(o).paddingOuter(l).align(u)
+            return bw().domain(t()).range(i).round(a).paddingInner(o).paddingOuter(l).align(u)
         }, c()
     }
 
-    function CN(e) {
+    function LN(e) {
         const t = e.copy;
         return e.padding = e.paddingOuter, delete e.paddingInner, e.copy = function() {
-            return CN(t())
+            return LN(t())
         }, e
     }
 
-    function mJ() {
-        return CN(Zw().paddingInner(1))
+    function EK() {
+        return LN(bw().paddingInner(1))
     }
-    var yJ = Array.prototype.map;
+    var CK = Array.prototype.map;
 
-    function vJ(e) {
-        return yJ.call(e, gn)
+    function kK(e) {
+        return CK.call(e, hn)
     }
-    const bJ = Array.prototype.slice;
+    const AK = Array.prototype.slice;
 
-    function kN() {
+    function IN() {
         let e = [],
             t = [];
 
         function n(i) {
-            return i == null || i !== i ? void 0 : t[(fd(e, i) - 1) % t.length]
+            return i == null || i !== i ? void 0 : t[(Zh(e, i) - 1) % t.length]
         }
         return n.domain = function(i) {
-            return arguments.length ? (e = vJ(i), n) : e.slice()
+            return arguments.length ? (e = kK(i), n) : e.slice()
         }, n.range = function(i) {
-            return arguments.length ? (t = bJ.call(i), n) : t.slice()
+            return arguments.length ? (t = AK.call(i), n) : t.slice()
         }, n.tickFormat = function(i, r) {
-            return jD(e[0], Le(e), i ?? 10, r)
+            return KF(e[0], De(e), i ?? 10, r)
         }, n.copy = function() {
-            return kN().domain(n.domain()).range(n.range())
+            return IN().domain(n.domain()).range(n.range())
         }, n
     }
-    const F0 = new Map,
-        AN = Symbol("vega_scale");
+    const d0 = new Map,
+        zN = Symbol("vega_scale");
 
-    function TN(e) {
-        return e[AN] = !0, e
+    function BN(e) {
+        return e[zN] = !0, e
     }
 
-    function xJ(e) {
-        return e && e[AN] === !0
+    function $K(e) {
+        return e && e[zN] === !0
     }
 
-    function _J(e, t, n) {
+    function TK(e, t, n) {
         const i = function() {
-            const a = t();
-            return a.invertRange || (a.invertRange = a.invert ? gJ(a) : a.invertExtent ? pJ(a) : void 0), a.type = e, TN(a)
+            const s = t();
+            return s.invertRange || (s.invertRange = s.invert ? wK(s) : s.invertExtent ? SK(s) : void 0), s.type = e, BN(s)
         };
-        return i.metadata = br(ie(n)), i
+        return i.metadata = fr(se(n)), i
     }
 
-    function qe(e, t, n) {
-        return arguments.length > 1 ? (F0.set(e, _J(e, t, n)), this) : $N(e) ? F0.get(e) : void 0
+    function We(e, t, n) {
+        return arguments.length > 1 ? (d0.set(e, TK(e, t, n)), this) : jN(e) ? d0.get(e) : void 0
     }
-    qe(dJ, BD);
-    qe(ec, zD, jt);
-    qe(Xa, UD, [jt, Xa]);
-    qe(wd, O_, jt);
-    qe(Sd, uH, jt);
-    qe(o1, qD, jt);
-    qe(dl, EY, [jt, Qw]);
-    qe(gl, OY, [jt, Qw]);
-    qe(Hr, $_, [jt, qi]);
-    qe(`${Hr}-${ec}`, $_, [jt, qi]);
-    qe(`${Hr}-${Xa}`, iR, [jt, qi, Xa]);
-    qe(`${Hr}-${wd}`, M_, [jt, qi]);
-    qe(`${Hr}-${Sd}`, CY, [jt, qi]);
-    qe(`${Hr}-${o1}`, rR, [jt, qi]);
-    qe(`${Lc}-${ec}`, aR, [jt, qi]);
-    qe(`${Lc}-${Xa}`, sR, [jt, qi, Xa]);
-    qe(`${Lc}-${wd}`, F_, [jt, qi]);
-    qe(`${Lc}-${Sd}`, kY, [jt, qi]);
-    qe(`${Lc}-${o1}`, oR, [jt, qi]);
-    qe(tc, WD, [Od, tc]);
-    qe(l1, HD, Od);
-    qe(u1, YD, Od);
-    qe(Jw, kN, [Ed, Od]);
-    qe(Kw, Dm, Ed);
-    qe(ON, Zw, Ed);
-    qe(k2, mJ, Ed);
+    We(_K, QF);
+    We(Gu, JF, Nt);
+    We(zs, eR, [Nt, zs]);
+    We(cd, Wx, Nt);
+    We(fd, mq, Nt);
+    We(Um, tR, Nt);
+    We(tl, OH, [Nt, vw]);
+    We(nl, FH, [Nt, vw]);
+    We(zr, Vx, [Nt, Ii]);
+    We(`${zr}-${Gu}`, Vx, [Nt, Ii]);
+    We(`${zr}-${zs}`, gR, [Nt, Ii, zs]);
+    We(`${zr}-${cd}`, Kx, [Nt, Ii]);
+    We(`${zr}-${fd}`, RH, [Nt, Ii]);
+    We(`${zr}-${Um}`, pR, [Nt, Ii]);
+    We(`${Cc}-${Gu}`, mR, [Nt, Ii]);
+    We(`${Cc}-${zs}`, yR, [Nt, Ii, zs]);
+    We(`${Cc}-${cd}`, Jx, [Nt, Ii]);
+    We(`${Cc}-${fd}`, DH, [Nt, Ii]);
+    We(`${Cc}-${Um}`, vR, [Nt, Ii]);
+    We(Wu, nR, [dd, Wu]);
+    We(Gm, iR, dd);
+    We(Wm, rR, dd);
+    We(yw, IN, [hd, dd]);
+    We(mw, dm, hd);
+    We(PN, bw, hd);
+    We(t2, EK, hd);
 
-    function $N(e) {
-        return F0.has(e)
+    function jN(e) {
+        return d0.has(e)
     }
 
-    function Bl(e, t) {
-        const n = F0.get(e);
+    function Ml(e, t) {
+        const n = d0.get(e);
         return n && n.metadata[t]
     }
 
-    function eS(e) {
-        return Bl(e, jt)
+    function xw(e) {
+        return Ml(e, Nt)
     }
 
-    function nc(e) {
-        return Bl(e, Ed)
+    function qu(e) {
+        return Ml(e, hd)
     }
 
-    function A2(e) {
-        return Bl(e, Od)
+    function n2(e) {
+        return Ml(e, dd)
     }
 
-    function MN(e) {
-        return Bl(e, Xa)
+    function UN(e) {
+        return Ml(e, zs)
     }
 
-    function wJ(e) {
-        return Bl(e, Qw)
+    function MK(e) {
+        return Ml(e, vw)
     }
 
-    function FN(e) {
-        return Bl(e, qi)
+    function GN(e) {
+        return Ml(e, Ii)
     }
 
-    function DN(e) {
-        return Bl(e, tc)
+    function WN(e) {
+        return Ml(e, Wu)
     }
-    const SJ = ["clamp", "base", "constant", "exponent"];
+    const OK = ["clamp", "base", "constant", "exponent"];
 
-    function RN(e, t) {
+    function qN(e, t) {
         const n = t[0],
-            i = Le(t) - n;
+            i = De(t) - n;
         return function(r) {
             return e(n + r * i)
         }
     }
 
-    function c1(e, t, n) {
-        return s_(tS(t || "rgb", n), e)
+    function qm(e, t, n) {
+        return Cx(_w(t || "rgb", n), e)
     }
 
-    function PN(e, t) {
+    function HN(e, t) {
         const n = new Array(t),
             i = t + 1;
         for (let r = 0; r < t;) n[r] = e(++r / i);
         return n
     }
 
-    function NN(e, t, n) {
+    function YN(e, t, n) {
         const i = n - t;
-        let r, a, s;
-        return !i || !Number.isFinite(i) ? Sn(.5) : (r = (a = e.type).indexOf("-"), a = r < 0 ? a : a.slice(r + 1), s = qe(a)().domain([t, n]).range([0, 1]), SJ.forEach(o => e[o] ? s[o](e[o]()) : 0), s)
+        let r, s, a;
+        return !i || !Number.isFinite(i) ? xn(.5) : (r = (s = e.type).indexOf("-"), s = r < 0 ? s : s.slice(r + 1), a = We(s)().domain([t, n]).range([0, 1]), OK.forEach(o => e[o] ? a[o](e[o]()) : 0), a)
     }
 
-    function tS(e, t) {
-        const n = uG[EJ(e)];
+    function _w(e, t) {
+        const n = mj[FK(e)];
         return t != null && n && n.gamma ? n.gamma(t) : n
     }
 
-    function EJ(e) {
+    function FK(e) {
         return "interpolate" + e.toLowerCase().split("-").map(t => t[0].toUpperCase() + t.slice(1)).join("")
     }
-    const OJ = {
+    const RK = {
             blues: "cfe1f2bed8eca8cee58fc1de74b2d75ba3cf4592c63181bd206fb2125ca40a4a90",
             greens: "d3eecdc0e6baabdda594d3917bc77d60ba6c46ab5e329a512089430e7735036429",
             greys: "e2e2e2d4d4d4c4c4c4b1b1b19d9d9d8888887575756262624d4d4d3535351e1e1e",
             oranges: "fdd8b3fdc998fdb87bfda55efc9244f87f2cf06b18e4580bd14904b93d029f3303",
             purples: "e2e1efd4d4e8c4c5e0b4b3d6a3a0cc928ec3827cb97566ae684ea25c3696501f8c",
             reds: "fdc9b4fcb49afc9e80fc8767fa7051f6573fec3f2fdc2a25c81b1db21218970b13",
             blueGreen: "d5efedc1e8e0a7ddd18bd2be70c6a958ba9144ad77319c5d2089460e7736036429",
@@ -22533,15 +22553,15 @@
             lightTealBlue: "e3e9e0c0dccf9aceca7abfc859afc0389fb9328dad2f7ca0276b95255988",
             darkBlue: "3232322d46681a5c930074af008cbf05a7ce25c0dd38daed50f3faffffff",
             darkGold: "3c3c3c584b37725e348c7631ae8b2bcfa424ecc31ef9de30fff184ffffff",
             darkGreen: "3a3a3a215748006f4d048942489e4276b340a6c63dd2d836ffeb2cffffaa",
             darkMulti: "3737371f5287197d8c29a86995ce3fffe800ffffff",
             darkRed: "3434347036339e3c38cc4037e75d1eec8620eeab29f0ce32ffeb2c"
         },
-        CJ = {
+        DK = {
             category10: "1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf",
             category20: "1f77b4aec7e8ff7f0effbb782ca02c98df8ad62728ff98969467bdc5b0d58c564bc49c94e377c2f7b6d27f7f7fc7c7c7bcbd22dbdb8d17becf9edae5",
             category20b: "393b795254a36b6ecf9c9ede6379398ca252b5cf6bcedb9c8c6d31bd9e39e7ba52e7cb94843c39ad494ad6616be7969c7b4173a55194ce6dbdde9ed6",
             category20c: "3182bd6baed69ecae1c6dbefe6550dfd8d3cfdae6bfdd0a231a35474c476a1d99bc7e9c0756bb19e9ac8bcbddcdadaeb636363969696bdbdbdd9d9d9",
             tableau10: "4c78a8f58518e4575672b7b254a24beeca3bb279a2ff9da69d755dbab0ac",
             tableau20: "4c78a89ecae9f58518ffbf7954a24b88d27ab79a20f2cf5b43989483bcb6e45756ff9d9879706ebab0acd67195fcbfd2b279a2d6a5c99e765fd8b5a5",
             accent: "7fc97fbeaed4fdc086ffff99386cb0f0027fbf5b17666666",
@@ -22550,348 +22570,348 @@
             pastel1: "fbb4aeb3cde3ccebc5decbe4fed9a6ffffcce5d8bdfddaecf2f2f2",
             pastel2: "b3e2cdfdcdaccbd5e8f4cae4e6f5c9fff2aef1e2cccccccc",
             set1: "e41a1c377eb84daf4a984ea3ff7f00ffff33a65628f781bf999999",
             set2: "66c2a5fc8d628da0cbe78ac3a6d854ffd92fe5c494b3b3b3",
             set3: "8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9bc80bdccebc5ffed6f"
         };
 
-    function LN(e) {
+    function XN(e) {
         const t = e.length / 6 | 0,
             n = new Array(t);
         for (let i = 0; i < t;) n[i] = "#" + e.slice(i * 6, ++i * 6);
         return n
     }
 
-    function IN(e, t) {
-        for (const n in e) nS(n, t(e[n]))
+    function VN(e, t) {
+        for (const n in e) ww(n, t(e[n]))
     }
-    const ST = {};
-    IN(CJ, LN);
-    IN(OJ, e => c1(LN(e)));
-
-    function nS(e, t) {
-        return e = e && e.toLowerCase(), arguments.length > 1 ? (ST[e] = t, this) : ST[e]
-    }
-    const mp = "symbol",
-        kJ = "discrete",
-        AJ = "gradient",
-        TJ = e => q(e) ? e.map(t => String(t)) : String(e),
-        $J = (e, t) => e[1] - t[1],
-        MJ = (e, t) => t[1] - e[1];
+    const L$ = {};
+    VN(DK, XN);
+    VN(RK, e => qm(XN(e)));
+
+    function ww(e, t) {
+        return e = e && e.toLowerCase(), arguments.length > 1 ? (L$[e] = t, this) : L$[e]
+    }
+    const Qg = "symbol",
+        NK = "discrete",
+        PK = "gradient",
+        LK = e => W(e) ? e.map(t => String(t)) : String(e),
+        IK = (e, t) => e[1] - t[1],
+        zK = (e, t) => t[1] - e[1];
 
-    function iS(e, t, n) {
+    function Sw(e, t, n) {
         let i;
-        return tt(t) && (e.bins && (t = Math.max(t, e.bins.length)), n != null && (t = Math.min(t, Math.floor(vd(e.domain()) / n || 1)))), se(t) && (i = t.step, t = t.interval), re(t) && (t = e.type === dl ? Rc(t) : e.type == gl ? Pc(t) : G("Only time and utc scales accept interval strings."), i && (t = t.every(i))), t
+        return Ze(t) && (e.bins && (t = Math.max(t, e.bins.length)), n != null && (t = Math.min(t, Math.floor(ad(e.domain()) / n || 1)))), ae(t) && (i = t.step, t = t.interval), re(t) && (t = e.type === tl ? wc(t) : e.type == nl ? Sc(t) : U("Only time and utc scales accept interval strings."), i && (t = t.every(i))), t
     }
 
-    function jN(e, t, n) {
+    function KN(e, t, n) {
         let i = e.range(),
             r = i[0],
-            a = Le(i),
-            s = $J;
-        if (r > a && (i = a, a = r, r = i, s = MJ), r = Math.floor(r), a = Math.ceil(a), t = t.map(o => [o, e(o)]).filter(o => r <= o[1] && o[1] <= a).sort(s).map(o => o[0]), n > 0 && t.length > 1) {
-            const o = [t[0], Le(t)];
+            s = De(i),
+            a = IK;
+        if (r > s && (i = s, s = r, r = i, a = zK), r = Math.floor(r), s = Math.ceil(s), t = t.map(o => [o, e(o)]).filter(o => r <= o[1] && o[1] <= s).sort(a).map(o => o[0]), n > 0 && t.length > 1) {
+            const o = [t[0], De(t)];
             for (; t.length > n && t.length >= 3;) t = t.filter((l, u) => !(u % 2));
             t.length < 3 && (t = o)
         }
         return t
     }
 
-    function rS(e, t) {
-        return e.bins ? jN(e, e.bins) : e.ticks ? e.ticks(t) : e.domain()
+    function Ew(e, t) {
+        return e.bins ? KN(e, e.bins) : e.ticks ? e.ticks(t) : e.domain()
     }
 
-    function zN(e, t, n, i, r, a) {
-        const s = t.type;
-        let o = TJ;
-        if (s === dl || r === dl) o = e.timeFormat(i);
-        else if (s === gl || r === gl) o = e.utcFormat(i);
-        else if (MN(s)) {
+    function JN(e, t, n, i, r, s) {
+        const a = t.type;
+        let o = LK;
+        if (a === tl || r === tl) o = e.timeFormat(i);
+        else if (a === nl || r === nl) o = e.utcFormat(i);
+        else if (UN(a)) {
             const l = e.formatFloat(i);
-            if (a || t.bins) o = l;
+            if (s || t.bins) o = l;
             else {
-                const u = BN(t, n, !1);
+                const u = QN(t, n, !1);
                 o = c => u(c) ? l(c) : ""
             }
         } else if (t.tickFormat) {
             const l = t.domain();
             o = e.formatSpan(l[0], l[l.length - 1], n, i)
         } else i && (o = e.format(i));
         return o
     }
 
-    function BN(e, t, n) {
-        const i = rS(e, t),
+    function QN(e, t, n) {
+        const i = Ew(e, t),
             r = e.base(),
-            a = Math.log(r),
-            s = Math.max(1, r * t / i.length),
+            s = Math.log(r),
+            a = Math.max(1, r * t / i.length),
             o = l => {
-                let u = l / Math.pow(r, Math.round(Math.log(l) / a));
-                return u * r < r - .5 && (u *= r), u <= s
+                let u = l / Math.pow(r, Math.round(Math.log(l) / s));
+                return u * r < r - .5 && (u *= r), u <= a
             };
         return n ? i.filter(o) : o
     }
-    const T2 = {
-            [tc]: "quantiles",
-            [l1]: "thresholds",
-            [u1]: "domain"
+    const i2 = {
+            [Wu]: "quantiles",
+            [Gm]: "thresholds",
+            [Wm]: "domain"
         },
-        GN = {
-            [tc]: "quantiles",
-            [l1]: "domain"
+        ZN = {
+            [Wu]: "quantiles",
+            [Gm]: "domain"
         };
 
-    function UN(e, t) {
-        return e.bins ? RJ(e.bins) : e.type === Xa ? BN(e, t, !0) : T2[e.type] ? DJ(e[T2[e.type]]()) : rS(e, t)
+    function eP(e, t) {
+        return e.bins ? UK(e.bins) : e.type === zs ? QN(e, t, !0) : i2[e.type] ? jK(e[i2[e.type]]()) : Ew(e, t)
     }
 
-    function FJ(e, t, n) {
-        const i = t[GN[t.type]](),
+    function BK(e, t, n) {
+        const i = t[ZN[t.type]](),
             r = i.length;
-        let a = r > 1 ? i[1] - i[0] : i[0],
-            s;
-        for (s = 1; s < r; ++s) a = Math.min(a, i[s] - i[s - 1]);
-        return e.formatSpan(0, a, 3 * 10, n)
+        let s = r > 1 ? i[1] - i[0] : i[0],
+            a;
+        for (a = 1; a < r; ++a) s = Math.min(s, i[a] - i[a - 1]);
+        return e.formatSpan(0, s, 3 * 10, n)
     }
 
-    function DJ(e) {
+    function jK(e) {
         const t = [-1 / 0].concat(e);
         return t.max = 1 / 0, t
     }
 
-    function RJ(e) {
+    function UK(e) {
         const t = e.slice(0, -1);
-        return t.max = Le(e), t
+        return t.max = De(e), t
     }
-    const PJ = e => T2[e.type] || e.bins;
+    const GK = e => i2[e.type] || e.bins;
 
-    function qN(e, t, n, i, r, a, s) {
-        const o = GN[t.type] && a !== dl && a !== gl ? FJ(e, t, r) : zN(e, t, n, r, a, s);
-        return i === mp && PJ(t) ? NJ(o) : i === kJ ? LJ(o) : IJ(o)
-    }
-    const NJ = e => (t, n, i) => {
-            const r = ET(i[n + 1], ET(i.max, 1 / 0)),
-                a = OT(t, e),
-                s = OT(r, e);
-            return a && s ? a + " – " + s : s ? "< " + s : "≥ " + a
-        },
-        ET = (e, t) => e ?? t,
-        LJ = e => (t, n) => n ? e(t) : null,
-        IJ = e => t => e(t),
-        OT = (e, t) => Number.isFinite(e) ? t(e) : null;
+    function tP(e, t, n, i, r, s, a) {
+        const o = ZN[t.type] && s !== tl && s !== nl ? BK(e, t, r) : JN(e, t, n, r, s, a);
+        return i === Qg && GK(t) ? WK(o) : i === NK ? qK(o) : HK(o)
+    }
+    const WK = e => (t, n, i) => {
+            const r = I$(i[n + 1], I$(i.max, 1 / 0)),
+                s = z$(t, e),
+                a = z$(r, e);
+            return s && a ? s + " – " + a : a ? "< " + a : "≥ " + s
+        },
+        I$ = (e, t) => e ?? t,
+        qK = e => (t, n) => n ? e(t) : null,
+        HK = e => t => e(t),
+        z$ = (e, t) => Number.isFinite(e) ? t(e) : null;
 
-    function jJ(e) {
+    function YK(e) {
         const t = e.domain(),
             n = t.length - 1;
         let i = +t[0],
-            r = +Le(t),
-            a = r - i;
-        if (e.type === u1) {
-            const s = n ? a / n : .1;
-            i -= s, r += s, a = r - i
+            r = +De(t),
+            s = r - i;
+        if (e.type === Wm) {
+            const a = n ? s / n : .1;
+            i -= a, r += a, s = r - i
         }
-        return s => (s - i) / a
+        return a => (a - i) / s
     }
 
-    function zJ(e, t, n, i) {
+    function XK(e, t, n, i) {
         const r = i || t.type;
-        return re(n) && wJ(r) && (n = n.replace(/%a/g, "%A").replace(/%b/g, "%B")), !n && r === dl ? e.timeFormat("%A, %d %B %Y, %X") : !n && r === gl ? e.utcFormat("%A, %d %B %Y, %X UTC") : qN(e, t, 5, null, n, i, !0)
+        return re(n) && MK(r) && (n = n.replace(/%a/g, "%A").replace(/%b/g, "%B")), !n && r === tl ? e.timeFormat("%A, %d %B %Y, %X") : !n && r === nl ? e.utcFormat("%A, %d %B %Y, %X UTC") : tP(e, t, 5, null, n, i, !0)
     }
 
-    function WN(e, t, n) {
+    function nP(e, t, n) {
         n = n || {};
         const i = Math.max(3, n.maxlen || 7),
-            r = zJ(e, t, n.format, n.formatType);
-        if (A2(t.type)) {
-            const a = UN(t).slice(1).map(r),
-                s = a.length;
-            return `${s} boundar${s===1?"y":"ies"}: ${a.join(", ")}`
-        } else if (nc(t.type)) {
-            const a = t.domain(),
-                s = a.length,
-                o = s > i ? a.slice(0, i - 2).map(r).join(", ") + ", ending with " + a.slice(-1).map(r) : a.map(r).join(", ");
-            return `${s} value${s===1?"":"s"}: ${o}`
+            r = XK(e, t, n.format, n.formatType);
+        if (n2(t.type)) {
+            const s = eP(t).slice(1).map(r),
+                a = s.length;
+            return `${a} boundar${a===1?"y":"ies"}: ${s.join(", ")}`
+        } else if (qu(t.type)) {
+            const s = t.domain(),
+                a = s.length,
+                o = a > i ? s.slice(0, i - 2).map(r).join(", ") + ", ending with " + s.slice(-1).map(r) : s.map(r).join(", ");
+            return `${a} value${a===1?"":"s"}: ${o}`
         } else {
-            const a = t.domain();
-            return `values from ${r(a[0])} to ${r(Le(a))}`
+            const s = t.domain();
+            return `values from ${r(s[0])} to ${r(De(s))}`
         }
     }
-    let HN = 0;
+    let iP = 0;
 
-    function BJ() {
-        HN = 0
+    function VK() {
+        iP = 0
     }
-    const D0 = "p_";
+    const g0 = "p_";
 
-    function aS(e) {
+    function Cw(e) {
         return e && e.gradient
     }
 
-    function YN(e, t, n) {
+    function rP(e, t, n) {
         const i = e.gradient;
         let r = e.id,
-            a = i === "radial" ? D0 : "";
-        return r || (r = e.id = "gradient_" + HN++, i === "radial" ? (e.x1 = Mr(e.x1, .5), e.y1 = Mr(e.y1, .5), e.r1 = Mr(e.r1, 0), e.x2 = Mr(e.x2, .5), e.y2 = Mr(e.y2, .5), e.r2 = Mr(e.r2, .5), a = D0) : (e.x1 = Mr(e.x1, 0), e.y1 = Mr(e.y1, 0), e.x2 = Mr(e.x2, 1), e.y2 = Mr(e.y2, 0))), t[r] = e, "url(" + (n || "") + "#" + a + r + ")"
+            s = i === "radial" ? g0 : "";
+        return r || (r = e.id = "gradient_" + iP++, i === "radial" ? (e.x1 = kr(e.x1, .5), e.y1 = kr(e.y1, .5), e.r1 = kr(e.r1, 0), e.x2 = kr(e.x2, .5), e.y2 = kr(e.y2, .5), e.r2 = kr(e.r2, .5), s = g0) : (e.x1 = kr(e.x1, 0), e.y1 = kr(e.y1, 0), e.x2 = kr(e.x2, 1), e.y2 = kr(e.y2, 0))), t[r] = e, "url(" + (n || "") + "#" + s + r + ")"
     }
 
-    function Mr(e, t) {
+    function kr(e, t) {
         return e ?? t
     }
 
-    function XN(e, t) {
+    function sP(e, t) {
         var n = [],
             i;
         return i = {
             gradient: "linear",
             x1: e ? e[0] : 0,
             y1: e ? e[1] : 0,
             x2: t ? t[0] : 1,
             y2: t ? t[1] : 0,
             stops: n,
-            stop: function(r, a) {
+            stop: function(r, s) {
                 return n.push({
                     offset: r,
-                    color: a
+                    color: s
                 }), i
             }
         }
     }
-    const CT = {
+    const B$ = {
         basis: {
-            curve: jY
+            curve: HH
         },
         "basis-closed": {
-            curve: zY
+            curve: YH
         },
         "basis-open": {
-            curve: BY
+            curve: XH
         },
         bundle: {
-            curve: GY,
+            curve: VH,
             tension: "beta",
             value: .85
         },
         cardinal: {
-            curve: UY,
+            curve: KH,
             tension: "tension",
             value: 0
         },
         "cardinal-open": {
-            curve: WY,
+            curve: QH,
             tension: "tension",
             value: 0
         },
         "cardinal-closed": {
-            curve: qY,
+            curve: JH,
             tension: "tension",
             value: 0
         },
         "catmull-rom": {
-            curve: HY,
+            curve: ZH,
             tension: "alpha",
             value: .5
         },
         "catmull-rom-closed": {
-            curve: YY,
+            curve: eY,
             tension: "alpha",
             value: .5
         },
         "catmull-rom-open": {
-            curve: XY,
+            curve: tY,
             tension: "alpha",
             value: .5
         },
         linear: {
-            curve: D_
+            curve: Qx
         },
         "linear-closed": {
-            curve: VY
+            curve: nY
         },
         monotone: {
-            horizontal: JY,
-            vertical: KY
+            horizontal: rY,
+            vertical: iY
         },
         natural: {
-            curve: QY
+            curve: sY
         },
         step: {
-            curve: ZY
+            curve: aY
         },
         "step-after": {
-            curve: tX
+            curve: lY
         },
         "step-before": {
-            curve: eX
+            curve: oY
         }
     };
 
-    function sS(e, t, n) {
-        var i = pe(CT, e) && CT[e],
+    function kw(e, t, n) {
+        var i = me(B$, e) && B$[e],
             r = null;
         return i && (r = i.curve || i[t || "vertical"], i.tension && n != null && (r = r[i.tension](n))), r
     }
-    const GJ = {
+    const KK = {
             m: 2,
             l: 2,
             h: 1,
             v: 1,
             z: 0,
             c: 6,
             s: 4,
             q: 4,
             t: 2,
             a: 7
         },
-        UJ = /[mlhvzcsqta]([^mlhvzcsqta]+|$)/gi,
-        qJ = /^[+-]?(([0-9]*\.[0-9]+)|([0-9]+\.)|([0-9]+))([eE][+-]?[0-9]+)?/,
-        WJ = /^((\s+,?\s*)|(,\s*))/,
-        HJ = /^[01]/;
+        JK = /[mlhvzcsqta]([^mlhvzcsqta]+|$)/gi,
+        QK = /^[+-]?(([0-9]*\.[0-9]+)|([0-9]+\.)|([0-9]+))([eE][+-]?[0-9]+)?/,
+        ZK = /^((\s+,?\s*)|(,\s*))/,
+        eJ = /^[01]/;
 
-    function ic(e) {
+    function Hu(e) {
         const t = [];
-        return (e.match(UJ) || []).forEach(i => {
+        return (e.match(JK) || []).forEach(i => {
             let r = i[0];
-            const a = r.toLowerCase(),
-                s = GJ[a],
-                o = YJ(a, s, i.slice(1).trim()),
+            const s = r.toLowerCase(),
+                a = KK[s],
+                o = tJ(s, a, i.slice(1).trim()),
                 l = o.length;
-            if (l < s || l && l % s !== 0) throw Error("Invalid SVG path, incorrect parameter count");
-            if (t.push([r, ...o.slice(0, s)]), l !== s) {
-                a === "m" && (r = r === "M" ? "L" : "l");
-                for (let u = s; u < l; u += s) t.push([r, ...o.slice(u, u + s)])
+            if (l < a || l && l % a !== 0) throw Error("Invalid SVG path, incorrect parameter count");
+            if (t.push([r, ...o.slice(0, a)]), l !== a) {
+                s === "m" && (r = r === "M" ? "L" : "l");
+                for (let u = a; u < l; u += a) t.push([r, ...o.slice(u, u + a)])
             }
         }), t
     }
 
-    function YJ(e, t, n) {
+    function tJ(e, t, n) {
         const i = [];
         for (let r = 0; t && r < n.length;)
-            for (let a = 0; a < t; ++a) {
-                const s = e === "a" && (a === 3 || a === 4) ? HJ : qJ,
-                    o = n.slice(r).match(s);
+            for (let s = 0; s < t; ++s) {
+                const a = e === "a" && (s === 3 || s === 4) ? eJ : QK,
+                    o = n.slice(r).match(a);
                 if (o === null) throw Error("Invalid SVG path, incorrect parameter type");
                 r += o[0].length, i.push(+o[0]);
-                const l = n.slice(r).match(WJ);
+                const l = n.slice(r).match(ZK);
                 l !== null && (r += l[0].length)
             }
         return i
     }
-    const qs = Math.PI / 180,
-        XJ = 1e-14,
-        Bo = Math.PI / 2,
-        jr = Math.PI * 2,
-        su = Math.sqrt(3) / 2;
-    var bv = {},
-        xv = {},
-        VN = [].join;
-
-    function VJ(e, t, n, i, r, a, s, o, l) {
-        const u = VN.call(arguments);
-        if (bv[u]) return bv[u];
-        const c = s * qs,
+    const Da = Math.PI / 180,
+        nJ = 1e-14,
+        To = Math.PI / 2,
+        Dr = Math.PI * 2,
+        Vl = Math.sqrt(3) / 2;
+    var Jy = {},
+        Qy = {},
+        aP = [].join;
+
+    function iJ(e, t, n, i, r, s, a, o, l) {
+        const u = aP.call(arguments);
+        if (Jy[u]) return Jy[u];
+        const c = a * Da,
             f = Math.sin(c),
             h = Math.cos(c);
         n = Math.abs(n), i = Math.abs(i);
         const d = h * (o - e) * .5 + f * (l - t) * .5,
             g = h * (l - t) * .5 - f * (o - e) * .5;
         let p = d * d / (n * n) + g * g / (i * i);
         p > 1 && (p = Math.sqrt(p), n *= p, i *= p);
@@ -22899,162 +22919,162 @@
             y = f / n,
             v = -f / i,
             b = h / i,
             x = m * o + y * l,
             _ = v * o + b * l,
             S = m * e + y * t,
             w = v * e + b * t;
-        let k = 1 / ((S - x) * (S - x) + (w - _) * (w - _)) - .25;
-        k < 0 && (k = 0);
-        let C = Math.sqrt(k);
-        a == r && (C = -C);
-        const E = .5 * (x + S) - C * (w - _),
-            T = .5 * (_ + w) + C * (S - x),
-            A = Math.atan2(_ - T, x - E);
-        let $ = Math.atan2(w - T, S - E) - A;
-        $ < 0 && a === 1 ? $ += jr : $ > 0 && a === 0 && ($ -= jr);
-        const D = Math.ceil(Math.abs($ / (Bo + .001))),
-            P = [];
-        for (let N = 0; N < D; ++N) {
-            const z = A + N * $ / D,
-                I = A + (N + 1) * $ / D;
-            P[N] = [E, T, z, I, n, i, f, h]
-        }
-        return bv[u] = P
-    }
-
-    function KJ(e) {
-        const t = VN.call(e);
-        if (xv[t]) return xv[t];
+        let A = 1 / ((S - x) * (S - x) + (w - _) * (w - _)) - .25;
+        A < 0 && (A = 0);
+        let C = Math.sqrt(A);
+        s == r && (C = -C);
+        const k = .5 * (x + S) - C * (w - _),
+            R = .5 * (_ + w) + C * (S - x),
+            $ = Math.atan2(_ - R, x - k);
+        let M = Math.atan2(w - R, S - k) - $;
+        M < 0 && s === 1 ? M += Dr : M > 0 && s === 0 && (M -= Dr);
+        const F = Math.ceil(Math.abs(M / (To + .001))),
+            N = [];
+        for (let P = 0; P < F; ++P) {
+            const z = $ + P * M / F,
+                I = $ + (P + 1) * M / F;
+            N[P] = [k, R, z, I, n, i, f, h]
+        }
+        return Jy[u] = N
+    }
+
+    function rJ(e) {
+        const t = aP.call(e);
+        if (Qy[t]) return Qy[t];
         var n = e[0],
             i = e[1],
             r = e[2],
-            a = e[3],
-            s = e[4],
+            s = e[3],
+            a = e[4],
             o = e[5],
             l = e[6],
             u = e[7];
-        const c = u * s,
+        const c = u * a,
             f = -l * o,
-            h = l * s,
+            h = l * a,
             d = u * o,
             g = Math.cos(r),
             p = Math.sin(r),
-            m = Math.cos(a),
-            y = Math.sin(a),
-            v = .5 * (a - r),
+            m = Math.cos(s),
+            y = Math.sin(s),
+            v = .5 * (s - r),
             b = Math.sin(v * .5),
             x = 8 / 3 * b * b / Math.sin(v),
             _ = n + g - x * p,
             S = i + p + x * g,
             w = n + m,
-            O = i + y,
-            k = w + x * y,
-            C = O - x * m;
-        return xv[t] = [c * _ + f * S, h * _ + d * S, c * k + f * C, h * k + d * C, c * w + f * O, h * w + d * O]
-    }
-    const Ci = ["l", 0, 0, 0, 0, 0, 0, 0];
-
-    function JJ(e, t, n) {
-        const i = Ci[0] = e[0];
-        if (i === "a" || i === "A") Ci[1] = t * e[1], Ci[2] = n * e[2], Ci[3] = e[3], Ci[4] = e[4], Ci[5] = e[5], Ci[6] = t * e[6], Ci[7] = n * e[7];
-        else if (i === "h" || i === "H") Ci[1] = t * e[1];
-        else if (i === "v" || i === "V") Ci[1] = n * e[1];
+            E = i + y,
+            A = w + x * y,
+            C = E - x * m;
+        return Qy[t] = [c * _ + f * S, h * _ + d * S, c * A + f * C, h * A + d * C, c * w + f * E, h * w + d * E]
+    }
+    const Si = ["l", 0, 0, 0, 0, 0, 0, 0];
+
+    function sJ(e, t, n) {
+        const i = Si[0] = e[0];
+        if (i === "a" || i === "A") Si[1] = t * e[1], Si[2] = n * e[2], Si[3] = e[3], Si[4] = e[4], Si[5] = e[5], Si[6] = t * e[6], Si[7] = n * e[7];
+        else if (i === "h" || i === "H") Si[1] = t * e[1];
+        else if (i === "v" || i === "V") Si[1] = n * e[1];
         else
-            for (var r = 1, a = e.length; r < a; ++r) Ci[r] = (r % 2 == 1 ? t : n) * e[r];
-        return Ci
+            for (var r = 1, s = e.length; r < s; ++r) Si[r] = (r % 2 == 1 ? t : n) * e[r];
+        return Si
     }
 
-    function Ih(e, t, n, i, r, a) {
-        var s, o = null,
+    function kh(e, t, n, i, r, s) {
+        var a, o = null,
             l = 0,
             u = 0,
             c = 0,
             f = 0,
             h, d, g, p, m = 0,
             y = 0;
-        n == null && (n = 0), i == null && (i = 0), r == null && (r = 1), a == null && (a = r), e.beginPath && e.beginPath();
+        n == null && (n = 0), i == null && (i = 0), r == null && (r = 1), s == null && (s = r), e.beginPath && e.beginPath();
         for (var v = 0, b = t.length; v < b; ++v) {
-            switch (s = t[v], (r !== 1 || a !== 1) && (s = JJ(s, r, a)), s[0]) {
+            switch (a = t[v], (r !== 1 || s !== 1) && (a = sJ(a, r, s)), a[0]) {
                 case "l":
-                    l += s[1], u += s[2], e.lineTo(l + n, u + i);
+                    l += a[1], u += a[2], e.lineTo(l + n, u + i);
                     break;
                 case "L":
-                    l = s[1], u = s[2], e.lineTo(l + n, u + i);
+                    l = a[1], u = a[2], e.lineTo(l + n, u + i);
                     break;
                 case "h":
-                    l += s[1], e.lineTo(l + n, u + i);
+                    l += a[1], e.lineTo(l + n, u + i);
                     break;
                 case "H":
-                    l = s[1], e.lineTo(l + n, u + i);
+                    l = a[1], e.lineTo(l + n, u + i);
                     break;
                 case "v":
-                    u += s[1], e.lineTo(l + n, u + i);
+                    u += a[1], e.lineTo(l + n, u + i);
                     break;
                 case "V":
-                    u = s[1], e.lineTo(l + n, u + i);
+                    u = a[1], e.lineTo(l + n, u + i);
                     break;
                 case "m":
-                    l += s[1], u += s[2], m = l, y = u, e.moveTo(l + n, u + i);
+                    l += a[1], u += a[2], m = l, y = u, e.moveTo(l + n, u + i);
                     break;
                 case "M":
-                    l = s[1], u = s[2], m = l, y = u, e.moveTo(l + n, u + i);
+                    l = a[1], u = a[2], m = l, y = u, e.moveTo(l + n, u + i);
                     break;
                 case "c":
-                    h = l + s[5], d = u + s[6], c = l + s[3], f = u + s[4], e.bezierCurveTo(l + s[1] + n, u + s[2] + i, c + n, f + i, h + n, d + i), l = h, u = d;
+                    h = l + a[5], d = u + a[6], c = l + a[3], f = u + a[4], e.bezierCurveTo(l + a[1] + n, u + a[2] + i, c + n, f + i, h + n, d + i), l = h, u = d;
                     break;
                 case "C":
-                    l = s[5], u = s[6], c = s[3], f = s[4], e.bezierCurveTo(s[1] + n, s[2] + i, c + n, f + i, l + n, u + i);
+                    l = a[5], u = a[6], c = a[3], f = a[4], e.bezierCurveTo(a[1] + n, a[2] + i, c + n, f + i, l + n, u + i);
                     break;
                 case "s":
-                    h = l + s[3], d = u + s[4], c = 2 * l - c, f = 2 * u - f, e.bezierCurveTo(c + n, f + i, l + s[1] + n, u + s[2] + i, h + n, d + i), c = l + s[1], f = u + s[2], l = h, u = d;
+                    h = l + a[3], d = u + a[4], c = 2 * l - c, f = 2 * u - f, e.bezierCurveTo(c + n, f + i, l + a[1] + n, u + a[2] + i, h + n, d + i), c = l + a[1], f = u + a[2], l = h, u = d;
                     break;
                 case "S":
-                    h = s[3], d = s[4], c = 2 * l - c, f = 2 * u - f, e.bezierCurveTo(c + n, f + i, s[1] + n, s[2] + i, h + n, d + i), l = h, u = d, c = s[1], f = s[2];
+                    h = a[3], d = a[4], c = 2 * l - c, f = 2 * u - f, e.bezierCurveTo(c + n, f + i, a[1] + n, a[2] + i, h + n, d + i), l = h, u = d, c = a[1], f = a[2];
                     break;
                 case "q":
-                    h = l + s[3], d = u + s[4], c = l + s[1], f = u + s[2], e.quadraticCurveTo(c + n, f + i, h + n, d + i), l = h, u = d;
+                    h = l + a[3], d = u + a[4], c = l + a[1], f = u + a[2], e.quadraticCurveTo(c + n, f + i, h + n, d + i), l = h, u = d;
                     break;
                 case "Q":
-                    h = s[3], d = s[4], e.quadraticCurveTo(s[1] + n, s[2] + i, h + n, d + i), l = h, u = d, c = s[1], f = s[2];
+                    h = a[3], d = a[4], e.quadraticCurveTo(a[1] + n, a[2] + i, h + n, d + i), l = h, u = d, c = a[1], f = a[2];
                     break;
                 case "t":
-                    h = l + s[1], d = u + s[2], o[0].match(/[QqTt]/) === null ? (c = l, f = u) : o[0] === "t" ? (c = 2 * l - g, f = 2 * u - p) : o[0] === "q" && (c = 2 * l - c, f = 2 * u - f), g = c, p = f, e.quadraticCurveTo(c + n, f + i, h + n, d + i), l = h, u = d, c = l + s[1], f = u + s[2];
+                    h = l + a[1], d = u + a[2], o[0].match(/[QqTt]/) === null ? (c = l, f = u) : o[0] === "t" ? (c = 2 * l - g, f = 2 * u - p) : o[0] === "q" && (c = 2 * l - c, f = 2 * u - f), g = c, p = f, e.quadraticCurveTo(c + n, f + i, h + n, d + i), l = h, u = d, c = l + a[1], f = u + a[2];
                     break;
                 case "T":
-                    h = s[1], d = s[2], c = 2 * l - c, f = 2 * u - f, e.quadraticCurveTo(c + n, f + i, h + n, d + i), l = h, u = d;
+                    h = a[1], d = a[2], c = 2 * l - c, f = 2 * u - f, e.quadraticCurveTo(c + n, f + i, h + n, d + i), l = h, u = d;
                     break;
                 case "a":
-                    kT(e, l + n, u + i, [s[1], s[2], s[3], s[4], s[5], s[6] + l + n, s[7] + u + i]), l += s[6], u += s[7];
+                    j$(e, l + n, u + i, [a[1], a[2], a[3], a[4], a[5], a[6] + l + n, a[7] + u + i]), l += a[6], u += a[7];
                     break;
                 case "A":
-                    kT(e, l + n, u + i, [s[1], s[2], s[3], s[4], s[5], s[6] + n, s[7] + i]), l = s[6], u = s[7];
+                    j$(e, l + n, u + i, [a[1], a[2], a[3], a[4], a[5], a[6] + n, a[7] + i]), l = a[6], u = a[7];
                     break;
                 case "z":
                 case "Z":
                     l = m, u = y, e.closePath();
                     break
             }
-            o = s
+            o = a
         }
     }
 
-    function kT(e, t, n, i) {
-        const r = VJ(i[5], i[6], i[0], i[1], i[3], i[4], i[2], t, n);
-        for (let a = 0; a < r.length; ++a) {
-            const s = KJ(r[a]);
-            e.bezierCurveTo(s[0], s[1], s[2], s[3], s[4], s[5])
+    function j$(e, t, n, i) {
+        const r = iJ(i[5], i[6], i[0], i[1], i[3], i[4], i[2], t, n);
+        for (let s = 0; s < r.length; ++s) {
+            const a = rJ(r[s]);
+            e.bezierCurveTo(a[0], a[1], a[2], a[3], a[4], a[5])
         }
     }
-    const AT = .5773502691896257,
-        TT = {
+    const U$ = .5773502691896257,
+        G$ = {
             circle: {
                 draw: function(e, t) {
                     const n = Math.sqrt(t) / 2;
-                    e.moveTo(n, 0), e.arc(0, 0, n, 0, jr)
+                    e.moveTo(n, 0), e.arc(0, 0, n, 0, Dr)
                 }
             },
             cross: {
                 draw: function(e, t) {
                     var n = Math.sqrt(t) / 2,
                         i = n / 2.5;
                     e.moveTo(-n, -i), e.lineTo(-n, i), e.lineTo(-i, i), e.lineTo(-i, n), e.lineTo(i, n), e.lineTo(i, i), e.lineTo(n, i), e.lineTo(n, -i), e.lineTo(i, -i), e.lineTo(i, -n), e.lineTo(-i, -n), e.lineTo(-i, -i), e.closePath()
@@ -23074,183 +23094,183 @@
                 }
             },
             arrow: {
                 draw: function(e, t) {
                     var n = Math.sqrt(t) / 2,
                         i = n / 7,
                         r = n / 2.5,
-                        a = n / 8;
-                    e.moveTo(-i, n), e.lineTo(i, n), e.lineTo(i, -a), e.lineTo(r, -a), e.lineTo(0, -n), e.lineTo(-r, -a), e.lineTo(-i, -a), e.closePath()
+                        s = n / 8;
+                    e.moveTo(-i, n), e.lineTo(i, n), e.lineTo(i, -s), e.lineTo(r, -s), e.lineTo(0, -n), e.lineTo(-r, -s), e.lineTo(-i, -s), e.closePath()
                 }
             },
             wedge: {
                 draw: function(e, t) {
                     var n = Math.sqrt(t) / 2,
-                        i = su * n,
-                        r = i - n * AT,
-                        a = n / 4;
-                    e.moveTo(0, -i - r), e.lineTo(-a, i - r), e.lineTo(a, i - r), e.closePath()
+                        i = Vl * n,
+                        r = i - n * U$,
+                        s = n / 4;
+                    e.moveTo(0, -i - r), e.lineTo(-s, i - r), e.lineTo(s, i - r), e.closePath()
                 }
             },
             triangle: {
                 draw: function(e, t) {
                     var n = Math.sqrt(t) / 2,
-                        i = su * n,
-                        r = i - n * AT;
+                        i = Vl * n,
+                        r = i - n * U$;
                     e.moveTo(0, -i - r), e.lineTo(-n, i - r), e.lineTo(n, i - r), e.closePath()
                 }
             },
             "triangle-up": {
                 draw: function(e, t) {
                     var n = Math.sqrt(t) / 2,
-                        i = su * n;
+                        i = Vl * n;
                     e.moveTo(0, -i), e.lineTo(-n, i), e.lineTo(n, i), e.closePath()
                 }
             },
             "triangle-down": {
                 draw: function(e, t) {
                     var n = Math.sqrt(t) / 2,
-                        i = su * n;
+                        i = Vl * n;
                     e.moveTo(0, i), e.lineTo(-n, -i), e.lineTo(n, -i), e.closePath()
                 }
             },
             "triangle-right": {
                 draw: function(e, t) {
                     var n = Math.sqrt(t) / 2,
-                        i = su * n;
+                        i = Vl * n;
                     e.moveTo(i, 0), e.lineTo(-i, -n), e.lineTo(-i, n), e.closePath()
                 }
             },
             "triangle-left": {
                 draw: function(e, t) {
                     var n = Math.sqrt(t) / 2,
-                        i = su * n;
+                        i = Vl * n;
                     e.moveTo(-i, 0), e.lineTo(i, -n), e.lineTo(i, n), e.closePath()
                 }
             },
             stroke: {
                 draw: function(e, t) {
                     const n = Math.sqrt(t) / 2;
                     e.moveTo(-n, 0), e.lineTo(n, 0)
                 }
             }
         };
 
-    function KN(e) {
-        return pe(TT, e) ? TT[e] : QJ(e)
+    function oP(e) {
+        return me(G$, e) ? G$[e] : aJ(e)
     }
-    var _v = {};
+    var Zy = {};
 
-    function QJ(e) {
-        if (!pe(_v, e)) {
-            const t = ic(e);
-            _v[e] = {
+    function aJ(e) {
+        if (!me(Zy, e)) {
+            const t = Hu(e);
+            Zy[e] = {
                 draw: function(n, i) {
-                    Ih(n, t, 0, 0, Math.sqrt(i) / 2)
+                    kh(n, t, 0, 0, Math.sqrt(i) / 2)
                 }
             }
         }
-        return _v[e]
+        return Zy[e]
     }
-    const cs = .448084975506;
+    const ta = .448084975506;
 
-    function ZJ(e) {
+    function oJ(e) {
         return e.x
     }
 
-    function eQ(e) {
+    function lJ(e) {
         return e.y
     }
 
-    function tQ(e) {
+    function uJ(e) {
         return e.width
     }
 
-    function nQ(e) {
+    function cJ(e) {
         return e.height
     }
 
-    function wa(e) {
+    function hs(e) {
         return typeof e == "function" ? e : () => +e
     }
 
-    function Dg(e, t, n) {
+    function vg(e, t, n) {
         return Math.max(t, Math.min(e, n))
     }
 
-    function JN() {
-        var e = ZJ,
-            t = eQ,
-            n = tQ,
-            i = nQ,
-            r = wa(0),
-            a = r,
+    function lP() {
+        var e = oJ,
+            t = lJ,
+            n = uJ,
+            i = cJ,
+            r = hs(0),
             s = r,
+            a = r,
             o = r,
             l = null;
 
         function u(c, f, h) {
             var d, g = f ?? +e.call(this, c),
                 p = h ?? +t.call(this, c),
                 m = +n.call(this, c),
                 y = +i.call(this, c),
                 v = Math.min(m, y) / 2,
-                b = Dg(+r.call(this, c), 0, v),
-                x = Dg(+a.call(this, c), 0, v),
-                _ = Dg(+s.call(this, c), 0, v),
-                S = Dg(+o.call(this, c), 0, v);
-            if (l || (l = d = km()), b <= 0 && x <= 0 && _ <= 0 && S <= 0) l.rect(g, p, m, y);
+                b = vg(+r.call(this, c), 0, v),
+                x = vg(+s.call(this, c), 0, v),
+                _ = vg(+a.call(this, c), 0, v),
+                S = vg(+o.call(this, c), 0, v);
+            if (l || (l = d = om()), b <= 0 && x <= 0 && _ <= 0 && S <= 0) l.rect(g, p, m, y);
             else {
                 var w = g + m,
-                    O = p + y;
-                l.moveTo(g + b, p), l.lineTo(w - x, p), l.bezierCurveTo(w - cs * x, p, w, p + cs * x, w, p + x), l.lineTo(w, O - S), l.bezierCurveTo(w, O - cs * S, w - cs * S, O, w - S, O), l.lineTo(g + _, O), l.bezierCurveTo(g + cs * _, O, g, O - cs * _, g, O - _), l.lineTo(g, p + b), l.bezierCurveTo(g, p + cs * b, g + cs * b, p, g + b, p), l.closePath()
+                    E = p + y;
+                l.moveTo(g + b, p), l.lineTo(w - x, p), l.bezierCurveTo(w - ta * x, p, w, p + ta * x, w, p + x), l.lineTo(w, E - S), l.bezierCurveTo(w, E - ta * S, w - ta * S, E, w - S, E), l.lineTo(g + _, E), l.bezierCurveTo(g + ta * _, E, g, E - ta * _, g, E - _), l.lineTo(g, p + b), l.bezierCurveTo(g, p + ta * b, g + ta * b, p, g + b, p), l.closePath()
             }
             if (d) return l = null, d + "" || null
         }
         return u.x = function(c) {
-            return arguments.length ? (e = wa(c), u) : e
+            return arguments.length ? (e = hs(c), u) : e
         }, u.y = function(c) {
-            return arguments.length ? (t = wa(c), u) : t
+            return arguments.length ? (t = hs(c), u) : t
         }, u.width = function(c) {
-            return arguments.length ? (n = wa(c), u) : n
+            return arguments.length ? (n = hs(c), u) : n
         }, u.height = function(c) {
-            return arguments.length ? (i = wa(c), u) : i
+            return arguments.length ? (i = hs(c), u) : i
         }, u.cornerRadius = function(c, f, h, d) {
-            return arguments.length ? (r = wa(c), a = f != null ? wa(f) : r, o = h != null ? wa(h) : r, s = d != null ? wa(d) : a, u) : r
+            return arguments.length ? (r = hs(c), s = f != null ? hs(f) : r, o = h != null ? hs(h) : r, a = d != null ? hs(d) : s, u) : r
         }, u.context = function(c) {
             return arguments.length ? (l = c ?? null, u) : l
         }, u
     }
 
-    function QN() {
+    function uP() {
         var e, t, n, i, r = null,
-            a, s, o, l;
+            s, a, o, l;
 
         function u(f, h, d) {
             const g = d / 2;
-            if (a) {
+            if (s) {
                 var p = o - h,
-                    m = f - s;
+                    m = f - a;
                 if (p || m) {
                     var y = Math.sqrt(p * p + m * m),
                         v = (p /= y) * l,
                         b = (m /= y) * l,
                         x = Math.atan2(m, p);
-                    r.moveTo(s - v, o - b), r.lineTo(f - p * g, h - m * g), r.arc(f, h, g, x - Math.PI, x), r.lineTo(s + v, o + b), r.arc(s, o, l, x, x + Math.PI)
-                } else r.arc(f, h, g, 0, jr);
+                    r.moveTo(a - v, o - b), r.lineTo(f - p * g, h - m * g), r.arc(f, h, g, x - Math.PI, x), r.lineTo(a + v, o + b), r.arc(a, o, l, x, x + Math.PI)
+                } else r.arc(f, h, g, 0, Dr);
                 r.closePath()
-            } else a = 1;
-            s = f, o = h, l = g
+            } else s = 1;
+            a = f, o = h, l = g
         }
 
         function c(f) {
             var h, d = f.length,
                 g, p = !1,
                 m;
-            for (r == null && (r = m = km()), h = 0; h <= d; ++h) !(h < d && i(g = f[h], h, f)) === p && (p = !p) && (a = 0), p && u(+e(g, h, f), +t(g, h, f), +n(g, h, f));
+            for (r == null && (r = m = om()), h = 0; h <= d; ++h) !(h < d && i(g = f[h], h, f)) === p && (p = !p) && (s = 0), p && u(+e(g, h, f), +t(g, h, f), +n(g, h, f));
             if (m) return r = null, m + "" || null
         }
         return c.x = function(f) {
             return arguments.length ? (e = f, c) : e
         }, c.y = function(f) {
             return arguments.length ? (t = f, c) : t
         }, c.size = function(f) {
@@ -23258,102 +23278,102 @@
         }, c.defined = function(f) {
             return arguments.length ? (i = f, c) : i
         }, c.context = function(f) {
             return arguments.length ? (f == null ? r = null : r = f, c) : r
         }, c
     }
 
-    function Cd(e, t) {
+    function gd(e, t) {
         return e ?? t
     }
-    const kd = e => e.x || 0,
-        Ad = e => e.y || 0,
-        iQ = e => e.width || 0,
-        rQ = e => e.height || 0,
-        aQ = e => (e.x || 0) + (e.width || 0),
-        sQ = e => (e.y || 0) + (e.height || 0),
-        oQ = e => e.startAngle || 0,
-        lQ = e => e.endAngle || 0,
-        uQ = e => e.padAngle || 0,
-        cQ = e => e.innerRadius || 0,
-        fQ = e => e.outerRadius || 0,
-        hQ = e => e.cornerRadius || 0,
-        dQ = e => Cd(e.cornerRadiusTopLeft, e.cornerRadius) || 0,
-        gQ = e => Cd(e.cornerRadiusTopRight, e.cornerRadius) || 0,
-        pQ = e => Cd(e.cornerRadiusBottomRight, e.cornerRadius) || 0,
-        mQ = e => Cd(e.cornerRadiusBottomLeft, e.cornerRadius) || 0,
-        yQ = e => Cd(e.size, 64),
-        vQ = e => e.size || 1,
-        f1 = e => e.defined !== !1,
-        bQ = e => KN(e.shape || "circle"),
-        xQ = NY().startAngle(oQ).endAngle(lQ).padAngle(uQ).innerRadius(cQ).outerRadius(fQ).cornerRadius(hQ),
-        _Q = gR().x(kd).y1(Ad).y0(sQ).defined(f1),
-        wQ = gR().y(Ad).x1(kd).x0(aQ).defined(f1),
-        SQ = dR().x(kd).y(Ad).defined(f1),
-        EQ = JN().x(kd).y(Ad).width(iQ).height(rQ).cornerRadius(dQ, gQ, pQ, mQ),
-        OQ = IY().type(bQ).size(yQ),
-        CQ = QN().x(kd).y(Ad).defined(f1).size(vQ);
+    const pd = e => e.x || 0,
+        md = e => e.y || 0,
+        fJ = e => e.width || 0,
+        hJ = e => e.height || 0,
+        dJ = e => (e.x || 0) + (e.width || 0),
+        gJ = e => (e.y || 0) + (e.height || 0),
+        pJ = e => e.startAngle || 0,
+        mJ = e => e.endAngle || 0,
+        yJ = e => e.padAngle || 0,
+        vJ = e => e.innerRadius || 0,
+        bJ = e => e.outerRadius || 0,
+        xJ = e => e.cornerRadius || 0,
+        _J = e => gd(e.cornerRadiusTopLeft, e.cornerRadius) || 0,
+        wJ = e => gd(e.cornerRadiusTopRight, e.cornerRadius) || 0,
+        SJ = e => gd(e.cornerRadiusBottomRight, e.cornerRadius) || 0,
+        EJ = e => gd(e.cornerRadiusBottomLeft, e.cornerRadius) || 0,
+        CJ = e => gd(e.size, 64),
+        kJ = e => e.size || 1,
+        Hm = e => e.defined !== !1,
+        AJ = e => oP(e.shape || "circle"),
+        $J = GH().startAngle(pJ).endAngle(mJ).padAngle(yJ).innerRadius(vJ).outerRadius(bJ).cornerRadius(xJ),
+        TJ = CR().x(pd).y1(md).y0(gJ).defined(Hm),
+        MJ = CR().y(md).x1(pd).x0(dJ).defined(Hm),
+        OJ = ER().x(pd).y(md).defined(Hm),
+        FJ = lP().x(pd).y(md).width(fJ).height(hJ).cornerRadius(_J, wJ, SJ, EJ),
+        RJ = qH().type(AJ).size(CJ),
+        DJ = uP().x(pd).y(md).defined(Hm).size(kJ);
 
-    function oS(e) {
+    function Aw(e) {
         return e.cornerRadius || e.cornerRadiusTopLeft || e.cornerRadiusTopRight || e.cornerRadiusBottomRight || e.cornerRadiusBottomLeft
     }
 
-    function kQ(e, t) {
-        return xQ.context(e)(t)
+    function NJ(e, t) {
+        return $J.context(e)(t)
     }
 
-    function AQ(e, t) {
+    function PJ(e, t) {
         const n = t[0],
             i = n.interpolate || "linear";
-        return (n.orient === "horizontal" ? wQ : _Q).curve(sS(i, n.orient, n.tension)).context(e)(t)
+        return (n.orient === "horizontal" ? MJ : TJ).curve(kw(i, n.orient, n.tension)).context(e)(t)
     }
 
-    function TQ(e, t) {
+    function LJ(e, t) {
         const n = t[0],
             i = n.interpolate || "linear";
-        return SQ.curve(sS(i, n.orient, n.tension)).context(e)(t)
+        return OJ.curve(kw(i, n.orient, n.tension)).context(e)(t)
     }
 
-    function Ic(e, t, n, i) {
-        return EQ.context(e)(t, n, i)
+    function kc(e, t, n, i) {
+        return FJ.context(e)(t, n, i)
     }
 
-    function $Q(e, t) {
+    function IJ(e, t) {
         return (t.mark.shape || t.shape).context(e)(t)
     }
 
-    function MQ(e, t) {
-        return OQ.context(e)(t)
+    function zJ(e, t) {
+        return RJ.context(e)(t)
     }
 
-    function FQ(e, t) {
-        return CQ.context(e)(t)
+    function BJ(e, t) {
+        return DJ.context(e)(t)
     }
-    var ZN = 1;
+    var cP = 1;
 
-    function e4() {
-        ZN = 1
+    function fP() {
+        cP = 1
     }
 
-    function lS(e, t, n) {
+    function $w(e, t, n) {
         var i = t.clip,
             r = e._defs,
-            a = t.clip_id || (t.clip_id = "clip" + ZN++),
-            s = r.clipping[a] || (r.clipping[a] = {
-                id: a
+            s = t.clip_id || (t.clip_id = "clip" + cP++),
+            a = r.clipping[s] || (r.clipping[s] = {
+                id: s
             });
-        return Ae(i) ? s.path = i(null) : oS(n) ? s.path = Ic(null, n, 0, 0) : (s.width = n.width || 0, s.height = n.height || 0), "url(#" + a + ")"
+        return $e(i) ? a.path = i(null) : Aw(n) ? a.path = kc(null, n, 0, 0) : (a.width = n.width || 0, a.height = n.height || 0), "url(#" + s + ")"
     }
 
-    function At(e) {
+    function kt(e) {
         this.clear(), e && this.union(e)
     }
-    At.prototype = {
+    kt.prototype = {
         clone() {
-            return new At(this)
+            return new kt(this)
         },
         clear() {
             return this.x1 = +Number.MAX_VALUE, this.y1 = +Number.MAX_VALUE, this.x2 = -Number.MAX_VALUE, this.y2 = -Number.MAX_VALUE, this
         },
         empty() {
             return this.x1 === +Number.MAX_VALUE && this.y1 === +Number.MAX_VALUE && this.x2 === -Number.MAX_VALUE && this.y2 === -Number.MAX_VALUE
         },
@@ -23382,18 +23402,18 @@
             const i = this.rotatedPoints(e, t, n);
             return this.clear().add(i[0], i[1]).add(i[2], i[3]).add(i[4], i[5]).add(i[6], i[7])
         },
         rotatedPoints(e, t, n) {
             var {
                 x1: i,
                 y1: r,
-                x2: a,
-                y2: s
+                x2: s,
+                y2: a
             } = this, o = Math.cos(e), l = Math.sin(e), u = t - t * o + n * l, c = n - t * l - n * o;
-            return [o * i - l * r + u, l * i + o * r + c, o * i - l * s + u, l * i + o * s + c, o * a - l * r + u, l * a + o * r + c, o * a - l * s + u, l * a + o * s + c]
+            return [o * i - l * r + u, l * i + o * r + c, o * i - l * a + u, l * i + o * a + c, o * s - l * r + u, l * s + o * r + c, o * s - l * a + u, l * s + o * a + c]
         },
         union(e) {
             return e.x1 < this.x1 && (this.x1 = e.x1), e.y1 < this.y1 && (this.y1 = e.y1), e.x2 > this.x2 && (this.x2 = e.x2), e.y2 > this.y2 && (this.y2 = e.y2), this
         },
         intersect(e) {
             return e.x1 > this.x1 && (this.x1 = e.x1), e.y1 > this.y1 && (this.y1 = e.y1), e.x2 < this.x2 && (this.x2 = e.x2), e.y2 < this.y2 && (this.y2 = e.y2), this
         },
@@ -23413,58 +23433,58 @@
             return this.x2 - this.x1
         },
         height() {
             return this.y2 - this.y1
         }
     };
 
-    function h1(e) {
-        this.mark = e, this.bounds = this.bounds || new At
+    function Ym(e) {
+        this.mark = e, this.bounds = this.bounds || new kt
     }
 
-    function d1(e) {
-        h1.call(this, e), this.items = this.items || []
+    function Xm(e) {
+        Ym.call(this, e), this.items = this.items || []
     }
-    Q(d1, h1);
+    ee(Xm, Ym);
 
-    function uS(e) {
-        this._pending = 0, this._loader = e || Vm()
+    function Tw(e) {
+        this._pending = 0, this._loader = e || Mm()
     }
 
-    function $T(e) {
+    function W$(e) {
         e._pending += 1
     }
 
-    function pf(e) {
+    function tf(e) {
         e._pending -= 1
     }
-    uS.prototype = {
+    Tw.prototype = {
         pending() {
             return this._pending
         },
         sanitizeURL(e) {
             const t = this;
-            return $T(t), t._loader.sanitize(e, {
+            return W$(t), t._loader.sanitize(e, {
                 context: "href"
-            }).then(n => (pf(t), n)).catch(() => (pf(t), null))
+            }).then(n => (tf(t), n)).catch(() => (tf(t), null))
         },
         loadImage(e) {
             const t = this,
-                n = hJ();
-            return $T(t), t._loader.sanitize(e, {
+                n = xK();
+            return W$(t), t._loader.sanitize(e, {
                 context: "image"
             }).then(i => {
                 const r = i.href;
                 if (!r || !n) throw {
                     url: r
                 };
-                const a = new n,
-                    s = pe(i, "crossOrigin") ? i.crossOrigin : "anonymous";
-                return s != null && (a.crossOrigin = s), a.onload = () => pf(t), a.onerror = () => pf(t), a.src = r, a
-            }).catch(i => (pf(t), {
+                const s = new n,
+                    a = me(i, "crossOrigin") ? i.crossOrigin : "anonymous";
+                return a != null && (s.crossOrigin = a), s.onload = () => tf(t), s.onerror = () => tf(t), s.src = r, s
+            }).catch(i => (tf(t), {
                 complete: !1,
                 width: 0,
                 height: 0,
                 src: i && i.url || ""
             }))
         },
         ready() {
@@ -23476,989 +23496,989 @@
                     }, 10) : t(i)
                 }
                 n(!1)
             })
         }
     };
 
-    function es(e, t, n) {
+    function qs(e, t, n) {
         if (t.stroke && t.opacity !== 0 && t.strokeOpacity !== 0) {
             const i = t.strokeWidth != null ? +t.strokeWidth : 1;
-            e.expand(i + (n ? DQ(t, i) : 0))
+            e.expand(i + (n ? jJ(t, i) : 0))
         }
         return e
     }
 
-    function DQ(e, t) {
+    function jJ(e, t) {
         return e.strokeJoin && e.strokeJoin !== "miter" ? 0 : t
     }
-    const RQ = jr - 1e-8;
-    let g1, yp, vp, Vo, $2, bp, M2, F2;
-    const Es = (e, t) => g1.add(e, t),
-        xp = (e, t) => Es(yp = e, vp = t),
-        MT = e => Es(e, g1.y1),
-        FT = e => Es(g1.x1, e),
-        Go = (e, t) => $2 * e + M2 * t,
-        Uo = (e, t) => bp * e + F2 * t,
-        wv = (e, t) => Es(Go(e, t), Uo(e, t)),
-        Sv = (e, t) => xp(Go(e, t), Uo(e, t));
+    const UJ = Dr - 1e-8;
+    let Vm, Zg, ep, Lo, r2, tp, s2, a2;
+    const ga = (e, t) => Vm.add(e, t),
+        np = (e, t) => ga(Zg = e, ep = t),
+        q$ = e => ga(e, Vm.y1),
+        H$ = e => ga(Vm.x1, e),
+        Mo = (e, t) => r2 * e + s2 * t,
+        Oo = (e, t) => tp * e + a2 * t,
+        ev = (e, t) => ga(Mo(e, t), Oo(e, t)),
+        tv = (e, t) => np(Mo(e, t), Oo(e, t));
 
-    function Td(e, t) {
-        return g1 = e, t ? (Vo = t * qs, $2 = F2 = Math.cos(Vo), bp = Math.sin(Vo), M2 = -bp) : ($2 = F2 = 1, Vo = bp = M2 = 0), PQ
+    function yd(e, t) {
+        return Vm = e, t ? (Lo = t * Da, r2 = a2 = Math.cos(Lo), tp = Math.sin(Lo), s2 = -tp) : (r2 = a2 = 1, Lo = tp = s2 = 0), GJ
     }
-    const PQ = {
+    const GJ = {
         beginPath() {},
         closePath() {},
-        moveTo: Sv,
-        lineTo: Sv,
+        moveTo: tv,
+        lineTo: tv,
         rect(e, t, n, i) {
-            Vo ? (wv(e + n, t), wv(e + n, t + i), wv(e, t + i), Sv(e, t)) : (Es(e + n, t + i), xp(e, t))
+            Lo ? (ev(e + n, t), ev(e + n, t + i), ev(e, t + i), tv(e, t)) : (ga(e + n, t + i), np(e, t))
         },
         quadraticCurveTo(e, t, n, i) {
-            const r = Go(e, t),
-                a = Uo(e, t),
-                s = Go(n, i),
-                o = Uo(n, i);
-            DT(yp, r, s, MT), DT(vp, a, o, FT), xp(s, o)
-        },
-        bezierCurveTo(e, t, n, i, r, a) {
-            const s = Go(e, t),
-                o = Uo(e, t),
-                l = Go(n, i),
-                u = Uo(n, i),
-                c = Go(r, a),
-                f = Uo(r, a);
-            RT(yp, s, l, c, MT), RT(vp, o, u, f, FT), xp(c, f)
+            const r = Mo(e, t),
+                s = Oo(e, t),
+                a = Mo(n, i),
+                o = Oo(n, i);
+            Y$(Zg, r, a, q$), Y$(ep, s, o, H$), np(a, o)
+        },
+        bezierCurveTo(e, t, n, i, r, s) {
+            const a = Mo(e, t),
+                o = Oo(e, t),
+                l = Mo(n, i),
+                u = Oo(n, i),
+                c = Mo(r, s),
+                f = Oo(r, s);
+            X$(Zg, a, l, c, q$), X$(ep, o, u, f, H$), np(c, f)
         },
-        arc(e, t, n, i, r, a) {
-            if (i += Vo, r += Vo, yp = n * Math.cos(r) + e, vp = n * Math.sin(r) + t, Math.abs(r - i) > RQ) Es(e - n, t - n), Es(e + n, t + n);
+        arc(e, t, n, i, r, s) {
+            if (i += Lo, r += Lo, Zg = n * Math.cos(r) + e, ep = n * Math.sin(r) + t, Math.abs(r - i) > UJ) ga(e - n, t - n), ga(e + n, t + n);
             else {
-                const s = u => Es(n * Math.cos(u) + e, n * Math.sin(u) + t);
+                const a = u => ga(n * Math.cos(u) + e, n * Math.sin(u) + t);
                 let o, l;
-                if (s(i), s(r), r !== i)
-                    if (i = i % jr, i < 0 && (i += jr), r = r % jr, r < 0 && (r += jr), r < i && (a = !a, o = i, i = r, r = o), a)
-                        for (r -= jr, o = i - i % Bo, l = 0; l < 4 && o > r; ++l, o -= Bo) s(o);
+                if (a(i), a(r), r !== i)
+                    if (i = i % Dr, i < 0 && (i += Dr), r = r % Dr, r < 0 && (r += Dr), r < i && (s = !s, o = i, i = r, r = o), s)
+                        for (r -= Dr, o = i - i % To, l = 0; l < 4 && o > r; ++l, o -= To) a(o);
                     else
-                        for (o = i - i % Bo + Bo, l = 0; l < 4 && o < r; ++l, o = o + Bo) s(o)
+                        for (o = i - i % To + To, l = 0; l < 4 && o < r; ++l, o = o + To) a(o)
             }
         }
     };
 
-    function DT(e, t, n, i) {
+    function Y$(e, t, n, i) {
         const r = (e - t) / (e + n - 2 * t);
         0 < r && r < 1 && i(e + (t - e) * r)
     }
 
-    function RT(e, t, n, i, r) {
-        const a = i - e + 3 * t - 3 * n,
-            s = e + n - 2 * t,
+    function X$(e, t, n, i, r) {
+        const s = i - e + 3 * t - 3 * n,
+            a = e + n - 2 * t,
             o = e - t;
         let l = 0,
             u = 0,
             c;
-        Math.abs(a) > XJ ? (c = s * s + o * a, c >= 0 && (c = Math.sqrt(c), l = (-s + c) / a, u = (-s - c) / a)) : l = .5 * o / s, 0 < l && l < 1 && r(PT(l, e, t, n, i)), 0 < u && u < 1 && r(PT(u, e, t, n, i))
+        Math.abs(s) > nJ ? (c = a * a + o * s, c >= 0 && (c = Math.sqrt(c), l = (-a + c) / s, u = (-a - c) / s)) : l = .5 * o / a, 0 < l && l < 1 && r(V$(l, e, t, n, i)), 0 < u && u < 1 && r(V$(u, e, t, n, i))
     }
 
-    function PT(e, t, n, i, r) {
-        const a = 1 - e,
-            s = a * a,
+    function V$(e, t, n, i, r) {
+        const s = 1 - e,
+            a = s * s,
             o = e * e;
-        return s * a * t + 3 * s * e * n + 3 * a * o * i + o * e * r
+        return a * s * t + 3 * a * e * n + 3 * s * o * i + o * e * r
     }
-    var Ns = (Ns = Ps(1, 1)) ? Ns.getContext("2d") : null;
-    const D2 = new At;
+    var Aa = (Aa = ka(1, 1)) ? Aa.getContext("2d") : null;
+    const o2 = new kt;
 
-    function cS(e) {
+    function Mw(e) {
         return function(t, n) {
-            if (!Ns) return !0;
-            e(Ns, t), D2.clear().union(t.bounds).intersect(n).round();
+            if (!Aa) return !0;
+            e(Aa, t), o2.clear().union(t.bounds).intersect(n).round();
             const {
                 x1: i,
                 y1: r,
-                x2: a,
-                y2: s
-            } = D2;
-            for (let o = r; o <= s; ++o)
-                for (let l = i; l <= a; ++l)
-                    if (Ns.isPointInPath(l, o)) return !0;
+                x2: s,
+                y2: a
+            } = o2;
+            for (let o = r; o <= a; ++o)
+                for (let l = i; l <= s; ++l)
+                    if (Aa.isPointInPath(l, o)) return !0;
             return !1
         }
     }
 
-    function fS(e, t) {
+    function Ow(e, t) {
         return t.contains(e.x || 0, e.y || 0)
     }
 
-    function t4(e, t) {
+    function hP(e, t) {
         const n = e.x || 0,
             i = e.y || 0,
             r = e.width || 0,
-            a = e.height || 0;
-        return t.intersects(D2.set(n, i, n + r, i + a))
+            s = e.height || 0;
+        return t.intersects(o2.set(n, i, n + r, i + s))
     }
 
-    function n4(e, t) {
+    function dP(e, t) {
         const n = e.x || 0,
             i = e.y || 0,
             r = e.x2 != null ? e.x2 : n,
-            a = e.y2 != null ? e.y2 : i;
-        return Eu(t, n, i, r, a)
+            s = e.y2 != null ? e.y2 : i;
+        return du(t, n, i, r, s)
     }
 
-    function Eu(e, t, n, i, r) {
+    function du(e, t, n, i, r) {
         const {
-            x1: a,
-            y1: s,
+            x1: s,
+            y1: a,
             x2: o,
             y2: l
         } = e, u = i - t, c = r - n;
         let f = 0,
             h = 1,
             d, g, p, m;
         for (m = 0; m < 4; ++m) {
-            if (m === 0 && (d = -u, g = -(a - t)), m === 1 && (d = u, g = o - t), m === 2 && (d = -c, g = -(s - n)), m === 3 && (d = c, g = l - n), Math.abs(d) < 1e-10 && g < 0) return !1;
+            if (m === 0 && (d = -u, g = -(s - t)), m === 1 && (d = u, g = o - t), m === 2 && (d = -c, g = -(a - n)), m === 3 && (d = c, g = l - n), Math.abs(d) < 1e-10 && g < 0) return !1;
             if (p = g / d, d < 0) {
                 if (p > h) return !1;
                 p > f && (f = p)
             } else if (d > 0) {
                 if (p < f) return !1;
                 p < h && (h = p)
             }
         }
         return !0
     }
 
-    function rc(e, t) {
+    function Yu(e, t) {
         e.globalCompositeOperation = t.blend || "source-over"
     }
 
-    function Ki(e, t) {
+    function Gi(e, t) {
         return e ?? t
     }
 
-    function NT(e, t) {
+    function K$(e, t) {
         const n = t.length;
         for (let i = 0; i < n; ++i) e.addColorStop(t[i].offset, t[i].color);
         return e
     }
 
-    function NQ(e, t, n) {
+    function WJ(e, t, n) {
         const i = n.width(),
             r = n.height();
-        let a;
-        if (t.gradient === "radial") a = e.createRadialGradient(n.x1 + Ki(t.x1, .5) * i, n.y1 + Ki(t.y1, .5) * r, Math.max(i, r) * Ki(t.r1, 0), n.x1 + Ki(t.x2, .5) * i, n.y1 + Ki(t.y2, .5) * r, Math.max(i, r) * Ki(t.r2, .5));
+        let s;
+        if (t.gradient === "radial") s = e.createRadialGradient(n.x1 + Gi(t.x1, .5) * i, n.y1 + Gi(t.y1, .5) * r, Math.max(i, r) * Gi(t.r1, 0), n.x1 + Gi(t.x2, .5) * i, n.y1 + Gi(t.y2, .5) * r, Math.max(i, r) * Gi(t.r2, .5));
         else {
-            const s = Ki(t.x1, 0),
-                o = Ki(t.y1, 0),
-                l = Ki(t.x2, 1),
-                u = Ki(t.y2, 0);
-            if (s === l || o === u || i === r) a = e.createLinearGradient(n.x1 + s * i, n.y1 + o * r, n.x1 + l * i, n.y1 + u * r);
+            const a = Gi(t.x1, 0),
+                o = Gi(t.y1, 0),
+                l = Gi(t.x2, 1),
+                u = Gi(t.y2, 0);
+            if (a === l || o === u || i === r) s = e.createLinearGradient(n.x1 + a * i, n.y1 + o * r, n.x1 + l * i, n.y1 + u * r);
             else {
-                const c = Ps(Math.ceil(i), Math.ceil(r)),
+                const c = ka(Math.ceil(i), Math.ceil(r)),
                     f = c.getContext("2d");
-                return f.scale(i, r), f.fillStyle = NT(f.createLinearGradient(s, o, l, u), t.stops), f.fillRect(0, 0, i, r), e.createPattern(c, "no-repeat")
+                return f.scale(i, r), f.fillStyle = K$(f.createLinearGradient(a, o, l, u), t.stops), f.fillRect(0, 0, i, r), e.createPattern(c, "no-repeat")
             }
         }
-        return NT(a, t.stops)
+        return K$(s, t.stops)
     }
 
-    function i4(e, t, n) {
-        return aS(n) ? NQ(e, n, t.bounds) : n
+    function gP(e, t, n) {
+        return Cw(n) ? WJ(e, n, t.bounds) : n
     }
 
-    function R0(e, t, n) {
-        return n *= t.fillOpacity == null ? 1 : t.fillOpacity, n > 0 ? (e.globalAlpha = n, e.fillStyle = i4(e, t, t.fill), !0) : !1
+    function p0(e, t, n) {
+        return n *= t.fillOpacity == null ? 1 : t.fillOpacity, n > 0 ? (e.globalAlpha = n, e.fillStyle = gP(e, t, t.fill), !0) : !1
     }
-    var LQ = [];
+    var qJ = [];
 
-    function ac(e, t, n) {
+    function Xu(e, t, n) {
         var i = (i = t.strokeWidth) != null ? i : 1;
-        return i <= 0 ? !1 : (n *= t.strokeOpacity == null ? 1 : t.strokeOpacity, n > 0 ? (e.globalAlpha = n, e.strokeStyle = i4(e, t, t.stroke), e.lineWidth = i, e.lineCap = t.strokeCap || "butt", e.lineJoin = t.strokeJoin || "miter", e.miterLimit = t.strokeMiterLimit || 10, e.setLineDash && (e.setLineDash(t.strokeDash || LQ), e.lineDashOffset = t.strokeDashOffset || 0), !0) : !1)
+        return i <= 0 ? !1 : (n *= t.strokeOpacity == null ? 1 : t.strokeOpacity, n > 0 ? (e.globalAlpha = n, e.strokeStyle = gP(e, t, t.stroke), e.lineWidth = i, e.lineCap = t.strokeCap || "butt", e.lineJoin = t.strokeJoin || "miter", e.miterLimit = t.strokeMiterLimit || 10, e.setLineDash && (e.setLineDash(t.strokeDash || qJ), e.lineDashOffset = t.strokeDashOffset || 0), !0) : !1)
     }
 
-    function IQ(e, t) {
+    function HJ(e, t) {
         return e.zindex - t.zindex || e.index - t.index
     }
 
-    function hS(e) {
+    function Fw(e) {
         if (!e.zdirty) return e.zitems;
         var t = e.items,
             n = [],
-            i, r, a;
-        for (r = 0, a = t.length; r < a; ++r) i = t[r], i.index = r, i.zindex && n.push(i);
-        return e.zdirty = !1, e.zitems = n.sort(IQ)
+            i, r, s;
+        for (r = 0, s = t.length; r < s; ++r) i = t[r], i.index = r, i.zindex && n.push(i);
+        return e.zdirty = !1, e.zitems = n.sort(HJ)
     }
 
-    function _r(e, t) {
+    function dr(e, t) {
         var n = e.items,
             i, r;
         if (!n || !n.length) return;
-        const a = hS(e);
-        if (a && a.length) {
+        const s = Fw(e);
+        if (s && s.length) {
             for (i = 0, r = n.length; i < r; ++i) n[i].zindex || t(n[i]);
-            n = a
+            n = s
         }
         for (i = 0, r = n.length; i < r; ++i) t(n[i])
     }
 
-    function P0(e, t) {
+    function m0(e, t) {
         var n = e.items,
             i, r;
         if (!n || !n.length) return null;
-        const a = hS(e);
-        for (a && a.length && (n = a), r = n.length; --r >= 0;)
+        const s = Fw(e);
+        for (s && s.length && (n = s), r = n.length; --r >= 0;)
             if (i = t(n[r])) return i;
-        if (n === a) {
+        if (n === s) {
             for (n = e.items, r = n.length; --r >= 0;)
                 if (!n[r].zindex && (i = t(n[r]))) return i
         }
         return null
     }
 
-    function dS(e) {
+    function Rw(e) {
         return function(t, n, i) {
-            _r(n, r => {
-                (!i || i.intersects(r.bounds)) && r4(e, t, r, r)
+            dr(n, r => {
+                (!i || i.intersects(r.bounds)) && pP(e, t, r, r)
             })
         }
     }
 
-    function jQ(e) {
+    function YJ(e) {
         return function(t, n, i) {
-            n.items.length && (!i || i.intersects(n.bounds)) && r4(e, t, n.items[0], n.items)
+            n.items.length && (!i || i.intersects(n.bounds)) && pP(e, t, n.items[0], n.items)
         }
     }
 
-    function r4(e, t, n, i) {
+    function pP(e, t, n, i) {
         var r = n.opacity == null ? 1 : n.opacity;
-        r !== 0 && (e(t, i) || (rc(t, n), n.fill && R0(t, n, r) && t.fill(), n.stroke && ac(t, n, r) && t.stroke()))
+        r !== 0 && (e(t, i) || (Yu(t, n), n.fill && p0(t, n, r) && t.fill(), n.stroke && Xu(t, n, r) && t.stroke()))
     }
 
-    function p1(e) {
-        return e = e || Ii,
-            function(t, n, i, r, a, s) {
-                return i *= t.pixelRatio, r *= t.pixelRatio, P0(n, o => {
+    function Km(e) {
+        return e = e || Ri,
+            function(t, n, i, r, s, a) {
+                return i *= t.pixelRatio, r *= t.pixelRatio, m0(n, o => {
                     const l = o.bounds;
-                    if (!(l && !l.contains(a, s) || !l) && e(t, o, i, r, a, s)) return o
+                    if (!(l && !l.contains(s, a) || !l) && e(t, o, i, r, s, a)) return o
                 })
             }
     }
 
-    function $d(e, t) {
-        return function(n, i, r, a) {
-            var s = Array.isArray(i) ? i[0] : i,
-                o = t ?? s.fill,
-                l = s.stroke && n.isPointInStroke,
+    function vd(e, t) {
+        return function(n, i, r, s) {
+            var a = Array.isArray(i) ? i[0] : i,
+                o = t ?? a.fill,
+                l = a.stroke && n.isPointInStroke,
                 u, c;
-            return l && (u = s.strokeWidth, c = s.strokeCap, n.lineWidth = u ?? 1, n.lineCap = c ?? "butt"), e(n, i) ? !1 : o && n.isPointInPath(r, a) || l && n.isPointInStroke(r, a)
+            return l && (u = a.strokeWidth, c = a.strokeCap, n.lineWidth = u ?? 1, n.lineCap = c ?? "butt"), e(n, i) ? !1 : o && n.isPointInPath(r, s) || l && n.isPointInStroke(r, s)
         }
     }
 
-    function gS(e) {
-        return p1($d(e))
+    function Dw(e) {
+        return Km(vd(e))
     }
 
-    function nl(e, t) {
+    function Go(e, t) {
         return "translate(" + e + "," + t + ")"
     }
 
-    function pS(e) {
+    function Nw(e) {
         return "rotate(" + e + ")"
     }
 
-    function zQ(e, t) {
+    function XJ(e, t) {
         return "scale(" + e + "," + t + ")"
     }
 
-    function a4(e) {
-        return nl(e.x || 0, e.y || 0)
+    function mP(e) {
+        return Go(e.x || 0, e.y || 0)
     }
 
-    function BQ(e) {
-        return nl(e.x || 0, e.y || 0) + (e.angle ? " " + pS(e.angle) : "")
+    function VJ(e) {
+        return Go(e.x || 0, e.y || 0) + (e.angle ? " " + Nw(e.angle) : "")
     }
 
-    function GQ(e) {
-        return nl(e.x || 0, e.y || 0) + (e.angle ? " " + pS(e.angle) : "") + (e.scaleX || e.scaleY ? " " + zQ(e.scaleX || 1, e.scaleY || 1) : "")
+    function KJ(e) {
+        return Go(e.x || 0, e.y || 0) + (e.angle ? " " + Nw(e.angle) : "") + (e.scaleX || e.scaleY ? " " + XJ(e.scaleX || 1, e.scaleY || 1) : "")
     }
 
-    function mS(e, t, n) {
-        function i(s, o) {
-            s("transform", BQ(o)), s("d", t(null, o))
+    function Pw(e, t, n) {
+        function i(a, o) {
+            a("transform", VJ(o)), a("d", t(null, o))
         }
 
-        function r(s, o) {
-            return t(Td(s, o.angle), o), es(s, o).translate(o.x || 0, o.y || 0)
+        function r(a, o) {
+            return t(yd(a, o.angle), o), qs(a, o).translate(o.x || 0, o.y || 0)
         }
 
-        function a(s, o) {
+        function s(a, o) {
             var l = o.x || 0,
                 u = o.y || 0,
                 c = o.angle || 0;
-            s.translate(l, u), c && s.rotate(c *= qs), s.beginPath(), t(s, o), c && s.rotate(-c), s.translate(-l, -u)
+            a.translate(l, u), c && a.rotate(c *= Da), a.beginPath(), t(a, o), c && a.rotate(-c), a.translate(-l, -u)
         }
         return {
             type: e,
             tag: "path",
             nested: !1,
             attr: i,
             bound: r,
-            draw: dS(a),
-            pick: gS(a),
-            isect: n || cS(a)
+            draw: Rw(s),
+            pick: Dw(s),
+            isect: n || Mw(s)
         }
     }
-    var UQ = mS("arc", kQ);
+    var JJ = Pw("arc", NJ);
 
-    function qQ(e, t) {
-        for (var n = e[0].orient === "horizontal" ? t[1] : t[0], i = e[0].orient === "horizontal" ? "y" : "x", r = e.length, a = 1 / 0, s, o; --r >= 0;) e[r].defined !== !1 && (o = Math.abs(e[r][i] - n), o < a && (a = o, s = e[r]));
-        return s
+    function QJ(e, t) {
+        for (var n = e[0].orient === "horizontal" ? t[1] : t[0], i = e[0].orient === "horizontal" ? "y" : "x", r = e.length, s = 1 / 0, a, o; --r >= 0;) e[r].defined !== !1 && (o = Math.abs(e[r][i] - n), o < s && (s = o, a = e[r]));
+        return a
     }
 
-    function WQ(e, t) {
-        for (var n = Math.pow(e[0].strokeWidth || 1, 2), i = e.length, r, a, s; --i >= 0;)
-            if (e[i].defined !== !1 && (r = e[i].x - t[0], a = e[i].y - t[1], s = r * r + a * a, s < n)) return e[i];
+    function ZJ(e, t) {
+        for (var n = Math.pow(e[0].strokeWidth || 1, 2), i = e.length, r, s, a; --i >= 0;)
+            if (e[i].defined !== !1 && (r = e[i].x - t[0], s = e[i].y - t[1], a = r * r + s * s, a < n)) return e[i];
         return null
     }
 
-    function HQ(e, t) {
-        for (var n = e.length, i, r, a; --n >= 0;)
-            if (e[n].defined !== !1 && (i = e[n].x - t[0], r = e[n].y - t[1], a = i * i + r * r, i = e[n].size || 1, a < i * i)) return e[n];
+    function eQ(e, t) {
+        for (var n = e.length, i, r, s; --n >= 0;)
+            if (e[n].defined !== !1 && (i = e[n].x - t[0], r = e[n].y - t[1], s = i * i + r * r, i = e[n].size || 1, s < i * i)) return e[n];
         return null
     }
 
-    function yS(e, t, n) {
+    function Lw(e, t, n) {
         function i(l, u) {
             var c = u.mark.items;
             c.length && l("d", t(null, c))
         }
 
         function r(l, u) {
             var c = u.items;
-            return c.length === 0 ? l : (t(Td(l), c), es(l, c[0]))
+            return c.length === 0 ? l : (t(yd(l), c), qs(l, c[0]))
         }
 
-        function a(l, u) {
+        function s(l, u) {
             l.beginPath(), t(l, u)
         }
-        const s = $d(a);
+        const a = vd(s);
 
         function o(l, u, c, f, h, d) {
             var g = u.items,
                 p = u.bounds;
-            return !g || !g.length || p && !p.contains(h, d) ? null : (c *= l.pixelRatio, f *= l.pixelRatio, s(l, g, c, f) ? g[0] : null)
+            return !g || !g.length || p && !p.contains(h, d) ? null : (c *= l.pixelRatio, f *= l.pixelRatio, a(l, g, c, f) ? g[0] : null)
         }
         return {
             type: e,
             tag: "path",
             nested: !0,
             attr: i,
             bound: r,
-            draw: jQ(a),
+            draw: YJ(s),
             pick: o,
-            isect: fS,
+            isect: Ow,
             tip: n
         }
     }
-    var YQ = yS("area", AQ, qQ);
+    var tQ = Lw("area", PJ, QJ);
 
-    function XQ(e, t) {
+    function nQ(e, t) {
         var n = t.clip;
-        e.save(), Ae(n) ? (e.beginPath(), n(e), e.clip()) : s4(e, t.group)
+        e.save(), $e(n) ? (e.beginPath(), n(e), e.clip()) : yP(e, t.group)
     }
 
-    function s4(e, t) {
-        e.beginPath(), oS(t) ? Ic(e, t, 0, 0) : e.rect(0, 0, t.width || 0, t.height || 0), e.clip()
+    function yP(e, t) {
+        e.beginPath(), Aw(t) ? kc(e, t, 0, 0) : e.rect(0, 0, t.width || 0, t.height || 0), e.clip()
     }
 
-    function o4(e) {
-        const t = Ki(e.strokeWidth, 1);
+    function vP(e) {
+        const t = Gi(e.strokeWidth, 1);
         return e.strokeOffset != null ? e.strokeOffset : e.stroke && t > .5 && t < 1.5 ? .5 - Math.abs(t - 1) : 0
     }
 
-    function VQ(e, t) {
-        e("transform", a4(t))
+    function iQ(e, t) {
+        e("transform", mP(t))
     }
 
-    function l4(e, t) {
-        const n = o4(t);
-        e("d", Ic(null, t, n, n))
+    function bP(e, t) {
+        const n = vP(t);
+        e("d", kc(null, t, n, n))
     }
 
-    function KQ(e, t) {
-        e("class", "background"), e("aria-hidden", !0), l4(e, t)
+    function rQ(e, t) {
+        e("class", "background"), e("aria-hidden", !0), bP(e, t)
     }
 
-    function JQ(e, t) {
-        e("class", "foreground"), e("aria-hidden", !0), t.strokeForeground ? l4(e, t) : e("d", "")
+    function sQ(e, t) {
+        e("class", "foreground"), e("aria-hidden", !0), t.strokeForeground ? bP(e, t) : e("d", "")
     }
 
-    function QQ(e, t, n) {
-        const i = t.clip ? lS(n, t, t) : null;
+    function aQ(e, t, n) {
+        const i = t.clip ? $w(n, t, t) : null;
         e("clip-path", i)
     }
 
-    function ZQ(e, t) {
+    function oQ(e, t) {
         if (!t.clip && t.items) {
             const n = t.items,
                 i = n.length;
             for (let r = 0; r < i; ++r) e.union(n[r].bounds)
         }
-        return (t.clip || t.width || t.height) && !t.noBound && e.add(0, 0).add(t.width || 0, t.height || 0), es(e, t), e.translate(t.x || 0, t.y || 0)
+        return (t.clip || t.width || t.height) && !t.noBound && e.add(0, 0).add(t.width || 0, t.height || 0), qs(e, t), e.translate(t.x || 0, t.y || 0)
     }
 
-    function jh(e, t, n, i) {
-        const r = o4(t);
-        e.beginPath(), Ic(e, t, (n || 0) + r, (i || 0) + r)
+    function Ah(e, t, n, i) {
+        const r = vP(t);
+        e.beginPath(), kc(e, t, (n || 0) + r, (i || 0) + r)
     }
-    const eZ = $d(jh),
-        tZ = $d(jh, !1),
-        nZ = $d(jh, !0);
+    const lQ = vd(Ah),
+        uQ = vd(Ah, !1),
+        cQ = vd(Ah, !0);
 
-    function iZ(e, t, n) {
-        _r(t, i => {
+    function fQ(e, t, n) {
+        dr(t, i => {
             const r = i.x || 0,
-                a = i.y || 0,
-                s = i.strokeForeground,
+                s = i.y || 0,
+                a = i.strokeForeground,
                 o = i.opacity == null ? 1 : i.opacity;
-            (i.stroke || i.fill) && o && (jh(e, i, r, a), rc(e, i), i.fill && R0(e, i, o) && e.fill(), i.stroke && !s && ac(e, i, o) && e.stroke()), e.save(), e.translate(r, a), i.clip && s4(e, i), n && n.translate(-r, -a), _r(i, l => {
+            (i.stroke || i.fill) && o && (Ah(e, i, r, s), Yu(e, i), i.fill && p0(e, i, o) && e.fill(), i.stroke && !a && Xu(e, i, o) && e.stroke()), e.save(), e.translate(r, s), i.clip && yP(e, i), n && n.translate(-r, -s), dr(i, l => {
                 this.draw(e, l, n)
-            }), n && n.translate(r, a), e.restore(), s && i.stroke && o && (jh(e, i, r, a), rc(e, i), ac(e, i, o) && e.stroke())
+            }), n && n.translate(r, s), e.restore(), a && i.stroke && o && (Ah(e, i, r, s), Yu(e, i), Xu(e, i, o) && e.stroke())
         })
     }
 
-    function rZ(e, t, n, i, r, a) {
-        if (t.bounds && !t.bounds.contains(r, a) || !t.items) return null;
-        const s = n * e.pixelRatio,
+    function hQ(e, t, n, i, r, s) {
+        if (t.bounds && !t.bounds.contains(r, s) || !t.items) return null;
+        const a = n * e.pixelRatio,
             o = i * e.pixelRatio;
-        return P0(t, l => {
+        return m0(t, l => {
             let u, c, f;
             const h = l.bounds;
-            if (h && !h.contains(r, a)) return;
+            if (h && !h.contains(r, s)) return;
             c = l.x || 0, f = l.y || 0;
             const d = c + (l.width || 0),
                 g = f + (l.height || 0),
                 p = l.clip;
-            if (p && (r < c || r > d || a < f || a > g)) return;
-            if (e.save(), e.translate(c, f), c = r - c, f = a - f, p && oS(l) && !nZ(e, l, s, o)) return e.restore(), null;
+            if (p && (r < c || r > d || s < f || s > g)) return;
+            if (e.save(), e.translate(c, f), c = r - c, f = s - f, p && Aw(l) && !cQ(e, l, a, o)) return e.restore(), null;
             const m = l.strokeForeground,
                 y = t.interactive !== !1;
-            return y && m && l.stroke && tZ(e, l, s, o) ? (e.restore(), l) : (u = P0(l, v => aZ(v, c, f) ? this.pick(v, n, i, c, f) : null), !u && y && (l.fill || !m && l.stroke) && eZ(e, l, s, o) && (u = l), e.restore(), u || null)
+            return y && m && l.stroke && uQ(e, l, a, o) ? (e.restore(), l) : (u = m0(l, v => dQ(v, c, f) ? this.pick(v, n, i, c, f) : null), !u && y && (l.fill || !m && l.stroke) && lQ(e, l, a, o) && (u = l), e.restore(), u || null)
         })
     }
 
-    function aZ(e, t, n) {
+    function dQ(e, t, n) {
         return (e.interactive !== !1 || e.marktype === "group") && e.bounds && e.bounds.contains(t, n)
     }
-    var sZ = {
+    var gQ = {
             type: "group",
             tag: "g",
             nested: !1,
-            attr: VQ,
-            bound: ZQ,
-            draw: iZ,
-            pick: rZ,
-            isect: t4,
-            content: QQ,
-            background: KQ,
-            foreground: JQ
+            attr: iQ,
+            bound: oQ,
+            draw: fQ,
+            pick: hQ,
+            isect: hP,
+            content: aQ,
+            background: rQ,
+            foreground: sQ
         },
-        zh = {
+        $h = {
             xmlns: "http://www.w3.org/2000/svg",
             "xmlns:xlink": "http://www.w3.org/1999/xlink",
             version: "1.1"
         };
 
-    function vS(e, t) {
+    function Iw(e, t) {
         var n = e.image;
         return (!n || e.url && e.url !== n.url) && (n = {
             complete: !1,
             width: 0,
             height: 0
         }, t.loadImage(e.url).then(i => {
             e.image = i, e.image.url = e.url
         })), n
     }
 
-    function bS(e, t) {
+    function zw(e, t) {
         return e.width != null ? e.width : !t || !t.width ? 0 : e.aspect !== !1 && e.height ? e.height * t.width / t.height : t.width
     }
 
-    function xS(e, t) {
+    function Bw(e, t) {
         return e.height != null ? e.height : !t || !t.height ? 0 : e.aspect !== !1 && e.width ? e.width * t.height / t.width : t.height
     }
 
-    function m1(e, t) {
+    function Jm(e, t) {
         return e === "center" ? t / 2 : e === "right" ? t : 0
     }
 
-    function y1(e, t) {
+    function Qm(e, t) {
         return e === "middle" ? t / 2 : e === "bottom" ? t : 0
     }
 
-    function oZ(e, t, n) {
-        const i = vS(t, n),
-            r = bS(t, i),
-            a = xS(t, i),
-            s = (t.x || 0) - m1(t.align, r),
-            o = (t.y || 0) - y1(t.baseline, a),
+    function pQ(e, t, n) {
+        const i = Iw(t, n),
+            r = zw(t, i),
+            s = Bw(t, i),
+            a = (t.x || 0) - Jm(t.align, r),
+            o = (t.y || 0) - Qm(t.baseline, s),
             l = !i.src && i.toDataURL ? i.toDataURL() : i.src || "";
-        e("href", l, zh["xmlns:xlink"], "xlink:href"), e("transform", nl(s, o)), e("width", r), e("height", a), e("preserveAspectRatio", t.aspect === !1 ? "none" : "xMidYMid")
+        e("href", l, $h["xmlns:xlink"], "xlink:href"), e("transform", Go(a, o)), e("width", r), e("height", s), e("preserveAspectRatio", t.aspect === !1 ? "none" : "xMidYMid")
     }
 
-    function lZ(e, t) {
+    function mQ(e, t) {
         const n = t.image,
-            i = bS(t, n),
-            r = xS(t, n),
-            a = (t.x || 0) - m1(t.align, i),
-            s = (t.y || 0) - y1(t.baseline, r);
-        return e.set(a, s, a + i, s + r)
+            i = zw(t, n),
+            r = Bw(t, n),
+            s = (t.x || 0) - Jm(t.align, i),
+            a = (t.y || 0) - Qm(t.baseline, r);
+        return e.set(s, a, s + i, a + r)
     }
 
-    function uZ(e, t, n) {
-        _r(t, i => {
+    function yQ(e, t, n) {
+        dr(t, i => {
             if (n && !n.intersects(i.bounds)) return;
-            const r = vS(i, this);
-            let a = bS(i, r),
-                s = xS(i, r);
-            if (a === 0 || s === 0) return;
-            let o = (i.x || 0) - m1(i.align, a),
-                l = (i.y || 0) - y1(i.baseline, s),
+            const r = Iw(i, this);
+            let s = zw(i, r),
+                a = Bw(i, r);
+            if (s === 0 || a === 0) return;
+            let o = (i.x || 0) - Jm(i.align, s),
+                l = (i.y || 0) - Qm(i.baseline, a),
                 u, c, f, h;
-            i.aspect !== !1 && (c = r.width / r.height, f = i.width / i.height, c === c && f === f && c !== f && (f < c ? (h = a / c, l += (s - h) / 2, s = h) : (h = s * c, o += (a - h) / 2, a = h))), (r.complete || r.toDataURL) && (rc(e, i), e.globalAlpha = (u = i.opacity) != null ? u : 1, e.imageSmoothingEnabled = i.smooth !== !1, e.drawImage(r, o, l, a, s))
+            i.aspect !== !1 && (c = r.width / r.height, f = i.width / i.height, c === c && f === f && c !== f && (f < c ? (h = s / c, l += (a - h) / 2, a = h) : (h = a * c, o += (s - h) / 2, s = h))), (r.complete || r.toDataURL) && (Yu(e, i), e.globalAlpha = (u = i.opacity) != null ? u : 1, e.imageSmoothingEnabled = i.smooth !== !1, e.drawImage(r, o, l, s, a))
         })
     }
-    var cZ = {
+    var vQ = {
             type: "image",
             tag: "image",
             nested: !1,
-            attr: oZ,
-            bound: lZ,
-            draw: uZ,
-            pick: p1(),
-            isect: Ii,
-            get: vS,
-            xOffset: m1,
-            yOffset: y1
+            attr: pQ,
+            bound: mQ,
+            draw: yQ,
+            pick: Km(),
+            isect: Ri,
+            get: Iw,
+            xOffset: Jm,
+            yOffset: Qm
         },
-        fZ = yS("line", TQ, WQ);
+        bQ = Lw("line", LJ, ZJ);
 
-    function hZ(e, t) {
+    function xQ(e, t) {
         var n = t.scaleX || 1,
             i = t.scaleY || 1;
-        (n !== 1 || i !== 1) && e("vector-effect", "non-scaling-stroke"), e("transform", GQ(t)), e("d", t.path)
+        (n !== 1 || i !== 1) && e("vector-effect", "non-scaling-stroke"), e("transform", KJ(t)), e("d", t.path)
     }
 
-    function _p(e, t) {
+    function ip(e, t) {
         var n = t.path;
         if (n == null) return !0;
         var i = t.x || 0,
             r = t.y || 0,
-            a = t.scaleX || 1,
-            s = t.scaleY || 1,
-            o = (t.angle || 0) * qs,
+            s = t.scaleX || 1,
+            a = t.scaleY || 1,
+            o = (t.angle || 0) * Da,
             l = t.pathCache;
-        (!l || l.path !== n) && ((t.pathCache = l = ic(n)).path = n), o && e.rotate && e.translate ? (e.translate(i, r), e.rotate(o), Ih(e, l, 0, 0, a, s), e.rotate(-o), e.translate(-i, -r)) : Ih(e, l, i, r, a, s)
+        (!l || l.path !== n) && ((t.pathCache = l = Hu(n)).path = n), o && e.rotate && e.translate ? (e.translate(i, r), e.rotate(o), kh(e, l, 0, 0, s, a), e.rotate(-o), e.translate(-i, -r)) : kh(e, l, i, r, s, a)
     }
 
-    function dZ(e, t) {
-        return _p(Td(e, t.angle), t) ? e.set(0, 0, 0, 0) : es(e, t, !0)
+    function _Q(e, t) {
+        return ip(yd(e, t.angle), t) ? e.set(0, 0, 0, 0) : qs(e, t, !0)
     }
-    var gZ = {
+    var wQ = {
         type: "path",
         tag: "path",
         nested: !1,
-        attr: hZ,
-        bound: dZ,
-        draw: dS(_p),
-        pick: gS(_p),
-        isect: cS(_p)
+        attr: xQ,
+        bound: _Q,
+        draw: Rw(ip),
+        pick: Dw(ip),
+        isect: Mw(ip)
     };
 
-    function pZ(e, t) {
-        e("d", Ic(null, t))
+    function SQ(e, t) {
+        e("d", kc(null, t))
     }
 
-    function mZ(e, t) {
+    function EQ(e, t) {
         var n, i;
-        return es(e.set(n = t.x || 0, i = t.y || 0, n + t.width || 0, i + t.height || 0), t)
+        return qs(e.set(n = t.x || 0, i = t.y || 0, n + t.width || 0, i + t.height || 0), t)
     }
 
-    function LT(e, t) {
-        e.beginPath(), Ic(e, t)
+    function J$(e, t) {
+        e.beginPath(), kc(e, t)
     }
-    var yZ = {
+    var CQ = {
         type: "rect",
         tag: "path",
         nested: !1,
-        attr: pZ,
-        bound: mZ,
-        draw: dS(LT),
-        pick: gS(LT),
-        isect: t4
+        attr: SQ,
+        bound: EQ,
+        draw: Rw(J$),
+        pick: Dw(J$),
+        isect: hP
     };
 
-    function vZ(e, t) {
-        e("transform", a4(t)), e("x2", t.x2 != null ? t.x2 - (t.x || 0) : 0), e("y2", t.y2 != null ? t.y2 - (t.y || 0) : 0)
+    function kQ(e, t) {
+        e("transform", mP(t)), e("x2", t.x2 != null ? t.x2 - (t.x || 0) : 0), e("y2", t.y2 != null ? t.y2 - (t.y || 0) : 0)
     }
 
-    function bZ(e, t) {
+    function AQ(e, t) {
         var n, i;
-        return es(e.set(n = t.x || 0, i = t.y || 0, t.x2 != null ? t.x2 : n, t.y2 != null ? t.y2 : i), t)
+        return qs(e.set(n = t.x || 0, i = t.y || 0, t.x2 != null ? t.x2 : n, t.y2 != null ? t.y2 : i), t)
     }
 
-    function u4(e, t, n) {
-        var i, r, a, s;
-        return t.stroke && ac(e, t, n) ? (i = t.x || 0, r = t.y || 0, a = t.x2 != null ? t.x2 : i, s = t.y2 != null ? t.y2 : r, e.beginPath(), e.moveTo(i, r), e.lineTo(a, s), !0) : !1
+    function xP(e, t, n) {
+        var i, r, s, a;
+        return t.stroke && Xu(e, t, n) ? (i = t.x || 0, r = t.y || 0, s = t.x2 != null ? t.x2 : i, a = t.y2 != null ? t.y2 : r, e.beginPath(), e.moveTo(i, r), e.lineTo(s, a), !0) : !1
     }
 
-    function xZ(e, t, n) {
-        _r(t, i => {
+    function $Q(e, t, n) {
+        dr(t, i => {
             if (!(n && !n.intersects(i.bounds))) {
                 var r = i.opacity == null ? 1 : i.opacity;
-                r && u4(e, i, r) && (rc(e, i), e.stroke())
+                r && xP(e, i, r) && (Yu(e, i), e.stroke())
             }
         })
     }
 
-    function _Z(e, t, n, i) {
-        return e.isPointInStroke ? u4(e, t, 1) && e.isPointInStroke(n, i) : !1
+    function TQ(e, t, n, i) {
+        return e.isPointInStroke ? xP(e, t, 1) && e.isPointInStroke(n, i) : !1
     }
-    var wZ = {
+    var MQ = {
             type: "rule",
             tag: "line",
             nested: !1,
-            attr: vZ,
-            bound: bZ,
-            draw: xZ,
-            pick: p1(_Z),
-            isect: n4
-        },
-        SZ = mS("shape", $Q),
-        EZ = mS("symbol", MQ, fS);
-    const IT = XR();
-    var dr = {
-        height: fa,
-        measureWidth: _S,
-        estimateWidth: R2,
-        width: R2,
-        canvas: c4
+            attr: kQ,
+            bound: AQ,
+            draw: $Q,
+            pick: Km(TQ),
+            isect: dP
+        },
+        OQ = Pw("shape", IJ),
+        FQ = Pw("symbol", zJ, Ow);
+    const Q$ = sD();
+    var sr = {
+        height: is,
+        measureWidth: jw,
+        estimateWidth: l2,
+        width: l2,
+        canvas: _P
     };
-    c4(!0);
+    _P(!0);
 
-    function c4(e) {
-        dr.width = e && Ns ? _S : R2
+    function _P(e) {
+        sr.width = e && Aa ? jw : l2
     }
 
-    function R2(e, t) {
-        return f4(Hs(e, t), fa(e))
+    function l2(e, t) {
+        return wP(Pa(e, t), is(e))
     }
 
-    function f4(e, t) {
+    function wP(e, t) {
         return ~~(.8 * e.length * t)
     }
 
-    function _S(e, t) {
-        return fa(e) <= 0 || !(t = Hs(e, t)) ? 0 : h4(t, v1(e))
+    function jw(e, t) {
+        return is(e) <= 0 || !(t = Pa(e, t)) ? 0 : SP(t, Zm(e))
     }
 
-    function h4(e, t) {
+    function SP(e, t) {
         const n = `(${t}) ${e}`;
-        let i = IT.get(n);
-        return i === void 0 && (Ns.font = t, i = Ns.measureText(e).width, IT.set(n, i)), i
+        let i = Q$.get(n);
+        return i === void 0 && (Aa.font = t, i = Aa.measureText(e).width, Q$.set(n, i)), i
     }
 
-    function fa(e) {
+    function is(e) {
         return e.fontSize != null ? +e.fontSize || 0 : 11
     }
 
-    function Ws(e) {
-        return e.lineHeight != null ? e.lineHeight : fa(e) + 2
+    function Na(e) {
+        return e.lineHeight != null ? e.lineHeight : is(e) + 2
     }
 
-    function OZ(e) {
-        return q(e) ? e.length > 1 ? e : e[0] : e
+    function RQ(e) {
+        return W(e) ? e.length > 1 ? e : e[0] : e
     }
 
-    function Md(e) {
-        return OZ(e.lineBreak && e.text && !q(e.text) ? e.text.split(e.lineBreak) : e.text)
+    function bd(e) {
+        return RQ(e.lineBreak && e.text && !W(e.text) ? e.text.split(e.lineBreak) : e.text)
     }
 
-    function wS(e) {
-        const t = Md(e);
-        return (q(t) ? t.length - 1 : 0) * Ws(e)
+    function Uw(e) {
+        const t = bd(e);
+        return (W(t) ? t.length - 1 : 0) * Na(e)
     }
 
-    function Hs(e, t) {
+    function Pa(e, t) {
         const n = t == null ? "" : (t + "").trim();
-        return e.limit > 0 && n.length ? kZ(e, n) : n
+        return e.limit > 0 && n.length ? NQ(e, n) : n
     }
 
-    function CZ(e) {
-        if (dr.width === _S) {
-            const t = v1(e);
-            return n => h4(n, t)
+    function DQ(e) {
+        if (sr.width === jw) {
+            const t = Zm(e);
+            return n => SP(n, t)
         } else {
-            const t = fa(e);
-            return n => f4(n, t)
+            const t = is(e);
+            return n => wP(n, t)
         }
     }
 
-    function kZ(e, t) {
+    function NQ(e, t) {
         var n = +e.limit,
-            i = CZ(e);
+            i = DQ(e);
         if (i(t) < n) return t;
         var r = e.ellipsis || "…",
-            a = e.dir === "rtl",
-            s = 0,
+            s = e.dir === "rtl",
+            a = 0,
             o = t.length,
             l;
-        if (n -= i(r), a) {
-            for (; s < o;) l = s + o >>> 1, i(t.slice(l)) > n ? s = l + 1 : o = l;
-            return r + t.slice(s)
+        if (n -= i(r), s) {
+            for (; a < o;) l = a + o >>> 1, i(t.slice(l)) > n ? a = l + 1 : o = l;
+            return r + t.slice(a)
         } else {
-            for (; s < o;) l = 1 + (s + o >>> 1), i(t.slice(0, l)) < n ? s = l : o = l - 1;
-            return t.slice(0, s) + r
+            for (; a < o;) l = 1 + (a + o >>> 1), i(t.slice(0, l)) < n ? a = l : o = l - 1;
+            return t.slice(0, a) + r
         }
     }
 
-    function Fd(e, t) {
+    function xd(e, t) {
         var n = e.font;
         return (t && n ? String(n).replace(/"/g, "'") : n) || "sans-serif"
     }
 
-    function v1(e, t) {
-        return (e.fontStyle ? e.fontStyle + " " : "") + (e.fontVariant ? e.fontVariant + " " : "") + (e.fontWeight ? e.fontWeight + " " : "") + fa(e) + "px " + Fd(e, t)
+    function Zm(e, t) {
+        return (e.fontStyle ? e.fontStyle + " " : "") + (e.fontVariant ? e.fontVariant + " " : "") + (e.fontWeight ? e.fontWeight + " " : "") + is(e) + "px " + xd(e, t)
     }
 
-    function SS(e) {
+    function Gw(e) {
         var t = e.baseline,
-            n = fa(e);
-        return Math.round(t === "top" ? .79 * n : t === "middle" ? .3 * n : t === "bottom" ? -.21 * n : t === "line-top" ? .29 * n + .5 * Ws(e) : t === "line-bottom" ? .29 * n - .5 * Ws(e) : 0)
+            n = is(e);
+        return Math.round(t === "top" ? .79 * n : t === "middle" ? .3 * n : t === "bottom" ? -.21 * n : t === "line-top" ? .29 * n + .5 * Na(e) : t === "line-bottom" ? .29 * n - .5 * Na(e) : 0)
     }
-    const AZ = {
+    const PQ = {
             left: "start",
             center: "middle",
             right: "end"
         },
-        dh = new At;
+        th = new kt;
 
-    function b1(e) {
+    function e1(e) {
         var t = e.x || 0,
             n = e.y || 0,
             i = e.radius || 0,
             r;
-        return i && (r = (e.theta || 0) - Bo, t += i * Math.cos(r), n += i * Math.sin(r)), dh.x1 = t, dh.y1 = n, dh
+        return i && (r = (e.theta || 0) - To, t += i * Math.cos(r), n += i * Math.sin(r)), th.x1 = t, th.y1 = n, th
     }
 
-    function TZ(e, t) {
+    function LQ(e, t) {
         var n = t.dx || 0,
-            i = (t.dy || 0) + SS(t),
-            r = b1(t),
-            a = r.x1,
-            s = r.y1,
+            i = (t.dy || 0) + Gw(t),
+            r = e1(t),
+            s = r.x1,
+            a = r.y1,
             o = t.angle || 0,
             l;
-        e("text-anchor", AZ[t.align] || "start"), o ? (l = nl(a, s) + " " + pS(o), (n || i) && (l += " " + nl(n, i))) : l = nl(a + n, s + i), e("transform", l)
+        e("text-anchor", PQ[t.align] || "start"), o ? (l = Go(s, a) + " " + Nw(o), (n || i) && (l += " " + Go(n, i))) : l = Go(s + n, a + i), e("transform", l)
     }
 
-    function ES(e, t, n) {
-        var i = dr.height(t),
+    function Ww(e, t, n) {
+        var i = sr.height(t),
             r = t.align,
-            a = b1(t),
-            s = a.x1,
-            o = a.y1,
+            s = e1(t),
+            a = s.x1,
+            o = s.y1,
             l = t.dx || 0,
-            u = (t.dy || 0) + SS(t) - Math.round(.8 * i),
-            c = Md(t),
+            u = (t.dy || 0) + Gw(t) - Math.round(.8 * i),
+            c = bd(t),
             f;
-        if (q(c) ? (i += Ws(t) * (c.length - 1), f = c.reduce((h, d) => Math.max(h, dr.width(t, d)), 0)) : f = dr.width(t, c), r === "center" ? l -= f / 2 : r === "right" && (l -= f), e.set(l += s, u += o, l + f, u + i), t.angle && !n) e.rotate(t.angle * qs, s, o);
-        else if (n === 2) return e.rotatedPoints(t.angle * qs, s, o);
+        if (W(c) ? (i += Na(t) * (c.length - 1), f = c.reduce((h, d) => Math.max(h, sr.width(t, d)), 0)) : f = sr.width(t, c), r === "center" ? l -= f / 2 : r === "right" && (l -= f), e.set(l += a, u += o, l + f, u + i), t.angle && !n) e.rotate(t.angle * Da, a, o);
+        else if (n === 2) return e.rotatedPoints(t.angle * Da, a, o);
         return e
     }
 
-    function $Z(e, t, n) {
-        _r(t, i => {
+    function IQ(e, t, n) {
+        dr(t, i => {
             var r = i.opacity == null ? 1 : i.opacity,
-                a, s, o, l, u, c, f;
+                s, a, o, l, u, c, f;
             if (!(n && !n.intersects(i.bounds) || r === 0 || i.fontSize <= 0 || i.text == null || i.text.length === 0)) {
-                if (e.font = v1(i), e.textAlign = i.align || "left", a = b1(i), s = a.x1, o = a.y1, i.angle && (e.save(), e.translate(s, o), e.rotate(i.angle * qs), s = o = 0), s += i.dx || 0, o += (i.dy || 0) + SS(i), c = Md(i), rc(e, i), q(c))
-                    for (u = Ws(i), l = 0; l < c.length; ++l) f = Hs(i, c[l]), i.fill && R0(e, i, r) && e.fillText(f, s, o), i.stroke && ac(e, i, r) && e.strokeText(f, s, o), o += u;
-                else f = Hs(i, c), i.fill && R0(e, i, r) && e.fillText(f, s, o), i.stroke && ac(e, i, r) && e.strokeText(f, s, o);
+                if (e.font = Zm(i), e.textAlign = i.align || "left", s = e1(i), a = s.x1, o = s.y1, i.angle && (e.save(), e.translate(a, o), e.rotate(i.angle * Da), a = o = 0), a += i.dx || 0, o += (i.dy || 0) + Gw(i), c = bd(i), Yu(e, i), W(c))
+                    for (u = Na(i), l = 0; l < c.length; ++l) f = Pa(i, c[l]), i.fill && p0(e, i, r) && e.fillText(f, a, o), i.stroke && Xu(e, i, r) && e.strokeText(f, a, o), o += u;
+                else f = Pa(i, c), i.fill && p0(e, i, r) && e.fillText(f, a, o), i.stroke && Xu(e, i, r) && e.strokeText(f, a, o);
                 i.angle && e.restore()
             }
         })
     }
 
-    function MZ(e, t, n, i, r, a) {
+    function zQ(e, t, n, i, r, s) {
         if (t.fontSize <= 0) return !1;
         if (!t.angle) return !0;
-        var s = b1(t),
-            o = s.x1,
-            l = s.y1,
-            u = ES(dh, t, 1),
-            c = -t.angle * qs,
+        var a = e1(t),
+            o = a.x1,
+            l = a.y1,
+            u = Ww(th, t, 1),
+            c = -t.angle * Da,
             f = Math.cos(c),
             h = Math.sin(c),
-            d = f * r - h * a + (o - f * o + h * l),
-            g = h * r + f * a + (l - h * o - f * l);
+            d = f * r - h * s + (o - f * o + h * l),
+            g = h * r + f * s + (l - h * o - f * l);
         return u.contains(d, g)
     }
 
-    function FZ(e, t) {
-        const n = ES(dh, e, 2);
-        return Eu(t, n[0], n[1], n[2], n[3]) || Eu(t, n[0], n[1], n[4], n[5]) || Eu(t, n[4], n[5], n[6], n[7]) || Eu(t, n[2], n[3], n[6], n[7])
+    function BQ(e, t) {
+        const n = Ww(th, e, 2);
+        return du(t, n[0], n[1], n[2], n[3]) || du(t, n[0], n[1], n[4], n[5]) || du(t, n[4], n[5], n[6], n[7]) || du(t, n[2], n[3], n[6], n[7])
     }
-    var DZ = {
+    var jQ = {
             type: "text",
             tag: "text",
             nested: !1,
-            attr: TZ,
-            bound: ES,
-            draw: $Z,
-            pick: p1(MZ),
-            isect: FZ
-        },
-        RZ = yS("trail", FQ, HQ),
-        wi = {
-            arc: UQ,
-            area: YQ,
-            group: sZ,
-            image: cZ,
-            line: fZ,
-            path: gZ,
-            rect: yZ,
-            rule: wZ,
-            shape: SZ,
-            symbol: EZ,
-            text: DZ,
-            trail: RZ
+            attr: LQ,
+            bound: Ww,
+            draw: IQ,
+            pick: Km(zQ),
+            isect: BQ
+        },
+        UQ = Lw("trail", BJ, eQ),
+        xi = {
+            arc: JJ,
+            area: tQ,
+            group: gQ,
+            image: vQ,
+            line: bQ,
+            path: wQ,
+            rect: CQ,
+            rule: MQ,
+            shape: OQ,
+            symbol: FQ,
+            text: jQ,
+            trail: UQ
         };
 
-    function P2(e, t, n) {
-        var i = wi[e.mark.marktype],
+    function u2(e, t, n) {
+        var i = xi[e.mark.marktype],
             r = t || i.bound;
-        return i.nested && (e = e.mark), r(e.bounds || (e.bounds = new At), e, n)
+        return i.nested && (e = e.mark), r(e.bounds || (e.bounds = new kt), e, n)
     }
-    var jT = {
+    var Z$ = {
         mark: null
     };
 
-    function d4(e, t, n) {
-        var i = wi[e.marktype],
+    function EP(e, t, n) {
+        var i = xi[e.marktype],
             r = i.bound,
-            a = e.items,
-            s = a && a.length,
+            s = e.items,
+            a = s && s.length,
             o, l, u, c;
-        if (i.nested) return s ? u = a[0] : (jT.mark = e, u = jT), c = P2(u, r, n), t = t && t.union(c) || c, t;
-        if (t = t || e.bounds && e.bounds.clear() || new At, s)
-            for (o = 0, l = a.length; o < l; ++o) t.union(P2(a[o], r, n));
+        if (i.nested) return a ? u = s[0] : (Z$.mark = e, u = Z$), c = u2(u, r, n), t = t && t.union(c) || c, t;
+        if (t = t || e.bounds && e.bounds.clear() || new kt, a)
+            for (o = 0, l = s.length; o < l; ++o) t.union(u2(s[o], r, n));
         return e.bounds = t
     }
-    const PZ = ["marktype", "name", "role", "interactive", "clip", "items", "zindex", "x", "y", "width", "height", "align", "baseline", "fill", "fillOpacity", "opacity", "blend", "stroke", "strokeOpacity", "strokeWidth", "strokeCap", "strokeDash", "strokeDashOffset", "strokeForeground", "strokeOffset", "startAngle", "endAngle", "innerRadius", "outerRadius", "cornerRadius", "padAngle", "cornerRadiusTopLeft", "cornerRadiusTopRight", "cornerRadiusBottomLeft", "cornerRadiusBottomRight", "interpolate", "tension", "orient", "defined", "url", "aspect", "smooth", "path", "scaleX", "scaleY", "x2", "y2", "size", "shape", "text", "angle", "theta", "radius", "dir", "dx", "dy", "ellipsis", "limit", "lineBreak", "lineHeight", "font", "fontSize", "fontWeight", "fontStyle", "fontVariant", "description", "aria", "ariaRole", "ariaRoleDescription"];
+    const GQ = ["marktype", "name", "role", "interactive", "clip", "items", "zindex", "x", "y", "width", "height", "align", "baseline", "fill", "fillOpacity", "opacity", "blend", "stroke", "strokeOpacity", "strokeWidth", "strokeCap", "strokeDash", "strokeDashOffset", "strokeForeground", "strokeOffset", "startAngle", "endAngle", "innerRadius", "outerRadius", "cornerRadius", "padAngle", "cornerRadiusTopLeft", "cornerRadiusTopRight", "cornerRadiusBottomLeft", "cornerRadiusBottomRight", "interpolate", "tension", "orient", "defined", "url", "aspect", "smooth", "path", "scaleX", "scaleY", "x2", "y2", "size", "shape", "text", "angle", "theta", "radius", "dir", "dx", "dy", "ellipsis", "limit", "lineBreak", "lineHeight", "font", "fontSize", "fontWeight", "fontStyle", "fontVariant", "description", "aria", "ariaRole", "ariaRoleDescription"];
 
-    function g4(e, t) {
-        return JSON.stringify(e, PZ, t)
+    function CP(e, t) {
+        return JSON.stringify(e, GQ, t)
     }
 
-    function p4(e) {
+    function kP(e) {
         const t = typeof e == "string" ? JSON.parse(e) : e;
-        return m4(t)
+        return AP(t)
     }
 
-    function m4(e) {
+    function AP(e) {
         var t = e.marktype,
             n = e.items,
-            i, r, a;
+            i, r, s;
         if (n)
-            for (r = 0, a = n.length; r < a; ++r) i = t ? "mark" : "group", n[r][i] = e, n[r].zindex && (n[r][i].zdirty = !0), (t || i) === "group" && m4(n[r]);
-        return t && d4(e), e
+            for (r = 0, s = n.length; r < s; ++r) i = t ? "mark" : "group", n[r][i] = e, n[r].zindex && (n[r][i].zdirty = !0), (t || i) === "group" && AP(n[r]);
+        return t && EP(e), e
     }
 
-    function OS(e) {
-        arguments.length ? this.root = p4(e) : (this.root = y4({
+    function qw(e) {
+        arguments.length ? this.root = kP(e) : (this.root = $P({
             marktype: "group",
             name: "root",
             role: "frame"
-        }), this.root.items = [new d1(this.root)])
+        }), this.root.items = [new Xm(this.root)])
     }
-    OS.prototype = {
+    qw.prototype = {
         toJSON(e) {
-            return g4(this.root, e || 0)
+            return CP(this.root, e || 0)
         },
         mark(e, t, n) {
             t = t || this.root.items[0];
-            const i = y4(e, t);
+            const i = $P(e, t);
             return t.items[n] = i, i.zindex && (i.group.zdirty = !0), i
         }
     };
 
-    function y4(e, t) {
+    function $P(e, t) {
         const n = {
-            bounds: new At,
+            bounds: new kt,
             clip: !!e.clip,
             group: t,
             interactive: e.interactive !== !1,
             items: [],
             marktype: e.marktype,
             name: e.name || void 0,
             role: e.role || void 0,
             zindex: e.zindex || 0
         };
         return e.aria != null && (n.aria = e.aria), e.description && (n.description = e.description), n
     }
 
-    function Os(e, t, n) {
+    function pa(e, t, n) {
         return !e && typeof document < "u" && document.createElement && (e = document), e ? n ? e.createElementNS(n, t) : e.createElement(t) : null
     }
 
-    function CS(e, t) {
+    function Hw(e, t) {
         t = t.toLowerCase();
         for (var n = e.childNodes, i = 0, r = n.length; i < r; ++i)
             if (n[i].tagName.toLowerCase() === t) return n[i]
     }
 
-    function Vn(e, t, n, i) {
+    function Yn(e, t, n, i) {
         var r = e.childNodes[t],
-            a;
-        return (!r || r.tagName.toLowerCase() !== n.toLowerCase()) && (a = r || null, r = Os(e.ownerDocument, n, i), e.insertBefore(r, a)), r
+            s;
+        return (!r || r.tagName.toLowerCase() !== n.toLowerCase()) && (s = r || null, r = pa(e.ownerDocument, n, i), e.insertBefore(r, s)), r
     }
 
-    function sr(e, t) {
+    function Zi(e, t) {
         for (var n = e.childNodes, i = n.length; i > t;) e.removeChild(n[--i]);
         return e
     }
 
-    function v4(e) {
+    function TP(e) {
         return "mark-" + e.marktype + (e.role ? " role-" + e.role : "") + (e.name ? " " + e.name : "")
     }
 
-    function x1(e, t) {
+    function t1(e, t) {
         const n = t.getBoundingClientRect();
         return [e.clientX - n.left - (t.clientLeft || 0), e.clientY - n.top - (t.clientTop || 0)]
     }
 
-    function NZ(e, t, n, i) {
+    function WQ(e, t, n, i) {
         var r = e && e.mark,
-            a, s;
-        if (r && (a = wi[r.marktype]).tip) {
-            for (s = x1(t, n), s[0] -= i[0], s[1] -= i[1]; e = e.mark.group;) s[0] -= e.x || 0, s[1] -= e.y || 0;
-            e = a.tip(r.items, s)
+            s, a;
+        if (r && (s = xi[r.marktype]).tip) {
+            for (a = t1(t, n), a[0] -= i[0], a[1] -= i[1]; e = e.mark.group;) a[0] -= e.x || 0, a[1] -= e.y || 0;
+            e = s.tip(r.items, a)
         }
         return e
     }
 
-    function Ys(e, t) {
-        this._active = null, this._handlers = {}, this._loader = e || Vm(), this._tooltip = t || LZ
+    function La(e, t) {
+        this._active = null, this._handlers = {}, this._loader = e || Mm(), this._tooltip = t || qQ
     }
 
-    function LZ(e, t, n, i) {
+    function qQ(e, t, n, i) {
         e.element().setAttribute("title", i || "")
     }
-    Ys.prototype = {
+    La.prototype = {
         initialize(e, t, n) {
             return this._el = e, this._obj = n || null, this.origin(t)
         },
         element() {
             return this._el
         },
         canvas() {
@@ -24490,54 +24510,54 @@
             return t < 0 ? e : e.slice(0, t)
         },
         handleHref(e, t, n) {
             this._loader.sanitize(n, {
                 context: "href"
             }).then(i => {
                 const r = new MouseEvent(e.type, e),
-                    a = Os(null, "a");
-                for (const s in i) a.setAttribute(s, i[s]);
-                a.dispatchEvent(r)
+                    s = pa(null, "a");
+                for (const a in i) s.setAttribute(a, i[a]);
+                s.dispatchEvent(r)
             }).catch(() => {})
         },
         handleTooltip(e, t, n) {
             if (t && t.tooltip != null) {
-                t = NZ(t, e, this.canvas(), this._origin);
+                t = WQ(t, e, this.canvas(), this._origin);
                 const i = n && t && t.tooltip || null;
                 this._tooltip.call(this._obj, this, e, t, i)
             }
         },
         getItemBoundingClientRect(e) {
             const t = this.canvas();
             if (!t) return;
             const n = t.getBoundingClientRect(),
                 i = this._origin,
                 r = e.bounds,
-                a = r.width(),
-                s = r.height();
+                s = r.width(),
+                a = r.height();
             let o = r.x1 + i[0] + n.left,
                 l = r.y1 + i[1] + n.top;
             for (; e.mark && (e = e.mark.group);) o += e.x || 0, l += e.y || 0;
             return {
                 x: o,
                 y: l,
-                width: a,
-                height: s,
+                width: s,
+                height: a,
                 left: o,
                 top: l,
-                right: o + a,
-                bottom: l + s
+                right: o + s,
+                bottom: l + a
             }
         }
     };
 
-    function ha(e) {
-        this._el = null, this._bgcolor = null, this._loader = new uS(e)
+    function rs(e) {
+        this._el = null, this._bgcolor = null, this._loader = new Tw(e)
     }
-    ha.prototype = {
+    rs.prototype = {
         initialize(e, t, n, i, r) {
             return this._el = e, this.resize(t, n, i, r)
         },
         element() {
             return this._el
         },
         canvas() {
@@ -24562,173 +24582,173 @@
             return this._ready ? this._ready.then(() => t) : Promise.resolve(t)
         },
         _load(e, t) {
             var n = this,
                 i = n._loader[e](t);
             if (!n._ready) {
                 const r = n._call;
-                n._ready = n._loader.ready().then(a => {
-                    a && r(), n._ready = null
+                n._ready = n._loader.ready().then(s => {
+                    s && r(), n._ready = null
                 })
             }
             return i
         },
         sanitizeURL(e) {
             return this._load("sanitizeURL", e)
         },
         loadImage(e) {
             return this._load("loadImage", e)
         }
     };
-    const IZ = "keydown",
-        jZ = "keypress",
-        zZ = "keyup",
-        b4 = "dragenter",
-        wp = "dragleave",
-        x4 = "dragover",
-        N2 = "mousedown",
-        BZ = "mouseup",
-        N0 = "mousemove",
-        gh = "mouseout",
-        _4 = "mouseover",
-        L0 = "click",
-        GZ = "dblclick",
-        UZ = "wheel",
-        w4 = "mousewheel",
-        I0 = "touchstart",
-        j0 = "touchmove",
-        z0 = "touchend",
-        qZ = [IZ, jZ, zZ, b4, wp, x4, N2, BZ, N0, gh, _4, L0, GZ, UZ, w4, I0, j0, z0],
-        L2 = N0,
-        Bh = gh,
-        I2 = L0;
-
-    function Dd(e, t) {
-        Ys.call(this, e, t), this._down = null, this._touch = null, this._first = !0, this._events = {}
+    const HQ = "keydown",
+        YQ = "keypress",
+        XQ = "keyup",
+        MP = "dragenter",
+        rp = "dragleave",
+        OP = "dragover",
+        c2 = "mousedown",
+        VQ = "mouseup",
+        y0 = "mousemove",
+        nh = "mouseout",
+        FP = "mouseover",
+        v0 = "click",
+        KQ = "dblclick",
+        JQ = "wheel",
+        RP = "mousewheel",
+        b0 = "touchstart",
+        x0 = "touchmove",
+        _0 = "touchend",
+        QQ = [HQ, YQ, XQ, MP, rp, OP, c2, VQ, y0, nh, FP, v0, KQ, JQ, RP, b0, x0, _0],
+        f2 = y0,
+        Th = nh,
+        h2 = v0;
+
+    function _d(e, t) {
+        La.call(this, e, t), this._down = null, this._touch = null, this._first = !0, this._events = {}
     }
-    const WZ = e => e === I0 || e === j0 || e === z0 ? [I0, j0, z0] : [e];
+    const ZQ = e => e === b0 || e === x0 || e === _0 ? [b0, x0, _0] : [e];
 
-    function zT(e, t) {
-        WZ(t).forEach(n => HZ(e, n))
+    function eT(e, t) {
+        ZQ(t).forEach(n => eZ(e, n))
     }
 
-    function HZ(e, t) {
+    function eZ(e, t) {
         const n = e.canvas();
         n && !e._events[t] && (e._events[t] = 1, n.addEventListener(t, e[t] ? i => e[t](i) : i => e.fire(t, i)))
     }
 
-    function BT(e, t, n) {
+    function tT(e, t, n) {
         return function(i) {
             const r = this._active,
-                a = this.pickEvent(i);
-            a === r ? this.fire(e, i) : ((!r || !r.exit) && this.fire(n, i), this._active = a, this.fire(t, i), this.fire(e, i))
+                s = this.pickEvent(i);
+            s === r ? this.fire(e, i) : ((!r || !r.exit) && this.fire(n, i), this._active = s, this.fire(t, i), this.fire(e, i))
         }
     }
 
-    function GT(e) {
+    function nT(e) {
         return function(t) {
             this.fire(e, t), this._active = null
         }
     }
-    Q(Dd, Ys, {
+    ee(_d, La, {
         initialize(e, t, n) {
-            return this._canvas = e && CS(e, "canvas"), [L0, N2, N0, gh, wp].forEach(i => zT(this, i)), Ys.prototype.initialize.call(this, e, t, n)
+            return this._canvas = e && Hw(e, "canvas"), [v0, c2, y0, nh, rp].forEach(i => eT(this, i)), La.prototype.initialize.call(this, e, t, n)
         },
         canvas() {
             return this._canvas
         },
         context() {
             return this._canvas.getContext("2d")
         },
-        events: qZ,
+        events: QQ,
         DOMMouseScroll(e) {
-            this.fire(w4, e)
+            this.fire(RP, e)
         },
-        mousemove: BT(N0, _4, gh),
-        dragover: BT(x4, b4, wp),
-        mouseout: GT(gh),
-        dragleave: GT(wp),
+        mousemove: tT(y0, FP, nh),
+        dragover: tT(OP, MP, rp),
+        mouseout: nT(nh),
+        dragleave: nT(rp),
         mousedown(e) {
-            this._down = this._active, this.fire(N2, e)
+            this._down = this._active, this.fire(c2, e)
         },
         click(e) {
-            this._down === this._active && (this.fire(L0, e), this._down = null)
+            this._down === this._active && (this.fire(v0, e), this._down = null)
         },
         touchstart(e) {
-            this._touch = this.pickEvent(e.changedTouches[0]), this._first && (this._active = this._touch, this._first = !1), this.fire(I0, e, !0)
+            this._touch = this.pickEvent(e.changedTouches[0]), this._first && (this._active = this._touch, this._first = !1), this.fire(b0, e, !0)
         },
         touchmove(e) {
-            this.fire(j0, e, !0)
+            this.fire(x0, e, !0)
         },
         touchend(e) {
-            this.fire(z0, e, !0), this._touch = null
+            this.fire(_0, e, !0), this._touch = null
         },
         fire(e, t, n) {
             const i = n ? this._touch : this._active,
                 r = this._handlers[e];
-            if (t.vegaType = e, e === I2 && i && i.href ? this.handleHref(t, i, i.href) : (e === L2 || e === Bh) && this.handleTooltip(t, i, e !== Bh), r)
-                for (let a = 0, s = r.length; a < s; ++a) r[a].handler.call(this._obj, t, i)
+            if (t.vegaType = e, e === h2 && i && i.href ? this.handleHref(t, i, i.href) : (e === f2 || e === Th) && this.handleTooltip(t, i, e !== Th), r)
+                for (let s = 0, a = r.length; s < a; ++s) r[s].handler.call(this._obj, t, i)
         },
         on(e, t) {
             const n = this.eventName(e),
                 i = this._handlers;
-            return this._handlerIndex(i[n], e, t) < 0 && (zT(this, e), (i[n] || (i[n] = [])).push({
+            return this._handlerIndex(i[n], e, t) < 0 && (eT(this, e), (i[n] || (i[n] = [])).push({
                 type: e,
                 handler: t
             })), this
         },
         off(e, t) {
             const n = this.eventName(e),
                 i = this._handlers[n],
                 r = this._handlerIndex(i, e, t);
             return r >= 0 && i.splice(r, 1), this
         },
         pickEvent(e) {
-            const t = x1(e, this._canvas),
+            const t = t1(e, this._canvas),
                 n = this._origin;
             return this.pick(this._scene, t[0], t[1], t[0] - n[0], t[1] - n[1])
         },
         pick(e, t, n, i, r) {
-            const a = this.context();
-            return wi[e.marktype].pick.call(this, a, e, t, n, i, r)
+            const s = this.context();
+            return xi[e.marktype].pick.call(this, s, e, t, n, i, r)
         }
     });
 
-    function YZ() {
+    function tZ() {
         return typeof window < "u" && window.devicePixelRatio || 1
     }
-    var XZ = YZ();
+    var nZ = tZ();
 
-    function VZ(e, t, n, i, r, a) {
-        const s = typeof HTMLElement < "u" && e instanceof HTMLElement && e.parentNode != null,
+    function iZ(e, t, n, i, r, s) {
+        const a = typeof HTMLElement < "u" && e instanceof HTMLElement && e.parentNode != null,
             o = e.getContext("2d"),
-            l = s ? XZ : r;
+            l = a ? nZ : r;
         e.width = t * l, e.height = n * l;
-        for (const u in a) o[u] = a[u];
-        return s && l !== 1 && (e.style.width = t + "px", e.style.height = n + "px"), o.pixelRatio = l, o.setTransform(l, 0, 0, l, l * i[0], l * i[1]), e
+        for (const u in s) o[u] = s[u];
+        return a && l !== 1 && (e.style.width = t + "px", e.style.height = n + "px"), o.pixelRatio = l, o.setTransform(l, 0, 0, l, l * i[0], l * i[1]), e
     }
 
-    function B0(e) {
-        ha.call(this, e), this._options = {}, this._redraw = !1, this._dirty = new At, this._tempb = new At
+    function w0(e) {
+        rs.call(this, e), this._options = {}, this._redraw = !1, this._dirty = new kt, this._tempb = new kt
     }
-    const UT = ha.prototype,
-        KZ = (e, t, n) => new At().set(0, 0, t, n).translate(-e[0], -e[1]);
+    const iT = rs.prototype,
+        rZ = (e, t, n) => new kt().set(0, 0, t, n).translate(-e[0], -e[1]);
 
-    function JZ(e, t, n) {
+    function sZ(e, t, n) {
         return t.expand(1).round(), e.pixelRatio % 1 && t.scale(e.pixelRatio).round().scale(1 / e.pixelRatio), t.translate(-(n[0] % 1), -(n[1] % 1)), e.beginPath(), e.rect(t.x1, t.y1, t.width(), t.height()), e.clip(), t
     }
-    Q(B0, ha, {
-        initialize(e, t, n, i, r, a) {
-            return this._options = a || {}, this._canvas = this._options.externalContext ? null : Ps(1, 1, this._options.type), e && this._canvas && (sr(e, 0).appendChild(this._canvas), this._canvas.setAttribute("class", "marks")), UT.initialize.call(this, e, t, n, i, r)
+    ee(w0, rs, {
+        initialize(e, t, n, i, r, s) {
+            return this._options = s || {}, this._canvas = this._options.externalContext ? null : ka(1, 1, this._options.type), e && this._canvas && (Zi(e, 0).appendChild(this._canvas), this._canvas.setAttribute("class", "marks")), iT.initialize.call(this, e, t, n, i, r)
         },
         resize(e, t, n, i) {
-            if (UT.resize.call(this, e, t, n, i), this._canvas) VZ(this._canvas, this._width, this._height, this._origin, this._scale, this._options.context);
+            if (iT.resize.call(this, e, t, n, i), this._canvas) iZ(this._canvas, this._width, this._height, this._origin, this._scale, this._options.context);
             else {
                 const r = this._options.externalContext;
-                r || G("CanvasRenderer is missing a valid canvas or context"), r.scale(this._scale, this._scale), r.translate(this._origin[0], this._origin[1])
+                r || U("CanvasRenderer is missing a valid canvas or context"), r.scale(this._scale, this._scale), r.translate(this._origin[0], this._origin[1])
             }
             return this._redraw = !0, this
         },
         canvas() {
             return this._canvas
         },
         context() {
@@ -24741,1639 +24761,1639 @@
             this._dirty.union(t)
         },
         _render(e) {
             const t = this.context(),
                 n = this._origin,
                 i = this._width,
                 r = this._height,
-                a = this._dirty,
-                s = KZ(n, i, r);
+                s = this._dirty,
+                a = rZ(n, i, r);
             t.save();
-            const o = this._redraw || a.empty() ? (this._redraw = !1, s.expand(1)) : JZ(t, s.intersect(a), n);
-            return this.clear(-n[0], -n[1], i, r), this.draw(t, e, o), t.restore(), a.clear(), this
+            const o = this._redraw || s.empty() ? (this._redraw = !1, a.expand(1)) : sZ(t, a.intersect(s), n);
+            return this.clear(-n[0], -n[1], i, r), this.draw(t, e, o), t.restore(), s.clear(), this
         },
         draw(e, t, n) {
-            const i = wi[t.marktype];
-            t.clip && XQ(e, t), i.draw.call(this, e, t, n), t.clip && e.restore()
+            const i = xi[t.marktype];
+            t.clip && nQ(e, t), i.draw.call(this, e, t, n), t.clip && e.restore()
         },
         clear(e, t, n, i) {
             const r = this._options,
-                a = this.context();
-            r.type !== "pdf" && !r.externalContext && a.clearRect(e, t, n, i), this._bgcolor != null && (a.fillStyle = this._bgcolor, a.fillRect(e, t, n, i))
+                s = this.context();
+            r.type !== "pdf" && !r.externalContext && s.clearRect(e, t, n, i), this._bgcolor != null && (s.fillStyle = this._bgcolor, s.fillRect(e, t, n, i))
         }
     });
 
-    function kS(e, t) {
-        Ys.call(this, e, t);
+    function Yw(e, t) {
+        La.call(this, e, t);
         const n = this;
-        n._hrefHandler = j2(n, (i, r) => {
+        n._hrefHandler = d2(n, (i, r) => {
             r && r.href && n.handleHref(i, r, r.href)
-        }), n._tooltipHandler = j2(n, (i, r) => {
-            n.handleTooltip(i, r, i.type !== Bh)
+        }), n._tooltipHandler = d2(n, (i, r) => {
+            n.handleTooltip(i, r, i.type !== Th)
         })
     }
-    const j2 = (e, t) => n => {
+    const d2 = (e, t) => n => {
         let i = n.target.__data__;
         i = Array.isArray(i) ? i[0] : i, n.vegaType = n.type, t.call(e._obj, n, i)
     };
-    Q(kS, Ys, {
+    ee(Yw, La, {
         initialize(e, t, n) {
             let i = this._svg;
-            return i && (i.removeEventListener(I2, this._hrefHandler), i.removeEventListener(L2, this._tooltipHandler), i.removeEventListener(Bh, this._tooltipHandler)), this._svg = i = e && CS(e, "svg"), i && (i.addEventListener(I2, this._hrefHandler), i.addEventListener(L2, this._tooltipHandler), i.addEventListener(Bh, this._tooltipHandler)), Ys.prototype.initialize.call(this, e, t, n)
+            return i && (i.removeEventListener(h2, this._hrefHandler), i.removeEventListener(f2, this._tooltipHandler), i.removeEventListener(Th, this._tooltipHandler)), this._svg = i = e && Hw(e, "svg"), i && (i.addEventListener(h2, this._hrefHandler), i.addEventListener(f2, this._tooltipHandler), i.addEventListener(Th, this._tooltipHandler)), La.prototype.initialize.call(this, e, t, n)
         },
         canvas() {
             return this._svg
         },
         on(e, t) {
             const n = this.eventName(e),
                 i = this._handlers;
             if (this._handlerIndex(i[n], e, t) < 0) {
-                const a = {
+                const s = {
                     type: e,
                     handler: t,
-                    listener: j2(this, t)
+                    listener: d2(this, t)
                 };
-                (i[n] || (i[n] = [])).push(a), this._svg && this._svg.addEventListener(n, a.listener)
+                (i[n] || (i[n] = [])).push(s), this._svg && this._svg.addEventListener(n, s.listener)
             }
             return this
         },
         off(e, t) {
             const n = this.eventName(e),
                 i = this._handlers[n],
                 r = this._handlerIndex(i, e, t);
             return r >= 0 && (this._svg && this._svg.removeEventListener(n, i[r].listener), i.splice(r, 1)), this
         }
     });
-    const S4 = "aria-hidden",
-        AS = "aria-label",
-        TS = "role",
-        $S = "aria-roledescription",
-        E4 = "graphics-object",
-        MS = "graphics-symbol",
-        O4 = (e, t, n) => ({
-            [TS]: e,
-            [$S]: t,
-            [AS]: n || void 0
+    const DP = "aria-hidden",
+        Xw = "aria-label",
+        Vw = "role",
+        Kw = "aria-roledescription",
+        NP = "graphics-object",
+        Jw = "graphics-symbol",
+        PP = (e, t, n) => ({
+            [Vw]: e,
+            [Kw]: t,
+            [Xw]: n || void 0
         }),
-        QZ = br(["axis-domain", "axis-grid", "axis-label", "axis-tick", "axis-title", "legend-band", "legend-entry", "legend-gradient", "legend-label", "legend-title", "legend-symbol", "title"]),
-        qT = {
+        aZ = fr(["axis-domain", "axis-grid", "axis-label", "axis-tick", "axis-title", "legend-band", "legend-entry", "legend-gradient", "legend-label", "legend-title", "legend-symbol", "title"]),
+        rT = {
             axis: {
                 desc: "axis",
-                caption: tee
+                caption: uZ
             },
             legend: {
                 desc: "legend",
-                caption: nee
+                caption: cZ
             },
             "title-text": {
                 desc: "title",
-                caption: e => `Title text '${HT(e)}'`
+                caption: e => `Title text '${aT(e)}'`
             },
             "title-subtitle": {
                 desc: "subtitle",
-                caption: e => `Subtitle text '${HT(e)}'`
+                caption: e => `Subtitle text '${aT(e)}'`
             }
         },
-        WT = {
-            ariaRole: TS,
-            ariaRoleDescription: $S,
-            description: AS
+        sT = {
+            ariaRole: Vw,
+            ariaRoleDescription: Kw,
+            description: Xw
         };
 
-    function C4(e, t) {
+    function LP(e, t) {
         const n = t.aria === !1;
-        if (e(S4, n || void 0), n || t.description == null)
-            for (const i in WT) e(WT[i], void 0);
+        if (e(DP, n || void 0), n || t.description == null)
+            for (const i in sT) e(sT[i], void 0);
         else {
             const i = t.mark.marktype;
-            e(AS, t.description), e(TS, t.ariaRole || (i === "group" ? E4 : MS)), e($S, t.ariaRoleDescription || `${i} mark`)
+            e(Xw, t.description), e(Vw, t.ariaRole || (i === "group" ? NP : Jw)), e(Kw, t.ariaRoleDescription || `${i} mark`)
         }
     }
 
-    function k4(e) {
+    function IP(e) {
         return e.aria === !1 ? {
-            [S4]: !0
-        } : QZ[e.role] ? null : qT[e.role] ? eee(e, qT[e.role]) : ZZ(e)
+            [DP]: !0
+        } : aZ[e.role] ? null : rT[e.role] ? lZ(e, rT[e.role]) : oZ(e)
     }
 
-    function ZZ(e) {
+    function oZ(e) {
         const t = e.marktype,
             n = t === "group" || t === "text" || e.items.some(i => i.description != null && i.aria !== !1);
-        return O4(n ? E4 : MS, `${t} mark container`, e.description)
+        return PP(n ? NP : Jw, `${t} mark container`, e.description)
     }
 
-    function eee(e, t) {
+    function lZ(e, t) {
         try {
             const n = e.items[0],
                 i = t.caption || (() => "");
-            return O4(t.role || MS, t.desc, n.description || i(n))
+            return PP(t.role || Jw, t.desc, n.description || i(n))
         } catch {
             return null
         }
     }
 
-    function HT(e) {
-        return ie(e.text).join(" ")
+    function aT(e) {
+        return se(e.text).join(" ")
     }
 
-    function tee(e) {
+    function uZ(e) {
         const t = e.datum,
             n = e.orient,
-            i = t.title ? A4(e) : null,
+            i = t.title ? zP(e) : null,
             r = e.context,
-            a = r.scales[t.scale].value,
-            s = r.dataflow.locale(),
-            o = a.type;
-        return `${n==="left"||n==="right"?"Y":"X"}-axis` + (i ? ` titled '${i}'` : "") + ` for a ${nc(o)?"discrete":o} scale with ${WN(s,a,e)}`
+            s = r.scales[t.scale].value,
+            a = r.dataflow.locale(),
+            o = s.type;
+        return `${n==="left"||n==="right"?"Y":"X"}-axis` + (i ? ` titled '${i}'` : "") + ` for a ${qu(o)?"discrete":o} scale with ${nP(a,s,e)}`
     }
 
-    function nee(e) {
+    function cZ(e) {
         const t = e.datum,
-            n = t.title ? A4(e) : null,
+            n = t.title ? zP(e) : null,
             i = `${t.type||""} legend`.trim(),
             r = t.scales,
-            a = Object.keys(r),
-            s = e.context,
-            o = s.scales[r[a[0]]].value,
-            l = s.dataflow.locale();
-        return ree(i) + (n ? ` titled '${n}'` : "") + ` for ${iee(a)} with ${WN(l,o,e)}`
+            s = Object.keys(r),
+            a = e.context,
+            o = a.scales[r[s[0]]].value,
+            l = a.dataflow.locale();
+        return hZ(i) + (n ? ` titled '${n}'` : "") + ` for ${fZ(s)} with ${nP(l,o,e)}`
     }
 
-    function A4(e) {
+    function zP(e) {
         try {
-            return ie(Le(e.items).items[0].text).join(" ")
+            return se(De(e.items).items[0].text).join(" ")
         } catch {
             return null
         }
     }
 
-    function iee(e) {
-        return e = e.map(t => t + (t === "fill" || t === "stroke" ? " color" : "")), e.length < 2 ? e[0] : e.slice(0, -1).join(", ") + " and " + Le(e)
+    function fZ(e) {
+        return e = e.map(t => t + (t === "fill" || t === "stroke" ? " color" : "")), e.length < 2 ? e[0] : e.slice(0, -1).join(", ") + " and " + De(e)
     }
 
-    function ree(e) {
+    function hZ(e) {
         return e.length ? e[0].toUpperCase() + e.slice(1) : e
     }
-    const T4 = e => (e + "").replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;"),
-        aee = e => T4(e).replace(/"/g, "&quot;").replace(/\t/g, "&#x9;").replace(/\n/g, "&#xA;").replace(/\r/g, "&#xD;");
+    const BP = e => (e + "").replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;"),
+        dZ = e => BP(e).replace(/"/g, "&quot;").replace(/\t/g, "&#x9;").replace(/\n/g, "&#xA;").replace(/\r/g, "&#xD;");
 
-    function FS() {
+    function Qw() {
         let e = "",
             t = "",
             n = "";
         const i = [],
             r = () => t = n = "",
-            a = l => {
+            s = l => {
                 t && (e += `${t}>${n}`, r()), i.push(l)
             },
-            s = (l, u) => (u != null && (t += ` ${l}="${aee(u)}"`), o),
+            a = (l, u) => (u != null && (t += ` ${l}="${dZ(u)}"`), o),
             o = {
                 open(l) {
-                    a(l), t = "<" + l;
+                    s(l), t = "<" + l;
                     for (var u = arguments.length, c = new Array(u > 1 ? u - 1 : 0), f = 1; f < u; f++) c[f - 1] = arguments[f];
                     for (const h of c)
-                        for (const d in h) s(d, h[d]);
+                        for (const d in h) a(d, h[d]);
                     return o
                 },
                 close() {
                     const l = i.pop();
                     return t ? e += t + (n ? `>${n}</${l}>` : "/>") : e += `</${l}>`, r(), o
                 },
-                attr: s,
-                text: l => (n += T4(l), o),
+                attr: a,
+                text: l => (n += BP(l), o),
                 toString: () => e
             };
         return o
     }
-    const $4 = e => M4(FS(), e) + "";
+    const jP = e => UP(Qw(), e) + "";
 
-    function M4(e, t) {
+    function UP(e, t) {
         if (e.open(t.tagName), t.hasAttributes()) {
             const n = t.attributes,
                 i = n.length;
             for (let r = 0; r < i; ++r) e.attr(n[r].name, n[r].value)
         }
         if (t.hasChildNodes()) {
             const n = t.childNodes;
-            for (const i of n) i.nodeType === 3 ? e.text(i.nodeValue) : M4(e, i)
+            for (const i of n) i.nodeType === 3 ? e.text(i.nodeValue) : UP(e, i)
         }
         return e.close()
     }
-    const G0 = {
+    const S0 = {
             fill: "fill",
             fillOpacity: "fill-opacity",
             stroke: "stroke",
             strokeOpacity: "stroke-opacity",
             strokeWidth: "stroke-width",
             strokeCap: "stroke-linecap",
             strokeJoin: "stroke-linejoin",
             strokeDash: "stroke-dasharray",
             strokeDashOffset: "stroke-dashoffset",
             strokeMiterLimit: "stroke-miterlimit",
             opacity: "opacity"
         },
-        U0 = {
+        E0 = {
             blend: "mix-blend-mode"
         },
-        F4 = {
+        GP = {
             fill: "none",
             "stroke-miterlimit": 10
         },
-        mf = 0,
-        YT = "http://www.w3.org/2000/xmlns/",
-        Ft = zh.xmlns;
+        nf = 0,
+        oT = "http://www.w3.org/2000/xmlns/",
+        $t = $h.xmlns;
 
-    function DS(e) {
-        ha.call(this, e), this._dirtyID = 0, this._dirty = [], this._svg = null, this._root = null, this._defs = null
+    function Zw(e) {
+        rs.call(this, e), this._dirtyID = 0, this._dirty = [], this._svg = null, this._root = null, this._defs = null
     }
-    const Ev = ha.prototype;
-    Q(DS, ha, {
+    const nv = rs.prototype;
+    ee(Zw, rs, {
         initialize(e, t, n, i, r) {
-            return this._defs = {}, this._clearDefs(), e && (this._svg = Vn(e, 0, "svg", Ft), this._svg.setAttributeNS(YT, "xmlns", Ft), this._svg.setAttributeNS(YT, "xmlns:xlink", zh["xmlns:xlink"]), this._svg.setAttribute("version", zh.version), this._svg.setAttribute("class", "marks"), sr(e, 1), this._root = Vn(this._svg, mf, "g", Ft), Cs(this._root, F4), sr(this._svg, mf + 1)), this.background(this._bgcolor), Ev.initialize.call(this, e, t, n, i, r)
+            return this._defs = {}, this._clearDefs(), e && (this._svg = Yn(e, 0, "svg", $t), this._svg.setAttributeNS(oT, "xmlns", $t), this._svg.setAttributeNS(oT, "xmlns:xlink", $h["xmlns:xlink"]), this._svg.setAttribute("version", $h.version), this._svg.setAttribute("class", "marks"), Zi(e, 1), this._root = Yn(this._svg, nf, "g", $t), ma(this._root, GP), Zi(this._svg, nf + 1)), this.background(this._bgcolor), nv.initialize.call(this, e, t, n, i, r)
         },
         background(e) {
-            return arguments.length && this._svg && this._svg.style.setProperty("background-color", e), Ev.background.apply(this, arguments)
+            return arguments.length && this._svg && this._svg.style.setProperty("background-color", e), nv.background.apply(this, arguments)
         },
         resize(e, t, n, i) {
-            return Ev.resize.call(this, e, t, n, i), this._svg && (Cs(this._svg, {
+            return nv.resize.call(this, e, t, n, i), this._svg && (ma(this._svg, {
                 width: this._width * this._scale,
                 height: this._height * this._scale,
                 viewBox: `0 0 ${this._width} ${this._height}`
             }), this._root.setAttribute("transform", `translate(${this._origin})`)), this._dirty = [], this
         },
         canvas() {
             return this._svg
         },
         svg() {
             const e = this._svg,
                 t = this._bgcolor;
             if (!e) return null;
             let n;
-            t && (e.removeAttribute("style"), n = Vn(e, mf, "rect", Ft), Cs(n, {
+            t && (e.removeAttribute("style"), n = Yn(e, nf, "rect", $t), ma(n, {
                 width: this._width,
                 height: this._height,
                 fill: t
             }));
-            const i = $4(e);
+            const i = jP(e);
             return t && (e.removeChild(n), this._svg.style.setProperty("background-color", t)), i
         },
         _render(e) {
-            return this._dirtyCheck() && (this._dirtyAll && this._clearDefs(), this.mark(this._root, e), sr(this._root, 1)), this.defs(), this._dirty = [], ++this._dirtyID, this
+            return this._dirtyCheck() && (this._dirtyAll && this._clearDefs(), this.mark(this._root, e), Zi(this._root, 1)), this.defs(), this._dirty = [], ++this._dirtyID, this
         },
         dirty(e) {
             e.dirty !== this._dirtyID && (e.dirty = this._dirtyID, this._dirty.push(e))
         },
         isDirty(e) {
             return this._dirtyAll || !e._svg || !e._svg.ownerSVGElement || e.dirty === this._dirtyID
         },
         _dirtyCheck() {
             this._dirtyAll = !0;
             const e = this._dirty;
             if (!e.length || !this._dirtyID) return !0;
             const t = ++this._dirtyID;
-            let n, i, r, a, s, o, l;
-            for (s = 0, o = e.length; s < o; ++s)
-                if (n = e[s], i = n.mark, i.marktype !== r && (r = i.marktype, a = wi[r]), i.zdirty && i.dirty !== t && (this._dirtyAll = !1, XT(n, t), i.items.forEach(u => {
+            let n, i, r, s, a, o, l;
+            for (a = 0, o = e.length; a < o; ++a)
+                if (n = e[a], i = n.mark, i.marktype !== r && (r = i.marktype, s = xi[r]), i.zdirty && i.dirty !== t && (this._dirtyAll = !1, lT(n, t), i.items.forEach(u => {
                         u.dirty = t
                     })), !i.zdirty) {
                     if (n.exit) {
-                        a.nested && i.items.length ? (l = i.items[0], l._svg && this._update(a, l._svg, l)) : n._svg && (l = n._svg.parentNode, l && l.removeChild(n._svg)), n._svg = null;
+                        s.nested && i.items.length ? (l = i.items[0], l._svg && this._update(s, l._svg, l)) : n._svg && (l = n._svg.parentNode, l && l.removeChild(n._svg)), n._svg = null;
                         continue
                     }
-                    n = a.nested ? i.items[0] : n, n._update !== t && (!n._svg || !n._svg.ownerSVGElement ? (this._dirtyAll = !1, XT(n, t)) : this._update(a, n._svg, n), n._update = t)
+                    n = s.nested ? i.items[0] : n, n._update !== t && (!n._svg || !n._svg.ownerSVGElement ? (this._dirtyAll = !1, lT(n, t)) : this._update(s, n._svg, n), n._update = t)
                 } return !this._dirtyAll
         },
         mark(e, t, n) {
             if (!this.isDirty(t)) return t._svg;
             const i = this._svg,
-                r = wi[t.marktype],
-                a = t.interactive === !1 ? "none" : null,
-                s = r.tag === "g",
-                o = VT(t, e, n, "g", i);
-            o.setAttribute("class", v4(t));
-            const l = k4(t);
-            for (const h in l) Tn(o, h, l[h]);
-            s || Tn(o, "pointer-events", a), Tn(o, "clip-path", t.clip ? lS(this, t, t.group) : null);
+                r = xi[t.marktype],
+                s = t.interactive === !1 ? "none" : null,
+                a = r.tag === "g",
+                o = uT(t, e, n, "g", i);
+            o.setAttribute("class", TP(t));
+            const l = IP(t);
+            for (const h in l) kn(o, h, l[h]);
+            a || kn(o, "pointer-events", s), kn(o, "clip-path", t.clip ? $w(this, t, t.group) : null);
             let u = null,
                 c = 0;
             const f = h => {
                 const d = this.isDirty(h),
-                    g = VT(h, o, u, r.tag, i);
-                d && (this._update(r, g, h), s && lee(this, g, h)), u = g, ++c
+                    g = uT(h, o, u, r.tag, i);
+                d && (this._update(r, g, h), a && mZ(this, g, h)), u = g, ++c
             };
-            return r.nested ? t.items.length && f(t.items[0]) : _r(t, f), sr(o, c), o
+            return r.nested ? t.items.length && f(t.items[0]) : dr(t, f), Zi(o, c), o
         },
         _update(e, t, n) {
-            La = t, fn = t.__values__, C4(ph, n), e.attr(ph, n, this);
-            const i = cee[e.type];
-            i && i.call(this, e, t, n), La && this.style(La, n)
+            As = t, un = t.__values__, LP(ih, n), e.attr(ih, n, this);
+            const i = vZ[e.type];
+            i && i.call(this, e, t, n), As && this.style(As, n)
         },
         style(e, t) {
             if (t != null) {
-                for (const n in G0) {
-                    let i = n === "font" ? Fd(t) : t[n];
-                    if (i === fn[n]) continue;
-                    const r = G0[n];
-                    i == null ? e.removeAttribute(r) : (aS(i) && (i = YN(i, this._defs.gradient, D4())), e.setAttribute(r, i + "")), fn[n] = i
+                for (const n in S0) {
+                    let i = n === "font" ? xd(t) : t[n];
+                    if (i === un[n]) continue;
+                    const r = S0[n];
+                    i == null ? e.removeAttribute(r) : (Cw(i) && (i = rP(i, this._defs.gradient, WP())), e.setAttribute(r, i + "")), un[n] = i
                 }
-                for (const n in U0) Sp(e, U0[n], t[n])
+                for (const n in E0) sp(e, E0[n], t[n])
             }
         },
         defs() {
             const e = this._svg,
                 t = this._defs;
             let n = t.el,
                 i = 0;
-            for (const r in t.gradient) n || (t.el = n = Vn(e, mf + 1, "defs", Ft)), i = see(n, t.gradient[r], i);
-            for (const r in t.clipping) n || (t.el = n = Vn(e, mf + 1, "defs", Ft)), i = oee(n, t.clipping[r], i);
-            n && (i === 0 ? (e.removeChild(n), t.el = null) : sr(n, i))
+            for (const r in t.gradient) n || (t.el = n = Yn(e, nf + 1, "defs", $t)), i = gZ(n, t.gradient[r], i);
+            for (const r in t.clipping) n || (t.el = n = Yn(e, nf + 1, "defs", $t)), i = pZ(n, t.clipping[r], i);
+            n && (i === 0 ? (e.removeChild(n), t.el = null) : Zi(n, i))
         },
         _clearDefs() {
             const e = this._defs;
             e.gradient = {}, e.clipping = {}
         }
     });
 
-    function XT(e, t) {
+    function lT(e, t) {
         for (; e && e.dirty !== t; e = e.mark.group)
             if (e.dirty = t, e.mark && e.mark.dirty !== t) e.mark.dirty = t;
             else return
     }
 
-    function see(e, t, n) {
-        let i, r, a;
+    function gZ(e, t, n) {
+        let i, r, s;
         if (t.gradient === "radial") {
-            let s = Vn(e, n++, "pattern", Ft);
-            Cs(s, {
-                id: D0 + t.id,
+            let a = Yn(e, n++, "pattern", $t);
+            ma(a, {
+                id: g0 + t.id,
                 viewBox: "0,0,1,1",
                 width: "100%",
                 height: "100%",
                 preserveAspectRatio: "xMidYMid slice"
-            }), s = Vn(s, 0, "rect", Ft), Cs(s, {
+            }), a = Yn(a, 0, "rect", $t), ma(a, {
                 width: 1,
                 height: 1,
-                fill: `url(${D4()}#${t.id})`
-            }), e = Vn(e, n++, "radialGradient", Ft), Cs(e, {
+                fill: `url(${WP()}#${t.id})`
+            }), e = Yn(e, n++, "radialGradient", $t), ma(e, {
                 id: t.id,
                 fx: t.x1,
                 fy: t.y1,
                 fr: t.r1,
                 cx: t.x2,
                 cy: t.y2,
                 r: t.r2
             })
-        } else e = Vn(e, n++, "linearGradient", Ft), Cs(e, {
+        } else e = Yn(e, n++, "linearGradient", $t), ma(e, {
             id: t.id,
             x1: t.x1,
             x2: t.x2,
             y1: t.y1,
             y2: t.y2
         });
-        for (i = 0, r = t.stops.length; i < r; ++i) a = Vn(e, i, "stop", Ft), a.setAttribute("offset", t.stops[i].offset), a.setAttribute("stop-color", t.stops[i].color);
-        return sr(e, i), n
+        for (i = 0, r = t.stops.length; i < r; ++i) s = Yn(e, i, "stop", $t), s.setAttribute("offset", t.stops[i].offset), s.setAttribute("stop-color", t.stops[i].color);
+        return Zi(e, i), n
     }
 
-    function oee(e, t, n) {
+    function pZ(e, t, n) {
         let i;
-        return e = Vn(e, n, "clipPath", Ft), e.setAttribute("id", t.id), t.path ? (i = Vn(e, 0, "path", Ft), i.setAttribute("d", t.path)) : (i = Vn(e, 0, "rect", Ft), Cs(i, {
+        return e = Yn(e, n, "clipPath", $t), e.setAttribute("id", t.id), t.path ? (i = Yn(e, 0, "path", $t), i.setAttribute("d", t.path)) : (i = Yn(e, 0, "rect", $t), ma(i, {
             x: 0,
             y: 0,
             width: t.width,
             height: t.height
-        })), sr(e, 1), n + 1
+        })), Zi(e, 1), n + 1
     }
 
-    function lee(e, t, n) {
+    function mZ(e, t, n) {
         t = t.lastChild.previousSibling;
         let i, r = 0;
-        _r(n, a => {
-            i = e.mark(t, a, i), ++r
-        }), sr(t, 1 + r)
+        dr(n, s => {
+            i = e.mark(t, s, i), ++r
+        }), Zi(t, 1 + r)
     }
 
-    function VT(e, t, n, i, r) {
-        let a = e._svg,
-            s;
-        if (!a && (s = t.ownerDocument, a = Os(s, i, Ft), e._svg = a, e.mark && (a.__data__ = e, a.__values__ = {
+    function uT(e, t, n, i, r) {
+        let s = e._svg,
+            a;
+        if (!s && (a = t.ownerDocument, s = pa(a, i, $t), e._svg = s, e.mark && (s.__data__ = e, s.__values__ = {
                 fill: "default"
             }, i === "g"))) {
-            const o = Os(s, "path", Ft);
-            a.appendChild(o), o.__data__ = e;
-            const l = Os(s, "g", Ft);
-            a.appendChild(l), l.__data__ = e;
-            const u = Os(s, "path", Ft);
-            a.appendChild(u), u.__data__ = e, u.__values__ = {
+            const o = pa(a, "path", $t);
+            s.appendChild(o), o.__data__ = e;
+            const l = pa(a, "g", $t);
+            s.appendChild(l), l.__data__ = e;
+            const u = pa(a, "path", $t);
+            s.appendChild(u), u.__data__ = e, u.__values__ = {
                 fill: "default"
             }
         }
-        return (a.ownerSVGElement !== r || uee(a, n)) && t.insertBefore(a, n ? n.nextSibling : t.firstChild), a
+        return (s.ownerSVGElement !== r || yZ(s, n)) && t.insertBefore(s, n ? n.nextSibling : t.firstChild), s
     }
 
-    function uee(e, t) {
+    function yZ(e, t) {
         return e.parentNode && e.parentNode.childNodes.length > 1 && e.previousSibling != t
     }
-    let La = null,
-        fn = null;
-    const cee = {
+    let As = null,
+        un = null;
+    const vZ = {
         group(e, t, n) {
-            const i = La = t.childNodes[2];
-            fn = i.__values__, e.foreground(ph, n, this), fn = t.__values__, La = t.childNodes[1], e.content(ph, n, this);
-            const r = La = t.childNodes[0];
-            e.background(ph, n, this);
-            const a = n.mark.interactive === !1 ? "none" : null;
-            if (a !== fn.events && (Tn(i, "pointer-events", a), Tn(r, "pointer-events", a), fn.events = a), n.strokeForeground && n.stroke) {
-                const s = n.fill;
-                Tn(i, "display", null), this.style(r, n), Tn(r, "stroke", null), s && (n.fill = null), fn = i.__values__, this.style(i, n), s && (n.fill = s), La = null
-            } else Tn(i, "display", "none")
+            const i = As = t.childNodes[2];
+            un = i.__values__, e.foreground(ih, n, this), un = t.__values__, As = t.childNodes[1], e.content(ih, n, this);
+            const r = As = t.childNodes[0];
+            e.background(ih, n, this);
+            const s = n.mark.interactive === !1 ? "none" : null;
+            if (s !== un.events && (kn(i, "pointer-events", s), kn(r, "pointer-events", s), un.events = s), n.strokeForeground && n.stroke) {
+                const a = n.fill;
+                kn(i, "display", null), this.style(r, n), kn(r, "stroke", null), a && (n.fill = null), un = i.__values__, this.style(i, n), a && (n.fill = a), As = null
+            } else kn(i, "display", "none")
         },
         image(e, t, n) {
-            n.smooth === !1 ? (Sp(t, "image-rendering", "optimizeSpeed"), Sp(t, "image-rendering", "pixelated")) : Sp(t, "image-rendering", null)
+            n.smooth === !1 ? (sp(t, "image-rendering", "optimizeSpeed"), sp(t, "image-rendering", "pixelated")) : sp(t, "image-rendering", null)
         },
         text(e, t, n) {
-            const i = Md(n);
-            let r, a, s, o;
-            q(i) ? (a = i.map(l => Hs(n, l)), r = a.join(`
-`), r !== fn.text && (sr(t, 0), s = t.ownerDocument, o = Ws(n), a.forEach((l, u) => {
-                const c = Os(s, "tspan", Ft);
+            const i = bd(n);
+            let r, s, a, o;
+            W(i) ? (s = i.map(l => Pa(n, l)), r = s.join(`
+`), r !== un.text && (Zi(t, 0), a = t.ownerDocument, o = Na(n), s.forEach((l, u) => {
+                const c = pa(a, "tspan", $t);
                 c.__data__ = n, c.textContent = l, u && (c.setAttribute("x", 0), c.setAttribute("dy", o)), t.appendChild(c)
-            }), fn.text = r)) : (a = Hs(n, i), a !== fn.text && (t.textContent = a, fn.text = a)), Tn(t, "font-family", Fd(n)), Tn(t, "font-size", fa(n) + "px"), Tn(t, "font-style", n.fontStyle), Tn(t, "font-variant", n.fontVariant), Tn(t, "font-weight", n.fontWeight)
+            }), un.text = r)) : (s = Pa(n, i), s !== un.text && (t.textContent = s, un.text = s)), kn(t, "font-family", xd(n)), kn(t, "font-size", is(n) + "px"), kn(t, "font-style", n.fontStyle), kn(t, "font-variant", n.fontVariant), kn(t, "font-weight", n.fontWeight)
         }
     };
 
-    function ph(e, t, n) {
-        t !== fn[e] && (n ? fee(La, e, t, n) : Tn(La, e, t), fn[e] = t)
+    function ih(e, t, n) {
+        t !== un[e] && (n ? bZ(As, e, t, n) : kn(As, e, t), un[e] = t)
     }
 
-    function Sp(e, t, n) {
-        n !== fn[t] && (n == null ? e.style.removeProperty(t) : e.style.setProperty(t, n + ""), fn[t] = n)
+    function sp(e, t, n) {
+        n !== un[t] && (n == null ? e.style.removeProperty(t) : e.style.setProperty(t, n + ""), un[t] = n)
     }
 
-    function Cs(e, t) {
-        for (const n in t) Tn(e, n, t[n])
+    function ma(e, t) {
+        for (const n in t) kn(e, n, t[n])
     }
 
-    function Tn(e, t, n) {
+    function kn(e, t, n) {
         n != null ? e.setAttribute(t, n) : e.removeAttribute(t)
     }
 
-    function fee(e, t, n, i) {
+    function bZ(e, t, n, i) {
         n != null ? e.setAttributeNS(i, t, n) : e.removeAttributeNS(i, t)
     }
 
-    function D4() {
+    function WP() {
         let e;
         return typeof window > "u" ? "" : (e = window.location).hash ? e.href.slice(0, -e.hash.length) : e.href
     }
 
-    function RS(e) {
-        ha.call(this, e), this._text = null, this._defs = {
+    function eS(e) {
+        rs.call(this, e), this._text = null, this._defs = {
             gradient: {},
             clipping: {}
         }
     }
-    Q(RS, ha, {
+    ee(eS, rs, {
         svg() {
             return this._text
         },
         _render(e) {
-            const t = FS();
-            t.open("svg", ke({}, zh, {
+            const t = Qw();
+            t.open("svg", Ae({}, $h, {
                 class: "marks",
                 width: this._width * this._scale,
                 height: this._height * this._scale,
                 viewBox: `0 0 ${this._width} ${this._height}`
             }));
             const n = this._bgcolor;
             return n && n !== "transparent" && n !== "none" && t.open("rect", {
                 width: this._width,
                 height: this._height,
                 fill: n
-            }).close(), t.open("g", F4, {
+            }).close(), t.open("g", GP, {
                 transform: "translate(" + this._origin + ")"
             }), this.mark(t, e), t.close(), this.defs(t), this._text = t.close() + "", this
         },
         mark(e, t) {
-            const n = wi[t.marktype],
+            const n = xi[t.marktype],
                 i = n.tag,
-                r = [C4, n.attr];
+                r = [LP, n.attr];
             e.open("g", {
-                class: v4(t),
-                "clip-path": t.clip ? lS(this, t, t.group) : null
-            }, k4(t), {
+                class: TP(t),
+                "clip-path": t.clip ? $w(this, t, t.group) : null
+            }, IP(t), {
                 "pointer-events": i !== "g" && t.interactive === !1 ? "none" : null
             });
-            const a = s => {
-                const o = this.href(s);
-                if (o && e.open("a", o), e.open(i, this.attr(t, s, r, i !== "g" ? i : null)), i === "text") {
-                    const l = Md(s);
-                    if (q(l)) {
+            const s = a => {
+                const o = this.href(a);
+                if (o && e.open("a", o), e.open(i, this.attr(t, a, r, i !== "g" ? i : null)), i === "text") {
+                    const l = bd(a);
+                    if (W(l)) {
                         const u = {
                             x: 0,
-                            dy: Ws(s)
+                            dy: Na(a)
                         };
-                        for (let c = 0; c < l.length; ++c) e.open("tspan", c ? u : null).text(Hs(s, l[c])).close()
-                    } else e.text(Hs(s, l))
+                        for (let c = 0; c < l.length; ++c) e.open("tspan", c ? u : null).text(Pa(a, l[c])).close()
+                    } else e.text(Pa(a, l))
                 } else if (i === "g") {
-                    const l = s.strokeForeground,
-                        u = s.fill,
-                        c = s.stroke;
-                    l && c && (s.stroke = null), e.open("path", this.attr(t, s, n.background, "bgrect")).close(), e.open("g", this.attr(t, s, n.content)), _r(s, f => this.mark(e, f)), e.close(), l && c ? (u && (s.fill = null), s.stroke = c, e.open("path", this.attr(t, s, n.foreground, "bgrect")).close(), u && (s.fill = u)) : e.open("path", this.attr(t, s, n.foreground, "bgfore")).close()
+                    const l = a.strokeForeground,
+                        u = a.fill,
+                        c = a.stroke;
+                    l && c && (a.stroke = null), e.open("path", this.attr(t, a, n.background, "bgrect")).close(), e.open("g", this.attr(t, a, n.content)), dr(a, f => this.mark(e, f)), e.close(), l && c ? (u && (a.fill = null), a.stroke = c, e.open("path", this.attr(t, a, n.foreground, "bgrect")).close(), u && (a.fill = u)) : e.open("path", this.attr(t, a, n.foreground, "bgfore")).close()
                 }
                 e.close(), o && e.close()
             };
-            return n.nested ? t.items && t.items.length && a(t.items[0]) : _r(t, a), e.close()
+            return n.nested ? t.items && t.items.length && s(t.items[0]) : dr(t, s), e.close()
         },
         href(e) {
             const t = e.href;
             let n;
             if (t) {
                 if (n = this._hrefs && this._hrefs[t]) return n;
                 this.sanitizeURL(t).then(i => {
                     i["xlink:href"] = i.href, i.href = null, (this._hrefs || (this._hrefs = {}))[t] = i
                 })
             }
             return null
         },
         attr(e, t, n, i) {
             const r = {},
-                a = (s, o, l, u) => {
-                    r[u || s] = o
+                s = (a, o, l, u) => {
+                    r[u || a] = o
                 };
-            return Array.isArray(n) ? n.forEach(s => s(a, t, this)) : n(a, t, this), i && hee(r, t, e, i, this._defs), r
+            return Array.isArray(n) ? n.forEach(a => a(s, t, this)) : n(s, t, this), i && xZ(r, t, e, i, this._defs), r
         },
         defs(e) {
             const t = this._defs.gradient,
                 n = this._defs.clipping;
             if (Object.keys(t).length + Object.keys(n).length !== 0) {
                 e.open("defs");
                 for (const r in t) {
-                    const a = t[r],
-                        s = a.stops;
-                    a.gradient === "radial" ? (e.open("pattern", {
-                        id: D0 + r,
+                    const s = t[r],
+                        a = s.stops;
+                    s.gradient === "radial" ? (e.open("pattern", {
+                        id: g0 + r,
                         viewBox: "0,0,1,1",
                         width: "100%",
                         height: "100%",
                         preserveAspectRatio: "xMidYMid slice"
                     }), e.open("rect", {
                         width: "1",
                         height: "1",
                         fill: "url(#" + r + ")"
                     }).close(), e.close(), e.open("radialGradient", {
                         id: r,
-                        fx: a.x1,
-                        fy: a.y1,
-                        fr: a.r1,
-                        cx: a.x2,
-                        cy: a.y2,
-                        r: a.r2
+                        fx: s.x1,
+                        fy: s.y1,
+                        fr: s.r1,
+                        cx: s.x2,
+                        cy: s.y2,
+                        r: s.r2
                     })) : e.open("linearGradient", {
                         id: r,
-                        x1: a.x1,
-                        x2: a.x2,
-                        y1: a.y1,
-                        y2: a.y2
+                        x1: s.x1,
+                        x2: s.x2,
+                        y1: s.y1,
+                        y2: s.y2
                     });
-                    for (let o = 0; o < s.length; ++o) e.open("stop", {
-                        offset: s[o].offset,
-                        "stop-color": s[o].color
+                    for (let o = 0; o < a.length; ++o) e.open("stop", {
+                        offset: a[o].offset,
+                        "stop-color": a[o].color
                     }).close();
                     e.close()
                 }
                 for (const r in n) {
-                    const a = n[r];
+                    const s = n[r];
                     e.open("clipPath", {
                         id: r
-                    }), a.path ? e.open("path", {
-                        d: a.path
+                    }), s.path ? e.open("path", {
+                        d: s.path
                     }).close() : e.open("rect", {
                         x: 0,
                         y: 0,
-                        width: a.width,
-                        height: a.height
+                        width: s.width,
+                        height: s.height
                     }).close(), e.close()
                 }
                 e.close()
             }
         }
     });
 
-    function hee(e, t, n, i, r) {
-        let a;
+    function xZ(e, t, n, i, r) {
+        let s;
         if (t == null || (i === "bgrect" && n.interactive === !1 && (e["pointer-events"] = "none"), i === "bgfore" && (n.interactive === !1 && (e["pointer-events"] = "none"), e.display = "none", t.fill !== null))) return e;
-        i === "image" && t.smooth === !1 && (a = ["image-rendering: optimizeSpeed;", "image-rendering: pixelated;"]), i === "text" && (e["font-family"] = Fd(t), e["font-size"] = fa(t) + "px", e["font-style"] = t.fontStyle, e["font-variant"] = t.fontVariant, e["font-weight"] = t.fontWeight);
-        for (const s in G0) {
-            let o = t[s];
-            const l = G0[s];
-            o === "transparent" && (l === "fill" || l === "stroke") || o != null && (aS(o) && (o = YN(o, r.gradient, "")), e[l] = o)
-        }
-        for (const s in U0) {
-            const o = t[s];
-            o != null && (a = a || [], a.push(`${U0[s]}: ${o};`))
-        }
-        return a && (e.style = a.join(" ")), e
-    }
-    const R4 = "canvas",
-        P4 = "png",
-        N4 = "svg",
-        L4 = "none",
-        ks = {
-            Canvas: R4,
-            PNG: P4,
-            SVG: N4,
-            None: L4
-        },
-        sc = {};
-    sc[R4] = sc[P4] = {
-        renderer: B0,
-        headless: B0,
-        handler: Dd
-    };
-    sc[N4] = {
-        renderer: DS,
-        headless: RS,
-        handler: kS
+        i === "image" && t.smooth === !1 && (s = ["image-rendering: optimizeSpeed;", "image-rendering: pixelated;"]), i === "text" && (e["font-family"] = xd(t), e["font-size"] = is(t) + "px", e["font-style"] = t.fontStyle, e["font-variant"] = t.fontVariant, e["font-weight"] = t.fontWeight);
+        for (const a in S0) {
+            let o = t[a];
+            const l = S0[a];
+            o === "transparent" && (l === "fill" || l === "stroke") || o != null && (Cw(o) && (o = rP(o, r.gradient, "")), e[l] = o)
+        }
+        for (const a in E0) {
+            const o = t[a];
+            o != null && (s = s || [], s.push(`${E0[a]}: ${o};`))
+        }
+        return s && (e.style = s.join(" ")), e
+    }
+    const qP = "canvas",
+        HP = "png",
+        YP = "svg",
+        XP = "none",
+        ya = {
+            Canvas: qP,
+            PNG: HP,
+            SVG: YP,
+            None: XP
+        },
+        Vu = {};
+    Vu[qP] = Vu[HP] = {
+        renderer: w0,
+        headless: w0,
+        handler: _d
+    };
+    Vu[YP] = {
+        renderer: Zw,
+        headless: eS,
+        handler: Yw
     };
-    sc[L4] = {};
+    Vu[XP] = {};
 
-    function _1(e, t) {
-        return e = String(e || "").toLowerCase(), arguments.length > 1 ? (sc[e] = t, this) : sc[e]
+    function n1(e, t) {
+        return e = String(e || "").toLowerCase(), arguments.length > 1 ? (Vu[e] = t, this) : Vu[e]
     }
 
-    function I4(e, t, n) {
+    function VP(e, t, n) {
         const i = [],
-            r = new At().union(t),
-            a = e.marktype;
-        return a ? j4(e, r, n, i) : a === "group" ? z4(e, r, n, i) : G("Intersect scene must be mark node or group item.")
+            r = new kt().union(t),
+            s = e.marktype;
+        return s ? KP(e, r, n, i) : s === "group" ? JP(e, r, n, i) : U("Intersect scene must be mark node or group item.")
     }
 
-    function j4(e, t, n, i) {
-        if (dee(e, t, n)) {
+    function KP(e, t, n, i) {
+        if (_Z(e, t, n)) {
             const r = e.items,
-                a = e.marktype,
-                s = r.length;
+                s = e.marktype,
+                a = r.length;
             let o = 0;
-            if (a === "group")
-                for (; o < s; ++o) z4(r[o], t, n, i);
+            if (s === "group")
+                for (; o < a; ++o) JP(r[o], t, n, i);
             else
-                for (const l = wi[a].isect; o < s; ++o) {
+                for (const l = xi[s].isect; o < a; ++o) {
                     const u = r[o];
-                    B4(u, t, l) && i.push(u)
+                    QP(u, t, l) && i.push(u)
                 }
         }
         return i
     }
 
-    function dee(e, t, n) {
+    function _Z(e, t, n) {
         return e.bounds && t.intersects(e.bounds) && (e.marktype === "group" || e.interactive !== !1 && (!n || n(e)))
     }
 
-    function z4(e, t, n, i) {
-        n && n(e.mark) && B4(e, t, wi.group.isect) && i.push(e);
+    function JP(e, t, n, i) {
+        n && n(e.mark) && QP(e, t, xi.group.isect) && i.push(e);
         const r = e.items,
-            a = r && r.length;
-        if (a) {
-            const s = e.x || 0,
+            s = r && r.length;
+        if (s) {
+            const a = e.x || 0,
                 o = e.y || 0;
-            t.translate(-s, -o);
-            for (let l = 0; l < a; ++l) j4(r[l], t, n, i);
-            t.translate(s, o)
+            t.translate(-a, -o);
+            for (let l = 0; l < s; ++l) KP(r[l], t, n, i);
+            t.translate(a, o)
         }
         return i
     }
 
-    function B4(e, t, n) {
+    function QP(e, t, n) {
         const i = e.bounds;
         return t.encloses(i) || t.intersects(i) && n(e, t)
     }
-    const Ov = new At;
+    const iv = new kt;
 
-    function G4(e) {
+    function ZP(e) {
         const t = e.clip;
-        if (Ae(t)) t(Td(Ov.clear()));
-        else if (t) Ov.set(0, 0, e.group.width, e.group.height);
+        if ($e(t)) t(yd(iv.clear()));
+        else if (t) iv.set(0, 0, e.group.width, e.group.height);
         else return;
-        e.bounds.intersect(Ov)
+        e.bounds.intersect(iv)
     }
-    const gee = 1e-9;
+    const wZ = 1e-9;
 
-    function PS(e, t, n) {
-        return e === t ? !0 : n === "path" ? U4(e, t) : e instanceof Date && t instanceof Date ? +e == +t : tt(e) && tt(t) ? Math.abs(e - t) <= gee : !e || !t || !se(e) && !se(t) ? e == t : pee(e, t)
+    function tS(e, t, n) {
+        return e === t ? !0 : n === "path" ? e4(e, t) : e instanceof Date && t instanceof Date ? +e == +t : Ze(e) && Ze(t) ? Math.abs(e - t) <= wZ : !e || !t || !ae(e) && !ae(t) ? e == t : SZ(e, t)
     }
 
-    function U4(e, t) {
-        return PS(ic(e), ic(t))
+    function e4(e, t) {
+        return tS(Hu(e), Hu(t))
     }
 
-    function pee(e, t) {
+    function SZ(e, t) {
         var n = Object.keys(e),
             i = Object.keys(t),
-            r, a;
+            r, s;
         if (n.length !== i.length) return !1;
-        for (n.sort(), i.sort(), a = n.length - 1; a >= 0; a--)
-            if (n[a] != i[a]) return !1;
-        for (a = n.length - 1; a >= 0; a--)
-            if (r = n[a], !PS(e[r], t[r], r)) return !1;
+        for (n.sort(), i.sort(), s = n.length - 1; s >= 0; s--)
+            if (n[s] != i[s]) return !1;
+        for (s = n.length - 1; s >= 0; s--)
+            if (r = n[s], !tS(e[r], t[r], r)) return !1;
         return typeof e == typeof t
     }
 
-    function mee() {
-        e4(), BJ()
+    function EZ() {
+        fP(), VK()
     }
-    const oc = "top",
-        or = "left",
-        cr = "right",
-        Xs = "bottom",
-        yee = "top-left",
-        vee = "top-right",
-        bee = "bottom-left",
-        xee = "bottom-right",
-        NS = "start",
-        z2 = "middle",
-        $n = "end",
-        _ee = "x",
-        wee = "y",
-        w1 = "group",
-        LS = "axis",
-        IS = "title",
-        See = "frame",
-        Eee = "scope",
-        jS = "legend",
-        q4 = "row-header",
-        W4 = "row-footer",
-        H4 = "row-title",
-        Y4 = "column-header",
-        X4 = "column-footer",
-        V4 = "column-title",
-        Oee = "padding",
-        Cee = "symbol",
-        K4 = "fit",
-        J4 = "fit-x",
-        Q4 = "fit-y",
-        kee = "pad",
-        zS = "none",
-        Rg = "all",
-        B2 = "each",
-        BS = "flush",
-        As = "column",
-        Ts = "row";
+    const Ku = "top",
+        er = "left",
+        nr = "right",
+        Ia = "bottom",
+        CZ = "top-left",
+        kZ = "top-right",
+        AZ = "bottom-left",
+        $Z = "bottom-right",
+        nS = "start",
+        g2 = "middle",
+        An = "end",
+        TZ = "x",
+        MZ = "y",
+        i1 = "group",
+        iS = "axis",
+        rS = "title",
+        OZ = "frame",
+        FZ = "scope",
+        sS = "legend",
+        t4 = "row-header",
+        n4 = "row-footer",
+        i4 = "row-title",
+        r4 = "column-header",
+        s4 = "column-footer",
+        a4 = "column-title",
+        RZ = "padding",
+        DZ = "symbol",
+        o4 = "fit",
+        l4 = "fit-x",
+        u4 = "fit-y",
+        NZ = "pad",
+        aS = "none",
+        bg = "all",
+        p2 = "each",
+        oS = "flush",
+        va = "column",
+        ba = "row";
 
-    function Z4(e) {
+    function c4(e) {
         L.call(this, null, e)
     }
-    Q(Z4, L, {
+    ee(c4, L, {
         transform(e, t) {
             const n = t.dataflow,
                 i = e.mark,
                 r = i.marktype,
-                a = wi[r],
-                s = a.bound;
+                s = xi[r],
+                a = s.bound;
             let o = i.bounds,
                 l;
-            if (a.nested) i.items.length && n.dirty(i.items[0]), o = Pg(i, s), i.items.forEach(u => {
+            if (s.nested) i.items.length && n.dirty(i.items[0]), o = xg(i, a), i.items.forEach(u => {
                 u.bounds.clear().union(o)
             });
-            else if (r === w1 || e.modified()) switch (t.visit(t.MOD, u => n.dirty(u)), o.clear(), i.items.forEach(u => o.union(Pg(u, s))), i.role) {
-                case LS:
-                case jS:
-                case IS:
+            else if (r === i1 || e.modified()) switch (t.visit(t.MOD, u => n.dirty(u)), o.clear(), i.items.forEach(u => o.union(xg(u, a))), i.role) {
+                case iS:
+                case sS:
+                case rS:
                     t.reflow()
             } else l = t.changed(t.REM), t.visit(t.ADD, u => {
-                o.union(Pg(u, s))
+                o.union(xg(u, a))
             }), t.visit(t.MOD, u => {
-                l = l || o.alignsWith(u.bounds), n.dirty(u), o.union(Pg(u, s))
+                l = l || o.alignsWith(u.bounds), n.dirty(u), o.union(xg(u, a))
             }), l && (o.clear(), i.items.forEach(u => o.union(u.bounds)));
-            return G4(i), t.modifies("bounds")
+            return ZP(i), t.modifies("bounds")
         }
     });
 
-    function Pg(e, t, n) {
+    function xg(e, t, n) {
         return t(e.bounds.clear(), e, n)
     }
-    const KT = ":vega_identifier:";
+    const cT = ":vega_identifier:";
 
-    function GS(e) {
+    function lS(e) {
         L.call(this, 0, e)
     }
-    GS.Definition = {
+    lS.Definition = {
         type: "Identifier",
         metadata: {
             modifies: !0
         },
         params: [{
             name: "as",
             type: "string",
             required: !0
         }]
     };
-    Q(GS, L, {
+    ee(lS, L, {
         transform(e, t) {
-            const n = Aee(t.dataflow),
+            const n = PZ(t.dataflow),
                 i = e.as;
             let r = n.value;
-            return t.visit(t.ADD, a => a[i] = a[i] || ++r), n.set(this.value = r), t
+            return t.visit(t.ADD, s => s[i] = s[i] || ++r), n.set(this.value = r), t
         }
     });
 
-    function Aee(e) {
-        return e._signals[KT] || (e._signals[KT] = e.add(0))
+    function PZ(e) {
+        return e._signals[cT] || (e._signals[cT] = e.add(0))
     }
 
-    function eL(e) {
+    function f4(e) {
         L.call(this, null, e)
     }
-    Q(eL, L, {
+    ee(f4, L, {
         transform(e, t) {
             let n = this.value;
-            n || (n = t.dataflow.scenegraph().mark(e.markdef, Tee(e), e.index), n.group.context = e.context, e.context.group || (e.context.group = n.group), n.source = this.source, n.clip = e.clip, n.interactive = e.interactive, this.value = n);
-            const i = n.marktype === w1 ? d1 : h1;
+            n || (n = t.dataflow.scenegraph().mark(e.markdef, LZ(e), e.index), n.group.context = e.context, e.context.group || (e.context.group = n.group), n.source = this.source, n.clip = e.clip, n.interactive = e.interactive, this.value = n);
+            const i = n.marktype === i1 ? Xm : Ym;
             return t.visit(t.ADD, r => i.call(r, n)), (e.modified("clip") || e.modified("interactive")) && (n.clip = e.clip, n.interactive = !!e.interactive, n.zdirty = !0, t.reflow()), n.items = t.source, t
         }
     });
 
-    function Tee(e) {
+    function LZ(e) {
         const t = e.groups,
             n = e.parent;
         return t && t.size === 1 ? t.get(Object.keys(t.object)[0]) : t && n ? t.lookup(n) : null
     }
 
-    function tL(e) {
+    function h4(e) {
         L.call(this, null, e)
     }
-    const JT = {
+    const fT = {
             parity: e => e.filter((t, n) => n % 2 ? t.opacity = 0 : 1),
             greedy: (e, t) => {
                 let n;
-                return e.filter((i, r) => !r || !nL(n.bounds, i.bounds, t) ? (n = i, 1) : i.opacity = 0)
+                return e.filter((i, r) => !r || !d4(n.bounds, i.bounds, t) ? (n = i, 1) : i.opacity = 0)
             }
         },
-        nL = (e, t, n) => n > Math.max(t.x1 - e.x2, e.x1 - t.x2, t.y1 - e.y2, e.y1 - t.y2),
-        QT = (e, t) => {
-            for (var n = 1, i = e.length, r = e[0].bounds, a; n < i; r = a, ++n)
-                if (nL(r, a = e[n].bounds, t)) return !0
+        d4 = (e, t, n) => n > Math.max(t.x1 - e.x2, e.x1 - t.x2, t.y1 - e.y2, e.y1 - t.y2),
+        hT = (e, t) => {
+            for (var n = 1, i = e.length, r = e[0].bounds, s; n < i; r = s, ++n)
+                if (d4(r, s = e[n].bounds, t)) return !0
         },
-        $ee = e => {
+        IZ = e => {
             const t = e.bounds;
             return t.width() > 1 && t.height() > 1
         },
-        Mee = (e, t, n) => {
+        zZ = (e, t, n) => {
             var i = e.range(),
-                r = new At;
-            return t === oc || t === Xs ? r.set(i[0], -1 / 0, i[1], 1 / 0) : r.set(-1 / 0, i[0], 1 / 0, i[1]), r.expand(n || 1), a => r.encloses(a.bounds)
+                r = new kt;
+            return t === Ku || t === Ia ? r.set(i[0], -1 / 0, i[1], 1 / 0) : r.set(-1 / 0, i[0], 1 / 0, i[1]), r.expand(n || 1), s => r.encloses(s.bounds)
         },
-        ZT = e => (e.forEach(t => t.opacity = 1), e),
-        e3 = (e, t) => e.reflow(t.modified()).modifies("opacity");
-    Q(tL, L, {
+        dT = e => (e.forEach(t => t.opacity = 1), e),
+        gT = (e, t) => e.reflow(t.modified()).modifies("opacity");
+    ee(h4, L, {
         transform(e, t) {
-            const n = JT[e.method] || JT.parity,
+            const n = fT[e.method] || fT.parity,
                 i = e.separation || 0;
             let r = t.materialize(t.SOURCE).source,
-                a, s;
+                s, a;
             if (!r || !r.length) return;
-            if (!e.method) return e.modified("method") && (ZT(r), t = e3(t, e)), t;
-            if (r = r.filter($ee), !r.length) return;
-            if (e.sort && (r = r.slice().sort(e.sort)), a = ZT(r), t = e3(t, e), a.length >= 3 && QT(a, i)) {
-                do a = n(a, i); while (a.length >= 3 && QT(a, i));
-                a.length < 3 && !Le(r).opacity && (a.length > 1 && (Le(a).opacity = 0), Le(r).opacity = 1)
+            if (!e.method) return e.modified("method") && (dT(r), t = gT(t, e)), t;
+            if (r = r.filter(IZ), !r.length) return;
+            if (e.sort && (r = r.slice().sort(e.sort)), s = dT(r), t = gT(t, e), s.length >= 3 && hT(s, i)) {
+                do s = n(s, i); while (s.length >= 3 && hT(s, i));
+                s.length < 3 && !De(r).opacity && (s.length > 1 && (De(s).opacity = 0), De(r).opacity = 1)
             }
-            e.boundScale && e.boundTolerance >= 0 && (s = Mee(e.boundScale, e.boundOrient, +e.boundTolerance), r.forEach(l => {
-                s(l) || (l.opacity = 0)
+            e.boundScale && e.boundTolerance >= 0 && (a = zZ(e.boundScale, e.boundOrient, +e.boundTolerance), r.forEach(l => {
+                a(l) || (l.opacity = 0)
             }));
-            const o = a[0].mark.bounds.clear();
+            const o = s[0].mark.bounds.clear();
             return r.forEach(l => {
                 l.opacity && o.union(l.bounds)
             }), t
         }
     });
 
-    function iL(e) {
+    function g4(e) {
         L.call(this, null, e)
     }
-    Q(iL, L, {
+    ee(g4, L, {
         transform(e, t) {
             const n = t.dataflow;
             if (t.visit(t.ALL, i => n.dirty(i)), t.fields && t.fields.zindex) {
                 const i = t.source && t.source[0];
                 i && (i.mark.zdirty = !0)
             }
         }
     });
-    const cn = new At;
+    const ln = new kt;
 
-    function Ou(e, t, n) {
+    function gu(e, t, n) {
         return e[t] === n ? 0 : (e[t] = n, 1)
     }
 
-    function Fee(e) {
+    function BZ(e) {
         var t = e.items[0].orient;
-        return t === or || t === cr
+        return t === er || t === nr
     }
 
-    function Dee(e) {
+    function jZ(e) {
         let t = +e.grid;
         return [e.ticks ? t++ : -1, e.labels ? t++ : -1, t + +e.domain]
     }
 
-    function Ree(e, t, n, i) {
+    function UZ(e, t, n, i) {
         var r = t.items[0],
-            a = r.datum,
-            s = r.translate != null ? r.translate : .5,
+            s = r.datum,
+            a = r.translate != null ? r.translate : .5,
             o = r.orient,
-            l = Dee(a),
+            l = jZ(s),
             u = r.range,
             c = r.offset,
             f = r.position,
             h = r.minExtent,
             d = r.maxExtent,
-            g = a.title && r.items[l[2]].items[0],
+            g = s.title && r.items[l[2]].items[0],
             p = r.titlePadding,
             m = r.bounds,
-            y = g && wS(g),
+            y = g && Uw(g),
             v = 0,
             b = 0,
             x, _;
-        switch (cn.clear().union(m), m.clear(), (x = l[0]) > -1 && m.union(r.items[x].bounds), (x = l[1]) > -1 && m.union(r.items[x].bounds), o) {
-            case oc:
-                v = f || 0, b = -c, _ = Math.max(h, Math.min(d, -m.y1)), m.add(0, -_).add(u, 0), g && Ng(e, g, _, p, y, 0, -1, m);
+        switch (ln.clear().union(m), m.clear(), (x = l[0]) > -1 && m.union(r.items[x].bounds), (x = l[1]) > -1 && m.union(r.items[x].bounds), o) {
+            case Ku:
+                v = f || 0, b = -c, _ = Math.max(h, Math.min(d, -m.y1)), m.add(0, -_).add(u, 0), g && _g(e, g, _, p, y, 0, -1, m);
                 break;
-            case or:
-                v = -c, b = f || 0, _ = Math.max(h, Math.min(d, -m.x1)), m.add(-_, 0).add(0, u), g && Ng(e, g, _, p, y, 1, -1, m);
+            case er:
+                v = -c, b = f || 0, _ = Math.max(h, Math.min(d, -m.x1)), m.add(-_, 0).add(0, u), g && _g(e, g, _, p, y, 1, -1, m);
                 break;
-            case cr:
-                v = n + c, b = f || 0, _ = Math.max(h, Math.min(d, m.x2)), m.add(0, 0).add(_, u), g && Ng(e, g, _, p, y, 1, 1, m);
+            case nr:
+                v = n + c, b = f || 0, _ = Math.max(h, Math.min(d, m.x2)), m.add(0, 0).add(_, u), g && _g(e, g, _, p, y, 1, 1, m);
                 break;
-            case Xs:
-                v = f || 0, b = i + c, _ = Math.max(h, Math.min(d, m.y2)), m.add(0, 0).add(u, _), g && Ng(e, g, _, p, 0, 0, 1, m);
+            case Ia:
+                v = f || 0, b = i + c, _ = Math.max(h, Math.min(d, m.y2)), m.add(0, 0).add(u, _), g && _g(e, g, _, p, 0, 0, 1, m);
                 break;
             default:
                 v = r.x, b = r.y
         }
-        return es(m.translate(v, b), r), Ou(r, "x", v + s) | Ou(r, "y", b + s) && (r.bounds = cn, e.dirty(r), r.bounds = m, e.dirty(r)), r.mark.bounds.clear().union(m)
+        return qs(m.translate(v, b), r), gu(r, "x", v + a) | gu(r, "y", b + a) && (r.bounds = ln, e.dirty(r), r.bounds = m, e.dirty(r)), r.mark.bounds.clear().union(m)
     }
 
-    function Ng(e, t, n, i, r, a, s, o) {
+    function _g(e, t, n, i, r, s, a, o) {
         const l = t.bounds;
         if (t.auto) {
-            const u = s * (n + r + i);
+            const u = a * (n + r + i);
             let c = 0,
                 f = 0;
-            e.dirty(t), a ? c = (t.x || 0) - (t.x = u) : f = (t.y || 0) - (t.y = u), t.mark.bounds.clear().union(l.translate(-c, -f)), e.dirty(t)
+            e.dirty(t), s ? c = (t.x || 0) - (t.x = u) : f = (t.y || 0) - (t.y = u), t.mark.bounds.clear().union(l.translate(-c, -f)), e.dirty(t)
         }
         o.union(l)
     }
-    const t3 = (e, t) => Math.floor(Math.min(e, t)),
-        n3 = (e, t) => Math.ceil(Math.max(e, t));
+    const pT = (e, t) => Math.floor(Math.min(e, t)),
+        mT = (e, t) => Math.ceil(Math.max(e, t));
 
-    function Pee(e) {
+    function GZ(e) {
         var t = e.items,
             n = t.length,
             i = 0,
-            r, a;
-        const s = {
+            r, s;
+        const a = {
             marks: [],
             rowheaders: [],
             rowfooters: [],
             colheaders: [],
             colfooters: [],
             rowtitle: null,
             coltitle: null
         };
         for (; i < n; ++i)
-            if (r = t[i], a = r.items, r.marktype === w1) switch (r.role) {
-                case LS:
-                case jS:
-                case IS:
+            if (r = t[i], s = r.items, r.marktype === i1) switch (r.role) {
+                case iS:
+                case sS:
+                case rS:
                     break;
-                case q4:
-                    s.rowheaders.push(...a);
+                case t4:
+                    a.rowheaders.push(...s);
                     break;
-                case W4:
-                    s.rowfooters.push(...a);
+                case n4:
+                    a.rowfooters.push(...s);
                     break;
-                case Y4:
-                    s.colheaders.push(...a);
+                case r4:
+                    a.colheaders.push(...s);
                     break;
-                case X4:
-                    s.colfooters.push(...a);
+                case s4:
+                    a.colfooters.push(...s);
                     break;
-                case H4:
-                    s.rowtitle = a[0];
+                case i4:
+                    a.rowtitle = s[0];
                     break;
-                case V4:
-                    s.coltitle = a[0];
+                case a4:
+                    a.coltitle = s[0];
                     break;
                 default:
-                    s.marks.push(...a)
+                    a.marks.push(...s)
             }
-        return s
+        return a
     }
 
-    function Nee(e) {
-        return new At().set(0, 0, e.width || 0, e.height || 0)
+    function WZ(e) {
+        return new kt().set(0, 0, e.width || 0, e.height || 0)
     }
 
-    function Lee(e) {
+    function qZ(e) {
         const t = e.bounds.clone();
         return t.empty() ? t.set(0, 0, 0, 0) : t.translate(-(e.x || 0), -(e.y || 0))
     }
 
-    function ft(e, t, n) {
-        const i = se(e) ? e[t] : e;
+    function ct(e, t, n) {
+        const i = ae(e) ? e[t] : e;
         return i ?? (n !== void 0 ? n : 0)
     }
 
-    function i3(e) {
+    function yT(e) {
         return e < 0 ? Math.ceil(-e) : 0
     }
 
-    function rL(e, t, n) {
+    function p4(e, t, n) {
         var i = !n.nodirty,
-            r = n.bounds === BS ? Nee : Lee,
-            a = cn.set(0, 0, 0, 0),
-            s = ft(n.align, As),
-            o = ft(n.align, Ts),
-            l = ft(n.padding, As),
-            u = ft(n.padding, Ts),
+            r = n.bounds === oS ? WZ : qZ,
+            s = ln.set(0, 0, 0, 0),
+            a = ct(n.align, va),
+            o = ct(n.align, ba),
+            l = ct(n.padding, va),
+            u = ct(n.padding, ba),
             c = n.columns || t.length,
             f = c <= 0 ? 1 : Math.ceil(t.length / c),
             h = t.length,
             d = Array(h),
             g = Array(c),
             p = 0,
             m = Array(h),
             y = Array(f),
             v = 0,
             b = Array(h),
             x = Array(h),
             _ = Array(h),
-            S, w, O, k, C, E, T, A, F, $, D;
+            S, w, E, A, C, k, R, $, T, M, F;
         for (w = 0; w < c; ++w) g[w] = 0;
         for (w = 0; w < f; ++w) y[w] = 0;
-        for (w = 0; w < h; ++w) E = t[w], C = _[w] = r(E), E.x = E.x || 0, b[w] = 0, E.y = E.y || 0, x[w] = 0, O = w % c, k = ~~(w / c), p = Math.max(p, T = Math.ceil(C.x2)), v = Math.max(v, A = Math.ceil(C.y2)), g[O] = Math.max(g[O], T), y[k] = Math.max(y[k], A), d[w] = l + i3(C.x1), m[w] = u + i3(C.y1), i && e.dirty(t[w]);
+        for (w = 0; w < h; ++w) k = t[w], C = _[w] = r(k), k.x = k.x || 0, b[w] = 0, k.y = k.y || 0, x[w] = 0, E = w % c, A = ~~(w / c), p = Math.max(p, R = Math.ceil(C.x2)), v = Math.max(v, $ = Math.ceil(C.y2)), g[E] = Math.max(g[E], R), y[A] = Math.max(y[A], $), d[w] = l + yT(C.x1), m[w] = u + yT(C.y1), i && e.dirty(t[w]);
         for (w = 0; w < h; ++w) w % c === 0 && (d[w] = 0), w < c && (m[w] = 0);
-        if (s === B2)
-            for (O = 1; O < c; ++O) {
-                for (D = 0, w = O; w < h; w += c) D < d[w] && (D = d[w]);
-                for (w = O; w < h; w += c) d[w] = D + g[O - 1]
-            } else if (s === Rg) {
-                for (D = 0, w = 0; w < h; ++w) w % c && D < d[w] && (D = d[w]);
-                for (w = 0; w < h; ++w) w % c && (d[w] = D + p)
+        if (a === p2)
+            for (E = 1; E < c; ++E) {
+                for (F = 0, w = E; w < h; w += c) F < d[w] && (F = d[w]);
+                for (w = E; w < h; w += c) d[w] = F + g[E - 1]
+            } else if (a === bg) {
+                for (F = 0, w = 0; w < h; ++w) w % c && F < d[w] && (F = d[w]);
+                for (w = 0; w < h; ++w) w % c && (d[w] = F + p)
             } else
-                for (s = !1, O = 1; O < c; ++O)
-                    for (w = O; w < h; w += c) d[w] += g[O - 1];
-        if (o === B2)
-            for (k = 1; k < f; ++k) {
-                for (D = 0, w = k * c, S = w + c; w < S; ++w) D < m[w] && (D = m[w]);
-                for (w = k * c; w < S; ++w) m[w] = D + y[k - 1]
-            } else if (o === Rg) {
-                for (D = 0, w = c; w < h; ++w) D < m[w] && (D = m[w]);
-                for (w = c; w < h; ++w) m[w] = D + v
+                for (a = !1, E = 1; E < c; ++E)
+                    for (w = E; w < h; w += c) d[w] += g[E - 1];
+        if (o === p2)
+            for (A = 1; A < f; ++A) {
+                for (F = 0, w = A * c, S = w + c; w < S; ++w) F < m[w] && (F = m[w]);
+                for (w = A * c; w < S; ++w) m[w] = F + y[A - 1]
+            } else if (o === bg) {
+                for (F = 0, w = c; w < h; ++w) F < m[w] && (F = m[w]);
+                for (w = c; w < h; ++w) m[w] = F + v
             } else
-                for (o = !1, k = 1; k < f; ++k)
-                    for (w = k * c, S = w + c; w < S; ++w) m[w] += y[k - 1];
-        for (F = 0, w = 0; w < h; ++w) F = d[w] + (w % c ? F : 0), b[w] += F - t[w].x;
-        for (O = 0; O < c; ++O)
-            for ($ = 0, w = O; w < h; w += c) $ += m[w], x[w] += $ - t[w].y;
-        if (s && ft(n.center, As) && f > 1)
-            for (w = 0; w < h; ++w) C = s === Rg ? p : g[w % c], F = C - _[w].x2 - t[w].x - b[w], F > 0 && (b[w] += F / 2);
-        if (o && ft(n.center, Ts) && c !== 1)
-            for (w = 0; w < h; ++w) C = o === Rg ? v : y[~~(w / c)], $ = C - _[w].y2 - t[w].y - x[w], $ > 0 && (x[w] += $ / 2);
-        for (w = 0; w < h; ++w) a.union(_[w].translate(b[w], x[w]));
-        switch (F = ft(n.anchor, _ee), $ = ft(n.anchor, wee), ft(n.anchor, As)) {
-            case $n:
-                F -= a.width();
+                for (o = !1, A = 1; A < f; ++A)
+                    for (w = A * c, S = w + c; w < S; ++w) m[w] += y[A - 1];
+        for (T = 0, w = 0; w < h; ++w) T = d[w] + (w % c ? T : 0), b[w] += T - t[w].x;
+        for (E = 0; E < c; ++E)
+            for (M = 0, w = E; w < h; w += c) M += m[w], x[w] += M - t[w].y;
+        if (a && ct(n.center, va) && f > 1)
+            for (w = 0; w < h; ++w) C = a === bg ? p : g[w % c], T = C - _[w].x2 - t[w].x - b[w], T > 0 && (b[w] += T / 2);
+        if (o && ct(n.center, ba) && c !== 1)
+            for (w = 0; w < h; ++w) C = o === bg ? v : y[~~(w / c)], M = C - _[w].y2 - t[w].y - x[w], M > 0 && (x[w] += M / 2);
+        for (w = 0; w < h; ++w) s.union(_[w].translate(b[w], x[w]));
+        switch (T = ct(n.anchor, TZ), M = ct(n.anchor, MZ), ct(n.anchor, va)) {
+            case An:
+                T -= s.width();
                 break;
-            case z2:
-                F -= a.width() / 2
+            case g2:
+                T -= s.width() / 2
         }
-        switch (ft(n.anchor, Ts)) {
-            case $n:
-                $ -= a.height();
+        switch (ct(n.anchor, ba)) {
+            case An:
+                M -= s.height();
                 break;
-            case z2:
-                $ -= a.height() / 2
+            case g2:
+                M -= s.height() / 2
         }
-        for (F = Math.round(F), $ = Math.round($), a.clear(), w = 0; w < h; ++w) t[w].mark.bounds.clear();
-        for (w = 0; w < h; ++w) E = t[w], E.x += b[w] += F, E.y += x[w] += $, a.union(E.mark.bounds.union(E.bounds.translate(b[w], x[w]))), i && e.dirty(E);
-        return a
+        for (T = Math.round(T), M = Math.round(M), s.clear(), w = 0; w < h; ++w) t[w].mark.bounds.clear();
+        for (w = 0; w < h; ++w) k = t[w], k.x += b[w] += T, k.y += x[w] += M, s.union(k.mark.bounds.union(k.bounds.translate(b[w], x[w]))), i && e.dirty(k);
+        return s
     }
 
-    function Iee(e, t, n) {
-        var i = Pee(t),
+    function HZ(e, t, n) {
+        var i = GZ(t),
             r = i.marks,
-            a = n.bounds === BS ? jee : zee,
-            s = n.offset,
+            s = n.bounds === oS ? YZ : XZ,
+            a = n.offset,
             o = n.columns || r.length,
             l = o <= 0 ? 1 : Math.ceil(r.length / o),
             u = l * o,
             c, f, h, d, g, p, m;
-        const y = rL(e, r, n);
-        y.empty() && y.set(0, 0, 0, 0), i.rowheaders && (p = ft(n.headerBand, Ts, null), c = Lg(e, i.rowheaders, r, o, l, -ft(s, "rowHeader"), t3, 0, a, "x1", 0, o, 1, p)), i.colheaders && (p = ft(n.headerBand, As, null), f = Lg(e, i.colheaders, r, o, o, -ft(s, "columnHeader"), t3, 1, a, "y1", 0, 1, o, p)), i.rowfooters && (p = ft(n.footerBand, Ts, null), h = Lg(e, i.rowfooters, r, o, l, ft(s, "rowFooter"), n3, 0, a, "x2", o - 1, o, 1, p)), i.colfooters && (p = ft(n.footerBand, As, null), d = Lg(e, i.colfooters, r, o, o, ft(s, "columnFooter"), n3, 1, a, "y2", u - o, 1, o, p)), i.rowtitle && (g = ft(n.titleAnchor, Ts), m = ft(s, "rowTitle"), m = g === $n ? h + m : c - m, p = ft(n.titleBand, Ts, .5), r3(e, i.rowtitle, m, 0, y, p)), i.coltitle && (g = ft(n.titleAnchor, As), m = ft(s, "columnTitle"), m = g === $n ? d + m : f - m, p = ft(n.titleBand, As, .5), r3(e, i.coltitle, m, 1, y, p))
+        const y = p4(e, r, n);
+        y.empty() && y.set(0, 0, 0, 0), i.rowheaders && (p = ct(n.headerBand, ba, null), c = wg(e, i.rowheaders, r, o, l, -ct(a, "rowHeader"), pT, 0, s, "x1", 0, o, 1, p)), i.colheaders && (p = ct(n.headerBand, va, null), f = wg(e, i.colheaders, r, o, o, -ct(a, "columnHeader"), pT, 1, s, "y1", 0, 1, o, p)), i.rowfooters && (p = ct(n.footerBand, ba, null), h = wg(e, i.rowfooters, r, o, l, ct(a, "rowFooter"), mT, 0, s, "x2", o - 1, o, 1, p)), i.colfooters && (p = ct(n.footerBand, va, null), d = wg(e, i.colfooters, r, o, o, ct(a, "columnFooter"), mT, 1, s, "y2", u - o, 1, o, p)), i.rowtitle && (g = ct(n.titleAnchor, ba), m = ct(a, "rowTitle"), m = g === An ? h + m : c - m, p = ct(n.titleBand, ba, .5), vT(e, i.rowtitle, m, 0, y, p)), i.coltitle && (g = ct(n.titleAnchor, va), m = ct(a, "columnTitle"), m = g === An ? d + m : f - m, p = ct(n.titleBand, va, .5), vT(e, i.coltitle, m, 1, y, p))
     }
 
-    function jee(e, t) {
+    function YZ(e, t) {
         return t === "x1" ? e.x || 0 : t === "y1" ? e.y || 0 : t === "x2" ? (e.x || 0) + (e.width || 0) : t === "y2" ? (e.y || 0) + (e.height || 0) : void 0
     }
 
-    function zee(e, t) {
+    function XZ(e, t) {
         return e.bounds[t]
     }
 
-    function Lg(e, t, n, i, r, a, s, o, l, u, c, f, h, d) {
+    function wg(e, t, n, i, r, s, a, o, l, u, c, f, h, d) {
         var g = n.length,
             p = 0,
             m = 0,
-            y, v, b, x, _, S, w, O, k;
+            y, v, b, x, _, S, w, E, A;
         if (!g) return p;
-        for (y = c; y < g; y += f) n[y] && (p = s(p, l(n[y], u)));
+        for (y = c; y < g; y += f) n[y] && (p = a(p, l(n[y], u)));
         if (!t.length) return p;
-        for (t.length > r && (e.warn("Grid headers exceed limit: " + r), t = t.slice(0, r)), p += a, v = 0, x = t.length; v < x; ++v) e.dirty(t[v]), t[v].mark.bounds.clear();
+        for (t.length > r && (e.warn("Grid headers exceed limit: " + r), t = t.slice(0, r)), p += s, v = 0, x = t.length; v < x; ++v) e.dirty(t[v]), t[v].mark.bounds.clear();
         for (y = c, v = 0, x = t.length; v < x; ++v, y += f) {
             for (S = t[v], _ = S.mark.bounds, b = y; b >= 0 && (w = n[b]) == null; b -= h);
-            o ? (O = d == null ? w.x : Math.round(w.bounds.x1 + d * w.bounds.width()), k = p) : (O = p, k = d == null ? w.y : Math.round(w.bounds.y1 + d * w.bounds.height())), _.union(S.bounds.translate(O - (S.x || 0), k - (S.y || 0))), S.x = O, S.y = k, e.dirty(S), m = s(m, _[u])
+            o ? (E = d == null ? w.x : Math.round(w.bounds.x1 + d * w.bounds.width()), A = p) : (E = p, A = d == null ? w.y : Math.round(w.bounds.y1 + d * w.bounds.height())), _.union(S.bounds.translate(E - (S.x || 0), A - (S.y || 0))), S.x = E, S.y = A, e.dirty(S), m = a(m, _[u])
         }
         return m
     }
 
-    function r3(e, t, n, i, r, a) {
+    function vT(e, t, n, i, r, s) {
         if (t) {
             e.dirty(t);
-            var s = n,
+            var a = n,
                 o = n;
-            i ? s = Math.round(r.x1 + a * r.width()) : o = Math.round(r.y1 + a * r.height()), t.bounds.translate(s - (t.x || 0), o - (t.y || 0)), t.mark.bounds.clear().union(t.bounds), t.x = s, t.y = o, e.dirty(t)
+            i ? a = Math.round(r.x1 + s * r.width()) : o = Math.round(r.y1 + s * r.height()), t.bounds.translate(a - (t.x || 0), o - (t.y || 0)), t.mark.bounds.clear().union(t.bounds), t.x = a, t.y = o, e.dirty(t)
         }
     }
 
-    function Bee(e, t) {
+    function VZ(e, t) {
         const n = e[t] || {};
         return (i, r) => n[i] != null ? n[i] : e[i] != null ? e[i] : r
     }
 
-    function Gee(e, t) {
+    function KZ(e, t) {
         let n = -1 / 0;
         return e.forEach(i => {
             i.offset != null && (n = Math.max(n, i.offset))
         }), n > -1 / 0 ? n : t
     }
 
-    function Uee(e, t, n, i, r, a, s) {
-        const o = Bee(n, t),
-            l = Gee(e, o("offset", 0)),
-            u = o("anchor", NS),
-            c = u === $n ? 1 : u === z2 ? .5 : 0,
+    function JZ(e, t, n, i, r, s, a) {
+        const o = VZ(n, t),
+            l = KZ(e, o("offset", 0)),
+            u = o("anchor", nS),
+            c = u === An ? 1 : u === g2 ? .5 : 0,
             f = {
-                align: B2,
-                bounds: o("bounds", BS),
+                align: p2,
+                bounds: o("bounds", oS),
                 columns: o("direction") === "vertical" ? 1 : e.length,
                 padding: o("margin", 8),
                 center: o("center"),
                 nodirty: !0
             };
         switch (t) {
-            case or:
+            case er:
                 f.anchor = {
                     x: Math.floor(i.x1) - l,
-                    column: $n,
-                    y: c * (s || i.height() + 2 * i.y1),
+                    column: An,
+                    y: c * (a || i.height() + 2 * i.y1),
                     row: u
                 };
                 break;
-            case cr:
+            case nr:
                 f.anchor = {
                     x: Math.ceil(i.x2) + l,
-                    y: c * (s || i.height() + 2 * i.y1),
+                    y: c * (a || i.height() + 2 * i.y1),
                     row: u
                 };
                 break;
-            case oc:
+            case Ku:
                 f.anchor = {
                     y: Math.floor(r.y1) - l,
-                    row: $n,
-                    x: c * (a || r.width() + 2 * r.x1),
+                    row: An,
+                    x: c * (s || r.width() + 2 * r.x1),
                     column: u
                 };
                 break;
-            case Xs:
+            case Ia:
                 f.anchor = {
                     y: Math.ceil(r.y2) + l,
-                    x: c * (a || r.width() + 2 * r.x1),
+                    x: c * (s || r.width() + 2 * r.x1),
                     column: u
                 };
                 break;
-            case yee:
+            case CZ:
                 f.anchor = {
                     x: l,
                     y: l
                 };
                 break;
-            case vee:
+            case kZ:
                 f.anchor = {
-                    x: a - l,
+                    x: s - l,
                     y: l,
-                    column: $n
+                    column: An
                 };
                 break;
-            case bee:
+            case AZ:
                 f.anchor = {
                     x: l,
-                    y: s - l,
-                    row: $n
+                    y: a - l,
+                    row: An
                 };
                 break;
-            case xee:
+            case $Z:
                 f.anchor = {
-                    x: a - l,
-                    y: s - l,
-                    column: $n,
-                    row: $n
+                    x: s - l,
+                    y: a - l,
+                    column: An,
+                    row: An
                 };
                 break
         }
         return f
     }
 
-    function qee(e, t) {
+    function QZ(e, t) {
         var n = t.items[0],
             i = n.datum,
             r = n.orient,
-            a = n.bounds,
-            s = n.x,
+            s = n.bounds,
+            a = n.x,
             o = n.y,
             l, u;
-        return n._bounds ? n._bounds.clear().union(a) : n._bounds = a.clone(), a.clear(), Hee(e, n, n.items[0].items[0]), a = Wee(n, a), l = 2 * n.padding, u = 2 * n.padding, a.empty() || (l = Math.ceil(a.width() + l), u = Math.ceil(a.height() + u)), i.type === Cee && Yee(n.items[0].items[0].items[0].items), r !== zS && (n.x = s = 0, n.y = o = 0), n.width = l, n.height = u, es(a.set(s, o, s + l, o + u), n), n.mark.bounds.clear().union(a), n
+        return n._bounds ? n._bounds.clear().union(s) : n._bounds = s.clone(), s.clear(), eee(e, n, n.items[0].items[0]), s = ZZ(n, s), l = 2 * n.padding, u = 2 * n.padding, s.empty() || (l = Math.ceil(s.width() + l), u = Math.ceil(s.height() + u)), i.type === DZ && tee(n.items[0].items[0].items[0].items), r !== aS && (n.x = a = 0, n.y = o = 0), n.width = l, n.height = u, qs(s.set(a, o, a + l, o + u), n), n.mark.bounds.clear().union(s), n
     }
 
-    function Wee(e, t) {
+    function ZZ(e, t) {
         return e.items.forEach(n => t.union(n.bounds)), t.x1 = e.padding, t.y1 = e.padding, t
     }
 
-    function Hee(e, t, n) {
+    function eee(e, t, n) {
         var i = t.padding,
             r = i - n.x,
-            a = i - n.y;
-        if (!t.datum.title)(r || a) && yf(e, n, r, a);
+            s = i - n.y;
+        if (!t.datum.title)(r || s) && rf(e, n, r, s);
         else {
-            var s = t.items[1].items[0],
-                o = s.anchor,
+            var a = t.items[1].items[0],
+                o = a.anchor,
                 l = t.titlePadding || 0,
-                u = i - s.x,
-                c = i - s.y;
-            switch (s.orient) {
-                case or:
-                    r += Math.ceil(s.bounds.width()) + l;
+                u = i - a.x,
+                c = i - a.y;
+            switch (a.orient) {
+                case er:
+                    r += Math.ceil(a.bounds.width()) + l;
                     break;
-                case cr:
-                case Xs:
+                case nr:
+                case Ia:
                     break;
                 default:
-                    a += s.bounds.height() + l
+                    s += a.bounds.height() + l
             }
-            switch ((r || a) && yf(e, n, r, a), s.orient) {
-                case or:
-                    c += ou(t, n, s, o, 1, 1);
+            switch ((r || s) && rf(e, n, r, s), a.orient) {
+                case er:
+                    c += Kl(t, n, a, o, 1, 1);
                     break;
-                case cr:
-                    u += ou(t, n, s, $n, 0, 0) + l, c += ou(t, n, s, o, 1, 1);
+                case nr:
+                    u += Kl(t, n, a, An, 0, 0) + l, c += Kl(t, n, a, o, 1, 1);
                     break;
-                case Xs:
-                    u += ou(t, n, s, o, 0, 0), c += ou(t, n, s, $n, -1, 0, 1) + l;
+                case Ia:
+                    u += Kl(t, n, a, o, 0, 0), c += Kl(t, n, a, An, -1, 0, 1) + l;
                     break;
                 default:
-                    u += ou(t, n, s, o, 0, 0)
-            }(u || c) && yf(e, s, u, c), (u = Math.round(s.bounds.x1 - i)) < 0 && (yf(e, n, -u, 0), yf(e, s, -u, 0))
+                    u += Kl(t, n, a, o, 0, 0)
+            }(u || c) && rf(e, a, u, c), (u = Math.round(a.bounds.x1 - i)) < 0 && (rf(e, n, -u, 0), rf(e, a, -u, 0))
         }
     }
 
-    function ou(e, t, n, i, r, a, s) {
+    function Kl(e, t, n, i, r, s, a) {
         const o = e.datum.type !== "symbol",
             l = n.datum.vgrad,
-            u = o && (a || !l) && !s ? t.items[0] : t,
+            u = o && (s || !l) && !a ? t.items[0] : t,
             c = u.bounds[r ? "y2" : "x2"] - e.padding,
-            f = l && a ? c : 0,
-            h = l && a ? 0 : c,
-            d = r <= 0 ? 0 : wS(n);
-        return Math.round(i === NS ? f : i === $n ? h - d : .5 * (c - d))
+            f = l && s ? c : 0,
+            h = l && s ? 0 : c,
+            d = r <= 0 ? 0 : Uw(n);
+        return Math.round(i === nS ? f : i === An ? h - d : .5 * (c - d))
     }
 
-    function yf(e, t, n, i) {
+    function rf(e, t, n, i) {
         t.x += n, t.y += i, t.bounds.translate(n, i), t.mark.bounds.translate(n, i), e.dirty(t)
     }
 
-    function Yee(e) {
+    function tee(e) {
         const t = e.reduce((n, i) => (n[i.column] = Math.max(i.bounds.x2 - i.x, n[i.column] || 0), n), {});
         e.forEach(n => {
             n.width = t[n.column], n.height = n.bounds.y2 - n.y
         })
     }
 
-    function Xee(e, t, n, i, r) {
-        var a = t.items[0],
-            s = a.frame,
-            o = a.orient,
-            l = a.anchor,
-            u = a.offset,
-            c = a.padding,
-            f = a.items[0].items[0],
-            h = a.items[1] && a.items[1].items[0],
-            d = o === or || o === cr ? i : n,
+    function nee(e, t, n, i, r) {
+        var s = t.items[0],
+            a = s.frame,
+            o = s.orient,
+            l = s.anchor,
+            u = s.offset,
+            c = s.padding,
+            f = s.items[0].items[0],
+            h = s.items[1] && s.items[1].items[0],
+            d = o === er || o === nr ? i : n,
             g = 0,
             p = 0,
             m = 0,
             y = 0,
             v = 0,
             b;
-        if (s !== w1 ? o === or ? (g = r.y2, d = r.y1) : o === cr ? (g = r.y1, d = r.y2) : (g = r.x1, d = r.x2) : o === or && (g = i, d = 0), b = l === NS ? g : l === $n ? d : (g + d) / 2, h && h.text) {
+        if (a !== i1 ? o === er ? (g = r.y2, d = r.y1) : o === nr ? (g = r.y1, d = r.y2) : (g = r.x1, d = r.x2) : o === er && (g = i, d = 0), b = l === nS ? g : l === An ? d : (g + d) / 2, h && h.text) {
             switch (o) {
-                case oc:
-                case Xs:
+                case Ku:
+                case Ia:
                     v = f.bounds.height() + c;
                     break;
-                case or:
+                case er:
                     y = f.bounds.width() + c;
                     break;
-                case cr:
+                case nr:
                     y = -f.bounds.width() - c;
                     break
             }
-            cn.clear().union(h.bounds), cn.translate(y - (h.x || 0), v - (h.y || 0)), Ou(h, "x", y) | Ou(h, "y", v) && (e.dirty(h), h.bounds.clear().union(cn), h.mark.bounds.clear().union(cn), e.dirty(h)), cn.clear().union(h.bounds)
-        } else cn.clear();
-        switch (cn.union(f.bounds), o) {
-            case oc:
-                p = b, m = r.y1 - cn.height() - u;
+            ln.clear().union(h.bounds), ln.translate(y - (h.x || 0), v - (h.y || 0)), gu(h, "x", y) | gu(h, "y", v) && (e.dirty(h), h.bounds.clear().union(ln), h.mark.bounds.clear().union(ln), e.dirty(h)), ln.clear().union(h.bounds)
+        } else ln.clear();
+        switch (ln.union(f.bounds), o) {
+            case Ku:
+                p = b, m = r.y1 - ln.height() - u;
                 break;
-            case or:
-                p = r.x1 - cn.width() - u, m = b;
+            case er:
+                p = r.x1 - ln.width() - u, m = b;
                 break;
-            case cr:
-                p = r.x2 + cn.width() + u, m = b;
+            case nr:
+                p = r.x2 + ln.width() + u, m = b;
                 break;
-            case Xs:
+            case Ia:
                 p = b, m = r.y2 + u;
                 break;
             default:
-                p = a.x, m = a.y
+                p = s.x, m = s.y
         }
-        return Ou(a, "x", p) | Ou(a, "y", m) && (cn.translate(p, m), e.dirty(a), a.bounds.clear().union(cn), t.bounds.clear().union(cn), e.dirty(a)), a.bounds
+        return gu(s, "x", p) | gu(s, "y", m) && (ln.translate(p, m), e.dirty(s), s.bounds.clear().union(ln), t.bounds.clear().union(ln), e.dirty(s)), s.bounds
     }
 
-    function aL(e) {
+    function m4(e) {
         L.call(this, null, e)
     }
-    Q(aL, L, {
+    ee(m4, L, {
         transform(e, t) {
             const n = t.dataflow;
             return e.mark.items.forEach(i => {
-                e.layout && Iee(n, i, e.layout), Kee(n, i, e)
-            }), Vee(e.mark.group) ? t.reflow() : t
+                e.layout && HZ(n, i, e.layout), ree(n, i, e)
+            }), iee(e.mark.group) ? t.reflow() : t
         }
     });
 
-    function Vee(e) {
+    function iee(e) {
         return e && e.mark.role !== "legend-entry"
     }
 
-    function Kee(e, t, n) {
+    function ree(e, t, n) {
         var i = t.items,
             r = Math.max(0, t.width || 0),
-            a = Math.max(0, t.height || 0),
-            s = new At().set(0, 0, r, a),
-            o = s.clone(),
-            l = s.clone(),
+            s = Math.max(0, t.height || 0),
+            a = new kt().set(0, 0, r, s),
+            o = a.clone(),
+            l = a.clone(),
             u = [],
             c, f, h, d, g, p;
         for (g = 0, p = i.length; g < p; ++g) switch (f = i[g], f.role) {
-            case LS:
-                d = Fee(f) ? o : l, d.union(Ree(e, f, r, a));
+            case iS:
+                d = BZ(f) ? o : l, d.union(UZ(e, f, r, s));
                 break;
-            case IS:
+            case rS:
                 c = f;
                 break;
-            case jS:
-                u.push(qee(e, f));
+            case sS:
+                u.push(QZ(e, f));
                 break;
-            case See:
-            case Eee:
-            case q4:
-            case W4:
-            case H4:
-            case Y4:
-            case X4:
-            case V4:
+            case OZ:
+            case FZ:
+            case t4:
+            case n4:
+            case i4:
+            case r4:
+            case s4:
+            case a4:
                 o.union(f.bounds), l.union(f.bounds);
                 break;
             default:
-                s.union(f.bounds)
+                a.union(f.bounds)
         }
         if (u.length) {
             const m = {};
             u.forEach(y => {
-                h = y.orient || cr, h !== zS && (m[h] || (m[h] = [])).push(y)
+                h = y.orient || nr, h !== aS && (m[h] || (m[h] = [])).push(y)
             });
             for (const y in m) {
                 const v = m[y];
-                rL(e, v, Uee(v, y, n.legends, o, l, r, a))
+                p4(e, v, JZ(v, y, n.legends, o, l, r, s))
             }
             u.forEach(y => {
                 const v = y.bounds;
-                if (v.equals(y._bounds) || (y.bounds = y._bounds, e.dirty(y), y.bounds = v, e.dirty(y)), n.autosize && (n.autosize.type === K4 || n.autosize.type === J4 || n.autosize.type === Q4)) switch (y.orient) {
-                    case or:
-                    case cr:
-                        s.add(v.x1, 0).add(v.x2, 0);
+                if (v.equals(y._bounds) || (y.bounds = y._bounds, e.dirty(y), y.bounds = v, e.dirty(y)), n.autosize && (n.autosize.type === o4 || n.autosize.type === l4 || n.autosize.type === u4)) switch (y.orient) {
+                    case er:
+                    case nr:
+                        a.add(v.x1, 0).add(v.x2, 0);
                         break;
-                    case oc:
-                    case Xs:
-                        s.add(0, v.y1).add(0, v.y2)
-                } else s.union(v)
+                    case Ku:
+                    case Ia:
+                        a.add(0, v.y1).add(0, v.y2)
+                } else a.union(v)
             })
         }
-        s.union(o).union(l), c && s.union(Xee(e, c, r, a, s)), t.clip && s.set(0, 0, t.width || 0, t.height || 0), Jee(e, t, s, n)
+        a.union(o).union(l), c && a.union(nee(e, c, r, s, a)), t.clip && a.set(0, 0, t.width || 0, t.height || 0), see(e, t, a, n)
     }
 
-    function Jee(e, t, n, i) {
+    function see(e, t, n, i) {
         const r = i.autosize || {},
-            a = r.type;
-        if (e._autosize < 1 || !a) return;
-        let s = e._width,
+            s = r.type;
+        if (e._autosize < 1 || !s) return;
+        let a = e._width,
             o = e._height,
             l = Math.max(0, t.width || 0),
             u = Math.max(0, Math.ceil(-n.x1)),
             c = Math.max(0, t.height || 0),
             f = Math.max(0, Math.ceil(-n.y1));
         const h = Math.max(0, Math.ceil(n.x2 - l)),
             d = Math.max(0, Math.ceil(n.y2 - c));
-        if (r.contains === Oee) {
+        if (r.contains === RZ) {
             const g = e.padding();
-            s -= g.left + g.right, o -= g.top + g.bottom
+            a -= g.left + g.right, o -= g.top + g.bottom
         }
-        a === zS ? (u = 0, f = 0, l = s, c = o) : a === K4 ? (l = Math.max(0, s - u - h), c = Math.max(0, o - f - d)) : a === J4 ? (l = Math.max(0, s - u - h), o = c + f + d) : a === Q4 ? (s = l + u + h, c = Math.max(0, o - f - d)) : a === kee && (s = l + u + h, o = c + f + d), e._resizeView(s, o, l, c, [u, f], r.resize)
+        s === aS ? (u = 0, f = 0, l = a, c = o) : s === o4 ? (l = Math.max(0, a - u - h), c = Math.max(0, o - f - d)) : s === l4 ? (l = Math.max(0, a - u - h), o = c + f + d) : s === u4 ? (a = l + u + h, c = Math.max(0, o - f - d)) : s === NZ && (a = l + u + h, o = c + f + d), e._resizeView(a, o, l, c, [u, f], r.resize)
     }
-    const Qee = Object.freeze(Object.defineProperty({
+    const aee = Object.freeze(Object.defineProperty({
         __proto__: null,
-        bound: Z4,
-        identifier: GS,
-        mark: eL,
-        overlap: tL,
-        render: iL,
-        viewlayout: aL
+        bound: c4,
+        identifier: lS,
+        mark: f4,
+        overlap: h4,
+        render: g4,
+        viewlayout: m4
     }, Symbol.toStringTag, {
         value: "Module"
     }));
 
-    function sL(e) {
+    function y4(e) {
         L.call(this, null, e)
     }
-    Q(sL, L, {
+    ee(y4, L, {
         transform(e, t) {
             if (this.value && !e.modified()) return t.StopPropagation;
             var n = t.dataflow.locale(),
                 i = t.fork(t.NO_SOURCE | t.NO_FIELDS),
                 r = this.value,
-                a = e.scale,
-                s = e.count == null ? e.values ? e.values.length : 10 : e.count,
-                o = iS(a, s, e.minstep),
-                l = e.format || zN(n, a, o, e.formatSpecifier, e.formatType, !!e.values),
-                u = e.values ? jN(a, e.values, o) : rS(a, o);
+                s = e.scale,
+                a = e.count == null ? e.values ? e.values.length : 10 : e.count,
+                o = Sw(s, a, e.minstep),
+                l = e.format || JN(n, s, o, e.formatSpecifier, e.formatType, !!e.values),
+                u = e.values ? KN(s, e.values, o) : Ew(s, o);
             return r && (i.rem = r), r = u.map((c, f) => He({
                 index: f / (u.length - 1 || 1),
                 value: c,
                 label: l(c)
             })), e.extra && r.length && r.push(He({
                 index: -1,
                 extra: {
                     value: r[0].value
                 },
                 label: ""
             })), i.source = r, i.add = r, this.value = r, i
         }
     });
 
-    function oL(e) {
+    function v4(e) {
         L.call(this, null, e)
     }
 
-    function Zee() {
+    function oee() {
         return He({})
     }
 
-    function ete(e) {
-        const t = Dc().test(n => n.exit);
+    function lee(e) {
+        const t = _c().test(n => n.exit);
         return t.lookup = n => t.get(e(n)), t
     }
-    Q(oL, L, {
+    ee(v4, L, {
         transform(e, t) {
             var n = t.dataflow,
                 i = t.fork(t.NO_SOURCE | t.NO_FIELDS),
-                r = e.item || Zee,
-                a = e.key || de,
-                s = this.value;
-            return q(i.encode) && (i.encode = null), s && (e.modified("key") || t.modified(a)) && G("DataJoin does not support modified key function or fields."), s || (t = t.addAll(), this.value = s = ete(a)), t.visit(t.ADD, o => {
-                const l = a(o);
-                let u = s.get(l);
-                u ? u.exit ? (s.empty--, i.add.push(u)) : i.mod.push(u) : (u = r(o), s.set(l, u), i.add.push(u)), u.datum = o, u.exit = !1
+                r = e.item || oee,
+                s = e.key || ge,
+                a = this.value;
+            return W(i.encode) && (i.encode = null), a && (e.modified("key") || t.modified(s)) && U("DataJoin does not support modified key function or fields."), a || (t = t.addAll(), this.value = a = lee(s)), t.visit(t.ADD, o => {
+                const l = s(o);
+                let u = a.get(l);
+                u ? u.exit ? (a.empty--, i.add.push(u)) : i.mod.push(u) : (u = r(o), a.set(l, u), i.add.push(u)), u.datum = o, u.exit = !1
             }), t.visit(t.MOD, o => {
-                const l = a(o),
-                    u = s.get(l);
+                const l = s(o),
+                    u = a.get(l);
                 u && (u.datum = o, i.mod.push(u))
             }), t.visit(t.REM, o => {
-                const l = a(o),
-                    u = s.get(l);
-                o === u.datum && !u.exit && (i.rem.push(u), u.exit = !0, ++s.empty)
-            }), t.changed(t.ADD_MOD) && i.modifies("datum"), (t.clean() || e.clean && s.empty > n.cleanThreshold) && n.runAfter(s.clean), i
+                const l = s(o),
+                    u = a.get(l);
+                o === u.datum && !u.exit && (i.rem.push(u), u.exit = !0, ++a.empty)
+            }), t.changed(t.ADD_MOD) && i.modifies("datum"), (t.clean() || e.clean && a.empty > n.cleanThreshold) && n.runAfter(a.clean), i
         }
     });
 
-    function lL(e) {
+    function b4(e) {
         L.call(this, null, e)
     }
-    Q(lL, L, {
+    ee(b4, L, {
         transform(e, t) {
             var n = t.fork(t.ADD_REM),
                 i = e.mod || !1,
                 r = e.encoders,
-                a = t.encode;
-            if (q(a))
-                if (n.changed() || a.every(f => r[f])) a = a[0], n.encode = null;
+                s = t.encode;
+            if (W(s))
+                if (n.changed() || s.every(f => r[f])) s = s[0], n.encode = null;
                 else return t.StopPropagation;
-            var s = a === "enter",
-                o = r.update || ds,
-                l = r.enter || ds,
-                u = r.exit || ds,
-                c = (a && !s ? r[a] : o) || ds;
+            var a = s === "enter",
+                o = r.update || ia,
+                l = r.enter || ia,
+                u = r.exit || ia,
+                c = (s && !a ? r[s] : o) || ia;
             if (t.changed(t.ADD) && (t.visit(t.ADD, f => {
                     l(f, e), o(f, e)
-                }), n.modifies(l.output), n.modifies(o.output), c !== ds && c !== o && (t.visit(t.ADD, f => {
+                }), n.modifies(l.output), n.modifies(o.output), c !== ia && c !== o && (t.visit(t.ADD, f => {
                     c(f, e)
-                }), n.modifies(c.output))), t.changed(t.REM) && u !== ds && (t.visit(t.REM, f => {
+                }), n.modifies(c.output))), t.changed(t.REM) && u !== ia && (t.visit(t.REM, f => {
                     u(f, e)
-                }), n.modifies(u.output)), s || c !== ds) {
+                }), n.modifies(u.output)), a || c !== ia) {
                 const f = t.MOD | (e.modified() ? t.REFLOW : 0);
-                s ? (t.visit(f, h => {
+                a ? (t.visit(f, h => {
                     const d = l(h, e) || i;
                     (c(h, e) || d) && n.mod.push(h)
                 }), n.mod.length && n.modifies(l.output)) : t.visit(f, h => {
                     (c(h, e) || i) && n.mod.push(h)
                 }), n.mod.length && n.modifies(c.output)
             }
             return n.changed() ? n : t.StopPropagation
         }
     });
 
-    function uL(e) {
+    function x4(e) {
         L.call(this, [], e)
     }
-    Q(uL, L, {
+    ee(x4, L, {
         transform(e, t) {
             if (this.value != null && !e.modified()) return t.StopPropagation;
             var n = t.dataflow.locale(),
                 i = t.fork(t.NO_SOURCE | t.NO_FIELDS),
                 r = this.value,
-                a = e.type || mp,
-                s = e.scale,
+                s = e.type || Qg,
+                a = e.scale,
                 o = +e.limit,
-                l = iS(s, e.count == null ? 5 : e.count, e.minstep),
-                u = !!e.values || a === mp,
-                c = e.format || qN(n, s, l, a, e.formatSpecifier, e.formatType, u),
-                f = e.values || UN(s, l),
+                l = Sw(a, e.count == null ? 5 : e.count, e.minstep),
+                u = !!e.values || s === Qg,
+                c = e.format || tP(n, a, l, s, e.formatSpecifier, e.formatType, u),
+                f = e.values || eP(a, l),
                 h, d, g, p, m;
-            return r && (i.rem = r), a === mp ? (o && f.length > o ? (t.dataflow.warn("Symbol legend count exceeds limit, filtering items."), r = f.slice(0, o - 1), m = !0) : r = f, Ae(g = e.size) ? (!e.values && s(r[0]) === 0 && (r = r.slice(1)), p = r.reduce((y, v) => Math.max(y, g(v, e)), 0)) : g = Sn(p = g || 8), r = r.map((y, v) => He({
+            return r && (i.rem = r), s === Qg ? (o && f.length > o ? (t.dataflow.warn("Symbol legend count exceeds limit, filtering items."), r = f.slice(0, o - 1), m = !0) : r = f, $e(g = e.size) ? (!e.values && a(r[0]) === 0 && (r = r.slice(1)), p = r.reduce((y, v) => Math.max(y, g(v, e)), 0)) : g = xn(p = g || 8), r = r.map((y, v) => He({
                 index: v,
                 label: c(y, v, r),
                 value: y,
                 offset: p,
                 size: g(y, e)
             })), m && (m = f[r.length], r.push(He({
                 index: r.length,
                 label: `…${f.length-r.length} entries`,
                 value: m,
                 offset: p,
                 size: g(m, e)
-            })))) : a === AJ ? (h = s.domain(), d = NN(s, h[0], Le(h)), f.length < 3 && !e.values && h[0] !== Le(h) && (f = [h[0], Le(h)]), r = f.map((y, v) => He({
+            })))) : s === PK ? (h = a.domain(), d = YN(a, h[0], De(h)), f.length < 3 && !e.values && h[0] !== De(h) && (f = [h[0], De(h)]), r = f.map((y, v) => He({
                 index: v,
                 label: c(y, v, f),
                 value: y,
                 perc: d(y)
-            }))) : (g = f.length - 1, d = jJ(s), r = f.map((y, v) => He({
+            }))) : (g = f.length - 1, d = YK(a), r = f.map((y, v) => He({
                 index: v,
                 label: c(y, v, f),
                 value: y,
                 perc: v ? d(y) : 0,
                 perc2: v === g ? 1 : d(f[v + 1])
             }))), i.source = r, i.add = r, this.value = r, i
         }
     });
-    const tte = e => e.source.x,
-        nte = e => e.source.y,
-        ite = e => e.target.x,
-        rte = e => e.target.y;
+    const uee = e => e.source.x,
+        cee = e => e.source.y,
+        fee = e => e.target.x,
+        hee = e => e.target.y;
 
-    function US(e) {
+    function uS(e) {
         L.call(this, {}, e)
     }
-    US.Definition = {
+    uS.Definition = {
         type: "LinkPath",
         metadata: {
             modifies: !0
         },
         params: [{
             name: "sourceX",
             type: "field",
@@ -26405,92 +26425,92 @@
             type: "signal"
         }, {
             name: "as",
             type: "string",
             default: "path"
         }]
     };
-    Q(US, L, {
+    ee(uS, L, {
         transform(e, t) {
-            var n = e.sourceX || tte,
-                i = e.sourceY || nte,
-                r = e.targetX || ite,
-                a = e.targetY || rte,
-                s = e.as || "path",
+            var n = e.sourceX || uee,
+                i = e.sourceY || cee,
+                r = e.targetX || fee,
+                s = e.targetY || hee,
+                a = e.as || "path",
                 o = e.orient || "vertical",
                 l = e.shape || "line",
-                u = a3.get(l + "-" + o) || a3.get(l);
-            return u || G("LinkPath unsupported type: " + e.shape + (e.orient ? "-" + e.orient : "")), t.visit(t.SOURCE, c => {
-                c[s] = u(n(c), i(c), r(c), a(c))
-            }), t.reflow(e.modified()).modifies(s)
+                u = bT.get(l + "-" + o) || bT.get(l);
+            return u || U("LinkPath unsupported type: " + e.shape + (e.orient ? "-" + e.orient : "")), t.visit(t.SOURCE, c => {
+                c[a] = u(n(c), i(c), r(c), s(c))
+            }), t.reflow(e.modified()).modifies(a)
         }
     });
-    const cL = (e, t, n, i) => "M" + e + "," + t + "L" + n + "," + i,
-        ate = (e, t, n, i) => cL(t * Math.cos(e), t * Math.sin(e), i * Math.cos(n), i * Math.sin(n)),
-        fL = (e, t, n, i) => {
+    const _4 = (e, t, n, i) => "M" + e + "," + t + "L" + n + "," + i,
+        dee = (e, t, n, i) => _4(t * Math.cos(e), t * Math.sin(e), i * Math.cos(n), i * Math.sin(n)),
+        w4 = (e, t, n, i) => {
             var r = n - e,
-                a = i - t,
-                s = Math.sqrt(r * r + a * a) / 2,
-                o = 180 * Math.atan2(a, r) / Math.PI;
-            return "M" + e + "," + t + "A" + s + "," + s + " " + o + " 0 1 " + n + "," + i
+                s = i - t,
+                a = Math.hypot(r, s) / 2,
+                o = 180 * Math.atan2(s, r) / Math.PI;
+            return "M" + e + "," + t + "A" + a + "," + a + " " + o + " 0 1 " + n + "," + i
         },
-        ste = (e, t, n, i) => fL(t * Math.cos(e), t * Math.sin(e), i * Math.cos(n), i * Math.sin(n)),
-        hL = (e, t, n, i) => {
+        gee = (e, t, n, i) => w4(t * Math.cos(e), t * Math.sin(e), i * Math.cos(n), i * Math.sin(n)),
+        S4 = (e, t, n, i) => {
             const r = n - e,
-                a = i - t,
-                s = .2 * (r + a),
-                o = .2 * (a - r);
-            return "M" + e + "," + t + "C" + (e + s) + "," + (t + o) + " " + (n + o) + "," + (i - s) + " " + n + "," + i
-        },
-        ote = (e, t, n, i) => hL(t * Math.cos(e), t * Math.sin(e), i * Math.cos(n), i * Math.sin(n)),
-        lte = (e, t, n, i) => "M" + e + "," + t + "V" + i + "H" + n,
-        ute = (e, t, n, i) => "M" + e + "," + t + "H" + n + "V" + i,
-        cte = (e, t, n, i) => {
+                s = i - t,
+                a = .2 * (r + s),
+                o = .2 * (s - r);
+            return "M" + e + "," + t + "C" + (e + a) + "," + (t + o) + " " + (n + o) + "," + (i - a) + " " + n + "," + i
+        },
+        pee = (e, t, n, i) => S4(t * Math.cos(e), t * Math.sin(e), i * Math.cos(n), i * Math.sin(n)),
+        mee = (e, t, n, i) => "M" + e + "," + t + "V" + i + "H" + n,
+        yee = (e, t, n, i) => "M" + e + "," + t + "H" + n + "V" + i,
+        vee = (e, t, n, i) => {
             const r = Math.cos(e),
-                a = Math.sin(e),
-                s = Math.cos(n),
+                s = Math.sin(e),
+                a = Math.cos(n),
                 o = Math.sin(n),
                 l = Math.abs(n - e) > Math.PI ? n <= e : n > e;
-            return "M" + t * r + "," + t * a + "A" + t + "," + t + " 0 0," + (l ? 1 : 0) + " " + t * s + "," + t * o + "L" + i * s + "," + i * o
+            return "M" + t * r + "," + t * s + "A" + t + "," + t + " 0 0," + (l ? 1 : 0) + " " + t * a + "," + t * o + "L" + i * a + "," + i * o
         },
-        fte = (e, t, n, i) => {
+        bee = (e, t, n, i) => {
             const r = (e + n) / 2;
             return "M" + e + "," + t + "C" + r + "," + t + " " + r + "," + i + " " + n + "," + i
         },
-        hte = (e, t, n, i) => {
+        xee = (e, t, n, i) => {
             const r = (t + i) / 2;
             return "M" + e + "," + t + "C" + e + "," + r + " " + n + "," + r + " " + n + "," + i
         },
-        dte = (e, t, n, i) => {
+        _ee = (e, t, n, i) => {
             const r = Math.cos(e),
-                a = Math.sin(e),
-                s = Math.cos(n),
+                s = Math.sin(e),
+                a = Math.cos(n),
                 o = Math.sin(n),
                 l = (t + i) / 2;
-            return "M" + t * r + "," + t * a + "C" + l * r + "," + l * a + " " + l * s + "," + l * o + " " + i * s + "," + i * o
+            return "M" + t * r + "," + t * s + "C" + l * r + "," + l * s + " " + l * a + "," + l * o + " " + i * a + "," + i * o
         },
-        a3 = Dc({
-            line: cL,
-            "line-radial": ate,
-            arc: fL,
-            "arc-radial": ste,
-            curve: hL,
-            "curve-radial": ote,
-            "orthogonal-horizontal": lte,
-            "orthogonal-vertical": ute,
-            "orthogonal-radial": cte,
-            "diagonal-horizontal": fte,
-            "diagonal-vertical": hte,
-            "diagonal-radial": dte
+        bT = _c({
+            line: _4,
+            "line-radial": dee,
+            arc: w4,
+            "arc-radial": gee,
+            curve: S4,
+            "curve-radial": pee,
+            "orthogonal-horizontal": mee,
+            "orthogonal-vertical": yee,
+            "orthogonal-radial": vee,
+            "diagonal-horizontal": bee,
+            "diagonal-vertical": xee,
+            "diagonal-radial": _ee
         });
 
-    function qS(e) {
+    function cS(e) {
         L.call(this, null, e)
     }
-    qS.Definition = {
+    cS.Definition = {
         type: "Pie",
         metadata: {
             modifies: !0
         },
         params: [{
             name: "field",
             type: "field"
@@ -26510,175 +26530,175 @@
             name: "as",
             type: "string",
             array: !0,
             length: 2,
             default: ["startAngle", "endAngle"]
         }]
     };
-    Q(qS, L, {
+    ee(cS, L, {
         transform(e, t) {
             var n = e.as || ["startAngle", "endAngle"],
                 i = n[0],
                 r = n[1],
-                a = e.field || $c,
-                s = e.startAngle || 0,
+                s = e.field || vc,
+                a = e.startAngle || 0,
                 o = e.endAngle != null ? e.endAngle : 2 * Math.PI,
                 l = t.source,
-                u = l.map(a),
+                u = l.map(s),
                 c = u.length,
-                f = s,
-                h = (o - s) / $F(u),
-                d = mi(c),
+                f = a,
+                h = (o - a) / jO(u),
+                d = gi(c),
                 g, p, m;
             for (e.sort && d.sort((y, v) => u[y] - u[v]), g = 0; g < c; ++g) m = u[d[g]], p = l[d[g]], p[i] = f, p[r] = f += m * h;
             return this.value = u, t.reflow(e.modified()).modifies(n)
         }
     });
-    const gte = 5;
+    const wee = 5;
 
-    function pte(e) {
+    function See(e) {
         const t = e.type;
-        return !e.bins && (t === ec || t === wd || t === Sd)
+        return !e.bins && (t === Gu || t === cd || t === fd)
     }
 
-    function dL(e) {
-        return eS(e) && e !== Hr
+    function E4(e) {
+        return xw(e) && e !== zr
     }
-    const mte = br(["set", "modified", "clear", "type", "scheme", "schemeExtent", "schemeCount", "domain", "domainMin", "domainMid", "domainMax", "domainRaw", "domainImplicit", "nice", "zero", "bins", "range", "rangeStep", "round", "reverse", "interpolate", "interpolateGamma"]);
+    const Eee = fr(["set", "modified", "clear", "type", "scheme", "schemeExtent", "schemeCount", "domain", "domainMin", "domainMid", "domainMax", "domainRaw", "domainImplicit", "nice", "zero", "bins", "range", "rangeStep", "round", "reverse", "interpolate", "interpolateGamma"]);
 
-    function gL(e) {
+    function C4(e) {
         L.call(this, null, e), this.modified(!0)
     }
-    Q(gL, L, {
+    ee(C4, L, {
         transform(e, t) {
             var n = t.dataflow,
                 i = this.value,
-                r = yte(e);
-            (!i || r !== i.type) && (this.value = i = qe(r)());
+                r = Cee(e);
+            (!i || r !== i.type) && (this.value = i = We(r)());
             for (r in e)
-                if (!mte[r]) {
-                    if (r === "padding" && dL(i.type)) continue;
-                    Ae(i[r]) ? i[r](e[r]) : n.warn("Unsupported scale property: " + r)
-                } return Ste(i, e, wte(i, e, bte(i, e, n))), t.fork(t.NO_SOURCE | t.NO_FIELDS)
+                if (!Eee[r]) {
+                    if (r === "padding" && E4(i.type)) continue;
+                    $e(i[r]) ? i[r](e[r]) : n.warn("Unsupported scale property: " + r)
+                } return Oee(i, e, Mee(i, e, Aee(i, e, n))), t.fork(t.NO_SOURCE | t.NO_FIELDS)
         }
     });
 
-    function yte(e) {
+    function Cee(e) {
         var t = e.type,
             n = "",
             i;
-        return t === Hr ? Hr + "-" + ec : (vte(e) && (i = e.rawDomain ? e.rawDomain.length : e.domain ? e.domain.length + +(e.domainMid != null) : 0, n = i === 2 ? Hr + "-" : i === 3 ? Lc + "-" : ""), (n + t || ec).toLowerCase())
+        return t === zr ? zr + "-" + Gu : (kee(e) && (i = e.rawDomain ? e.rawDomain.length : e.domain ? e.domain.length + +(e.domainMid != null) : 0, n = i === 2 ? zr + "-" : i === 3 ? Cc + "-" : ""), (n + t || Gu).toLowerCase())
     }
 
-    function vte(e) {
+    function kee(e) {
         const t = e.type;
-        return eS(t) && t !== dl && t !== gl && (e.scheme || e.range && e.range.length && e.range.every(re))
+        return xw(t) && t !== tl && t !== nl && (e.scheme || e.range && e.range.length && e.range.every(re))
     }
 
-    function bte(e, t, n) {
-        const i = xte(e, t.domainRaw, n);
+    function Aee(e, t, n) {
+        const i = $ee(e, t.domainRaw, n);
         if (i > -1) return i;
         var r = t.domain,
-            a = e.type,
-            s = t.zero || t.zero === void 0 && pte(e),
+            s = e.type,
+            a = t.zero || t.zero === void 0 && See(e),
             o, l;
         if (!r) return 0;
-        if (dL(a) && t.padding && r[0] !== Le(r) && (r = _te(a, r, t.range, t.padding, t.exponent, t.constant)), (s || t.domainMin != null || t.domainMax != null || t.domainMid != null) && (o = (r = r.slice()).length - 1 || 1, s && (r[0] > 0 && (r[0] = 0), r[o] < 0 && (r[o] = 0)), t.domainMin != null && (r[0] = t.domainMin), t.domainMax != null && (r[o] = t.domainMax), t.domainMid != null)) {
+        if (E4(s) && t.padding && r[0] !== De(r) && (r = Tee(s, r, t.range, t.padding, t.exponent, t.constant)), (a || t.domainMin != null || t.domainMax != null || t.domainMid != null) && (o = (r = r.slice()).length - 1 || 1, a && (r[0] > 0 && (r[0] = 0), r[o] < 0 && (r[o] = 0)), t.domainMin != null && (r[0] = t.domainMin), t.domainMax != null && (r[o] = t.domainMax), t.domainMid != null)) {
             l = t.domainMid;
             const u = l > r[o] ? o + 1 : l < r[0] ? 0 : o;
             u !== o && n.warn("Scale domainMid exceeds domain min or max.", l), r.splice(u, 0, l)
         }
-        return e.domain(pL(a, r, n)), a === Kw && e.unknown(t.domainImplicit ? u2 : void 0), t.nice && e.nice && e.nice(t.nice !== !0 && iS(e, t.nice) || null), r.length
+        return e.domain(k4(s, r, n)), s === mw && e.unknown(t.domainImplicit ? Lb : void 0), t.nice && e.nice && e.nice(t.nice !== !0 && Sw(e, t.nice) || null), r.length
     }
 
-    function xte(e, t, n) {
-        return t ? (e.domain(pL(e.type, t, n)), t.length) : -1
+    function $ee(e, t, n) {
+        return t ? (e.domain(k4(e.type, t, n)), t.length) : -1
     }
 
-    function _te(e, t, n, i, r, a) {
-        var s = Math.abs(Le(n) - n[0]),
-            o = s / (s - 2 * i),
-            l = e === Xa ? q_(t, null, o) : e === Sd ? T0(t, null, o, .5) : e === wd ? T0(t, null, o, r || 1) : e === o1 ? W_(t, null, o, a || 1) : U_(t, null, o);
+    function Tee(e, t, n, i, r, s) {
+        var a = Math.abs(De(n) - n[0]),
+            o = a / (a - 2 * i),
+            l = e === zs ? u_(t, null, o) : e === fd ? c0(t, null, o, .5) : e === cd ? c0(t, null, o, r || 1) : e === Um ? c_(t, null, o, s || 1) : l_(t, null, o);
         return t = t.slice(), t[0] = l[0], t[t.length - 1] = l[1], t
     }
 
-    function pL(e, t, n) {
-        if (MN(e)) {
-            var i = Math.abs(t.reduce((r, a) => r + (a < 0 ? -1 : a > 0 ? 1 : 0), 0));
+    function k4(e, t, n) {
+        if (UN(e)) {
+            var i = Math.abs(t.reduce((r, s) => r + (s < 0 ? -1 : s > 0 ? 1 : 0), 0));
             i !== t.length && n.warn("Log scale domain includes zero: " + Z(t))
         }
         return t
     }
 
-    function wte(e, t, n) {
+    function Mee(e, t, n) {
         let i = t.bins;
-        if (i && !q(i)) {
+        if (i && !W(i)) {
             const r = e.domain(),
-                a = r[0],
-                s = Le(r),
+                s = r[0],
+                a = De(r),
                 o = i.step;
-            let l = i.start == null ? a : i.start,
-                u = i.stop == null ? s : i.stop;
-            o || G("Scale bins parameter missing step property."), l < a && (l = o * Math.ceil(a / o)), u > s && (u = o * Math.floor(s / o)), i = mi(l, u + o / 2, o)
+            let l = i.start == null ? s : i.start,
+                u = i.stop == null ? a : i.stop;
+            o || U("Scale bins parameter missing step property."), l < s && (l = o * Math.ceil(s / o)), u > a && (u = o * Math.floor(a / o)), i = gi(l, u + o / 2, o)
         }
-        return i ? e.bins = i : e.bins && delete e.bins, e.type === Jw && (i ? !t.domain && !t.domainRaw && (e.domain(i), n = i.length) : e.bins = e.domain()), n
+        return i ? e.bins = i : e.bins && delete e.bins, e.type === yw && (i ? !t.domain && !t.domainRaw && (e.domain(i), n = i.length) : e.bins = e.domain()), n
     }
 
-    function Ste(e, t, n) {
+    function Oee(e, t, n) {
         var i = e.type,
             r = t.round || !1,
-            a = t.range;
-        if (t.rangeStep != null) a = Ete(i, t, n);
-        else if (t.scheme && (a = Ote(i, t, n), Ae(a))) {
-            if (e.interpolator) return e.interpolator(a);
-            G(`Scale type ${i} does not support interpolating color schemes.`)
+            s = t.range;
+        if (t.rangeStep != null) s = Fee(i, t, n);
+        else if (t.scheme && (s = Ree(i, t, n), $e(s))) {
+            if (e.interpolator) return e.interpolator(s);
+            U(`Scale type ${i} does not support interpolating color schemes.`)
         }
-        if (a && FN(i)) return e.interpolator(c1(G2(a, t.reverse), t.interpolate, t.interpolateGamma));
-        a && t.interpolate && e.interpolate ? e.interpolate(tS(t.interpolate, t.interpolateGamma)) : Ae(e.round) ? e.round(r) : Ae(e.rangeRound) && e.interpolate(r ? ud : oo), a && e.range(G2(a, t.reverse))
+        if (s && GN(i)) return e.interpolator(qm(m2(s, t.reverse), t.interpolate, t.interpolateGamma));
+        s && t.interpolate && e.interpolate ? e.interpolate(_w(t.interpolate, t.interpolateGamma)) : $e(e.round) ? e.round(r) : $e(e.rangeRound) && e.interpolate(r ? Jh : Ka), s && e.range(m2(s, t.reverse))
     }
 
-    function Ete(e, t, n) {
-        e !== ON && e !== k2 && G("Only band and point scales support rangeStep.");
+    function Fee(e, t, n) {
+        e !== PN && e !== t2 && U("Only band and point scales support rangeStep.");
         var i = (t.paddingOuter != null ? t.paddingOuter : t.padding) || 0,
-            r = e === k2 ? 1 : (t.paddingInner != null ? t.paddingInner : t.padding) || 0;
-        return [0, t.rangeStep * Vw(n, r, i)]
+            r = e === t2 ? 1 : (t.paddingInner != null ? t.paddingInner : t.padding) || 0;
+        return [0, t.rangeStep * pw(n, r, i)]
     }
 
-    function Ote(e, t, n) {
+    function Ree(e, t, n) {
         var i = t.schemeExtent,
-            r, a;
-        return q(t.scheme) ? a = c1(t.scheme, t.interpolate, t.interpolateGamma) : (r = t.scheme.toLowerCase(), a = nS(r), a || G(`Unrecognized scheme name: ${t.scheme}`)), n = e === u1 ? n + 1 : e === Jw ? n - 1 : e === tc || e === l1 ? +t.schemeCount || gte : n, FN(e) ? s3(a, i, t.reverse) : Ae(a) ? PN(s3(a, i), n) : e === Kw ? a : a.slice(0, n)
+            r, s;
+        return W(t.scheme) ? s = qm(t.scheme, t.interpolate, t.interpolateGamma) : (r = t.scheme.toLowerCase(), s = ww(r), s || U(`Unrecognized scheme name: ${t.scheme}`)), n = e === Wm ? n + 1 : e === yw ? n - 1 : e === Wu || e === Gm ? +t.schemeCount || wee : n, GN(e) ? xT(s, i, t.reverse) : $e(s) ? HN(xT(s, i), n) : e === mw ? s : s.slice(0, n)
     }
 
-    function s3(e, t, n) {
-        return Ae(e) && (t || n) ? RN(e, G2(t || [0, 1], n)) : e
+    function xT(e, t, n) {
+        return $e(e) && (t || n) ? qN(e, m2(t || [0, 1], n)) : e
     }
 
-    function G2(e, t) {
+    function m2(e, t) {
         return t ? e.slice().reverse() : e
     }
 
-    function mL(e) {
+    function A4(e) {
         L.call(this, null, e)
     }
-    Q(mL, L, {
+    ee(A4, L, {
         transform(e, t) {
             const n = e.modified("sort") || t.changed(t.ADD) || t.modified(e.sort.fields) || t.modified("datum");
-            return n && t.source.sort(jl(e.sort)), this.modified(n), t
+            return n && t.source.sort($l(e.sort)), this.modified(n), t
         }
     });
-    const o3 = "zero",
-        yL = "center",
-        vL = "normalize",
-        bL = ["y0", "y1"];
+    const _T = "zero",
+        $4 = "center",
+        T4 = "normalize",
+        M4 = ["y0", "y1"];
 
-    function WS(e) {
+    function fS(e) {
         L.call(this, null, e)
     }
-    WS.Definition = {
+    fS.Definition = {
         type: "Stack",
         metadata: {
             modifies: !0
         },
         params: [{
             name: "field",
             type: "field"
@@ -26688,160 +26708,160 @@
             array: !0
         }, {
             name: "sort",
             type: "compare"
         }, {
             name: "offset",
             type: "enum",
-            default: o3,
-            values: [o3, yL, vL]
+            default: _T,
+            values: [_T, $4, T4]
         }, {
             name: "as",
             type: "string",
             array: !0,
             length: 2,
-            default: bL
+            default: M4
         }]
     };
-    Q(WS, L, {
+    ee(fS, L, {
         transform(e, t) {
-            var n = e.as || bL,
+            var n = e.as || M4,
                 i = n[0],
                 r = n[1],
-                a = jl(e.sort),
-                s = e.field || $c,
-                o = e.offset === yL ? Cte : e.offset === vL ? kte : Ate,
+                s = $l(e.sort),
+                a = e.field || vc,
+                o = e.offset === $4 ? Dee : e.offset === T4 ? Nee : Pee,
                 l, u, c, f;
-            for (l = Tte(t.source, e.groupby, a, s), u = 0, c = l.length, f = l.max; u < c; ++u) o(l[u], f, s, i, r);
+            for (l = Lee(t.source, e.groupby, s, a), u = 0, c = l.length, f = l.max; u < c; ++u) o(l[u], f, a, i, r);
             return t.reflow(e.modified()).modifies(n)
         }
     });
 
-    function Cte(e, t, n, i, r) {
-        for (var a = (t - e.sum) / 2, s = e.length, o = 0, l; o < s; ++o) l = e[o], l[i] = a, l[r] = a += Math.abs(n(l))
+    function Dee(e, t, n, i, r) {
+        for (var s = (t - e.sum) / 2, a = e.length, o = 0, l; o < a; ++o) l = e[o], l[i] = s, l[r] = s += Math.abs(n(l))
     }
 
-    function kte(e, t, n, i, r) {
-        for (var a = 1 / e.sum, s = 0, o = e.length, l = 0, u = 0, c; l < o; ++l) c = e[l], c[i] = s, c[r] = s = a * (u += Math.abs(n(c)))
+    function Nee(e, t, n, i, r) {
+        for (var s = 1 / e.sum, a = 0, o = e.length, l = 0, u = 0, c; l < o; ++l) c = e[l], c[i] = a, c[r] = a = s * (u += Math.abs(n(c)))
     }
 
-    function Ate(e, t, n, i, r) {
-        for (var a = 0, s = 0, o = e.length, l = 0, u, c; l < o; ++l) c = e[l], u = +n(c), u < 0 ? (c[i] = s, c[r] = s += u) : (c[i] = a, c[r] = a += u)
+    function Pee(e, t, n, i, r) {
+        for (var s = 0, a = 0, o = e.length, l = 0, u, c; l < o; ++l) c = e[l], u = +n(c), u < 0 ? (c[i] = a, c[r] = a += u) : (c[i] = s, c[r] = s += u)
     }
 
-    function Tte(e, t, n, i) {
+    function Lee(e, t, n, i) {
         var r = [],
-            a = p => p(c),
-            s, o, l, u, c, f, h, d, g;
+            s = p => p(c),
+            a, o, l, u, c, f, h, d, g;
         if (t == null) r.push(e.slice());
         else
-            for (s = {}, o = 0, l = e.length; o < l; ++o) c = e[o], f = t.map(a), h = s[f], h || (s[f] = h = [], r.push(h)), h.push(c);
+            for (a = {}, o = 0, l = e.length; o < l; ++o) c = e[o], f = t.map(s), h = a[f], h || (a[f] = h = [], r.push(h)), h.push(c);
         for (f = 0, g = 0, u = r.length; f < u; ++f) {
             for (h = r[f], o = 0, d = 0, l = h.length; o < l; ++o) d += Math.abs(i(h[o]));
             h.sum = d, d > g && (g = d), n && h.sort(n)
         }
         return r.max = g, r
     }
-    const $te = Object.freeze(Object.defineProperty({
+    const Iee = Object.freeze(Object.defineProperty({
         __proto__: null,
-        axisticks: sL,
-        datajoin: oL,
-        encode: lL,
-        legendentries: uL,
-        linkpath: US,
-        pie: qS,
-        scale: gL,
-        sortitems: mL,
-        stack: WS
+        axisticks: y4,
+        datajoin: v4,
+        encode: b4,
+        legendentries: x4,
+        linkpath: uS,
+        pie: cS,
+        scale: C4,
+        sortitems: A4,
+        stack: fS
     }, Symbol.toStringTag, {
         value: "Module"
     }));
-    var Mte = Math.abs,
-        U2 = Math.cos,
-        q0 = Math.sin,
-        Fte = 1e-6,
-        xL = Math.PI,
-        q2 = xL / 2,
-        l3 = Dte(2);
+    var zee = Math.abs,
+        y2 = Math.cos,
+        C0 = Math.sin,
+        Bee = 1e-6,
+        O4 = Math.PI,
+        v2 = O4 / 2,
+        wT = jee(2);
 
-    function u3(e) {
-        return e > 1 ? q2 : e < -1 ? -q2 : Math.asin(e)
+    function ST(e) {
+        return e > 1 ? v2 : e < -1 ? -v2 : Math.asin(e)
     }
 
-    function Dte(e) {
+    function jee(e) {
         return e > 0 ? Math.sqrt(e) : 0
     }
 
-    function Rte(e, t) {
-        var n = e * q0(t),
+    function Uee(e, t) {
+        var n = e * C0(t),
             i = 30,
             r;
-        do t -= r = (t + q0(t) - n) / (1 + U2(t)); while (Mte(r) > Fte && --i > 0);
+        do t -= r = (t + C0(t) - n) / (1 + y2(t)); while (zee(r) > Bee && --i > 0);
         return t / 2
     }
 
-    function Pte(e, t, n) {
-        function i(r, a) {
-            return [e * r * U2(a = Rte(n, a)), t * q0(a)]
+    function Gee(e, t, n) {
+        function i(r, s) {
+            return [e * r * y2(s = Uee(n, s)), t * C0(s)]
         }
-        return i.invert = function(r, a) {
-            return a = u3(a / t), [r / (e * U2(a)), u3((2 * a + q0(2 * a)) / n)]
+        return i.invert = function(r, s) {
+            return s = ST(s / t), [r / (e * y2(s)), ST((2 * s + C0(2 * s)) / n)]
         }, i
     }
-    var Nte = Pte(l3 / q2, l3, xL);
+    var Wee = Gee(wT / v2, wT, O4);
 
-    function Lte() {
-        return la(Nte).scale(169.529)
+    function qee() {
+        return es(Wee).scale(169.529)
     }
-    const Ite = yD(),
-        W2 = ["clipAngle", "clipExtent", "scale", "translate", "center", "rotate", "parallels", "precision", "reflectX", "reflectY", "coefficient", "distance", "fraction", "lobes", "parallel", "radius", "ratio", "spacing", "tilt"];
+    const Hee = $F(),
+        b2 = ["clipAngle", "clipExtent", "scale", "translate", "center", "rotate", "parallels", "precision", "reflectX", "reflectY", "coefficient", "distance", "fraction", "lobes", "parallel", "radius", "ratio", "spacing", "tilt"];
 
-    function jte(e, t) {
+    function Yee(e, t) {
         return function n() {
             const i = t();
-            return i.type = e, i.path = yD().projection(i), i.copy = i.copy || function() {
+            return i.type = e, i.path = $F().projection(i), i.copy = i.copy || function() {
                 const r = n();
-                return W2.forEach(a => {
-                    i[a] && r[a](i[a]())
+                return b2.forEach(s => {
+                    i[s] && r[s](i[s]())
                 }), r.path.pointRadius(i.path.pointRadius()), r
-            }, TN(i)
+            }, BN(i)
         }
     }
 
-    function HS(e, t) {
+    function hS(e, t) {
         if (!e || typeof e != "string") throw new Error("Projection type must be a name string.");
-        return e = e.toLowerCase(), arguments.length > 1 ? (W0[e] = jte(e, t), this) : W0[e] || null
+        return e = e.toLowerCase(), arguments.length > 1 ? (k0[e] = Yee(e, t), this) : k0[e] || null
     }
 
-    function _L(e) {
-        return e && e.path || Ite
+    function F4(e) {
+        return e && e.path || Hee
     }
-    const W0 = {
-        albers: bD,
-        albersusa: Pq,
-        azimuthalequalarea: Nq,
-        azimuthalequidistant: Lq,
-        conicconformal: zq,
-        conicequalarea: y0,
-        conicequidistant: Uq,
-        equalEarth: Wq,
-        equirectangular: Bq,
-        gnomonic: Hq,
-        identity: Yq,
-        mercator: Iq,
-        mollweide: Lte,
-        naturalEarth1: Xq,
-        orthographic: Vq,
-        stereographic: Kq,
-        transversemercator: Jq
+    const k0 = {
+        albers: MF,
+        albersusa: UG,
+        azimuthalequalarea: GG,
+        azimuthalequidistant: WG,
+        conicconformal: YG,
+        conicequalarea: Qp,
+        conicequidistant: KG,
+        equalEarth: QG,
+        equirectangular: XG,
+        gnomonic: ZG,
+        identity: eW,
+        mercator: qG,
+        mollweide: qee,
+        naturalEarth1: tW,
+        orthographic: nW,
+        stereographic: iW,
+        transversemercator: rW
     };
-    for (const e in W0) HS(e, W0[e]);
+    for (const e in k0) hS(e, k0[e]);
 
-    function zte() {}
-    const Sa = [
+    function Xee() {}
+    const ds = [
         [],
         [
             [
                 [1, 1.5],
                 [.5, 1]
             ]
         ],
@@ -26930,76 +26950,76 @@
                 [.5, 1],
                 [1, 1.5]
             ]
         ],
         []
     ];
 
-    function wL() {
+    function R4() {
         var e = 1,
             t = 1,
             n = o;
 
         function i(l, u) {
             return u.map(c => r(l, c))
         }
 
         function r(l, u) {
             var c = [],
                 f = [];
-            return a(l, u, h => {
-                n(h, l, u), Bte(h) > 0 ? c.push([h]) : f.push(h)
+            return s(l, u, h => {
+                n(h, l, u), Vee(h) > 0 ? c.push([h]) : f.push(h)
             }), f.forEach(h => {
                 for (var d = 0, g = c.length, p; d < g; ++d)
-                    if (Gte((p = c[d])[0], h) !== -1) {
+                    if (Kee((p = c[d])[0], h) !== -1) {
                         p.push(h);
                         return
                     }
             }), {
                 type: "MultiPolygon",
                 value: u,
                 coordinates: c
             }
         }
 
-        function a(l, u, c) {
+        function s(l, u, c) {
             var f = new Array,
                 h = new Array,
                 d, g, p, m, y, v;
-            for (d = g = -1, m = l[0] >= u, Sa[m << 1].forEach(b); ++d < e - 1;) p = m, m = l[d + 1] >= u, Sa[p | m << 1].forEach(b);
-            for (Sa[m << 0].forEach(b); ++g < t - 1;) {
-                for (d = -1, m = l[g * e + e] >= u, y = l[g * e] >= u, Sa[m << 1 | y << 2].forEach(b); ++d < e - 1;) p = m, m = l[g * e + e + d + 1] >= u, v = y, y = l[g * e + d + 1] >= u, Sa[p | m << 1 | y << 2 | v << 3].forEach(b);
-                Sa[m | y << 3].forEach(b)
+            for (d = g = -1, m = l[0] >= u, ds[m << 1].forEach(b); ++d < e - 1;) p = m, m = l[d + 1] >= u, ds[p | m << 1].forEach(b);
+            for (ds[m << 0].forEach(b); ++g < t - 1;) {
+                for (d = -1, m = l[g * e + e] >= u, y = l[g * e] >= u, ds[m << 1 | y << 2].forEach(b); ++d < e - 1;) p = m, m = l[g * e + e + d + 1] >= u, v = y, y = l[g * e + d + 1] >= u, ds[p | m << 1 | y << 2 | v << 3].forEach(b);
+                ds[m | y << 3].forEach(b)
             }
-            for (d = -1, y = l[g * e] >= u, Sa[y << 2].forEach(b); ++d < e - 1;) v = y, y = l[g * e + d + 1] >= u, Sa[y << 2 | v << 3].forEach(b);
-            Sa[y << 3].forEach(b);
+            for (d = -1, y = l[g * e] >= u, ds[y << 2].forEach(b); ++d < e - 1;) v = y, y = l[g * e + d + 1] >= u, ds[y << 2 | v << 3].forEach(b);
+            ds[y << 3].forEach(b);
 
             function b(x) {
                 var _ = [x[0][0] + d, x[0][1] + g],
                     S = [x[1][0] + d, x[1][1] + g],
-                    w = s(_),
-                    O = s(S),
-                    k, C;
-                (k = h[w]) ? (C = f[O]) ? (delete h[k.end], delete f[C.start], k === C ? (k.ring.push(S), c(k.ring)) : f[k.start] = h[C.end] = {
-                    start: k.start,
+                    w = a(_),
+                    E = a(S),
+                    A, C;
+                (A = h[w]) ? (C = f[E]) ? (delete h[A.end], delete f[C.start], A === C ? (A.ring.push(S), c(A.ring)) : f[A.start] = h[C.end] = {
+                    start: A.start,
                     end: C.end,
-                    ring: k.ring.concat(C.ring)
-                }) : (delete h[k.end], k.ring.push(S), h[k.end = O] = k) : (k = f[O]) ? (C = h[w]) ? (delete f[k.start], delete h[C.end], k === C ? (k.ring.push(S), c(k.ring)) : f[C.start] = h[k.end] = {
+                    ring: A.ring.concat(C.ring)
+                }) : (delete h[A.end], A.ring.push(S), h[A.end = E] = A) : (A = f[E]) ? (C = h[w]) ? (delete f[A.start], delete h[C.end], A === C ? (A.ring.push(S), c(A.ring)) : f[C.start] = h[A.end] = {
                     start: C.start,
-                    end: k.end,
-                    ring: C.ring.concat(k.ring)
-                }) : (delete f[k.start], k.ring.unshift(_), f[k.start = w] = k) : f[w] = h[O] = {
+                    end: A.end,
+                    ring: C.ring.concat(A.ring)
+                }) : (delete f[A.start], A.ring.unshift(_), f[A.start = w] = A) : f[w] = h[E] = {
                     start: w,
-                    end: O,
+                    end: E,
                     ring: [_, S]
                 }
             }
         }
 
-        function s(l) {
+        function a(l) {
             return l[0] * 2 + l[1] * (e + 1) * 4
         }
 
         function o(l, u, c) {
             l.forEach(f => {
                 var h = f[0],
                     d = f[1],
@@ -27009,73 +27029,73 @@
                 h > 0 && h < e && g === h && (m = u[p * e + g - 1], f[0] = h + (c - m) / (y - m) - .5), d > 0 && d < t && p === d && (m = u[(p - 1) * e + g], f[1] = d + (c - m) / (y - m) - .5)
             })
         }
         return i.contour = r, i.size = function(l) {
             if (!arguments.length) return [e, t];
             var u = Math.floor(l[0]),
                 c = Math.floor(l[1]);
-            return u >= 0 && c >= 0 || G("invalid size"), e = u, t = c, i
+            return u >= 0 && c >= 0 || U("invalid size"), e = u, t = c, i
         }, i.smooth = function(l) {
-            return arguments.length ? (n = l ? o : zte, i) : n === o
+            return arguments.length ? (n = l ? o : Xee, i) : n === o
         }, i
     }
 
-    function Bte(e) {
+    function Vee(e) {
         for (var t = 0, n = e.length, i = e[n - 1][1] * e[0][0] - e[n - 1][0] * e[0][1]; ++t < n;) i += e[t - 1][1] * e[t][0] - e[t - 1][0] * e[t][1];
         return i
     }
 
-    function Gte(e, t) {
+    function Kee(e, t) {
         for (var n = -1, i = t.length, r; ++n < i;)
-            if (r = Ute(e, t[n])) return r;
+            if (r = Jee(e, t[n])) return r;
         return 0
     }
 
-    function Ute(e, t) {
-        for (var n = t[0], i = t[1], r = -1, a = 0, s = e.length, o = s - 1; a < s; o = a++) {
-            var l = e[a],
+    function Jee(e, t) {
+        for (var n = t[0], i = t[1], r = -1, s = 0, a = e.length, o = a - 1; s < a; o = s++) {
+            var l = e[s],
                 u = l[0],
                 c = l[1],
                 f = e[o],
                 h = f[0],
                 d = f[1];
-            if (qte(l, f, t)) return 0;
+            if (Qee(l, f, t)) return 0;
             c > i != d > i && n < (h - u) * (i - c) / (d - c) + u && (r = -r)
         }
         return r
     }
 
-    function qte(e, t, n) {
+    function Qee(e, t, n) {
         var i;
-        return Wte(e, t, n) && Hte(e[i = +(e[0] === t[0])], n[i], t[i])
+        return Zee(e, t, n) && ete(e[i = +(e[0] === t[0])], n[i], t[i])
     }
 
-    function Wte(e, t, n) {
+    function Zee(e, t, n) {
         return (t[0] - e[0]) * (n[1] - e[1]) === (n[0] - e[0]) * (t[1] - e[1])
     }
 
-    function Hte(e, t, n) {
+    function ete(e, t, n) {
         return e <= t && t <= n || n <= t && t <= e
     }
 
-    function SL(e, t, n) {
+    function D4(e, t, n) {
         return function(i) {
-            var r = Zr(i),
-                a = n ? Math.min(r[0], 0) : r[0],
-                s = r[1],
-                o = s - a,
-                l = t ? Bs(a, s, e) : o / (e + 1);
-            return mi(a + l, s, l)
+            var r = Hr(i),
+                s = n ? Math.min(r[0], 0) : r[0],
+                a = r[1],
+                o = a - s,
+                l = t ? Oa(s, a, e) : o / (e + 1);
+            return gi(s + l, a, l)
         }
     }
 
-    function YS(e) {
+    function dS(e) {
         L.call(this, null, e)
     }
-    YS.Definition = {
+    dS.Definition = {
         type: "Isocontour",
         metadata: {
             generates: !0
         },
         params: [{
             name: "field",
             type: "field"
@@ -27115,153 +27135,153 @@
         }, {
             name: "as",
             type: "string",
             null: !0,
             default: "contour"
         }]
     };
-    Q(YS, L, {
+    ee(dS, L, {
         transform(e, t) {
             if (this.value && !t.changed() && !e.modified()) return t.StopPropagation;
             var n = t.fork(t.NO_SOURCE | t.NO_FIELDS),
                 i = t.materialize(t.SOURCE).source,
-                r = e.field || wn,
-                a = wL().smooth(e.smooth !== !1),
-                s = e.thresholds || Yte(i, r, e),
+                r = e.field || bn,
+                s = R4().smooth(e.smooth !== !1),
+                a = e.thresholds || tte(i, r, e),
                 o = e.as === null ? null : e.as || "contour",
                 l = [];
             return i.forEach(u => {
                 const c = r(u),
-                    f = a.size([c.width, c.height])(c.values, q(s) ? s : s(c.values));
-                Xte(f, c, u, e), f.forEach(h => {
-                    l.push(Qm(u, He(o != null ? {
+                    f = s.size([c.width, c.height])(c.values, W(a) ? a : a(c.values));
+                nte(f, c, u, e), f.forEach(h => {
+                    l.push(Rm(u, He(o != null ? {
                         [o]: h
                     } : h)))
                 })
             }), this.value && (n.rem = this.value), this.value = n.source = n.add = l, n
         }
     });
 
-    function Yte(e, t, n) {
-        const i = SL(n.levels || 10, n.nice, n.zero !== !1);
-        return n.resolve !== "shared" ? i : i(e.map(r => el(t(r).values)))
+    function tte(e, t, n) {
+        const i = D4(n.levels || 10, n.nice, n.zero !== !1);
+        return n.resolve !== "shared" ? i : i(e.map(r => jo(t(r).values)))
     }
 
-    function Xte(e, t, n, i) {
+    function nte(e, t, n, i) {
         let r = i.scale || t.scale,
-            a = i.translate || t.translate;
-        if (Ae(r) && (r = r(n, i)), Ae(a) && (a = a(n, i)), (r === 1 || r == null) && !a) return;
-        const s = (tt(r) ? r : r[0]) || 1,
-            o = (tt(r) ? r : r[1]) || 1,
-            l = a && a[0] || 0,
-            u = a && a[1] || 0;
-        e.forEach(EL(t, s, o, l, u))
+            s = i.translate || t.translate;
+        if ($e(r) && (r = r(n, i)), $e(s) && (s = s(n, i)), (r === 1 || r == null) && !s) return;
+        const a = (Ze(r) ? r : r[0]) || 1,
+            o = (Ze(r) ? r : r[1]) || 1,
+            l = s && s[0] || 0,
+            u = s && s[1] || 0;
+        e.forEach(N4(t, a, o, l, u))
     }
 
-    function EL(e, t, n, i, r) {
-        const a = e.x1 || 0,
-            s = e.y1 || 0,
+    function N4(e, t, n, i, r) {
+        const s = e.x1 || 0,
+            a = e.y1 || 0,
             o = t * n < 0;
 
         function l(f) {
             f.forEach(u)
         }
 
         function u(f) {
             o && f.reverse(), f.forEach(c)
         }
 
         function c(f) {
-            f[0] = (f[0] - a) * t + i, f[1] = (f[1] - s) * n + r
+            f[0] = (f[0] - s) * t + i, f[1] = (f[1] - a) * n + r
         }
         return function(f) {
             return f.coordinates.forEach(l), f
         }
     }
 
-    function c3(e, t, n) {
-        const i = e >= 0 ? e : cw(t, n);
+    function ET(e, t, n) {
+        const i = e >= 0 ? e : T_(t, n);
         return Math.round((Math.sqrt(4 * i * i + 1) - 1) / 2)
     }
 
-    function Cv(e) {
-        return Ae(e) ? e : Sn(+e)
+    function rv(e) {
+        return $e(e) ? e : xn(+e)
     }
 
-    function OL() {
+    function P4() {
         var e = l => l[0],
             t = l => l[1],
-            n = $c,
+            n = vc,
             i = [-1, -1],
             r = 960,
-            a = 500,
-            s = 2;
+            s = 500,
+            a = 2;
 
         function o(l, u) {
-            const c = c3(i[0], l, e) >> s,
-                f = c3(i[1], l, t) >> s,
+            const c = ET(i[0], l, e) >> a,
+                f = ET(i[1], l, t) >> a,
                 h = c ? c + 2 : 0,
                 d = f ? f + 2 : 0,
-                g = 2 * h + (r >> s),
-                p = 2 * d + (a >> s),
+                g = 2 * h + (r >> a),
+                p = 2 * d + (s >> a),
                 m = new Float32Array(g * p),
                 y = new Float32Array(g * p);
             let v = m;
             l.forEach(x => {
-                const _ = h + (+e(x) >> s),
-                    S = d + (+t(x) >> s);
+                const _ = h + (+e(x) >> a),
+                    S = d + (+t(x) >> a);
                 _ >= 0 && _ < g && S >= 0 && S < p && (m[_ + S * g] += +n(x))
-            }), c > 0 && f > 0 ? (lu(g, p, m, y, c), uu(g, p, y, m, f), lu(g, p, m, y, c), uu(g, p, y, m, f), lu(g, p, m, y, c), uu(g, p, y, m, f)) : c > 0 ? (lu(g, p, m, y, c), lu(g, p, y, m, c), lu(g, p, m, y, c), v = y) : f > 0 && (uu(g, p, m, y, f), uu(g, p, y, m, f), uu(g, p, m, y, f), v = y);
-            const b = u ? Math.pow(2, -2 * s) : 1 / $F(v);
+            }), c > 0 && f > 0 ? (Jl(g, p, m, y, c), Ql(g, p, y, m, f), Jl(g, p, m, y, c), Ql(g, p, y, m, f), Jl(g, p, m, y, c), Ql(g, p, y, m, f)) : c > 0 ? (Jl(g, p, m, y, c), Jl(g, p, y, m, c), Jl(g, p, m, y, c), v = y) : f > 0 && (Ql(g, p, m, y, f), Ql(g, p, y, m, f), Ql(g, p, m, y, f), v = y);
+            const b = u ? Math.pow(2, -2 * a) : 1 / jO(v);
             for (let x = 0, _ = g * p; x < _; ++x) v[x] *= b;
             return {
                 values: v,
-                scale: 1 << s,
+                scale: 1 << a,
                 width: g,
                 height: p,
                 x1: h,
                 y1: d,
-                x2: h + (r >> s),
-                y2: d + (a >> s)
+                x2: h + (r >> a),
+                y2: d + (s >> a)
             }
         }
         return o.x = function(l) {
-            return arguments.length ? (e = Cv(l), o) : e
+            return arguments.length ? (e = rv(l), o) : e
         }, o.y = function(l) {
-            return arguments.length ? (t = Cv(l), o) : t
+            return arguments.length ? (t = rv(l), o) : t
         }, o.weight = function(l) {
-            return arguments.length ? (n = Cv(l), o) : n
+            return arguments.length ? (n = rv(l), o) : n
         }, o.size = function(l) {
-            if (!arguments.length) return [r, a];
+            if (!arguments.length) return [r, s];
             var u = +l[0],
                 c = +l[1];
-            return u >= 0 && c >= 0 || G("invalid size"), r = u, a = c, o
+            return u >= 0 && c >= 0 || U("invalid size"), r = u, s = c, o
         }, o.cellSize = function(l) {
-            return arguments.length ? ((l = +l) >= 1 || G("invalid cell size"), s = Math.floor(Math.log(l) / Math.LN2), o) : 1 << s
+            return arguments.length ? ((l = +l) >= 1 || U("invalid cell size"), a = Math.floor(Math.log(l) / Math.LN2), o) : 1 << a
         }, o.bandwidth = function(l) {
-            return arguments.length ? (l = ie(l), l.length === 1 && (l = [+l[0], +l[0]]), l.length !== 2 && G("invalid bandwidth"), i = l, o) : i
+            return arguments.length ? (l = se(l), l.length === 1 && (l = [+l[0], +l[0]]), l.length !== 2 && U("invalid bandwidth"), i = l, o) : i
         }, o
     }
 
-    function lu(e, t, n, i, r) {
-        const a = (r << 1) + 1;
-        for (let s = 0; s < t; ++s)
-            for (let o = 0, l = 0; o < e + r; ++o) o < e && (l += n[o + s * e]), o >= r && (o >= a && (l -= n[o - a + s * e]), i[o - r + s * e] = l / Math.min(o + 1, e - 1 + a - o, a))
+    function Jl(e, t, n, i, r) {
+        const s = (r << 1) + 1;
+        for (let a = 0; a < t; ++a)
+            for (let o = 0, l = 0; o < e + r; ++o) o < e && (l += n[o + a * e]), o >= r && (o >= s && (l -= n[o - s + a * e]), i[o - r + a * e] = l / Math.min(o + 1, e - 1 + s - o, s))
     }
 
-    function uu(e, t, n, i, r) {
-        const a = (r << 1) + 1;
-        for (let s = 0; s < e; ++s)
-            for (let o = 0, l = 0; o < t + r; ++o) o < t && (l += n[s + o * e]), o >= r && (o >= a && (l -= n[s + (o - a) * e]), i[s + (o - r) * e] = l / Math.min(o + 1, t - 1 + a - o, a))
+    function Ql(e, t, n, i, r) {
+        const s = (r << 1) + 1;
+        for (let a = 0; a < e; ++a)
+            for (let o = 0, l = 0; o < t + r; ++o) o < t && (l += n[a + o * e]), o >= r && (o >= s && (l -= n[a + (o - s) * e]), i[a + (o - r) * e] = l / Math.min(o + 1, t - 1 + s - o, s))
     }
 
-    function XS(e) {
+    function gS(e) {
         L.call(this, null, e)
     }
-    XS.Definition = {
+    gS.Definition = {
         type: "KDE2D",
         metadata: {
             generates: !0
         },
         params: [{
             name: "size",
             type: "number",
@@ -27297,54 +27317,54 @@
             default: !1
         }, {
             name: "as",
             type: "string",
             default: "grid"
         }]
     };
-    const Vte = ["x", "y", "weight", "size", "cellSize", "bandwidth"];
+    const ite = ["x", "y", "weight", "size", "cellSize", "bandwidth"];
 
-    function CL(e, t) {
-        return Vte.forEach(n => t[n] != null ? e[n](t[n]) : 0), e
+    function L4(e, t) {
+        return ite.forEach(n => t[n] != null ? e[n](t[n]) : 0), e
     }
-    Q(XS, L, {
+    ee(gS, L, {
         transform(e, t) {
             if (this.value && !t.changed() && !e.modified()) return t.StopPropagation;
             var n = t.fork(t.NO_SOURCE | t.NO_FIELDS),
                 i = t.materialize(t.SOURCE).source,
-                r = Kte(i, e.groupby),
-                a = (e.groupby || []).map(wt),
-                s = CL(OL(), e),
+                r = rte(i, e.groupby),
+                s = (e.groupby || []).map(bt),
+                a = L4(P4(), e),
                 o = e.as || "grid",
                 l = [];
 
             function u(c, f) {
-                for (let h = 0; h < a.length; ++h) c[a[h]] = f[h];
+                for (let h = 0; h < s.length; ++h) c[s[h]] = f[h];
                 return c
             }
             return l = r.map(c => He(u({
-                [o]: s(c, e.counts)
+                [o]: a(c, e.counts)
             }, c.dims))), this.value && (n.rem = this.value), this.value = n.source = n.add = l, n
         }
     });
 
-    function Kte(e, t) {
+    function rte(e, t) {
         var n = [],
             i = c => c(o),
-            r, a, s, o, l, u;
+            r, s, a, o, l, u;
         if (t == null) n.push(e);
         else
-            for (r = {}, a = 0, s = e.length; a < s; ++a) o = e[a], l = t.map(i), u = r[l], u || (r[l] = u = [], u.dims = l, n.push(u)), u.push(o);
+            for (r = {}, s = 0, a = e.length; s < a; ++s) o = e[s], l = t.map(i), u = r[l], u || (r[l] = u = [], u.dims = l, n.push(u)), u.push(o);
         return n
     }
 
-    function VS(e) {
+    function pS(e) {
         L.call(this, null, e)
     }
-    VS.Definition = {
+    pS.Definition = {
         type: "Contour",
         metadata: {
             generates: !0
         },
         params: [{
             name: "size",
             type: "number",
@@ -27383,77 +27403,77 @@
             array: !0
         }, {
             name: "smooth",
             type: "boolean",
             default: !0
         }]
     };
-    Q(VS, L, {
+    ee(pS, L, {
         transform(e, t) {
             if (this.value && !t.changed() && !e.modified()) return t.StopPropagation;
             var n = t.fork(t.NO_SOURCE | t.NO_FIELDS),
-                i = wL().smooth(e.smooth !== !1),
+                i = R4().smooth(e.smooth !== !1),
                 r = e.values,
-                a = e.thresholds || SL(e.count || 10, e.nice, !!r),
-                s = e.size,
+                s = e.thresholds || D4(e.count || 10, e.nice, !!r),
+                a = e.size,
                 o, l;
-            return r || (r = t.materialize(t.SOURCE).source, o = CL(OL(), e)(r, !0), l = EL(o, o.scale || 1, o.scale || 1, 0, 0), s = [o.width, o.height], r = o.values), a = q(a) ? a : a(r), r = i.size(s)(r, a), l && r.forEach(l), this.value && (n.rem = this.value), this.value = n.source = n.add = (r || []).map(He), n
+            return r || (r = t.materialize(t.SOURCE).source, o = L4(P4(), e)(r, !0), l = N4(o, o.scale || 1, o.scale || 1, 0, 0), a = [o.width, o.height], r = o.values), s = W(s) ? s : s(r), r = i.size(a)(r, s), l && r.forEach(l), this.value && (n.rem = this.value), this.value = n.source = n.add = (r || []).map(He), n
         }
     });
-    const H2 = "Feature",
-        KS = "FeatureCollection",
-        Jte = "MultiPoint";
+    const x2 = "Feature",
+        mS = "FeatureCollection",
+        ste = "MultiPoint";
 
-    function JS(e) {
+    function yS(e) {
         L.call(this, null, e)
     }
-    JS.Definition = {
+    yS.Definition = {
         type: "GeoJSON",
         metadata: {},
         params: [{
             name: "fields",
             type: "field",
             array: !0,
             length: 2
         }, {
             name: "geojson",
             type: "field"
         }]
     };
-    Q(JS, L, {
+    ee(yS, L, {
         transform(e, t) {
             var n = this._features,
                 i = this._points,
                 r = e.fields,
-                a = r && r[0],
-                s = r && r[1],
-                o = e.geojson || !r && wn,
+                s = r && r[0],
+                a = r && r[1],
+                o = e.geojson || !r && bn,
                 l = t.ADD,
                 u;
-            u = e.modified() || t.changed(t.REM) || t.modified(yn(o)) || a && t.modified(yn(a)) || s && t.modified(yn(s)), (!this.value || u) && (l = t.SOURCE, this._features = n = [], this._points = i = []), o && t.visit(l, c => n.push(o(c))), a && s && (t.visit(l, c => {
-                var f = a(c),
-                    h = s(c);
+            u = e.modified() || t.changed(t.REM) || t.modified(pn(o)) || s && t.modified(pn(s)) || a && t.modified(pn(a)), (!this.value || u) && (l = t.SOURCE, this._features = n = [], this._points = i = []), o && t.visit(l, c => n.push(o(c))), s && a && (t.visit(l, c => {
+                var f = s(c),
+                    h = a(c);
                 f != null && h != null && (f = +f) === f && (h = +h) === h && i.push([f, h])
             }), n = n.concat({
-                type: H2,
+                type: x2,
                 geometry: {
-                    type: Jte,
+                    type: ste,
                     coordinates: i
                 }
             })), this.value = {
-                type: KS,
+                type: mS,
                 features: n
             }
         }
     });
 
-    function QS(e) {
+    function vS(e) {
         L.call(this, null, e)
     }
-    QS.Definition = {
+    vS.Definition = {
         type: "GeoPath",
         metadata: {
             modifies: !0
         },
         params: [{
             name: "projection",
             type: "projection"
@@ -27466,36 +27486,36 @@
             expr: !0
         }, {
             name: "as",
             type: "string",
             default: "path"
         }]
     };
-    Q(QS, L, {
+    ee(vS, L, {
         transform(e, t) {
             var n = t.fork(t.ALL),
                 i = this.value,
-                r = e.field || wn,
-                a = e.as || "path",
-                s = n.SOURCE;
-            !i || e.modified() ? (this.value = i = _L(e.projection), n.materialize().reflow()) : s = r === wn || t.modified(r.fields) ? n.ADD_MOD : n.ADD;
-            const o = Qte(i, e.pointRadius);
-            return n.visit(s, l => l[a] = i(r(l))), i.pointRadius(o), n.modifies(a)
+                r = e.field || bn,
+                s = e.as || "path",
+                a = n.SOURCE;
+            !i || e.modified() ? (this.value = i = F4(e.projection), n.materialize().reflow()) : a = r === bn || t.modified(r.fields) ? n.ADD_MOD : n.ADD;
+            const o = ate(i, e.pointRadius);
+            return n.visit(a, l => l[s] = i(r(l))), i.pointRadius(o), n.modifies(s)
         }
     });
 
-    function Qte(e, t) {
+    function ate(e, t) {
         const n = e.pointRadius();
         return e.context(null), t != null && e.pointRadius(t), n
     }
 
-    function ZS(e) {
+    function bS(e) {
         L.call(this, null, e)
     }
-    ZS.Definition = {
+    bS.Definition = {
         type: "GeoPoint",
         metadata: {
             modifies: !0
         },
         params: [{
             name: "projection",
             type: "projection",
@@ -27510,36 +27530,36 @@
             name: "as",
             type: "string",
             array: !0,
             length: 2,
             default: ["x", "y"]
         }]
     };
-    Q(ZS, L, {
+    ee(bS, L, {
         transform(e, t) {
             var n = e.projection,
                 i = e.fields[0],
                 r = e.fields[1],
-                a = e.as || ["x", "y"],
-                s = a[0],
-                o = a[1],
+                s = e.as || ["x", "y"],
+                a = s[0],
+                o = s[1],
                 l;
 
             function u(c) {
                 const f = n([i(c), r(c)]);
-                f ? (c[s] = f[0], c[o] = f[1]) : (c[s] = void 0, c[o] = void 0)
+                f ? (c[a] = f[0], c[o] = f[1]) : (c[a] = void 0, c[o] = void 0)
             }
-            return e.modified() ? t = t.materialize().reflow(!0).visit(t.SOURCE, u) : (l = t.modified(i.fields) || t.modified(r.fields), t.visit(l ? t.ADD_MOD : t.ADD, u)), t.modifies(a)
+            return e.modified() ? t = t.materialize().reflow(!0).visit(t.SOURCE, u) : (l = t.modified(i.fields) || t.modified(r.fields), t.visit(l ? t.ADD_MOD : t.ADD, u)), t.modifies(s)
         }
     });
 
-    function eE(e) {
+    function xS(e) {
         L.call(this, null, e)
     }
-    eE.Definition = {
+    xS.Definition = {
         type: "GeoShape",
         metadata: {
             modifies: !0,
             nomod: !0
         },
         params: [{
             name: "projection",
@@ -27554,37 +27574,37 @@
             expr: !0
         }, {
             name: "as",
             type: "string",
             default: "shape"
         }]
     };
-    Q(eE, L, {
+    ee(xS, L, {
         transform(e, t) {
             var n = t.fork(t.ALL),
                 i = this.value,
                 r = e.as || "shape",
-                a = n.ADD;
-            return (!i || e.modified()) && (this.value = i = Zte(_L(e.projection), e.field || ri("datum"), e.pointRadius), n.materialize().reflow(), a = n.SOURCE), n.visit(a, s => s[r] = i), n.modifies(r)
+                s = n.ADD;
+            return (!i || e.modified()) && (this.value = i = ote(F4(e.projection), e.field || ni("datum"), e.pointRadius), n.materialize().reflow(), s = n.SOURCE), n.visit(s, a => a[r] = i), n.modifies(r)
         }
     });
 
-    function Zte(e, t, n) {
+    function ote(e, t, n) {
         const i = n == null ? r => e(t(r)) : r => {
-            var a = e.pointRadius(),
-                s = e.pointRadius(n)(t(r));
-            return e.pointRadius(a), s
+            var s = e.pointRadius(),
+                a = e.pointRadius(n)(t(r));
+            return e.pointRadius(s), a
         };
         return i.context = r => (e.context(r), i), i
     }
 
-    function tE(e) {
-        L.call(this, [], e), this.generator = dq()
+    function _S(e) {
+        L.call(this, [], e), this.generator = xG()
     }
-    tE.Definition = {
+    _S.Definition = {
         type: "Graticule",
         metadata: {
             changes: !0,
             generates: !0
         },
         params: [{
             name: "extent",
@@ -27635,29 +27655,29 @@
             default: [10, 10]
         }, {
             name: "precision",
             type: "number",
             default: 2.5
         }]
     };
-    Q(tE, L, {
+    ee(_S, L, {
         transform(e, t) {
             var n = this.value,
                 i = this.generator,
                 r;
             if (!n.length || e.modified())
-                for (const a in e) Ae(i[a]) && i[a](e[a]);
-            return r = i(), n.length ? t.mod.push(DP(n[0], r)) : t.add.push(He(r)), n[0] = r, t
+                for (const s in e) $e(i[s]) && i[s](e[s]);
+            return r = i(), n.length ? t.mod.push(WD(n[0], r)) : t.add.push(He(r)), n[0] = r, t
         }
     });
 
-    function nE(e) {
+    function wS(e) {
         L.call(this, null, e)
     }
-    nE.Definition = {
+    wS.Definition = {
         type: "heatmap",
         metadata: {
             modifies: !0
         },
         params: [{
             name: "field",
             type: "field"
@@ -27676,150 +27696,150 @@
             default: "independent"
         }, {
             name: "as",
             type: "string",
             default: "image"
         }]
     };
-    Q(nE, L, {
+    ee(wS, L, {
         transform(e, t) {
             if (!t.changed() && !e.modified()) return t.StopPropagation;
             var n = t.materialize(t.SOURCE).source,
                 i = e.resolve === "shared",
-                r = e.field || wn,
-                a = tne(e.opacity, e),
-                s = ene(e.color, e),
+                r = e.field || bn,
+                s = ute(e.opacity, e),
+                a = lte(e.color, e),
                 o = e.as || "image",
                 l = {
                     $x: 0,
                     $y: 0,
                     $value: 0,
-                    $max: i ? el(n.map(u => el(r(u).values))) : 0
+                    $max: i ? jo(n.map(u => jo(r(u).values))) : 0
                 };
             return n.forEach(u => {
                 const c = r(u),
-                    f = ke({}, u, l);
-                i || (f.$max = el(c.values || [])), u[o] = nne(c, f, s.dep ? s : Sn(s(f)), a.dep ? a : Sn(a(f)))
+                    f = Ae({}, u, l);
+                i || (f.$max = jo(c.values || [])), u[o] = cte(c, f, a.dep ? a : xn(a(f)), s.dep ? s : xn(s(f)))
             }), t.reflow(!0).modifies(o)
         }
     });
 
-    function ene(e, t) {
+    function lte(e, t) {
         let n;
-        return Ae(e) ? (n = i => zs(e(i, t)), n.dep = kL(e)) : n = Sn(zs(e || "#888")), n
+        return $e(e) ? (n = i => Ma(e(i, t)), n.dep = I4(e)) : n = xn(Ma(e || "#888")), n
     }
 
-    function tne(e, t) {
+    function ute(e, t) {
         let n;
-        return Ae(e) ? (n = i => e(i, t), n.dep = kL(e)) : e ? n = Sn(e) : (n = i => i.$value / i.$max || 0, n.dep = !0), n
+        return $e(e) ? (n = i => e(i, t), n.dep = I4(e)) : e ? n = xn(e) : (n = i => i.$value / i.$max || 0, n.dep = !0), n
     }
 
-    function kL(e) {
-        if (!Ae(e)) return !1;
-        const t = br(yn(e));
+    function I4(e) {
+        if (!$e(e)) return !1;
+        const t = fr(pn(e));
         return t.$x || t.$y || t.$value || t.$max
     }
 
-    function nne(e, t, n, i) {
+    function cte(e, t, n, i) {
         const r = e.width,
-            a = e.height,
-            s = e.x1 || 0,
+            s = e.height,
+            a = e.x1 || 0,
             o = e.y1 || 0,
             l = e.x2 || r,
-            u = e.y2 || a,
+            u = e.y2 || s,
             c = e.values,
-            f = c ? m => c[m] : ws,
-            h = Ps(l - s, u - o),
+            f = c ? m => c[m] : ha,
+            h = ka(l - a, u - o),
             d = h.getContext("2d"),
-            g = d.getImageData(0, 0, l - s, u - o),
+            g = d.getImageData(0, 0, l - a, u - o),
             p = g.data;
         for (let m = o, y = 0; m < u; ++m) {
             t.$y = m - o;
-            for (let v = s, b = m * r; v < l; ++v, y += 4) {
-                t.$x = v - s, t.$value = f(v + b);
+            for (let v = a, b = m * r; v < l; ++v, y += 4) {
+                t.$x = v - a, t.$value = f(v + b);
                 const x = n(t);
                 p[y + 0] = x.r, p[y + 1] = x.g, p[y + 2] = x.b, p[y + 3] = ~~(255 * i(t))
             }
         }
         return d.putImageData(g, 0, 0), h
     }
 
-    function AL(e) {
+    function z4(e) {
         L.call(this, null, e), this.modified(!0)
     }
-    Q(AL, L, {
+    ee(z4, L, {
         transform(e, t) {
             let n = this.value;
-            return !n || e.modified("type") ? (this.value = n = rne(e.type), W2.forEach(i => {
-                e[i] != null && f3(n, i, e[i])
-            })) : W2.forEach(i => {
-                e.modified(i) && f3(n, i, e[i])
-            }), e.pointRadius != null && n.path.pointRadius(e.pointRadius), e.fit && ine(n, e), t.fork(t.NO_SOURCE | t.NO_FIELDS)
+            return !n || e.modified("type") ? (this.value = n = hte(e.type), b2.forEach(i => {
+                e[i] != null && CT(n, i, e[i])
+            })) : b2.forEach(i => {
+                e.modified(i) && CT(n, i, e[i])
+            }), e.pointRadius != null && n.path.pointRadius(e.pointRadius), e.fit && fte(n, e), t.fork(t.NO_SOURCE | t.NO_FIELDS)
         }
     });
 
-    function ine(e, t) {
-        const n = ane(t.fit);
+    function fte(e, t) {
+        const n = dte(t.fit);
         t.extent ? e.fitExtent(t.extent, n) : t.size && e.fitSize(t.size, n)
     }
 
-    function rne(e) {
-        const t = HS((e || "mercator").toLowerCase());
-        return t || G("Unrecognized projection type: " + e), t()
+    function hte(e) {
+        const t = hS((e || "mercator").toLowerCase());
+        return t || U("Unrecognized projection type: " + e), t()
     }
 
-    function f3(e, t, n) {
-        Ae(e[t]) && e[t](n)
+    function CT(e, t, n) {
+        $e(e[t]) && e[t](n)
     }
 
-    function ane(e) {
-        return e = ie(e), e.length === 1 ? e[0] : {
-            type: KS,
-            features: e.reduce((t, n) => t.concat(sne(n)), [])
+    function dte(e) {
+        return e = se(e), e.length === 1 ? e[0] : {
+            type: mS,
+            features: e.reduce((t, n) => t.concat(gte(n)), [])
         }
     }
 
-    function sne(e) {
-        return e.type === KS ? e.features : ie(e).filter(t => t != null).map(t => t.type === H2 ? t : {
-            type: H2,
+    function gte(e) {
+        return e.type === mS ? e.features : se(e).filter(t => t != null).map(t => t.type === x2 ? t : {
+            type: x2,
             geometry: t
         })
     }
-    const one = Object.freeze(Object.defineProperty({
+    const pte = Object.freeze(Object.defineProperty({
             __proto__: null,
-            contour: VS,
-            geojson: JS,
-            geopath: QS,
-            geopoint: ZS,
-            geoshape: eE,
-            graticule: tE,
-            heatmap: nE,
-            isocontour: YS,
-            kde2d: XS,
-            projection: AL
+            contour: pS,
+            geojson: yS,
+            geopath: vS,
+            geopoint: bS,
+            geoshape: xS,
+            graticule: _S,
+            heatmap: wS,
+            isocontour: dS,
+            kde2d: gS,
+            projection: z4
         }, Symbol.toStringTag, {
             value: "Module"
         })),
-        h3 = {
-            center: iU,
-            collide: wU,
-            nbody: DU,
-            link: EU,
-            x: RU,
-            y: PU
-        },
-        Qf = "forces",
-        Y2 = ["alpha", "alphaMin", "alphaTarget", "velocityDecay", "forces"],
-        lne = ["static", "iterations"],
-        TL = ["x", "y", "vx", "vy"];
+        kT = {
+            center: cU,
+            collide: TU,
+            nbody: BU,
+            link: OU,
+            x: jU,
+            y: UU
+        },
+        Bf = "forces",
+        _2 = ["alpha", "alphaMin", "alphaTarget", "velocityDecay", "forces"],
+        mte = ["static", "iterations"],
+        B4 = ["x", "y", "vx", "vy"];
 
-    function iE(e) {
+    function SS(e) {
         L.call(this, null, e)
     }
-    iE.Definition = {
+    SS.Definition = {
         type: "Force",
         metadata: {
             modifies: !0
         },
         params: [{
             name: "static",
             type: "boolean",
@@ -27953,201 +27973,201 @@
                 }]
             }]
         }, {
             name: "as",
             type: "string",
             array: !0,
             modify: !1,
-            default: TL
+            default: B4
         }]
     };
-    Q(iE, L, {
+    ee(SS, L, {
         transform(e, t) {
             var n = this.value,
                 i = t.changed(t.ADD_REM),
-                r = e.modified(Y2),
-                a = e.iterations || 300;
-            if (n ? (i && (t.modifies("index"), n.nodes(t.source)), (r || t.changed(t.MOD)) && $L(n, e, 0, t)) : (this.value = n = cne(t.source, e), n.on("tick", une(t.dataflow, this)), e.static || (i = !0, n.tick()), t.modifies("index")), r || i || e.modified(lne) || t.changed() && e.restart) {
-                if (n.alpha(Math.max(n.alpha(), e.alpha || 1)).alphaDecay(1 - Math.pow(n.alphaMin(), 1 / a)), e.static)
-                    for (n.stop(); --a >= 0;) n.tick();
+                r = e.modified(_2),
+                s = e.iterations || 300;
+            if (n ? (i && (t.modifies("index"), n.nodes(t.source)), (r || t.changed(t.MOD)) && j4(n, e, 0, t)) : (this.value = n = vte(t.source, e), n.on("tick", yte(t.dataflow, this)), e.static || (i = !0, n.tick()), t.modifies("index")), r || i || e.modified(mte) || t.changed() && e.restart) {
+                if (n.alpha(Math.max(n.alpha(), e.alpha || 1)).alphaDecay(1 - Math.pow(n.alphaMin(), 1 / s)), e.static)
+                    for (n.stop(); --s >= 0;) n.tick();
                 else if (n.stopped() && n.restart(), !i) return t.StopPropagation
             }
             return this.finish(e, t)
         },
         finish(e, t) {
             const n = t.dataflow;
             for (let o = this._argops, l = 0, u = o.length, c; l < u; ++l)
-                if (c = o[l], !(c.name !== Qf || c.op._argval.force !== "link")) {
-                    for (var i = c.op._argops, r = 0, a = i.length, s; r < a; ++r)
-                        if (i[r].name === "links" && (s = i[r].op.source)) {
-                            n.pulse(s, n.changeset().reflow());
+                if (c = o[l], !(c.name !== Bf || c.op._argval.force !== "link")) {
+                    for (var i = c.op._argops, r = 0, s = i.length, a; r < s; ++r)
+                        if (i[r].name === "links" && (a = i[r].op.source)) {
+                            n.pulse(a, n.changeset().reflow());
                             break
                         }
-                } return t.reflow(e.modified()).modifies(TL)
+                } return t.reflow(e.modified()).modifies(B4)
         }
     });
 
-    function une(e, t) {
+    function yte(e, t) {
         return () => e.touch(t).run()
     }
 
-    function cne(e, t) {
-        const n = FU(e),
+    function vte(e, t) {
+        const n = zU(e),
             i = n.stop,
             r = n.restart;
-        let a = !1;
-        return n.stopped = () => a, n.restart = () => (a = !1, r()), n.stop = () => (a = !0, i()), $L(n, t, !0).on("end", () => a = !0)
+        let s = !1;
+        return n.stopped = () => s, n.restart = () => (s = !1, r()), n.stop = () => (s = !0, i()), j4(n, t, !0).on("end", () => s = !0)
     }
 
-    function $L(e, t, n, i) {
-        var r = ie(t.forces),
-            a, s, o, l;
-        for (a = 0, s = Y2.length; a < s; ++a) o = Y2[a], o !== Qf && t.modified(o) && e[o](t[o]);
-        for (a = 0, s = r.length; a < s; ++a) l = Qf + a, o = n || t.modified(Qf, a) ? hne(r[a]) : i && fne(r[a], i) ? e.force(l) : null, o && e.force(l, o);
-        for (s = e.numForces || 0; a < s; ++a) e.force(Qf + a, null);
+    function j4(e, t, n, i) {
+        var r = se(t.forces),
+            s, a, o, l;
+        for (s = 0, a = _2.length; s < a; ++s) o = _2[s], o !== Bf && t.modified(o) && e[o](t[o]);
+        for (s = 0, a = r.length; s < a; ++s) l = Bf + s, o = n || t.modified(Bf, s) ? xte(r[s]) : i && bte(r[s], i) ? e.force(l) : null, o && e.force(l, o);
+        for (a = e.numForces || 0; s < a; ++s) e.force(Bf + s, null);
         return e.numForces = r.length, e
     }
 
-    function fne(e, t) {
+    function bte(e, t) {
         var n, i;
         for (n in e)
-            if (Ae(i = e[n]) && t.modified(yn(i))) return 1;
+            if ($e(i = e[n]) && t.modified(pn(i))) return 1;
         return 0
     }
 
-    function hne(e) {
+    function xte(e) {
         var t, n;
-        pe(h3, e.force) || G("Unrecognized force: " + e.force), t = h3[e.force]();
-        for (n in e) Ae(t[n]) && dne(t[n], e[n], e);
+        me(kT, e.force) || U("Unrecognized force: " + e.force), t = kT[e.force]();
+        for (n in e) $e(t[n]) && _te(t[n], e[n], e);
         return t
     }
 
-    function dne(e, t, n) {
-        e(Ae(t) ? i => t(i, n) : t)
+    function _te(e, t, n) {
+        e($e(t) ? i => t(i, n) : t)
     }
-    const gne = Object.freeze(Object.defineProperty({
+    const wte = Object.freeze(Object.defineProperty({
         __proto__: null,
-        force: iE
+        force: SS
     }, Symbol.toStringTag, {
         value: "Module"
     }));
 
-    function X2(e, t, n) {
+    function w2(e, t, n) {
         const i = {};
         return e.each(r => {
-            const a = r.data;
-            n(a) && (i[t(a)] = r)
+            const s = r.data;
+            n(s) && (i[t(s)] = r)
         }), e.lookup = i, e
     }
 
-    function rE(e) {
+    function ES(e) {
         L.call(this, null, e)
     }
-    rE.Definition = {
+    ES.Definition = {
         type: "Nest",
         metadata: {
             treesource: !0,
             changes: !0
         },
         params: [{
             name: "keys",
             type: "field",
             array: !0
         }, {
             name: "generate",
             type: "boolean"
         }]
     };
-    const pne = e => e.values;
-    Q(rE, L, {
+    const Ste = e => e.values;
+    ee(ES, L, {
         transform(e, t) {
-            t.source || G("Nest transform requires an upstream data source.");
+            t.source || U("Nest transform requires an upstream data source.");
             var n = e.generate,
                 i = e.modified(),
                 r = t.clone(),
-                a = this.value;
-            return (!a || i || t.changed()) && (a && a.each(s => {
-                s.children && Jm(s.data) && r.rem.push(s.data)
-            }), this.value = a = __({
-                values: ie(e.keys).reduce((s, o) => (s.key(o), s), mne()).entries(r.source)
-            }, pne), n && a.each(s => {
-                s.children && (s = He(s.data), r.add.push(s), r.source.push(s))
-            }), X2(a, de, de)), r.source.root = a, r
+                s = this.value;
+            return (!s || i || t.changed()) && (s && s.each(a => {
+                a.children && Fm(a.data) && r.rem.push(a.data)
+            }), this.value = s = Bx({
+                values: se(e.keys).reduce((a, o) => (a.key(o), a), Ete()).entries(r.source)
+            }, Ste), n && s.each(a => {
+                a.children && (a = He(a.data), r.add.push(a), r.source.push(a))
+            }), w2(s, ge, ge)), r.source.root = s, r
         }
     });
 
-    function mne() {
+    function Ete() {
         const e = [],
             t = {
                 entries: r => i(n(r, 0), 0),
                 key: r => (e.push(r), t)
             };
 
-        function n(r, a) {
-            if (a >= e.length) return r;
-            const s = r.length,
-                o = e[a++],
+        function n(r, s) {
+            if (s >= e.length) return r;
+            const a = r.length,
+                o = e[s++],
                 l = {},
                 u = {};
             let c = -1,
                 f, h, d;
-            for (; ++c < s;) f = o(h = r[c]) + "", (d = l[f]) ? d.push(h) : l[f] = [h];
-            for (f in l) u[f] = n(l[f], a);
+            for (; ++c < a;) f = o(h = r[c]) + "", (d = l[f]) ? d.push(h) : l[f] = [h];
+            for (f in l) u[f] = n(l[f], s);
             return u
         }
 
-        function i(r, a) {
-            if (++a > e.length) return r;
-            const s = [];
-            for (const o in r) s.push({
+        function i(r, s) {
+            if (++s > e.length) return r;
+            const a = [];
+            for (const o in r) a.push({
                 key: o,
-                values: i(r[o], a)
+                values: i(r[o], s)
             });
-            return s
+            return a
         }
         return t
     }
 
-    function ts(e) {
+    function Hs(e) {
         L.call(this, null, e)
     }
-    const yne = (e, t) => e.parent === t.parent ? 1 : 2;
-    Q(ts, L, {
+    const Cte = (e, t) => e.parent === t.parent ? 1 : 2;
+    ee(Hs, L, {
         transform(e, t) {
-            (!t.source || !t.source.root) && G(this.constructor.name + " transform requires a backing tree data source.");
+            (!t.source || !t.source.root) && U(this.constructor.name + " transform requires a backing tree data source.");
             const n = this.layout(e.method),
                 i = this.fields,
                 r = t.source.root,
-                a = e.as || i;
-            e.field ? r.sum(e.field) : r.count(), e.sort && r.sort(jl(e.sort, s => s.data)), vne(n, this.params, e), n.separation && n.separation(e.separation !== !1 ? yne : $c);
+                s = e.as || i;
+            e.field ? r.sum(e.field) : r.count(), e.sort && r.sort($l(e.sort, a => a.data)), kte(n, this.params, e), n.separation && n.separation(e.separation !== !1 ? Cte : vc);
             try {
                 this.value = n(r)
-            } catch (s) {
-                G(s)
+            } catch (a) {
+                U(a)
             }
-            return r.each(s => bne(s, i, a)), t.reflow(e.modified()).modifies(a).modifies("leaf")
+            return r.each(a => Ate(a, i, s)), t.reflow(e.modified()).modifies(s).modifies("leaf")
         }
     });
 
-    function vne(e, t, n) {
-        for (let i, r = 0, a = t.length; r < a; ++r) i = t[r], i in n && e[i](n[i])
+    function kte(e, t, n) {
+        for (let i, r = 0, s = t.length; r < s; ++r) i = t[r], i in n && e[i](n[i])
     }
 
-    function bne(e, t, n) {
+    function Ate(e, t, n) {
         const i = e.data,
             r = t.length - 1;
-        for (let a = 0; a < r; ++a) i[n[a]] = e[t[a]];
+        for (let s = 0; s < r; ++s) i[n[s]] = e[t[s]];
         i[n[r]] = e.children ? e.children.length : 0
     }
-    const V2 = ["x", "y", "r", "depth", "children"];
+    const S2 = ["x", "y", "r", "depth", "children"];
 
-    function aE(e) {
-        ts.call(this, e)
+    function CS(e) {
+        Hs.call(this, e)
     }
-    aE.Definition = {
+    CS.Definition = {
         type: "Pack",
         metadata: {
             tree: !0,
             modifies: !0
         },
         params: [{
             name: "field",
@@ -28168,29 +28188,29 @@
             type: "number",
             array: !0,
             length: 2
         }, {
             name: "as",
             type: "string",
             array: !0,
-            length: V2.length,
-            default: V2
+            length: S2.length,
+            default: S2
         }]
     };
-    Q(aE, ts, {
-        layout: NW,
+    ee(CS, Hs, {
+        layout: GW,
         params: ["radius", "size", "padding"],
-        fields: V2
+        fields: S2
     });
-    const K2 = ["x0", "y0", "x1", "y1", "depth", "children"];
+    const E2 = ["x0", "y0", "x1", "y1", "depth", "children"];
 
-    function sE(e) {
-        ts.call(this, e)
+    function kS(e) {
+        Hs.call(this, e)
     }
-    sE.Definition = {
+    kS.Definition = {
         type: "Partition",
         metadata: {
             tree: !0,
             modifies: !0
         },
         params: [{
             name: "field",
@@ -28211,62 +28231,62 @@
             type: "number",
             array: !0,
             length: 2
         }, {
             name: "as",
             type: "string",
             array: !0,
-            length: K2.length,
-            default: K2
+            length: E2.length,
+            default: E2
         }]
     };
-    Q(sE, ts, {
-        layout: LW,
+    ee(kS, Hs, {
+        layout: WW,
         params: ["size", "round", "padding"],
-        fields: K2
+        fields: E2
     });
 
-    function oE(e) {
+    function AS(e) {
         L.call(this, null, e)
     }
-    oE.Definition = {
+    AS.Definition = {
         type: "Stratify",
         metadata: {
             treesource: !0
         },
         params: [{
             name: "key",
             type: "field",
             required: !0
         }, {
             name: "parentKey",
             type: "field",
             required: !0
         }]
     };
-    Q(oE, L, {
+    ee(AS, L, {
         transform(e, t) {
-            t.source || G("Stratify transform requires an upstream data source.");
+            t.source || U("Stratify transform requires an upstream data source.");
             let n = this.value;
             const i = e.modified(),
                 r = t.fork(t.ALL).materialize(t.SOURCE),
-                a = !n || i || t.changed(t.ADD_REM) || t.modified(e.key.fields) || t.modified(e.parentKey.fields);
-            return r.source = r.source.slice(), a && (n = r.source.length ? X2(wA().id(e.key).parentId(e.parentKey)(r.source), e.key, Ii) : X2(wA()([{}]), e.key, e.key)), r.source.root = this.value = n, r
+                s = !n || i || t.changed(t.ADD_REM) || t.modified(e.key.fields) || t.modified(e.parentKey.fields);
+            return r.source = r.source.slice(), s && (n = r.source.length ? w2(PA().id(e.key).parentId(e.parentKey)(r.source), e.key, Ri) : w2(PA()([{}]), e.key, e.key)), r.source.root = this.value = n, r
         }
     });
-    const d3 = {
-            tidy: YW,
-            cluster: aW
+    const AT = {
+            tidy: eq,
+            cluster: hW
         },
-        J2 = ["x", "y", "depth", "children"];
+        C2 = ["x", "y", "depth", "children"];
 
-    function lE(e) {
-        ts.call(this, e)
+    function $S(e) {
+        Hs.call(this, e)
     }
-    lE.Definition = {
+    $S.Definition = {
         type: "Tree",
         metadata: {
             tree: !0,
             modifies: !0
         },
         params: [{
             name: "field",
@@ -28293,72 +28313,72 @@
             name: "separation",
             type: "boolean",
             default: !0
         }, {
             name: "as",
             type: "string",
             array: !0,
-            length: J2.length,
-            default: J2
+            length: C2.length,
+            default: C2
         }]
     };
-    Q(lE, ts, {
+    ee($S, Hs, {
         layout(e) {
             const t = e || "tidy";
-            if (pe(d3, t)) return d3[t]();
-            G("Unrecognized Tree layout method: " + t)
+            if (me(AT, t)) return AT[t]();
+            U("Unrecognized Tree layout method: " + t)
         },
         params: ["size", "nodeSize"],
-        fields: J2
+        fields: C2
     });
 
-    function uE(e) {
+    function TS(e) {
         L.call(this, [], e)
     }
-    uE.Definition = {
+    TS.Definition = {
         type: "TreeLinks",
         metadata: {
             tree: !0,
             generates: !0,
             changes: !0
         },
         params: []
     };
-    Q(uE, L, {
+    ee(TS, L, {
         transform(e, t) {
             const n = this.value,
                 i = t.source && t.source.root,
                 r = t.fork(t.NO_SOURCE),
-                a = {};
-            return i || G("TreeLinks transform requires a tree data source."), t.changed(t.ADD_REM) ? (r.rem = n, t.visit(t.SOURCE, s => a[de(s)] = 1), i.each(s => {
-                const o = s.data,
-                    l = s.parent && s.parent.data;
-                l && a[de(o)] && a[de(l)] && r.add.push(He({
+                s = {};
+            return i || U("TreeLinks transform requires a tree data source."), t.changed(t.ADD_REM) ? (r.rem = n, t.visit(t.SOURCE, a => s[ge(a)] = 1), i.each(a => {
+                const o = a.data,
+                    l = a.parent && a.parent.data;
+                l && s[ge(o)] && s[ge(l)] && r.add.push(He({
                     source: l,
                     target: o
                 }))
-            }), this.value = r.add) : t.changed(t.MOD) && (t.visit(t.MOD, s => a[de(s)] = 1), n.forEach(s => {
-                (a[de(s.source)] || a[de(s.target)]) && r.mod.push(s)
+            }), this.value = r.add) : t.changed(t.MOD) && (t.visit(t.MOD, a => s[ge(a)] = 1), n.forEach(a => {
+                (s[ge(a.source)] || s[ge(a.target)]) && r.mod.push(a)
             })), r
         }
     });
-    const g3 = {
-            binary: VW,
-            dice: pd,
-            slice: Fm,
-            slicedice: KW,
-            squarify: LD,
-            resquarify: JW
+    const $T = {
+            binary: nq,
+            dice: id,
+            slice: hm,
+            slicedice: iq,
+            squarify: XF,
+            resquarify: rq
         },
-        Q2 = ["x0", "y0", "x1", "y1", "depth", "children"];
+        k2 = ["x0", "y0", "x1", "y1", "depth", "children"];
 
-    function cE(e) {
-        ts.call(this, e)
+    function MS(e) {
+        Hs.call(this, e)
     }
-    cE.Definition = {
+    MS.Definition = {
         type: "Treemap",
         metadata: {
             tree: !0,
             modifies: !0
         },
         params: [{
             name: "field",
@@ -28412,394 +28432,394 @@
             type: "number",
             array: !0,
             length: 2
         }, {
             name: "as",
             type: "string",
             array: !0,
-            length: Q2.length,
-            default: Q2
+            length: k2.length,
+            default: k2
         }]
     };
-    Q(cE, ts, {
+    ee(MS, Hs, {
         layout() {
-            const e = XW();
+            const e = tq();
             return e.ratio = t => {
                 const n = e.tile();
                 n.ratio && e.tile(n.ratio(t))
             }, e.method = t => {
-                pe(g3, t) ? e.tile(g3[t]) : G("Unrecognized Treemap layout method: " + t)
+                me($T, t) ? e.tile($T[t]) : U("Unrecognized Treemap layout method: " + t)
             }, e
         },
         params: ["method", "ratio", "size", "round", "padding", "paddingInner", "paddingOuter", "paddingTop", "paddingRight", "paddingBottom", "paddingLeft"],
-        fields: Q2
+        fields: k2
     });
-    const xne = Object.freeze(Object.defineProperty({
+    const $te = Object.freeze(Object.defineProperty({
             __proto__: null,
-            nest: rE,
-            pack: aE,
-            partition: sE,
-            stratify: oE,
-            tree: lE,
-            treelinks: uE,
-            treemap: cE
+            nest: ES,
+            pack: CS,
+            partition: kS,
+            stratify: AS,
+            tree: $S,
+            treelinks: TS,
+            treemap: MS
         }, Symbol.toStringTag, {
             value: "Module"
         })),
-        kv = 4278190080;
+        sv = 4278190080;
 
-    function _ne(e, t) {
+    function Tte(e, t) {
         const n = e.bitmap();
         return (t || []).forEach(i => n.set(e(i.boundary[0]), e(i.boundary[3]))), [n, void 0]
     }
 
-    function wne(e, t, n, i, r) {
-        const a = e.width,
-            s = e.height,
+    function Mte(e, t, n, i, r) {
+        const s = e.width,
+            a = e.height,
             o = i || r,
-            l = Ps(a, s).getContext("2d"),
-            u = Ps(a, s).getContext("2d"),
-            c = o && Ps(a, s).getContext("2d");
-        n.forEach(O => Ep(l, O, !1)), Ep(u, t, !1), o && Ep(c, t, !0);
-        const f = Av(l, a, s),
-            h = Av(u, a, s),
-            d = o && Av(c, a, s),
+            l = ka(s, a).getContext("2d"),
+            u = ka(s, a).getContext("2d"),
+            c = o && ka(s, a).getContext("2d");
+        n.forEach(E => ap(l, E, !1)), ap(u, t, !1), o && ap(c, t, !0);
+        const f = av(l, s, a),
+            h = av(u, s, a),
+            d = o && av(c, s, a),
             g = e.bitmap(),
             p = o && e.bitmap();
         let m, y, v, b, x, _, S, w;
-        for (y = 0; y < s; ++y)
-            for (m = 0; m < a; ++m) x = y * a + m, _ = f[x] & kv, w = h[x] & kv, S = o && d[x] & kv, (_ || S || w) && (v = e(m), b = e(y), !r && (_ || w) && g.set(v, b), o && (_ || S) && p.set(v, b));
+        for (y = 0; y < a; ++y)
+            for (m = 0; m < s; ++m) x = y * s + m, _ = f[x] & sv, w = h[x] & sv, S = o && d[x] & sv, (_ || S || w) && (v = e(m), b = e(y), !r && (_ || w) && g.set(v, b), o && (_ || S) && p.set(v, b));
         return [g, p]
     }
 
-    function Av(e, t, n) {
+    function av(e, t, n) {
         return new Uint32Array(e.getImageData(0, 0, t, n).data.buffer)
     }
 
-    function Ep(e, t, n) {
+    function ap(e, t, n) {
         if (!t.length) return;
         const i = t[0].mark.marktype;
         i === "group" ? t.forEach(r => {
-            r.items.forEach(a => Ep(e, a.items, n))
-        }) : wi[i].draw(e, {
-            items: n ? t.map(Sne) : t
+            r.items.forEach(s => ap(e, s.items, n))
+        }) : xi[i].draw(e, {
+            items: n ? t.map(Ote) : t
         })
     }
 
-    function Sne(e) {
-        const t = Qm(e, {});
+    function Ote(e) {
+        const t = Rm(e, {});
         return t.stroke && t.strokeOpacity !== 0 || t.fill && t.fillOpacity !== 0 ? {
             ...t,
             strokeOpacity: 1,
             stroke: "#000",
             fillOpacity: 0
         } : t
     }
-    const Ea = 5,
-        An = 31,
-        Gh = 32,
-        bs = new Uint32Array(Gh + 1),
-        nr = new Uint32Array(Gh + 1);
-    nr[0] = 0;
-    bs[0] = ~nr[0];
-    for (let e = 1; e <= Gh; ++e) nr[e] = nr[e - 1] << 1 | 1, bs[e] = ~nr[e];
-
-    function Ene(e, t) {
-        const n = new Uint32Array(~~((e * t + Gh) / Gh));
+    const gs = 5,
+        Cn = 31,
+        Mh = 32,
+        ua = new Uint32Array(Mh + 1),
+        Vi = new Uint32Array(Mh + 1);
+    Vi[0] = 0;
+    ua[0] = ~Vi[0];
+    for (let e = 1; e <= Mh; ++e) Vi[e] = Vi[e - 1] << 1 | 1, ua[e] = ~Vi[e];
+
+    function Fte(e, t) {
+        const n = new Uint32Array(~~((e * t + Mh) / Mh));
 
-        function i(a, s) {
-            n[a] |= s
+        function i(s, a) {
+            n[s] |= a
         }
 
-        function r(a, s) {
-            n[a] &= s
+        function r(s, a) {
+            n[s] &= a
         }
         return {
             array: n,
-            get: (a, s) => {
-                const o = s * e + a;
-                return n[o >>> Ea] & 1 << (o & An)
-            },
-            set: (a, s) => {
-                const o = s * e + a;
-                i(o >>> Ea, 1 << (o & An))
-            },
-            clear: (a, s) => {
-                const o = s * e + a;
-                r(o >>> Ea, ~(1 << (o & An)))
+            get: (s, a) => {
+                const o = a * e + s;
+                return n[o >>> gs] & 1 << (o & Cn)
+            },
+            set: (s, a) => {
+                const o = a * e + s;
+                i(o >>> gs, 1 << (o & Cn))
+            },
+            clear: (s, a) => {
+                const o = a * e + s;
+                r(o >>> gs, ~(1 << (o & Cn)))
             },
-            getRange: (a, s, o, l) => {
+            getRange: (s, a, o, l) => {
                 let u = l,
                     c, f, h, d;
-                for (; u >= s; --u)
-                    if (c = u * e + a, f = u * e + o, h = c >>> Ea, d = f >>> Ea, h === d) {
-                        if (n[h] & bs[c & An] & nr[(f & An) + 1]) return !0
+                for (; u >= a; --u)
+                    if (c = u * e + s, f = u * e + o, h = c >>> gs, d = f >>> gs, h === d) {
+                        if (n[h] & ua[c & Cn] & Vi[(f & Cn) + 1]) return !0
                     } else {
-                        if (n[h] & bs[c & An] || n[d] & nr[(f & An) + 1]) return !0;
+                        if (n[h] & ua[c & Cn] || n[d] & Vi[(f & Cn) + 1]) return !0;
                         for (let g = h + 1; g < d; ++g)
                             if (n[g]) return !0
                     } return !1
             },
-            setRange: (a, s, o, l) => {
+            setRange: (s, a, o, l) => {
                 let u, c, f, h, d;
-                for (; s <= l; ++s)
-                    if (u = s * e + a, c = s * e + o, f = u >>> Ea, h = c >>> Ea, f === h) i(f, bs[u & An] & nr[(c & An) + 1]);
+                for (; a <= l; ++a)
+                    if (u = a * e + s, c = a * e + o, f = u >>> gs, h = c >>> gs, f === h) i(f, ua[u & Cn] & Vi[(c & Cn) + 1]);
                     else
-                        for (i(f, bs[u & An]), i(h, nr[(c & An) + 1]), d = f + 1; d < h; ++d) i(d, 4294967295)
+                        for (i(f, ua[u & Cn]), i(h, Vi[(c & Cn) + 1]), d = f + 1; d < h; ++d) i(d, 4294967295)
             },
-            clearRange: (a, s, o, l) => {
+            clearRange: (s, a, o, l) => {
                 let u, c, f, h, d;
-                for (; s <= l; ++s)
-                    if (u = s * e + a, c = s * e + o, f = u >>> Ea, h = c >>> Ea, f === h) r(f, nr[u & An] | bs[(c & An) + 1]);
+                for (; a <= l; ++a)
+                    if (u = a * e + s, c = a * e + o, f = u >>> gs, h = c >>> gs, f === h) r(f, Vi[u & Cn] | ua[(c & Cn) + 1]);
                     else
-                        for (r(f, nr[u & An]), r(h, bs[(c & An) + 1]), d = f + 1; d < h; ++d) r(d, 0)
+                        for (r(f, Vi[u & Cn]), r(h, ua[(c & Cn) + 1]), d = f + 1; d < h; ++d) r(d, 0)
             },
-            outOfBounds: (a, s, o, l) => a < 0 || s < 0 || l >= t || o >= e
+            outOfBounds: (s, a, o, l) => s < 0 || a < 0 || l >= t || o >= e
         }
     }
 
-    function One(e, t, n) {
+    function Rte(e, t, n) {
         const i = Math.max(1, Math.sqrt(e * t / 1e6)),
             r = ~~((e + 2 * n + i) / i),
-            a = ~~((t + 2 * n + i) / i),
-            s = o => ~~((o + n) / i);
-        return s.invert = o => o * i - n, s.bitmap = () => Ene(r, a), s.ratio = i, s.padding = n, s.width = e, s.height = t, s
+            s = ~~((t + 2 * n + i) / i),
+            a = o => ~~((o + n) / i);
+        return a.invert = o => o * i - n, a.bitmap = () => Fte(r, s), a.ratio = i, a.padding = n, a.width = e, a.height = t, a
     }
 
-    function Cne(e, t, n, i) {
+    function Dte(e, t, n, i) {
         const r = e.width,
-            a = e.height;
-        return function(s) {
-            const o = s.datum.datum.items[i].items,
+            s = e.height;
+        return function(a) {
+            const o = a.datum.datum.items[i].items,
                 l = o.length,
-                u = s.datum.fontSize,
-                c = dr.width(s.datum, s.datum.text);
+                u = a.datum.fontSize,
+                c = sr.width(a.datum, a.datum.text);
             let f = 0,
                 h, d, g, p, m, y, v;
-            for (let b = 0; b < l; ++b) h = o[b].x, g = o[b].y, d = o[b].x2 === void 0 ? h : o[b].x2, p = o[b].y2 === void 0 ? g : o[b].y2, m = (h + d) / 2, y = (g + p) / 2, v = Math.abs(d - h + p - g), v >= f && (f = v, s.x = m, s.y = y);
-            return m = c / 2, y = u / 2, h = s.x - m, d = s.x + m, g = s.y - y, p = s.y + y, s.align = "center", h < 0 && d <= r ? s.align = "left" : 0 <= h && r < d && (s.align = "right"), s.baseline = "middle", g < 0 && p <= a ? s.baseline = "top" : 0 <= g && a < p && (s.baseline = "bottom"), !0
+            for (let b = 0; b < l; ++b) h = o[b].x, g = o[b].y, d = o[b].x2 === void 0 ? h : o[b].x2, p = o[b].y2 === void 0 ? g : o[b].y2, m = (h + d) / 2, y = (g + p) / 2, v = Math.abs(d - h + p - g), v >= f && (f = v, a.x = m, a.y = y);
+            return m = c / 2, y = u / 2, h = a.x - m, d = a.x + m, g = a.y - y, p = a.y + y, a.align = "center", h < 0 && d <= r ? a.align = "left" : 0 <= h && r < d && (a.align = "right"), a.baseline = "middle", g < 0 && p <= s ? a.baseline = "top" : 0 <= g && s < p && (a.baseline = "bottom"), !0
         }
     }
 
-    function H0(e, t, n, i, r, a) {
-        let s = n / 2;
-        return e - s < 0 || e + s > r || t - (s = i / 2) < 0 || t + s > a
+    function A0(e, t, n, i, r, s) {
+        let a = n / 2;
+        return e - a < 0 || e + a > r || t - (a = i / 2) < 0 || t + a > s
     }
 
-    function $s(e, t, n, i, r, a, s, o) {
-        const l = r * a / (i * 2),
+    function xa(e, t, n, i, r, s, a, o) {
+        const l = r * s / (i * 2),
             u = e(t - l),
             c = e(t + l),
-            f = e(n - (a = a / 2)),
-            h = e(n + a);
-        return s.outOfBounds(u, f, c, h) || s.getRange(u, f, c, h) || o && o.getRange(u, f, c, h)
+            f = e(n - (s = s / 2)),
+            h = e(n + s);
+        return a.outOfBounds(u, f, c, h) || a.getRange(u, f, c, h) || o && o.getRange(u, f, c, h)
     }
 
-    function kne(e, t, n, i) {
+    function Nte(e, t, n, i) {
         const r = e.width,
-            a = e.height,
-            s = t[0],
+            s = e.height,
+            a = t[0],
             o = t[1];
 
         function l(u, c, f, h, d) {
             const g = e.invert(u),
                 p = e.invert(c);
             let m = f,
-                y = a,
+                y = s,
                 v;
-            if (!H0(g, p, h, d, r, a) && !$s(e, g, p, d, h, m, s, o) && !$s(e, g, p, d, h, d, s, null)) {
-                for (; y - m >= 1;) v = (m + y) / 2, $s(e, g, p, d, h, v, s, o) ? y = v : m = v;
+            if (!A0(g, p, h, d, r, s) && !xa(e, g, p, d, h, m, a, o) && !xa(e, g, p, d, h, d, a, null)) {
+                for (; y - m >= 1;) v = (m + y) / 2, xa(e, g, p, d, h, v, a, o) ? y = v : m = v;
                 if (m > f) return [g, p, m, !0]
             }
         }
         return function(u) {
             const c = u.datum.datum.items[i].items,
                 f = c.length,
                 h = u.datum.fontSize,
-                d = dr.width(u.datum, u.datum.text);
+                d = sr.width(u.datum, u.datum.text);
             let g = n ? h : 0,
                 p = !1,
                 m = !1,
                 y = 0,
-                v, b, x, _, S, w, O, k, C, E, T, A, F, $, D, P, N;
+                v, b, x, _, S, w, E, A, C, k, R, $, T, M, F, N, P;
             for (let z = 0; z < f; ++z) {
-                for (v = c[z].x, x = c[z].y, b = c[z].x2 === void 0 ? v : c[z].x2, _ = c[z].y2 === void 0 ? x : c[z].y2, v > b && (N = v, v = b, b = N), x > _ && (N = x, x = _, _ = N), C = e(v), T = e(b), E = ~~((C + T) / 2), A = e(x), $ = e(_), F = ~~((A + $) / 2), O = E; O >= C; --O)
-                    for (k = F; k >= A; --k) P = l(O, k, g, d, h), P && ([u.x, u.y, g, p] = P);
-                for (O = E; O <= T; ++O)
-                    for (k = F; k <= $; ++k) P = l(O, k, g, d, h), P && ([u.x, u.y, g, p] = P);
-                !p && !n && (D = Math.abs(b - v + _ - x), S = (v + b) / 2, w = (x + _) / 2, D >= y && !H0(S, w, d, h, r, a) && !$s(e, S, w, h, d, h, s, null) && (y = D, u.x = S, u.y = w, m = !0))
+                for (v = c[z].x, x = c[z].y, b = c[z].x2 === void 0 ? v : c[z].x2, _ = c[z].y2 === void 0 ? x : c[z].y2, v > b && (P = v, v = b, b = P), x > _ && (P = x, x = _, _ = P), C = e(v), R = e(b), k = ~~((C + R) / 2), $ = e(x), M = e(_), T = ~~(($ + M) / 2), E = k; E >= C; --E)
+                    for (A = T; A >= $; --A) N = l(E, A, g, d, h), N && ([u.x, u.y, g, p] = N);
+                for (E = k; E <= R; ++E)
+                    for (A = T; A <= M; ++A) N = l(E, A, g, d, h), N && ([u.x, u.y, g, p] = N);
+                !p && !n && (F = Math.abs(b - v + _ - x), S = (v + b) / 2, w = (x + _) / 2, F >= y && !A0(S, w, d, h, r, s) && !xa(e, S, w, h, d, h, a, null) && (y = F, u.x = S, u.y = w, m = !0))
             }
-            return p || m ? (S = d / 2, w = h / 2, s.setRange(e(u.x - S), e(u.y - w), e(u.x + S), e(u.y + w)), u.align = "center", u.baseline = "middle", !0) : !1
+            return p || m ? (S = d / 2, w = h / 2, a.setRange(e(u.x - S), e(u.y - w), e(u.x + S), e(u.y + w)), u.align = "center", u.baseline = "middle", !0) : !1
         }
     }
-    const Ane = [-1, -1, 1, 1],
-        Tne = [-1, 1, -1, 1];
+    const Pte = [-1, -1, 1, 1],
+        Lte = [-1, 1, -1, 1];
 
-    function $ne(e, t, n, i) {
+    function Ite(e, t, n, i) {
         const r = e.width,
-            a = e.height,
-            s = t[0],
+            s = e.height,
+            a = t[0],
             o = t[1],
             l = e.bitmap();
         return function(u) {
             const c = u.datum.datum.items[i].items,
                 f = c.length,
                 h = u.datum.fontSize,
-                d = dr.width(u.datum, u.datum.text),
+                d = sr.width(u.datum, u.datum.text),
                 g = [];
             let p = n ? h : 0,
                 m = !1,
                 y = !1,
                 v = 0,
-                b, x, _, S, w, O, k, C, E, T, A, F;
-            for (let $ = 0; $ < f; ++$) {
-                for (b = c[$].x, _ = c[$].y, x = c[$].x2 === void 0 ? b : c[$].x2, S = c[$].y2 === void 0 ? _ : c[$].y2, g.push([e((b + x) / 2), e((_ + S) / 2)]); g.length;)
-                    if ([k, C] = g.pop(), !(s.get(k, C) || o.get(k, C) || l.get(k, C))) {
-                        l.set(k, C);
-                        for (let D = 0; D < 4; ++D) w = k + Ane[D], O = C + Tne[D], l.outOfBounds(w, O, w, O) || g.push([w, O]);
-                        if (w = e.invert(k), O = e.invert(C), E = p, T = a, !H0(w, O, d, h, r, a) && !$s(e, w, O, h, d, E, s, o) && !$s(e, w, O, h, d, h, s, null)) {
-                            for (; T - E >= 1;) A = (E + T) / 2, $s(e, w, O, h, d, A, s, o) ? T = A : E = A;
-                            E > p && (u.x = w, u.y = O, p = E, m = !0)
+                b, x, _, S, w, E, A, C, k, R, $, T;
+            for (let M = 0; M < f; ++M) {
+                for (b = c[M].x, _ = c[M].y, x = c[M].x2 === void 0 ? b : c[M].x2, S = c[M].y2 === void 0 ? _ : c[M].y2, g.push([e((b + x) / 2), e((_ + S) / 2)]); g.length;)
+                    if ([A, C] = g.pop(), !(a.get(A, C) || o.get(A, C) || l.get(A, C))) {
+                        l.set(A, C);
+                        for (let F = 0; F < 4; ++F) w = A + Pte[F], E = C + Lte[F], l.outOfBounds(w, E, w, E) || g.push([w, E]);
+                        if (w = e.invert(A), E = e.invert(C), k = p, R = s, !A0(w, E, d, h, r, s) && !xa(e, w, E, h, d, k, a, o) && !xa(e, w, E, h, d, h, a, null)) {
+                            for (; R - k >= 1;) $ = (k + R) / 2, xa(e, w, E, h, d, $, a, o) ? R = $ : k = $;
+                            k > p && (u.x = w, u.y = E, p = k, m = !0)
                         }
-                    }! m && !n && (F = Math.abs(x - b + S - _), w = (b + x) / 2, O = (_ + S) / 2, F >= v && !H0(w, O, d, h, r, a) && !$s(e, w, O, h, d, h, s, null) && (v = F, u.x = w, u.y = O, y = !0))
+                    }! m && !n && (T = Math.abs(x - b + S - _), w = (b + x) / 2, E = (_ + S) / 2, T >= v && !A0(w, E, d, h, r, s) && !xa(e, w, E, h, d, h, a, null) && (v = T, u.x = w, u.y = E, y = !0))
             }
-            return m || y ? (w = d / 2, O = h / 2, s.setRange(e(u.x - w), e(u.y - O), e(u.x + w), e(u.y + O)), u.align = "center", u.baseline = "middle", !0) : !1
+            return m || y ? (w = d / 2, E = h / 2, a.setRange(e(u.x - w), e(u.y - E), e(u.x + w), e(u.y + E)), u.align = "center", u.baseline = "middle", !0) : !1
         }
     }
-    const Mne = ["right", "center", "left"],
-        Fne = ["bottom", "middle", "top"];
+    const zte = ["right", "center", "left"],
+        Bte = ["bottom", "middle", "top"];
 
-    function Dne(e, t, n, i) {
+    function jte(e, t, n, i) {
         const r = e.width,
-            a = e.height,
-            s = t[0],
+            s = e.height,
+            a = t[0],
             o = t[1],
             l = i.length;
         return function(u) {
             const c = u.boundary,
                 f = u.datum.fontSize;
-            if (c[2] < 0 || c[5] < 0 || c[0] > r || c[3] > a) return !1;
+            if (c[2] < 0 || c[5] < 0 || c[0] > r || c[3] > s) return !1;
             let h = u.textWidth ?? 0,
-                d, g, p, m, y, v, b, x, _, S, w, O, k, C, E;
-            for (let T = 0; T < l; ++T) {
-                if (d = (n[T] & 3) - 1, g = (n[T] >>> 2 & 3) - 1, p = d === 0 && g === 0 || i[T] < 0, m = d && g ? Math.SQRT1_2 : 1, y = i[T] < 0 ? -1 : 1, v = c[1 + d] + i[T] * d * m, w = c[4 + g] + y * f * g / 2 + i[T] * g * m, x = w - f / 2, _ = w + f / 2, O = e(v), C = e(x), E = e(_), !h)
-                    if (p3(O, O, C, E, s, o, v, v, x, _, c, p)) h = dr.width(u.datum, u.datum.text);
+                d, g, p, m, y, v, b, x, _, S, w, E, A, C, k;
+            for (let R = 0; R < l; ++R) {
+                if (d = (n[R] & 3) - 1, g = (n[R] >>> 2 & 3) - 1, p = d === 0 && g === 0 || i[R] < 0, m = d && g ? Math.SQRT1_2 : 1, y = i[R] < 0 ? -1 : 1, v = c[1 + d] + i[R] * d * m, w = c[4 + g] + y * f * g / 2 + i[R] * g * m, x = w - f / 2, _ = w + f / 2, E = e(v), C = e(x), k = e(_), !h)
+                    if (TT(E, E, C, k, a, o, v, v, x, _, c, p)) h = sr.width(u.datum, u.datum.text);
                     else continue;
-                if (S = v + y * h * d / 2, v = S - h / 2, b = S + h / 2, O = e(v), k = e(b), p3(O, k, C, E, s, o, v, b, x, _, c, p)) return u.x = d ? d * y < 0 ? b : v : S, u.y = g ? g * y < 0 ? _ : x : w, u.align = Mne[d * y + 1], u.baseline = Fne[g * y + 1], s.setRange(O, C, k, E), !0
+                if (S = v + y * h * d / 2, v = S - h / 2, b = S + h / 2, E = e(v), A = e(b), TT(E, A, C, k, a, o, v, b, x, _, c, p)) return u.x = d ? d * y < 0 ? b : v : S, u.y = g ? g * y < 0 ? _ : x : w, u.align = zte[d * y + 1], u.baseline = Bte[g * y + 1], a.setRange(E, C, A, k), !0
             }
             return !1
         }
     }
 
-    function p3(e, t, n, i, r, a, s, o, l, u, c, f) {
-        return !(r.outOfBounds(e, n, t, i) || (f && a || r).getRange(e, n, t, i))
+    function TT(e, t, n, i, r, s, a, o, l, u, c, f) {
+        return !(r.outOfBounds(e, n, t, i) || (f && s || r).getRange(e, n, t, i))
     }
-    const Tv = 0,
-        $v = 4,
-        Mv = 8,
-        Fv = 0,
-        Dv = 1,
-        Rv = 2,
-        Rne = {
-            "top-left": Tv + Fv,
-            top: Tv + Dv,
-            "top-right": Tv + Rv,
-            left: $v + Fv,
-            middle: $v + Dv,
-            right: $v + Rv,
-            "bottom-left": Mv + Fv,
-            bottom: Mv + Dv,
-            "bottom-right": Mv + Rv
-        },
-        Pne = {
-            naive: Cne,
-            "reduced-search": kne,
-            floodfill: $ne
+    const ov = 0,
+        lv = 4,
+        uv = 8,
+        cv = 0,
+        fv = 1,
+        hv = 2,
+        Ute = {
+            "top-left": ov + cv,
+            top: ov + fv,
+            "top-right": ov + hv,
+            left: lv + cv,
+            middle: lv + fv,
+            right: lv + hv,
+            "bottom-left": uv + cv,
+            bottom: uv + fv,
+            "bottom-right": uv + hv
+        },
+        Gte = {
+            naive: Dte,
+            "reduced-search": Nte,
+            floodfill: Ite
         };
 
-    function Nne(e, t, n, i, r, a, s, o, l, u, c) {
+    function Wte(e, t, n, i, r, s, a, o, l, u, c) {
         if (!e.length) return e;
         const f = Math.max(i.length, r.length),
-            h = Lne(i, f),
-            d = Ine(r, f),
-            g = jne(e[0].datum),
+            h = qte(i, f),
+            d = Hte(r, f),
+            g = Yte(e[0].datum),
             p = g === "group" && e[0].datum.items[l].marktype,
             m = p === "area",
-            y = zne(g, p, o, l),
+            y = Xte(g, p, o, l),
             v = u === null || u === 1 / 0,
             b = m && c === "naive";
         let x = -1,
             _ = -1;
         const S = e.map(C => {
-            const E = v ? dr.width(C, C.text) : void 0;
-            return x = Math.max(x, E), _ = Math.max(_, C.fontSize), {
+            const k = v ? sr.width(C, C.text) : void 0;
+            return x = Math.max(x, k), _ = Math.max(_, C.fontSize), {
                 datum: C,
                 opacity: 0,
                 x: void 0,
                 y: void 0,
                 align: void 0,
                 baseline: void 0,
                 boundary: y(C),
-                textWidth: E
+                textWidth: k
             }
         });
         u = u === null || u === 1 / 0 ? Math.max(x, _) + Math.max(...i) : u;
-        const w = One(t[0], t[1], u);
-        let O;
+        const w = Rte(t[0], t[1], u);
+        let E;
         if (!b) {
-            n && S.sort((T, A) => n(T.datum, A.datum));
+            n && S.sort((R, $) => n(R.datum, $.datum));
             let C = !1;
-            for (let T = 0; T < d.length && !C; ++T) C = d[T] === 5 || h[T] < 0;
-            const E = (g && s || m) && e.map(T => T.datum);
-            O = a.length || E ? wne(w, E || [], a, C, m) : _ne(w, s && S)
+            for (let R = 0; R < d.length && !C; ++R) C = d[R] === 5 || h[R] < 0;
+            const k = (g && a || m) && e.map(R => R.datum);
+            E = s.length || k ? Mte(w, k || [], s, C, m) : Tte(w, a && S)
         }
-        const k = m ? Pne[c](w, O, s, l) : Dne(w, O, d, h);
-        return S.forEach(C => C.opacity = +k(C)), S
+        const A = m ? Gte[c](w, E, a, l) : jte(w, E, d, h);
+        return S.forEach(C => C.opacity = +A(C)), S
     }
 
-    function Lne(e, t) {
+    function qte(e, t) {
         const n = new Float64Array(t),
             i = e.length;
         for (let r = 0; r < i; ++r) n[r] = e[r] || 0;
         for (let r = i; r < t; ++r) n[r] = n[i - 1];
         return n
     }
 
-    function Ine(e, t) {
+    function Hte(e, t) {
         const n = new Int8Array(t),
             i = e.length;
-        for (let r = 0; r < i; ++r) n[r] |= Rne[e[r]];
+        for (let r = 0; r < i; ++r) n[r] |= Ute[e[r]];
         for (let r = i; r < t; ++r) n[r] = n[i - 1];
         return n
     }
 
-    function jne(e) {
+    function Yte(e) {
         return e && e.mark && e.mark.marktype
     }
 
-    function zne(e, t, n, i) {
-        const r = a => [a.x, a.x, a.x, a.y, a.y, a.y];
-        return e ? e === "line" || e === "area" ? a => r(a.datum) : t === "line" ? a => {
-            const s = a.datum.items[i].items;
-            return r(s.length ? s[n === "start" ? 0 : s.length - 1] : {
+    function Xte(e, t, n, i) {
+        const r = s => [s.x, s.x, s.x, s.y, s.y, s.y];
+        return e ? e === "line" || e === "area" ? s => r(s.datum) : t === "line" ? s => {
+            const a = s.datum.items[i].items;
+            return r(a.length ? a[n === "start" ? 0 : a.length - 1] : {
                 x: NaN,
                 y: NaN
             })
-        } : a => {
-            const s = a.datum.bounds;
-            return [s.x1, (s.x1 + s.x2) / 2, s.x2, s.y1, (s.y1 + s.y2) / 2, s.y2]
+        } : s => {
+            const a = s.datum.bounds;
+            return [a.x1, (a.x1 + a.x2) / 2, a.x2, a.y1, (a.y1 + a.y2) / 2, a.y2]
         } : r
     }
-    const Z2 = ["x", "y", "opacity", "align", "baseline"],
-        ML = ["top-left", "left", "bottom-left", "top", "bottom", "top-right", "right", "bottom-right"];
+    const A2 = ["x", "y", "opacity", "align", "baseline"],
+        U4 = ["top-left", "left", "bottom-left", "top", "bottom", "top-right", "right", "bottom-right"];
 
-    function fE(e) {
+    function OS(e) {
         L.call(this, null, e)
     }
-    fE.Definition = {
+    OS.Definition = {
         type: "Label",
         metadata: {
             modifies: !0
         },
         params: [{
             name: "size",
             type: "number",
@@ -28809,15 +28829,15 @@
         }, {
             name: "sort",
             type: "compare"
         }, {
             name: "anchor",
             type: "string",
             array: !0,
-            default: ML
+            default: U4
         }, {
             name: "offset",
             type: "number",
             array: !0,
             default: [1]
         }, {
             name: "padding",
@@ -28845,57 +28865,57 @@
             name: "method",
             type: "string",
             default: "naive"
         }, {
             name: "as",
             type: "string",
             array: !0,
-            length: Z2.length,
-            default: Z2
+            length: A2.length,
+            default: A2
         }]
     };
-    Q(fE, L, {
+    ee(OS, L, {
         transform(e, t) {
-            function n(a) {
-                const s = e[a];
-                return Ae(s) && t.modified(s.fields)
+            function n(s) {
+                const a = e[s];
+                return $e(a) && t.modified(a.fields)
             }
             const i = e.modified();
             if (!(i || t.changed(t.ADD_REM) || n("sort"))) return;
-            (!e.size || e.size.length !== 2) && G("Size parameter should be specified as a [width, height] array.");
-            const r = e.as || Z2;
-            return Nne(t.materialize(t.SOURCE).source || [], e.size, e.sort, ie(e.offset == null ? 1 : e.offset), ie(e.anchor || ML), e.avoidMarks || [], e.avoidBaseMark !== !1, e.lineAnchor || "end", e.markIndex || 0, e.padding === void 0 ? 0 : e.padding, e.method || "naive").forEach(a => {
-                const s = a.datum;
-                s[r[0]] = a.x, s[r[1]] = a.y, s[r[2]] = a.opacity, s[r[3]] = a.align, s[r[4]] = a.baseline
+            (!e.size || e.size.length !== 2) && U("Size parameter should be specified as a [width, height] array.");
+            const r = e.as || A2;
+            return Wte(t.materialize(t.SOURCE).source || [], e.size, e.sort, se(e.offset == null ? 1 : e.offset), se(e.anchor || U4), e.avoidMarks || [], e.avoidBaseMark !== !1, e.lineAnchor || "end", e.markIndex || 0, e.padding === void 0 ? 0 : e.padding, e.method || "naive").forEach(s => {
+                const a = s.datum;
+                a[r[0]] = s.x, a[r[1]] = s.y, a[r[2]] = s.opacity, a[r[3]] = s.align, a[r[4]] = s.baseline
             }), t.reflow(i).modifies(r)
         }
     });
-    const Bne = Object.freeze(Object.defineProperty({
+    const Vte = Object.freeze(Object.defineProperty({
         __proto__: null,
-        label: fE
+        label: OS
     }, Symbol.toStringTag, {
         value: "Module"
     }));
 
-    function FL(e, t) {
+    function G4(e, t) {
         var n = [],
             i = function(c) {
                 return c(o)
             },
-            r, a, s, o, l, u;
+            r, s, a, o, l, u;
         if (t == null) n.push(e);
         else
-            for (r = {}, a = 0, s = e.length; a < s; ++a) o = e[a], l = t.map(i), u = r[l], u || (r[l] = u = [], u.dims = l, n.push(u)), u.push(o);
+            for (r = {}, s = 0, a = e.length; s < a; ++s) o = e[s], l = t.map(i), u = r[l], u || (r[l] = u = [], u.dims = l, n.push(u)), u.push(o);
         return n
     }
 
-    function hE(e) {
+    function FS(e) {
         L.call(this, null, e)
     }
-    hE.Definition = {
+    FS.Definition = {
         type: "Loess",
         metadata: {
             generates: !0
         },
         params: [{
             name: "x",
             type: "field",
@@ -28914,49 +28934,50 @@
             default: .3
         }, {
             name: "as",
             type: "string",
             array: !0
         }]
     };
-    Q(hE, L, {
+    ee(FS, L, {
         transform(e, t) {
             const n = t.fork(t.NO_SOURCE | t.NO_FIELDS);
             if (!this.value || t.changed() || e.modified()) {
                 const i = t.materialize(t.SOURCE).source,
-                    r = FL(i, e.groupby),
-                    a = (e.groupby || []).map(wt),
-                    s = a.length,
-                    o = e.as || [wt(e.x), wt(e.y)],
+                    r = G4(i, e.groupby),
+                    s = (e.groupby || []).map(bt),
+                    a = s.length,
+                    o = e.as || [bt(e.x), bt(e.y)],
                     l = [];
                 r.forEach(u => {
-                    JP(u, e.x, e.y, e.bandwidth || .3).forEach(c => {
+                    lN(u, e.x, e.y, e.bandwidth || .3).forEach(c => {
                         const f = {};
-                        for (let h = 0; h < s; ++h) f[a[h]] = u.dims[h];
+                        for (let h = 0; h < a; ++h) f[s[h]] = u.dims[h];
                         f[o[0]] = c[0], f[o[1]] = c[1], l.push(He(f))
                     })
                 }), this.value && (n.rem = this.value), this.value = n.add = n.source = l
             }
             return n
         }
     });
-    const ex = {
-            linear: ww,
-            log: YP,
-            exp: XP,
-            pow: VP,
-            quad: Sw,
-            poly: KP
+    const $2 = {
+            constant: j_,
+            linear: U_,
+            log: rN,
+            exp: sN,
+            pow: aN,
+            quad: G_,
+            poly: oN
         },
-        Gne = (e, t) => e === "poly" ? t : e === "quad" ? 2 : 1;
+        Kte = (e, t) => e === "poly" ? t : e === "quad" ? 2 : 1;
 
-    function dE(e) {
+    function RS(e) {
         L.call(this, null, e)
     }
-    dE.Definition = {
+    RS.Definition = {
         type: "Regression",
         metadata: {
             generates: !0
         },
         params: [{
             name: "x",
             type: "field",
@@ -28969,15 +28990,15 @@
             name: "groupby",
             type: "field",
             array: !0
         }, {
             name: "method",
             type: "string",
             default: "linear",
-            values: Object.keys(ex)
+            values: Object.keys($2)
         }, {
             name: "order",
             type: "number",
             default: 3
         }, {
             name: "extent",
             type: "number",
@@ -28989,66 +29010,66 @@
             default: !1
         }, {
             name: "as",
             type: "string",
             array: !0
         }]
     };
-    Q(dE, L, {
+    ee(RS, L, {
         transform(e, t) {
             const n = t.fork(t.NO_SOURCE | t.NO_FIELDS);
             if (!this.value || t.changed() || e.modified()) {
                 const i = t.materialize(t.SOURCE).source,
-                    r = FL(i, e.groupby),
-                    a = (e.groupby || []).map(wt),
-                    s = e.method || "linear",
-                    o = e.order || 3,
-                    l = Gne(s, o),
-                    u = e.as || [wt(e.x), wt(e.y)],
-                    c = ex[s],
+                    r = G4(i, e.groupby),
+                    s = (e.groupby || []).map(bt),
+                    a = e.method || "linear",
+                    o = e.order == null ? 3 : e.order,
+                    l = Kte(a, o),
+                    u = e.as || [bt(e.x), bt(e.y)],
+                    c = $2[a],
                     f = [];
                 let h = e.extent;
-                pe(ex, s) || G("Invalid regression method: " + s), h != null && s === "log" && h[0] <= 0 && (t.dataflow.warn("Ignoring extent with values <= 0 for log regression."), h = null), r.forEach(d => {
+                me($2, a) || U("Invalid regression method: " + a), h != null && a === "log" && h[0] <= 0 && (t.dataflow.warn("Ignoring extent with values <= 0 for log regression."), h = null), r.forEach(d => {
                     if (d.length <= l) {
                         t.dataflow.warn("Skipping regression with more parameters than data points.");
                         return
                     }
                     const p = c(d, e.x, e.y, o);
                     if (e.params) {
                         f.push(He({
                             keys: d.dims,
                             coef: p.coef,
                             rSquared: p.rSquared
                         }));
                         return
                     }
-                    const m = h || Zr(d, e.x),
+                    const m = h || Hr(d, e.x),
                         y = v => {
                             const b = {};
-                            for (let x = 0; x < a.length; ++x) b[a[x]] = d.dims[x];
+                            for (let x = 0; x < s.length; ++x) b[s[x]] = d.dims[x];
                             b[u[0]] = v[0], b[u[1]] = v[1], f.push(He(b))
                         };
-                    s === "linear" ? m.forEach(v => y([v, p.predict(v)])) : a1(p.predict, m, 25, 200).forEach(y)
+                    a === "linear" || a === "constant" ? m.forEach(v => y([v, p.predict(v)])) : Bm(p.predict, m, 25, 200).forEach(y)
                 }), this.value && (n.rem = this.value), this.value = n.add = n.source = f
             }
             return n
         }
     });
-    const Une = Object.freeze(Object.defineProperty({
+    const Jte = Object.freeze(Object.defineProperty({
         __proto__: null,
-        loess: hE,
-        regression: dE
+        loess: FS,
+        regression: RS
     }, Symbol.toStringTag, {
         value: "Module"
     }));
 
-    function gE(e) {
+    function DS(e) {
         L.call(this, null, e)
     }
-    gE.Definition = {
+    DS.Definition = {
         type: "Voronoi",
         metadata: {
             modifies: !0
         },
         params: [{
             name: "x",
             type: "field",
@@ -29078,212 +29099,212 @@
             }
         }, {
             name: "as",
             type: "string",
             default: "path"
         }]
     };
-    const qne = [-1e5, -1e5, 1e5, 1e5];
-    Q(gE, L, {
+    const Qte = [-1e5, -1e5, 1e5, 1e5];
+    ee(DS, L, {
         transform(e, t) {
             const n = e.as || "path",
                 i = t.source;
             if (!i || !i.length) return t;
             let r = e.size;
-            r = r ? [0, 0, r[0], r[1]] : (r = e.extent) ? [r[0][0], r[0][1], r[1][0], r[1][1]] : qne;
-            const a = this.value = u_.from(i, e.x, e.y).voronoi(r);
-            for (let s = 0, o = i.length; s < o; ++s) {
-                const l = a.cellPolygon(s);
-                i[s][n] = l ? Wne(l) : null
+            r = r ? [0, 0, r[0], r[1]] : (r = e.extent) ? [r[0][0], r[0][1], r[1][0], r[1][1]] : Qte;
+            const s = this.value = $x.from(i, e.x, e.y).voronoi(r);
+            for (let a = 0, o = i.length; a < o; ++a) {
+                const l = s.cellPolygon(a);
+                i[a][n] = l ? Zte(l) : null
             }
             return t.reflow(e.modified()).modifies(n)
         }
     });
 
-    function Wne(e) {
+    function Zte(e) {
         const t = e[0][0],
             n = e[0][1];
         let i = e.length - 1;
         for (; e[i][0] === t && e[i][1] === n; --i);
         return "M" + e.slice(0, i + 1).join("L") + "Z"
     }
-    const Hne = Object.freeze(Object.defineProperty({
+    const ene = Object.freeze(Object.defineProperty({
         __proto__: null,
-        voronoi: gE
+        voronoi: DS
     }, Symbol.toStringTag, {
         value: "Module"
     }));
-    var Pv = Math.PI / 180,
-        Zf = 1 << 11 >> 5,
-        Op = 1 << 11;
+    var dv = Math.PI / 180,
+        jf = 64,
+        op = 2048;
 
-    function Yne() {
+    function tne() {
         var e = [256, 256],
-            t, n, i, r, a, s, o, l = DL,
+            t, n, i, r, s, a, o, l = W4,
             u = [],
             c = Math.random,
             f = {};
         f.layout = function() {
-            for (var g = h(Ps()), p = Zne((e[0] >> 5) * e[1]), m = null, y = u.length, v = -1, b = [], x = u.map(S => ({
+            for (var g = h(ka()), p = one((e[0] >> 5) * e[1]), m = null, y = u.length, v = -1, b = [], x = u.map(S => ({
                     text: t(S),
                     font: n(S),
                     style: r(S),
-                    weight: a(S),
-                    rotate: s(S),
+                    weight: s(S),
+                    rotate: a(S),
                     size: ~~(i(S) + 1e-14),
                     padding: o(S),
                     xoff: 0,
                     yoff: 0,
                     x1: 0,
                     y1: 0,
                     x0: 0,
                     y0: 0,
                     hasText: !1,
                     sprite: null,
                     datum: S
                 })).sort((S, w) => w.size - S.size); ++v < y;) {
                 var _ = x[v];
-                _.x = e[0] * (c() + .5) >> 1, _.y = e[1] * (c() + .5) >> 1, Xne(g, _, x, v), _.hasText && d(p, _, m) && (b.push(_), m ? Kne(m, _) : m = [{
+                _.x = e[0] * (c() + .5) >> 1, _.y = e[1] * (c() + .5) >> 1, nne(g, _, x, v), _.hasText && d(p, _, m) && (b.push(_), m ? rne(m, _) : m = [{
                     x: _.x + _.x0,
                     y: _.y + _.y0
                 }, {
                     x: _.x + _.x1,
                     y: _.y + _.y1
                 }], _.x -= e[0] >> 1, _.y -= e[1] >> 1)
             }
             return b
         };
 
         function h(g) {
             g.width = g.height = 1;
             var p = Math.sqrt(g.getContext("2d").getImageData(0, 0, 1, 1).data.length >> 2);
-            g.width = (Zf << 5) / p, g.height = Op / p;
+            g.width = (jf << 5) / p, g.height = op / p;
             var m = g.getContext("2d");
             return m.fillStyle = m.strokeStyle = "red", m.textAlign = "center", {
                 context: m,
                 ratio: p
             }
         }
 
         function d(g, p, m) {
-            for (var y = p.x, v = p.y, b = Math.sqrt(e[0] * e[0] + e[1] * e[1]), x = l(e), _ = c() < .5 ? 1 : -1, S = -_, w, O, k;
-                (w = x(S += _)) && (O = ~~w[0], k = ~~w[1], !(Math.min(Math.abs(O), Math.abs(k)) >= b));)
-                if (p.x = y + O, p.y = v + k, !(p.x + p.x0 < 0 || p.y + p.y0 < 0 || p.x + p.x1 > e[0] || p.y + p.y1 > e[1]) && (!m || !Vne(p, g, e[0])) && (!m || Jne(p, m))) {
-                    for (var C = p.sprite, E = p.width >> 5, T = e[0] >> 5, A = p.x - (E << 4), F = A & 127, $ = 32 - F, D = p.y1 - p.y0, P = (p.y + p.y0) * T + (A >> 5), N, z = 0; z < D; z++) {
-                        N = 0;
-                        for (var I = 0; I <= E; I++) g[P + I] |= N << $ | (I < E ? (N = C[z * E + I]) >>> F : 0);
-                        P += T
+            for (var y = p.x, v = p.y, b = Math.sqrt(e[0] * e[0] + e[1] * e[1]), x = l(e), _ = c() < .5 ? 1 : -1, S = -_, w, E, A;
+                (w = x(S += _)) && (E = ~~w[0], A = ~~w[1], !(Math.min(Math.abs(E), Math.abs(A)) >= b));)
+                if (p.x = y + E, p.y = v + A, !(p.x + p.x0 < 0 || p.y + p.y0 < 0 || p.x + p.x1 > e[0] || p.y + p.y1 > e[1]) && (!m || !ine(p, g, e[0])) && (!m || sne(p, m))) {
+                    for (var C = p.sprite, k = p.width >> 5, R = e[0] >> 5, $ = p.x - (k << 4), T = $ & 127, M = 32 - T, F = p.y1 - p.y0, N = (p.y + p.y0) * R + ($ >> 5), P, z = 0; z < F; z++) {
+                        P = 0;
+                        for (var I = 0; I <= k; I++) g[N + I] |= P << M | (I < k ? (P = C[z * k + I]) >>> T : 0);
+                        N += R
                     }
                     return p.sprite = null, !0
                 } return !1
         }
         return f.words = function(g) {
             return arguments.length ? (u = g, f) : u
         }, f.size = function(g) {
             return arguments.length ? (e = [+g[0], +g[1]], f) : e
         }, f.font = function(g) {
-            return arguments.length ? (n = Co(g), f) : n
+            return arguments.length ? (n = go(g), f) : n
         }, f.fontStyle = function(g) {
-            return arguments.length ? (r = Co(g), f) : r
+            return arguments.length ? (r = go(g), f) : r
         }, f.fontWeight = function(g) {
-            return arguments.length ? (a = Co(g), f) : a
+            return arguments.length ? (s = go(g), f) : s
         }, f.rotate = function(g) {
-            return arguments.length ? (s = Co(g), f) : s
+            return arguments.length ? (a = go(g), f) : a
         }, f.text = function(g) {
-            return arguments.length ? (t = Co(g), f) : t
+            return arguments.length ? (t = go(g), f) : t
         }, f.spiral = function(g) {
-            return arguments.length ? (l = eie[g] || g, f) : l
+            return arguments.length ? (l = lne[g] || g, f) : l
         }, f.fontSize = function(g) {
-            return arguments.length ? (i = Co(g), f) : i
+            return arguments.length ? (i = go(g), f) : i
         }, f.padding = function(g) {
-            return arguments.length ? (o = Co(g), f) : o
+            return arguments.length ? (o = go(g), f) : o
         }, f.random = function(g) {
             return arguments.length ? (c = g, f) : c
         }, f
     }
 
-    function Xne(e, t, n, i) {
+    function nne(e, t, n, i) {
         if (!t.sprite) {
             var r = e.context,
-                a = e.ratio;
-            r.clearRect(0, 0, (Zf << 5) / a, Op / a);
-            var s = 0,
+                s = e.ratio;
+            r.clearRect(0, 0, (jf << 5) / s, op / s);
+            var a = 0,
                 o = 0,
                 l = 0,
                 u = n.length,
                 c, f, h, d, g;
             for (--i; ++i < u;) {
-                if (t = n[i], r.save(), r.font = t.style + " " + t.weight + " " + ~~((t.size + 1) / a) + "px " + t.font, c = r.measureText(t.text + "m").width * a, h = t.size << 1, t.rotate) {
-                    var p = Math.sin(t.rotate * Pv),
-                        m = Math.cos(t.rotate * Pv),
+                if (t = n[i], r.save(), r.font = t.style + " " + t.weight + " " + ~~((t.size + 1) / s) + "px " + t.font, c = r.measureText(t.text + "m").width * s, h = t.size << 1, t.rotate) {
+                    var p = Math.sin(t.rotate * dv),
+                        m = Math.cos(t.rotate * dv),
                         y = c * m,
                         v = c * p,
                         b = h * m,
                         x = h * p;
                     c = Math.max(Math.abs(y + x), Math.abs(y - x)) + 31 >> 5 << 5, h = ~~Math.max(Math.abs(v + b), Math.abs(v - b))
                 } else c = c + 31 >> 5 << 5;
-                if (h > l && (l = h), s + c >= Zf << 5 && (s = 0, o += l, l = 0), o + h >= Op) break;
-                r.translate((s + (c >> 1)) / a, (o + (h >> 1)) / a), t.rotate && r.rotate(t.rotate * Pv), r.fillText(t.text, 0, 0), t.padding && (r.lineWidth = 2 * t.padding, r.strokeText(t.text, 0, 0)), r.restore(), t.width = c, t.height = h, t.xoff = s, t.yoff = o, t.x1 = c >> 1, t.y1 = h >> 1, t.x0 = -t.x1, t.y0 = -t.y1, t.hasText = !0, s += c
+                if (h > l && (l = h), a + c >= jf << 5 && (a = 0, o += l, l = 0), o + h >= op) break;
+                r.translate((a + (c >> 1)) / s, (o + (h >> 1)) / s), t.rotate && r.rotate(t.rotate * dv), r.fillText(t.text, 0, 0), t.padding && (r.lineWidth = 2 * t.padding, r.strokeText(t.text, 0, 0)), r.restore(), t.width = c, t.height = h, t.xoff = a, t.yoff = o, t.x1 = c >> 1, t.y1 = h >> 1, t.x0 = -t.x1, t.y0 = -t.y1, t.hasText = !0, a += c
             }
-            for (var _ = r.getImageData(0, 0, (Zf << 5) / a, Op / a).data, S = []; --i >= 0;)
+            for (var _ = r.getImageData(0, 0, (jf << 5) / s, op / s).data, S = []; --i >= 0;)
                 if (t = n[i], !!t.hasText) {
                     for (c = t.width, f = c >> 5, h = t.y1 - t.y0, d = 0; d < h * f; d++) S[d] = 0;
-                    if (s = t.xoff, s == null) return;
+                    if (a = t.xoff, a == null) return;
                     o = t.yoff;
                     var w = 0,
-                        O = -1;
+                        E = -1;
                     for (g = 0; g < h; g++) {
                         for (d = 0; d < c; d++) {
-                            var k = f * g + (d >> 5),
-                                C = _[(o + g) * (Zf << 5) + (s + d) << 2] ? 1 << 31 - d % 32 : 0;
-                            S[k] |= C, w |= C
+                            var A = f * g + (d >> 5),
+                                C = _[(o + g) * (jf << 5) + (a + d) << 2] ? 1 << 31 - d % 32 : 0;
+                            S[A] |= C, w |= C
                         }
-                        w ? O = g : (t.y0++, h--, g--, o++)
+                        w ? E = g : (t.y0++, h--, g--, o++)
                     }
-                    t.y1 = t.y0 + O, t.sprite = S.slice(0, (t.y1 - t.y0) * f)
+                    t.y1 = t.y0 + E, t.sprite = S.slice(0, (t.y1 - t.y0) * f)
                 }
         }
     }
 
-    function Vne(e, t, n) {
+    function ine(e, t, n) {
         n >>= 5;
-        for (var i = e.sprite, r = e.width >> 5, a = e.x - (r << 4), s = a & 127, o = 32 - s, l = e.y1 - e.y0, u = (e.y + e.y0) * n + (a >> 5), c, f = 0; f < l; f++) {
+        for (var i = e.sprite, r = e.width >> 5, s = e.x - (r << 4), a = s & 127, o = 32 - a, l = e.y1 - e.y0, u = (e.y + e.y0) * n + (s >> 5), c, f = 0; f < l; f++) {
             c = 0;
             for (var h = 0; h <= r; h++)
-                if ((c << o | (h < r ? (c = i[f * r + h]) >>> s : 0)) & t[u + h]) return !0;
+                if ((c << o | (h < r ? (c = i[f * r + h]) >>> a : 0)) & t[u + h]) return !0;
             u += n
         }
         return !1
     }
 
-    function Kne(e, t) {
+    function rne(e, t) {
         var n = e[0],
             i = e[1];
         t.x + t.x0 < n.x && (n.x = t.x + t.x0), t.y + t.y0 < n.y && (n.y = t.y + t.y0), t.x + t.x1 > i.x && (i.x = t.x + t.x1), t.y + t.y1 > i.y && (i.y = t.y + t.y1)
     }
 
-    function Jne(e, t) {
+    function sne(e, t) {
         return e.x + e.x1 > t[0].x && e.x + e.x0 < t[1].x && e.y + e.y1 > t[0].y && e.y + e.y0 < t[1].y
     }
 
-    function DL(e) {
+    function W4(e) {
         var t = e[0] / e[1];
         return function(n) {
             return [t * (n *= .1) * Math.cos(n), n * Math.sin(n)]
         }
     }
 
-    function Qne(e) {
+    function ane(e) {
         var t = 4,
             n = t * e[0] / e[1],
             i = 0,
             r = 0;
-        return function(a) {
-            var s = a < 0 ? -1 : 1;
-            switch (Math.sqrt(1 + 4 * s * a) - s & 3) {
+        return function(s) {
+            var a = s < 0 ? -1 : 1;
+            switch (Math.sqrt(1 + 4 * a * s) - a & 3) {
                 case 0:
                     i += n;
                     break;
                 case 1:
                     r += t;
                     break;
                 case 2:
@@ -29293,35 +29314,35 @@
                     r -= t;
                     break
             }
             return [i, r]
         }
     }
 
-    function Zne(e) {
+    function one(e) {
         for (var t = [], n = -1; ++n < e;) t[n] = 0;
         return t
     }
 
-    function Co(e) {
+    function go(e) {
         return typeof e == "function" ? e : function() {
             return e
         }
     }
-    var eie = {
-        archimedean: DL,
-        rectangular: Qne
+    var lne = {
+        archimedean: W4,
+        rectangular: ane
     };
-    const RL = ["x", "y", "font", "fontSize", "fontStyle", "fontWeight", "angle"],
-        tie = ["text", "font", "rotate", "fontSize", "fontStyle", "fontWeight"];
+    const q4 = ["x", "y", "font", "fontSize", "fontStyle", "fontWeight", "angle"],
+        une = ["text", "font", "rotate", "fontSize", "fontStyle", "fontWeight"];
 
-    function pE(e) {
-        L.call(this, Yne(), e)
+    function NS(e) {
+        L.call(this, tne(), e)
     }
-    pE.Definition = {
+    NS.Definition = {
         type: "Wordcloud",
         metadata: {
             modifies: !0
         },
         params: [{
             name: "size",
             type: "number",
@@ -29369,145 +29390,145 @@
             type: "number",
             expr: !0
         }, {
             name: "as",
             type: "string",
             array: !0,
             length: 7,
-            default: RL
+            default: q4
         }]
     };
-    Q(pE, L, {
+    ee(NS, L, {
         transform(e, t) {
-            e.size && !(e.size[0] && e.size[1]) && G("Wordcloud size dimensions must be non-zero.");
+            e.size && !(e.size[0] && e.size[1]) && U("Wordcloud size dimensions must be non-zero.");
 
             function n(g) {
                 const p = e[g];
-                return Ae(p) && t.modified(p.fields)
+                return $e(p) && t.modified(p.fields)
             }
             const i = e.modified();
-            if (!(i || t.changed(t.ADD_REM) || tie.some(n))) return;
+            if (!(i || t.changed(t.ADD_REM) || une.some(n))) return;
             const r = t.materialize(t.SOURCE).source,
-                a = this.value,
-                s = e.as || RL;
+                s = this.value,
+                a = e.as || q4;
             let o = e.fontSize || 14,
                 l;
-            if (Ae(o) ? l = e.fontSizeRange : o = Sn(o), l) {
+            if ($e(o) ? l = e.fontSizeRange : o = xn(o), l) {
                 const g = o,
-                    p = qe("sqrt")().domain(Zr(r, g)).range(l);
+                    p = We("sqrt")().domain(Hr(r, g)).range(l);
                 o = m => p(g(m))
             }
             r.forEach(g => {
-                g[s[0]] = NaN, g[s[1]] = NaN, g[s[3]] = 0
+                g[a[0]] = NaN, g[a[1]] = NaN, g[a[3]] = 0
             });
-            const u = a.words(r).text(e.text).size(e.size || [500, 500]).padding(e.padding || 1).spiral(e.spiral || "archimedean").rotate(e.rotate || 0).font(e.font || "sans-serif").fontStyle(e.fontStyle || "normal").fontWeight(e.fontWeight || "normal").fontSize(o).random(zi).layout(),
-                c = a.size(),
+            const u = s.words(r).text(e.text).size(e.size || [500, 500]).padding(e.padding || 1).spiral(e.spiral || "archimedean").rotate(e.rotate || 0).font(e.font || "sans-serif").fontStyle(e.fontStyle || "normal").fontWeight(e.fontWeight || "normal").fontSize(o).random(Ni).layout(),
+                c = s.size(),
                 f = c[0] >> 1,
                 h = c[1] >> 1,
                 d = u.length;
-            for (let g = 0, p, m; g < d; ++g) p = u[g], m = p.datum, m[s[0]] = p.x + f, m[s[1]] = p.y + h, m[s[2]] = p.font, m[s[3]] = p.size, m[s[4]] = p.style, m[s[5]] = p.weight, m[s[6]] = p.rotate;
-            return t.reflow(i).modifies(s)
+            for (let g = 0, p, m; g < d; ++g) p = u[g], m = p.datum, m[a[0]] = p.x + f, m[a[1]] = p.y + h, m[a[2]] = p.font, m[a[3]] = p.size, m[a[4]] = p.style, m[a[5]] = p.weight, m[a[6]] = p.rotate;
+            return t.reflow(i).modifies(a)
         }
     });
-    const nie = Object.freeze(Object.defineProperty({
+    const cne = Object.freeze(Object.defineProperty({
             __proto__: null,
-            wordcloud: pE
+            wordcloud: NS
         }, Symbol.toStringTag, {
             value: "Module"
         })),
-        iie = e => new Uint8Array(e),
-        rie = e => new Uint16Array(e),
-        mh = e => new Uint32Array(e);
+        fne = e => new Uint8Array(e),
+        hne = e => new Uint16Array(e),
+        rh = e => new Uint32Array(e);
 
-    function aie() {
+    function dne() {
         let e = 8,
             t = [],
-            n = mh(0),
-            i = Ig(0, e),
-            r = Ig(0, e);
+            n = rh(0),
+            i = Sg(0, e),
+            r = Sg(0, e);
         return {
             data: () => t,
-            seen: () => n = sie(n, t.length),
-            add(a) {
-                for (let s = 0, o = t.length, l = a.length, u; s < l; ++s) u = a[s], u._index = o++, t.push(u)
+            seen: () => n = gne(n, t.length),
+            add(s) {
+                for (let a = 0, o = t.length, l = s.length, u; a < l; ++a) u = s[a], u._index = o++, t.push(u)
             },
-            remove(a, s) {
+            remove(s, a) {
                 const o = t.length,
-                    l = Array(o - a),
+                    l = Array(o - s),
                     u = t;
                 let c, f, h;
-                for (f = 0; !s[f] && f < o; ++f) l[f] = t[f], u[f] = f;
-                for (h = f; f < o; ++f) c = t[f], s[f] ? u[f] = -1 : (u[f] = h, i[h] = i[f], r[h] = r[f], l[h] = c, c._index = h++), i[f] = 0;
+                for (f = 0; !a[f] && f < o; ++f) l[f] = t[f], u[f] = f;
+                for (h = f; f < o; ++f) c = t[f], a[f] ? u[f] = -1 : (u[f] = h, i[h] = i[f], r[h] = r[f], l[h] = c, c._index = h++), i[f] = 0;
                 return t = l, u
             },
             size: () => t.length,
             curr: () => i,
             prev: () => r,
-            reset: a => r[a] = i[a],
+            reset: s => r[s] = i[s],
             all: () => e < 257 ? 255 : e < 65537 ? 65535 : 4294967295,
-            set(a, s) {
-                i[a] |= s
+            set(s, a) {
+                i[s] |= a
             },
-            clear(a, s) {
-                i[a] &= ~s
+            clear(s, a) {
+                i[s] &= ~a
             },
-            resize(a, s) {
+            resize(s, a) {
                 const o = i.length;
-                (a > o || s > e) && (e = Math.max(s, e), i = Ig(a, e, i), r = Ig(a, e))
+                (s > o || a > e) && (e = Math.max(a, e), i = Sg(s, e, i), r = Sg(s, e))
             }
         }
     }
 
-    function sie(e, t, n) {
+    function gne(e, t, n) {
         return e.length >= t ? e : (n = n || new e.constructor(t), n.set(e), n)
     }
 
-    function Ig(e, t, n) {
-        const i = (t < 257 ? iie : t < 65537 ? rie : mh)(e);
+    function Sg(e, t, n) {
+        const i = (t < 257 ? fne : t < 65537 ? hne : rh)(e);
         return n && i.set(n), i
     }
 
-    function m3(e, t, n) {
+    function MT(e, t, n) {
         const i = 1 << t;
         return {
             one: i,
             zero: ~i,
             range: n.slice(),
             bisect: e.bisect,
             index: e.index,
             size: e.size,
-            onAdd(r, a) {
-                const s = this,
-                    o = s.bisect(s.range, r.value),
+            onAdd(r, s) {
+                const a = this,
+                    o = a.bisect(a.range, r.value),
                     l = r.index,
                     u = o[0],
                     c = o[1],
                     f = l.length;
                 let h;
-                for (h = 0; h < u; ++h) a[l[h]] |= i;
-                for (h = c; h < f; ++h) a[l[h]] |= i;
-                return s
+                for (h = 0; h < u; ++h) s[l[h]] |= i;
+                for (h = c; h < f; ++h) s[l[h]] |= i;
+                return a
             }
         }
     }
 
-    function y3() {
-        let e = mh(0),
+    function OT() {
+        let e = rh(0),
             t = [],
             n = 0;
 
         function i(o, l, u) {
             if (!l.length) return [];
             const c = n,
                 f = l.length,
-                h = mh(f);
+                h = rh(f);
             let d = Array(f),
                 g, p, m;
             for (m = 0; m < f; ++m) d[m] = o(l[m]), h[m] = m;
-            if (d = oie(d, h), c) g = t, p = e, t = Array(c + f), e = mh(c + f), lie(u, g, p, c, d, h, f, t, e);
+            if (d = pne(d, h), c) g = t, p = e, t = Array(c + f), e = rh(c + f), mne(u, g, p, c, d, h, f, t, e);
             else {
                 if (u > 0)
                     for (m = 0; m < f; ++m) h[m] += u;
                 t = d, e = h
             }
             return n = c + f, {
                 index: h,
@@ -29519,53 +29540,53 @@
             const u = n;
             let c, f, h;
             for (f = 0; !l[e[f]] && f < u; ++f);
             for (h = f; f < u; ++f) l[c = e[f]] || (e[h] = c, t[h] = t[f], ++h);
             n = u - o
         }
 
-        function a(o) {
+        function s(o) {
             for (let l = 0, u = n; l < u; ++l) e[l] = o[e[l]]
         }
 
-        function s(o, l) {
+        function a(o, l) {
             let u;
-            return l ? u = l.length : (l = t, u = n), [dG(l, o[0], 0, u), Bp(l, o[1], 0, u)]
+            return l ? u = l.length : (l = t, u = n), [xj(l, o[0], 0, u), wp(l, o[1], 0, u)]
         }
         return {
             insert: i,
             remove: r,
-            bisect: s,
-            reindex: a,
+            bisect: a,
+            reindex: s,
             index: () => e,
             size: () => n
         }
     }
 
-    function oie(e, t) {
+    function pne(e, t) {
         return e.sort.call(t, (n, i) => {
             const r = e[n],
-                a = e[i];
-            return r < a ? -1 : r > a ? 1 : 0
-        }), mG(e, t)
+                s = e[i];
+            return r < s ? -1 : r > s ? 1 : 0
+        }), Sj(e, t)
     }
 
-    function lie(e, t, n, i, r, a, s, o, l) {
+    function mne(e, t, n, i, r, s, a, o, l) {
         let u = 0,
             c = 0,
             f;
-        for (f = 0; u < i && c < s; ++f) t[u] < r[c] ? (o[f] = t[u], l[f] = n[u++]) : (o[f] = r[c], l[f] = a[c++] + e);
+        for (f = 0; u < i && c < a; ++f) t[u] < r[c] ? (o[f] = t[u], l[f] = n[u++]) : (o[f] = r[c], l[f] = s[c++] + e);
         for (; u < i; ++u, ++f) o[f] = t[u], l[f] = n[u];
-        for (; c < s; ++c, ++f) o[f] = r[c], l[f] = a[c] + e
+        for (; c < a; ++c, ++f) o[f] = r[c], l[f] = s[c] + e
     }
 
-    function mE(e) {
-        L.call(this, aie(), e), this._indices = null, this._dims = null
+    function PS(e) {
+        L.call(this, dne(), e), this._indices = null, this._dims = null
     }
-    mE.Definition = {
+    PS.Definition = {
         type: "CrossFilter",
         metadata: {},
         params: [{
             name: "fields",
             type: "field",
             array: !0,
             required: !0
@@ -29577,341 +29598,341 @@
             content: {
                 type: "number",
                 array: !0,
                 length: 2
             }
         }]
     };
-    Q(mE, L, {
+    ee(PS, L, {
         transform(e, t) {
             if (this._dims) {
                 var n = e.modified("fields") || e.fields.some(i => t.modified(i.fields));
                 return n ? this.reinit(e, t) : this.eval(e, t)
             } else return this.init(e, t)
         },
         init(e, t) {
             const n = e.fields,
                 i = e.query,
                 r = this._indices = {},
-                a = this._dims = [],
-                s = i.length;
+                s = this._dims = [],
+                a = i.length;
             let o = 0,
                 l, u;
-            for (; o < s; ++o) l = n[o].fname, u = r[l] || (r[l] = y3()), a.push(m3(u, o, i[o]));
+            for (; o < a; ++o) l = n[o].fname, u = r[l] || (r[l] = OT()), s.push(MT(u, o, i[o]));
             return this.eval(e, t)
         },
         reinit(e, t) {
             const n = t.materialize().fork(),
                 i = e.fields,
                 r = e.query,
-                a = this._indices,
-                s = this._dims,
+                s = this._indices,
+                a = this._dims,
                 o = this.value,
                 l = o.curr(),
                 u = o.prev(),
                 c = o.all(),
                 f = n.rem = n.add,
                 h = n.mod,
                 d = r.length,
                 g = {};
             let p, m, y, v, b, x, _, S, w;
             if (u.set(l), t.rem.length && (b = this.remove(e, t, n)), t.add.length && o.add(t.add), t.mod.length)
                 for (x = {}, v = t.mod, _ = 0, S = v.length; _ < S; ++_) x[v[_]._index] = 1;
-            for (_ = 0; _ < d; ++_) w = i[_], (!s[_] || e.modified("fields", _) || t.modified(w.fields)) && (y = w.fname, (p = g[y]) || (a[y] = m = y3(), g[y] = p = m.insert(w, t.source, 0)), s[_] = m3(m, _, r[_]).onAdd(p, l));
+            for (_ = 0; _ < d; ++_) w = i[_], (!a[_] || e.modified("fields", _) || t.modified(w.fields)) && (y = w.fname, (p = g[y]) || (s[y] = m = OT(), g[y] = p = m.insert(w, t.source, 0)), a[_] = MT(m, _, r[_]).onAdd(p, l));
             for (_ = 0, S = o.data().length; _ < S; ++_) b[_] || (u[_] !== l[_] ? f.push(_) : x[_] && l[_] !== c && h.push(_));
             return o.mask = (1 << d) - 1, n
         },
         eval(e, t) {
             const n = t.materialize().fork(),
                 i = this._dims.length;
             let r = 0;
             return t.rem.length && (this.remove(e, t, n), r |= (1 << i) - 1), e.modified("query") && !e.modified("fields") && (r |= this.update(e, t, n)), t.add.length && (this.insert(e, t, n), r |= (1 << i) - 1), t.mod.length && (this.modify(t, n), r |= (1 << i) - 1), this.value.mask = r, n
         },
         insert(e, t, n) {
             const i = t.add,
                 r = this.value,
-                a = this._dims,
-                s = this._indices,
+                s = this._dims,
+                a = this._indices,
                 o = e.fields,
                 l = {},
                 u = n.add,
                 c = r.size() + i.length,
-                f = a.length;
+                f = s.length;
             let h = r.size(),
                 d, g, p;
             r.resize(c, f), r.add(i);
             const m = r.curr(),
                 y = r.prev(),
                 v = r.all();
-            for (d = 0; d < f; ++d) g = o[d].fname, p = l[g] || (l[g] = s[g].insert(o[d], i, h)), a[d].onAdd(p, m);
+            for (d = 0; d < f; ++d) g = o[d].fname, p = l[g] || (l[g] = a[g].insert(o[d], i, h)), s[d].onAdd(p, m);
             for (; h < c; ++h) y[h] = v, m[h] !== v && u.push(h)
         },
         modify(e, t) {
             const n = t.mod,
                 i = this.value,
                 r = i.curr(),
-                a = i.all(),
-                s = e.mod;
+                s = i.all(),
+                a = e.mod;
             let o, l, u;
-            for (o = 0, l = s.length; o < l; ++o) u = s[o]._index, r[u] !== a && n.push(u)
+            for (o = 0, l = a.length; o < l; ++o) u = a[o]._index, r[u] !== s && n.push(u)
         },
         remove(e, t, n) {
             const i = this._indices,
                 r = this.value,
-                a = r.curr(),
-                s = r.prev(),
+                s = r.curr(),
+                a = r.prev(),
                 o = r.all(),
                 l = {},
                 u = n.rem,
                 c = t.rem;
             let f, h, d, g;
-            for (f = 0, h = c.length; f < h; ++f) d = c[f]._index, l[d] = 1, s[d] = g = a[d], a[d] = o, g !== o && u.push(d);
+            for (f = 0, h = c.length; f < h; ++f) d = c[f]._index, l[d] = 1, a[d] = g = s[d], s[d] = o, g !== o && u.push(d);
             for (d in i) i[d].remove(h, l);
             return this.reindex(t, h, l), l
         },
         reindex(e, t, n) {
             const i = this._indices,
                 r = this.value;
             e.runAfter(() => {
-                const a = r.remove(t, n);
-                for (const s in i) i[s].reindex(a)
+                const s = r.remove(t, n);
+                for (const a in i) i[a].reindex(s)
             })
         },
         update(e, t, n) {
             const i = this._dims,
                 r = e.query,
-                a = t.stamp,
-                s = i.length;
+                s = t.stamp,
+                a = i.length;
             let o = 0,
                 l, u;
-            for (n.filters = 0, u = 0; u < s; ++u) e.modified("query", u) && (l = u, ++o);
+            for (n.filters = 0, u = 0; u < a; ++u) e.modified("query", u) && (l = u, ++o);
             if (o === 1) o = i[l].one, this.incrementOne(i[l], r[l], n.add, n.rem);
             else
-                for (u = 0, o = 0; u < s; ++u) e.modified("query", u) && (o |= i[u].one, this.incrementAll(i[u], r[u], a, n.add), n.rem = n.add);
+                for (u = 0, o = 0; u < a; ++u) e.modified("query", u) && (o |= i[u].one, this.incrementAll(i[u], r[u], s, n.add), n.rem = n.add);
             return o
         },
         incrementAll(e, t, n, i) {
             const r = this.value,
-                a = r.seen(),
-                s = r.curr(),
+                s = r.seen(),
+                a = r.curr(),
                 o = r.prev(),
                 l = e.index(),
                 u = e.bisect(e.range),
                 c = e.bisect(t),
                 f = c[0],
                 h = c[1],
                 d = u[0],
                 g = u[1],
                 p = e.one;
             let m, y, v;
             if (f < d)
-                for (m = f, y = Math.min(d, h); m < y; ++m) v = l[m], a[v] !== n && (o[v] = s[v], a[v] = n, i.push(v)), s[v] ^= p;
+                for (m = f, y = Math.min(d, h); m < y; ++m) v = l[m], s[v] !== n && (o[v] = a[v], s[v] = n, i.push(v)), a[v] ^= p;
             else if (f > d)
-                for (m = d, y = Math.min(f, g); m < y; ++m) v = l[m], a[v] !== n && (o[v] = s[v], a[v] = n, i.push(v)), s[v] ^= p;
+                for (m = d, y = Math.min(f, g); m < y; ++m) v = l[m], s[v] !== n && (o[v] = a[v], s[v] = n, i.push(v)), a[v] ^= p;
             if (h > g)
-                for (m = Math.max(f, g), y = h; m < y; ++m) v = l[m], a[v] !== n && (o[v] = s[v], a[v] = n, i.push(v)), s[v] ^= p;
+                for (m = Math.max(f, g), y = h; m < y; ++m) v = l[m], s[v] !== n && (o[v] = a[v], s[v] = n, i.push(v)), a[v] ^= p;
             else if (h < g)
-                for (m = Math.max(d, h), y = g; m < y; ++m) v = l[m], a[v] !== n && (o[v] = s[v], a[v] = n, i.push(v)), s[v] ^= p;
+                for (m = Math.max(d, h), y = g; m < y; ++m) v = l[m], s[v] !== n && (o[v] = a[v], s[v] = n, i.push(v)), a[v] ^= p;
             e.range = t.slice()
         },
         incrementOne(e, t, n, i) {
             const r = this.value,
-                a = r.curr(),
-                s = e.index(),
+                s = r.curr(),
+                a = e.index(),
                 o = e.bisect(e.range),
                 l = e.bisect(t),
                 u = l[0],
                 c = l[1],
                 f = o[0],
                 h = o[1],
                 d = e.one;
             let g, p, m;
             if (u < f)
-                for (g = u, p = Math.min(f, c); g < p; ++g) m = s[g], a[m] ^= d, n.push(m);
+                for (g = u, p = Math.min(f, c); g < p; ++g) m = a[g], s[m] ^= d, n.push(m);
             else if (u > f)
-                for (g = f, p = Math.min(u, h); g < p; ++g) m = s[g], a[m] ^= d, i.push(m);
+                for (g = f, p = Math.min(u, h); g < p; ++g) m = a[g], s[m] ^= d, i.push(m);
             if (c > h)
-                for (g = Math.max(u, h), p = c; g < p; ++g) m = s[g], a[m] ^= d, n.push(m);
+                for (g = Math.max(u, h), p = c; g < p; ++g) m = a[g], s[m] ^= d, n.push(m);
             else if (c < h)
-                for (g = Math.max(f, c), p = h; g < p; ++g) m = s[g], a[m] ^= d, i.push(m);
+                for (g = Math.max(f, c), p = h; g < p; ++g) m = a[g], s[m] ^= d, i.push(m);
             e.range = t.slice()
         }
     });
 
-    function yE(e) {
+    function LS(e) {
         L.call(this, null, e)
     }
-    yE.Definition = {
+    LS.Definition = {
         type: "ResolveFilter",
         metadata: {},
         params: [{
             name: "ignore",
             type: "number",
             required: !0,
             description: "A bit mask indicating which filters to ignore."
         }, {
             name: "filter",
             type: "object",
             required: !0,
             description: "Per-tuple filter bitmaps from a CrossFilter transform."
         }]
     };
-    Q(yE, L, {
+    ee(LS, L, {
         transform(e, t) {
             const n = ~(e.ignore || 0),
                 i = e.filter,
                 r = i.mask;
             if (!(r & n)) return t.StopPropagation;
-            const a = t.fork(t.ALL),
-                s = i.data(),
+            const s = t.fork(t.ALL),
+                a = i.data(),
                 o = i.curr(),
                 l = i.prev(),
-                u = c => o[c] & n ? null : s[c];
-            return a.filter(a.MOD, u), r & r - 1 ? (a.filter(a.ADD, c => {
+                u = c => o[c] & n ? null : a[c];
+            return s.filter(s.MOD, u), r & r - 1 ? (s.filter(s.ADD, c => {
                 const f = o[c] & n;
-                return !f && f ^ l[c] & n ? s[c] : null
-            }), a.filter(a.REM, c => {
+                return !f && f ^ l[c] & n ? a[c] : null
+            }), s.filter(s.REM, c => {
                 const f = o[c] & n;
-                return f && !(f ^ (f ^ l[c] & n)) ? s[c] : null
-            })) : (a.filter(a.ADD, u), a.filter(a.REM, c => (o[c] & n) === r ? s[c] : null)), a.filter(a.SOURCE, c => u(c._index))
+                return f && !(f ^ (f ^ l[c] & n)) ? a[c] : null
+            })) : (s.filter(s.ADD, u), s.filter(s.REM, c => (o[c] & n) === r ? a[c] : null)), s.filter(s.SOURCE, c => u(c._index))
         }
     });
-    const uie = Object.freeze(Object.defineProperty({
+    const yne = Object.freeze(Object.defineProperty({
             __proto__: null,
-            crossfilter: mE,
-            resolvefilter: yE
+            crossfilter: PS,
+            resolvefilter: LS
         }, Symbol.toStringTag, {
             value: "Module"
         })),
-        cie = "RawCode",
-        pl = "Literal",
-        fie = "Property",
-        hie = "Identifier",
-        die = "ArrayExpression",
-        gie = "BinaryExpression",
-        PL = "CallExpression",
-        pie = "ConditionalExpression",
-        mie = "LogicalExpression",
-        yie = "MemberExpression",
-        vie = "ObjectExpression",
-        bie = "UnaryExpression";
+        vne = "RawCode",
+        il = "Literal",
+        bne = "Property",
+        xne = "Identifier",
+        _ne = "ArrayExpression",
+        wne = "BinaryExpression",
+        H4 = "CallExpression",
+        Sne = "ConditionalExpression",
+        Ene = "LogicalExpression",
+        Cne = "MemberExpression",
+        kne = "ObjectExpression",
+        Ane = "UnaryExpression";
 
-    function Er(e) {
+    function yr(e) {
         this.type = e
     }
-    Er.prototype.visit = function(e) {
+    yr.prototype.visit = function(e) {
         let t, n, i;
         if (e(this)) return 1;
-        for (t = xie(this), n = 0, i = t.length; n < i; ++n)
+        for (t = $ne(this), n = 0, i = t.length; n < i; ++n)
             if (t[n].visit(e)) return 1
     };
 
-    function xie(e) {
+    function $ne(e) {
         switch (e.type) {
-            case die:
+            case _ne:
                 return e.elements;
-            case gie:
-            case mie:
+            case wne:
+            case Ene:
                 return [e.left, e.right];
-            case PL:
+            case H4:
                 return [e.callee].concat(e.arguments);
-            case pie:
+            case Sne:
                 return [e.test, e.consequent, e.alternate];
-            case yie:
+            case Cne:
                 return [e.object, e.property];
-            case vie:
+            case kne:
                 return e.properties;
-            case fie:
+            case bne:
                 return [e.key, e.value];
-            case bie:
+            case Ane:
                 return [e.argument];
-            case hie:
-            case pl:
-            case cie:
+            case xne:
+            case il:
+            case vne:
             default:
                 return []
         }
     }
-    var da, ce, j, bn, Ze, S1 = 1,
-        Rd = 2,
-        ml = 3,
-        fo = 4,
-        E1 = 5,
-        Gl = 6,
-        Hn = 7,
-        Pd = 8,
-        _ie = 9;
-    da = {};
-    da[S1] = "Boolean";
-    da[Rd] = "<end>";
-    da[ml] = "Identifier";
-    da[fo] = "Keyword";
-    da[E1] = "Null";
-    da[Gl] = "Numeric";
-    da[Hn] = "Punctuator";
-    da[Pd] = "String";
-    da[_ie] = "RegularExpression";
-    var wie = "ArrayExpression",
-        Sie = "BinaryExpression",
-        Eie = "CallExpression",
-        Oie = "ConditionalExpression",
-        NL = "Identifier",
-        Cie = "Literal",
-        kie = "LogicalExpression",
-        Aie = "MemberExpression",
-        Tie = "ObjectExpression",
-        $ie = "Property",
-        Mie = "UnaryExpression",
-        qt = "Unexpected token %0",
-        Fie = "Unexpected number",
-        Die = "Unexpected string",
-        Rie = "Unexpected identifier",
-        Pie = "Unexpected reserved word",
-        Nie = "Unexpected end of input",
-        tx = "Invalid regular expression",
-        Nv = "Invalid regular expression: missing /",
-        LL = "Octal literals are not allowed in strict mode.",
-        Lie = "Duplicate data property in object literal not allowed in strict mode",
-        en = "ILLEGAL",
-        Uh = "Disabled.",
-        Iie = new RegExp("[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0-\\u08B2\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58\\u0C59\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D60\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19C1-\\u19C7\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]"),
-        jie = new RegExp("[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0300-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u0483-\\u0487\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0610-\\u061A\\u0620-\\u0669\\u066E-\\u06D3\\u06D5-\\u06DC\\u06DF-\\u06E8\\u06EA-\\u06FC\\u06FF\\u0710-\\u074A\\u074D-\\u07B1\\u07C0-\\u07F5\\u07FA\\u0800-\\u082D\\u0840-\\u085B\\u08A0-\\u08B2\\u08E4-\\u0963\\u0966-\\u096F\\u0971-\\u0983\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BC-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CE\\u09D7\\u09DC\\u09DD\\u09DF-\\u09E3\\u09E6-\\u09F1\\u0A01-\\u0A03\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A75\\u0A81-\\u0A83\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABC-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AD0\\u0AE0-\\u0AE3\\u0AE6-\\u0AEF\\u0B01-\\u0B03\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3C-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B5C\\u0B5D\\u0B5F-\\u0B63\\u0B66-\\u0B6F\\u0B71\\u0B82\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD0\\u0BD7\\u0BE6-\\u0BEF\\u0C00-\\u0C03\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C58\\u0C59\\u0C60-\\u0C63\\u0C66-\\u0C6F\\u0C81-\\u0C83\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBC-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CDE\\u0CE0-\\u0CE3\\u0CE6-\\u0CEF\\u0CF1\\u0CF2\\u0D01-\\u0D03\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4E\\u0D57\\u0D60-\\u0D63\\u0D66-\\u0D6F\\u0D7A-\\u0D7F\\u0D82\\u0D83\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DE6-\\u0DEF\\u0DF2\\u0DF3\\u0E01-\\u0E3A\\u0E40-\\u0E4E\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB9\\u0EBB-\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EC8-\\u0ECD\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E-\\u0F47\\u0F49-\\u0F6C\\u0F71-\\u0F84\\u0F86-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u1000-\\u1049\\u1050-\\u109D\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u135D-\\u135F\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1714\\u1720-\\u1734\\u1740-\\u1753\\u1760-\\u176C\\u176E-\\u1770\\u1772\\u1773\\u1780-\\u17D3\\u17D7\\u17DC\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u1810-\\u1819\\u1820-\\u1877\\u1880-\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19D9\\u1A00-\\u1A1B\\u1A20-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1AB0-\\u1ABD\\u1B00-\\u1B4B\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1BF3\\u1C00-\\u1C37\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1CD0-\\u1CD2\\u1CD4-\\u1CF6\\u1CF8\\u1CF9\\u1D00-\\u1DF5\\u1DFC-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u200C\\u200D\\u203F\\u2040\\u2054\\u2071\\u207F\\u2090-\\u209C\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D7F-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2DE0-\\u2DFF\\u2E2F\\u3005-\\u3007\\u3021-\\u302F\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u3099\\u309A\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66F\\uA674-\\uA67D\\uA67F-\\uA69D\\uA69F-\\uA6F1\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA827\\uA840-\\uA873\\uA880-\\uA8C4\\uA8D0-\\uA8D9\\uA8E0-\\uA8F7\\uA8FB\\uA900-\\uA92D\\uA930-\\uA953\\uA960-\\uA97C\\uA980-\\uA9C0\\uA9CF-\\uA9D9\\uA9E0-\\uA9FE\\uAA00-\\uAA36\\uAA40-\\uAA4D\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A-\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEF\\uAAF2-\\uAAF6\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE00-\\uFE0F\\uFE20-\\uFE2D\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF3F\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]");
+    var ss, ce, B, yn, Qe, r1 = 1,
+        wd = 2,
+        rl = 3,
+        eo = 4,
+        s1 = 5,
+        Ol = 6,
+        Wn = 7,
+        Sd = 8,
+        Tne = 9;
+    ss = {};
+    ss[r1] = "Boolean";
+    ss[wd] = "<end>";
+    ss[rl] = "Identifier";
+    ss[eo] = "Keyword";
+    ss[s1] = "Null";
+    ss[Ol] = "Numeric";
+    ss[Wn] = "Punctuator";
+    ss[Sd] = "String";
+    ss[Tne] = "RegularExpression";
+    var Mne = "ArrayExpression",
+        One = "BinaryExpression",
+        Fne = "CallExpression",
+        Rne = "ConditionalExpression",
+        Y4 = "Identifier",
+        Dne = "Literal",
+        Nne = "LogicalExpression",
+        Pne = "MemberExpression",
+        Lne = "ObjectExpression",
+        Ine = "Property",
+        zne = "UnaryExpression",
+        Bt = "Unexpected token %0",
+        Bne = "Unexpected number",
+        jne = "Unexpected string",
+        Une = "Unexpected identifier",
+        Gne = "Unexpected reserved word",
+        Wne = "Unexpected end of input",
+        T2 = "Invalid regular expression",
+        gv = "Invalid regular expression: missing /",
+        X4 = "Octal literals are not allowed in strict mode.",
+        qne = "Duplicate data property in object literal not allowed in strict mode",
+        Kt = "ILLEGAL",
+        Oh = "Disabled.",
+        Hne = new RegExp("[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0-\\u08B2\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58\\u0C59\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D60\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19C1-\\u19C7\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]"),
+        Yne = new RegExp("[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0300-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u0483-\\u0487\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0610-\\u061A\\u0620-\\u0669\\u066E-\\u06D3\\u06D5-\\u06DC\\u06DF-\\u06E8\\u06EA-\\u06FC\\u06FF\\u0710-\\u074A\\u074D-\\u07B1\\u07C0-\\u07F5\\u07FA\\u0800-\\u082D\\u0840-\\u085B\\u08A0-\\u08B2\\u08E4-\\u0963\\u0966-\\u096F\\u0971-\\u0983\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BC-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CE\\u09D7\\u09DC\\u09DD\\u09DF-\\u09E3\\u09E6-\\u09F1\\u0A01-\\u0A03\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A75\\u0A81-\\u0A83\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABC-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AD0\\u0AE0-\\u0AE3\\u0AE6-\\u0AEF\\u0B01-\\u0B03\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3C-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B5C\\u0B5D\\u0B5F-\\u0B63\\u0B66-\\u0B6F\\u0B71\\u0B82\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD0\\u0BD7\\u0BE6-\\u0BEF\\u0C00-\\u0C03\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C58\\u0C59\\u0C60-\\u0C63\\u0C66-\\u0C6F\\u0C81-\\u0C83\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBC-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CDE\\u0CE0-\\u0CE3\\u0CE6-\\u0CEF\\u0CF1\\u0CF2\\u0D01-\\u0D03\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4E\\u0D57\\u0D60-\\u0D63\\u0D66-\\u0D6F\\u0D7A-\\u0D7F\\u0D82\\u0D83\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DE6-\\u0DEF\\u0DF2\\u0DF3\\u0E01-\\u0E3A\\u0E40-\\u0E4E\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB9\\u0EBB-\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EC8-\\u0ECD\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E-\\u0F47\\u0F49-\\u0F6C\\u0F71-\\u0F84\\u0F86-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u1000-\\u1049\\u1050-\\u109D\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u135D-\\u135F\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1714\\u1720-\\u1734\\u1740-\\u1753\\u1760-\\u176C\\u176E-\\u1770\\u1772\\u1773\\u1780-\\u17D3\\u17D7\\u17DC\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u1810-\\u1819\\u1820-\\u1877\\u1880-\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19D9\\u1A00-\\u1A1B\\u1A20-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1AB0-\\u1ABD\\u1B00-\\u1B4B\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1BF3\\u1C00-\\u1C37\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1CD0-\\u1CD2\\u1CD4-\\u1CF6\\u1CF8\\u1CF9\\u1D00-\\u1DF5\\u1DFC-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u200C\\u200D\\u203F\\u2040\\u2054\\u2071\\u207F\\u2090-\\u209C\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D7F-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2DE0-\\u2DFF\\u2E2F\\u3005-\\u3007\\u3021-\\u302F\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u3099\\u309A\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66F\\uA674-\\uA67D\\uA67F-\\uA69D\\uA69F-\\uA6F1\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA827\\uA840-\\uA873\\uA880-\\uA8C4\\uA8D0-\\uA8D9\\uA8E0-\\uA8F7\\uA8FB\\uA900-\\uA92D\\uA930-\\uA953\\uA960-\\uA97C\\uA980-\\uA9C0\\uA9CF-\\uA9D9\\uA9E0-\\uA9FE\\uAA00-\\uAA36\\uAA40-\\uAA4D\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A-\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEF\\uAAF2-\\uAAF6\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE00-\\uFE0F\\uFE20-\\uFE2D\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF3F\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]");
 
-    function O1(e, t) {
+    function a1(e, t) {
         if (!e) throw new Error("ASSERT: " + t)
     }
 
-    function $a(e) {
+    function xs(e) {
         return e >= 48 && e <= 57
     }
 
-    function vE(e) {
+    function IS(e) {
         return "0123456789abcdefABCDEF".indexOf(e) >= 0
     }
 
-    function yh(e) {
+    function sh(e) {
         return "01234567".indexOf(e) >= 0
     }
 
-    function zie(e) {
+    function Xne(e) {
         return e === 32 || e === 9 || e === 11 || e === 12 || e === 160 || e >= 5760 && [5760, 6158, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8239, 8287, 12288, 65279].indexOf(e) >= 0
     }
 
-    function qh(e) {
+    function Fh(e) {
         return e === 10 || e === 13 || e === 8232 || e === 8233
     }
 
-    function Nd(e) {
-        return e === 36 || e === 95 || e >= 65 && e <= 90 || e >= 97 && e <= 122 || e === 92 || e >= 128 && Iie.test(String.fromCharCode(e))
+    function Ed(e) {
+        return e === 36 || e === 95 || e >= 65 && e <= 90 || e >= 97 && e <= 122 || e === 92 || e >= 128 && Hne.test(String.fromCharCode(e))
     }
 
-    function Y0(e) {
-        return e === 36 || e === 95 || e >= 65 && e <= 90 || e >= 97 && e <= 122 || e >= 48 && e <= 57 || e === 92 || e >= 128 && jie.test(String.fromCharCode(e))
+    function $0(e) {
+        return e === 36 || e === 95 || e >= 65 && e <= 90 || e >= 97 && e <= 122 || e >= 48 && e <= 57 || e === 92 || e >= 128 && Yne.test(String.fromCharCode(e))
     }
-    const Bie = {
+    const Vne = {
         if: 1,
         in: 1,
         do: 1,
         var: 1,
         for: 1,
         new: 1,
         try: 1,
@@ -29948,201 +29969,201 @@
         debugger: 1,
         interface: 1,
         protected: 1,
         instanceof: 1,
         implements: 1
     };
 
-    function IL() {
-        for (; j < bn;) {
-            const e = ce.charCodeAt(j);
-            if (zie(e) || qh(e)) ++j;
+    function V4() {
+        for (; B < yn;) {
+            const e = ce.charCodeAt(B);
+            if (Xne(e) || Fh(e)) ++B;
             else break
         }
     }
 
-    function nx(e) {
+    function M2(e) {
         var t, n, i, r = 0;
-        for (n = e === "u" ? 4 : 2, t = 0; t < n; ++t) j < bn && vE(ce[j]) ? (i = ce[j++], r = r * 16 + "0123456789abcdef".indexOf(i.toLowerCase())) : Ge({}, qt, en);
+        for (n = e === "u" ? 4 : 2, t = 0; t < n; ++t) B < yn && IS(ce[B]) ? (i = ce[B++], r = r * 16 + "0123456789abcdef".indexOf(i.toLowerCase())) : Ue({}, Bt, Kt);
         return String.fromCharCode(r)
     }
 
-    function Gie() {
+    function Kne() {
         var e, t, n, i;
-        for (e = ce[j], t = 0, e === "}" && Ge({}, qt, en); j < bn && (e = ce[j++], !!vE(e));) t = t * 16 + "0123456789abcdef".indexOf(e.toLowerCase());
-        return (t > 1114111 || e !== "}") && Ge({}, qt, en), t <= 65535 ? String.fromCharCode(t) : (n = (t - 65536 >> 10) + 55296, i = (t - 65536 & 1023) + 56320, String.fromCharCode(n, i))
+        for (e = ce[B], t = 0, e === "}" && Ue({}, Bt, Kt); B < yn && (e = ce[B++], !!IS(e));) t = t * 16 + "0123456789abcdef".indexOf(e.toLowerCase());
+        return (t > 1114111 || e !== "}") && Ue({}, Bt, Kt), t <= 65535 ? String.fromCharCode(t) : (n = (t - 65536 >> 10) + 55296, i = (t - 65536 & 1023) + 56320, String.fromCharCode(n, i))
     }
 
-    function jL() {
+    function K4() {
         var e, t;
-        for (e = ce.charCodeAt(j++), t = String.fromCharCode(e), e === 92 && (ce.charCodeAt(j) !== 117 && Ge({}, qt, en), ++j, e = nx("u"), (!e || e === "\\" || !Nd(e.charCodeAt(0))) && Ge({}, qt, en), t = e); j < bn && (e = ce.charCodeAt(j), !!Y0(e));) ++j, t += String.fromCharCode(e), e === 92 && (t = t.substr(0, t.length - 1), ce.charCodeAt(j) !== 117 && Ge({}, qt, en), ++j, e = nx("u"), (!e || e === "\\" || !Y0(e.charCodeAt(0))) && Ge({}, qt, en), t += e);
+        for (e = ce.charCodeAt(B++), t = String.fromCharCode(e), e === 92 && (ce.charCodeAt(B) !== 117 && Ue({}, Bt, Kt), ++B, e = M2("u"), (!e || e === "\\" || !Ed(e.charCodeAt(0))) && Ue({}, Bt, Kt), t = e); B < yn && (e = ce.charCodeAt(B), !!$0(e));) ++B, t += String.fromCharCode(e), e === 92 && (t = t.substr(0, t.length - 1), ce.charCodeAt(B) !== 117 && Ue({}, Bt, Kt), ++B, e = M2("u"), (!e || e === "\\" || !$0(e.charCodeAt(0))) && Ue({}, Bt, Kt), t += e);
         return t
     }
 
-    function Uie() {
+    function Jne() {
         var e, t;
-        for (e = j++; j < bn;) {
-            if (t = ce.charCodeAt(j), t === 92) return j = e, jL();
-            if (Y0(t)) ++j;
+        for (e = B++; B < yn;) {
+            if (t = ce.charCodeAt(B), t === 92) return B = e, K4();
+            if ($0(t)) ++B;
             else break
         }
-        return ce.slice(e, j)
+        return ce.slice(e, B)
     }
 
-    function qie() {
+    function Qne() {
         var e, t, n;
-        return e = j, t = ce.charCodeAt(j) === 92 ? jL() : Uie(), t.length === 1 ? n = ml : Bie.hasOwnProperty(t) ? n = fo : t === "null" ? n = E1 : t === "true" || t === "false" ? n = S1 : n = ml, {
+        return e = B, t = ce.charCodeAt(B) === 92 ? K4() : Jne(), t.length === 1 ? n = rl : Vne.hasOwnProperty(t) ? n = eo : t === "null" ? n = s1 : t === "true" || t === "false" ? n = r1 : n = rl, {
             type: n,
             value: t,
             start: e,
-            end: j
+            end: B
         }
     }
 
-    function Lv() {
-        var e = j,
-            t = ce.charCodeAt(j),
-            n, i = ce[j],
-            r, a, s;
+    function pv() {
+        var e = B,
+            t = ce.charCodeAt(B),
+            n, i = ce[B],
+            r, s, a;
         switch (t) {
             case 46:
             case 40:
             case 41:
             case 59:
             case 44:
             case 123:
             case 125:
             case 91:
             case 93:
             case 58:
             case 63:
             case 126:
-                return ++j, {
-                    type: Hn,
+                return ++B, {
+                    type: Wn,
                     value: String.fromCharCode(t),
                     start: e,
-                    end: j
+                    end: B
                 };
             default:
-                if (n = ce.charCodeAt(j + 1), n === 61) switch (t) {
+                if (n = ce.charCodeAt(B + 1), n === 61) switch (t) {
                     case 43:
                     case 45:
                     case 47:
                     case 60:
                     case 62:
                     case 94:
                     case 124:
                     case 37:
                     case 38:
                     case 42:
-                        return j += 2, {
-                            type: Hn,
+                        return B += 2, {
+                            type: Wn,
                             value: String.fromCharCode(t) + String.fromCharCode(n),
                             start: e,
-                            end: j
+                            end: B
                         };
                     case 33:
                     case 61:
-                        return j += 2, ce.charCodeAt(j) === 61 && ++j, {
-                            type: Hn,
-                            value: ce.slice(e, j),
+                        return B += 2, ce.charCodeAt(B) === 61 && ++B, {
+                            type: Wn,
+                            value: ce.slice(e, B),
                             start: e,
-                            end: j
+                            end: B
                         }
                 }
         }
-        if (s = ce.substr(j, 4), s === ">>>=") return j += 4, {
-            type: Hn,
-            value: s,
+        if (a = ce.substr(B, 4), a === ">>>=") return B += 4, {
+            type: Wn,
+            value: a,
             start: e,
-            end: j
+            end: B
         };
-        if (a = s.substr(0, 3), a === ">>>" || a === "<<=" || a === ">>=") return j += 3, {
-            type: Hn,
-            value: a,
+        if (s = a.substr(0, 3), s === ">>>" || s === "<<=" || s === ">>=") return B += 3, {
+            type: Wn,
+            value: s,
             start: e,
-            end: j
+            end: B
         };
-        if (r = a.substr(0, 2), i === r[1] && "+-<>&|".indexOf(i) >= 0 || r === "=>") return j += 2, {
-            type: Hn,
+        if (r = s.substr(0, 2), i === r[1] && "+-<>&|".indexOf(i) >= 0 || r === "=>") return B += 2, {
+            type: Wn,
             value: r,
             start: e,
-            end: j
+            end: B
         };
-        if (r === "//" && Ge({}, qt, en), "<>=!+-*%&|^/".indexOf(i) >= 0) return ++j, {
-            type: Hn,
+        if (r === "//" && Ue({}, Bt, Kt), "<>=!+-*%&|^/".indexOf(i) >= 0) return ++B, {
+            type: Wn,
             value: i,
             start: e,
-            end: j
+            end: B
         };
-        Ge({}, qt, en)
+        Ue({}, Bt, Kt)
     }
 
-    function Wie(e) {
+    function Zne(e) {
         let t = "";
-        for (; j < bn && vE(ce[j]);) t += ce[j++];
-        return t.length === 0 && Ge({}, qt, en), Nd(ce.charCodeAt(j)) && Ge({}, qt, en), {
-            type: Gl,
+        for (; B < yn && IS(ce[B]);) t += ce[B++];
+        return t.length === 0 && Ue({}, Bt, Kt), Ed(ce.charCodeAt(B)) && Ue({}, Bt, Kt), {
+            type: Ol,
             value: parseInt("0x" + t, 16),
             start: e,
-            end: j
+            end: B
         }
     }
 
-    function Hie(e) {
-        let t = "0" + ce[j++];
-        for (; j < bn && yh(ce[j]);) t += ce[j++];
-        return (Nd(ce.charCodeAt(j)) || $a(ce.charCodeAt(j))) && Ge({}, qt, en), {
-            type: Gl,
+    function eie(e) {
+        let t = "0" + ce[B++];
+        for (; B < yn && sh(ce[B]);) t += ce[B++];
+        return (Ed(ce.charCodeAt(B)) || xs(ce.charCodeAt(B))) && Ue({}, Bt, Kt), {
+            type: Ol,
             value: parseInt(t, 8),
             octal: !0,
             start: e,
-            end: j
+            end: B
         }
     }
 
-    function v3() {
+    function FT() {
         var e, t, n;
-        if (n = ce[j], O1($a(n.charCodeAt(0)) || n === ".", "Numeric literal must start with a decimal digit or a decimal point"), t = j, e = "", n !== ".") {
-            if (e = ce[j++], n = ce[j], e === "0") {
-                if (n === "x" || n === "X") return ++j, Wie(t);
-                if (yh(n)) return Hie(t);
-                n && $a(n.charCodeAt(0)) && Ge({}, qt, en)
+        if (n = ce[B], a1(xs(n.charCodeAt(0)) || n === ".", "Numeric literal must start with a decimal digit or a decimal point"), t = B, e = "", n !== ".") {
+            if (e = ce[B++], n = ce[B], e === "0") {
+                if (n === "x" || n === "X") return ++B, Zne(t);
+                if (sh(n)) return eie(t);
+                n && xs(n.charCodeAt(0)) && Ue({}, Bt, Kt)
             }
-            for (; $a(ce.charCodeAt(j));) e += ce[j++];
-            n = ce[j]
+            for (; xs(ce.charCodeAt(B));) e += ce[B++];
+            n = ce[B]
         }
         if (n === ".") {
-            for (e += ce[j++]; $a(ce.charCodeAt(j));) e += ce[j++];
-            n = ce[j]
+            for (e += ce[B++]; xs(ce.charCodeAt(B));) e += ce[B++];
+            n = ce[B]
         }
         if (n === "e" || n === "E")
-            if (e += ce[j++], n = ce[j], (n === "+" || n === "-") && (e += ce[j++]), $a(ce.charCodeAt(j)))
-                for (; $a(ce.charCodeAt(j));) e += ce[j++];
-            else Ge({}, qt, en);
-        return Nd(ce.charCodeAt(j)) && Ge({}, qt, en), {
-            type: Gl,
+            if (e += ce[B++], n = ce[B], (n === "+" || n === "-") && (e += ce[B++]), xs(ce.charCodeAt(B)))
+                for (; xs(ce.charCodeAt(B));) e += ce[B++];
+            else Ue({}, Bt, Kt);
+        return Ed(ce.charCodeAt(B)) && Ue({}, Bt, Kt), {
+            type: Ol,
             value: parseFloat(e),
             start: t,
-            end: j
+            end: B
         }
     }
 
-    function Yie() {
+    function tie() {
         var e = "",
-            t, n, i, r, a = !1;
-        for (t = ce[j], O1(t === "'" || t === '"', "String literal must starts with a quote"), n = j, ++j; j < bn;)
-            if (i = ce[j++], i === t) {
+            t, n, i, r, s = !1;
+        for (t = ce[B], a1(t === "'" || t === '"', "String literal must starts with a quote"), n = B, ++B; B < yn;)
+            if (i = ce[B++], i === t) {
                 t = "";
                 break
             } else if (i === "\\")
-            if (i = ce[j++], !i || !qh(i.charCodeAt(0))) switch (i) {
+            if (i = ce[B++], !i || !Fh(i.charCodeAt(0))) switch (i) {
                 case "u":
                 case "x":
-                    ce[j] === "{" ? (++j, e += Gie()) : e += nx(i);
+                    ce[B] === "{" ? (++B, e += Kne()) : e += M2(i);
                     break;
                 case "n":
                     e += `
 `;
                     break;
                 case "r":
                     e += "\r";
@@ -30156,290 +30177,290 @@
                 case "f":
                     e += "\f";
                     break;
                 case "v":
                     e += "\v";
                     break;
                 default:
-                    yh(i) ? (r = "01234567".indexOf(i), r !== 0 && (a = !0), j < bn && yh(ce[j]) && (a = !0, r = r * 8 + "01234567".indexOf(ce[j++]), "0123".indexOf(i) >= 0 && j < bn && yh(ce[j]) && (r = r * 8 + "01234567".indexOf(ce[j++]))), e += String.fromCharCode(r)) : e += i;
+                    sh(i) ? (r = "01234567".indexOf(i), r !== 0 && (s = !0), B < yn && sh(ce[B]) && (s = !0, r = r * 8 + "01234567".indexOf(ce[B++]), "0123".indexOf(i) >= 0 && B < yn && sh(ce[B]) && (r = r * 8 + "01234567".indexOf(ce[B++]))), e += String.fromCharCode(r)) : e += i;
                     break
-            } else i === "\r" && ce[j] === `
-` && ++j;
+            } else i === "\r" && ce[B] === `
+` && ++B;
             else {
-                if (qh(i.charCodeAt(0))) break;
+                if (Fh(i.charCodeAt(0))) break;
                 e += i
-            } return t !== "" && Ge({}, qt, en), {
-            type: Pd,
+            } return t !== "" && Ue({}, Bt, Kt), {
+            type: Sd,
             value: e,
-            octal: a,
+            octal: s,
             start: n,
-            end: j
+            end: B
         }
     }
 
-    function Xie(e, t) {
+    function nie(e, t) {
         let n = e;
         t.indexOf("u") >= 0 && (n = n.replace(/\\u\{([0-9a-fA-F]+)\}/g, (i, r) => {
             if (parseInt(r, 16) <= 1114111) return "x";
-            Ge({}, tx)
+            Ue({}, T2)
         }).replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, "x"));
         try {
             new RegExp(n)
         } catch {
-            Ge({}, tx)
+            Ue({}, T2)
         }
         try {
             return new RegExp(e, t)
         } catch {
             return null
         }
     }
 
-    function Vie() {
+    function iie() {
         var e, t, n, i, r;
-        for (e = ce[j], O1(e === "/", "Regular expression literal must start with a slash"), t = ce[j++], n = !1, i = !1; j < bn;)
-            if (e = ce[j++], t += e, e === "\\") e = ce[j++], qh(e.charCodeAt(0)) && Ge({}, Nv), t += e;
-            else if (qh(e.charCodeAt(0))) Ge({}, Nv);
+        for (e = ce[B], a1(e === "/", "Regular expression literal must start with a slash"), t = ce[B++], n = !1, i = !1; B < yn;)
+            if (e = ce[B++], t += e, e === "\\") e = ce[B++], Fh(e.charCodeAt(0)) && Ue({}, gv), t += e;
+            else if (Fh(e.charCodeAt(0))) Ue({}, gv);
         else if (n) e === "]" && (n = !1);
         else if (e === "/") {
             i = !0;
             break
         } else e === "[" && (n = !0);
-        return i || Ge({}, Nv), r = t.substr(1, t.length - 2), {
+        return i || Ue({}, gv), r = t.substr(1, t.length - 2), {
             value: r,
             literal: t
         }
     }
 
-    function Kie() {
+    function rie() {
         var e, t, n;
-        for (t = "", n = ""; j < bn && (e = ce[j], !!Y0(e.charCodeAt(0)));) ++j, e === "\\" && j < bn ? Ge({}, qt, en) : (n += e, t += e);
-        return n.search(/[^gimuy]/g) >= 0 && Ge({}, tx, n), {
+        for (t = "", n = ""; B < yn && (e = ce[B], !!$0(e.charCodeAt(0)));) ++B, e === "\\" && B < yn ? Ue({}, Bt, Kt) : (n += e, t += e);
+        return n.search(/[^gimuy]/g) >= 0 && Ue({}, T2, n), {
             value: n,
             literal: t
         }
     }
 
-    function Jie() {
+    function sie() {
         var e, t, n, i;
-        return Ze = null, IL(), e = j, t = Vie(), n = Kie(), i = Xie(t.value, n.value), {
+        return Qe = null, V4(), e = B, t = iie(), n = rie(), i = nie(t.value, n.value), {
             literal: t.literal + n.literal,
             value: i,
             regex: {
                 pattern: t.value,
                 flags: n.value
             },
             start: e,
-            end: j
+            end: B
         }
     }
 
-    function Qie(e) {
-        return e.type === ml || e.type === fo || e.type === S1 || e.type === E1
+    function aie(e) {
+        return e.type === rl || e.type === eo || e.type === r1 || e.type === s1
     }
 
-    function zL() {
-        if (IL(), j >= bn) return {
-            type: Rd,
-            start: j,
-            end: j
+    function J4() {
+        if (V4(), B >= yn) return {
+            type: wd,
+            start: B,
+            end: B
         };
-        const e = ce.charCodeAt(j);
-        return Nd(e) ? qie() : e === 40 || e === 41 || e === 59 ? Lv() : e === 39 || e === 34 ? Yie() : e === 46 ? $a(ce.charCodeAt(j + 1)) ? v3() : Lv() : $a(e) ? v3() : Lv()
+        const e = ce.charCodeAt(B);
+        return Ed(e) ? Qne() : e === 40 || e === 41 || e === 59 ? pv() : e === 39 || e === 34 ? tie() : e === 46 ? xs(ce.charCodeAt(B + 1)) ? FT() : pv() : xs(e) ? FT() : pv()
     }
 
-    function Kn() {
-        const e = Ze;
-        return j = e.end, Ze = zL(), j = e.end, e
+    function Xn() {
+        const e = Qe;
+        return B = e.end, Qe = J4(), B = e.end, e
     }
 
-    function BL() {
-        const e = j;
-        Ze = zL(), j = e
+    function Q4() {
+        const e = B;
+        Qe = J4(), B = e
     }
 
-    function Zie(e) {
-        const t = new Er(wie);
+    function oie(e) {
+        const t = new yr(Mne);
         return t.elements = e, t
     }
 
-    function b3(e, t, n) {
-        const i = new Er(e === "||" || e === "&&" ? kie : Sie);
+    function RT(e, t, n) {
+        const i = new yr(e === "||" || e === "&&" ? Nne : One);
         return i.operator = e, i.left = t, i.right = n, i
     }
 
-    function ere(e, t) {
-        const n = new Er(Eie);
+    function lie(e, t) {
+        const n = new yr(Fne);
         return n.callee = e, n.arguments = t, n
     }
 
-    function tre(e, t, n) {
-        const i = new Er(Oie);
+    function uie(e, t, n) {
+        const i = new yr(Rne);
         return i.test = e, i.consequent = t, i.alternate = n, i
     }
 
-    function bE(e) {
-        const t = new Er(NL);
+    function zS(e) {
+        const t = new yr(Y4);
         return t.name = e, t
     }
 
-    function eh(e) {
-        const t = new Er(Cie);
+    function Uf(e) {
+        const t = new yr(Dne);
         return t.value = e.value, t.raw = ce.slice(e.start, e.end), e.regex && (t.raw === "//" && (t.raw = "/(?:)/"), t.regex = e.regex), t
     }
 
-    function x3(e, t, n) {
-        const i = new Er(Aie);
+    function DT(e, t, n) {
+        const i = new yr(Pne);
         return i.computed = e === "[", i.object = t, i.property = n, i.computed || (n.member = !0), i
     }
 
-    function nre(e) {
-        const t = new Er(Tie);
+    function cie(e) {
+        const t = new yr(Lne);
         return t.properties = e, t
     }
 
-    function _3(e, t, n) {
-        const i = new Er($ie);
+    function NT(e, t, n) {
+        const i = new yr(Ine);
         return i.key = t, i.value = n, i.kind = e, i
     }
 
-    function ire(e, t) {
-        const n = new Er(Mie);
+    function fie(e, t) {
+        const n = new yr(zne);
         return n.operator = e, n.argument = t, n.prefix = !0, n
     }
 
-    function Ge(e, t) {
+    function Ue(e, t) {
         var n, i = Array.prototype.slice.call(arguments, 2),
-            r = t.replace(/%(\d)/g, (a, s) => (O1(s < i.length, "Message reference must be in range"), i[s]));
-        throw n = new Error(r), n.index = j, n.description = r, n
+            r = t.replace(/%(\d)/g, (s, a) => (a1(a < i.length, "Message reference must be in range"), i[a]));
+        throw n = new Error(r), n.index = B, n.description = r, n
     }
 
-    function C1(e) {
-        e.type === Rd && Ge(e, Nie), e.type === Gl && Ge(e, Fie), e.type === Pd && Ge(e, Die), e.type === ml && Ge(e, Rie), e.type === fo && Ge(e, Pie), Ge(e, qt, e.value)
+    function o1(e) {
+        e.type === wd && Ue(e, Wne), e.type === Ol && Ue(e, Bne), e.type === Sd && Ue(e, jne), e.type === rl && Ue(e, Une), e.type === eo && Ue(e, Gne), Ue(e, Bt, e.value)
     }
 
-    function xn(e) {
-        const t = Kn();
-        (t.type !== Hn || t.value !== e) && C1(t)
+    function vn(e) {
+        const t = Xn();
+        (t.type !== Wn || t.value !== e) && o1(t)
     }
 
-    function ut(e) {
-        return Ze.type === Hn && Ze.value === e
+    function lt(e) {
+        return Qe.type === Wn && Qe.value === e
     }
 
-    function Iv(e) {
-        return Ze.type === fo && Ze.value === e
+    function mv(e) {
+        return Qe.type === eo && Qe.value === e
     }
 
-    function rre() {
+    function hie() {
         const e = [];
-        for (j = Ze.start, xn("["); !ut("]");) ut(",") ? (Kn(), e.push(null)) : (e.push(yl()), ut("]") || xn(","));
-        return Kn(), Zie(e)
+        for (B = Qe.start, vn("["); !lt("]");) lt(",") ? (Xn(), e.push(null)) : (e.push(sl()), lt("]") || vn(","));
+        return Xn(), oie(e)
     }
 
-    function w3() {
-        j = Ze.start;
-        const e = Kn();
-        return e.type === Pd || e.type === Gl ? (e.octal && Ge(e, LL), eh(e)) : bE(e.value)
+    function PT() {
+        B = Qe.start;
+        const e = Xn();
+        return e.type === Sd || e.type === Ol ? (e.octal && Ue(e, X4), Uf(e)) : zS(e.value)
     }
 
-    function are() {
+    function die() {
         var e, t, n, i;
-        if (j = Ze.start, e = Ze, e.type === ml) return n = w3(), xn(":"), i = yl(), _3("init", n, i);
-        if (e.type === Rd || e.type === Hn) C1(e);
-        else return t = w3(), xn(":"), i = yl(), _3("init", t, i)
+        if (B = Qe.start, e = Qe, e.type === rl) return n = PT(), vn(":"), i = sl(), NT("init", n, i);
+        if (e.type === wd || e.type === Wn) o1(e);
+        else return t = PT(), vn(":"), i = sl(), NT("init", t, i)
     }
 
-    function sre() {
+    function gie() {
         var e = [],
             t, n, i, r = {},
-            a = String;
-        for (j = Ze.start, xn("{"); !ut("}");) t = are(), t.key.type === NL ? n = t.key.name : n = a(t.key.value), i = "$" + n, Object.prototype.hasOwnProperty.call(r, i) ? Ge({}, Lie) : r[i] = !0, e.push(t), ut("}") || xn(",");
-        return xn("}"), nre(e)
+            s = String;
+        for (B = Qe.start, vn("{"); !lt("}");) t = die(), t.key.type === Y4 ? n = t.key.name : n = s(t.key.value), i = "$" + n, Object.prototype.hasOwnProperty.call(r, i) ? Ue({}, qne) : r[i] = !0, e.push(t), lt("}") || vn(",");
+        return vn("}"), cie(e)
     }
 
-    function ore() {
-        xn("(");
-        const e = xE();
-        return xn(")"), e
+    function pie() {
+        vn("(");
+        const e = BS();
+        return vn(")"), e
     }
-    const lre = {
+    const mie = {
         if: 1
     };
 
-    function ure() {
+    function yie() {
         var e, t, n;
-        if (ut("(")) return ore();
-        if (ut("[")) return rre();
-        if (ut("{")) return sre();
-        if (e = Ze.type, j = Ze.start, e === ml || lre[Ze.value]) n = bE(Kn().value);
-        else if (e === Pd || e === Gl) Ze.octal && Ge(Ze, LL), n = eh(Kn());
+        if (lt("(")) return pie();
+        if (lt("[")) return hie();
+        if (lt("{")) return gie();
+        if (e = Qe.type, B = Qe.start, e === rl || mie[Qe.value]) n = zS(Xn().value);
+        else if (e === Sd || e === Ol) Qe.octal && Ue(Qe, X4), n = Uf(Xn());
         else {
-            if (e === fo) throw new Error(Uh);
-            e === S1 ? (t = Kn(), t.value = t.value === "true", n = eh(t)) : e === E1 ? (t = Kn(), t.value = null, n = eh(t)) : ut("/") || ut("/=") ? (n = eh(Jie()), BL()) : C1(Kn())
+            if (e === eo) throw new Error(Oh);
+            e === r1 ? (t = Xn(), t.value = t.value === "true", n = Uf(t)) : e === s1 ? (t = Xn(), t.value = null, n = Uf(t)) : lt("/") || lt("/=") ? (n = Uf(sie()), Q4()) : o1(Xn())
         }
         return n
     }
 
-    function cre() {
+    function vie() {
         const e = [];
-        if (xn("("), !ut(")"))
-            for (; j < bn && (e.push(yl()), !ut(")"));) xn(",");
-        return xn(")"), e
+        if (vn("("), !lt(")"))
+            for (; B < yn && (e.push(sl()), !lt(")"));) vn(",");
+        return vn(")"), e
     }
 
-    function fre() {
-        j = Ze.start;
-        const e = Kn();
-        return Qie(e) || C1(e), bE(e.value)
+    function bie() {
+        B = Qe.start;
+        const e = Xn();
+        return aie(e) || o1(e), zS(e.value)
     }
 
-    function hre() {
-        return xn("."), fre()
+    function xie() {
+        return vn("."), bie()
     }
 
-    function dre() {
-        xn("[");
-        const e = xE();
-        return xn("]"), e
+    function _ie() {
+        vn("[");
+        const e = BS();
+        return vn("]"), e
     }
 
-    function gre() {
+    function wie() {
         var e, t, n;
-        for (e = ure();;)
-            if (ut(".")) n = hre(), e = x3(".", e, n);
-            else if (ut("(")) t = cre(), e = ere(e, t);
-        else if (ut("[")) n = dre(), e = x3("[", e, n);
+        for (e = yie();;)
+            if (lt(".")) n = xie(), e = DT(".", e, n);
+            else if (lt("(")) t = vie(), e = lie(e, t);
+        else if (lt("[")) n = _ie(), e = DT("[", e, n);
         else break;
         return e
     }
 
-    function S3() {
-        const e = gre();
-        if (Ze.type === Hn && (ut("++") || ut("--"))) throw new Error(Uh);
+    function LT() {
+        const e = wie();
+        if (Qe.type === Wn && (lt("++") || lt("--"))) throw new Error(Oh);
         return e
     }
 
-    function Cp() {
+    function lp() {
         var e, t;
-        if (Ze.type !== Hn && Ze.type !== fo) t = S3();
+        if (Qe.type !== Wn && Qe.type !== eo) t = LT();
         else {
-            if (ut("++") || ut("--")) throw new Error(Uh);
-            if (ut("+") || ut("-") || ut("~") || ut("!")) e = Kn(), t = Cp(), t = ire(e.value, t);
+            if (lt("++") || lt("--")) throw new Error(Oh);
+            if (lt("+") || lt("-") || lt("~") || lt("!")) e = Xn(), t = lp(), t = fie(e.value, t);
             else {
-                if (Iv("delete") || Iv("void") || Iv("typeof")) throw new Error(Uh);
-                t = S3()
+                if (mv("delete") || mv("void") || mv("typeof")) throw new Error(Oh);
+                t = LT()
             }
         }
         return t
     }
 
-    function E3(e) {
+    function IT(e) {
         let t = 0;
-        if (e.type !== Hn && e.type !== fo) return 0;
+        if (e.type !== Wn && e.type !== eo) return 0;
         switch (e.value) {
             case "||":
                 t = 1;
                 break;
             case "&&":
                 t = 2;
                 break;
@@ -30480,93 +30501,94 @@
             case "%":
                 t = 11;
                 break
         }
         return t
     }
 
-    function pre() {
-        var e, t, n, i, r, a, s, o, l, u;
-        if (e = Ze, l = Cp(), i = Ze, r = E3(i), r === 0) return l;
-        for (i.prec = r, Kn(), t = [e, Ze], s = Cp(), a = [l, i, s];
-            (r = E3(Ze)) > 0;) {
-            for (; a.length > 2 && r <= a[a.length - 2].prec;) s = a.pop(), o = a.pop().value, l = a.pop(), t.pop(), n = b3(o, l, s), a.push(n);
-            i = Kn(), i.prec = r, a.push(i), t.push(Ze), n = Cp(), a.push(n)
+    function Sie() {
+        var e, t, n, i, r, s, a, o, l, u;
+        if (e = Qe, l = lp(), i = Qe, r = IT(i), r === 0) return l;
+        for (i.prec = r, Xn(), t = [e, Qe], a = lp(), s = [l, i, a];
+            (r = IT(Qe)) > 0;) {
+            for (; s.length > 2 && r <= s[s.length - 2].prec;) a = s.pop(), o = s.pop().value, l = s.pop(), t.pop(), n = RT(o, l, a), s.push(n);
+            i = Xn(), i.prec = r, s.push(i), t.push(Qe), n = lp(), s.push(n)
         }
-        for (u = a.length - 1, n = a[u], t.pop(); u > 1;) t.pop(), n = b3(a[u - 1].value, a[u - 2], n), u -= 2;
+        for (u = s.length - 1, n = s[u], t.pop(); u > 1;) t.pop(), n = RT(s[u - 1].value, s[u - 2], n), u -= 2;
         return n
     }
 
-    function yl() {
+    function sl() {
         var e, t, n;
-        return e = pre(), ut("?") && (Kn(), t = yl(), xn(":"), n = yl(), e = tre(e, t, n)), e
+        return e = Sie(), lt("?") && (Xn(), t = sl(), vn(":"), n = sl(), e = uie(e, t, n)), e
     }
 
-    function xE() {
-        const e = yl();
-        if (ut(",")) throw new Error(Uh);
+    function BS() {
+        const e = sl();
+        if (lt(",")) throw new Error(Oh);
         return e
     }
 
-    function _E(e) {
-        ce = e, j = 0, bn = ce.length, Ze = null, BL();
-        const t = xE();
-        if (Ze.type !== Rd) throw new Error("Unexpect token after expression.");
+    function jS(e) {
+        ce = e, B = 0, yn = ce.length, Qe = null, Q4();
+        const t = BS();
+        if (Qe.type !== wd) throw new Error("Unexpect token after expression.");
         return t
     }
-    var GL = {
+    var Z4 = {
         NaN: "NaN",
         E: "Math.E",
         LN2: "Math.LN2",
         LN10: "Math.LN10",
         LOG2E: "Math.LOG2E",
         LOG10E: "Math.LOG10E",
         PI: "Math.PI",
         SQRT1_2: "Math.SQRT1_2",
         SQRT2: "Math.SQRT2",
         MIN_VALUE: "Number.MIN_VALUE",
         MAX_VALUE: "Number.MAX_VALUE"
     };
 
-    function UL(e) {
-        function t(s, o, l, u) {
+    function eL(e) {
+        function t(a, o, l, u) {
             let c = e(o[0]);
-            return l && (c = l + "(" + c + ")", l.lastIndexOf("new ", 0) === 0 && (c = "(" + c + ")")), c + "." + s + (u < 0 ? "" : u === 0 ? "()" : "(" + o.slice(1).map(e).join(",") + ")")
+            return l && (c = l + "(" + c + ")", l.lastIndexOf("new ", 0) === 0 && (c = "(" + c + ")")), c + "." + a + (u < 0 ? "" : u === 0 ? "()" : "(" + o.slice(1).map(e).join(",") + ")")
         }
 
-        function n(s, o, l) {
-            return u => t(s, u, o, l)
+        function n(a, o, l) {
+            return u => t(a, u, o, l)
         }
         const i = "new Date",
             r = "String",
-            a = "RegExp";
+            s = "RegExp";
         return {
             isNaN: "Number.isNaN",
             isFinite: "Number.isFinite",
             abs: "Math.abs",
             acos: "Math.acos",
             asin: "Math.asin",
             atan: "Math.atan",
             atan2: "Math.atan2",
             ceil: "Math.ceil",
             cos: "Math.cos",
             exp: "Math.exp",
             floor: "Math.floor",
+            hypot: "Math.hypot",
             log: "Math.log",
             max: "Math.max",
             min: "Math.min",
             pow: "Math.pow",
             random: "Math.random",
             round: "Math.round",
             sin: "Math.sin",
             sqrt: "Math.sqrt",
             tan: "Math.tan",
-            clamp: function(s) {
-                s.length < 3 && G("Missing arguments to clamp function."), s.length > 3 && G("Too many arguments to clamp function.");
-                const o = s.map(e);
+            clamp: function(a) {
+                a.length < 3 && U("Missing arguments to clamp function."), a.length > 3 && U("Too many arguments to clamp function.");
+                const o = a.map(e);
                 return "Math.max(" + o[1] + ", Math.min(" + o[2] + "," + o[0] + "))"
             },
             now: "Date.now",
             utc: "Date.UTC",
             datetime: i,
             date: n("getDate", i, 0),
             day: n("getDay", i, 0),
@@ -30590,66 +30612,66 @@
             parseFloat: "parseFloat",
             parseInt: "parseInt",
             upper: n("toUpperCase", r, 0),
             lower: n("toLowerCase", r, 0),
             substring: n("substring", r),
             split: n("split", r),
             trim: n("trim", r, 0),
-            regexp: a,
-            test: n("test", a),
-            if: function(s) {
-                s.length < 3 && G("Missing arguments to if function."), s.length > 3 && G("Too many arguments to if function.");
-                const o = s.map(e);
+            regexp: s,
+            test: n("test", s),
+            if: function(a) {
+                a.length < 3 && U("Missing arguments to if function."), a.length > 3 && U("Too many arguments to if function.");
+                const o = a.map(e);
                 return "(" + o[0] + "?" + o[1] + ":" + o[2] + ")"
             }
         }
     }
 
-    function mre(e) {
+    function Eie(e) {
         const t = e && e.length - 1;
         return t && (e[0] === '"' && e[t] === '"' || e[0] === "'" && e[t] === "'") ? e.slice(1, -1) : e
     }
 
-    function qL(e) {
+    function tL(e) {
         e = e || {};
-        const t = e.allowed ? br(e.allowed) : {},
-            n = e.forbidden ? br(e.forbidden) : {},
-            i = e.constants || GL,
-            r = (e.functions || UL)(f),
-            a = e.globalvar,
-            s = e.fieldvar,
-            o = Ae(a) ? a : g => `${a}["${g}"]`;
+        const t = e.allowed ? fr(e.allowed) : {},
+            n = e.forbidden ? fr(e.forbidden) : {},
+            i = e.constants || Z4,
+            r = (e.functions || eL)(f),
+            s = e.globalvar,
+            a = e.fieldvar,
+            o = $e(s) ? s : g => `${s}["${g}"]`;
         let l = {},
             u = {},
             c = 0;
 
         function f(g) {
             if (re(g)) return g;
             const p = h[g.type];
-            return p == null && G("Unsupported type: " + g.type), p(g)
+            return p == null && U("Unsupported type: " + g.type), p(g)
         }
         const h = {
             Literal: g => g.raw,
             Identifier: g => {
                 const p = g.name;
-                return c > 0 ? p : pe(n, p) ? G("Illegal identifier: " + p) : pe(i, p) ? i[p] : pe(t, p) ? p : (l[p] = 1, o(p))
+                return c > 0 ? p : me(n, p) ? U("Illegal identifier: " + p) : me(i, p) ? i[p] : me(t, p) ? p : (l[p] = 1, o(p))
             },
             MemberExpression: g => {
                 const p = !g.computed,
                     m = f(g.object);
                 p && (c += 1);
                 const y = f(g.property);
-                return m === s && (u[mre(y)] = 1), p && (c -= 1), m + (p ? "." + y : "[" + y + "]")
+                return m === a && (u[Eie(y)] = 1), p && (c -= 1), m + (p ? "." + y : "[" + y + "]")
             },
             CallExpression: g => {
-                g.callee.type !== "Identifier" && G("Illegal callee type: " + g.callee.type);
+                g.callee.type !== "Identifier" && U("Illegal callee type: " + g.callee.type);
                 const p = g.callee.name,
                     m = g.arguments,
-                    y = pe(r, p) && r[p];
-                return y || G("Unrecognized function: " + p), Ae(y) ? y(m) : y + "(" + m.map(f).join(",") + ")"
+                    y = me(r, p) && r[p];
+                return y || U("Unrecognized function: " + p), $e(y) ? y(m) : y + "(" + m.map(f).join(",") + ")"
             },
             ArrayExpression: g => "[" + g.elements.map(f).join(",") + "]",
             BinaryExpression: g => "(" + f(g.left) + " " + g.operator + " " + f(g.right) + ")",
             UnaryExpression: g => "(" + g.operator + f(g.argument) + ")",
             ConditionalExpression: g => "(" + f(g.test) + "?" + f(g.consequent) + ":" + f(g.alternate) + ")",
             LogicalExpression: g => "(" + f(g.left) + g.operator + f(g.right) + ")",
             ObjectExpression: g => "{" + g.properties.map(f).join(",") + "}",
@@ -30667,1062 +30689,1062 @@
                 fields: Object.keys(u)
             };
             return l = {}, u = {}, p
         }
         return d.functions = r, d.constants = i, d
     }
 
-    function jv(e, t) {
+    function yv(e, t) {
         return e == null || t == null ? NaN : e < t ? -1 : e > t ? 1 : e >= t ? 0 : NaN
     }
 
-    function yre(e, t) {
+    function Cie(e, t) {
         return e == null || t == null ? NaN : t < e ? -1 : t > e ? 1 : t >= e ? 0 : NaN
     }
 
-    function vre(e) {
+    function kie(e) {
         let t, n, i;
-        e.length !== 2 ? (t = jv, n = (o, l) => jv(e(o), l), i = (o, l) => e(o) - l) : (t = e === jv || e === yre ? e : bre, n = e, i = e);
+        e.length !== 2 ? (t = yv, n = (o, l) => yv(e(o), l), i = (o, l) => e(o) - l) : (t = e === yv || e === Cie ? e : Aie, n = e, i = e);
 
         function r(o, l, u = 0, c = o.length) {
             if (u < c) {
                 if (t(l, l) !== 0) return c;
                 do {
                     const f = u + c >>> 1;
                     n(o[f], l) < 0 ? u = f + 1 : c = f
                 } while (u < c)
             }
             return u
         }
 
-        function a(o, l, u = 0, c = o.length) {
+        function s(o, l, u = 0, c = o.length) {
             if (u < c) {
                 if (t(l, l) !== 0) return c;
                 do {
                     const f = u + c >>> 1;
                     n(o[f], l) <= 0 ? u = f + 1 : c = f
                 } while (u < c)
             }
             return u
         }
 
-        function s(o, l, u = 0, c = o.length) {
+        function a(o, l, u = 0, c = o.length) {
             const f = r(o, l, u, c - 1);
             return f > u && i(o[f - 1], l) > -i(o[f], l) ? f - 1 : f
         }
         return {
             left: r,
-            center: s,
-            right: a
+            center: a,
+            right: s
         }
     }
 
-    function bre() {
+    function Aie() {
         return 0
     }
 
-    function xre(e, ...t) {
-        e = new Gp(e), t = t.map(_re);
+    function $ie(e, ...t) {
+        e = new Sp(e), t = t.map(Tie);
         e: for (const n of e)
             for (const i of t)
                 if (!i.has(n)) {
                     e.delete(n);
                     continue e
                 }
         return e
     }
 
-    function _re(e) {
-        return e instanceof Gp ? e : new Gp(e)
+    function Tie(e) {
+        return e instanceof Sp ? e : new Sp(e)
     }
 
-    function wre(...e) {
-        const t = new Gp;
+    function Mie(...e) {
+        const t = new Sp;
         for (const n of e)
             for (const i of n) t.add(i);
         return t
     }
-    const wE = "intersect",
-        O3 = "union",
-        Sre = "vlMulti",
-        Ere = "vlPoint",
-        C3 = "or",
-        Ore = "and",
-        Nr = "_vgsid_",
-        Wh = ri(Nr),
-        Cre = "E",
-        kre = "R",
-        Are = "R-E",
-        Tre = "R-LE",
-        $re = "R-RE",
-        X0 = "index:unit";
-
-    function k3(e, t) {
-        for (var n = t.fields, i = t.values, r = n.length, a = 0, s, o; a < r; ++a)
-            if (o = n[a], o.getter = ri.getter || ri(o.field), s = o.getter(e), Ds(s) && (s = gn(s)), Ds(i[a]) && (i[a] = gn(i[a])), Ds(i[a][0]) && (i[a] = i[a].map(gn)), o.type === Cre) {
-                if (q(i[a]) ? i[a].indexOf(s) < 0 : s !== i[a]) return !1
-            } else if (o.type === kre) {
-            if (!Su(s, i[a])) return !1
-        } else if (o.type === $re) {
-            if (!Su(s, i[a], !0, !1)) return !1
-        } else if (o.type === Are) {
-            if (!Su(s, i[a], !1, !1)) return !1
-        } else if (o.type === Tre && !Su(s, i[a], !1, !0)) return !1;
+    const US = "intersect",
+        zT = "union",
+        Oie = "vlMulti",
+        Fie = "vlPoint",
+        BT = "or",
+        Rie = "and",
+        Or = "_vgsid_",
+        Rh = ni(Or),
+        Die = "E",
+        Nie = "R",
+        Pie = "R-E",
+        Lie = "R-LE",
+        Iie = "R-RE",
+        T0 = "index:unit";
+
+    function jT(e, t) {
+        for (var n = t.fields, i = t.values, r = n.length, s = 0, a, o; s < r; ++s)
+            if (o = n[s], o.getter = ni.getter || ni(o.field), a = o.getter(e), Ea(a) && (a = hn(a)), Ea(i[s]) && (i[s] = hn(i[s])), Ea(i[s][0]) && (i[s] = i[s].map(hn)), o.type === Die) {
+                if (W(i[s]) ? i[s].indexOf(a) < 0 : a !== i[s]) return !1
+            } else if (o.type === Nie) {
+            if (!hu(a, i[s])) return !1
+        } else if (o.type === Iie) {
+            if (!hu(a, i[s], !0, !1)) return !1
+        } else if (o.type === Pie) {
+            if (!hu(a, i[s], !1, !1)) return !1
+        } else if (o.type === Lie && !hu(a, i[s], !1, !0)) return !1;
         return !0
     }
 
-    function Mre(e, t, n) {
-        for (var i = this.context.data[e], r = i ? i.values.value : [], a = i ? i[X0] && i[X0].value : void 0, s = n === wE, o = r.length, l = 0, u, c, f, h, d; l < o; ++l)
-            if (u = r[l], a && s) {
+    function zie(e, t, n) {
+        for (var i = this.context.data[e], r = i ? i.values.value : [], s = i ? i[T0] && i[T0].value : void 0, a = n === US, o = r.length, l = 0, u, c, f, h, d; l < o; ++l)
+            if (u = r[l], s && a) {
                 if (c = c || {}, f = c[h = u.unit] || 0, f === -1) continue;
-                if (d = k3(t, u), c[h] = d ? -1 : ++f, d && a.size === 1) return !0;
-                if (!d && f === a.get(h).count) return !1
-            } else if (d = k3(t, u), s ^ d) return d;
-        return o && s
-    }
-    const WL = vre(Wh),
-        Fre = WL.left,
-        Dre = WL.right;
+                if (d = jT(t, u), c[h] = d ? -1 : ++f, d && s.size === 1) return !0;
+                if (!d && f === s.get(h).count) return !1
+            } else if (d = jT(t, u), a ^ d) return d;
+        return o && a
+    }
+    const nL = kie(Rh),
+        Bie = nL.left,
+        jie = nL.right;
 
-    function Rre(e, t, n) {
+    function Uie(e, t, n) {
         const i = this.context.data[e],
             r = i ? i.values.value : [],
-            a = i ? i[X0] && i[X0].value : void 0,
-            s = n === wE,
-            o = Wh(t),
-            l = Fre(r, o);
-        if (l === r.length || Wh(r[l]) !== o) return !1;
-        if (a && s) {
-            if (a.size === 1) return !0;
-            if (Dre(r, o) - l < a.size) return !1
+            s = i ? i[T0] && i[T0].value : void 0,
+            a = n === US,
+            o = Rh(t),
+            l = Bie(r, o);
+        if (l === r.length || Rh(r[l]) !== o) return !1;
+        if (s && a) {
+            if (s.size === 1) return !0;
+            if (jie(r, o) - l < s.size) return !1
         }
         return !0
     }
 
-    function Pre(e, t) {
-        return e.map(n => ke(t.fields ? {
-            values: t.fields.map(i => (i.getter || (i.getter = ri(i.field)))(n.datum))
+    function Gie(e, t) {
+        return e.map(n => Ae(t.fields ? {
+            values: t.fields.map(i => (i.getter || (i.getter = ni(i.field)))(n.datum))
         } : {
-            [Nr]: Wh(n.datum)
+            [Or]: Rh(n.datum)
         }, t))
     }
 
-    function Nre(e, t, n, i) {
-        for (var r = this.context.data[e], a = r ? r.values.value : [], s = {}, o = {}, l = {}, u, c, f, h, d, g, p, m, y, v, b = a.length, x = 0, _, S; x < b; ++x)
-            if (u = a[x], h = u.unit, c = u.fields, f = u.values, c && f) {
-                for (_ = 0, S = c.length; _ < S; ++_) d = c[_], p = s[d.field] || (s[d.field] = {}), m = p[h] || (p[h] = []), l[d.field] = y = d.type.charAt(0), v = zv[`${y}_union`], p[h] = v(m, ie(f[_]));
-                n && (m = o[h] || (o[h] = []), m.push(ie(f).reduce((w, O, k) => (w[c[k].field] = O, w), {})))
-            } else d = Nr, g = Wh(u), p = s[d] || (s[d] = {}), m = p[h] || (p[h] = []), m.push(g), n && (m = o[h] || (o[h] = []), m.push({
-                [Nr]: g
+    function Wie(e, t, n, i) {
+        for (var r = this.context.data[e], s = r ? r.values.value : [], a = {}, o = {}, l = {}, u, c, f, h, d, g, p, m, y, v, b = s.length, x = 0, _, S; x < b; ++x)
+            if (u = s[x], h = u.unit, c = u.fields, f = u.values, c && f) {
+                for (_ = 0, S = c.length; _ < S; ++_) d = c[_], p = a[d.field] || (a[d.field] = {}), m = p[h] || (p[h] = []), l[d.field] = y = d.type.charAt(0), v = vv[`${y}_union`], p[h] = v(m, se(f[_]));
+                n && (m = o[h] || (o[h] = []), m.push(se(f).reduce((w, E, A) => (w[c[A].field] = E, w), {})))
+            } else d = Or, g = Rh(u), p = a[d] || (a[d] = {}), m = p[h] || (p[h] = []), m.push(g), n && (m = o[h] || (o[h] = []), m.push({
+                [Or]: g
             }));
-        if (t = t || O3, s[Nr] ? s[Nr] = zv[`${Nr}_${t}`](...Object.values(s[Nr])) : Object.keys(s).forEach(w => {
-                s[w] = Object.keys(s[w]).map(O => s[w][O]).reduce((O, k) => O === void 0 ? k : zv[`${l[w]}_${t}`](O, k))
-            }), a = Object.keys(o), n && a.length) {
-            const w = i ? Ere : Sre;
-            s[w] = t === O3 ? {
-                [C3]: a.reduce((O, k) => (O.push(...o[k]), O), [])
+        if (t = t || zT, a[Or] ? a[Or] = vv[`${Or}_${t}`](...Object.values(a[Or])) : Object.keys(a).forEach(w => {
+                a[w] = Object.keys(a[w]).map(E => a[w][E]).reduce((E, A) => E === void 0 ? A : vv[`${l[w]}_${t}`](E, A))
+            }), s = Object.keys(o), n && s.length) {
+            const w = i ? Fie : Oie;
+            a[w] = t === zT ? {
+                [BT]: s.reduce((E, A) => (E.push(...o[A]), E), [])
             } : {
-                [Ore]: a.map(O => ({
-                    [C3]: o[O]
+                [Rie]: s.map(E => ({
+                    [BT]: o[E]
                 }))
             }
         }
-        return s
+        return a
     }
-    var zv = {
-        [`${Nr}_union`]: wre,
-        [`${Nr}_intersect`]: xre,
+    var vv = {
+        [`${Or}_union`]: Mie,
+        [`${Or}_intersect`]: $ie,
         E_union: function(e, t) {
             if (!e.length) return t;
             for (var n = 0, i = t.length; n < i; ++n) e.indexOf(t[n]) < 0 && e.push(t[n]);
             return e
         },
         E_intersect: function(e, t) {
             return e.length ? e.filter(n => t.indexOf(n) >= 0) : t
         },
         R_union: function(e, t) {
-            var n = gn(t[0]),
-                i = gn(t[1]);
+            var n = hn(t[0]),
+                i = hn(t[1]);
             return n > i && (n = t[1], i = t[0]), e.length ? (e[0] > n && (e[0] = n), e[1] < i && (e[1] = i), e) : [n, i]
         },
         R_intersect: function(e, t) {
-            var n = gn(t[0]),
-                i = gn(t[1]);
+            var n = hn(t[0]),
+                i = hn(t[1]);
             return n > i && (n = t[1], i = t[0]), e.length ? i < e[0] || e[1] < n ? [] : (e[0] < n && (e[0] = n), e[1] > i && (e[1] = i), e) : [n, i]
         }
     };
-    const Lre = ":",
-        Ire = "@";
+    const qie = ":",
+        Hie = "@";
 
-    function SE(e, t, n, i) {
-        t[0].type !== pl && G("First argument to selection functions must be a string literal.");
+    function GS(e, t, n, i) {
+        t[0].type !== il && U("First argument to selection functions must be a string literal.");
         const r = t[0].value,
-            a = t.length >= 2 && Le(t).value,
-            s = "unit",
-            o = Ire + s,
-            l = Lre + r;
-        a === wE && !pe(i, o) && (i[o] = n.getData(r).indataRef(n, s)), pe(i, l) || (i[l] = n.getData(r).tuplesRef())
+            s = t.length >= 2 && De(t).value,
+            a = "unit",
+            o = Hie + a,
+            l = qie + r;
+        s === US && !me(i, o) && (i[o] = n.getData(r).indataRef(n, a)), me(i, l) || (i[l] = n.getData(r).tuplesRef())
     }
 
-    function HL(e) {
+    function iL(e) {
         const t = this.context.data[e];
         return t ? t.values.value : []
     }
 
-    function jre(e, t, n) {
+    function Yie(e, t, n) {
         const i = this.context.data[e]["index:" + t],
             r = i ? i.value.get(n) : void 0;
         return r && r.count
     }
 
-    function zre(e, t) {
+    function Xie(e, t) {
         const n = this.context.dataflow,
             i = this.context.data[e],
             r = i.input;
-        return n.pulse(r, n.changeset().remove(Ii).insert(t)), 1
+        return n.pulse(r, n.changeset().remove(Ri).insert(t)), 1
     }
 
-    function Bre(e, t, n) {
+    function Vie(e, t, n) {
         if (e) {
             const i = this.context.dataflow,
                 r = e.mark.source;
             i.pulse(r, i.changeset().encode(e, t))
         }
         return n !== void 0 ? n : e
     }
-    const Ld = e => function(t, n) {
+    const Cd = e => function(t, n) {
             return this.context.dataflow.locale()[e](n)(t)
         },
-        Gre = Ld("format"),
-        YL = Ld("timeFormat"),
-        Ure = Ld("utcFormat"),
-        qre = Ld("timeParse"),
-        Wre = Ld("utcParse"),
-        jg = new Date(2e3, 0, 1);
+        Kie = Cd("format"),
+        rL = Cd("timeFormat"),
+        Jie = Cd("utcFormat"),
+        Qie = Cd("timeParse"),
+        Zie = Cd("utcParse"),
+        Eg = new Date(2e3, 0, 1);
 
-    function k1(e, t, n) {
-        return !Number.isInteger(e) || !Number.isInteger(t) ? "" : (jg.setYear(2e3), jg.setMonth(e), jg.setDate(t), YL.call(this, jg, n))
+    function l1(e, t, n) {
+        return !Number.isInteger(e) || !Number.isInteger(t) ? "" : (Eg.setYear(2e3), Eg.setMonth(e), Eg.setDate(t), rL.call(this, Eg, n))
     }
 
-    function Hre(e) {
-        return k1.call(this, e, 1, "%B")
+    function ere(e) {
+        return l1.call(this, e, 1, "%B")
     }
 
-    function Yre(e) {
-        return k1.call(this, e, 1, "%b")
+    function tre(e) {
+        return l1.call(this, e, 1, "%b")
     }
 
-    function Xre(e) {
-        return k1.call(this, 0, 2 + e, "%A")
+    function nre(e) {
+        return l1.call(this, 0, 2 + e, "%A")
     }
 
-    function Vre(e) {
-        return k1.call(this, 0, 2 + e, "%a")
+    function ire(e) {
+        return l1.call(this, 0, 2 + e, "%a")
     }
-    const Kre = ":",
-        Jre = "@",
-        ix = "%",
-        XL = "$";
+    const rre = ":",
+        sre = "@",
+        O2 = "%",
+        sL = "$";
 
-    function EE(e, t, n, i) {
-        t[0].type !== pl && G("First argument to data functions must be a string literal.");
+    function WS(e, t, n, i) {
+        t[0].type !== il && U("First argument to data functions must be a string literal.");
         const r = t[0].value,
-            a = Kre + r;
-        if (!pe(a, i)) try {
-            i[a] = n.getData(r).tuplesRef()
+            s = rre + r;
+        if (!me(s, i)) try {
+            i[s] = n.getData(r).tuplesRef()
         } catch {}
     }
 
-    function Qre(e, t, n, i) {
-        t[0].type !== pl && G("First argument to indata must be a string literal."), t[1].type !== pl && G("Second argument to indata must be a string literal.");
+    function are(e, t, n, i) {
+        t[0].type !== il && U("First argument to indata must be a string literal."), t[1].type !== il && U("Second argument to indata must be a string literal.");
         const r = t[0].value,
-            a = t[1].value,
-            s = Jre + a;
-        pe(s, i) || (i[s] = n.getData(r).indataRef(n, a))
+            s = t[1].value,
+            a = sre + s;
+        me(a, i) || (i[a] = n.getData(r).indataRef(n, s))
     }
 
-    function Qn(e, t, n, i) {
-        if (t[0].type === pl) A3(n, i, t[0].value);
+    function Kn(e, t, n, i) {
+        if (t[0].type === il) UT(n, i, t[0].value);
         else
-            for (e in n.scales) A3(n, i, e)
+            for (e in n.scales) UT(n, i, e)
     }
 
-    function A3(e, t, n) {
-        const i = ix + n;
-        if (!pe(t, i)) try {
+    function UT(e, t, n) {
+        const i = O2 + n;
+        if (!me(t, i)) try {
             t[i] = e.scaleRef(n)
         } catch {}
     }
 
-    function ns(e, t) {
-        if (Ae(e)) return e;
+    function Ys(e, t) {
+        if ($e(e)) return e;
         if (re(e)) {
             const n = t.scales[e];
-            return n && xJ(n.value) ? n.value : void 0
+            return n && $K(n.value) ? n.value : void 0
         }
     }
 
-    function Zre(e, t, n) {
-        t.__bandwidth = r => r && r.bandwidth ? r.bandwidth() : 0, n._bandwidth = Qn, n._range = Qn, n._scale = Qn;
-        const i = r => "_[" + (r.type === pl ? Z(ix + r.value) : Z(ix) + "+" + e(r)) + "]";
+    function ore(e, t, n) {
+        t.__bandwidth = r => r && r.bandwidth ? r.bandwidth() : 0, n._bandwidth = Kn, n._range = Kn, n._scale = Kn;
+        const i = r => "_[" + (r.type === il ? Z(O2 + r.value) : Z(O2) + "+" + e(r)) + "]";
         return {
             _bandwidth: r => `this.__bandwidth(${i(r[0])})`,
             _range: r => `${i(r[0])}.range()`,
             _scale: r => `${i(r[0])}(${e(r[1])})`
         }
     }
 
-    function OE(e, t) {
+    function qS(e, t) {
         return function(n, i, r) {
             if (n) {
-                const a = ns(n, (r || this).context);
-                return a && a.path[e](i)
+                const s = Ys(n, (r || this).context);
+                return s && s.path[e](i)
             } else return t(i)
         }
     }
-    const eae = OE("area", HU),
-        tae = OE("bounds", KU),
-        nae = OE("centroid", nq);
+    const lre = qS("area", ZU),
+        ure = qS("bounds", iG),
+        cre = qS("centroid", uG);
 
-    function iae(e) {
+    function fre(e) {
         const t = this.context.group;
         let n = !1;
         if (t)
             for (; e;) {
                 if (e === t) {
                     n = !0;
                     break
                 }
                 e = e.mark.group
             }
         return n
     }
 
-    function CE(e, t, n) {
+    function HS(e, t, n) {
         try {
             e[t].apply(e, ["EXPRESSION"].concat([].slice.call(n)))
         } catch (i) {
             e.warn(i)
         }
         return n[n.length - 1]
     }
 
-    function rae() {
-        return CE(this.context.dataflow, "warn", arguments)
+    function hre() {
+        return HS(this.context.dataflow, "warn", arguments)
     }
 
-    function aae() {
-        return CE(this.context.dataflow, "info", arguments)
+    function dre() {
+        return HS(this.context.dataflow, "info", arguments)
     }
 
-    function sae() {
-        return CE(this.context.dataflow, "debug", arguments)
+    function gre() {
+        return HS(this.context.dataflow, "debug", arguments)
     }
 
-    function Bv(e) {
+    function bv(e) {
         const t = e / 255;
         return t <= .03928 ? t / 12.92 : Math.pow((t + .055) / 1.055, 2.4)
     }
 
-    function rx(e) {
-        const t = zs(e),
-            n = Bv(t.r),
-            i = Bv(t.g),
-            r = Bv(t.b);
+    function F2(e) {
+        const t = Ma(e),
+            n = bv(t.r),
+            i = bv(t.g),
+            r = bv(t.b);
         return .2126 * n + .7152 * i + .0722 * r
     }
 
-    function oae(e, t) {
-        const n = rx(e),
-            i = rx(t),
+    function pre(e, t) {
+        const n = F2(e),
+            i = F2(t),
             r = Math.max(n, i),
-            a = Math.min(n, i);
-        return (r + .05) / (a + .05)
+            s = Math.min(n, i);
+        return (r + .05) / (s + .05)
     }
 
-    function lae() {
+    function mre() {
         const e = [].slice.call(arguments);
-        return e.unshift({}), ke(...e)
+        return e.unshift({}), Ae(...e)
     }
 
-    function VL(e, t) {
-        return e === t || e !== e && t !== t ? !0 : q(e) ? q(t) && e.length === t.length ? uae(e, t) : !1 : se(e) && se(t) ? KL(e, t) : !1
+    function aL(e, t) {
+        return e === t || e !== e && t !== t ? !0 : W(e) ? W(t) && e.length === t.length ? yre(e, t) : !1 : ae(e) && ae(t) ? oL(e, t) : !1
     }
 
-    function uae(e, t) {
+    function yre(e, t) {
         for (let n = 0, i = e.length; n < i; ++n)
-            if (!VL(e[n], t[n])) return !1;
+            if (!aL(e[n], t[n])) return !1;
         return !0
     }
 
-    function KL(e, t) {
+    function oL(e, t) {
         for (const n in e)
-            if (!VL(e[n], t[n])) return !1;
+            if (!aL(e[n], t[n])) return !1;
         return !0
     }
 
-    function T3(e) {
-        return t => KL(e, t)
+    function GT(e) {
+        return t => oL(e, t)
     }
 
-    function cae(e, t, n, i, r, a) {
-        const s = this.context.dataflow,
+    function vre(e, t, n, i, r, s) {
+        const a = this.context.dataflow,
             o = this.context.data[e],
             l = o.input,
-            u = s.stamp();
+            u = a.stamp();
         let c = o.changes,
             f, h;
-        if (s._trigger === !1 || !(l.value.length || t || i)) return 0;
-        if ((!c || c.stamp < u) && (o.changes = c = s.changeset(), c.stamp = u, s.runAfter(() => {
-                o.modified = !0, s.pulse(l, c).run()
-            }, !0, 1)), n && (f = n === !0 ? Ii : q(n) || Jm(n) ? n : T3(n), c.remove(f)), t && c.insert(t), i && (f = T3(i), l.value.some(f) ? c.remove(f) : c.insert(i)), r)
-            for (h in a) c.modify(r, h, a[h]);
+        if (a._trigger === !1 || !(l.value.length || t || i)) return 0;
+        if ((!c || c.stamp < u) && (o.changes = c = a.changeset(), c.stamp = u, a.runAfter(() => {
+                o.modified = !0, a.pulse(l, c).run()
+            }, !0, 1)), n && (f = n === !0 ? Ri : W(n) || Fm(n) ? n : GT(n), c.remove(f)), t && c.insert(t), i && (f = GT(i), l.value.some(f) ? c.remove(f) : c.insert(i)), r)
+            for (h in s) c.modify(r, h, s[h]);
         return 1
     }
 
-    function fae(e) {
+    function bre(e) {
         const t = e.touches,
             n = t[0].clientX - t[1].clientX,
             i = t[0].clientY - t[1].clientY;
-        return Math.sqrt(n * n + i * i)
+        return Math.hypot(n, i)
     }
 
-    function hae(e) {
+    function xre(e) {
         const t = e.touches;
         return Math.atan2(t[0].clientY - t[1].clientY, t[0].clientX - t[1].clientX)
     }
-    const $3 = {};
+    const WT = {};
 
-    function dae(e, t) {
-        const n = $3[t] || ($3[t] = ri(t));
-        return q(e) ? e.map(n) : n(e)
+    function _re(e, t) {
+        const n = WT[t] || (WT[t] = ni(t));
+        return W(e) ? e.map(n) : n(e)
     }
 
-    function kE(e) {
-        return q(e) || ArrayBuffer.isView(e) ? e : null
+    function YS(e) {
+        return W(e) || ArrayBuffer.isView(e) ? e : null
     }
 
-    function AE(e) {
-        return kE(e) || (re(e) ? e : null)
+    function XS(e) {
+        return YS(e) || (re(e) ? e : null)
     }
 
-    function gae(e) {
+    function wre(e) {
         for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++) n[i - 1] = arguments[i];
-        return kE(e).join(...n)
+        return YS(e).join(...n)
     }
 
-    function pae(e) {
+    function Sre(e) {
         for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++) n[i - 1] = arguments[i];
-        return AE(e).indexOf(...n)
+        return XS(e).indexOf(...n)
     }
 
-    function mae(e) {
+    function Ere(e) {
         for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++) n[i - 1] = arguments[i];
-        return AE(e).lastIndexOf(...n)
+        return XS(e).lastIndexOf(...n)
     }
 
-    function yae(e) {
+    function Cre(e) {
         for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++) n[i - 1] = arguments[i];
-        return AE(e).slice(...n)
+        return XS(e).slice(...n)
     }
 
-    function vae(e, t, n) {
-        return Ae(n) && G("Function argument passed to replace."), String(e).replace(t, n)
+    function kre(e, t, n) {
+        return $e(n) && U("Function argument passed to replace."), String(e).replace(t, n)
     }
 
-    function bae(e) {
-        return kE(e).slice().reverse()
+    function Are(e) {
+        return YS(e).slice().reverse()
     }
 
-    function xae(e, t, n) {
-        return Vw(e || 0, t || 0, n || 0)
+    function $re(e, t, n) {
+        return pw(e || 0, t || 0, n || 0)
     }
 
-    function _ae(e, t) {
-        const n = ns(e, (t || this).context);
+    function Tre(e, t) {
+        const n = Ys(e, (t || this).context);
         return n && n.bandwidth ? n.bandwidth() : 0
     }
 
-    function wae(e, t) {
-        const n = ns(e, (t || this).context);
+    function Mre(e, t) {
+        const n = Ys(e, (t || this).context);
         return n ? n.copy() : void 0
     }
 
-    function Sae(e, t) {
-        const n = ns(e, (t || this).context);
+    function Ore(e, t) {
+        const n = Ys(e, (t || this).context);
         return n ? n.domain() : []
     }
 
-    function Eae(e, t, n) {
-        const i = ns(e, (n || this).context);
-        return i ? q(t) ? (i.invertRange || i.invert)(t) : (i.invert || i.invertExtent)(t) : void 0
+    function Fre(e, t, n) {
+        const i = Ys(e, (n || this).context);
+        return i ? W(t) ? (i.invertRange || i.invert)(t) : (i.invert || i.invertExtent)(t) : void 0
     }
 
-    function Oae(e, t) {
-        const n = ns(e, (t || this).context);
+    function Rre(e, t) {
+        const n = Ys(e, (t || this).context);
         return n && n.range ? n.range() : []
     }
 
-    function Cae(e, t, n) {
-        const i = ns(e, (n || this).context);
+    function Dre(e, t, n) {
+        const i = Ys(e, (n || this).context);
         return i ? i(t) : void 0
     }
 
-    function kae(e, t, n, i, r) {
-        e = ns(e, (r || this).context);
-        const a = XN(t, n);
-        let s = e.domain(),
-            o = s[0],
-            l = Le(s),
-            u = wn;
-        return l - o ? u = NN(e, o, l) : e = (e.interpolator ? qe("sequential")().interpolator(e.interpolator()) : qe("linear")().interpolate(e.interpolate()).range(e.range())).domain([o = 0, l = 1]), e.ticks && (s = e.ticks(+i || 15), o !== s[0] && s.unshift(o), l !== Le(s) && s.push(l)), s.forEach(c => a.stop(u(c), e(c))), a
+    function Nre(e, t, n, i, r) {
+        e = Ys(e, (r || this).context);
+        const s = sP(t, n);
+        let a = e.domain(),
+            o = a[0],
+            l = De(a),
+            u = bn;
+        return l - o ? u = YN(e, o, l) : e = (e.interpolator ? We("sequential")().interpolator(e.interpolator()) : We("linear")().interpolate(e.interpolate()).range(e.range())).domain([o = 0, l = 1]), e.ticks && (a = e.ticks(+i || 15), o !== a[0] && a.unshift(o), l !== De(a) && a.push(l)), a.forEach(c => s.stop(u(c), e(c))), s
     }
 
-    function Aae(e, t, n) {
-        const i = ns(e, (n || this).context);
+    function Pre(e, t, n) {
+        const i = Ys(e, (n || this).context);
         return function(r) {
             return i ? i.path.context(r)(t) : ""
         }
     }
 
-    function Tae(e) {
+    function Lre(e) {
         let t = null;
         return function(n) {
-            return n ? Ih(n, t = t || ic(e)) : e
+            return n ? kh(n, t = t || Hu(e)) : e
         }
     }
-    const JL = e => e.data;
+    const lL = e => e.data;
 
-    function QL(e, t) {
-        const n = HL.call(t, e);
+    function uL(e, t) {
+        const n = iL.call(t, e);
         return n.root && n.root.lookup || {}
     }
 
-    function $ae(e, t, n) {
-        const i = QL(e, this),
+    function Ire(e, t, n) {
+        const i = uL(e, this),
             r = i[t],
-            a = i[n];
-        return r && a ? r.path(a).map(JL) : void 0
+            s = i[n];
+        return r && s ? r.path(s).map(lL) : void 0
     }
 
-    function Mae(e, t) {
-        const n = QL(e, this)[t];
-        return n ? n.ancestors().map(JL) : void 0
+    function zre(e, t) {
+        const n = uL(e, this)[t];
+        return n ? n.ancestors().map(lL) : void 0
     }
-    const ZL = () => typeof window < "u" && window || null;
+    const cL = () => typeof window < "u" && window || null;
 
-    function Fae() {
-        const e = ZL();
+    function Bre() {
+        const e = cL();
         return e ? e.screen : {}
     }
 
-    function Dae() {
-        const e = ZL();
+    function jre() {
+        const e = cL();
         return e ? [e.innerWidth, e.innerHeight] : [void 0, void 0]
     }
 
-    function Rae() {
+    function Ure() {
         const e = this.context.dataflow,
             t = e.container && e.container();
         return t ? [t.clientWidth, t.clientHeight] : [void 0, void 0]
     }
 
-    function eI(e, t, n) {
+    function fL(e, t, n) {
         if (!e) return [];
-        const [i, r] = e, a = new At().set(i[0], i[1], r[0], r[1]), s = n || this.context.dataflow.scenegraph().root;
-        return I4(s, a, Pae(t))
+        const [i, r] = e, s = new kt().set(i[0], i[1], r[0], r[1]), a = n || this.context.dataflow.scenegraph().root;
+        return VP(a, s, Gre(t))
     }
 
-    function Pae(e) {
+    function Gre(e) {
         let t = null;
         if (e) {
-            const n = ie(e.marktype),
-                i = ie(e.markname);
-            t = r => (!n.length || n.some(a => r.marktype === a)) && (!i.length || i.some(a => r.name === a))
+            const n = se(e.marktype),
+                i = se(e.markname);
+            t = r => (!n.length || n.some(s => r.marktype === s)) && (!i.length || i.some(s => r.name === s))
         }
         return t
     }
 
-    function Nae(e, t, n) {
+    function Wre(e, t, n) {
         let i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 5;
-        e = ie(e);
+        e = se(e);
         const r = e[e.length - 1];
-        return r === void 0 || Math.sqrt((r[0] - t) ** 2 + (r[1] - n) ** 2) > i ? [...e, [t, n]] : e
+        return r === void 0 || Math.hypot(r[0] - t, r[1] - n) > i ? [...e, [t, n]] : e
     }
 
-    function Lae(e) {
-        return ie(e).reduce((t, n, i) => {
-            let [r, a] = n;
-            return t += i == 0 ? `M ${r},${a} ` : i === e.length - 1 ? " Z" : `L ${r},${a} `
+    function qre(e) {
+        return se(e).reduce((t, n, i) => {
+            let [r, s] = n;
+            return t += i == 0 ? `M ${r},${s} ` : i === e.length - 1 ? " Z" : `L ${r},${s} `
         }, "")
     }
 
-    function Iae(e, t, n) {
+    function Hre(e, t, n) {
         const {
             x: i,
             y: r,
-            mark: a
-        } = n, s = new At().set(Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER, Number.MIN_SAFE_INTEGER, Number.MIN_SAFE_INTEGER);
-        for (const [l, u] of t) l < s.x1 && (s.x1 = l), l > s.x2 && (s.x2 = l), u < s.y1 && (s.y1 = u), u > s.y2 && (s.y2 = u);
-        return s.translate(i, r), eI([
-            [s.x1, s.y1],
-            [s.x2, s.y2]
-        ], e, a).filter(l => jae(l.x, l.y, t))
+            mark: s
+        } = n, a = new kt().set(Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER, Number.MIN_SAFE_INTEGER, Number.MIN_SAFE_INTEGER);
+        for (const [l, u] of t) l < a.x1 && (a.x1 = l), l > a.x2 && (a.x2 = l), u < a.y1 && (a.y1 = u), u > a.y2 && (a.y2 = u);
+        return a.translate(i, r), fL([
+            [a.x1, a.y1],
+            [a.x2, a.y2]
+        ], e, s).filter(l => Yre(l.x, l.y, t))
     }
 
-    function jae(e, t, n) {
+    function Yre(e, t, n) {
         let i = 0;
-        for (let r = 0, a = n.length - 1; r < n.length; a = r++) {
-            const [s, o] = n[a], [l, u] = n[r];
-            u > t != o > t && e < (s - l) * (t - u) / (o - u) + l && i++
+        for (let r = 0, s = n.length - 1; r < n.length; s = r++) {
+            const [a, o] = n[s], [l, u] = n[r];
+            u > t != o > t && e < (a - l) * (t - u) / (o - u) + l && i++
         }
         return i & 1
     }
-    const Hh = {
+    const Dh = {
             random() {
-                return zi()
+                return Ni()
             },
-            cumulativeNormal: n1,
-            cumulativeLogNormal: mw,
-            cumulativeUniform: xw,
-            densityNormal: fw,
-            densityLogNormal: pw,
-            densityUniform: bw,
-            quantileNormal: i1,
-            quantileLogNormal: yw,
-            quantileUniform: _w,
-            sampleNormal: t1,
-            sampleLogNormal: gw,
-            sampleUniform: vw,
-            isArray: q,
-            isBoolean: co,
-            isDate: Ds,
+            cumulativeNormal: Lm,
+            cumulativeLogNormal: N_,
+            cumulativeUniform: z_,
+            densityNormal: M_,
+            densityLogNormal: D_,
+            densityUniform: I_,
+            quantileNormal: Im,
+            quantileLogNormal: P_,
+            quantileUniform: B_,
+            sampleNormal: Pm,
+            sampleLogNormal: R_,
+            sampleUniform: L_,
+            isArray: W,
+            isBoolean: Za,
+            isDate: Ea,
             isDefined(e) {
                 return e !== void 0
             },
-            isNumber: tt,
-            isObject: se,
-            isRegExp: HR,
+            isNumber: Ze,
+            isObject: ae,
+            isRegExp: iD,
             isString: re,
-            isTuple: Jm,
+            isTuple: Fm,
             isValid(e) {
                 return e != null && e === e
             },
-            toBoolean: V_,
+            toBoolean: g_,
             toDate(e) {
-                return K_(e)
+                return p_(e)
             },
-            toNumber: gn,
-            toString: J_,
-            indexof: pae,
-            join: gae,
-            lastindexof: mae,
-            replace: vae,
-            reverse: bae,
-            slice: yae,
-            flush: qR,
-            lerp: YR,
-            merge: lae,
-            pad: KR,
-            peek: Le,
-            pluck: dae,
-            span: vd,
-            inrange: Su,
-            truncate: JR,
-            rgb: zs,
-            lab: jp,
-            hcl: zp,
-            hsl: Lp,
-            luminance: rx,
-            contrast: oae,
-            sequence: mi,
-            format: Gre,
-            utcFormat: Ure,
-            utcParse: Wre,
-            utcOffset: fP,
-            utcSequence: gP,
-            timeFormat: YL,
-            timeParse: qre,
-            timeOffset: cP,
-            timeSequence: dP,
-            timeUnitSpecifier: ZR,
-            monthFormat: Hre,
-            monthAbbrevFormat: Yre,
-            dayFormat: Xre,
-            dayAbbrevFormat: Vre,
-            quarter: zR,
-            utcquarter: BR,
-            week: tP,
-            utcweek: rP,
-            dayofyear: eP,
-            utcdayofyear: iP,
-            warn: rae,
-            info: aae,
-            debug: sae,
+            toNumber: hn,
+            toString: m_,
+            indexof: Sre,
+            join: wre,
+            lastindexof: Ere,
+            replace: kre,
+            reverse: Are,
+            slice: Cre,
+            flush: tD,
+            lerp: rD,
+            merge: mre,
+            pad: oD,
+            peek: De,
+            pluck: _re,
+            span: ad,
+            inrange: hu,
+            truncate: lD,
+            rgb: Ma,
+            lab: xp,
+            hcl: _p,
+            hsl: vp,
+            luminance: F2,
+            contrast: pre,
+            sequence: gi,
+            format: Kie,
+            utcFormat: Jie,
+            utcParse: Zie,
+            utcOffset: wD,
+            utcSequence: CD,
+            timeFormat: rL,
+            timeParse: Qie,
+            timeOffset: _D,
+            timeSequence: ED,
+            timeUnitSpecifier: cD,
+            monthFormat: ere,
+            monthAbbrevFormat: tre,
+            dayFormat: nre,
+            dayAbbrevFormat: ire,
+            quarter: JR,
+            utcquarter: QR,
+            week: hD,
+            utcweek: pD,
+            dayofyear: fD,
+            utcdayofyear: gD,
+            warn: hre,
+            info: dre,
+            debug: gre,
             extent(e) {
-                return Zr(e)
+                return Hr(e)
             },
-            inScope: iae,
-            intersect: eI,
-            clampRange: GR,
-            pinchDistance: fae,
-            pinchAngle: hae,
-            screen: Fae,
-            containerSize: Rae,
-            windowSize: Dae,
-            bandspace: xae,
-            setdata: zre,
-            pathShape: Tae,
-            panLinear: NR,
-            panLog: LR,
-            panPow: IR,
-            panSymlog: jR,
-            zoomLinear: U_,
-            zoomLog: q_,
-            zoomPow: T0,
-            zoomSymlog: W_,
-            encode: Bre,
-            modify: cae,
-            lassoAppend: Nae,
-            lassoPath: Lae,
-            intersectLasso: Iae
-        },
-        zae = ["view", "item", "group", "xy", "x", "y"],
-        Bae = "event.vega.",
-        tI = "this.",
-        TE = {},
-        nI = {
+            inScope: fre,
+            intersect: fL,
+            clampRange: ZR,
+            pinchDistance: bre,
+            pinchAngle: xre,
+            screen: Bre,
+            containerSize: Ure,
+            windowSize: jre,
+            bandspace: $re,
+            setdata: Xie,
+            pathShape: Lre,
+            panLinear: YR,
+            panLog: XR,
+            panPow: VR,
+            panSymlog: KR,
+            zoomLinear: l_,
+            zoomLog: u_,
+            zoomPow: c0,
+            zoomSymlog: c_,
+            encode: Vie,
+            modify: vre,
+            lassoAppend: Wre,
+            lassoPath: qre,
+            intersectLasso: Hre
+        },
+        Xre = ["view", "item", "group", "xy", "x", "y"],
+        Vre = "event.vega.",
+        hL = "this.",
+        VS = {},
+        dL = {
             forbidden: ["_"],
             allowed: ["datum", "event", "item"],
             fieldvar: "datum",
-            globalvar: e => `_[${Z(XL+e)}]`,
-            functions: Gae,
-            constants: GL,
-            visitors: TE
-        },
-        ax = qL(nI);
-
-    function Gae(e) {
-        const t = UL(e);
-        zae.forEach(n => t[n] = Bae + n);
-        for (const n in Hh) t[n] = tI + n;
-        return ke(t, Zre(e, Hh, TE)), t
-    }
-
-    function $t(e, t, n) {
-        return arguments.length === 1 ? Hh[e] : (Hh[e] = t, n && (TE[e] = n), ax && (ax.functions[e] = tI + e), this)
-    }
-    $t("bandwidth", _ae, Qn);
-    $t("copy", wae, Qn);
-    $t("domain", Sae, Qn);
-    $t("range", Oae, Qn);
-    $t("invert", Eae, Qn);
-    $t("scale", Cae, Qn);
-    $t("gradient", kae, Qn);
-    $t("geoArea", eae, Qn);
-    $t("geoBounds", tae, Qn);
-    $t("geoCentroid", nae, Qn);
-    $t("geoShape", Aae, Qn);
-    $t("indata", jre, Qre);
-    $t("data", HL, EE);
-    $t("treePath", $ae, EE);
-    $t("treeAncestors", Mae, EE);
-    $t("vlSelectionTest", Mre, SE);
-    $t("vlSelectionIdTest", Rre, SE);
-    $t("vlSelectionResolve", Nre, SE);
-    $t("vlSelectionTuples", Pre);
+            globalvar: e => `_[${Z(sL+e)}]`,
+            functions: Kre,
+            constants: Z4,
+            visitors: VS
+        },
+        R2 = tL(dL);
+
+    function Kre(e) {
+        const t = eL(e);
+        Xre.forEach(n => t[n] = Vre + n);
+        for (const n in Dh) t[n] = hL + n;
+        return Ae(t, ore(e, Dh, VS)), t
+    }
+
+    function At(e, t, n) {
+        return arguments.length === 1 ? Dh[e] : (Dh[e] = t, n && (VS[e] = n), R2 && (R2.functions[e] = hL + e), this)
+    }
+    At("bandwidth", Tre, Kn);
+    At("copy", Mre, Kn);
+    At("domain", Ore, Kn);
+    At("range", Rre, Kn);
+    At("invert", Fre, Kn);
+    At("scale", Dre, Kn);
+    At("gradient", Nre, Kn);
+    At("geoArea", lre, Kn);
+    At("geoBounds", ure, Kn);
+    At("geoCentroid", cre, Kn);
+    At("geoShape", Pre, Kn);
+    At("indata", Yie, are);
+    At("data", iL, WS);
+    At("treePath", Ire, WS);
+    At("treeAncestors", zre, WS);
+    At("vlSelectionTest", zie, GS);
+    At("vlSelectionIdTest", Uie, GS);
+    At("vlSelectionResolve", Wie, GS);
+    At("vlSelectionTuples", Gie);
 
-    function ta(e, t) {
+    function Xr(e, t) {
         const n = {};
         let i;
         try {
-            e = re(e) ? e : Z(e) + "", i = _E(e)
+            e = re(e) ? e : Z(e) + "", i = jS(e)
         } catch {
-            G("Expression parse error: " + e)
+            U("Expression parse error: " + e)
         }
-        i.visit(a => {
-            if (a.type !== PL) return;
-            const s = a.callee.name,
-                o = nI.visitors[s];
-            o && o(s, a.arguments, t, n)
+        i.visit(s => {
+            if (s.type !== H4) return;
+            const a = s.callee.name,
+                o = dL.visitors[a];
+            o && o(a, s.arguments, t, n)
         });
-        const r = ax(i);
-        return r.globals.forEach(a => {
-            const s = XL + a;
-            !pe(n, s) && t.getSignal(a) && (n[s] = t.signalRef(a))
+        const r = R2(i);
+        return r.globals.forEach(s => {
+            const a = sL + s;
+            !me(n, a) && t.getSignal(s) && (n[a] = t.signalRef(s))
         }), {
-            $expr: ke({
+            $expr: Ae({
                 code: r.code
             }, t.options.ast ? {
                 ast: i
             } : null),
             $fields: r.fields,
             $params: n
         }
     }
 
-    function Uae(e) {
+    function Jre(e) {
         const t = this,
             n = e.operators || [];
         return e.background && (t.background = e.background), e.eventConfig && (t.eventConfig = e.eventConfig), e.locale && (t.locale = e.locale), n.forEach(i => t.parseOperator(i)), n.forEach(i => t.parseOperatorParameters(i)), (e.streams || []).forEach(i => t.parseStream(i)), (e.updates || []).forEach(i => t.parseUpdate(i)), t.resolve()
     }
-    const qae = br(["rule"]),
-        M3 = br(["group", "image", "rect"]);
+    const Qre = fr(["rule"]),
+        qT = fr(["group", "image", "rect"]);
 
-    function Wae(e, t) {
+    function Zre(e, t) {
         let n = "";
-        return qae[t] || (e.x2 && (e.x ? (M3[t] && (n += "if(o.x>o.x2)$=o.x,o.x=o.x2,o.x2=$;"), n += "o.width=o.x2-o.x;") : n += "o.x=o.x2-(o.width||0);"), e.xc && (n += "o.x=o.xc-(o.width||0)/2;"), e.y2 && (e.y ? (M3[t] && (n += "if(o.y>o.y2)$=o.y,o.y=o.y2,o.y2=$;"), n += "o.height=o.y2-o.y;") : n += "o.y=o.y2-(o.height||0);"), e.yc && (n += "o.y=o.yc-(o.height||0)/2;")), n
+        return Qre[t] || (e.x2 && (e.x ? (qT[t] && (n += "if(o.x>o.x2)$=o.x,o.x=o.x2,o.x2=$;"), n += "o.width=o.x2-o.x;") : n += "o.x=o.x2-(o.width||0);"), e.xc && (n += "o.x=o.xc-(o.width||0)/2;"), e.y2 && (e.y ? (qT[t] && (n += "if(o.y>o.y2)$=o.y,o.y=o.y2,o.y2=$;"), n += "o.height=o.y2-o.y;") : n += "o.y=o.y2-(o.height||0);"), e.yc && (n += "o.y=o.yc-(o.height||0)/2;")), n
     }
 
-    function $E(e) {
+    function KS(e) {
         return (e + "").toLowerCase()
     }
 
-    function Hae(e) {
-        return $E(e) === "operator"
+    function ese(e) {
+        return KS(e) === "operator"
     }
 
-    function Yae(e) {
-        return $E(e) === "collect"
+    function tse(e) {
+        return KS(e) === "collect"
     }
 
-    function vf(e, t, n) {
+    function sf(e, t, n) {
         n.endsWith(";") || (n = "return(" + n + ");");
         const i = Function(...t.concat(n));
         return e && e.functions ? i.bind(e.functions) : i
     }
 
-    function Xae(e, t, n, i) {
+    function nse(e, t, n, i) {
         return `((u = ${e}) < (v = ${t}) || u == null) && v != null ? ${n}
   : (u > v || v == null) && u != null ? ${i}
   : ((v = v instanceof Date ? +v : v), (u = u instanceof Date ? +u : u)) !== u && v === v ? ${n}
   : v !== v && u === u ? ${i} : `
     }
-    var Vae = {
-        operator: (e, t) => vf(e, ["_"], t.code),
-        parameter: (e, t) => vf(e, ["datum", "_"], t.code),
-        event: (e, t) => vf(e, ["event"], t.code),
+    var ise = {
+        operator: (e, t) => sf(e, ["_"], t.code),
+        parameter: (e, t) => sf(e, ["datum", "_"], t.code),
+        event: (e, t) => sf(e, ["event"], t.code),
         handler: (e, t) => {
             const n = `var datum=event.item&&event.item.datum;return ${t.code};`;
-            return vf(e, ["_", "event"], n)
+            return sf(e, ["_", "event"], n)
         },
         encode: (e, t) => {
             const {
                 marktype: n,
                 channels: i
             } = t;
             let r = "var o=item,datum=o.datum,m=0,$;";
-            for (const a in i) {
-                const s = "o[" + Z(a) + "]";
-                r += `$=${i[a].code};if(${s}!==$)${s}=$,m=1;`
+            for (const s in i) {
+                const a = "o[" + Z(s) + "]";
+                r += `$=${i[s].code};if(${a}!==$)${a}=$,m=1;`
             }
-            return r += Wae(i, n), r += "return m;", vf(e, ["item", "_"], r)
+            return r += Zre(i, n), r += "return m;", sf(e, ["item", "_"], r)
         },
         codegen: {
             get(e) {
                 const t = `[${e.map(Z).join("][")}]`,
                     n = Function("_", `return _${t};`);
                 return n.path = t, n
             },
             comparator(e, t) {
                 let n;
-                const i = (a, s) => {
-                        const o = t[s];
+                const i = (s, a) => {
+                        const o = t[a];
                         let l, u;
-                        return a.path ? (l = `a${a.path}`, u = `b${a.path}`) : ((n = n || {})["f" + s] = a, l = `this.f${s}(a)`, u = `this.f${s}(b)`), Xae(l, u, -o, o)
+                        return s.path ? (l = `a${s.path}`, u = `b${s.path}`) : ((n = n || {})["f" + a] = s, l = `this.f${a}(a)`, u = `this.f${a}(b)`), nse(l, u, -o, o)
                     },
                     r = Function("a", "b", "var u, v; return " + e.map(i).join("") + "0;");
                 return n ? r.bind(n) : r
             }
         }
     };
 
-    function Kae(e) {
+    function rse(e) {
         const t = this;
-        Hae(e.type) || !e.type ? t.operator(e, e.update ? t.operatorExpression(e.update) : null) : t.transform(e, e.type)
+        ese(e.type) || !e.type ? t.operator(e, e.update ? t.operatorExpression(e.update) : null) : t.transform(e, e.type)
     }
 
-    function Jae(e) {
+    function sse(e) {
         const t = this;
         if (e.params) {
             const n = t.get(e.id);
-            n || G("Invalid operator id: " + e.id), t.dataflow.connect(n, n.parameters(t.parseParameters(e.params), e.react, e.initonly))
+            n || U("Invalid operator id: " + e.id), t.dataflow.connect(n, n.parameters(t.parseParameters(e.params), e.react, e.initonly))
         }
     }
 
-    function Qae(e, t) {
+    function ase(e, t) {
         t = t || {};
         const n = this;
         for (const i in e) {
             const r = e[i];
-            t[i] = q(r) ? r.map(a => F3(a, n, t)) : F3(r, n, t)
+            t[i] = W(r) ? r.map(s => HT(s, n, t)) : HT(r, n, t)
         }
         return t
     }
 
-    function F3(e, t, n) {
-        if (!e || !se(e)) return e;
-        for (let i = 0, r = D3.length, a; i < r; ++i)
-            if (a = D3[i], pe(e, a.key)) return a.parse(e, t, n);
+    function HT(e, t, n) {
+        if (!e || !ae(e)) return e;
+        for (let i = 0, r = YT.length, s; i < r; ++i)
+            if (s = YT[i], me(e, s.key)) return s.parse(e, t, n);
         return e
     }
-    var D3 = [{
+    var YT = [{
         key: "$ref",
-        parse: Zae
+        parse: ose
     }, {
         key: "$key",
-        parse: tse
+        parse: use
     }, {
         key: "$expr",
-        parse: ese
+        parse: lse
     }, {
         key: "$field",
-        parse: nse
+        parse: cse
     }, {
         key: "$encode",
-        parse: rse
+        parse: hse
     }, {
         key: "$compare",
-        parse: ise
+        parse: fse
     }, {
         key: "$context",
-        parse: ase
+        parse: dse
     }, {
         key: "$subflow",
-        parse: sse
+        parse: gse
     }, {
         key: "$tupleid",
-        parse: ose
+        parse: pse
     }];
 
-    function Zae(e, t) {
-        return t.get(e.$ref) || G("Operator not defined: " + e.$ref)
+    function ose(e, t) {
+        return t.get(e.$ref) || U("Operator not defined: " + e.$ref)
     }
 
-    function ese(e, t, n) {
+    function lse(e, t, n) {
         e.$params && t.parseParameters(e.$params, n);
         const i = "e:" + e.$expr.code;
-        return t.fn[i] || (t.fn[i] = ci(t.parameterExpression(e.$expr), e.$fields))
+        return t.fn[i] || (t.fn[i] = li(t.parameterExpression(e.$expr), e.$fields))
     }
 
-    function tse(e, t) {
+    function use(e, t) {
         const n = "k:" + e.$key + "_" + !!e.$flat;
-        return t.fn[n] || (t.fn[n] = X_(e.$key, e.$flat, t.expr.codegen))
+        return t.fn[n] || (t.fn[n] = d_(e.$key, e.$flat, t.expr.codegen))
     }
 
-    function nse(e, t) {
+    function cse(e, t) {
         if (!e.$field) return null;
         const n = "f:" + e.$field + "_" + e.$name;
-        return t.fn[n] || (t.fn[n] = ri(e.$field, e.$name, t.expr.codegen))
+        return t.fn[n] || (t.fn[n] = ni(e.$field, e.$name, t.expr.codegen))
     }
 
-    function ise(e, t) {
+    function fse(e, t) {
         const n = "c:" + e.$compare + "_" + e.$order,
-            i = ie(e.$compare).map(r => r && r.$tupleid ? de : r);
-        return t.fn[n] || (t.fn[n] = H_(i, e.$order, t.expr.codegen))
+            i = se(e.$compare).map(r => r && r.$tupleid ? ge : r);
+        return t.fn[n] || (t.fn[n] = f_(i, e.$order, t.expr.codegen))
     }
 
-    function rse(e, t) {
+    function hse(e, t) {
         const n = e.$encode,
             i = {};
         for (const r in n) {
-            const a = n[r];
-            i[r] = ci(t.encodeExpression(a.$expr), a.$fields), i[r].output = a.$output
+            const s = n[r];
+            i[r] = li(t.encodeExpression(s.$expr), s.$fields), i[r].output = s.$output
         }
         return i
     }
 
-    function ase(e, t) {
+    function dse(e, t) {
         return t
     }
 
-    function sse(e, t) {
+    function gse(e, t) {
         const n = e.$subflow;
-        return function(i, r, a) {
-            const s = t.fork().parse(n),
-                o = s.get(n.operators[0].id),
-                l = s.signals.parent;
-            return l && l.set(a), o.detachSubflow = () => t.detach(s), o
+        return function(i, r, s) {
+            const a = t.fork().parse(n),
+                o = a.get(n.operators[0].id),
+                l = a.signals.parent;
+            return l && l.set(s), o.detachSubflow = () => t.detach(a), o
         }
     }
 
-    function ose() {
-        return de
+    function pse() {
+        return ge
     }
 
-    function lse(e) {
+    function mse(e) {
         var t = this,
             n = e.filter != null ? t.eventExpression(e.filter) : void 0,
             i = e.stream != null ? t.get(e.stream) : void 0,
             r;
-        e.source ? i = t.events(e.source, e.type, n) : e.merge && (r = e.merge.map(a => t.get(a)), i = r[0].merge.apply(r[0], r.slice(1))), e.between && (r = e.between.map(a => t.get(a)), i = i.between(r[0], r[1])), e.filter && (i = i.filter(n)), e.throttle != null && (i = i.throttle(+e.throttle)), e.debounce != null && (i = i.debounce(+e.debounce)), i == null && G("Invalid stream definition: " + JSON.stringify(e)), e.consume && i.consume(!0), t.stream(e, i)
+        e.source ? i = t.events(e.source, e.type, n) : e.merge && (r = e.merge.map(s => t.get(s)), i = r[0].merge.apply(r[0], r.slice(1))), e.between && (r = e.between.map(s => t.get(s)), i = i.between(r[0], r[1])), e.filter && (i = i.filter(n)), e.throttle != null && (i = i.throttle(+e.throttle)), e.debounce != null && (i = i.debounce(+e.debounce)), i == null && U("Invalid stream definition: " + JSON.stringify(e)), e.consume && i.consume(!0), t.stream(e, i)
     }
 
-    function use(e) {
+    function yse(e) {
         var t = this,
-            n = se(n = e.source) ? n.$ref : n,
+            n = ae(n = e.source) ? n.$ref : n,
             i = t.get(n),
             r = null,
-            a = e.update,
-            s = void 0;
-        i || G("Source not defined: " + e.source), r = e.target && e.target.$expr ? t.eventExpression(e.target.$expr) : t.get(e.target), a && a.$expr && (a.$params && (s = t.parseParameters(a.$params)), a = t.handlerExpression(a.$expr)), t.update(e, i, r, a, s)
+            s = e.update,
+            a = void 0;
+        i || U("Source not defined: " + e.source), r = e.target && e.target.$expr ? t.eventExpression(e.target.$expr) : t.get(e.target), s && s.$expr && (s.$params && (a = t.parseParameters(s.$params)), s = t.handlerExpression(s.$expr)), t.update(e, i, r, s, a)
     }
-    const cse = {
+    const vse = {
         skip: !0
     };
 
-    function fse(e) {
+    function bse(e) {
         var t = this,
             n = {};
         if (e.signals) {
             var i = n.signals = {};
-            Object.keys(t.signals).forEach(a => {
-                const s = t.signals[a];
-                e.signals(a, s) && (i[a] = s.value)
+            Object.keys(t.signals).forEach(s => {
+                const a = t.signals[s];
+                e.signals(s, a) && (i[s] = a.value)
             })
         }
         if (e.data) {
             var r = n.data = {};
-            Object.keys(t.data).forEach(a => {
-                const s = t.data[a];
-                e.data(a, s) && (r[a] = s.input.value)
+            Object.keys(t.data).forEach(s => {
+                const a = t.data[s];
+                e.data(s, a) && (r[s] = a.input.value)
             })
         }
-        return t.subcontext && e.recurse !== !1 && (n.subcontext = t.subcontext.map(a => a.getState(e))), n
+        return t.subcontext && e.recurse !== !1 && (n.subcontext = t.subcontext.map(s => s.getState(e))), n
     }
 
-    function hse(e) {
+    function xse(e) {
         var t = this,
             n = t.dataflow,
             i = e.data,
             r = e.signals;
-        Object.keys(r || {}).forEach(a => {
-            n.update(t.signals[a], r[a], cse)
-        }), Object.keys(i || {}).forEach(a => {
-            n.pulse(t.data[a].input, n.changeset().remove(Ii).insert(i[a]))
-        }), (e.subcontext || []).forEach((a, s) => {
-            const o = t.subcontext[s];
-            o && o.setState(a)
+        Object.keys(r || {}).forEach(s => {
+            n.update(t.signals[s], r[s], vse)
+        }), Object.keys(i || {}).forEach(s => {
+            n.pulse(t.data[s].input, n.changeset().remove(Ri).insert(i[s]))
+        }), (e.subcontext || []).forEach((s, a) => {
+            const o = t.subcontext[a];
+            o && o.setState(s)
         })
     }
 
-    function iI(e, t, n, i) {
-        return new rI(e, t, n, i)
+    function gL(e, t, n, i) {
+        return new pL(e, t, n, i)
     }
 
-    function rI(e, t, n, i) {
-        this.dataflow = e, this.transforms = t, this.events = e.events.bind(e), this.expr = i || Vae, this.signals = {}, this.scales = {}, this.nodes = {}, this.data = {}, this.fn = {}, n && (this.functions = Object.create(n), this.functions.context = this)
+    function pL(e, t, n, i) {
+        this.dataflow = e, this.transforms = t, this.events = e.events.bind(e), this.expr = i || ise, this.signals = {}, this.scales = {}, this.nodes = {}, this.data = {}, this.fn = {}, n && (this.functions = Object.create(n), this.functions.context = this)
     }
 
-    function R3(e) {
+    function XT(e) {
         this.dataflow = e.dataflow, this.transforms = e.transforms, this.events = e.events, this.expr = e.expr, this.signals = Object.create(e.signals), this.scales = Object.create(e.scales), this.nodes = Object.create(e.nodes), this.data = Object.create(e.data), this.fn = Object.create(e.fn), e.functions && (this.functions = Object.create(e.functions), this.functions.context = this)
     }
-    rI.prototype = R3.prototype = {
+    pL.prototype = XT.prototype = {
         fork() {
-            const e = new R3(this);
+            const e = new XT(this);
             return (this.subcontext || (this.subcontext = [])).push(e), e
         },
         detach(e) {
             this.subcontext = this.subcontext.filter(n => n !== e);
             const t = Object.keys(e.nodes);
             for (const n of t) e.nodes[n]._targets = null;
             for (const n of t) e.nodes[n].detach();
@@ -31734,34 +31756,34 @@
         set(e, t) {
             return this.nodes[e] = t
         },
         add(e, t) {
             const n = this,
                 i = n.dataflow,
                 r = e.value;
-            if (n.set(e.id, t), Yae(e.type) && r && (r.$ingest ? i.ingest(t, r.$ingest, r.$format) : r.$request ? i.preload(t, r.$request, r.$format) : i.pulse(t, i.changeset().insert(r))), e.root && (n.root = t), e.parent) {
-                let a = n.get(e.parent.$ref);
-                a ? (i.connect(a, [t]), t.targets().add(a)) : (n.unresolved = n.unresolved || []).push(() => {
-                    a = n.get(e.parent.$ref), i.connect(a, [t]), t.targets().add(a)
+            if (n.set(e.id, t), tse(e.type) && r && (r.$ingest ? i.ingest(t, r.$ingest, r.$format) : r.$request ? i.preload(t, r.$request, r.$format) : i.pulse(t, i.changeset().insert(r))), e.root && (n.root = t), e.parent) {
+                let s = n.get(e.parent.$ref);
+                s ? (i.connect(s, [t]), t.targets().add(s)) : (n.unresolved = n.unresolved || []).push(() => {
+                    s = n.get(e.parent.$ref), i.connect(s, [t]), t.targets().add(s)
                 })
             }
             if (e.signal && (n.signals[e.signal] = t), e.scale && (n.scales[e.scale] = t), e.data)
-                for (const a in e.data) {
-                    const s = n.data[a] || (n.data[a] = {});
-                    e.data[a].forEach(o => s[o] = t)
+                for (const s in e.data) {
+                    const a = n.data[s] || (n.data[s] = {});
+                    e.data[s].forEach(o => a[o] = t)
                 }
         },
         resolve() {
             return (this.unresolved || []).forEach(e => e()), delete this.unresolved, this
         },
         operator(e, t) {
             this.add(e, this.dataflow.add(e.value, t))
         },
         transform(e, t) {
-            this.add(e, this.dataflow.add(this.transforms[$E(t)]))
+            this.add(e, this.dataflow.add(this.transforms[KS(t)]))
         },
         stream(e, t) {
             this.set(e.id, t)
         },
         update(e, t, n, i, r) {
             this.dataflow.on(t, n, i, r, e.options)
         },
@@ -31776,2316 +31798,2315 @@
         },
         handlerExpression(e) {
             return this.expr.handler(this, e)
         },
         encodeExpression(e) {
             return this.expr.encode(this, e)
         },
-        parse: Uae,
-        parseOperator: Kae,
-        parseOperatorParameters: Jae,
-        parseParameters: Qae,
-        parseStream: lse,
-        parseUpdate: use,
-        getState: fse,
-        setState: hse
+        parse: Jre,
+        parseOperator: rse,
+        parseOperatorParameters: sse,
+        parseParameters: ase,
+        parseStream: mse,
+        parseUpdate: yse,
+        getState: bse,
+        setState: xse
     };
 
-    function dse(e) {
+    function _se(e) {
         const t = e.container();
-        t && (t.setAttribute("role", "graphics-document"), t.setAttribute("aria-roleDescription", "visualization"), aI(t, e.description()))
+        t && (t.setAttribute("role", "graphics-document"), t.setAttribute("aria-roleDescription", "visualization"), mL(t, e.description()))
     }
 
-    function aI(e, t) {
+    function mL(e, t) {
         e && (t == null ? e.removeAttribute("aria-label") : e.setAttribute("aria-label", t))
     }
 
-    function gse(e) {
+    function wse(e) {
         e.add(null, t => (e._background = t.bg, e._resize = 1, t.bg), {
             bg: e._signals.background
         })
     }
-    const Gv = "default";
+    const xv = "default";
 
-    function pse(e) {
+    function Sse(e) {
         const t = e._signals.cursor || (e._signals.cursor = e.add({
-            user: Gv,
+            user: xv,
             item: null
         }));
         e.on(e.events("view", "mousemove"), t, (n, i) => {
             const r = t.value,
-                a = r ? re(r) ? r : r.user : Gv,
-                s = i.item && i.item.cursor || null;
-            return r && a === r.user && s == r.item ? r : {
-                user: a,
-                item: s
+                s = r ? re(r) ? r : r.user : xv,
+                a = i.item && i.item.cursor || null;
+            return r && s === r.user && a == r.item ? r : {
+                user: s,
+                item: a
             }
         }), e.add(null, function(n) {
             let i = n.cursor,
                 r = this.value;
-            return re(i) || (r = i.item, i = i.user), sx(e, i && i !== Gv ? i : r || i), r
+            return re(i) || (r = i.item, i = i.user), D2(e, i && i !== xv ? i : r || i), r
         }, {
             cursor: t
         })
     }
 
-    function sx(e, t) {
+    function D2(e, t) {
         const n = e.globalCursor() ? typeof document < "u" && document.body : e.container();
         if (n) return t == null ? n.style.removeProperty("cursor") : n.style.cursor = t
     }
 
-    function V0(e, t) {
+    function M0(e, t) {
         var n = e._runtime.data;
-        return pe(n, t) || G("Unrecognized data set: " + t), n[t]
+        return me(n, t) || U("Unrecognized data set: " + t), n[t]
     }
 
-    function mse(e, t) {
-        return arguments.length < 2 ? V0(this, e).values.value : A1.call(this, e, zl().remove(Ii).insert(t))
+    function Ese(e, t) {
+        return arguments.length < 2 ? M0(this, e).values.value : u1.call(this, e, Tl().remove(Ri).insert(t))
     }
 
-    function A1(e, t) {
-        RP(t) || G("Second argument to changes must be a changeset.");
-        const n = V0(this, e);
+    function u1(e, t) {
+        qD(t) || U("Second argument to changes must be a changeset.");
+        const n = M0(this, e);
         return n.modified = !0, this.pulse(n.input, t)
     }
 
-    function yse(e, t) {
-        return A1.call(this, e, zl().insert(t))
+    function Cse(e, t) {
+        return u1.call(this, e, Tl().insert(t))
     }
 
-    function vse(e, t) {
-        return A1.call(this, e, zl().remove(t))
+    function kse(e, t) {
+        return u1.call(this, e, Tl().remove(t))
     }
 
-    function sI(e) {
+    function yL(e) {
         var t = e.padding();
         return Math.max(0, e._viewWidth + t.left + t.right)
     }
 
-    function oI(e) {
+    function vL(e) {
         var t = e.padding();
         return Math.max(0, e._viewHeight + t.top + t.bottom)
     }
 
-    function T1(e) {
+    function c1(e) {
         var t = e.padding(),
             n = e._origin;
         return [t.left + n[0], t.top + n[1]]
     }
 
-    function bse(e) {
-        var t = T1(e),
-            n = sI(e),
-            i = oI(e);
+    function Ase(e) {
+        var t = c1(e),
+            n = yL(e),
+            i = vL(e);
         e._renderer.background(e.background()), e._renderer.resize(n, i, t), e._handler.origin(t), e._resizeListeners.forEach(r => {
             try {
                 r(n, i)
-            } catch (a) {
-                e.error(a)
+            } catch (s) {
+                e.error(s)
             }
         })
     }
 
-    function xse(e, t, n) {
+    function $se(e, t, n) {
         var i = e._renderer,
             r = i && i.canvas(),
-            a, s, o;
-        return r && (o = T1(e), s = t.changedTouches ? t.changedTouches[0] : t, a = x1(s, r), a[0] -= o[0], a[1] -= o[1]), t.dataflow = e, t.item = n, t.vega = _se(e, n, a), t
+            s, a, o;
+        return r && (o = c1(e), a = t.changedTouches ? t.changedTouches[0] : t, s = t1(a, r), s[0] -= o[0], s[1] -= o[1]), t.dataflow = e, t.item = n, t.vega = Tse(e, n, s), t
     }
 
-    function _se(e, t, n) {
+    function Tse(e, t, n) {
         const i = t ? t.mark.marktype === "group" ? t : t.mark.group : null;
 
-        function r(s) {
+        function r(a) {
             var o = i,
                 l;
-            if (s) {
+            if (a) {
                 for (l = t; l; l = l.mark.group)
-                    if (l.mark.name === s) {
+                    if (l.mark.name === a) {
                         o = l;
                         break
                     }
             }
             return o && o.mark && o.mark.interactive ? o : {}
         }
 
-        function a(s) {
-            if (!s) return n;
-            re(s) && (s = r(s));
+        function s(a) {
+            if (!a) return n;
+            re(a) && (a = r(a));
             const o = n.slice();
-            for (; s;) o[0] -= s.x || 0, o[1] -= s.y || 0, s = s.mark && s.mark.group;
+            for (; a;) o[0] -= a.x || 0, o[1] -= a.y || 0, a = a.mark && a.mark.group;
             return o
         }
         return {
-            view: Sn(e),
-            item: Sn(t || {}),
+            view: xn(e),
+            item: xn(t || {}),
             group: r,
-            xy: a,
-            x: s => a(s)[0],
-            y: s => a(s)[1]
+            xy: s,
+            x: a => s(a)[0],
+            y: a => s(a)[1]
         }
     }
-    const P3 = "view",
-        wse = "timer",
-        Sse = "window",
-        Ese = {
+    const VT = "view",
+        Mse = "timer",
+        Ose = "window",
+        Fse = {
             trap: !1
         };
 
-    function Ose(e) {
-        const t = ke({
+    function Rse(e) {
+        const t = Ae({
                 defaults: {}
             }, e),
             n = (i, r) => {
-                r.forEach(a => {
-                    q(i[a]) && (i[a] = br(i[a]))
+                r.forEach(s => {
+                    W(i[s]) && (i[s] = fr(i[s]))
                 })
             };
         return n(t.defaults, ["prevent", "allow"]), n(t, ["view", "window", "selector"]), t
     }
 
-    function lI(e, t, n, i) {
+    function bL(e, t, n, i) {
         e._eventListeners.push({
             type: n,
-            sources: ie(t),
+            sources: se(t),
             handler: i
         })
     }
 
-    function Cse(e, t) {
+    function Dse(e, t) {
         var n = e._eventConfig.defaults,
             i = n.prevent,
             r = n.allow;
         return i === !1 || r === !0 ? !1 : i === !0 || r === !1 ? !0 : i ? i[t] : r ? !r[t] : e.preventDefault()
     }
 
-    function zg(e, t, n) {
+    function Cg(e, t, n) {
         const i = e._eventConfig && e._eventConfig[t];
-        return i === !1 || se(i) && !i[n] ? (e.warn(`Blocked ${t} ${n} event listener.`), !1) : !0
+        return i === !1 || ae(i) && !i[n] ? (e.warn(`Blocked ${t} ${n} event listener.`), !1) : !0
     }
 
-    function kse(e, t, n) {
+    function Nse(e, t, n) {
         var i = this,
-            r = new e1(n),
-            a = function(u, c) {
+            r = new Nm(n),
+            s = function(u, c) {
                 i.runAsync(null, () => {
-                    e === P3 && Cse(i, t) && u.preventDefault(), r.receive(xse(i, u, c))
+                    e === VT && Dse(i, t) && u.preventDefault(), r.receive($se(i, u, c))
                 })
             },
-            s;
-        if (e === wse) zg(i, "timer", t) && i.timer(a, t);
-        else if (e === P3) zg(i, "view", t) && i.addEventListener(t, a, Ese);
-        else if (e === Sse ? zg(i, "window", t) && typeof window < "u" && (s = [window]) : typeof document < "u" && zg(i, "selector", t) && (s = Array.from(document.querySelectorAll(e))), !s) i.warn("Can not resolve event source: " + e);
+            a;
+        if (e === Mse) Cg(i, "timer", t) && i.timer(s, t);
+        else if (e === VT) Cg(i, "view", t) && i.addEventListener(t, s, Fse);
+        else if (e === Ose ? Cg(i, "window", t) && typeof window < "u" && (a = [window]) : typeof document < "u" && Cg(i, "selector", t) && (a = Array.from(document.querySelectorAll(e))), !a) i.warn("Can not resolve event source: " + e);
         else {
-            for (var o = 0, l = s.length; o < l; ++o) s[o].addEventListener(t, a);
-            lI(i, s, t, a)
+            for (var o = 0, l = a.length; o < l; ++o) a[o].addEventListener(t, s);
+            bL(i, a, t, s)
         }
         return r
     }
 
-    function N3(e) {
+    function KT(e) {
         return e.item
     }
 
-    function L3(e) {
+    function JT(e) {
         return e.item.mark.source
     }
 
-    function I3(e) {
+    function QT(e) {
         return function(t, n) {
             return n.vega.view().changeset().encode(n.item, e)
         }
     }
 
-    function Ase(e, t) {
-        return e = [e || "hover"], t = [t || "update", e[0]], this.on(this.events("view", "mouseover", N3), L3, I3(e)), this.on(this.events("view", "mouseout", N3), L3, I3(t)), this
+    function Pse(e, t) {
+        return e = [e || "hover"], t = [t || "update", e[0]], this.on(this.events("view", "mouseover", KT), JT, QT(e)), this.on(this.events("view", "mouseout", KT), JT, QT(t)), this
     }
 
-    function Tse() {
+    function Lse() {
         var e = this._tooltip,
             t = this._timers,
             n = this._eventListeners,
-            i, r, a;
+            i, r, s;
         for (i = t.length; --i >= 0;) t[i].stop();
         for (i = n.length; --i >= 0;)
-            for (a = n[i], r = a.sources.length; --r >= 0;) a.sources[r].removeEventListener(a.type, a.handler);
+            for (s = n[i], r = s.sources.length; --r >= 0;) s.sources[r].removeEventListener(s.type, s.handler);
         return e && e.call(this, this._handler, null, null, null), this
     }
 
-    function bi(e, t, n) {
+    function yi(e, t, n) {
         const i = document.createElement(e);
         for (const r in t) i.setAttribute(r, t[r]);
         return n != null && (i.textContent = n), i
     }
-    const $se = "vega-bind",
-        Mse = "vega-bind-name",
-        Fse = "vega-bind-radio";
+    const Ise = "vega-bind",
+        zse = "vega-bind-name",
+        Bse = "vega-bind-radio";
 
-    function Dse(e, t, n) {
+    function jse(e, t, n) {
         if (!t) return;
         const i = n.param;
         let r = n.state;
         return r || (r = n.state = {
             elements: null,
             active: !1,
             set: null,
-            update: s => {
-                s != e.signal(i.signal) && e.runAsync(null, () => {
-                    r.source = !0, e.signal(i.signal, s)
+            update: a => {
+                a != e.signal(i.signal) && e.runAsync(null, () => {
+                    r.source = !0, e.signal(i.signal, a)
                 })
             }
-        }, i.debounce && (r.update = Y_(i.debounce, r.update))), (i.input == null && i.element ? Rse : Nse)(r, t, i, e), r.active || (e.on(e._signals[i.signal], null, () => {
+        }, i.debounce && (r.update = h_(i.debounce, r.update))), (i.input == null && i.element ? Use : Wse)(r, t, i, e), r.active || (e.on(e._signals[i.signal], null, () => {
             r.source ? r.source = !1 : r.set(e.signal(i.signal))
         }), r.active = !0), r
     }
 
-    function Rse(e, t, n, i) {
+    function Use(e, t, n, i) {
         const r = n.event || "input",
-            a = () => e.update(t.value);
-        i.signal(n.signal, t.value), t.addEventListener(r, a), lI(i, t, r, a), e.set = s => {
-            t.value = s, t.dispatchEvent(Pse(r))
+            s = () => e.update(t.value);
+        i.signal(n.signal, t.value), t.addEventListener(r, s), bL(i, t, r, s), e.set = a => {
+            t.value = a, t.dispatchEvent(Gse(r))
         }
     }
 
-    function Pse(e) {
+    function Gse(e) {
         return typeof Event < "u" ? new Event(e) : {
             type: e
         }
     }
 
-    function Nse(e, t, n, i) {
+    function Wse(e, t, n, i) {
         const r = i.signal(n.signal),
-            a = bi("div", {
-                class: $se
+            s = yi("div", {
+                class: Ise
             }),
-            s = n.input === "radio" ? a : a.appendChild(bi("label"));
-        s.appendChild(bi("span", {
-            class: Mse
-        }, n.name || n.signal)), t.appendChild(a);
-        let o = Lse;
+            a = n.input === "radio" ? s : s.appendChild(yi("label"));
+        a.appendChild(yi("span", {
+            class: zse
+        }, n.name || n.signal)), t.appendChild(s);
+        let o = qse;
         switch (n.input) {
             case "checkbox":
-                o = Ise;
+                o = Hse;
                 break;
             case "select":
-                o = jse;
+                o = Yse;
                 break;
             case "radio":
-                o = zse;
+                o = Xse;
                 break;
             case "range":
-                o = Bse;
+                o = Vse;
                 break
         }
-        o(e, s, n, r)
+        o(e, a, n, r)
     }
 
-    function Lse(e, t, n, i) {
-        const r = bi("input");
-        for (const a in n) a !== "signal" && a !== "element" && r.setAttribute(a === "input" ? "type" : a, n[a]);
-        r.setAttribute("name", n.signal), r.value = i, t.appendChild(r), r.addEventListener("input", () => e.update(r.value)), e.elements = [r], e.set = a => r.value = a
+    function qse(e, t, n, i) {
+        const r = yi("input");
+        for (const s in n) s !== "signal" && s !== "element" && r.setAttribute(s === "input" ? "type" : s, n[s]);
+        r.setAttribute("name", n.signal), r.value = i, t.appendChild(r), r.addEventListener("input", () => e.update(r.value)), e.elements = [r], e.set = s => r.value = s
     }
 
-    function Ise(e, t, n, i) {
+    function Hse(e, t, n, i) {
         const r = {
             type: "checkbox",
             name: n.signal
         };
         i && (r.checked = !0);
-        const a = bi("input", r);
-        t.appendChild(a), a.addEventListener("change", () => e.update(a.checked)), e.elements = [a], e.set = s => a.checked = !!s || null
+        const s = yi("input", r);
+        t.appendChild(s), s.addEventListener("change", () => e.update(s.checked)), e.elements = [s], e.set = a => s.checked = !!a || null
     }
 
-    function jse(e, t, n, i) {
-        const r = bi("select", {
+    function Yse(e, t, n, i) {
+        const r = yi("select", {
                 name: n.signal
             }),
-            a = n.labels || [];
-        n.options.forEach((s, o) => {
+            s = n.labels || [];
+        n.options.forEach((a, o) => {
             const l = {
-                value: s
+                value: a
             };
-            K0(s, i) && (l.selected = !0), r.appendChild(bi("option", l, (a[o] || s) + ""))
+            O0(a, i) && (l.selected = !0), r.appendChild(yi("option", l, (s[o] || a) + ""))
         }), t.appendChild(r), r.addEventListener("change", () => {
             e.update(n.options[r.selectedIndex])
-        }), e.elements = [r], e.set = s => {
+        }), e.elements = [r], e.set = a => {
             for (let o = 0, l = n.options.length; o < l; ++o)
-                if (K0(n.options[o], s)) {
+                if (O0(n.options[o], a)) {
                     r.selectedIndex = o;
                     return
                 }
         }
     }
 
-    function zse(e, t, n, i) {
-        const r = bi("span", {
-                class: Fse
+    function Xse(e, t, n, i) {
+        const r = yi("span", {
+                class: Bse
             }),
-            a = n.labels || [];
-        t.appendChild(r), e.elements = n.options.map((s, o) => {
+            s = n.labels || [];
+        t.appendChild(r), e.elements = n.options.map((a, o) => {
             const l = {
                 type: "radio",
                 name: n.signal,
-                value: s
+                value: a
             };
-            K0(s, i) && (l.checked = !0);
-            const u = bi("input", l);
-            u.addEventListener("change", () => e.update(s));
-            const c = bi("label", {}, (a[o] || s) + "");
+            O0(a, i) && (l.checked = !0);
+            const u = yi("input", l);
+            u.addEventListener("change", () => e.update(a));
+            const c = yi("label", {}, (s[o] || a) + "");
             return c.prepend(u), r.appendChild(c), u
-        }), e.set = s => {
+        }), e.set = a => {
             const o = e.elements,
                 l = o.length;
-            for (let u = 0; u < l; ++u) K0(o[u].value, s) && (o[u].checked = !0)
+            for (let u = 0; u < l; ++u) O0(o[u].value, a) && (o[u].checked = !0)
         }
     }
 
-    function Bse(e, t, n, i) {
+    function Vse(e, t, n, i) {
         i = i !== void 0 ? i : (+n.max + +n.min) / 2;
         const r = n.max != null ? n.max : Math.max(100, +i) || 100,
-            a = n.min || Math.min(0, r, +i) || 0,
-            s = n.step || Bs(a, r, 100),
-            o = bi("input", {
+            s = n.min || Math.min(0, r, +i) || 0,
+            a = n.step || Oa(s, r, 100),
+            o = yi("input", {
                 type: "range",
                 name: n.signal,
-                min: a,
+                min: s,
                 max: r,
-                step: s
+                step: a
             });
         o.value = i;
-        const l = bi("span", {}, +i);
+        const l = yi("span", {}, +i);
         t.appendChild(o), t.appendChild(l);
         const u = () => {
             l.textContent = o.value, e.update(+o.value)
         };
         o.addEventListener("input", u), o.addEventListener("change", u), e.elements = [o], e.set = c => {
             o.value = c, l.textContent = c
         }
     }
 
-    function K0(e, t) {
+    function O0(e, t) {
         return e === t || e + "" == t + ""
     }
 
-    function uI(e, t, n, i, r, a) {
-        return t = t || new i(e.loader()), t.initialize(n, sI(e), oI(e), T1(e), r, a).background(e.background())
+    function xL(e, t, n, i, r, s) {
+        return t = t || new i(e.loader()), t.initialize(n, yL(e), vL(e), c1(e), r, s).background(e.background())
     }
 
-    function ME(e, t) {
+    function JS(e, t) {
         return t ? function() {
             try {
                 t.apply(this, arguments)
             } catch (n) {
                 e.error(n)
             }
         } : null
     }
 
-    function Gse(e, t, n, i) {
-        const r = new i(e.loader(), ME(e, e.tooltip())).scene(e.scenegraph().root).initialize(n, T1(e), e);
-        return t && t.handlers().forEach(a => {
-            r.on(a.type, a.handler)
+    function Kse(e, t, n, i) {
+        const r = new i(e.loader(), JS(e, e.tooltip())).scene(e.scenegraph().root).initialize(n, c1(e), e);
+        return t && t.handlers().forEach(s => {
+            r.on(s.type, s.handler)
         }), r
     }
 
-    function Use(e, t) {
+    function Jse(e, t) {
         const n = this,
             i = n._renderType,
             r = n._eventConfig.bind,
-            a = _1(i);
-        e = n._el = e ? Uv(n, e, !0) : null, dse(n), a || n.error("Unrecognized renderer type: " + i);
-        const s = a.handler || Dd,
-            o = e ? a.renderer : a.headless;
-        return n._renderer = o ? uI(n, n._renderer, e, o) : null, n._handler = Gse(n, n._handler, e, s), n._redraw = !0, e && r !== "none" && (t = t ? n._elBind = Uv(n, t, !0) : e.appendChild(bi("form", {
+            s = n1(i);
+        e = n._el = e ? _v(n, e, !0) : null, _se(n), s || n.error("Unrecognized renderer type: " + i);
+        const a = s.handler || _d,
+            o = e ? s.renderer : s.headless;
+        return n._renderer = o ? xL(n, n._renderer, e, o) : null, n._handler = Kse(n, n._handler, e, a), n._redraw = !0, e && r !== "none" && (t = t ? n._elBind = _v(n, t, !0) : e.appendChild(yi("form", {
             class: "vega-bindings"
         })), n._bind.forEach(l => {
-            l.param.element && r !== "container" && (l.element = Uv(n, l.param.element, !!l.param.input))
+            l.param.element && r !== "container" && (l.element = _v(n, l.param.element, !!l.param.input))
         }), n._bind.forEach(l => {
-            Dse(n, l.element || t, l)
+            jse(n, l.element || t, l)
         })), n
     }
 
-    function Uv(e, t, n) {
+    function _v(e, t, n) {
         if (typeof t == "string")
             if (typeof document < "u") {
                 if (t = document.querySelector(t), !t) return e.error("Signal bind element not found: " + t), null
             } else return e.error("DOM document instance not found."), null;
         if (t && n) try {
             t.textContent = ""
         } catch (i) {
             t = null, e.error(i)
         }
         return t
     }
-    const bf = e => +e || 0,
-        qse = e => ({
+    const af = e => +e || 0,
+        Qse = e => ({
             top: e,
             bottom: e,
             left: e,
             right: e
         });
 
-    function j3(e) {
-        return se(e) ? {
-            top: bf(e.top),
-            bottom: bf(e.bottom),
-            left: bf(e.left),
-            right: bf(e.right)
-        } : qse(bf(e))
-    }
-    async function FE(e, t, n, i) {
-        const r = _1(t),
-            a = r && r.headless;
-        return a || G("Unrecognized renderer type: " + t), await e.runAsync(), uI(e, null, null, a, n, i).renderAsync(e._scenegraph.root)
-    }
-    async function Wse(e, t) {
-        e !== ks.Canvas && e !== ks.SVG && e !== ks.PNG && G("Unrecognized image type: " + e);
-        const n = await FE(this, e, t);
-        return e === ks.SVG ? Hse(n.svg(), "image/svg+xml") : n.canvas().toDataURL("image/png")
+    function ZT(e) {
+        return ae(e) ? {
+            top: af(e.top),
+            bottom: af(e.bottom),
+            left: af(e.left),
+            right: af(e.right)
+        } : Qse(af(e))
+    }
+    async function QS(e, t, n, i) {
+        const r = n1(t),
+            s = r && r.headless;
+        return s || U("Unrecognized renderer type: " + t), await e.runAsync(), xL(e, null, null, s, n, i).renderAsync(e._scenegraph.root)
+    }
+    async function Zse(e, t) {
+        e !== ya.Canvas && e !== ya.SVG && e !== ya.PNG && U("Unrecognized image type: " + e);
+        const n = await QS(this, e, t);
+        return e === ya.SVG ? eae(n.svg(), "image/svg+xml") : n.canvas().toDataURL("image/png")
     }
 
-    function Hse(e, t) {
+    function eae(e, t) {
         const n = new Blob([e], {
             type: t
         });
         return window.URL.createObjectURL(n)
     }
-    async function Yse(e, t) {
-        return (await FE(this, ks.Canvas, e, t)).canvas()
+    async function tae(e, t) {
+        return (await QS(this, ya.Canvas, e, t)).canvas()
     }
-    async function Xse(e) {
-        return (await FE(this, ks.SVG, e)).svg()
+    async function nae(e) {
+        return (await QS(this, ya.SVG, e)).svg()
     }
 
-    function Vse(e, t, n) {
-        return iI(e, Zu, Hh, n).parse(t)
+    function iae(e, t, n) {
+        return gL(e, Uu, Dh, n).parse(t)
     }
 
-    function Kse(e) {
+    function rae(e) {
         var t = this._runtime.scales;
-        return pe(t, e) || G("Unrecognized scale or projection: " + e), t[e].value
+        return me(t, e) || U("Unrecognized scale or projection: " + e), t[e].value
     }
-    var cI = "width",
-        fI = "height",
-        DE = "padding",
-        z3 = {
+    var _L = "width",
+        wL = "height",
+        ZS = "padding",
+        e5 = {
             skip: !0
         };
 
-    function hI(e, t) {
+    function SL(e, t) {
         var n = e.autosize(),
             i = e.padding();
-        return t - (n && n.contains === DE ? i.left + i.right : 0)
+        return t - (n && n.contains === ZS ? i.left + i.right : 0)
     }
 
-    function dI(e, t) {
+    function EL(e, t) {
         var n = e.autosize(),
             i = e.padding();
-        return t - (n && n.contains === DE ? i.top + i.bottom : 0)
+        return t - (n && n.contains === ZS ? i.top + i.bottom : 0)
     }
 
-    function Jse(e) {
+    function sae(e) {
         var t = e._signals,
-            n = t[cI],
-            i = t[fI],
-            r = t[DE];
+            n = t[_L],
+            i = t[wL],
+            r = t[ZS];
 
-        function a() {
+        function s() {
             e._autosize = e._resize = 1
         }
         e._resizeWidth = e.add(null, o => {
-            e._width = o.size, e._viewWidth = hI(e, o.size), a()
+            e._width = o.size, e._viewWidth = SL(e, o.size), s()
         }, {
             size: n
         }), e._resizeHeight = e.add(null, o => {
-            e._height = o.size, e._viewHeight = dI(e, o.size), a()
+            e._height = o.size, e._viewHeight = EL(e, o.size), s()
         }, {
             size: i
         });
-        const s = e.add(null, a, {
+        const a = e.add(null, s, {
             pad: r
         });
-        e._resizeWidth.rank = n.rank + 1, e._resizeHeight.rank = i.rank + 1, s.rank = r.rank + 1
+        e._resizeWidth.rank = n.rank + 1, e._resizeHeight.rank = i.rank + 1, a.rank = r.rank + 1
     }
 
-    function Qse(e, t, n, i, r, a) {
-        this.runAfter(s => {
+    function aae(e, t, n, i, r, s) {
+        this.runAfter(a => {
             let o = 0;
-            s._autosize = 0, s.width() !== n && (o = 1, s.signal(cI, n, z3), s._resizeWidth.skip(!0)), s.height() !== i && (o = 1, s.signal(fI, i, z3), s._resizeHeight.skip(!0)), s._viewWidth !== e && (s._resize = 1, s._viewWidth = e), s._viewHeight !== t && (s._resize = 1, s._viewHeight = t), (s._origin[0] !== r[0] || s._origin[1] !== r[1]) && (s._resize = 1, s._origin = r), o && s.run("enter"), a && s.runAfter(l => l.resize())
+            a._autosize = 0, a.width() !== n && (o = 1, a.signal(_L, n, e5), a._resizeWidth.skip(!0)), a.height() !== i && (o = 1, a.signal(wL, i, e5), a._resizeHeight.skip(!0)), a._viewWidth !== e && (a._resize = 1, a._viewWidth = e), a._viewHeight !== t && (a._resize = 1, a._viewHeight = t), (a._origin[0] !== r[0] || a._origin[1] !== r[1]) && (a._resize = 1, a._origin = r), o && a.run("enter"), s && a.runAfter(l => l.resize())
         }, !1, 1)
     }
 
-    function Zse(e) {
+    function oae(e) {
         return this._runtime.getState(e || {
-            data: eoe,
-            signals: toe,
+            data: lae,
+            signals: uae,
             recurse: !0
         })
     }
 
-    function eoe(e, t) {
-        return t.modified && q(t.input.value) && e.indexOf("_:vega:_")
+    function lae(e, t) {
+        return t.modified && W(t.input.value) && e.indexOf("_:vega:_")
     }
 
-    function toe(e, t) {
-        return !(e === "parent" || t instanceof Zu.proxy)
+    function uae(e, t) {
+        return !(e === "parent" || t instanceof Uu.proxy)
     }
 
-    function noe(e) {
+    function cae(e) {
         return this.runAsync(null, t => {
             t._trigger = !1, t._runtime.setState(e)
         }, t => {
             t._trigger = !0
         }), this
     }
 
-    function ioe(e, t) {
+    function fae(e, t) {
         function n(i) {
             e({
                 timestamp: Date.now(),
                 elapsed: i
             })
         }
-        this._timers.push($G(n, t))
+        this._timers.push(Lj(n, t))
     }
 
-    function roe(e, t, n, i) {
+    function hae(e, t, n, i) {
         const r = e.element();
-        r && r.setAttribute("title", aoe(i))
+        r && r.setAttribute("title", dae(i))
     }
 
-    function aoe(e) {
-        return e == null ? "" : q(e) ? gI(e) : se(e) && !Ds(e) ? soe(e) : e + ""
+    function dae(e) {
+        return e == null ? "" : W(e) ? CL(e) : ae(e) && !Ea(e) ? gae(e) : e + ""
     }
 
-    function soe(e) {
+    function gae(e) {
         return Object.keys(e).map(t => {
             const n = e[t];
-            return t + ": " + (q(n) ? gI(n) : pI(n))
+            return t + ": " + (W(n) ? CL(n) : kL(n))
         }).join(`
 `)
     }
 
-    function gI(e) {
-        return "[" + e.map(pI).join(", ") + "]"
+    function CL(e) {
+        return "[" + e.map(kL).join(", ") + "]"
     }
 
-    function pI(e) {
-        return q(e) ? "[…]" : se(e) && !Ds(e) ? "{…}" : e
+    function kL(e) {
+        return W(e) ? "[…]" : ae(e) && !Ea(e) ? "{…}" : e
     }
 
-    function mI(e, t) {
+    function AL(e, t) {
         const n = this;
-        if (t = t || {}, Du.call(n), t.loader && n.loader(t.loader), t.logger && n.logger(t.logger), t.logLevel != null && n.logLevel(t.logLevel), t.locale || e.locale) {
-            const a = ke({}, e.locale, t.locale);
-            n.locale(EP(a.number, a.time))
+        if (t = t || {}, wu.call(n), t.loader && n.loader(t.loader), t.logger && n.logger(t.logger), t.logLevel != null && n.logLevel(t.logLevel), t.locale || e.locale) {
+            const s = Ae({}, e.locale, t.locale);
+            n.locale(ND(s.number, s.time))
         }
-        n._el = null, n._elBind = null, n._renderType = t.renderer || ks.Canvas, n._scenegraph = new OS;
+        n._el = null, n._elBind = null, n._renderType = t.renderer || ya.Canvas, n._scenegraph = new qw;
         const i = n._scenegraph.root;
-        n._renderer = null, n._tooltip = t.tooltip || roe, n._redraw = !0, n._handler = new Dd().scene(i), n._globalCursor = !1, n._preventDefault = !1, n._timers = [], n._eventListeners = [], n._resizeListeners = [], n._eventConfig = Ose(e.eventConfig), n.globalCursor(n._eventConfig.globalCursor);
-        const r = Vse(n, e, t.expr);
-        n._runtime = r, n._signals = r.signals, n._bind = (e.bindings || []).map(a => ({
+        n._renderer = null, n._tooltip = t.tooltip || hae, n._redraw = !0, n._handler = new _d().scene(i), n._globalCursor = !1, n._preventDefault = !1, n._timers = [], n._eventListeners = [], n._resizeListeners = [], n._eventConfig = Rse(e.eventConfig), n.globalCursor(n._eventConfig.globalCursor);
+        const r = iae(n, e, t.expr);
+        n._runtime = r, n._signals = r.signals, n._bind = (e.bindings || []).map(s => ({
             state: null,
-            param: ke({}, a)
-        })), r.root && r.root.set(i), i.source = r.data.root.input, n.pulse(r.data.root.input, n.changeset().insert(i.items)), n._width = n.width(), n._height = n.height(), n._viewWidth = hI(n, n._width), n._viewHeight = dI(n, n._height), n._origin = [0, 0], n._resize = 0, n._autosize = 1, Jse(n), gse(n), pse(n), n.description(e.description), t.hover && n.hover(), t.container && n.initialize(t.container, t.bind)
+            param: Ae({}, s)
+        })), r.root && r.root.set(i), i.source = r.data.root.input, n.pulse(r.data.root.input, n.changeset().insert(i.items)), n._width = n.width(), n._height = n.height(), n._viewWidth = SL(n, n._width), n._viewHeight = EL(n, n._height), n._origin = [0, 0], n._resize = 0, n._autosize = 1, sae(n), wse(n), Sse(n), n.description(e.description), t.hover && n.hover(), t.container && n.initialize(t.container, t.bind)
     }
 
-    function Bg(e, t) {
-        return pe(e._signals, t) ? e._signals[t] : G("Unrecognized signal name: " + Z(t))
+    function kg(e, t) {
+        return me(e._signals, t) ? e._signals[t] : U("Unrecognized signal name: " + Z(t))
     }
 
-    function yI(e, t) {
+    function $L(e, t) {
         const n = (e._targets || []).filter(i => i._update && i._update.handler === t);
         return n.length ? n[0] : null
     }
 
-    function B3(e, t, n, i) {
-        let r = yI(n, i);
-        return r || (r = ME(e, () => i(t, n.value)), r.handler = i, e.on(n, null, r)), e
+    function t5(e, t, n, i) {
+        let r = $L(n, i);
+        return r || (r = JS(e, () => i(t, n.value)), r.handler = i, e.on(n, null, r)), e
     }
 
-    function G3(e, t, n) {
-        const i = yI(t, n);
+    function n5(e, t, n) {
+        const i = $L(t, n);
         return i && t._targets.remove(i), e
     }
-    Q(mI, Du, {
+    ee(AL, wu, {
         async evaluate(e, t, n) {
-            if (await Du.prototype.evaluate.call(this, e, t), this._redraw || this._resize) try {
-                this._renderer && (this._resize && (this._resize = 0, bse(this)), await this._renderer.renderAsync(this._scenegraph.root)), this._redraw = !1
+            if (await wu.prototype.evaluate.call(this, e, t), this._redraw || this._resize) try {
+                this._renderer && (this._resize && (this._resize = 0, Ase(this)), await this._renderer.renderAsync(this._scenegraph.root)), this._redraw = !1
             } catch (i) {
                 this.error(i)
             }
-            return n && gp(this, n), this
+            return n && Kg(this, n), this
         },
         dirty(e) {
             this._redraw = !0, this._renderer && this._renderer.dirty(e)
         },
         description(e) {
             if (arguments.length) {
                 const t = e != null ? e + "" : null;
-                return t !== this._desc && aI(this._el, this._desc = t), this
+                return t !== this._desc && mL(this._el, this._desc = t), this
             }
             return this._desc
         },
         container() {
             return this._el
         },
         scenegraph() {
             return this._scenegraph
         },
         origin() {
             return this._origin.slice()
         },
         signal(e, t, n) {
-            const i = Bg(this, e);
+            const i = kg(this, e);
             return arguments.length === 1 ? i.value : this.update(i, t, n)
         },
         width(e) {
             return arguments.length ? this.signal("width", e) : this.signal("width")
         },
         height(e) {
             return arguments.length ? this.signal("height", e) : this.signal("height")
         },
         padding(e) {
-            return arguments.length ? this.signal("padding", j3(e)) : j3(this.signal("padding"))
+            return arguments.length ? this.signal("padding", ZT(e)) : ZT(this.signal("padding"))
         },
         autosize(e) {
             return arguments.length ? this.signal("autosize", e) : this.signal("autosize")
         },
         background(e) {
             return arguments.length ? this.signal("background", e) : this.signal("background")
         },
         renderer(e) {
-            return arguments.length ? (_1(e) || G("Unrecognized renderer type: " + e), e !== this._renderType && (this._renderType = e, this._resetRenderer()), this) : this._renderType
+            return arguments.length ? (n1(e) || U("Unrecognized renderer type: " + e), e !== this._renderType && (this._renderType = e, this._resetRenderer()), this) : this._renderType
         },
         tooltip(e) {
             return arguments.length ? (e !== this._tooltip && (this._tooltip = e, this._resetRenderer()), this) : this._tooltip
         },
         loader(e) {
-            return arguments.length ? (e !== this._loader && (Du.prototype.loader.call(this, e), this._resetRenderer()), this) : this._loader
+            return arguments.length ? (e !== this._loader && (wu.prototype.loader.call(this, e), this._resetRenderer()), this) : this._loader
         },
         resize() {
-            return this._autosize = 1, this.touch(Bg(this, "autosize"))
+            return this._autosize = 1, this.touch(kg(this, "autosize"))
         },
         _resetRenderer() {
             this._renderer && (this._renderer = null, this.initialize(this._el, this._elBind))
         },
-        _resizeView: Qse,
+        _resizeView: aae,
         addEventListener(e, t, n) {
             let i = t;
-            return n && n.trap === !1 || (i = ME(this, t), i.raw = t), this._handler.on(e, i), this
+            return n && n.trap === !1 || (i = JS(this, t), i.raw = t), this._handler.on(e, i), this
         },
         removeEventListener(e, t) {
-            for (var n = this._handler.handlers(e), i = n.length, r, a; --i >= 0;)
-                if (a = n[i].type, r = n[i].handler, e === a && (t === r || t === r.raw)) {
-                    this._handler.off(a, r);
+            for (var n = this._handler.handlers(e), i = n.length, r, s; --i >= 0;)
+                if (s = n[i].type, r = n[i].handler, e === s && (t === r || t === r.raw)) {
+                    this._handler.off(s, r);
                     break
                 } return this
         },
         addResizeListener(e) {
             const t = this._resizeListeners;
             return t.indexOf(e) < 0 && t.push(e), this
         },
         removeResizeListener(e) {
             var t = this._resizeListeners,
                 n = t.indexOf(e);
             return n >= 0 && t.splice(n, 1), this
         },
         addSignalListener(e, t) {
-            return B3(this, e, Bg(this, e), t)
+            return t5(this, e, kg(this, e), t)
         },
         removeSignalListener(e, t) {
-            return G3(this, Bg(this, e), t)
+            return n5(this, kg(this, e), t)
         },
         addDataListener(e, t) {
-            return B3(this, e, V0(this, e).values, t)
+            return t5(this, e, M0(this, e).values, t)
         },
         removeDataListener(e, t) {
-            return G3(this, V0(this, e).values, t)
+            return n5(this, M0(this, e).values, t)
         },
         globalCursor(e) {
             if (arguments.length) {
                 if (this._globalCursor !== !!e) {
-                    const t = sx(this, null);
-                    this._globalCursor = !!e, t && sx(this, t)
+                    const t = D2(this, null);
+                    this._globalCursor = !!e, t && D2(this, t)
                 }
                 return this
             } else return this._globalCursor
         },
         preventDefault(e) {
             return arguments.length ? (this._preventDefault = e, this) : this._preventDefault
         },
-        timer: ioe,
-        events: kse,
-        finalize: Tse,
-        hover: Ase,
-        data: mse,
-        change: A1,
-        insert: yse,
-        remove: vse,
-        scale: Kse,
-        initialize: Use,
-        toImageURL: Wse,
-        toCanvas: Yse,
-        toSVG: Xse,
-        getState: Zse,
-        setState: noe
-    });
-    const ooe = "view",
-        J0 = "[",
-        Q0 = "]",
-        vI = "{",
-        bI = "}",
-        loe = ":",
-        xI = ",",
-        uoe = "@",
-        coe = ">",
-        foe = /[[\]{}]/,
-        hoe = {
+        timer: fae,
+        events: Nse,
+        finalize: Lse,
+        hover: Pse,
+        data: Ese,
+        change: u1,
+        insert: Cse,
+        remove: kse,
+        scale: rae,
+        initialize: Jse,
+        toImageURL: Zse,
+        toCanvas: tae,
+        toSVG: nae,
+        getState: oae,
+        setState: cae
+    });
+    const pae = "view",
+        F0 = "[",
+        R0 = "]",
+        TL = "{",
+        ML = "}",
+        mae = ":",
+        OL = ",",
+        yae = "@",
+        vae = ">",
+        bae = /[[\]{}]/,
+        xae = {
             "*": 1,
             arc: 1,
             area: 1,
             group: 1,
             image: 1,
             line: 1,
             path: 1,
             rect: 1,
             rule: 1,
             shape: 1,
             symbol: 1,
             text: 1,
             trail: 1
         };
-    let _I, wI;
+    let FL, RL;
 
-    function ho(e, t, n) {
-        return _I = t || ooe, wI = n || hoe, SI(e.trim()).map(ox)
+    function to(e, t, n) {
+        return FL = t || pae, RL = n || xae, DL(e.trim()).map(N2)
     }
 
-    function doe(e) {
-        return wI[e]
+    function _ae(e) {
+        return RL[e]
     }
 
-    function vh(e, t, n, i, r) {
-        const a = e.length;
-        let s = 0,
+    function ah(e, t, n, i, r) {
+        const s = e.length;
+        let a = 0,
             o;
-        for (; t < a; ++t) {
-            if (o = e[t], !s && o === n) return t;
-            r && r.indexOf(o) >= 0 ? --s : i && i.indexOf(o) >= 0 && ++s
+        for (; t < s; ++t) {
+            if (o = e[t], !a && o === n) return t;
+            r && r.indexOf(o) >= 0 ? --a : i && i.indexOf(o) >= 0 && ++a
         }
         return t
     }
 
-    function SI(e) {
+    function DL(e) {
         const t = [],
             n = e.length;
         let i = 0,
             r = 0;
-        for (; r < n;) r = vh(e, r, xI, J0 + vI, Q0 + bI), t.push(e.substring(i, r).trim()), i = ++r;
+        for (; r < n;) r = ah(e, r, OL, F0 + TL, R0 + ML), t.push(e.substring(i, r).trim()), i = ++r;
         if (t.length === 0) throw "Empty event selector: " + e;
         return t
     }
 
-    function ox(e) {
-        return e[0] === "[" ? goe(e) : poe(e)
+    function N2(e) {
+        return e[0] === "[" ? wae(e) : Sae(e)
     }
 
-    function goe(e) {
+    function wae(e) {
         const t = e.length;
         let n = 1,
             i;
-        if (n = vh(e, n, Q0, J0, Q0), n === t) throw "Empty between selector: " + e;
-        if (i = SI(e.substring(1, n)), i.length !== 2) throw "Between selector must have two elements: " + e;
-        if (e = e.slice(n + 1).trim(), e[0] !== coe) throw "Expected '>' after between selector: " + e;
-        i = i.map(ox);
-        const r = ox(e.slice(1).trim());
+        if (n = ah(e, n, R0, F0, R0), n === t) throw "Empty between selector: " + e;
+        if (i = DL(e.substring(1, n)), i.length !== 2) throw "Between selector must have two elements: " + e;
+        if (e = e.slice(n + 1).trim(), e[0] !== vae) throw "Expected '>' after between selector: " + e;
+        i = i.map(N2);
+        const r = N2(e.slice(1).trim());
         return r.between ? {
             between: i,
             stream: r
         } : (r.between = i, r)
     }
 
-    function poe(e) {
+    function Sae(e) {
         const t = {
-                source: _I
+                source: FL
             },
             n = [];
         let i = [0, 0],
             r = 0,
-            a = 0,
-            s = e.length,
+            s = 0,
+            a = e.length,
             o = 0,
             l, u;
-        if (e[s - 1] === bI) {
-            if (o = e.lastIndexOf(vI), o >= 0) {
+        if (e[a - 1] === ML) {
+            if (o = e.lastIndexOf(TL), o >= 0) {
                 try {
-                    i = moe(e.substring(o + 1, s - 1))
+                    i = Eae(e.substring(o + 1, a - 1))
                 } catch {
                     throw "Invalid throttle specification: " + e
                 }
-                e = e.slice(0, o).trim(), s = e.length
+                e = e.slice(0, o).trim(), a = e.length
             } else throw "Unmatched right brace: " + e;
             o = 0
         }
-        if (!s) throw e;
-        if (e[0] === uoe && (r = ++o), l = vh(e, o, loe), l < s && (n.push(e.substring(a, l).trim()), a = o = ++l), o = vh(e, o, J0), o === s) n.push(e.substring(a, s).trim());
-        else if (n.push(e.substring(a, o).trim()), u = [], a = ++o, a === s) throw "Unmatched left bracket: " + e;
-        for (; o < s;) {
-            if (o = vh(e, o, Q0), o === s) throw "Unmatched left bracket: " + e;
-            if (u.push(e.substring(a, o).trim()), o < s - 1 && e[++o] !== J0) throw "Expected left bracket: " + e;
-            a = ++o
+        if (!a) throw e;
+        if (e[0] === yae && (r = ++o), l = ah(e, o, mae), l < a && (n.push(e.substring(s, l).trim()), s = o = ++l), o = ah(e, o, F0), o === a) n.push(e.substring(s, a).trim());
+        else if (n.push(e.substring(s, o).trim()), u = [], s = ++o, s === a) throw "Unmatched left bracket: " + e;
+        for (; o < a;) {
+            if (o = ah(e, o, R0), o === a) throw "Unmatched left bracket: " + e;
+            if (u.push(e.substring(s, o).trim()), o < a - 1 && e[++o] !== F0) throw "Expected left bracket: " + e;
+            s = ++o
         }
-        if (!(s = n.length) || foe.test(n[s - 1])) throw "Invalid event selector: " + e;
-        return s > 1 ? (t.type = n[1], r ? t.markname = n[0].slice(1) : doe(n[0]) ? t.marktype = n[0] : t.source = n[0]) : t.type = n[0], t.type.slice(-1) === "!" && (t.consume = !0, t.type = t.type.slice(0, -1)), u != null && (t.filter = u), i[0] && (t.throttle = i[0]), i[1] && (t.debounce = i[1]), t
+        if (!(a = n.length) || bae.test(n[a - 1])) throw "Invalid event selector: " + e;
+        return a > 1 ? (t.type = n[1], r ? t.markname = n[0].slice(1) : _ae(n[0]) ? t.marktype = n[0] : t.source = n[0]) : t.type = n[0], t.type.slice(-1) === "!" && (t.consume = !0, t.type = t.type.slice(0, -1)), u != null && (t.filter = u), i[0] && (t.throttle = i[0]), i[1] && (t.debounce = i[1]), t
     }
 
-    function moe(e) {
-        const t = e.split(xI);
+    function Eae(e) {
+        const t = e.split(OL);
         if (!e.length || t.length > 2) throw e;
         return t.map(n => {
             const i = +n;
             if (i !== i) throw e;
             return i
         })
     }
 
-    function yoe(e) {
-        return se(e) ? e : {
+    function Cae(e) {
+        return ae(e) ? e : {
             type: e || "pad"
         }
     }
-    const xf = e => +e || 0,
-        voe = e => ({
-            top: e,
-            bottom: e,
-            left: e,
-            right: e
-        });
-
-    function boe(e) {
-        return se(e) ? e.signal ? e : {
-            top: xf(e.top),
-            bottom: xf(e.bottom),
-            left: xf(e.left),
-            right: xf(e.right)
-        } : voe(xf(e))
+    const of = e => +e || 0, kae = e => ({
+        top: e,
+        bottom: e,
+        left: e,
+        right: e
+    });
+
+    function Aae(e) {
+        return ae(e) ? e.signal ? e : {
+            top: of(e.top),
+            bottom: of(e.bottom),
+            left: of(e.left),
+            right: of(e.right)
+        } : kae(of(e))
     }
-    const Wt = e => se(e) && !q(e) ? ke({}, e) : {
+    const jt = e => ae(e) && !W(e) ? Ae({}, e) : {
         value: e
     };
 
-    function U3(e, t, n, i) {
-        return n != null ? (se(n) && !q(n) || q(n) && n.length && se(n[0]) ? e.update[t] = n : e[i || "enter"][t] = {
+    function i5(e, t, n, i) {
+        return n != null ? (ae(n) && !W(n) || W(n) && n.length && ae(n[0]) ? e.update[t] = n : e[i || "enter"][t] = {
             value: n
         }, 1) : 0
     }
 
-    function nn(e, t, n) {
-        for (const i in t) U3(e, i, t[i]);
-        for (const i in n) U3(e, i, n[i], "update")
+    function Zt(e, t, n) {
+        for (const i in t) i5(e, i, t[i]);
+        for (const i in n) i5(e, i, n[i], "update")
     }
 
-    function jc(e, t, n) {
-        for (const i in t) n && pe(n, i) || (e[i] = ke(e[i] || {}, t[i]));
+    function Ac(e, t, n) {
+        for (const i in t) n && me(n, i) || (e[i] = Ae(e[i] || {}, t[i]));
         return e
     }
 
-    function vu(e, t) {
+    function ou(e, t) {
         return t && (t.enter && t.enter[e] || t.update && t.update[e])
     }
-    const RE = "mark",
-        PE = "frame",
-        NE = "scope",
-        xoe = "axis",
-        _oe = "axis-domain",
-        woe = "axis-grid",
-        Soe = "axis-label",
-        Eoe = "axis-tick",
-        Ooe = "axis-title",
-        Coe = "legend",
-        koe = "legend-band",
-        Aoe = "legend-entry",
-        Toe = "legend-gradient",
-        EI = "legend-label",
-        $oe = "legend-symbol",
-        Moe = "legend-title",
-        Foe = "title",
-        Doe = "title-text",
-        Roe = "title-subtitle";
+    const eE = "mark",
+        tE = "frame",
+        nE = "scope",
+        $ae = "axis",
+        Tae = "axis-domain",
+        Mae = "axis-grid",
+        Oae = "axis-label",
+        Fae = "axis-tick",
+        Rae = "axis-title",
+        Dae = "legend",
+        Nae = "legend-band",
+        Pae = "legend-entry",
+        Lae = "legend-gradient",
+        NL = "legend-label",
+        Iae = "legend-symbol",
+        zae = "legend-title",
+        Bae = "title",
+        jae = "title-text",
+        Uae = "title-subtitle";
 
-    function Poe(e, t, n, i, r) {
-        const a = {},
-            s = {};
+    function Gae(e, t, n, i, r) {
+        const s = {},
+            a = {};
         let o, l, u, c;
-        l = "lineBreak", t === "text" && r[l] != null && !vu(l, e) && qv(a, l, r[l]), (n == "legend" || String(n).startsWith("axis")) && (n = null), c = n === PE ? r.group : n === RE ? ke({}, r.mark, r[t]) : null;
-        for (l in c) u = vu(l, e) || (l === "fill" || l === "stroke") && (vu("fill", e) || vu("stroke", e)), u || qv(a, l, c[l]);
-        ie(i).forEach(f => {
+        l = "lineBreak", t === "text" && r[l] != null && !ou(l, e) && wv(s, l, r[l]), (n == "legend" || String(n).startsWith("axis")) && (n = null), c = n === tE ? r.group : n === eE ? Ae({}, r.mark, r[t]) : null;
+        for (l in c) u = ou(l, e) || (l === "fill" || l === "stroke") && (ou("fill", e) || ou("stroke", e)), u || wv(s, l, c[l]);
+        se(i).forEach(f => {
             const h = r.style && r.style[f];
-            for (const d in h) vu(d, e) || qv(a, d, h[d])
-        }), e = ke({}, e);
-        for (l in a) c = a[l], c.signal ? (o = o || {})[l] = c : s[l] = c;
-        return e.enter = ke(s, e.enter), o && (e.update = ke(o, e.update)), e
+            for (const d in h) ou(d, e) || wv(s, d, h[d])
+        }), e = Ae({}, e);
+        for (l in s) c = s[l], c.signal ? (o = o || {})[l] = c : a[l] = c;
+        return e.enter = Ae(a, e.enter), o && (e.update = Ae(o, e.update)), e
     }
 
-    function qv(e, t, n) {
+    function wv(e, t, n) {
         e[t] = n && n.signal ? {
             signal: n.signal
         } : {
             value: n
         }
     }
-    const OI = e => re(e) ? Z(e) : e.signal ? `(${e.signal})` : CI(e);
+    const PL = e => re(e) ? Z(e) : e.signal ? `(${e.signal})` : LL(e);
 
-    function $1(e) {
-        if (e.gradient != null) return Loe(e);
-        let t = e.signal ? `(${e.signal})` : e.color ? Noe(e.color) : e.field != null ? CI(e.field) : e.value !== void 0 ? Z(e.value) : void 0;
-        return e.scale != null && (t = Ioe(e, t)), t === void 0 && (t = null), e.exponent != null && (t = `pow(${t},${kp(e.exponent)})`), e.mult != null && (t += `*${kp(e.mult)}`), e.offset != null && (t += `+${kp(e.offset)}`), e.round && (t = `round(${t})`), t
+    function f1(e) {
+        if (e.gradient != null) return qae(e);
+        let t = e.signal ? `(${e.signal})` : e.color ? Wae(e.color) : e.field != null ? LL(e.field) : e.value !== void 0 ? Z(e.value) : void 0;
+        return e.scale != null && (t = Hae(e, t)), t === void 0 && (t = null), e.exponent != null && (t = `pow(${t},${up(e.exponent)})`), e.mult != null && (t += `*${up(e.mult)}`), e.offset != null && (t += `+${up(e.offset)}`), e.round && (t = `round(${t})`), t
     }
-    const Gg = (e, t, n, i) => `(${e}(${[t,n,i].map($1).join(",")})+'')`;
+    const Ag = (e, t, n, i) => `(${e}(${[t,n,i].map(f1).join(",")})+'')`;
 
-    function Noe(e) {
-        return e.c ? Gg("hcl", e.h, e.c, e.l) : e.h || e.s ? Gg("hsl", e.h, e.s, e.l) : e.l || e.a ? Gg("lab", e.l, e.a, e.b) : e.r || e.g || e.b ? Gg("rgb", e.r, e.g, e.b) : null
+    function Wae(e) {
+        return e.c ? Ag("hcl", e.h, e.c, e.l) : e.h || e.s ? Ag("hsl", e.h, e.s, e.l) : e.l || e.a ? Ag("lab", e.l, e.a, e.b) : e.r || e.g || e.b ? Ag("rgb", e.r, e.g, e.b) : null
     }
 
-    function Loe(e) {
+    function qae(e) {
         const t = [e.start, e.stop, e.count].map(n => n == null ? null : Z(n));
-        for (; t.length && Le(t) == null;) t.pop();
-        return t.unshift(OI(e.gradient)), `gradient(${t.join(",")})`
+        for (; t.length && De(t) == null;) t.pop();
+        return t.unshift(PL(e.gradient)), `gradient(${t.join(",")})`
     }
 
-    function kp(e) {
-        return se(e) ? "(" + $1(e) + ")" : e
+    function up(e) {
+        return ae(e) ? "(" + f1(e) + ")" : e
     }
 
-    function CI(e) {
-        return kI(se(e) ? e : {
+    function LL(e) {
+        return IL(ae(e) ? e : {
             datum: e
         })
     }
 
-    function kI(e) {
+    function IL(e) {
         let t, n, i;
         if (e.signal) t = "datum", i = e.signal;
         else if (e.group || e.parent) {
             for (n = Math.max(1, e.level || 1), t = "item"; n-- > 0;) t += ".mark.group";
             e.parent ? (i = e.parent, t += ".datum") : i = e.group
-        } else e.datum ? (t = "datum", i = e.datum) : G("Invalid field reference: " + Z(e));
-        return e.signal || (i = re(i) ? ca(i).map(Z).join("][") : kI(i)), t + "[" + i + "]"
+        } else e.datum ? (t = "datum", i = e.datum) : U("Invalid field reference: " + Z(e));
+        return e.signal || (i = re(i) ? ns(i).map(Z).join("][") : IL(i)), t + "[" + i + "]"
     }
 
-    function Ioe(e, t) {
-        const n = OI(e.scale);
-        return e.range != null ? t = `lerp(_range(${n}), ${+e.range})` : (t !== void 0 && (t = `_scale(${n}, ${t})`), e.band && (t = (t ? t + "+" : "") + `_bandwidth(${n})` + (+e.band == 1 ? "" : "*" + kp(e.band)), e.extra && (t = `(datum.extra ? _scale(${n}, datum.extra.value) : ${t})`)), t == null && (t = "0")), t
+    function Hae(e, t) {
+        const n = PL(e.scale);
+        return e.range != null ? t = `lerp(_range(${n}), ${+e.range})` : (t !== void 0 && (t = `_scale(${n}, ${t})`), e.band && (t = (t ? t + "+" : "") + `_bandwidth(${n})` + (+e.band == 1 ? "" : "*" + up(e.band)), e.extra && (t = `(datum.extra ? _scale(${n}, datum.extra.value) : ${t})`)), t == null && (t = "0")), t
     }
 
-    function joe(e) {
+    function Yae(e) {
         let t = "";
         return e.forEach(n => {
-            const i = $1(n);
+            const i = f1(n);
             t += n.test ? `(${n.test})?${i}:` : i
-        }), Le(t) === ":" && (t += "null"), t
+        }), De(t) === ":" && (t += "null"), t
     }
 
-    function AI(e, t, n, i, r, a) {
-        const s = {};
-        a = a || {}, a.encoders = {
-            $encode: s
-        }, e = Poe(e, t, n, i, r.config);
-        for (const o in e) s[o] = zoe(e[o], t, a, r);
-        return a
+    function zL(e, t, n, i, r, s) {
+        const a = {};
+        s = s || {}, s.encoders = {
+            $encode: a
+        }, e = Gae(e, t, n, i, r.config);
+        for (const o in e) a[o] = Xae(e[o], t, s, r);
+        return s
     }
 
-    function zoe(e, t, n, i) {
+    function Xae(e, t, n, i) {
         const r = {},
-            a = {};
-        for (const s in e) e[s] != null && (r[s] = Goe(Boe(e[s]), i, n, a));
+            s = {};
+        for (const a in e) e[a] != null && (r[a] = Kae(Vae(e[a]), i, n, s));
         return {
             $expr: {
                 marktype: t,
                 channels: r
             },
-            $fields: Object.keys(a),
+            $fields: Object.keys(s),
             $output: Object.keys(e)
         }
     }
 
-    function Boe(e) {
-        return q(e) ? joe(e) : $1(e)
+    function Vae(e) {
+        return W(e) ? Yae(e) : f1(e)
     }
 
-    function Goe(e, t, n, i) {
-        const r = ta(e, t);
-        return r.$fields.forEach(a => i[a] = 1), ke(n, r.$params), r.$expr
+    function Kae(e, t, n, i) {
+        const r = Xr(e, t);
+        return r.$fields.forEach(s => i[s] = 1), Ae(n, r.$params), r.$expr
     }
-    const Uoe = "outer",
-        qoe = ["value", "update", "init", "react", "bind"];
+    const Jae = "outer",
+        Qae = ["value", "update", "init", "react", "bind"];
 
-    function q3(e, t) {
-        G(e + ' for "outer" push: ' + Z(t))
+    function r5(e, t) {
+        U(e + ' for "outer" push: ' + Z(t))
     }
 
-    function TI(e, t) {
+    function BL(e, t) {
         const n = e.name;
-        if (e.push === Uoe) t.signals[n] || q3("No prior signal definition", n), qoe.forEach(i => {
-            e[i] !== void 0 && q3("Invalid property ", i)
+        if (e.push === Jae) t.signals[n] || r5("No prior signal definition", n), Qae.forEach(i => {
+            e[i] !== void 0 && r5("Invalid property ", i)
         });
         else {
             const i = t.addSignal(n, e.value);
             e.react === !1 && (i.react = !1), e.bind && t.addBinding(n, e.bind)
         }
     }
 
-    function lx(e, t, n, i) {
+    function P2(e, t, n, i) {
         this.id = -1, this.type = e, this.value = t, this.params = n, i && (this.parent = i)
     }
 
-    function M1(e, t, n, i) {
-        return new lx(e, t, n, i)
+    function h1(e, t, n, i) {
+        return new P2(e, t, n, i)
     }
 
-    function Z0(e, t) {
-        return M1("operator", e, t)
+    function D0(e, t) {
+        return h1("operator", e, t)
     }
 
-    function he(e) {
+    function de(e) {
         const t = {
             $ref: e.id
         };
         return e.id < 0 && (e.refs = e.refs || []).push(t), t
     }
 
-    function Yh(e, t) {
+    function Nh(e, t) {
         return t ? {
             $field: e,
             $name: t
         } : {
             $field: e
         }
     }
-    const ux = Yh("key");
+    const L2 = Nh("key");
 
-    function W3(e, t) {
+    function s5(e, t) {
         return {
             $compare: e,
             $order: t
         }
     }
 
-    function Woe(e, t) {
+    function Zae(e, t) {
         const n = {
             $key: e
         };
         return t && (n.$flat = !0), n
     }
-    const Hoe = "ascending",
-        Yoe = "descending";
+    const eoe = "ascending",
+        toe = "descending";
 
-    function Xoe(e) {
-        return se(e) ? (e.order === Yoe ? "-" : "+") + F1(e.op, e.field) : ""
+    function noe(e) {
+        return ae(e) ? (e.order === toe ? "-" : "+") + d1(e.op, e.field) : ""
     }
 
-    function F1(e, t) {
+    function d1(e, t) {
         return (e && e.signal ? "$" + e.signal : e || "") + (e && t ? "_" : "") + (t && t.signal ? "$" + t.signal : t || "")
     }
-    const LE = "scope",
-        cx = "view";
+    const iE = "scope",
+        I2 = "view";
 
-    function Nt(e) {
+    function Ft(e) {
         return e && e.signal
     }
 
-    function Voe(e) {
+    function ioe(e) {
         return e && e.expr
     }
 
-    function Ap(e) {
-        if (Nt(e)) return !0;
-        if (se(e)) {
+    function cp(e) {
+        if (Ft(e)) return !0;
+        if (ae(e)) {
             for (const t in e)
-                if (Ap(e[t])) return !0
+                if (cp(e[t])) return !0
         }
         return !1
     }
 
-    function er(e, t) {
+    function Yi(e, t) {
         return e ?? t
     }
 
-    function il(e) {
+    function Wo(e) {
         return e && e.signal || e
     }
-    const H3 = "timer";
+    const a5 = "timer";
 
-    function Xh(e, t) {
-        return (e.merge ? Joe : e.stream ? Qoe : e.type ? Zoe : G("Invalid stream specification: " + Z(e)))(e, t)
+    function Ph(e, t) {
+        return (e.merge ? soe : e.stream ? aoe : e.type ? ooe : U("Invalid stream specification: " + Z(e)))(e, t)
     }
 
-    function Koe(e) {
-        return e === LE ? cx : e || cx
+    function roe(e) {
+        return e === iE ? I2 : e || I2
     }
 
-    function Joe(e, t) {
-        const n = e.merge.map(r => Xh(r, t)),
-            i = IE({
+    function soe(e, t) {
+        const n = e.merge.map(r => Ph(r, t)),
+            i = rE({
                 merge: n
             }, e, t);
         return t.addStream(i).id
     }
 
-    function Qoe(e, t) {
-        const n = Xh(e.stream, t),
-            i = IE({
+    function aoe(e, t) {
+        const n = Ph(e.stream, t),
+            i = rE({
                 stream: n
             }, e, t);
         return t.addStream(i).id
     }
 
-    function Zoe(e, t) {
+    function ooe(e, t) {
         let n;
-        e.type === H3 ? (n = t.event(H3, e.throttle), e = {
+        e.type === a5 ? (n = t.event(a5, e.throttle), e = {
             between: e.between,
             filter: e.filter
-        }) : n = t.event(Koe(e.source), e.type);
-        const i = IE({
+        }) : n = t.event(roe(e.source), e.type);
+        const i = rE({
             stream: n
         }, e, t);
         return Object.keys(i).length === 1 ? n : t.addStream(i).id
     }
 
-    function IE(e, t, n) {
+    function rE(e, t, n) {
         let i = t.between;
-        return i && (i.length !== 2 && G('Stream "between" parameter must have 2 entries: ' + Z(t)), e.between = [Xh(i[0], n), Xh(i[1], n)]), i = t.filter ? [].concat(t.filter) : [], (t.marktype || t.markname || t.markrole) && i.push(ele(t.marktype, t.markname, t.markrole)), t.source === LE && i.push("inScope(event.item)"), i.length && (e.filter = ta("(" + i.join(")&&(") + ")", n).$expr), (i = t.throttle) != null && (e.throttle = +i), (i = t.debounce) != null && (e.debounce = +i), t.consume && (e.consume = !0), e
+        return i && (i.length !== 2 && U('Stream "between" parameter must have 2 entries: ' + Z(t)), e.between = [Ph(i[0], n), Ph(i[1], n)]), i = t.filter ? [].concat(t.filter) : [], (t.marktype || t.markname || t.markrole) && i.push(loe(t.marktype, t.markname, t.markrole)), t.source === iE && i.push("inScope(event.item)"), i.length && (e.filter = Xr("(" + i.join(")&&(") + ")", n).$expr), (i = t.throttle) != null && (e.throttle = +i), (i = t.debounce) != null && (e.debounce = +i), t.consume && (e.consume = !0), e
     }
 
-    function ele(e, t, n) {
+    function loe(e, t, n) {
         const i = "event.item";
         return i + (e && e !== "*" ? "&&" + i + ".mark.marktype==='" + e + "'" : "") + (n ? "&&" + i + ".mark.role==='" + n + "'" : "") + (t ? "&&" + i + ".mark.name==='" + t + "'" : "")
     }
-    const tle = {
+    const uoe = {
         code: "_.$value",
         ast: {
             type: "Identifier",
             value: "value"
         }
     };
 
-    function nle(e, t, n) {
+    function coe(e, t, n) {
         const i = e.encode,
             r = {
                 target: n
             };
-        let a = e.events,
-            s = e.update,
+        let s = e.events,
+            a = e.update,
             o = [];
-        a || G("Signal update missing events specification."), re(a) && (a = ho(a, t.isSubscope() ? LE : cx)), a = ie(a).filter(l => l.signal || l.scale ? (o.push(l), 0) : 1), o.length > 1 && (o = [rle(o)]), a.length && o.push(a.length > 1 ? {
-            merge: a
-        } : a[0]), i != null && (s && G("Signal encode and update are mutually exclusive."), s = "encode(item()," + Z(i) + ")"), r.update = re(s) ? ta(s, t) : s.expr != null ? ta(s.expr, t) : s.value != null ? s.value : s.signal != null ? {
-            $expr: tle,
+        s || U("Signal update missing events specification."), re(s) && (s = to(s, t.isSubscope() ? iE : I2)), s = se(s).filter(l => l.signal || l.scale ? (o.push(l), 0) : 1), o.length > 1 && (o = [hoe(o)]), s.length && o.push(s.length > 1 ? {
+            merge: s
+        } : s[0]), i != null && (a && U("Signal encode and update are mutually exclusive."), a = "encode(item()," + Z(i) + ")"), r.update = re(a) ? Xr(a, t) : a.expr != null ? Xr(a.expr, t) : a.value != null ? a.value : a.signal != null ? {
+            $expr: uoe,
             $params: {
-                $value: t.signalRef(s.signal)
+                $value: t.signalRef(a.signal)
             }
-        } : G("Invalid signal update specification."), e.force && (r.options = {
+        } : U("Invalid signal update specification."), e.force && (r.options = {
             force: !0
-        }), o.forEach(l => t.addUpdate(ke(ile(l, t), r)))
+        }), o.forEach(l => t.addUpdate(Ae(foe(l, t), r)))
     }
 
-    function ile(e, t) {
+    function foe(e, t) {
         return {
-            source: e.signal ? t.signalRef(e.signal) : e.scale ? t.scaleRef(e.scale) : Xh(e, t)
+            source: e.signal ? t.signalRef(e.signal) : e.scale ? t.scaleRef(e.scale) : Ph(e, t)
         }
     }
 
-    function rle(e) {
+    function hoe(e) {
         return {
             signal: "[" + e.map(t => t.scale ? 'scale("' + t.scale + '")' : t.signal) + "]"
         }
     }
 
-    function ale(e, t) {
+    function doe(e, t) {
         const n = t.getSignal(e.name);
         let i = e.update;
-        e.init && (i ? G("Signals can not include both init and update expressions.") : (i = e.init, n.initonly = !0)), i && (i = ta(i, t), n.update = i.$expr, n.params = i.$params), e.on && e.on.forEach(r => nle(r, t, n.id))
+        e.init && (i ? U("Signals can not include both init and update expressions.") : (i = e.init, n.initonly = !0)), i && (i = Xr(i, t), n.update = i.$expr, n.params = i.$params), e.on && e.on.forEach(r => coe(r, t, n.id))
     }
-    const nt = e => (t, n, i) => M1(e, n, t || void 0, i),
-        $I = nt("aggregate"),
-        sle = nt("axisticks"),
-        MI = nt("bound"),
-        Or = nt("collect"),
-        Y3 = nt("compare"),
-        ole = nt("datajoin"),
-        FI = nt("encode"),
-        lle = nt("expression"),
-        ule = nt("facet"),
-        cle = nt("field"),
-        fle = nt("key"),
-        hle = nt("legendentries"),
-        dle = nt("load"),
-        gle = nt("mark"),
-        ple = nt("multiextent"),
-        mle = nt("multivalues"),
-        yle = nt("overlap"),
-        vle = nt("params"),
-        DI = nt("prefacet"),
-        ble = nt("projection"),
-        xle = nt("proxy"),
-        _le = nt("relay"),
-        RI = nt("render"),
-        wle = nt("scale"),
-        Ul = nt("sieve"),
-        Sle = nt("sortitems"),
-        PI = nt("viewlayout"),
-        Ele = nt("values");
-    let Ole = 0;
-    const NI = {
+    const tt = e => (t, n, i) => h1(e, n, t || void 0, i),
+        jL = tt("aggregate"),
+        goe = tt("axisticks"),
+        UL = tt("bound"),
+        vr = tt("collect"),
+        o5 = tt("compare"),
+        poe = tt("datajoin"),
+        GL = tt("encode"),
+        moe = tt("expression"),
+        yoe = tt("facet"),
+        voe = tt("field"),
+        boe = tt("key"),
+        xoe = tt("legendentries"),
+        _oe = tt("load"),
+        woe = tt("mark"),
+        Soe = tt("multiextent"),
+        Eoe = tt("multivalues"),
+        Coe = tt("overlap"),
+        koe = tt("params"),
+        WL = tt("prefacet"),
+        Aoe = tt("projection"),
+        $oe = tt("proxy"),
+        Toe = tt("relay"),
+        qL = tt("render"),
+        Moe = tt("scale"),
+        Fl = tt("sieve"),
+        Ooe = tt("sortitems"),
+        HL = tt("viewlayout"),
+        Foe = tt("values");
+    let Roe = 0;
+    const YL = {
         min: "min",
         max: "max",
         count: "sum"
     };
 
-    function Cle(e, t) {
+    function Doe(e, t) {
         const n = e.type || "linear";
-        $N(n) || G("Unrecognized scale type: " + Z(n)), t.addScale(e.name, {
+        jN(n) || U("Unrecognized scale type: " + Z(n)), t.addScale(e.name, {
             type: n,
             domain: void 0
         })
     }
 
-    function kle(e, t) {
+    function Noe(e, t) {
         const n = t.getScale(e.name).params;
         let i;
-        n.domain = LI(e.domain, e, t), e.range != null && (n.range = jI(e, t, n)), e.interpolate != null && Lle(e.interpolate, n), e.nice != null && (n.nice = Nle(e.nice)), e.bins != null && (n.bins = Ple(e.bins, t));
-        for (i in e) pe(n, i) || i === "name" || (n[i] = Di(e[i], t))
+        n.domain = XL(e.domain, e, t), e.range != null && (n.range = KL(e, t, n)), e.interpolate != null && qoe(e.interpolate, n), e.nice != null && (n.nice = Woe(e.nice)), e.bins != null && (n.bins = Goe(e.bins, t));
+        for (i in e) me(n, i) || i === "name" || (n[i] = $i(e[i], t))
     }
 
-    function Di(e, t) {
-        return se(e) ? e.signal ? t.signalRef(e.signal) : G("Unsupported object: " + Z(e)) : e
+    function $i(e, t) {
+        return ae(e) ? e.signal ? t.signalRef(e.signal) : U("Unsupported object: " + Z(e)) : e
     }
 
-    function Tp(e, t) {
-        return e.signal ? t.signalRef(e.signal) : e.map(n => Di(n, t))
+    function fp(e, t) {
+        return e.signal ? t.signalRef(e.signal) : e.map(n => $i(n, t))
     }
 
-    function D1(e) {
-        G("Can not find data set: " + Z(e))
+    function g1(e) {
+        U("Can not find data set: " + Z(e))
     }
 
-    function LI(e, t, n) {
+    function XL(e, t, n) {
         if (!e) {
-            (t.domainMin != null || t.domainMax != null) && G("No scale domain defined for domainMin/domainMax to override.");
+            (t.domainMin != null || t.domainMax != null) && U("No scale domain defined for domainMin/domainMax to override.");
             return
         }
-        return e.signal ? n.signalRef(e.signal) : (q(e) ? Ale : e.fields ? $le : Tle)(e, t, n)
+        return e.signal ? n.signalRef(e.signal) : (W(e) ? Poe : e.fields ? Ioe : Loe)(e, t, n)
     }
 
-    function Ale(e, t, n) {
-        return e.map(i => Di(i, n))
+    function Poe(e, t, n) {
+        return e.map(i => $i(i, n))
     }
 
-    function Tle(e, t, n) {
+    function Loe(e, t, n) {
         const i = n.getData(e.data);
-        return i || D1(e.data), nc(t.type) ? i.valuesRef(n, e.field, II(e.sort, !1)) : DN(t.type) ? i.domainRef(n, e.field) : i.extentRef(n, e.field)
+        return i || g1(e.data), qu(t.type) ? i.valuesRef(n, e.field, VL(e.sort, !1)) : WN(t.type) ? i.domainRef(n, e.field) : i.extentRef(n, e.field)
     }
 
-    function $le(e, t, n) {
+    function Ioe(e, t, n) {
         const i = e.data,
-            r = e.fields.reduce((a, s) => (s = re(s) ? {
+            r = e.fields.reduce((s, a) => (a = re(a) ? {
                 data: i,
-                field: s
-            } : q(s) || s.signal ? Mle(s, n) : s, a.push(s), a), []);
-        return (nc(t.type) ? Fle : DN(t.type) ? Dle : Rle)(e, n, r)
+                field: a
+            } : W(a) || a.signal ? zoe(a, n) : a, s.push(a), s), []);
+        return (qu(t.type) ? Boe : WN(t.type) ? joe : Uoe)(e, n, r)
     }
 
-    function Mle(e, t) {
-        const n = "_:vega:_" + Ole++,
-            i = Or({});
-        if (q(e)) i.value = {
+    function zoe(e, t) {
+        const n = "_:vega:_" + Roe++,
+            i = vr({});
+        if (W(e)) i.value = {
             $ingest: e
         };
         else if (e.signal) {
             const r = "setdata(" + Z(n) + "," + e.signal + ")";
             i.params.input = t.signalRef(r)
         }
-        return t.addDataPipeline(n, [i, Ul({})]), {
+        return t.addDataPipeline(n, [i, Fl({})]), {
             data: n,
             field: "data"
         }
     }
 
-    function Fle(e, t, n) {
-        const i = II(e.sort, !0);
-        let r, a;
-        const s = n.map(u => {
+    function Boe(e, t, n) {
+        const i = VL(e.sort, !0);
+        let r, s;
+        const a = n.map(u => {
                 const c = t.getData(u.data);
-                return c || D1(u.data), c.countsRef(t, u.field, i)
+                return c || g1(u.data), c.countsRef(t, u.field, i)
             }),
             o = {
-                groupby: ux,
-                pulse: s
+                groupby: L2,
+                pulse: a
             };
-        i && (r = i.op || "count", a = i.field ? F1(r, i.field) : "count", o.ops = [NI[r]], o.fields = [t.fieldRef(a)], o.as = [a]), r = t.add($I(o));
-        const l = t.add(Or({
-            pulse: he(r)
+        i && (r = i.op || "count", s = i.field ? d1(r, i.field) : "count", o.ops = [YL[r]], o.fields = [t.fieldRef(s)], o.as = [s]), r = t.add(jL(o));
+        const l = t.add(vr({
+            pulse: de(r)
         }));
-        return a = t.add(Ele({
-            field: ux,
+        return s = t.add(Foe({
+            field: L2,
             sort: t.sortRef(i),
-            pulse: he(l)
-        })), he(a)
+            pulse: de(l)
+        })), de(s)
     }
 
-    function II(e, t) {
-        return e && (!e.field && !e.op ? se(e) ? e.field = "key" : e = {
+    function VL(e, t) {
+        return e && (!e.field && !e.op ? ae(e) ? e.field = "key" : e = {
             field: "key"
-        } : !e.field && e.op !== "count" ? G("No field provided for sort aggregate op: " + e.op) : t && e.field && e.op && !NI[e.op] && G("Multiple domain scales can not be sorted using " + e.op)), e
+        } : !e.field && e.op !== "count" ? U("No field provided for sort aggregate op: " + e.op) : t && e.field && e.op && !YL[e.op] && U("Multiple domain scales can not be sorted using " + e.op)), e
     }
 
-    function Dle(e, t, n) {
+    function joe(e, t, n) {
         const i = n.map(r => {
-            const a = t.getData(r.data);
-            return a || D1(r.data), a.domainRef(t, r.field)
+            const s = t.getData(r.data);
+            return s || g1(r.data), s.domainRef(t, r.field)
         });
-        return he(t.add(mle({
+        return de(t.add(Eoe({
             values: i
         })))
     }
 
-    function Rle(e, t, n) {
+    function Uoe(e, t, n) {
         const i = n.map(r => {
-            const a = t.getData(r.data);
-            return a || D1(r.data), a.extentRef(t, r.field)
+            const s = t.getData(r.data);
+            return s || g1(r.data), s.extentRef(t, r.field)
         });
-        return he(t.add(ple({
+        return de(t.add(Soe({
             extents: i
         })))
     }
 
-    function Ple(e, t) {
-        return e.signal || q(e) ? Tp(e, t) : t.objectProperty(e)
+    function Goe(e, t) {
+        return e.signal || W(e) ? fp(e, t) : t.objectProperty(e)
     }
 
-    function Nle(e) {
-        return se(e) ? {
-            interval: Di(e.interval),
-            step: Di(e.step)
-        } : Di(e)
+    function Woe(e) {
+        return ae(e) ? {
+            interval: $i(e.interval),
+            step: $i(e.step)
+        } : $i(e)
     }
 
-    function Lle(e, t) {
-        t.interpolate = Di(e.type || e), e.gamma != null && (t.interpolateGamma = Di(e.gamma))
+    function qoe(e, t) {
+        t.interpolate = $i(e.type || e), e.gamma != null && (t.interpolateGamma = $i(e.gamma))
     }
 
-    function jI(e, t, n) {
+    function KL(e, t, n) {
         const i = t.config.range;
         let r = e.range;
         if (r.signal) return t.signalRef(r.signal);
         if (re(r)) {
-            if (i && pe(i, r)) return e = ke({}, e, {
+            if (i && me(i, r)) return e = Ae({}, e, {
                 range: i[r]
-            }), jI(e, t, n);
+            }), KL(e, t, n);
             r === "width" ? r = [0, {
                 signal: "width"
-            }] : r === "height" ? r = nc(e.type) ? [0, {
+            }] : r === "height" ? r = qu(e.type) ? [0, {
                 signal: "height"
             }] : [{
                 signal: "height"
-            }, 0] : G("Unrecognized scale range value: " + Z(r))
+            }, 0] : U("Unrecognized scale range value: " + Z(r))
         } else if (r.scheme) {
-            n.scheme = q(r.scheme) ? Tp(r.scheme, t) : Di(r.scheme, t), r.extent && (n.schemeExtent = Tp(r.extent, t)), r.count && (n.schemeCount = Di(r.count, t));
+            n.scheme = W(r.scheme) ? fp(r.scheme, t) : $i(r.scheme, t), r.extent && (n.schemeExtent = fp(r.extent, t)), r.count && (n.schemeCount = $i(r.count, t));
             return
         } else if (r.step) {
-            n.rangeStep = Di(r.step, t);
+            n.rangeStep = $i(r.step, t);
             return
         } else {
-            if (nc(e.type) && !q(r)) return LI(r, e, t);
-            q(r) || G("Unsupported range type: " + Z(r))
+            if (qu(e.type) && !W(r)) return XL(r, e, t);
+            W(r) || U("Unsupported range type: " + Z(r))
         }
-        return r.map(a => (q(a) ? Tp : Di)(a, t))
+        return r.map(s => (W(s) ? fp : $i)(s, t))
     }
 
-    function Ile(e, t) {
+    function Hoe(e, t) {
         const n = t.config.projection || {},
             i = {};
-        for (const r in e) r !== "name" && (i[r] = fx(e[r], r, t));
-        for (const r in n) i[r] == null && (i[r] = fx(n[r], r, t));
+        for (const r in e) r !== "name" && (i[r] = z2(e[r], r, t));
+        for (const r in n) i[r] == null && (i[r] = z2(n[r], r, t));
         t.addProjection(e.name, i)
     }
 
-    function fx(e, t, n) {
-        return q(e) ? e.map(i => fx(i, t, n)) : se(e) ? e.signal ? n.signalRef(e.signal) : t === "fit" ? e : G("Unsupported parameter object: " + Z(e)) : e
+    function z2(e, t, n) {
+        return W(e) ? e.map(i => z2(i, t, n)) : ae(e) ? e.signal ? n.signalRef(e.signal) : t === "fit" ? e : U("Unsupported parameter object: " + Z(e)) : e
     }
-    const Cr = "top",
-        zc = "left",
-        Bc = "right",
-        Vs = "bottom",
-        zI = "center",
-        jle = "vertical",
-        zle = "start",
-        Ble = "middle",
-        Gle = "end",
-        hx = "index",
-        jE = "label",
-        Ule = "offset",
-        lc = "perc",
-        qle = "perc2",
-        Pi = "value",
-        Id = "guide-label",
-        zE = "guide-title",
-        Wle = "group-title",
-        Hle = "group-subtitle",
-        X3 = "symbol",
-        $p = "gradient",
-        dx = "discrete",
-        gx = "size",
-        Yle = "shape",
-        Xle = "fill",
-        Vle = "stroke",
-        Kle = "strokeWidth",
-        Jle = "strokeDash",
-        Qle = "opacity",
-        BE = [gx, Yle, Xle, Vle, Kle, Jle, Qle],
-        jd = {
+    const br = "top",
+        $c = "left",
+        Tc = "right",
+        za = "bottom",
+        JL = "center",
+        Yoe = "vertical",
+        Xoe = "start",
+        Voe = "middle",
+        Koe = "end",
+        B2 = "index",
+        sE = "label",
+        Joe = "offset",
+        Ju = "perc",
+        Qoe = "perc2",
+        Mi = "value",
+        kd = "guide-label",
+        aE = "guide-title",
+        Zoe = "group-title",
+        ele = "group-subtitle",
+        l5 = "symbol",
+        hp = "gradient",
+        j2 = "discrete",
+        U2 = "size",
+        tle = "shape",
+        nle = "fill",
+        ile = "stroke",
+        rle = "strokeWidth",
+        sle = "strokeDash",
+        ale = "opacity",
+        oE = [U2, tle, nle, ile, rle, sle, ale],
+        Ad = {
             name: 1,
             style: 1,
             interactive: 1
         },
-        je = {
+        Le = {
             value: 0
         },
-        Ni = {
+        Oi = {
             value: 1
         },
-        R1 = "group",
-        BI = "rect",
-        GE = "rule",
-        Zle = "symbol",
-        ql = "text";
+        p1 = "group",
+        QL = "rect",
+        lE = "rule",
+        ole = "symbol",
+        Rl = "text";
 
-    function Vh(e) {
-        return e.type = R1, e.interactive = e.interactive || !1, e
+    function Lh(e) {
+        return e.type = p1, e.interactive = e.interactive || !1, e
     }
 
-    function fi(e, t) {
-        const n = (i, r) => er(e[i], er(t[i], r));
-        return n.isVertical = i => jle === er(e.direction, t.direction || (i ? t.symbolDirection : t.gradientDirection)), n.gradientLength = () => er(e.gradientLength, t.gradientLength || t.gradientWidth), n.gradientThickness = () => er(e.gradientThickness, t.gradientThickness || t.gradientHeight), n.entryColumns = () => er(e.columns, er(t.columns, +n.isVertical(!0))), n
+    function ui(e, t) {
+        const n = (i, r) => Yi(e[i], Yi(t[i], r));
+        return n.isVertical = i => Yoe === Yi(e.direction, t.direction || (i ? t.symbolDirection : t.gradientDirection)), n.gradientLength = () => Yi(e.gradientLength, t.gradientLength || t.gradientWidth), n.gradientThickness = () => Yi(e.gradientThickness, t.gradientThickness || t.gradientHeight), n.entryColumns = () => Yi(e.columns, Yi(t.columns, +n.isVertical(!0))), n
     }
 
-    function GI(e, t) {
+    function ZL(e, t) {
         const n = t && (t.update && t.update[e] || t.enter && t.enter[e]);
         return n && n.signal ? n : n ? n.value : null
     }
 
-    function eue(e, t, n) {
+    function lle(e, t, n) {
         const i = t.config.style[n];
         return i && i[e]
     }
 
-    function P1(e, t, n) {
-        return `item.anchor === '${zle}' ? ${e} : item.anchor === '${Gle}' ? ${t} : ${n}`
+    function m1(e, t, n) {
+        return `item.anchor === '${Xoe}' ? ${e} : item.anchor === '${Koe}' ? ${t} : ${n}`
     }
-    const UE = P1(Z(zc), Z(Bc), Z(zI));
+    const uE = m1(Z($c), Z(Tc), Z(JL));
 
-    function tue(e) {
+    function ule(e) {
         const t = e("tickBand");
         let n = e("tickOffset"),
             i, r;
         return t ? t.signal ? (i = {
             signal: `(${t.signal}) === 'extent' ? 1 : 0.5`
         }, r = {
             signal: `(${t.signal}) === 'extent'`
-        }, se(n) || (n = {
+        }, ae(n) || (n = {
             signal: `(${t.signal}) === 'extent' ? 0 : ${n}`
         })) : t === "extent" ? (i = 1, r = !0, n = 0) : (i = .5, r = !1) : (i = e("bandPosition"), r = e("tickExtra")), {
             extra: r,
             band: i,
             offset: n
         }
     }
 
-    function UI(e, t) {
-        return t ? e ? se(e) ? Object.assign({}, e, {
-            offset: UI(e.offset, t)
+    function eI(e, t) {
+        return t ? e ? ae(e) ? Object.assign({}, e, {
+            offset: eI(e.offset, t)
         }) : {
             value: e,
             offset: t
         } : t : e
     }
 
-    function Si(e, t) {
-        return t ? (e.name = t.name, e.style = t.style || e.style, e.interactive = !!t.interactive, e.encode = jc(e.encode, t, jd)) : e.interactive = !1, e
+    function _i(e, t) {
+        return t ? (e.name = t.name, e.style = t.style || e.style, e.interactive = !!t.interactive, e.encode = Ac(e.encode, t, Ad)) : e.interactive = !1, e
     }
 
-    function nue(e, t, n, i) {
-        const r = fi(e, n),
-            a = r.isVertical(),
-            s = r.gradientThickness(),
+    function cle(e, t, n, i) {
+        const r = ui(e, n),
+            s = r.isVertical(),
+            a = r.gradientThickness(),
             o = r.gradientLength();
         let l, u, c, f, h;
-        a ? (u = [0, 1], c = [0, 0], f = s, h = o) : (u = [0, 0], c = [1, 0], f = o, h = s);
+        s ? (u = [0, 1], c = [0, 0], f = a, h = o) : (u = [0, 0], c = [1, 0], f = o, h = a);
         const d = {
             enter: l = {
-                opacity: je,
-                x: je,
-                y: je,
-                width: Wt(f),
-                height: Wt(h)
+                opacity: Le,
+                x: Le,
+                y: Le,
+                width: jt(f),
+                height: jt(h)
             },
-            update: ke({}, l, {
-                opacity: Ni,
+            update: Ae({}, l, {
+                opacity: Oi,
                 fill: {
                     gradient: t,
                     start: u,
                     stop: c
                 }
             }),
             exit: {
-                opacity: je
+                opacity: Le
             }
         };
-        return nn(d, {
+        return Zt(d, {
             stroke: r("gradientStrokeColor"),
             strokeWidth: r("gradientStrokeWidth")
         }, {
             opacity: r("gradientOpacity")
-        }), Si({
-            type: BI,
-            role: Toe,
+        }), _i({
+            type: QL,
+            role: Lae,
             encode: d
         }, i)
     }
 
-    function iue(e, t, n, i, r) {
-        const a = fi(e, n),
-            s = a.isVertical(),
-            o = a.gradientThickness(),
-            l = a.gradientLength();
+    function fle(e, t, n, i, r) {
+        const s = ui(e, n),
+            a = s.isVertical(),
+            o = s.gradientThickness(),
+            l = s.gradientLength();
         let u, c, f, h, d = "";
-        s ? (u = "y", f = "y2", c = "x", h = "width", d = "1-") : (u = "x", f = "x2", c = "y", h = "height");
+        a ? (u = "y", f = "y2", c = "x", h = "width", d = "1-") : (u = "x", f = "x2", c = "y", h = "height");
         const g = {
-            opacity: je,
+            opacity: Le,
             fill: {
                 scale: t,
-                field: Pi
+                field: Mi
             }
         };
         g[u] = {
-            signal: d + "datum." + lc,
+            signal: d + "datum." + Ju,
             mult: l
-        }, g[c] = je, g[f] = {
-            signal: d + "datum." + qle,
+        }, g[c] = Le, g[f] = {
+            signal: d + "datum." + Qoe,
             mult: l
-        }, g[h] = Wt(o);
+        }, g[h] = jt(o);
         const p = {
             enter: g,
-            update: ke({}, g, {
-                opacity: Ni
+            update: Ae({}, g, {
+                opacity: Oi
             }),
             exit: {
-                opacity: je
+                opacity: Le
             }
         };
-        return nn(p, {
-            stroke: a("gradientStrokeColor"),
-            strokeWidth: a("gradientStrokeWidth")
-        }, {
-            opacity: a("gradientOpacity")
-        }), Si({
-            type: BI,
-            role: koe,
-            key: Pi,
+        return Zt(p, {
+            stroke: s("gradientStrokeColor"),
+            strokeWidth: s("gradientStrokeWidth")
+        }, {
+            opacity: s("gradientOpacity")
+        }), _i({
+            type: QL,
+            role: Nae,
+            key: Mi,
             from: r,
             encode: p
         }, i)
     }
-    const rue = `datum.${lc}<=0?"${zc}":datum.${lc}>=1?"${Bc}":"${zI}"`,
-        aue = `datum.${lc}<=0?"${Vs}":datum.${lc}>=1?"${Cr}":"${Ble}"`;
+    const hle = `datum.${Ju}<=0?"${$c}":datum.${Ju}>=1?"${Tc}":"${JL}"`,
+        dle = `datum.${Ju}<=0?"${za}":datum.${Ju}>=1?"${br}":"${Voe}"`;
 
-    function V3(e, t, n, i) {
-        const r = fi(e, t),
-            a = r.isVertical(),
-            s = Wt(r.gradientThickness()),
+    function u5(e, t, n, i) {
+        const r = ui(e, t),
+            s = r.isVertical(),
+            a = jt(r.gradientThickness()),
             o = r.gradientLength();
         let l = r("labelOverlap"),
             u, c, f, h, d = "";
         const g = {
             enter: u = {
-                opacity: je
+                opacity: Le
             },
             update: c = {
-                opacity: Ni,
+                opacity: Oi,
                 text: {
-                    field: jE
+                    field: sE
                 }
             },
             exit: {
-                opacity: je
+                opacity: Le
             }
         };
-        return nn(g, {
+        return Zt(g, {
             fill: r("labelColor"),
             fillOpacity: r("labelOpacity"),
             font: r("labelFont"),
             fontSize: r("labelFontSize"),
             fontStyle: r("labelFontStyle"),
             fontWeight: r("labelFontWeight"),
-            limit: er(e.labelLimit, t.gradientLabelLimit)
-        }), a ? (u.align = {
+            limit: Yi(e.labelLimit, t.gradientLabelLimit)
+        }), s ? (u.align = {
             value: "left"
         }, u.baseline = c.baseline = {
-            signal: aue
+            signal: dle
         }, f = "y", h = "x", d = "1-") : (u.align = c.align = {
-            signal: rue
+            signal: hle
         }, u.baseline = {
             value: "top"
         }, f = "x", h = "y"), u[f] = c[f] = {
-            signal: d + "datum." + lc,
+            signal: d + "datum." + Ju,
             mult: o
-        }, u[h] = c[h] = s, s.offset = er(e.labelOffset, t.gradientLabelOffset) || 0, l = l ? {
+        }, u[h] = c[h] = a, a.offset = Yi(e.labelOffset, t.gradientLabelOffset) || 0, l = l ? {
             separation: r("labelSeparation"),
             method: l,
-            order: "datum." + hx
-        } : void 0, Si({
-            type: ql,
-            role: EI,
-            style: Id,
-            key: Pi,
+            order: "datum." + B2
+        } : void 0, _i({
+            type: Rl,
+            role: NL,
+            style: kd,
+            key: Mi,
             from: i,
             encode: g,
             overlap: l
         }, n)
     }
 
-    function sue(e, t, n, i, r) {
-        const a = fi(e, t),
-            s = n.entries,
-            o = !!(s && s.interactive),
-            l = s ? s.name : void 0,
-            u = a("clipHeight"),
-            c = a("symbolOffset"),
+    function gle(e, t, n, i, r) {
+        const s = ui(e, t),
+            a = n.entries,
+            o = !!(a && a.interactive),
+            l = a ? a.name : void 0,
+            u = s("clipHeight"),
+            c = s("symbolOffset"),
             f = {
                 data: "value"
             },
-            h = `(${r}) ? datum.${Ule} : datum.${gx}`,
-            d = u ? Wt(u) : {
-                field: gx
+            h = `(${r}) ? datum.${Joe} : datum.${U2}`,
+            d = u ? jt(u) : {
+                field: U2
             },
-            g = `datum.${hx}`,
+            g = `datum.${B2}`,
             p = `max(1, ${r})`;
         let m, y, v, b, x;
         d.mult = .5, m = {
             enter: y = {
-                opacity: je,
+                opacity: Le,
                 x: {
                     signal: h,
                     mult: .5,
                     offset: c
                 },
                 y: d
             },
             update: v = {
-                opacity: Ni,
+                opacity: Oi,
                 x: y.x,
                 y: y.y
             },
             exit: {
-                opacity: je
+                opacity: Le
             }
         };
         let _ = null,
             S = null;
-        e.fill || (_ = t.symbolBaseFillColor, S = t.symbolBaseStrokeColor), nn(m, {
-            fill: a("symbolFillColor", _),
-            shape: a("symbolType"),
-            size: a("symbolSize"),
-            stroke: a("symbolStrokeColor", S),
-            strokeDash: a("symbolDash"),
-            strokeDashOffset: a("symbolDashOffset"),
-            strokeWidth: a("symbolStrokeWidth")
+        e.fill || (_ = t.symbolBaseFillColor, S = t.symbolBaseStrokeColor), Zt(m, {
+            fill: s("symbolFillColor", _),
+            shape: s("symbolType"),
+            size: s("symbolSize"),
+            stroke: s("symbolStrokeColor", S),
+            strokeDash: s("symbolDash"),
+            strokeDashOffset: s("symbolDashOffset"),
+            strokeWidth: s("symbolStrokeWidth")
         }, {
-            opacity: a("symbolOpacity")
-        }), BE.forEach(C => {
+            opacity: s("symbolOpacity")
+        }), oE.forEach(C => {
             e[C] && (v[C] = y[C] = {
                 scale: e[C],
-                field: Pi
+                field: Mi
             })
         });
-        const w = Si({
-                type: Zle,
-                role: $oe,
-                key: Pi,
+        const w = _i({
+                type: ole,
+                role: Iae,
+                key: Mi,
                 from: f,
                 clip: u ? !0 : void 0,
                 encode: m
             }, n.symbols),
-            O = Wt(c);
-        O.offset = a("labelOffset"), m = {
+            E = jt(c);
+        E.offset = s("labelOffset"), m = {
             enter: y = {
-                opacity: je,
+                opacity: Le,
                 x: {
                     signal: h,
-                    offset: O
+                    offset: E
                 },
                 y: d
             },
             update: v = {
-                opacity: Ni,
+                opacity: Oi,
                 text: {
-                    field: jE
+                    field: sE
                 },
                 x: y.x,
                 y: y.y
             },
             exit: {
-                opacity: je
+                opacity: Le
             }
-        }, nn(m, {
-            align: a("labelAlign"),
-            baseline: a("labelBaseline"),
-            fill: a("labelColor"),
-            fillOpacity: a("labelOpacity"),
-            font: a("labelFont"),
-            fontSize: a("labelFontSize"),
-            fontStyle: a("labelFontStyle"),
-            fontWeight: a("labelFontWeight"),
-            limit: a("labelLimit")
+        }, Zt(m, {
+            align: s("labelAlign"),
+            baseline: s("labelBaseline"),
+            fill: s("labelColor"),
+            fillOpacity: s("labelOpacity"),
+            font: s("labelFont"),
+            fontSize: s("labelFontSize"),
+            fontStyle: s("labelFontStyle"),
+            fontWeight: s("labelFontWeight"),
+            limit: s("labelLimit")
         });
-        const k = Si({
-            type: ql,
-            role: EI,
-            style: Id,
-            key: Pi,
+        const A = _i({
+            type: Rl,
+            role: NL,
+            style: kd,
+            key: Mi,
             from: f,
             encode: m
         }, n.labels);
         return m = {
             enter: {
                 noBound: {
                     value: !u
                 },
-                width: je,
-                height: u ? Wt(u) : je,
-                opacity: je
+                width: Le,
+                height: u ? jt(u) : Le,
+                opacity: Le
             },
             exit: {
-                opacity: je
+                opacity: Le
             },
             update: v = {
-                opacity: Ni,
+                opacity: Oi,
                 row: {
                     signal: null
                 },
                 column: {
                     signal: null
                 }
             }
-        }, a.isVertical(!0) ? (b = `ceil(item.mark.items.length / ${p})`, v.row.signal = `${g}%${b}`, v.column.signal = `floor(${g} / ${b})`, x = {
+        }, s.isVertical(!0) ? (b = `ceil(item.mark.items.length / ${p})`, v.row.signal = `${g}%${b}`, v.column.signal = `floor(${g} / ${b})`, x = {
             field: ["row", g]
         }) : (v.row.signal = `floor(${g} / ${p})`, v.column.signal = `${g} % ${p}`, x = {
             field: g
         }), v.column.signal = `(${r})?${v.column.signal}:${g}`, i = {
             facet: {
                 data: i,
                 name: "value",
-                groupby: hx
+                groupby: B2
             }
-        }, Vh({
-            role: NE,
+        }, Lh({
+            role: nE,
             from: i,
-            encode: jc(m, s, jd),
-            marks: [w, k],
+            encode: Ac(m, a, Ad),
+            marks: [w, A],
             name: l,
             interactive: o,
             sort: x
         })
     }
 
-    function oue(e, t) {
-        const n = fi(e, t);
+    function ple(e, t) {
+        const n = ui(e, t);
         return {
             align: n("gridAlign"),
             columns: n.entryColumns(),
             center: {
                 row: !0,
                 column: !1
             },
             padding: {
                 row: n("rowPadding"),
                 column: n("columnPadding")
             }
         }
     }
-    const qE = 'item.orient === "left"',
-        WE = 'item.orient === "right"',
-        N1 = `(${qE} || ${WE})`,
-        lue = `datum.vgrad && ${N1}`,
-        uue = P1('"top"', '"bottom"', '"middle"'),
-        cue = P1('"right"', '"left"', '"center"'),
-        fue = `datum.vgrad && ${WE} ? (${cue}) : (${N1} && !(datum.vgrad && ${qE})) ? "left" : ${UE}`,
-        hue = `item._anchor || (${N1} ? "middle" : "start")`,
-        due = `${lue} ? (${qE} ? -90 : 90) : 0`,
-        gue = `${N1} ? (datum.vgrad ? (${WE} ? "bottom" : "top") : ${uue}) : "top"`;
+    const cE = 'item.orient === "left"',
+        fE = 'item.orient === "right"',
+        y1 = `(${cE} || ${fE})`,
+        mle = `datum.vgrad && ${y1}`,
+        yle = m1('"top"', '"bottom"', '"middle"'),
+        vle = m1('"right"', '"left"', '"center"'),
+        ble = `datum.vgrad && ${fE} ? (${vle}) : (${y1} && !(datum.vgrad && ${cE})) ? "left" : ${uE}`,
+        xle = `item._anchor || (${y1} ? "middle" : "start")`,
+        _le = `${mle} ? (${cE} ? -90 : 90) : 0`,
+        wle = `${y1} ? (datum.vgrad ? (${fE} ? "bottom" : "top") : ${yle}) : "top"`;
 
-    function pue(e, t, n, i) {
-        const r = fi(e, t),
-            a = {
+    function Sle(e, t, n, i) {
+        const r = ui(e, t),
+            s = {
                 enter: {
-                    opacity: je
+                    opacity: Le
                 },
                 update: {
-                    opacity: Ni,
+                    opacity: Oi,
                     x: {
                         field: {
                             group: "padding"
                         }
                     },
                     y: {
                         field: {
                             group: "padding"
                         }
                     }
                 },
                 exit: {
-                    opacity: je
+                    opacity: Le
                 }
             };
-        return nn(a, {
+        return Zt(s, {
             orient: r("titleOrient"),
             _anchor: r("titleAnchor"),
             anchor: {
-                signal: hue
+                signal: xle
             },
             angle: {
-                signal: due
+                signal: _le
             },
             align: {
-                signal: fue
+                signal: ble
             },
             baseline: {
-                signal: gue
+                signal: wle
             },
             text: e.title,
             fill: r("titleColor"),
             fillOpacity: r("titleOpacity"),
             font: r("titleFont"),
             fontSize: r("titleFontSize"),
             fontStyle: r("titleFontStyle"),
             fontWeight: r("titleFontWeight"),
             limit: r("titleLimit"),
             lineHeight: r("titleLineHeight")
         }, {
             align: r("titleAlign"),
             baseline: r("titleBaseline")
-        }), Si({
-            type: ql,
-            role: Moe,
-            style: zE,
+        }), _i({
+            type: Rl,
+            role: zae,
+            style: aE,
             from: i,
-            encode: a
+            encode: s
         }, n)
     }
 
-    function mue(e, t) {
+    function Ele(e, t) {
         let n;
-        return se(e) && (e.signal ? n = e.signal : e.path ? n = "pathShape(" + K3(e.path) + ")" : e.sphere && (n = "geoShape(" + K3(e.sphere) + ', {type: "Sphere"})')), n ? t.signalRef(n) : !!e
+        return ae(e) && (e.signal ? n = e.signal : e.path ? n = "pathShape(" + c5(e.path) + ")" : e.sphere && (n = "geoShape(" + c5(e.sphere) + ', {type: "Sphere"})')), n ? t.signalRef(n) : !!e
     }
 
-    function K3(e) {
-        return se(e) && e.signal ? e.signal : Z(e)
+    function c5(e) {
+        return ae(e) && e.signal ? e.signal : Z(e)
     }
 
-    function qI(e) {
+    function tI(e) {
         const t = e.role || "";
-        return !t.indexOf("axis") || !t.indexOf("legend") || !t.indexOf("title") ? t : e.type === R1 ? NE : t || RE
+        return !t.indexOf("axis") || !t.indexOf("legend") || !t.indexOf("title") ? t : e.type === p1 ? nE : t || eE
     }
 
-    function yue(e) {
+    function Cle(e) {
         return {
             marktype: e.type,
             name: e.name || void 0,
-            role: e.role || qI(e),
+            role: e.role || tI(e),
             zindex: +e.zindex || void 0,
             aria: e.aria,
             description: e.description
         }
     }
 
-    function vue(e, t) {
+    function kle(e, t) {
         return e && e.signal ? t.signalRef(e.signal) : e !== !1
     }
 
-    function HE(e, t) {
-        const n = LP(e.type);
-        n || G("Unrecognized transform type: " + Z(e.type));
-        const i = M1(n.type.toLowerCase(), null, WI(n, e, t));
+    function hE(e, t) {
+        const n = XD(e.type);
+        n || U("Unrecognized transform type: " + Z(e.type));
+        const i = h1(n.type.toLowerCase(), null, nI(n, e, t));
         return e.signal && t.addSignal(e.signal, t.proxy(i)), i.metadata = n.metadata || {}, i
     }
 
-    function WI(e, t, n) {
+    function nI(e, t, n) {
         const i = {},
             r = e.params.length;
-        for (let a = 0; a < r; ++a) {
-            const s = e.params[a];
-            i[s.name] = bue(s, t, n)
+        for (let s = 0; s < r; ++s) {
+            const a = e.params[s];
+            i[a.name] = Ale(a, t, n)
         }
         return i
     }
 
-    function bue(e, t, n) {
+    function Ale(e, t, n) {
         const i = e.type,
             r = t[e.name];
-        if (i === "index") return xue(e, t, n);
+        if (i === "index") return $le(e, t, n);
         if (r === void 0) {
-            e.required && G("Missing required " + Z(t.type) + " parameter: " + Z(e.name));
+            e.required && U("Missing required " + Z(t.type) + " parameter: " + Z(e.name));
             return
         } else {
-            if (i === "param") return _ue(e, t, n);
+            if (i === "param") return Tle(e, t, n);
             if (i === "projection") return n.projectionRef(t[e.name])
         }
-        return e.array && !Nt(r) ? r.map(a => J3(e, a, n)) : J3(e, r, n)
+        return e.array && !Ft(r) ? r.map(s => f5(e, s, n)) : f5(e, r, n)
     }
 
-    function J3(e, t, n) {
+    function f5(e, t, n) {
         const i = e.type;
-        if (Nt(t)) return Z3(i) ? G("Expression references can not be signals.") : Wv(i) ? n.fieldRef(t) : e$(i) ? n.compareRef(t) : n.signalRef(t.signal); {
-            const r = e.expr || Wv(i);
-            return r && wue(t) ? n.exprRef(t.expr, t.as) : r && Sue(t) ? Yh(t.field, t.as) : Z3(i) ? ta(t, n) : Eue(i) ? he(n.getData(t).values) : Wv(i) ? Yh(t) : e$(i) ? n.compareRef(t) : t
+        if (Ft(t)) return d5(i) ? U("Expression references can not be signals.") : Sv(i) ? n.fieldRef(t) : g5(i) ? n.compareRef(t) : n.signalRef(t.signal); {
+            const r = e.expr || Sv(i);
+            return r && Mle(t) ? n.exprRef(t.expr, t.as) : r && Ole(t) ? Nh(t.field, t.as) : d5(i) ? Xr(t, n) : Fle(i) ? de(n.getData(t).values) : Sv(i) ? Nh(t) : g5(i) ? n.compareRef(t) : t
         }
     }
 
-    function xue(e, t, n) {
-        return re(t.from) || G('Lookup "from" parameter must be a string literal.'), n.getData(t.from).lookupRef(n, t.key)
+    function $le(e, t, n) {
+        return re(t.from) || U('Lookup "from" parameter must be a string literal.'), n.getData(t.from).lookupRef(n, t.key)
     }
 
-    function _ue(e, t, n) {
+    function Tle(e, t, n) {
         const i = t[e.name];
-        return e.array ? (q(i) || G("Expected an array of sub-parameters. Instead: " + Z(i)), i.map(r => Q3(e, r, n))) : Q3(e, i, n)
+        return e.array ? (W(i) || U("Expected an array of sub-parameters. Instead: " + Z(i)), i.map(r => h5(e, r, n))) : h5(e, i, n)
     }
 
-    function Q3(e, t, n) {
+    function h5(e, t, n) {
         const i = e.params.length;
         let r;
-        for (let s = 0; s < i; ++s) {
-            r = e.params[s];
+        for (let a = 0; a < i; ++a) {
+            r = e.params[a];
             for (const o in r.key)
                 if (r.key[o] !== t[o]) {
                     r = null;
                     break
                 } if (r) break
         }
-        r || G("Unsupported parameter: " + Z(t));
-        const a = ke(WI(r, t, n), r.key);
-        return he(n.add(vle(a)))
-    }
-    const wue = e => e && e.expr,
-        Sue = e => e && e.field,
-        Eue = e => e === "data",
-        Z3 = e => e === "expr",
-        Wv = e => e === "field",
-        e$ = e => e === "compare";
-
-    function Oue(e, t, n) {
-        let i, r, a, s, o;
-        return e ? (i = e.facet) && (t || G("Only group marks can be faceted."), i.field != null ? s = o = Mp(i, n) : (e.data ? o = he(n.getData(e.data).aggregate) : (a = HE(ke({
+        r || U("Unsupported parameter: " + Z(t));
+        const s = Ae(nI(r, t, n), r.key);
+        return de(n.add(koe(s)))
+    }
+    const Mle = e => e && e.expr,
+        Ole = e => e && e.field,
+        Fle = e => e === "data",
+        d5 = e => e === "expr",
+        Sv = e => e === "field",
+        g5 = e => e === "compare";
+
+    function Rle(e, t, n) {
+        let i, r, s, a, o;
+        return e ? (i = e.facet) && (t || U("Only group marks can be faceted."), i.field != null ? a = o = dp(i, n) : (e.data ? o = de(n.getData(e.data).aggregate) : (s = hE(Ae({
             type: "aggregate",
-            groupby: ie(i.groupby)
-        }, i.aggregate), n), a.params.key = n.keyRef(i.groupby), a.params.pulse = Mp(i, n), s = o = he(n.add(a))), r = n.keyRef(i.groupby, !0))) : s = he(n.add(Or(null, [{}]))), s || (s = Mp(e, n)), {
+            groupby: se(i.groupby)
+        }, i.aggregate), n), s.params.key = n.keyRef(i.groupby), s.params.pulse = dp(i, n), a = o = de(n.add(s))), r = n.keyRef(i.groupby, !0))) : a = de(n.add(vr(null, [{}]))), a || (a = dp(e, n)), {
             key: r,
-            pulse: s,
+            pulse: a,
             parent: o
         }
     }
 
-    function Mp(e, t) {
-        return e.$ref ? e : e.data && e.data.$ref ? e.data : he(t.getData(e.data).output)
+    function dp(e, t) {
+        return e.$ref ? e : e.data && e.data.$ref ? e.data : de(t.getData(e.data).output)
     }
 
-    function vl(e, t, n, i, r) {
+    function al(e, t, n, i, r) {
         this.scope = e, this.input = t, this.output = n, this.values = i, this.aggregate = r, this.index = {}
     }
-    vl.fromEntries = function(e, t) {
+    al.fromEntries = function(e, t) {
         const n = t.length,
             i = t[n - 1],
             r = t[n - 2];
-        let a = t[0],
-            s = null,
+        let s = t[0],
+            a = null,
             o = 1;
-        for (a && a.type === "load" && (a = t[1]), e.add(t[0]); o < n; ++o) t[o].params.pulse = he(t[o - 1]), e.add(t[o]), t[o].type === "aggregate" && (s = t[o]);
-        return new vl(e, a, r, i, s)
+        for (s && s.type === "load" && (s = t[1]), e.add(t[0]); o < n; ++o) t[o].params.pulse = de(t[o - 1]), e.add(t[o]), t[o].type === "aggregate" && (a = t[o]);
+        return new al(e, s, r, i, a)
     };
 
-    function HI(e) {
+    function iI(e) {
         return re(e) ? e : null
     }
 
-    function t$(e, t, n) {
-        const i = F1(n.op, n.field);
+    function p5(e, t, n) {
+        const i = d1(n.op, n.field);
         let r;
         if (t.ops) {
-            for (let a = 0, s = t.as.length; a < s; ++a)
-                if (t.as[a] === i) return
+            for (let s = 0, a = t.as.length; s < a; ++s)
+                if (t.as[s] === i) return
         } else t.ops = ["count"], t.fields = [null], t.as = ["count"];
         n.op && (t.ops.push((r = n.op.signal) ? e.signalRef(r) : n.op), t.fields.push(e.fieldRef(n.field)), t.as.push(i))
     }
 
-    function _f(e, t, n, i, r, a, s) {
+    function lf(e, t, n, i, r, s, a) {
         const o = t[n] || (t[n] = {}),
-            l = Xoe(a);
-        let u = HI(r),
+            l = noe(s);
+        let u = iI(r),
             c, f;
         if (u != null && (e = t.scope, u = u + (l ? "|" + l : ""), c = o[u]), !c) {
-            const h = a ? {
-                field: ux,
-                pulse: t.countsRef(e, r, a)
+            const h = s ? {
+                field: L2,
+                pulse: t.countsRef(e, r, s)
             } : {
                 field: e.fieldRef(r),
-                pulse: he(t.output)
+                pulse: de(t.output)
             };
-            l && (h.sort = e.sortRef(a)), f = e.add(M1(i, void 0, h)), s && (t.index[r] = f), c = he(f), u != null && (o[u] = c)
+            l && (h.sort = e.sortRef(s)), f = e.add(h1(i, void 0, h)), a && (t.index[r] = f), c = de(f), u != null && (o[u] = c)
         }
         return c
     }
-    vl.prototype = {
+    al.prototype = {
         countsRef(e, t, n) {
             const i = this,
                 r = i.counts || (i.counts = {}),
-                a = HI(t);
-            let s, o, l;
-            return a != null && (e = i.scope, s = r[a]), s ? n && n.field && t$(e, s.agg.params, n) : (l = {
+                s = iI(t);
+            let a, o, l;
+            return s != null && (e = i.scope, a = r[s]), a ? n && n.field && p5(e, a.agg.params, n) : (l = {
                 groupby: e.fieldRef(t, "key"),
-                pulse: he(i.output)
-            }, n && n.field && t$(e, l, n), o = e.add($I(l)), s = e.add(Or({
-                pulse: he(o)
-            })), s = {
+                pulse: de(i.output)
+            }, n && n.field && p5(e, l, n), o = e.add(jL(l)), a = e.add(vr({
+                pulse: de(o)
+            })), a = {
                 agg: o,
-                ref: he(s)
-            }, a != null && (r[a] = s)), s.ref
+                ref: de(a)
+            }, s != null && (r[s] = a)), a.ref
         },
         tuplesRef() {
-            return he(this.values)
+            return de(this.values)
         },
         extentRef(e, t) {
-            return _f(e, this, "extent", "extent", t, !1)
+            return lf(e, this, "extent", "extent", t, !1)
         },
         domainRef(e, t) {
-            return _f(e, this, "domain", "values", t, !1)
+            return lf(e, this, "domain", "values", t, !1)
         },
         valuesRef(e, t, n) {
-            return _f(e, this, "vals", "values", t, n || !0)
+            return lf(e, this, "vals", "values", t, n || !0)
         },
         lookupRef(e, t) {
-            return _f(e, this, "lookup", "tupleindex", t, !1)
+            return lf(e, this, "lookup", "tupleindex", t, !1)
         },
         indataRef(e, t) {
-            return _f(e, this, "indata", "tupleindex", t, !0, !0)
+            return lf(e, this, "indata", "tupleindex", t, !0, !0)
         }
     };
 
-    function Cue(e, t, n) {
+    function Dle(e, t, n) {
         const i = e.from.facet,
             r = i.name,
-            a = Mp(i, t);
-        let s;
-        i.name || G("Facet must have a name: " + Z(i)), i.data || G("Facet must reference a data set: " + Z(i)), i.field ? s = t.add(DI({
+            s = dp(i, t);
+        let a;
+        i.name || U("Facet must have a name: " + Z(i)), i.data || U("Facet must reference a data set: " + Z(i)), i.field ? a = t.add(WL({
             field: t.fieldRef(i.field),
-            pulse: a
-        })) : i.groupby ? s = t.add(ule({
+            pulse: s
+        })) : i.groupby ? a = t.add(yoe({
             key: t.keyRef(i.groupby),
-            group: he(t.proxy(n.parent)),
-            pulse: a
-        })) : G("Facet must specify groupby or field: " + Z(i));
+            group: de(t.proxy(n.parent)),
+            pulse: s
+        })) : U("Facet must specify groupby or field: " + Z(i));
         const o = t.fork(),
-            l = o.add(Or()),
-            u = o.add(Ul({
-                pulse: he(l)
+            l = o.add(vr()),
+            u = o.add(Fl({
+                pulse: de(l)
             }));
-        o.addData(r, new vl(o, l, l, u)), o.addSignal("parent", null), s.params.subflow = {
+        o.addData(r, new al(o, l, l, u)), o.addSignal("parent", null), a.params.subflow = {
             $subflow: o.parse(e).toRuntime()
         }
     }
 
-    function kue(e, t, n) {
-        const i = t.add(DI({
+    function Nle(e, t, n) {
+        const i = t.add(WL({
                 pulse: n.pulse
             })),
             r = t.fork();
-        r.add(Ul()), r.addSignal("parent", null), i.params.subflow = {
+        r.add(Fl()), r.addSignal("parent", null), i.params.subflow = {
             $subflow: r.parse(e).toRuntime()
         }
     }
 
-    function YI(e, t, n) {
+    function rI(e, t, n) {
         const i = e.remove,
             r = e.insert,
-            a = e.toggle,
-            s = e.modify,
+            s = e.toggle,
+            a = e.modify,
             o = e.values,
-            l = t.add(Z0()),
-            u = "if(" + e.trigger + ',modify("' + n + '",' + [r, i, a, s, o].map(f => f ?? "null").join(",") + "),0)",
-            c = ta(u, t);
+            l = t.add(D0()),
+            u = "if(" + e.trigger + ',modify("' + n + '",' + [r, i, s, a, o].map(f => f ?? "null").join(",") + "),0)",
+            c = Xr(u, t);
         l.update = c.$expr, l.params = c.$params
     }
 
-    function L1(e, t) {
-        const n = qI(e),
-            i = e.type === R1,
+    function v1(e, t) {
+        const n = tI(e),
+            i = e.type === p1,
             r = e.from && e.from.facet,
-            a = e.overlap;
-        let s = e.layout || n === NE || n === PE,
+            s = e.overlap;
+        let a = e.layout || n === nE || n === tE,
             o, l, u, c, f, h, d;
-        const g = n === RE || s || r,
-            p = Oue(e.from, i, t);
-        l = t.add(ole({
-            key: p.key || (e.key ? Yh(e.key) : void 0),
+        const g = n === eE || a || r,
+            p = Rle(e.from, i, t);
+        l = t.add(poe({
+            key: p.key || (e.key ? Nh(e.key) : void 0),
             pulse: p.pulse,
             clean: !i
         }));
-        const m = he(l);
-        l = u = t.add(Or({
+        const m = de(l);
+        l = u = t.add(vr({
             pulse: m
-        })), l = t.add(gle({
-            markdef: yue(e),
-            interactive: vue(e.interactive, t),
-            clip: mue(e.clip, t),
+        })), l = t.add(woe({
+            markdef: Cle(e),
+            interactive: kle(e.interactive, t),
+            clip: Ele(e.clip, t),
             context: {
                 $context: !0
             },
             groups: t.lookup(),
             parent: t.signals.parent ? t.signalRef("parent") : null,
             index: t.markpath(),
-            pulse: he(l)
+            pulse: de(l)
         }));
-        const y = he(l);
-        l = c = t.add(FI(AI(e.encode, e.type, n, e.style, t, {
+        const y = de(l);
+        l = c = t.add(GL(zL(e.encode, e.type, n, e.style, t, {
             mod: !1,
             pulse: y
         }))), l.params.parent = t.encode(), e.transform && e.transform.forEach(S => {
-            const w = HE(S, t),
-                O = w.metadata;
-            (O.generates || O.changes) && G("Mark transforms should not generate new data."), O.nomod || (c.params.mod = !0), w.params.pulse = he(l), t.add(l = w)
-        }), e.sort && (l = t.add(Sle({
+            const w = hE(S, t),
+                E = w.metadata;
+            (E.generates || E.changes) && U("Mark transforms should not generate new data."), E.nomod || (c.params.mod = !0), w.params.pulse = de(l), t.add(l = w)
+        }), e.sort && (l = t.add(Ooe({
             sort: t.compareRef(e.sort),
-            pulse: he(l)
+            pulse: de(l)
         })));
-        const v = he(l);
-        (r || s) && (s = t.add(PI({
+        const v = de(l);
+        (r || a) && (a = t.add(HL({
             layout: t.objectProperty(e.layout),
             legends: t.legends,
             mark: y,
             pulse: v
-        })), h = he(s));
-        const b = t.add(MI({
+        })), h = de(a));
+        const b = t.add(UL({
             mark: y,
             pulse: h || v
         }));
-        d = he(b), i && (g && (o = t.operators, o.pop(), s && o.pop()), t.pushState(v, h || d, m), r ? Cue(e, t, p) : g ? kue(e, t, p) : t.parse(e), t.popState(), g && (s && o.push(s), o.push(b))), a && (d = Aue(a, d, t));
-        const x = t.add(RI({
+        d = de(b), i && (g && (o = t.operators, o.pop(), a && o.pop()), t.pushState(v, h || d, m), r ? Dle(e, t, p) : g ? Nle(e, t, p) : t.parse(e), t.popState(), g && (a && o.push(a), o.push(b))), s && (d = Ple(s, d, t));
+        const x = t.add(qL({
                 pulse: d
             })),
-            _ = t.add(Ul({
-                pulse: he(x)
+            _ = t.add(Fl({
+                pulse: de(x)
             }, void 0, t.parent()));
-        e.name != null && (f = e.name, t.addData(f, new vl(t, u, x, _)), e.on && e.on.forEach(S => {
-            (S.insert || S.remove || S.toggle) && G("Marks only support modify triggers."), YI(S, t, f)
+        e.name != null && (f = e.name, t.addData(f, new al(t, u, x, _)), e.on && e.on.forEach(S => {
+            (S.insert || S.remove || S.toggle) && U("Marks only support modify triggers."), rI(S, t, f)
         }))
     }
 
-    function Aue(e, t, n) {
+    function Ple(e, t, n) {
         const i = e.method,
             r = e.bound,
-            a = e.separation,
-            s = {
-                separation: Nt(a) ? n.signalRef(a.signal) : a,
-                method: Nt(i) ? n.signalRef(i.signal) : i,
+            s = e.separation,
+            a = {
+                separation: Ft(s) ? n.signalRef(s.signal) : s,
+                method: Ft(i) ? n.signalRef(i.signal) : i,
                 pulse: t
             };
-        if (e.order && (s.sort = n.compareRef({
+        if (e.order && (a.sort = n.compareRef({
                 field: e.order
             })), r) {
             const o = r.tolerance;
-            s.boundTolerance = Nt(o) ? n.signalRef(o.signal) : +o, s.boundScale = n.scaleRef(r.scale), s.boundOrient = r.orient
+            a.boundTolerance = Ft(o) ? n.signalRef(o.signal) : +o, a.boundScale = n.scaleRef(r.scale), a.boundOrient = r.orient
         }
-        return he(n.add(yle(s)))
+        return de(n.add(Coe(a)))
     }
 
-    function Tue(e, t) {
+    function Lle(e, t) {
         const n = t.config.legend,
             i = e.encode || {},
-            r = fi(e, n),
-            a = i.legend || {},
-            s = a.name || void 0,
-            o = a.interactive,
-            l = a.style,
+            r = ui(e, n),
+            s = i.legend || {},
+            a = s.name || void 0,
+            o = s.interactive,
+            l = s.style,
             u = {};
         let c = 0,
             f, h, d;
-        BE.forEach(b => e[b] ? (u[b] = e[b], c = c || e[b]) : 0), c || G("Missing valid scale for legend.");
-        const g = $ue(e, t.scaleType(c)),
+        oE.forEach(b => e[b] ? (u[b] = e[b], c = c || e[b]) : 0), c || U("Missing valid scale for legend.");
+        const g = Ile(e, t.scaleType(c)),
             p = {
                 title: e.title != null,
                 scales: u,
                 type: g,
                 vgrad: g !== "symbol" && r.isVertical()
             },
-            m = he(t.add(Or(null, [p]))),
+            m = de(t.add(vr(null, [p]))),
             y = {
                 enter: {
                     x: {
                         value: 0
                     },
                     y: {
                         value: 0
                     }
                 }
             },
-            v = he(t.add(hle(h = {
+            v = de(t.add(xoe(h = {
                 type: g,
                 scale: t.scaleRef(c),
                 count: t.objectProperty(r("tickCount")),
                 limit: t.property(r("symbolLimit")),
                 values: t.objectProperty(e.values),
                 minstep: t.property(e.tickMinStep),
                 formatType: t.property(e.formatType),
                 formatSpecifier: t.property(e.format)
             })));
-        return g === $p ? (d = [nue(e, c, n, i.gradient), V3(e, n, i.labels, v)], h.count = h.count || t.signalRef(`max(2,2*floor((${il(r.gradientLength())})/100))`)) : g === dx ? d = [iue(e, c, n, i.gradient, v), V3(e, n, i.labels, v)] : (f = oue(e, n), d = [sue(e, n, i, v, il(f.columns))], h.size = Due(e, t, d[0].marks)), d = [Vh({
-            role: Aoe,
+        return g === hp ? (d = [cle(e, c, n, i.gradient), u5(e, n, i.labels, v)], h.count = h.count || t.signalRef(`max(2,2*floor((${Wo(r.gradientLength())})/100))`)) : g === j2 ? d = [fle(e, c, n, i.gradient, v), u5(e, n, i.labels, v)] : (f = ple(e, n), d = [gle(e, n, i, v, Wo(f.columns))], h.size = jle(e, t, d[0].marks)), d = [Lh({
+            role: Pae,
             from: m,
             encode: y,
             marks: d,
             layout: f,
             interactive: o
-        })], p.title && d.push(pue(e, n, i.title, m)), L1(Vh({
-            role: Coe,
+        })], p.title && d.push(Sle(e, n, i.title, m)), v1(Lh({
+            role: Dae,
             from: m,
-            encode: jc(Fue(r, e, n), a, jd),
+            encode: Ac(Ble(r, e, n), s, Ad),
             marks: d,
             aria: r("aria"),
             description: r("description"),
             zindex: r("zindex"),
-            name: s,
+            name: a,
             interactive: o,
             style: l
         }), t)
     }
 
-    function $ue(e, t) {
-        let n = e.type || X3;
-        return !e.type && Mue(e) === 1 && (e.fill || e.stroke) && (n = eS(t) ? $p : A2(t) ? dx : X3), n !== $p ? n : A2(t) ? dx : $p
+    function Ile(e, t) {
+        let n = e.type || l5;
+        return !e.type && zle(e) === 1 && (e.fill || e.stroke) && (n = xw(t) ? hp : n2(t) ? j2 : l5), n !== hp ? n : n2(t) ? j2 : hp
     }
 
-    function Mue(e) {
-        return BE.reduce((t, n) => t + (e[n] ? 1 : 0), 0)
+    function zle(e) {
+        return oE.reduce((t, n) => t + (e[n] ? 1 : 0), 0)
     }
 
-    function Fue(e, t, n) {
+    function Ble(e, t, n) {
         const i = {
             enter: {},
             update: {}
         };
-        return nn(i, {
+        return Zt(i, {
             orient: e("orient"),
             offset: e("offset"),
             padding: e("padding"),
             titlePadding: e("titlePadding"),
             cornerRadius: e("cornerRadius"),
             fill: e("fillColor"),
             stroke: e("strokeColor"),
@@ -34094,107 +34115,107 @@
             x: e("legendX"),
             y: e("legendY"),
             format: t.format,
             formatType: t.formatType
         }), i
     }
 
-    function Due(e, t, n) {
-        const i = il(n$("size", e, n)),
-            r = il(n$("strokeWidth", e, n)),
-            a = il(Rue(n[1].encode, t, Id));
-        return ta(`max(ceil(sqrt(${i})+${r}),${a})`, t)
+    function jle(e, t, n) {
+        const i = Wo(m5("size", e, n)),
+            r = Wo(m5("strokeWidth", e, n)),
+            s = Wo(Ule(n[1].encode, t, kd));
+        return Xr(`max(ceil(sqrt(${i})+${r}),${s})`, t)
     }
 
-    function n$(e, t, n) {
-        return t[e] ? `scale("${t[e]}",datum)` : GI(e, n[0].encode)
+    function m5(e, t, n) {
+        return t[e] ? `scale("${t[e]}",datum)` : ZL(e, n[0].encode)
     }
 
-    function Rue(e, t, n) {
-        return GI("fontSize", e) || eue("fontSize", t, n)
+    function Ule(e, t, n) {
+        return ZL("fontSize", e) || lle("fontSize", t, n)
     }
-    const Pue = `item.orient==="${zc}"?-90:item.orient==="${Bc}"?90:0`;
+    const Gle = `item.orient==="${$c}"?-90:item.orient==="${Tc}"?90:0`;
 
-    function Nue(e, t) {
+    function Wle(e, t) {
         e = re(e) ? {
             text: e
         } : e;
-        const n = fi(e, t.config.title),
+        const n = ui(e, t.config.title),
             i = e.encode || {},
             r = i.group || {},
-            a = r.name || void 0,
-            s = r.interactive,
+            s = r.name || void 0,
+            a = r.interactive,
             o = r.style,
             l = [],
             u = {},
-            c = he(t.add(Or(null, [u])));
-        return l.push(jue(e, n, Lue(e), c)), e.subtitle && l.push(zue(e, n, i.subtitle, c)), L1(Vh({
-            role: Foe,
+            c = de(t.add(vr(null, [u])));
+        return l.push(Yle(e, n, qle(e), c)), e.subtitle && l.push(Xle(e, n, i.subtitle, c)), v1(Lh({
+            role: Bae,
             from: c,
-            encode: Iue(n, r),
+            encode: Hle(n, r),
             marks: l,
             aria: n("aria"),
             description: n("description"),
             zindex: n("zindex"),
-            name: a,
-            interactive: s,
+            name: s,
+            interactive: a,
             style: o
         }), t)
     }
 
-    function Lue(e) {
+    function qle(e) {
         const t = e.encode;
-        return t && t.title || ke({
+        return t && t.title || Ae({
             name: e.name,
             interactive: e.interactive,
             style: e.style
         }, t)
     }
 
-    function Iue(e, t) {
+    function Hle(e, t) {
         const n = {
             enter: {},
             update: {}
         };
-        return nn(n, {
+        return Zt(n, {
             orient: e("orient"),
             anchor: e("anchor"),
             align: {
-                signal: UE
+                signal: uE
             },
             angle: {
-                signal: Pue
+                signal: Gle
             },
             limit: e("limit"),
             frame: e("frame"),
             offset: e("offset") || 0,
             padding: e("subtitlePadding")
-        }), jc(n, t, jd)
+        }), Ac(n, t, Ad)
     }
 
-    function jue(e, t, n, i) {
+    function Yle(e, t, n, i) {
         const r = {
                 value: 0
             },
-            a = e.text,
-            s = {
+            s = e.text,
+            a = {
                 enter: {
                     opacity: r
                 },
                 update: {
                     opacity: {
                         value: 1
                     }
                 },
                 exit: {
                     opacity: r
                 }
             };
-        return nn(s, {
-            text: a,
+        return Zt(a, {
+            text: s,
             align: {
                 signal: "item.mark.group.align"
             },
             angle: {
                 signal: "item.mark.group.angle"
             },
             limit: {
@@ -34209,43 +34230,43 @@
             fontStyle: t("fontStyle"),
             fontWeight: t("fontWeight"),
             lineHeight: t("lineHeight")
         }, {
             align: t("align"),
             angle: t("angle"),
             baseline: t("baseline")
-        }), Si({
-            type: ql,
-            role: Doe,
-            style: Wle,
+        }), _i({
+            type: Rl,
+            role: jae,
+            style: Zoe,
             from: i,
-            encode: s
+            encode: a
         }, n)
     }
 
-    function zue(e, t, n, i) {
+    function Xle(e, t, n, i) {
         const r = {
                 value: 0
             },
-            a = e.subtitle,
-            s = {
+            s = e.subtitle,
+            a = {
                 enter: {
                     opacity: r
                 },
                 update: {
                     opacity: {
                         value: 1
                     }
                 },
                 exit: {
                     opacity: r
                 }
             };
-        return nn(s, {
-            text: a,
+        return Zt(a, {
+            text: s,
             align: {
                 signal: "item.mark.group.align"
             },
             angle: {
                 signal: "item.mark.group.angle"
             },
             limit: {
@@ -34260,240 +34281,240 @@
             fontStyle: t("subtitleFontStyle"),
             fontWeight: t("subtitleFontWeight"),
             lineHeight: t("subtitleLineHeight")
         }, {
             align: t("align"),
             angle: t("angle"),
             baseline: t("baseline")
-        }), Si({
-            type: ql,
-            role: Roe,
-            style: Hle,
+        }), _i({
+            type: Rl,
+            role: Uae,
+            style: ele,
             from: i,
-            encode: s
+            encode: a
         }, n)
     }
 
-    function Bue(e, t) {
+    function Vle(e, t) {
         const n = [];
         e.transform && e.transform.forEach(i => {
-            n.push(HE(i, t))
+            n.push(hE(i, t))
         }), e.on && e.on.forEach(i => {
-            YI(i, t, e.name)
-        }), t.addDataPipeline(e.name, Gue(e, t, n))
+            rI(i, t, e.name)
+        }), t.addDataPipeline(e.name, Kle(e, t, n))
     }
 
-    function Gue(e, t, n) {
+    function Kle(e, t, n) {
         const i = [];
         let r = null,
-            a = !1,
             s = !1,
+            a = !1,
             o, l, u, c, f;
-        for (e.values ? Nt(e.values) || Ap(e.format) ? (i.push(i$(t, e)), i.push(r = ko())) : i.push(r = ko({
+        for (e.values ? Ft(e.values) || cp(e.format) ? (i.push(y5(t, e)), i.push(r = po())) : i.push(r = po({
                 $ingest: e.values,
                 $format: e.format
-            })) : e.url ? Ap(e.url) || Ap(e.format) ? (i.push(i$(t, e)), i.push(r = ko())) : i.push(r = ko({
+            })) : e.url ? cp(e.url) || cp(e.format) ? (i.push(y5(t, e)), i.push(r = po())) : i.push(r = po({
                 $request: e.url,
                 $format: e.format
-            })) : e.source && (r = o = ie(e.source).map(h => he(t.getData(h).output)), i.push(null)), l = 0, u = n.length; l < u; ++l) c = n[l], f = c.metadata, !r && !f.source && i.push(r = ko()), i.push(c), f.generates && (s = !0), f.modifies && !s && (a = !0), f.source ? r = c : f.changes && (r = null);
-        return o && (u = o.length - 1, i[0] = _le({
-            derive: a,
+            })) : e.source && (r = o = se(e.source).map(h => de(t.getData(h).output)), i.push(null)), l = 0, u = n.length; l < u; ++l) c = n[l], f = c.metadata, !r && !f.source && i.push(r = po()), i.push(c), f.generates && (a = !0), f.modifies && !a && (s = !0), f.source ? r = c : f.changes && (r = null);
+        return o && (u = o.length - 1, i[0] = Toe({
+            derive: s,
             pulse: u ? o : o[0]
-        }), (a || u) && i.splice(1, 0, ko())), r || i.push(ko()), i.push(Ul({})), i
+        }), (s || u) && i.splice(1, 0, po())), r || i.push(po()), i.push(Fl({})), i
     }
 
-    function ko(e) {
-        const t = Or({}, e);
+    function po(e) {
+        const t = vr({}, e);
         return t.metadata = {
             source: !0
         }, t
     }
 
-    function i$(e, t) {
-        return dle({
+    function y5(e, t) {
+        return _oe({
             url: t.url ? e.property(t.url) : void 0,
             async: t.async ? e.property(t.async) : void 0,
             values: t.values ? e.property(t.values) : void 0,
             format: e.objectProperty(t.format)
         })
     }
-    const XI = e => e === Vs || e === Cr,
-        I1 = (e, t, n) => Nt(e) ? Hue(e.signal, t, n) : e === zc || e === Cr ? t : n,
-        Ht = (e, t, n) => Nt(e) ? que(e.signal, t, n) : XI(e) ? t : n,
-        gr = (e, t, n) => Nt(e) ? Wue(e.signal, t, n) : XI(e) ? n : t,
-        VI = (e, t, n) => Nt(e) ? Yue(e.signal, t, n) : e === Cr ? {
+    const sI = e => e === za || e === br,
+        b1 = (e, t, n) => Ft(e) ? eue(e.signal, t, n) : e === $c || e === br ? t : n,
+        Ut = (e, t, n) => Ft(e) ? Qle(e.signal, t, n) : sI(e) ? t : n,
+        ar = (e, t, n) => Ft(e) ? Zle(e.signal, t, n) : sI(e) ? n : t,
+        aI = (e, t, n) => Ft(e) ? tue(e.signal, t, n) : e === br ? {
             value: t
         } : {
             value: n
         },
-        Uue = (e, t, n) => Nt(e) ? Xue(e.signal, t, n) : e === Bc ? {
+        Jle = (e, t, n) => Ft(e) ? nue(e.signal, t, n) : e === Tc ? {
             value: t
         } : {
             value: n
         },
-        que = (e, t, n) => KI(`${e} === '${Cr}' || ${e} === '${Vs}'`, t, n),
-        Wue = (e, t, n) => KI(`${e} !== '${Cr}' && ${e} !== '${Vs}'`, t, n),
-        Hue = (e, t, n) => YE(`${e} === '${zc}' || ${e} === '${Cr}'`, t, n),
-        Yue = (e, t, n) => YE(`${e} === '${Cr}'`, t, n),
-        Xue = (e, t, n) => YE(`${e} === '${Bc}'`, t, n),
-        KI = (e, t, n) => (t = t != null ? Wt(t) : t, n = n != null ? Wt(n) : n, r$(t) && r$(n) ? (t = t ? t.signal || Z(t.value) : null, n = n ? n.signal || Z(n.value) : null, {
+        Qle = (e, t, n) => oI(`${e} === '${br}' || ${e} === '${za}'`, t, n),
+        Zle = (e, t, n) => oI(`${e} !== '${br}' && ${e} !== '${za}'`, t, n),
+        eue = (e, t, n) => dE(`${e} === '${$c}' || ${e} === '${br}'`, t, n),
+        tue = (e, t, n) => dE(`${e} === '${br}'`, t, n),
+        nue = (e, t, n) => dE(`${e} === '${Tc}'`, t, n),
+        oI = (e, t, n) => (t = t != null ? jt(t) : t, n = n != null ? jt(n) : n, v5(t) && v5(n) ? (t = t ? t.signal || Z(t.value) : null, n = n ? n.signal || Z(n.value) : null, {
             signal: `${e} ? (${t}) : (${n})`
-        }) : [ke({
+        }) : [Ae({
             test: e
         }, t)].concat(n || [])),
-        r$ = e => e == null || Object.keys(e).length === 1,
-        YE = (e, t, n) => ({
-            signal: `${e} ? (${Cu(t)}) : (${Cu(n)})`
+        v5 = e => e == null || Object.keys(e).length === 1,
+        dE = (e, t, n) => ({
+            signal: `${e} ? (${pu(t)}) : (${pu(n)})`
         }),
-        Vue = (e, t, n, i, r) => ({
-            signal: (i != null ? `${e} === '${zc}' ? (${Cu(i)}) : ` : "") + (n != null ? `${e} === '${Vs}' ? (${Cu(n)}) : ` : "") + (r != null ? `${e} === '${Bc}' ? (${Cu(r)}) : ` : "") + (t != null ? `${e} === '${Cr}' ? (${Cu(t)}) : ` : "") + "(null)"
+        iue = (e, t, n, i, r) => ({
+            signal: (i != null ? `${e} === '${$c}' ? (${pu(i)}) : ` : "") + (n != null ? `${e} === '${za}' ? (${pu(n)}) : ` : "") + (r != null ? `${e} === '${Tc}' ? (${pu(r)}) : ` : "") + (t != null ? `${e} === '${br}' ? (${pu(t)}) : ` : "") + "(null)"
         }),
-        Cu = e => Nt(e) ? e.signal : e == null ? null : Z(e),
-        Kue = (e, t) => t === 0 ? 0 : Nt(e) ? {
+        pu = e => Ft(e) ? e.signal : e == null ? null : Z(e),
+        rue = (e, t) => t === 0 ? 0 : Ft(e) ? {
             signal: `(${e.signal}) * ${t}`
         } : {
             value: e * t
         },
-        Ru = (e, t) => {
+        Su = (e, t) => {
             const n = e.signal;
             return n && n.endsWith("(null)") ? {
                 signal: n.slice(0, -6) + t.signal
             } : e
         };
 
-    function cu(e, t, n, i) {
+    function Zl(e, t, n, i) {
         let r;
-        if (t && pe(t, e)) return t[e];
-        if (pe(n, e)) return n[e];
+        if (t && me(t, e)) return t[e];
+        if (me(n, e)) return n[e];
         if (e.startsWith("title")) {
             switch (e) {
                 case "titleColor":
                     r = "fill";
                     break;
                 case "titleFont":
                 case "titleFontSize":
                 case "titleFontWeight":
                     r = e[5].toLowerCase() + e.slice(6)
             }
-            return i[zE][r]
+            return i[aE][r]
         } else if (e.startsWith("label")) {
             switch (e) {
                 case "labelColor":
                     r = "fill";
                     break;
                 case "labelFont":
                 case "labelFontSize":
                     r = e[5].toLowerCase() + e.slice(6)
             }
-            return i[Id][r]
+            return i[kd][r]
         }
         return null
     }
 
-    function a$(e) {
+    function b5(e) {
         const t = {};
         for (const n of e)
             if (n)
                 for (const i in n) t[i] = 1;
         return Object.keys(t)
     }
 
-    function Jue(e, t) {
+    function sue(e, t) {
         var n = t.config,
             i = n.style,
             r = n.axis,
-            a = t.scaleType(e.scale) === "band" && n.axisBand,
-            s = e.orient,
+            s = t.scaleType(e.scale) === "band" && n.axisBand,
+            a = e.orient,
             o, l, u;
-        if (Nt(s)) {
-            const f = a$([n.axisX, n.axisY]),
-                h = a$([n.axisTop, n.axisBottom, n.axisLeft, n.axisRight]);
+        if (Ft(a)) {
+            const f = b5([n.axisX, n.axisY]),
+                h = b5([n.axisTop, n.axisBottom, n.axisLeft, n.axisRight]);
             o = {};
-            for (u of f) o[u] = Ht(s, cu(u, n.axisX, r, i), cu(u, n.axisY, r, i));
+            for (u of f) o[u] = Ut(a, Zl(u, n.axisX, r, i), Zl(u, n.axisY, r, i));
             l = {};
-            for (u of h) l[u] = Vue(s.signal, cu(u, n.axisTop, r, i), cu(u, n.axisBottom, r, i), cu(u, n.axisLeft, r, i), cu(u, n.axisRight, r, i))
-        } else o = s === Cr || s === Vs ? n.axisX : n.axisY, l = n["axis" + s[0].toUpperCase() + s.slice(1)];
-        return o || l || a ? ke({}, r, o, l, a) : r
+            for (u of h) l[u] = iue(a.signal, Zl(u, n.axisTop, r, i), Zl(u, n.axisBottom, r, i), Zl(u, n.axisLeft, r, i), Zl(u, n.axisRight, r, i))
+        } else o = a === br || a === za ? n.axisX : n.axisY, l = n["axis" + a[0].toUpperCase() + a.slice(1)];
+        return o || l || s ? Ae({}, r, o, l, s) : r
     }
 
-    function Que(e, t, n, i) {
-        const r = fi(e, t),
-            a = e.orient;
-        let s, o;
+    function aue(e, t, n, i) {
+        const r = ui(e, t),
+            s = e.orient;
+        let a, o;
         const l = {
-            enter: s = {
-                opacity: je
+            enter: a = {
+                opacity: Le
             },
             update: o = {
-                opacity: Ni
+                opacity: Oi
             },
             exit: {
-                opacity: je
+                opacity: Le
             }
         };
-        nn(l, {
+        Zt(l, {
             stroke: r("domainColor"),
             strokeCap: r("domainCap"),
             strokeDash: r("domainDash"),
             strokeDashOffset: r("domainDashOffset"),
             strokeWidth: r("domainWidth"),
             strokeOpacity: r("domainOpacity")
         });
-        const u = s$(e, 0),
-            c = s$(e, 1);
-        return s.x = o.x = Ht(a, u, je), s.x2 = o.x2 = Ht(a, c), s.y = o.y = gr(a, u, je), s.y2 = o.y2 = gr(a, c), Si({
-            type: GE,
-            role: _oe,
+        const u = x5(e, 0),
+            c = x5(e, 1);
+        return a.x = o.x = Ut(s, u, Le), a.x2 = o.x2 = Ut(s, c), a.y = o.y = ar(s, u, Le), a.y2 = o.y2 = ar(s, c), _i({
+            type: lE,
+            role: Tae,
             from: i,
             encode: l
         }, n)
     }
 
-    function s$(e, t) {
+    function x5(e, t) {
         return {
             scale: e.scale,
             range: t
         }
     }
 
-    function Zue(e, t, n, i, r) {
-        const a = fi(e, t),
-            s = e.orient,
+    function oue(e, t, n, i, r) {
+        const s = ui(e, t),
+            a = e.orient,
             o = e.gridScale,
-            l = I1(s, 1, -1),
-            u = ece(e.offset, l);
+            l = b1(a, 1, -1),
+            u = lue(e.offset, l);
         let c, f, h;
         const d = {
             enter: c = {
-                opacity: je
+                opacity: Le
             },
             update: h = {
-                opacity: Ni
+                opacity: Oi
             },
             exit: f = {
-                opacity: je
+                opacity: Le
             }
         };
-        nn(d, {
-            stroke: a("gridColor"),
-            strokeCap: a("gridCap"),
-            strokeDash: a("gridDash"),
-            strokeDashOffset: a("gridDashOffset"),
-            strokeOpacity: a("gridOpacity"),
-            strokeWidth: a("gridWidth")
+        Zt(d, {
+            stroke: s("gridColor"),
+            strokeCap: s("gridCap"),
+            strokeDash: s("gridDash"),
+            strokeDashOffset: s("gridDashOffset"),
+            strokeOpacity: s("gridOpacity"),
+            strokeWidth: s("gridWidth")
         });
         const g = {
                 scale: e.scale,
-                field: Pi,
+                field: Mi,
                 band: r.band,
                 extra: r.extra,
                 offset: r.offset,
-                round: a("tickRound")
+                round: s("tickRound")
             },
-            p = Ht(s, {
+            p = Ut(a, {
                 signal: "height"
             }, {
                 signal: "width"
             }),
             m = o ? {
                 scale: o,
                 range: 0,
@@ -34504,306 +34525,306 @@
                 offset: u
             },
             y = o ? {
                 scale: o,
                 range: 1,
                 mult: l,
                 offset: u
-            } : ke(p, {
+            } : Ae(p, {
                 mult: l,
                 offset: u
             });
-        return c.x = h.x = Ht(s, g, m), c.y = h.y = gr(s, g, m), c.x2 = h.x2 = gr(s, y), c.y2 = h.y2 = Ht(s, y), f.x = Ht(s, g), f.y = gr(s, g), Si({
-            type: GE,
-            role: woe,
-            key: Pi,
+        return c.x = h.x = Ut(a, g, m), c.y = h.y = ar(a, g, m), c.x2 = h.x2 = ar(a, y), c.y2 = h.y2 = Ut(a, y), f.x = Ut(a, g), f.y = ar(a, g), _i({
+            type: lE,
+            role: Mae,
+            key: Mi,
             from: i,
             encode: d
         }, n)
     }
 
-    function ece(e, t) {
+    function lue(e, t) {
         if (t !== 1)
-            if (!se(e)) e = Nt(t) ? {
+            if (!ae(e)) e = Ft(t) ? {
                 signal: `(${t.signal}) * (${e||0})`
             } : t * (e || 0);
             else {
-                let n = e = ke({}, e);
+                let n = e = Ae({}, e);
                 for (; n.mult != null;)
-                    if (se(n.mult)) n = n.mult = ke({}, n.mult);
-                    else return n.mult = Nt(t) ? {
+                    if (ae(n.mult)) n = n.mult = Ae({}, n.mult);
+                    else return n.mult = Ft(t) ? {
                         signal: `(${n.mult}) * (${t.signal})`
                     } : n.mult * t, e;
                 n.mult = t
             } return e
     }
 
-    function tce(e, t, n, i, r, a) {
-        const s = fi(e, t),
+    function uue(e, t, n, i, r, s) {
+        const a = ui(e, t),
             o = e.orient,
-            l = I1(o, -1, 1);
+            l = b1(o, -1, 1);
         let u, c, f;
         const h = {
             enter: u = {
-                opacity: je
+                opacity: Le
             },
             update: f = {
-                opacity: Ni
+                opacity: Oi
             },
             exit: c = {
-                opacity: je
+                opacity: Le
             }
         };
-        nn(h, {
-            stroke: s("tickColor"),
-            strokeCap: s("tickCap"),
-            strokeDash: s("tickDash"),
-            strokeDashOffset: s("tickDashOffset"),
-            strokeOpacity: s("tickOpacity"),
-            strokeWidth: s("tickWidth")
+        Zt(h, {
+            stroke: a("tickColor"),
+            strokeCap: a("tickCap"),
+            strokeDash: a("tickDash"),
+            strokeDashOffset: a("tickDashOffset"),
+            strokeOpacity: a("tickOpacity"),
+            strokeWidth: a("tickWidth")
         });
-        const d = Wt(r);
+        const d = jt(r);
         d.mult = l;
         const g = {
             scale: e.scale,
-            field: Pi,
-            band: a.band,
-            extra: a.extra,
-            offset: a.offset,
-            round: s("tickRound")
-        };
-        return f.y = u.y = Ht(o, je, g), f.y2 = u.y2 = Ht(o, d), c.x = Ht(o, g), f.x = u.x = gr(o, je, g), f.x2 = u.x2 = gr(o, d), c.y = gr(o, g), Si({
-            type: GE,
-            role: Eoe,
-            key: Pi,
+            field: Mi,
+            band: s.band,
+            extra: s.extra,
+            offset: s.offset,
+            round: a("tickRound")
+        };
+        return f.y = u.y = Ut(o, Le, g), f.y2 = u.y2 = Ut(o, d), c.x = Ut(o, g), f.x = u.x = ar(o, Le, g), f.x2 = u.x2 = ar(o, d), c.y = ar(o, g), _i({
+            type: lE,
+            role: Fae,
+            key: Mi,
             from: i,
             encode: h
         }, n)
     }
 
-    function Hv(e, t, n, i, r) {
+    function Ev(e, t, n, i, r) {
         return {
             signal: 'flush(range("' + e + '"), scale("' + e + '", datum.value), ' + t + "," + n + "," + i + "," + r + ")"
         }
     }
 
-    function nce(e, t, n, i, r, a) {
-        const s = fi(e, t),
+    function cue(e, t, n, i, r, s) {
+        const a = ui(e, t),
             o = e.orient,
             l = e.scale,
-            u = I1(o, -1, 1),
-            c = il(s("labelFlush")),
-            f = il(s("labelFlushOffset")),
-            h = s("labelAlign"),
-            d = s("labelBaseline");
+            u = b1(o, -1, 1),
+            c = Wo(a("labelFlush")),
+            f = Wo(a("labelFlushOffset")),
+            h = a("labelAlign"),
+            d = a("labelBaseline");
         let g = c === 0 || !!c,
             p;
-        const m = Wt(r);
-        m.mult = u, m.offset = Wt(s("labelPadding") || 0), m.offset.mult = u;
+        const m = jt(r);
+        m.mult = u, m.offset = jt(a("labelPadding") || 0), m.offset.mult = u;
         const y = {
                 scale: l,
-                field: Pi,
+                field: Mi,
                 band: .5,
-                offset: UI(a.offset, s("labelOffset"))
+                offset: eI(s.offset, a("labelOffset"))
             },
-            v = Ht(o, g ? Hv(l, c, '"left"', '"right"', '"center"') : {
+            v = Ut(o, g ? Ev(l, c, '"left"', '"right"', '"center"') : {
                 value: "center"
-            }, Uue(o, "left", "right")),
-            b = Ht(o, VI(o, "bottom", "top"), g ? Hv(l, c, '"top"', '"bottom"', '"middle"') : {
+            }, Jle(o, "left", "right")),
+            b = Ut(o, aI(o, "bottom", "top"), g ? Ev(l, c, '"top"', '"bottom"', '"middle"') : {
                 value: "middle"
             }),
-            x = Hv(l, c, `-(${f})`, f, 0);
+            x = Ev(l, c, `-(${f})`, f, 0);
         g = g && f;
         const _ = {
-                opacity: je,
-                x: Ht(o, y, m),
-                y: gr(o, y, m)
+                opacity: Le,
+                x: Ut(o, y, m),
+                y: ar(o, y, m)
             },
             S = {
                 enter: _,
                 update: p = {
-                    opacity: Ni,
+                    opacity: Oi,
                     text: {
-                        field: jE
+                        field: sE
                     },
                     x: _.x,
                     y: _.y,
                     align: v,
                     baseline: b
                 },
                 exit: {
-                    opacity: je,
+                    opacity: Le,
                     x: _.x,
                     y: _.y
                 }
             };
-        nn(S, {
-            dx: !h && g ? Ht(o, x) : null,
-            dy: !d && g ? gr(o, x) : null
-        }), nn(S, {
-            angle: s("labelAngle"),
-            fill: s("labelColor"),
-            fillOpacity: s("labelOpacity"),
-            font: s("labelFont"),
-            fontSize: s("labelFontSize"),
-            fontWeight: s("labelFontWeight"),
-            fontStyle: s("labelFontStyle"),
-            limit: s("labelLimit"),
-            lineHeight: s("labelLineHeight")
+        Zt(S, {
+            dx: !h && g ? Ut(o, x) : null,
+            dy: !d && g ? ar(o, x) : null
+        }), Zt(S, {
+            angle: a("labelAngle"),
+            fill: a("labelColor"),
+            fillOpacity: a("labelOpacity"),
+            font: a("labelFont"),
+            fontSize: a("labelFontSize"),
+            fontWeight: a("labelFontWeight"),
+            fontStyle: a("labelFontStyle"),
+            limit: a("labelLimit"),
+            lineHeight: a("labelLineHeight")
         }, {
             align: h,
             baseline: d
         });
-        const w = s("labelBound");
-        let O = s("labelOverlap");
-        return O = O || w ? {
-            separation: s("labelSeparation"),
-            method: O,
+        const w = a("labelBound");
+        let E = a("labelOverlap");
+        return E = E || w ? {
+            separation: a("labelSeparation"),
+            method: E,
             order: "datum.index",
             bound: w ? {
                 scale: l,
                 orient: o,
                 tolerance: w
             } : null
-        } : void 0, p.align !== v && (p.align = Ru(p.align, v)), p.baseline !== b && (p.baseline = Ru(p.baseline, b)), Si({
-            type: ql,
-            role: Soe,
-            style: Id,
-            key: Pi,
+        } : void 0, p.align !== v && (p.align = Su(p.align, v)), p.baseline !== b && (p.baseline = Su(p.baseline, b)), _i({
+            type: Rl,
+            role: Oae,
+            style: kd,
+            key: Mi,
             from: i,
             encode: S,
-            overlap: O
+            overlap: E
         }, n)
     }
 
-    function ice(e, t, n, i) {
-        const r = fi(e, t),
-            a = e.orient,
-            s = I1(a, -1, 1);
+    function fue(e, t, n, i) {
+        const r = ui(e, t),
+            s = e.orient,
+            a = b1(s, -1, 1);
         let o, l;
         const u = {
                 enter: o = {
-                    opacity: je,
-                    anchor: Wt(r("titleAnchor", null)),
+                    opacity: Le,
+                    anchor: jt(r("titleAnchor", null)),
                     align: {
-                        signal: UE
+                        signal: uE
                     }
                 },
-                update: l = ke({}, o, {
-                    opacity: Ni,
-                    text: Wt(e.title)
+                update: l = Ae({}, o, {
+                    opacity: Oi,
+                    text: jt(e.title)
                 }),
                 exit: {
-                    opacity: je
+                    opacity: Le
                 }
             },
             c = {
-                signal: `lerp(range("${e.scale}"), ${P1(0,1,.5)})`
+                signal: `lerp(range("${e.scale}"), ${m1(0,1,.5)})`
             };
-        return l.x = Ht(a, c), l.y = gr(a, c), o.angle = Ht(a, je, Kue(s, 90)), o.baseline = Ht(a, VI(a, Vs, Cr), {
-            value: Vs
-        }), l.angle = o.angle, l.baseline = o.baseline, nn(u, {
+        return l.x = Ut(s, c), l.y = ar(s, c), o.angle = Ut(s, Le, rue(a, 90)), o.baseline = Ut(s, aI(s, za, br), {
+            value: za
+        }), l.angle = o.angle, l.baseline = o.baseline, Zt(u, {
             fill: r("titleColor"),
             fillOpacity: r("titleOpacity"),
             font: r("titleFont"),
             fontSize: r("titleFontSize"),
             fontStyle: r("titleFontStyle"),
             fontWeight: r("titleFontWeight"),
             limit: r("titleLimit"),
             lineHeight: r("titleLineHeight")
         }, {
             align: r("titleAlign"),
             angle: r("titleAngle"),
             baseline: r("titleBaseline")
-        }), rce(r, a, u, n), u.update.align = Ru(u.update.align, o.align), u.update.angle = Ru(u.update.angle, o.angle), u.update.baseline = Ru(u.update.baseline, o.baseline), Si({
-            type: ql,
-            role: Ooe,
-            style: zE,
+        }), hue(r, s, u, n), u.update.align = Su(u.update.align, o.align), u.update.angle = Su(u.update.angle, o.angle), u.update.baseline = Su(u.update.baseline, o.baseline), _i({
+            type: Rl,
+            role: Rae,
+            style: aE,
             from: i,
             encode: u
         }, n)
     }
 
-    function rce(e, t, n, i) {
-        const r = (o, l) => o != null ? (n.update[l] = Ru(Wt(o), n.update[l]), !1) : !vu(l, i),
-            a = r(e("titleX"), "x"),
-            s = r(e("titleY"), "y");
-        n.enter.auto = s === a ? Wt(s) : Ht(t, Wt(s), Wt(a))
+    function hue(e, t, n, i) {
+        const r = (o, l) => o != null ? (n.update[l] = Su(jt(o), n.update[l]), !1) : !ou(l, i),
+            s = r(e("titleX"), "x"),
+            a = r(e("titleY"), "y");
+        n.enter.auto = a === s ? jt(a) : Ut(t, jt(a), jt(s))
     }
 
-    function ace(e, t) {
-        const n = Jue(e, t),
+    function due(e, t) {
+        const n = sue(e, t),
             i = e.encode || {},
             r = i.axis || {},
-            a = r.name || void 0,
-            s = r.interactive,
+            s = r.name || void 0,
+            a = r.interactive,
             o = r.style,
-            l = fi(e, n),
-            u = tue(l),
+            l = ui(e, n),
+            u = ule(l),
             c = {
                 scale: e.scale,
                 ticks: !!l("ticks"),
                 labels: !!l("labels"),
                 grid: !!l("grid"),
                 domain: !!l("domain"),
                 title: e.title != null
             },
-            f = he(t.add(Or({}, [c]))),
-            h = he(t.add(sle({
+            f = de(t.add(vr({}, [c]))),
+            h = de(t.add(goe({
                 scale: t.scaleRef(e.scale),
                 extra: t.property(u.extra),
                 count: t.objectProperty(e.tickCount),
                 values: t.objectProperty(e.values),
                 minstep: t.property(e.tickMinStep),
                 formatType: t.property(e.formatType),
                 formatSpecifier: t.property(e.format)
             }))),
             d = [];
         let g;
-        return c.grid && d.push(Zue(e, n, i.grid, h, u)), c.ticks && (g = l("tickSize"), d.push(tce(e, n, i.ticks, h, g, u))), c.labels && (g = c.ticks ? g : 0, d.push(nce(e, n, i.labels, h, g, u))), c.domain && d.push(Que(e, n, i.domain, f)), c.title && d.push(ice(e, n, i.title, f)), L1(Vh({
-            role: xoe,
+        return c.grid && d.push(oue(e, n, i.grid, h, u)), c.ticks && (g = l("tickSize"), d.push(uue(e, n, i.ticks, h, g, u))), c.labels && (g = c.ticks ? g : 0, d.push(cue(e, n, i.labels, h, g, u))), c.domain && d.push(aue(e, n, i.domain, f)), c.title && d.push(fue(e, n, i.title, f)), v1(Lh({
+            role: $ae,
             from: f,
-            encode: jc(sce(l, e), r, jd),
+            encode: Ac(gue(l, e), r, Ad),
             marks: d,
             aria: l("aria"),
             description: l("description"),
             zindex: l("zindex"),
-            name: a,
-            interactive: s,
+            name: s,
+            interactive: a,
             style: o
         }), t)
     }
 
-    function sce(e, t) {
+    function gue(e, t) {
         const n = {
             enter: {},
             update: {}
         };
-        return nn(n, {
+        return Zt(n, {
             orient: e("orient"),
             offset: e("offset") || 0,
-            position: er(t.position, 0),
+            position: Yi(t.position, 0),
             titlePadding: e("titlePadding"),
             minExtent: e("minExtent"),
             maxExtent: e("maxExtent"),
             range: {
                 signal: `abs(span(range("${t.scale}")))`
             },
             translate: e("translate"),
             format: t.format,
             formatType: t.formatType
         }), n
     }
 
-    function JI(e, t, n) {
-        const i = ie(e.signals),
-            r = ie(e.scales);
-        return n || i.forEach(a => TI(a, t)), ie(e.projections).forEach(a => Ile(a, t)), r.forEach(a => Cle(a, t)), ie(e.data).forEach(a => Bue(a, t)), r.forEach(a => kle(a, t)), (n || i).forEach(a => ale(a, t)), ie(e.axes).forEach(a => ace(a, t)), ie(e.marks).forEach(a => L1(a, t)), ie(e.legends).forEach(a => Tue(a, t)), e.title && Nue(e.title, t), t.parseLambdas(), t
+    function lI(e, t, n) {
+        const i = se(e.signals),
+            r = se(e.scales);
+        return n || i.forEach(s => BL(s, t)), se(e.projections).forEach(s => Hoe(s, t)), r.forEach(s => Doe(s, t)), se(e.data).forEach(s => Vle(s, t)), r.forEach(s => Noe(s, t)), (n || i).forEach(s => doe(s, t)), se(e.axes).forEach(s => due(s, t)), se(e.marks).forEach(s => v1(s, t)), se(e.legends).forEach(s => Lle(s, t)), e.title && Wle(e.title, t), t.parseLambdas(), t
     }
-    const oce = e => jc({
+    const pue = e => Ac({
         enter: {
             x: {
                 value: 0
             },
             y: {
                 value: 0
             }
@@ -34814,77 +34835,77 @@
             },
             height: {
                 signal: "height"
             }
         }
     }, e);
 
-    function lce(e, t) {
+    function mue(e, t) {
         const n = t.config,
-            i = he(t.root = t.add(Z0())),
-            r = uce(e, n);
-        r.forEach(u => TI(u, t)), t.description = e.description || n.description, t.eventConfig = n.events, t.legends = t.objectProperty(n.legend && n.legend.layout), t.locale = n.locale;
-        const a = t.add(Or()),
-            s = t.add(FI(AI(oce(e.encode), R1, PE, e.style, t, {
-                pulse: he(a)
+            i = de(t.root = t.add(D0())),
+            r = yue(e, n);
+        r.forEach(u => BL(u, t)), t.description = e.description || n.description, t.eventConfig = n.events, t.legends = t.objectProperty(n.legend && n.legend.layout), t.locale = n.locale;
+        const s = t.add(vr()),
+            a = t.add(GL(zL(pue(e.encode), p1, tE, e.style, t, {
+                pulse: de(s)
             }))),
-            o = t.add(PI({
+            o = t.add(HL({
                 layout: t.objectProperty(e.layout),
                 legends: t.legends,
                 autosize: t.signalRef("autosize"),
                 mark: i,
-                pulse: he(s)
+                pulse: de(a)
             }));
-        t.operators.pop(), t.pushState(he(s), he(o), null), JI(e, t, r), t.operators.push(o);
-        let l = t.add(MI({
+        t.operators.pop(), t.pushState(de(a), de(o), null), lI(e, t, r), t.operators.push(o);
+        let l = t.add(UL({
             mark: i,
-            pulse: he(o)
+            pulse: de(o)
         }));
-        return l = t.add(RI({
-            pulse: he(l)
-        })), l = t.add(Ul({
-            pulse: he(l)
-        })), t.addData("root", new vl(t, a, a, l)), t
+        return l = t.add(qL({
+            pulse: de(l)
+        })), l = t.add(Fl({
+            pulse: de(l)
+        })), t.addData("root", new al(t, s, s, l)), t
     }
 
-    function wf(e, t) {
+    function uf(e, t) {
         return t && t.signal ? {
             name: e,
             update: t.signal
         } : {
             name: e,
             value: t
         }
     }
 
-    function uce(e, t) {
-        const n = s => er(e[s], t[s]),
-            i = [wf("background", n("background")), wf("autosize", yoe(n("autosize"))), wf("padding", boe(n("padding"))), wf("width", n("width") || 0), wf("height", n("height") || 0)],
-            r = i.reduce((s, o) => (s[o.name] = o, s), {}),
-            a = {};
-        return ie(e.signals).forEach(s => {
-            pe(r, s.name) ? s = ke(r[s.name], s) : i.push(s), a[s.name] = s
-        }), ie(t.signals).forEach(s => {
-            !pe(a, s.name) && !pe(r, s.name) && i.push(s)
+    function yue(e, t) {
+        const n = a => Yi(e[a], t[a]),
+            i = [uf("background", n("background")), uf("autosize", Cae(n("autosize"))), uf("padding", Aae(n("padding"))), uf("width", n("width") || 0), uf("height", n("height") || 0)],
+            r = i.reduce((a, o) => (a[o.name] = o, a), {}),
+            s = {};
+        return se(e.signals).forEach(a => {
+            me(r, a.name) ? a = Ae(r[a.name], a) : i.push(a), s[a.name] = a
+        }), se(t.signals).forEach(a => {
+            !me(s, a.name) && !me(r, a.name) && i.push(a)
         }), i
     }
 
-    function QI(e, t) {
+    function uI(e, t) {
         this.config = e || {}, this.options = t || {}, this.bindings = [], this.field = {}, this.signals = {}, this.lambdas = {}, this.scales = {}, this.events = {}, this.data = {}, this.streams = [], this.updates = [], this.operators = [], this.eventConfig = null, this.locale = null, this._id = 0, this._subid = 0, this._nextsub = [0], this._parent = [], this._encode = [], this._lookup = [], this._markpath = []
     }
 
-    function o$(e) {
+    function _5(e) {
         this.config = e.config, this.options = e.options, this.legends = e.legends, this.field = Object.create(e.field), this.signals = Object.create(e.signals), this.lambdas = Object.create(e.lambdas), this.scales = Object.create(e.scales), this.events = Object.create(e.events), this.data = Object.create(e.data), this.streams = [], this.updates = [], this.operators = [], this._id = 0, this._subid = ++e._nextsub[0], this._nextsub = e._nextsub, this._parent = e._parent.slice(), this._encode = e._encode.slice(), this._lookup = e._lookup.slice(), this._markpath = e._markpath
     }
-    QI.prototype = o$.prototype = {
+    uI.prototype = _5.prototype = {
         parse(e) {
-            return JI(e, this)
+            return lI(e, this)
         },
         fork() {
-            return new o$(this)
+            return new _5(this)
         },
         isSubscope() {
             return this._subid > 0
         },
         toRuntime() {
             return this.finish(), {
                 description: this.description,
@@ -34901,16 +34922,16 @@
         },
         add(e) {
             return this.operators.push(e), e.id = this.id(), e.refs && (e.refs.forEach(t => {
                 t.$ref = e.id
             }), e.refs = null), e
         },
         proxy(e) {
-            const t = e instanceof lx ? he(e) : e;
-            return this.add(xle({
+            const t = e instanceof P2 ? de(e) : e;
+            return this.add($oe({
                 value: t
             }))
         },
         addStream(e) {
             return this.streams.push(e), e.id = this.id(), e
         },
         addUpdate(e) {
@@ -34918,201 +34939,201 @@
         },
         finish() {
             let e, t;
             this.root && (this.root.root = !0);
             for (e in this.signals) this.signals[e].signal = e;
             for (e in this.scales) this.scales[e].scale = e;
 
-            function n(i, r, a) {
-                let s, o;
-                i && (s = i.data || (i.data = {}), o = s[r] || (s[r] = []), o.push(a))
+            function n(i, r, s) {
+                let a, o;
+                i && (a = i.data || (i.data = {}), o = a[r] || (a[r] = []), o.push(s))
             }
             for (e in this.data) {
                 t = this.data[e], n(t.input, e, "input"), n(t.output, e, "output"), n(t.values, e, "values");
                 for (const i in t.index) n(t.index[i], e, "index:" + i)
             }
             return this
         },
         pushState(e, t, n) {
-            this._encode.push(he(this.add(Ul({
+            this._encode.push(de(this.add(Fl({
                 pulse: e
-            })))), this._parent.push(t), this._lookup.push(n ? he(this.proxy(n)) : null), this._markpath.push(-1)
+            })))), this._parent.push(t), this._lookup.push(n ? de(this.proxy(n)) : null), this._markpath.push(-1)
         },
         popState() {
             this._encode.pop(), this._parent.pop(), this._lookup.pop(), this._markpath.pop()
         },
         parent() {
-            return Le(this._parent)
+            return De(this._parent)
         },
         encode() {
-            return Le(this._encode)
+            return De(this._encode)
         },
         lookup() {
-            return Le(this._lookup)
+            return De(this._lookup)
         },
         markpath() {
             const e = this._markpath;
             return ++e[e.length - 1]
         },
         fieldRef(e, t) {
-            if (re(e)) return Yh(e, t);
-            e.signal || G("Unsupported field reference: " + Z(e));
+            if (re(e)) return Nh(e, t);
+            e.signal || U("Unsupported field reference: " + Z(e));
             const n = e.signal;
             let i = this.field[n];
             if (!i) {
                 const r = {
                     name: this.signalRef(n)
                 };
-                t && (r.as = t), this.field[n] = i = he(this.add(cle(r)))
+                t && (r.as = t), this.field[n] = i = de(this.add(voe(r)))
             }
             return i
         },
         compareRef(e) {
             let t = !1;
-            const n = a => Nt(a) ? (t = !0, this.signalRef(a.signal)) : Voe(a) ? (t = !0, this.exprRef(a.expr)) : a,
-                i = ie(e.field).map(n),
-                r = ie(e.order).map(n);
-            return t ? he(this.add(Y3({
+            const n = s => Ft(s) ? (t = !0, this.signalRef(s.signal)) : ioe(s) ? (t = !0, this.exprRef(s.expr)) : s,
+                i = se(e.field).map(n),
+                r = se(e.order).map(n);
+            return t ? de(this.add(o5({
                 fields: i,
                 orders: r
-            }))) : W3(i, r)
+            }))) : s5(i, r)
         },
         keyRef(e, t) {
             let n = !1;
-            const i = a => Nt(a) ? (n = !0, he(r[a.signal])) : a,
+            const i = s => Ft(s) ? (n = !0, de(r[s.signal])) : s,
                 r = this.signals;
-            return e = ie(e).map(i), n ? he(this.add(fle({
+            return e = se(e).map(i), n ? de(this.add(boe({
                 fields: e,
                 flat: t
-            }))) : Woe(e, t)
+            }))) : Zae(e, t)
         },
         sortRef(e) {
             if (!e) return e;
-            const t = F1(e.op, e.field),
-                n = e.order || Hoe;
-            return n.signal ? he(this.add(Y3({
+            const t = d1(e.op, e.field),
+                n = e.order || eoe;
+            return n.signal ? de(this.add(o5({
                 fields: t,
                 orders: this.signalRef(n.signal)
-            }))) : W3(t, n)
+            }))) : s5(t, n)
         },
         event(e, t) {
             const n = e + ":" + t;
             if (!this.events[n]) {
                 const i = this.id();
                 this.streams.push({
                     id: i,
                     source: e,
                     type: t
                 }), this.events[n] = i
             }
             return this.events[n]
         },
         hasOwnSignal(e) {
-            return pe(this.signals, e)
+            return me(this.signals, e)
         },
         addSignal(e, t) {
-            this.hasOwnSignal(e) && G("Duplicate signal name: " + Z(e));
-            const n = t instanceof lx ? t : this.add(Z0(t));
+            this.hasOwnSignal(e) && U("Duplicate signal name: " + Z(e));
+            const n = t instanceof P2 ? t : this.add(D0(t));
             return this.signals[e] = n
         },
         getSignal(e) {
-            return this.signals[e] || G("Unrecognized signal name: " + Z(e)), this.signals[e]
+            return this.signals[e] || U("Unrecognized signal name: " + Z(e)), this.signals[e]
         },
         signalRef(e) {
-            return this.signals[e] ? he(this.signals[e]) : (pe(this.lambdas, e) || (this.lambdas[e] = this.add(Z0(null))), he(this.lambdas[e]))
+            return this.signals[e] ? de(this.signals[e]) : (me(this.lambdas, e) || (this.lambdas[e] = this.add(D0(null))), de(this.lambdas[e]))
         },
         parseLambdas() {
             const e = Object.keys(this.lambdas);
             for (let t = 0, n = e.length; t < n; ++t) {
                 const i = e[t],
-                    r = ta(i, this),
-                    a = this.lambdas[i];
-                a.params = r.$params, a.update = r.$expr
+                    r = Xr(i, this),
+                    s = this.lambdas[i];
+                s.params = r.$params, s.update = r.$expr
             }
         },
         property(e) {
             return e && e.signal ? this.signalRef(e.signal) : e
         },
         objectProperty(e) {
-            return !e || !se(e) ? e : this.signalRef(e.signal || XE(e))
+            return !e || !ae(e) ? e : this.signalRef(e.signal || gE(e))
         },
         exprRef(e, t) {
             const n = {
-                expr: ta(e, this)
+                expr: Xr(e, this)
             };
-            return t && (n.expr.$name = t), he(this.add(lle(n)))
+            return t && (n.expr.$name = t), de(this.add(moe(n)))
         },
         addBinding(e, t) {
-            this.bindings || G("Nested signals do not support binding: " + Z(e)), this.bindings.push(ke({
+            this.bindings || U("Nested signals do not support binding: " + Z(e)), this.bindings.push(Ae({
                 signal: e
             }, t))
         },
         addScaleProj(e, t) {
-            pe(this.scales, e) && G("Duplicate scale or projection name: " + Z(e)), this.scales[e] = this.add(t)
+            me(this.scales, e) && U("Duplicate scale or projection name: " + Z(e)), this.scales[e] = this.add(t)
         },
         addScale(e, t) {
-            this.addScaleProj(e, wle(t))
+            this.addScaleProj(e, Moe(t))
         },
         addProjection(e, t) {
-            this.addScaleProj(e, ble(t))
+            this.addScaleProj(e, Aoe(t))
         },
         getScale(e) {
-            return this.scales[e] || G("Unrecognized scale name: " + Z(e)), this.scales[e]
+            return this.scales[e] || U("Unrecognized scale name: " + Z(e)), this.scales[e]
         },
         scaleRef(e) {
-            return he(this.getScale(e))
+            return de(this.getScale(e))
         },
         scaleType(e) {
             return this.getScale(e).params.type
         },
         projectionRef(e) {
             return this.scaleRef(e)
         },
         projectionType(e) {
             return this.scaleType(e)
         },
         addData(e, t) {
-            return pe(this.data, e) && G("Duplicate data set name: " + Z(e)), this.data[e] = t
+            return me(this.data, e) && U("Duplicate data set name: " + Z(e)), this.data[e] = t
         },
         getData(e) {
-            return this.data[e] || G("Undefined data set name: " + Z(e)), this.data[e]
+            return this.data[e] || U("Undefined data set name: " + Z(e)), this.data[e]
         },
         addDataPipeline(e, t) {
-            return pe(this.data, e) && G("Duplicate data set name: " + Z(e)), this.addData(e, vl.fromEntries(this, t))
+            return me(this.data, e) && U("Duplicate data set name: " + Z(e)), this.addData(e, al.fromEntries(this, t))
         }
     };
 
-    function XE(e) {
-        return (q(e) ? cce : fce)(e)
+    function gE(e) {
+        return (W(e) ? vue : bue)(e)
     }
 
-    function cce(e) {
+    function vue(e) {
         const t = e.length;
         let n = "[";
         for (let i = 0; i < t; ++i) {
             const r = e[i];
-            n += (i > 0 ? "," : "") + (se(r) ? r.signal || XE(r) : Z(r))
+            n += (i > 0 ? "," : "") + (ae(r) ? r.signal || gE(r) : Z(r))
         }
         return n + "]"
     }
 
-    function fce(e) {
+    function bue(e) {
         let t = "{",
             n = 0,
             i, r;
-        for (i in e) r = e[i], t += (++n > 1 ? "," : "") + Z(i) + ":" + (se(r) ? r.signal || XE(r) : Z(r));
+        for (i in e) r = e[i], t += (++n > 1 ? "," : "") + Z(i) + ":" + (ae(r) ? r.signal || gE(r) : Z(r));
         return t + "}"
     }
 
-    function hce() {
+    function xue() {
         const e = "sans-serif",
             i = "#4c78a8",
             r = "#000",
-            a = "#888",
-            s = "#ddd";
+            s = "#888",
+            a = "#ddd";
         return {
             description: "Vega visualization",
             padding: 0,
             autosize: "pad",
             background: null,
             events: {
                 defaults: {
@@ -35192,15 +35213,15 @@
                 square: {
                     size: 30,
                     strokeWidth: 2,
                     shape: "square"
                 },
                 cell: {
                     fill: "transparent",
-                    stroke: s
+                    stroke: a
                 },
                 view: {
                     fill: "transparent"
                 }
             },
             title: {
                 orient: "top",
@@ -35210,25 +35231,25 @@
             },
             axis: {
                 minExtent: 0,
                 maxExtent: 200,
                 bandPosition: .5,
                 domain: !0,
                 domainWidth: 1,
-                domainColor: a,
+                domainColor: s,
                 grid: !1,
                 gridWidth: 1,
-                gridColor: s,
+                gridColor: a,
                 labels: !0,
                 labelAngle: 0,
                 labelLimit: 180,
                 labelOffset: 0,
                 labelPadding: 2,
                 ticks: !0,
-                tickColor: a,
+                tickColor: s,
                 tickOffset: 0,
                 tickRound: !0,
                 tickSize: 5,
                 tickWidth: 1,
                 titlePadding: 4
             },
             axisBand: {
@@ -35243,29 +35264,29 @@
                 gridAlign: "each",
                 columnPadding: 10,
                 rowPadding: 2,
                 symbolDirection: "vertical",
                 gradientDirection: "vertical",
                 gradientLength: 200,
                 gradientThickness: 16,
-                gradientStrokeColor: s,
+                gradientStrokeColor: a,
                 gradientStrokeWidth: 0,
                 gradientLabelOffset: 2,
                 labelAlign: "left",
                 labelBaseline: "middle",
                 labelLimit: 160,
                 labelOffset: 4,
                 labelOverlap: !0,
                 symbolLimit: 30,
                 symbolType: "circle",
                 symbolSize: 100,
                 symbolOffset: 0,
                 symbolStrokeWidth: 1.5,
                 symbolBaseFillColor: "transparent",
-                symbolBaseStrokeColor: a,
+                symbolBaseStrokeColor: s,
                 titleLimit: 180,
                 titleOrient: "top",
                 titlePadding: 5,
                 layout: {
                     offset: 18,
                     direction: "horizontal",
                     left: {
@@ -35294,273 +35315,274 @@
                     extent: [1, 0]
                 },
                 symbol: ["circle", "square", "triangle-up", "cross", "diamond", "triangle-right", "triangle-down", "triangle-left"]
             }
         }
     }
 
-    function dce(e, t, n) {
-        return se(e) || G("Input Vega specification must be an object."), t = Mc(hce(), t, e.config), lce(e, new QI(t, n)).toRuntime()
+    function _ue(e, t, n) {
+        return ae(e) || U("Input Vega specification must be an object."), t = bc(xue(), t, e.config), mue(e, new uI(t, n)).toRuntime()
     }
-    var gce = "5.24.0";
-    ke(Zu, fJ, Qee, $te, one, gne, Bne, xne, Une, Hne, nie, uie);
-    const pce = Object.freeze(Object.defineProperty({
+    var wue = "5.25.0";
+    Ae(Uu, bK, aee, Iee, pte, wte, Vte, $te, Jte, ene, cne, yne);
+    const Sue = Object.freeze(Object.defineProperty({
         __proto__: null,
-        Bounds: At,
-        CanvasHandler: Dd,
-        CanvasRenderer: B0,
-        DATE: si,
-        DAY: dn,
-        DAYOFYEAR: ea,
-        Dataflow: Du,
-        Debug: MR,
-        Error: z_,
-        EventStream: e1,
-        Gradient: XN,
-        GroupItem: d1,
-        HOURS: xi,
-        Handler: Ys,
-        Info: $R,
-        Item: h1,
-        MILLISECONDS: xr,
-        MINUTES: _i,
-        MONTH: vn,
-        Marks: wi,
-        MultiPulse: sw,
-        None: TR,
-        Operator: rt,
-        Parameters: Zm,
-        Pulse: Rs,
-        QUARTER: ai,
-        RenderType: ks,
-        Renderer: ha,
-        ResourceLoader: uS,
-        SECONDS: ji,
-        SVGHandler: kS,
-        SVGRenderer: DS,
-        SVGStringRenderer: RS,
-        Scenegraph: OS,
-        TIME_UNITS: Q_,
+        Bounds: kt,
+        CanvasHandler: _d,
+        CanvasRenderer: w0,
+        DATE: ri,
+        DAY: fn,
+        DAYOFYEAR: Yr,
+        Dataflow: wu,
+        Debug: UR,
+        Error: s_,
+        EventStream: Nm,
+        Gradient: sP,
+        GroupItem: Xm,
+        HOURS: vi,
+        Handler: La,
+        Info: jR,
+        Item: Ym,
+        MILLISECONDS: hr,
+        MINUTES: bi,
+        MONTH: mn,
+        Marks: xi,
+        MultiPulse: C_,
+        None: BR,
+        Operator: it,
+        Parameters: Dm,
+        Pulse: Ca,
+        QUARTER: ii,
+        RenderType: ya,
+        Renderer: rs,
+        ResourceLoader: Tw,
+        SECONDS: Di,
+        SVGHandler: Yw,
+        SVGRenderer: Zw,
+        SVGStringRenderer: eS,
+        Scenegraph: qw,
+        TIME_UNITS: y_,
         Transform: L,
-        View: mI,
-        WEEK: Dt,
-        Warn: B_,
-        YEAR: tn,
-        accessor: ci,
-        accessorFields: yn,
-        accessorName: wt,
-        array: ie,
-        ascending: Ym,
-        bandwidthNRD: cw,
-        bin: zP,
-        bootstrapCI: BP,
-        boundClip: G4,
-        boundContext: Td,
-        boundItem: P2,
-        boundMark: d4,
-        boundStroke: es,
-        changeset: zl,
-        clampRange: GR,
-        codegenExpression: qL,
-        compare: H_,
-        constant: Sn,
-        cumulativeLogNormal: mw,
-        cumulativeNormal: n1,
-        cumulativeUniform: xw,
-        dayofyear: eP,
-        debounce: Y_,
-        defaultLocale: tw,
-        definition: LP,
-        densityLogNormal: pw,
-        densityNormal: fw,
-        densityUniform: bw,
-        domChild: Vn,
-        domClear: sr,
-        domCreate: Os,
-        domFind: CS,
-        dotbin: GP,
-        error: G,
-        expressionFunction: $t,
-        extend: ke,
-        extent: Zr,
-        extentIndex: UR,
-        falsy: ds,
-        fastmap: Dc,
-        field: ri,
-        flush: qR,
-        font: v1,
-        fontFamily: Fd,
-        fontSize: fa,
-        format: dp,
-        formatLocale: $0,
-        formats: rw,
-        hasOwnProperty: pe,
-        id: yd,
-        identity: wn,
-        inferType: CP,
-        inferTypes: kP,
+        View: AL,
+        WEEK: Tt,
+        Warn: a_,
+        YEAR: Jt,
+        accessor: li,
+        accessorFields: pn,
+        accessorName: bt,
+        array: se,
+        ascending: $m,
+        bandwidthNRD: T_,
+        bin: JD,
+        bootstrapCI: QD,
+        boundClip: ZP,
+        boundContext: yd,
+        boundItem: u2,
+        boundMark: EP,
+        boundStroke: qs,
+        changeset: Tl,
+        clampRange: ZR,
+        codegenExpression: tL,
+        compare: f_,
+        constant: xn,
+        cumulativeLogNormal: N_,
+        cumulativeNormal: Lm,
+        cumulativeUniform: z_,
+        dayofyear: fD,
+        debounce: h_,
+        defaultLocale: x_,
+        definition: XD,
+        densityLogNormal: D_,
+        densityNormal: M_,
+        densityUniform: I_,
+        domChild: Yn,
+        domClear: Zi,
+        domCreate: pa,
+        domFind: Hw,
+        dotbin: ZD,
+        error: U,
+        expressionFunction: At,
+        extend: Ae,
+        extent: Hr,
+        extentIndex: eD,
+        falsy: ia,
+        fastmap: _c,
+        field: ni,
+        flush: tD,
+        font: Zm,
+        fontFamily: xd,
+        fontSize: is,
+        format: Vg,
+        formatLocale: f0,
+        formats: S_,
+        hasOwnProperty: me,
+        id: sd,
+        identity: bn,
+        inferType: LD,
+        inferTypes: ID,
         ingest: He,
-        inherits: Q,
-        inrange: Su,
-        interpolate: tS,
-        interpolateColors: c1,
-        interpolateRange: RN,
-        intersect: I4,
-        intersectBoxLine: Eu,
-        intersectPath: cS,
-        intersectPoint: fS,
-        intersectRule: n4,
-        isArray: q,
-        isBoolean: co,
-        isDate: Ds,
-        isFunction: Ae,
-        isIterable: WR,
-        isNumber: tt,
-        isObject: se,
-        isRegExp: HR,
+        inherits: ee,
+        inrange: hu,
+        interpolate: _w,
+        interpolateColors: qm,
+        interpolateRange: qN,
+        intersect: VP,
+        intersectBoxLine: du,
+        intersectPath: Mw,
+        intersectPoint: Ow,
+        intersectRule: dP,
+        isArray: W,
+        isBoolean: Za,
+        isDate: Ea,
+        isFunction: $e,
+        isIterable: nD,
+        isNumber: Ze,
+        isObject: ae,
+        isRegExp: iD,
         isString: re,
-        isTuple: Jm,
-        key: X_,
-        lerp: YR,
-        lineHeight: Ws,
-        loader: Vm,
-        locale: EP,
-        logger: G_,
-        lruCache: XR,
-        markup: FS,
-        merge: VR,
-        mergeConfig: Mc,
-        multiLineOffset: wS,
-        one: $c,
-        pad: KR,
-        panLinear: NR,
-        panLog: LR,
-        panPow: IR,
-        panSymlog: jR,
-        parse: dce,
-        parseExpression: _E,
-        parseSelector: ho,
-        path: km,
-        pathCurves: sS,
-        pathEqual: U4,
-        pathParse: ic,
-        pathRectangle: JN,
-        pathRender: Ih,
-        pathSymbols: KN,
-        pathTrail: QN,
-        peek: Le,
-        point: x1,
-        projection: HS,
-        quantileLogNormal: yw,
-        quantileNormal: i1,
-        quantileUniform: _w,
-        quantiles: lw,
-        quantizeInterpolator: PN,
-        quarter: zR,
-        quartiles: uw,
+        isTuple: Fm,
+        key: d_,
+        lerp: rD,
+        lineHeight: Na,
+        loader: Mm,
+        locale: ND,
+        logger: o_,
+        lruCache: sD,
+        markup: Qw,
+        merge: aD,
+        mergeConfig: bc,
+        multiLineOffset: Uw,
+        one: vc,
+        pad: oD,
+        panLinear: YR,
+        panLog: XR,
+        panPow: VR,
+        panSymlog: KR,
+        parse: _ue,
+        parseExpression: jS,
+        parseSelector: to,
+        path: om,
+        pathCurves: kw,
+        pathEqual: e4,
+        pathParse: Hu,
+        pathRectangle: lP,
+        pathRender: kh,
+        pathSymbols: oP,
+        pathTrail: uP,
+        peek: De,
+        point: t1,
+        projection: hS,
+        quantileLogNormal: P_,
+        quantileNormal: Im,
+        quantileUniform: B_,
+        quantiles: A_,
+        quantizeInterpolator: HN,
+        quarter: JR,
+        quartiles: $_,
         get random() {
-            return zi
+            return Ni
         },
-        randomInteger: pK,
-        randomKDE: dw,
-        randomLCG: gK,
-        randomLogNormal: qP,
-        randomMixture: WP,
-        randomNormal: hw,
-        randomUniform: HP,
-        read: $P,
-        regressionExp: XP,
-        regressionLinear: ww,
-        regressionLoess: JP,
-        regressionLog: YP,
-        regressionPoly: KP,
-        regressionPow: VP,
-        regressionQuad: Sw,
-        renderModule: _1,
-        repeat: qf,
-        resetDefaultLocale: fV,
-        resetSVGClipId: e4,
-        resetSVGDefIds: mee,
-        responseType: TP,
-        runtimeContext: iI,
-        sampleCurve: a1,
-        sampleLogNormal: gw,
-        sampleNormal: t1,
-        sampleUniform: vw,
-        scale: qe,
-        sceneEqual: PS,
-        sceneFromJSON: p4,
-        scenePickVisit: P0,
-        sceneToJSON: g4,
-        sceneVisit: _r,
-        sceneZOrder: hS,
-        scheme: nS,
-        serializeXML: $4,
-        setRandom: hK,
-        span: vd,
-        splitAccessPath: ca,
+        randomInteger: SV,
+        randomKDE: F_,
+        randomLCG: wV,
+        randomLogNormal: tN,
+        randomMixture: nN,
+        randomNormal: O_,
+        randomUniform: iN,
+        read: jD,
+        regressionConstant: j_,
+        regressionExp: sN,
+        regressionLinear: U_,
+        regressionLoess: lN,
+        regressionLog: rN,
+        regressionPoly: oN,
+        regressionPow: aN,
+        regressionQuad: G_,
+        renderModule: n1,
+        repeat: Ff,
+        resetDefaultLocale: bX,
+        resetSVGClipId: fP,
+        resetSVGDefIds: EZ,
+        responseType: BD,
+        runtimeContext: gL,
+        sampleCurve: Bm,
+        sampleLogNormal: R_,
+        sampleNormal: Pm,
+        sampleUniform: L_,
+        scale: We,
+        sceneEqual: tS,
+        sceneFromJSON: kP,
+        scenePickVisit: m0,
+        sceneToJSON: CP,
+        sceneVisit: dr,
+        sceneZOrder: Fw,
+        scheme: ww,
+        serializeXML: jP,
+        setRandom: xV,
+        span: ad,
+        splitAccessPath: ns,
         stringValue: Z,
-        textMetrics: dr,
-        timeBin: yP,
-        timeFloor: oP,
-        timeFormatLocale: Ph,
-        timeInterval: Rc,
-        timeOffset: cP,
-        timeSequence: dP,
-        timeUnitSpecifier: ZR,
-        timeUnits: Z_,
-        toBoolean: V_,
-        toDate: K_,
-        toNumber: gn,
-        toSet: br,
-        toString: J_,
-        transform: IP,
-        transforms: Zu,
-        truncate: JR,
-        truthy: Ii,
-        tupleid: de,
-        typeParsers: O2,
-        utcFloor: lP,
-        utcInterval: Pc,
-        utcOffset: fP,
-        utcSequence: gP,
-        utcdayofyear: iP,
-        utcquarter: BR,
-        utcweek: rP,
-        version: gce,
-        visitArray: ys,
-        week: tP,
-        writeConfig: Fc,
-        zero: ws,
-        zoomLinear: U_,
-        zoomLog: q_,
-        zoomPow: T0,
-        zoomSymlog: W_
+        textMetrics: sr,
+        timeBin: $D,
+        timeFloor: vD,
+        timeFormatLocale: Sh,
+        timeInterval: wc,
+        timeOffset: _D,
+        timeSequence: ED,
+        timeUnitSpecifier: cD,
+        timeUnits: v_,
+        toBoolean: g_,
+        toDate: p_,
+        toNumber: hn,
+        toSet: fr,
+        toString: m_,
+        transform: VD,
+        transforms: Uu,
+        truncate: lD,
+        truthy: Ri,
+        tupleid: ge,
+        typeParsers: Zb,
+        utcFloor: bD,
+        utcInterval: Sc,
+        utcOffset: wD,
+        utcSequence: CD,
+        utcdayofyear: gD,
+        utcquarter: QR,
+        utcweek: pD,
+        version: wue,
+        visitArray: oa,
+        week: hD,
+        writeConfig: xc,
+        zero: ha,
+        zoomLinear: l_,
+        zoomLog: u_,
+        zoomPow: c0,
+        zoomSymlog: c_
     }, Symbol.toStringTag, {
         value: "Module"
     }));
 
-    function mce(e, t, n) {
+    function Eue(e, t, n) {
         let i;
         t.x2 && (t.x ? (n && e.x > e.x2 && (i = e.x, e.x = e.x2, e.x2 = i), e.width = e.x2 - e.x) : e.x = e.x2 - (e.width || 0)), t.xc && (e.x = e.xc - (e.width || 0) / 2), t.y2 && (t.y ? (n && e.y > e.y2 && (i = e.y, e.y = e.y2, e.y2 = i), e.height = e.y2 - e.y) : e.y = e.y2 - (e.height || 0)), t.yc && (e.y = e.yc - (e.height || 0) / 2)
     }
-    var yce = {
+    var Cue = {
             NaN: NaN,
             E: Math.E,
             LN2: Math.LN2,
             LN10: Math.LN10,
             LOG2E: Math.LOG2E,
             LOG10E: Math.LOG10E,
             PI: Math.PI,
             SQRT1_2: Math.SQRT1_2,
             SQRT2: Math.SQRT2,
             MIN_VALUE: Number.MIN_VALUE,
             MAX_VALUE: Number.MAX_VALUE
         },
-        vce = {
+        kue = {
             "*": (e, t) => e * t,
             "+": (e, t) => e + t,
             "-": (e, t) => e - t,
             "/": (e, t) => e / t,
             "%": (e, t) => e % t,
             ">": (e, t) => e > t,
             "<": (e, t) => e < t,
@@ -35573,27 +35595,27 @@
             "&": (e, t) => e & t,
             "|": (e, t) => e | t,
             "^": (e, t) => e ^ t,
             "<<": (e, t) => e << t,
             ">>": (e, t) => e >> t,
             ">>>": (e, t) => e >>> t
         },
-        bce = {
+        Aue = {
             "+": e => +e,
             "-": e => -e,
             "~": e => ~e,
             "!": e => !e
         };
-    const xce = Array.prototype.slice,
-        Ao = (e, t, n) => {
+    const $ue = Array.prototype.slice,
+        mo = (e, t, n) => {
             const i = n ? n(t[0]) : t[0];
-            return i[e].apply(i, xce.call(t, 1))
+            return i[e].apply(i, $ue.call(t, 1))
         },
-        _ce = (e, t, n, i, r, a, s) => new Date(e, t || 0, n ?? 1, i || 0, r || 0, a || 0, s || 0);
-    var wce = {
+        Tue = (e, t, n, i, r, s, a) => new Date(e, t || 0, n ?? 1, i || 0, r || 0, s || 0, a || 0);
+    var Mue = {
         isNaN: Number.isNaN,
         isFinite: Number.isFinite,
         abs: Math.abs,
         acos: Math.acos,
         asin: Math.asin,
         atan: Math.atan,
         atan2: Math.atan2,
@@ -35609,15 +35631,15 @@
         round: Math.round,
         sin: Math.sin,
         sqrt: Math.sqrt,
         tan: Math.tan,
         clamp: (e, t, n) => Math.max(t, Math.min(n, e)),
         now: Date.now,
         utc: Date.UTC,
-        datetime: _ce,
+        datetime: Tue,
         date: e => new Date(e).getDate(),
         day: e => new Date(e).getDay(),
         year: e => new Date(e).getFullYear(),
         month: e => new Date(e).getMonth(),
         hours: e => new Date(e).getHours(),
         minutes: e => new Date(e).getMinutes(),
         seconds: e => new Date(e).getSeconds(),
@@ -35630,144 +35652,144 @@
         utcmonth: e => new Date(e).getUTCMonth(),
         utchours: e => new Date(e).getUTCHours(),
         utcminutes: e => new Date(e).getUTCMinutes(),
         utcseconds: e => new Date(e).getUTCSeconds(),
         utcmilliseconds: e => new Date(e).getUTCMilliseconds(),
         length: e => e.length,
         join: function() {
-            return Ao("join", arguments)
+            return mo("join", arguments)
         },
         indexof: function() {
-            return Ao("indexOf", arguments)
+            return mo("indexOf", arguments)
         },
         lastindexof: function() {
-            return Ao("lastIndexOf", arguments)
+            return mo("lastIndexOf", arguments)
         },
         slice: function() {
-            return Ao("slice", arguments)
+            return mo("slice", arguments)
         },
         reverse: e => e.slice().reverse(),
         parseFloat,
         parseInt,
         upper: e => String(e).toUpperCase(),
         lower: e => String(e).toLowerCase(),
         substring: function() {
-            return Ao("substring", arguments, String)
+            return mo("substring", arguments, String)
         },
         split: function() {
-            return Ao("split", arguments, String)
+            return mo("split", arguments, String)
         },
         replace: function() {
-            return Ao("replace", arguments, String)
+            return mo("replace", arguments, String)
         },
         trim: e => String(e).trim(),
         regexp: RegExp,
         test: (e, t) => RegExp(e).test(t)
     };
-    const Sce = ["view", "item", "group", "xy", "x", "y"],
-        px = new Set([Function, eval, setTimeout, setInterval]);
-    typeof setImmediate == "function" && px.add(setImmediate);
-    const Ece = {
+    const Oue = ["view", "item", "group", "xy", "x", "y"],
+        G2 = new Set([Function, eval, setTimeout, setInterval]);
+    typeof setImmediate == "function" && G2.add(setImmediate);
+    const Fue = {
         Literal: (e, t) => t.value,
         Identifier: (e, t) => {
             const n = t.name;
-            return e.memberDepth > 0 ? n : n === "datum" ? e.datum : n === "event" ? e.event : n === "item" ? e.item : yce[n] || e.params["$" + n]
+            return e.memberDepth > 0 ? n : n === "datum" ? e.datum : n === "event" ? e.event : n === "item" ? e.item : Cue[n] || e.params["$" + n]
         },
         MemberExpression: (e, t) => {
             const n = !t.computed,
                 i = e(t.object);
             n && (e.memberDepth += 1);
             const r = e(t.property);
-            if (n && (e.memberDepth -= 1), px.has(i[r])) {
+            if (n && (e.memberDepth -= 1), G2.has(i[r])) {
                 console.error(`Prevented interpretation of member "${r}" which could lead to insecure code execution`);
                 return
             }
             return i[r]
         },
         CallExpression: (e, t) => {
             const n = t.arguments;
             let i = t.callee.name;
-            return i.startsWith("_") && (i = i.slice(1)), i === "if" ? e(n[0]) ? e(n[1]) : e(n[2]) : (e.fn[i] || wce[i]).apply(e.fn, n.map(e))
+            return i.startsWith("_") && (i = i.slice(1)), i === "if" ? e(n[0]) ? e(n[1]) : e(n[2]) : (e.fn[i] || Mue[i]).apply(e.fn, n.map(e))
         },
         ArrayExpression: (e, t) => t.elements.map(e),
-        BinaryExpression: (e, t) => vce[t.operator](e(t.left), e(t.right)),
-        UnaryExpression: (e, t) => bce[t.operator](e(t.argument)),
+        BinaryExpression: (e, t) => kue[t.operator](e(t.left), e(t.right)),
+        UnaryExpression: (e, t) => Aue[t.operator](e(t.argument)),
         ConditionalExpression: (e, t) => e(t.test) ? e(t.consequent) : e(t.alternate),
         LogicalExpression: (e, t) => t.operator === "&&" ? e(t.left) && e(t.right) : e(t.left) || e(t.right),
         ObjectExpression: (e, t) => t.properties.reduce((n, i) => {
             e.memberDepth += 1;
             const r = e(i.key);
-            return e.memberDepth -= 1, px.has(e(i.value)) ? console.error(`Prevented interpretation of property "${r}" which could lead to insecure code execution`) : n[r] = e(i.value), n
+            return e.memberDepth -= 1, G2.has(e(i.value)) ? console.error(`Prevented interpretation of property "${r}" which could lead to insecure code execution`) : n[r] = e(i.value), n
         }, {})
     };
 
-    function Sf(e, t, n, i, r, a) {
-        const s = o => Ece[o.type](s, o);
-        return s.memberDepth = 0, s.fn = Object.create(t), s.params = n, s.datum = i, s.event = r, s.item = a, Sce.forEach(o => s.fn[o] = function() {
+    function cf(e, t, n, i, r, s) {
+        const a = o => Fue[o.type](a, o);
+        return a.memberDepth = 0, a.fn = Object.create(t), a.params = n, a.datum = i, a.event = r, a.item = s, Oue.forEach(o => a.fn[o] = function() {
             return r.vega[o](...arguments)
-        }), s(e)
+        }), a(e)
     }
-    var Oce = {
+    var Rue = {
         operator(e, t) {
             const n = t.ast,
                 i = e.functions;
-            return r => Sf(n, i, r)
+            return r => cf(n, i, r)
         },
         parameter(e, t) {
             const n = t.ast,
                 i = e.functions;
-            return (r, a) => Sf(n, i, a, r)
+            return (r, s) => cf(n, i, s, r)
         },
         event(e, t) {
             const n = t.ast,
                 i = e.functions;
-            return r => Sf(n, i, void 0, void 0, r)
+            return r => cf(n, i, void 0, void 0, r)
         },
         handler(e, t) {
             const n = t.ast,
                 i = e.functions;
-            return (r, a) => {
-                const s = a.item && a.item.datum;
-                return Sf(n, i, r, s, a)
+            return (r, s) => {
+                const a = s.item && s.item.datum;
+                return cf(n, i, r, a, s)
             }
         },
         encode(e, t) {
             const {
                 marktype: n,
                 channels: i
-            } = t, r = e.functions, a = n === "group" || n === "image" || n === "rect";
-            return (s, o) => {
-                const l = s.datum;
+            } = t, r = e.functions, s = n === "group" || n === "image" || n === "rect";
+            return (a, o) => {
+                const l = a.datum;
                 let u = 0,
                     c;
-                for (const f in i) c = Sf(i[f].ast, r, o, l, void 0, s), s[f] !== c && (s[f] = c, u = 1);
-                return n !== "rule" && mce(s, i, a), u
+                for (const f in i) c = cf(i[f].ast, r, o, l, void 0, a), a[f] !== c && (a[f] = c, u = 1);
+                return n !== "rule" && Eue(a, i, s), u
             }
         }
     };
-    const Cce = "vega-lite",
-        kce = 'Dominik Moritz, Kanit "Ham" Wongsuphasawat, Arvind Satyanarayan, Jeffrey Heer',
-        Ace = "5.6.1",
-        Tce = ["Kanit Wongsuphasawat (http://kanitw.yellowpigz.com)", "Dominik Moritz (https://www.domoritz.de)", "Arvind Satyanarayan (https://arvindsatya.com)", "Jeffrey Heer (https://jheer.org)"],
-        $ce = "https://vega.github.io/vega-lite/",
-        Mce = "Vega-Lite is a concise high-level language for interactive visualization.",
-        Fce = ["vega", "chart", "visualization"],
-        Dce = "build/vega-lite.js",
-        Rce = "build/vega-lite.min.js",
-        Pce = "build/vega-lite.min.js",
-        Nce = "build/src/index",
-        Lce = "build/src/index.d.ts",
-        Ice = {
+    const Due = "vega-lite",
+        Nue = 'Dominik Moritz, Kanit "Ham" Wongsuphasawat, Arvind Satyanarayan, Jeffrey Heer',
+        Pue = "5.9.3",
+        Lue = ["Kanit Wongsuphasawat (http://kanitw.yellowpigz.com)", "Dominik Moritz (https://www.domoritz.de)", "Arvind Satyanarayan (https://arvindsatya.com)", "Jeffrey Heer (https://jheer.org)"],
+        Iue = "https://vega.github.io/vega-lite/",
+        zue = "Vega-Lite is a concise high-level language for interactive visualization.",
+        Bue = ["vega", "chart", "visualization"],
+        jue = "build/vega-lite.js",
+        Uue = "build/vega-lite.min.js",
+        Gue = "build/vega-lite.min.js",
+        Wue = "build/src/index",
+        que = "build/src/index.d.ts",
+        Hue = {
             vl2pdf: "./bin/vl2pdf",
             vl2png: "./bin/vl2png",
             vl2svg: "./bin/vl2svg",
             vl2vg: "./bin/vl2vg"
         },
-        jce = ["bin", "build", "src", "vega-lite*", "tsconfig.json"],
-        zce = {
+        Yue = ["bin", "build", "src", "vega-lite*", "tsconfig.json"],
+        Xue = {
             changelog: "conventional-changelog -p angular -r 2",
             prebuild: "yarn clean:build",
             build: "yarn build:only",
             "build:only": "tsc -p tsconfig.build.json && rollup -c",
             "prebuild:examples": "yarn build:only",
             "build:examples": "yarn data && TZ=America/Los_Angeles scripts/build-examples.sh",
             "prebuild:examples-full": "yarn build:only",
@@ -35775,149 +35797,138 @@
             "build:example": "TZ=America/Los_Angeles scripts/build-example.sh",
             "build:toc": "yarn build:jekyll && scripts/generate-toc",
             "build:site": "rollup -c site/rollup.config.mjs",
             "build:jekyll": "pushd site && bundle exec jekyll build -q && popd",
             "build:versions": "scripts/update-version.sh",
             clean: "yarn clean:build && del-cli 'site/data/*' 'examples/compiled/*.png' && find site/examples ! -name 'index.md' ! -name 'data' -type f -delete",
             "clean:build": "del-cli 'build/*' !build/vega-lite-schema.json",
-            "predeploy:site": "yarn presite",
-            "deploy:site": "gh-pages -d site",
             data: "rsync -r node_modules/vega-datasets/data/* site/data",
             schema: "mkdir -p build && ts-json-schema-generator -f tsconfig.json -p src/index.ts -t TopLevelSpec --no-type-check --no-ref-encode > build/vega-lite-schema.json && yarn renameschema && cp build/vega-lite-schema.json site/_data/",
             renameschema: "scripts/rename-schema.sh",
             presite: "yarn data && yarn schema && yarn build:site && yarn build:versions && scripts/create-example-pages.sh",
             site: "yarn site:only",
             "site:only": "pushd site && bundle exec jekyll serve -I -l && popd",
             prettierbase: "prettier '**/*.{md,css,yml}'",
-            eslintbase: "eslint .",
-            format: "yarn eslintbase --fix && yarn prettierbase --write",
-            lint: "yarn eslintbase && yarn prettierbase --check",
+            format: "eslint . --fix && yarn prettierbase --write",
+            lint: "eslint . && yarn prettierbase --check",
             jest: "NODE_OPTIONS=--experimental-vm-modules npx jest",
             test: "yarn jest test/ && yarn lint && yarn schema && yarn jest examples/ && yarn test:runtime",
             "test:cover": "yarn jest --collectCoverage test/",
             "test:inspect": "node --inspect-brk --experimental-vm-modules ./node_modules/.bin/jest --runInBand test",
             "test:runtime": "NODE_OPTIONS=--experimental-vm-modules TZ=America/Los_Angeles npx jest test-runtime/ --config test-runtime/jest-config.json",
             "test:runtime:generate": "yarn build:only && del-cli test-runtime/resources && VL_GENERATE_TESTS=true yarn test:runtime",
             watch: "tsc -p tsconfig.build.json -w",
             "watch:site": "yarn build:site -w",
             "watch:test": "yarn jest --watch test/",
             "watch:test:runtime": "NODE_OPTIONS=--experimental-vm-modules TZ=America/Los_Angeles npx jest --watch test-runtime/ --config test-runtime/jest-config.json",
-            release: "yarn release-it"
+            release: "release-it"
         },
-        Bce = {
+        Vue = {
             type: "git",
             url: "https://github.com/vega/vega-lite.git"
         },
-        Gce = "BSD-3-Clause",
-        Uce = {
+        Kue = "BSD-3-Clause",
+        Jue = {
             url: "https://github.com/vega/vega-lite/issues"
         },
-        qce = {
-            "@babel/core": "^7.20.12",
-            "@babel/preset-env": "^7.20.2",
-            "@babel/preset-typescript": "^7.18.6",
+        Que = {
+            "@babel/core": "^7.21.8",
+            "@babel/preset-env": "^7.21.5",
+            "@babel/preset-typescript": "^7.21.5",
             "@release-it/conventional-changelog": "^5.1.1",
-            "@rollup/plugin-alias": "^4.0.3",
+            "@rollup/plugin-alias": "^5.0.0",
             "@rollup/plugin-babel": "^6.0.3",
-            "@rollup/plugin-commonjs": "^24.0.1",
+            "@rollup/plugin-commonjs": "^25.0.0",
             "@rollup/plugin-json": "^6.0.0",
-            "@rollup/plugin-node-resolve": "^15.0.1",
-            "@rollup/plugin-terser": "^0.4.0",
-            "@types/chai": "^4.3.4",
+            "@rollup/plugin-node-resolve": "^15.0.2",
+            "@rollup/plugin-terser": "^0.4.1",
+            "@types/chai": "^4.3.5",
             "@types/d3": "^7.4.0",
             "@types/jest": "^27.4.1",
-            "@types/mkdirp": "^1.0.2",
             "@types/pako": "^2.0.0",
-            "@typescript-eslint/eslint-plugin": "^5.52.0",
-            "@typescript-eslint/parser": "^5.52.0",
+            "@typescript-eslint/eslint-plugin": "^5.59.5",
+            "@typescript-eslint/parser": "^5.59.5",
             "ajv-formats": "^2.1.1",
             ajv: "^8.12.0",
             chai: "^4.3.7",
             cheerio: "^1.0.0-rc.12",
             "conventional-changelog-cli": "^2.2.2",
-            d3: "^7.8.2",
+            d3: "^7.8.4",
             "del-cli": "^5.0.0",
-            "eslint-config-prettier": "^8.6.0",
+            "eslint-config-prettier": "^8.8.0",
             "eslint-plugin-jest": "^27.2.1",
             "eslint-plugin-prettier": "^4.2.1",
-            eslint: "^8.34.0",
-            "gh-pages": "^5.0.0",
-            "highlight.js": "^11.7.0",
+            eslint: "^8.40.0",
+            "highlight.js": "^11.8.0",
             "jest-dev-server": "^6.1.1",
             jest: "^27.5.1",
-            mkdirp: "^2.1.3",
+            mkdirp: "^3.0.1",
             pako: "^2.1.0",
-            prettier: "^2.8.4",
+            prettier: "^2.8.8",
             puppeteer: "^15.0.0",
-            "release-it": "^15.6.0",
+            "release-it": "^15.10.3",
             "rollup-plugin-bundle-size": "^1.0.3",
             "rollup-plugin-sourcemaps": "^0.6.3",
-            rollup: "^3.15.0",
+            rollup: "^3.21.6",
             serve: "^14.2.0",
-            terser: "^5.16.3",
-            "ts-jest": "^29.0.5",
+            terser: "^5.17.3",
+            "ts-jest": "^29.1.0",
             "ts-json-schema-generator": "^1.2.0",
             typescript: "~4.9.5",
-            "vega-cli": "^5.22.1",
-            "vega-datasets": "~2.5.4",
-            "vega-embed": "^6.21.2",
-            "vega-tooltip": "^0.30.1",
+            "vega-cli": "^5.25.0",
+            "vega-datasets": "^2.7.0",
+            "vega-embed": "^6.22.1",
+            "vega-tooltip": "^0.32.0",
             "yaml-front-matter": "^4.1.1"
         },
-        Wce = {
+        Zue = {
             "@types/clone": "~2.1.1",
             clone: "~2.1.2",
             "fast-deep-equal": "~3.1.3",
             "fast-json-stable-stringify": "~2.1.0",
             "json-stringify-pretty-compact": "~3.0.0",
             tslib: "~2.5.0",
-            "vega-event-selector": "~3.0.0",
-            "vega-expression": "~5.0.0",
-            "vega-util": "~1.17.0",
-            yargs: "~17.6.2"
-        },
-        Hce = {
-            vega: "^5.22.0"
-        },
-        Yce = {
-            node: ">=12"
-        },
-        Xce = {
-            name: Cce,
-            author: kce,
-            version: Ace,
-            collaborators: Tce,
-            homepage: $ce,
-            description: Mce,
-            keywords: Fce,
-            main: Dce,
-            unpkg: Rce,
-            jsdelivr: Pce,
-            module: Nce,
-            types: Lce,
-            bin: Ice,
-            files: jce,
-            scripts: zce,
-            repository: Bce,
-            license: Gce,
-            bugs: Uce,
-            devDependencies: qce,
-            dependencies: Wce,
-            peerDependencies: Hce,
-            engines: Yce
-        };
-    var mx = {},
-        Vce = {
-            get exports() {
-                return mx
-            },
-            set exports(e) {
-                mx = e
-            }
+            "vega-event-selector": "~3.0.1",
+            "vega-expression": "~5.1.0",
+            "vega-util": "~1.17.2",
+            yargs: "~17.7.2"
+        },
+        ece = {
+            vega: "^5.24.0"
+        },
+        tce = {
+            node: ">=16"
+        },
+        nce = {
+            name: Due,
+            author: Nue,
+            version: Pue,
+            collaborators: Lue,
+            homepage: Iue,
+            description: zue,
+            keywords: Bue,
+            main: jue,
+            unpkg: Uue,
+            jsdelivr: Gue,
+            module: Wue,
+            types: que,
+            bin: Hue,
+            files: Yue,
+            scripts: Xue,
+            repository: Vue,
+            license: Kue,
+            bugs: Jue,
+            devDependencies: Que,
+            dependencies: Zue,
+            peerDependencies: ece,
+            engines: tce
         };
+    var cI = {
+        exports: {}
+    };
     (function(e) {
         var t = function() {
             function n(h, d) {
                 return d != null && h instanceof d
             }
             var i;
             try {
@@ -35927,511 +35938,512 @@
             }
             var r;
             try {
                 r = Set
             } catch {
                 r = function() {}
             }
-            var a;
+            var s;
             try {
-                a = Promise
+                s = Promise
             } catch {
-                a = function() {}
+                s = function() {}
             }
 
-            function s(h, d, g, p, m) {
+            function a(h, d, g, p, m) {
                 typeof d == "object" && (g = d.depth, p = d.prototype, m = d.includeNonEnumerable, d = d.circular);
                 var y = [],
                     v = [],
                     b = typeof Buffer < "u";
                 typeof d > "u" && (d = !0), typeof g > "u" && (g = 1 / 0);
 
                 function x(_, S) {
                     if (_ === null) return null;
                     if (S === 0) return _;
-                    var w, O;
+                    var w, E;
                     if (typeof _ != "object") return _;
                     if (n(_, i)) w = new i;
                     else if (n(_, r)) w = new r;
-                    else if (n(_, a)) w = new a(function(P, N) {
+                    else if (n(_, s)) w = new s(function(N, P) {
                         _.then(function(z) {
-                            P(x(z, S - 1))
-                        }, function(z) {
                             N(x(z, S - 1))
+                        }, function(z) {
+                            P(x(z, S - 1))
                         })
                     });
-                    else if (s.__isArray(_)) w = [];
-                    else if (s.__isRegExp(_)) w = new RegExp(_.source, f(_)), _.lastIndex && (w.lastIndex = _.lastIndex);
-                    else if (s.__isDate(_)) w = new Date(_.getTime());
+                    else if (a.__isArray(_)) w = [];
+                    else if (a.__isRegExp(_)) w = new RegExp(_.source, f(_)), _.lastIndex && (w.lastIndex = _.lastIndex);
+                    else if (a.__isDate(_)) w = new Date(_.getTime());
                     else {
                         if (b && Buffer.isBuffer(_)) return Buffer.allocUnsafe ? w = Buffer.allocUnsafe(_.length) : w = new Buffer(_.length), _.copy(w), w;
-                        n(_, Error) ? w = Object.create(_) : typeof p > "u" ? (O = Object.getPrototypeOf(_), w = Object.create(O)) : (w = Object.create(p), O = p)
+                        n(_, Error) ? w = Object.create(_) : typeof p > "u" ? (E = Object.getPrototypeOf(_), w = Object.create(E)) : (w = Object.create(p), E = p)
                     }
                     if (d) {
-                        var k = y.indexOf(_);
-                        if (k != -1) return v[k];
+                        var A = y.indexOf(_);
+                        if (A != -1) return v[A];
                         y.push(_), v.push(w)
                     }
-                    n(_, i) && _.forEach(function(P, N) {
-                        var z = x(N, S - 1),
-                            I = x(P, S - 1);
+                    n(_, i) && _.forEach(function(N, P) {
+                        var z = x(P, S - 1),
+                            I = x(N, S - 1);
                         w.set(z, I)
-                    }), n(_, r) && _.forEach(function(P) {
-                        var N = x(P, S - 1);
-                        w.add(N)
+                    }), n(_, r) && _.forEach(function(N) {
+                        var P = x(N, S - 1);
+                        w.add(P)
                     });
                     for (var C in _) {
-                        var E;
-                        O && (E = Object.getOwnPropertyDescriptor(O, C)), !(E && E.set == null) && (w[C] = x(_[C], S - 1))
+                        var k;
+                        E && (k = Object.getOwnPropertyDescriptor(E, C)), !(k && k.set == null) && (w[C] = x(_[C], S - 1))
                     }
                     if (Object.getOwnPropertySymbols)
-                        for (var T = Object.getOwnPropertySymbols(_), C = 0; C < T.length; C++) {
-                            var A = T[C],
-                                F = Object.getOwnPropertyDescriptor(_, A);
-                            F && !F.enumerable && !m || (w[A] = x(_[A], S - 1), F.enumerable || Object.defineProperty(w, A, {
+                        for (var R = Object.getOwnPropertySymbols(_), C = 0; C < R.length; C++) {
+                            var $ = R[C],
+                                T = Object.getOwnPropertyDescriptor(_, $);
+                            T && !T.enumerable && !m || (w[$] = x(_[$], S - 1), T.enumerable || Object.defineProperty(w, $, {
                                 enumerable: !1
                             }))
                         }
                     if (m)
-                        for (var $ = Object.getOwnPropertyNames(_), C = 0; C < $.length; C++) {
-                            var D = $[C],
-                                F = Object.getOwnPropertyDescriptor(_, D);
-                            F && F.enumerable || (w[D] = x(_[D], S - 1), Object.defineProperty(w, D, {
+                        for (var M = Object.getOwnPropertyNames(_), C = 0; C < M.length; C++) {
+                            var F = M[C],
+                                T = Object.getOwnPropertyDescriptor(_, F);
+                            T && T.enumerable || (w[F] = x(_[F], S - 1), Object.defineProperty(w, F, {
                                 enumerable: !1
                             }))
                         }
                     return w
                 }
                 return x(h, g)
             }
-            s.clonePrototype = function(d) {
+            a.clonePrototype = function(d) {
                 if (d === null) return null;
                 var g = function() {};
                 return g.prototype = d, new g
             };
 
             function o(h) {
                 return Object.prototype.toString.call(h)
             }
-            s.__objToStr = o;
+            a.__objToStr = o;
 
             function l(h) {
                 return typeof h == "object" && o(h) === "[object Date]"
             }
-            s.__isDate = l;
+            a.__isDate = l;
 
             function u(h) {
                 return typeof h == "object" && o(h) === "[object Array]"
             }
-            s.__isArray = u;
+            a.__isArray = u;
 
             function c(h) {
                 return typeof h == "object" && o(h) === "[object RegExp]"
             }
-            s.__isRegExp = c;
+            a.__isRegExp = c;
 
             function f(h) {
                 var d = "";
                 return h.global && (d += "g"), h.ignoreCase && (d += "i"), h.multiline && (d += "m"), d
             }
-            return s.__getRegExpFlags = f, s
+            return a.__getRegExpFlags = f, a
         }();
         e.exports && (e.exports = t)
-    })(Vce);
-    const Kce = mx;
-    var ZI = function e(t, n) {
-            if (t === n) return !0;
-            if (t && n && typeof t == "object" && typeof n == "object") {
-                if (t.constructor !== n.constructor) return !1;
-                var i, r, a;
-                if (Array.isArray(t)) {
-                    if (i = t.length, i != n.length) return !1;
-                    for (r = i; r-- !== 0;)
-                        if (!e(t[r], n[r])) return !1;
-                    return !0
-                }
-                if (t.constructor === RegExp) return t.source === n.source && t.flags === n.flags;
-                if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === n.valueOf();
-                if (t.toString !== Object.prototype.toString) return t.toString() === n.toString();
-                if (a = Object.keys(t), i = a.length, i !== Object.keys(n).length) return !1;
+    })(cI);
+    var ice = cI.exports;
+    const rce = Cm(ice);
+    var sce = function e(t, n) {
+        if (t === n) return !0;
+        if (t && n && typeof t == "object" && typeof n == "object") {
+            if (t.constructor !== n.constructor) return !1;
+            var i, r, s;
+            if (Array.isArray(t)) {
+                if (i = t.length, i != n.length) return !1;
                 for (r = i; r-- !== 0;)
-                    if (!Object.prototype.hasOwnProperty.call(n, a[r])) return !1;
-                for (r = i; r-- !== 0;) {
-                    var s = a[r];
-                    if (!e(t[s], n[s])) return !1
-                }
+                    if (!e(t[r], n[r])) return !1;
                 return !0
             }
-            return t !== t && n !== n
-        },
-        VE = function(e, t) {
-            t || (t = {}), typeof t == "function" && (t = {
-                cmp: t
-            });
-            var n = typeof t.cycles == "boolean" ? t.cycles : !1,
-                i = t.cmp && function(a) {
-                    return function(s) {
-                        return function(o, l) {
-                            var u = {
-                                    key: o,
-                                    value: s[o]
-                                },
-                                c = {
-                                    key: l,
-                                    value: s[l]
-                                };
-                            return a(u, c)
-                        }
-                    }
-                }(t.cmp),
-                r = [];
-            return function a(s) {
-                if (s && s.toJSON && typeof s.toJSON == "function" && (s = s.toJSON()), s !== void 0) {
-                    if (typeof s == "number") return isFinite(s) ? "" + s : "null";
-                    if (typeof s != "object") return JSON.stringify(s);
-                    var o, l;
-                    if (Array.isArray(s)) {
-                        for (l = "[", o = 0; o < s.length; o++) o && (l += ","), l += a(s[o]) || "null";
-                        return l + "]"
-                    }
-                    if (s === null) return "null";
-                    if (r.indexOf(s) !== -1) {
-                        if (n) return JSON.stringify("__cycle__");
-                        throw new TypeError("Converting circular structure to JSON")
-                    }
-                    var u = r.push(s) - 1,
-                        c = Object.keys(s).sort(i && i(s));
-                    for (l = "", o = 0; o < c.length; o++) {
-                        var f = c[o],
-                            h = a(s[f]);
-                        h && (l && (l += ","), l += JSON.stringify(f) + ":" + h)
+            if (t.constructor === RegExp) return t.source === n.source && t.flags === n.flags;
+            if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === n.valueOf();
+            if (t.toString !== Object.prototype.toString) return t.toString() === n.toString();
+            if (s = Object.keys(t), i = s.length, i !== Object.keys(n).length) return !1;
+            for (r = i; r-- !== 0;)
+                if (!Object.prototype.hasOwnProperty.call(n, s[r])) return !1;
+            for (r = i; r-- !== 0;) {
+                var a = s[r];
+                if (!e(t[a], n[a])) return !1
+            }
+            return !0
+        }
+        return t !== t && n !== n
+    };
+    const fI = Cm(sce);
+    var ace = function(e, t) {
+        t || (t = {}), typeof t == "function" && (t = {
+            cmp: t
+        });
+        var n = typeof t.cycles == "boolean" ? t.cycles : !1,
+            i = t.cmp && function(s) {
+                return function(a) {
+                    return function(o, l) {
+                        var u = {
+                                key: o,
+                                value: a[o]
+                            },
+                            c = {
+                                key: l,
+                                value: a[l]
+                            };
+                        return s(u, c)
                     }
-                    return r.splice(u, 1), "{" + l + "}"
                 }
-            }(e)
-        };
+            }(t.cmp),
+            r = [];
+        return function s(a) {
+            if (a && a.toJSON && typeof a.toJSON == "function" && (a = a.toJSON()), a !== void 0) {
+                if (typeof a == "number") return isFinite(a) ? "" + a : "null";
+                if (typeof a != "object") return JSON.stringify(a);
+                var o, l;
+                if (Array.isArray(a)) {
+                    for (l = "[", o = 0; o < a.length; o++) o && (l += ","), l += s(a[o]) || "null";
+                    return l + "]"
+                }
+                if (a === null) return "null";
+                if (r.indexOf(a) !== -1) {
+                    if (n) return JSON.stringify("__cycle__");
+                    throw new TypeError("Converting circular structure to JSON")
+                }
+                var u = r.push(a) - 1,
+                    c = Object.keys(a).sort(i && i(a));
+                for (l = "", o = 0; o < c.length; o++) {
+                    var f = c[o],
+                        h = s(a[f]);
+                    h && (l && (l += ","), l += JSON.stringify(f) + ":" + h)
+                }
+                return r.splice(u, 1), "{" + l + "}"
+            }
+        }(e)
+    };
+    const pE = Cm(ace);
 
-    function KE(e) {
+    function mE(e) {
         return !!e.or
     }
 
-    function JE(e) {
+    function yE(e) {
         return !!e.and
     }
 
-    function QE(e) {
+    function vE(e) {
         return !!e.not
     }
 
-    function Fp(e, t) {
-        if (QE(e)) Fp(e.not, t);
-        else if (JE(e))
-            for (const n of e.and) Fp(n, t);
-        else if (KE(e))
-            for (const n of e.or) Fp(n, t);
+    function gp(e, t) {
+        if (vE(e)) gp(e.not, t);
+        else if (yE(e))
+            for (const n of e.and) gp(n, t);
+        else if (mE(e))
+            for (const n of e.or) gp(n, t);
         else t(e)
     }
 
-    function Pu(e, t) {
-        return QE(e) ? {
-            not: Pu(e.not, t)
-        } : JE(e) ? {
-            and: e.and.map(n => Pu(n, t))
-        } : KE(e) ? {
-            or: e.or.map(n => Pu(n, t))
+    function Eu(e, t) {
+        return vE(e) ? {
+            not: Eu(e.not, t)
+        } : yE(e) ? {
+            and: e.and.map(n => Eu(n, t))
+        } : mE(e) ? {
+            or: e.or.map(n => Eu(n, t))
         } : t(e)
     }
-    const Br = ZI,
-        Ce = Kce;
+    const Nr = fI,
+        ke = rce;
 
-    function ej(e) {
+    function hI(e) {
         throw new Error(e)
     }
 
-    function uc(e, t) {
+    function Qu(e, t) {
         const n = {};
-        for (const i of t) pe(e, i) && (n[i] = e[i]);
+        for (const i of t) me(e, i) && (n[i] = e[i]);
         return n
     }
 
-    function Zn(e, t) {
-        const n = Object.assign({}, e);
+    function Jn(e, t) {
+        const n = {
+            ...e
+        };
         for (const i of t) delete n[i];
         return n
     }
     Set.prototype.toJSON = function() {
-        return `Set(${[...this].map(e=>VE(e)).join(",")})`
+        return `Set(${[...this].map(e=>pE(e)).join(",")})`
     };
-    const ot = VE;
+    const at = pE;
 
-    function Ie(e) {
-        if (tt(e)) return e;
-        const t = re(e) ? e : VE(e);
+    function Ne(e) {
+        if (Ze(e)) return e;
+        const t = re(e) ? e : pE(e);
         if (t.length < 250) return t;
         let n = 0;
         for (let i = 0; i < t.length; i++) {
             const r = t.charCodeAt(i);
             n = (n << 5) - n + r, n = n & n
         }
         return n
     }
 
-    function yx(e) {
+    function W2(e) {
         return e === !1 || e === null
     }
 
-    function Pe(e, t) {
+    function Fe(e, t) {
         return e.includes(t)
     }
 
-    function bl(e, t) {
+    function ol(e, t) {
         let n = 0;
         for (const [i, r] of e.entries())
             if (t(r, i, n++)) return !0;
         return !1
     }
 
-    function ZE(e, t) {
+    function bE(e, t) {
         let n = 0;
         for (const [i, r] of e.entries())
             if (!t(r, i, n++)) return !1;
         return !0
     }
 
-    function tj(e, ...t) {
-        for (const n of t) Jce(e, n ?? {});
+    function dI(e, ...t) {
+        for (const n of t) oce(e, n ?? {});
         return e
     }
 
-    function Jce(e, t) {
-        for (const n of Y(t)) Fc(e, n, t[n], !0)
+    function oce(e, t) {
+        for (const n of H(t)) xc(e, n, t[n], !0)
     }
 
-    function Gr(e, t) {
+    function Pr(e, t) {
         const n = [],
             i = {};
         let r;
-        for (const a of e) r = t(a), !(r in i) && (i[r] = 1, n.push(a));
+        for (const s of e) r = t(s), !(r in i) && (i[r] = 1, n.push(s));
         return n
     }
 
-    function Qce(e, t) {
-        const n = Y(e),
-            i = Y(t);
+    function lce(e, t) {
+        const n = H(e),
+            i = H(t);
         if (n.length !== i.length) return !1;
         for (const r of n)
             if (e[r] !== t[r]) return !1;
         return !0
     }
 
-    function nj(e, t) {
+    function gI(e, t) {
         if (e.size !== t.size) return !1;
         for (const n of e)
             if (!t.has(n)) return !1;
         return !0
     }
 
-    function eO(e, t) {
+    function xE(e, t) {
         for (const n of e)
             if (t.has(n)) return !0;
         return !1
     }
 
-    function vx(e) {
+    function q2(e) {
         const t = new Set;
         for (const n of e) {
-            const r = ca(n).map((s, o) => o === 0 ? s : `[${s}]`),
-                a = r.map((s, o) => r.slice(0, o + 1).join(""));
-            for (const s of a) t.add(s)
+            const r = ns(n).map((a, o) => o === 0 ? a : `[${a}]`),
+                s = r.map((a, o) => r.slice(0, o + 1).join(""));
+            for (const a of s) t.add(a)
         }
         return t
     }
 
-    function tO(e, t) {
-        return e === void 0 || t === void 0 ? !0 : eO(vx(e), vx(t))
+    function _E(e, t) {
+        return e === void 0 || t === void 0 ? !0 : xE(q2(e), q2(t))
     }
 
     function et(e) {
-        return Y(e).length === 0
+        return H(e).length === 0
     }
-    const Y = Object.keys,
-        _n = Object.values,
-        Ks = Object.entries;
+    const H = Object.keys,
+        Qt = Object.values,
+        Ba = Object.entries;
 
-    function Kh(e) {
+    function Ih(e) {
         return e === !0 || e === !1
     }
 
-    function ht(e) {
+    function ft(e) {
         const t = e.replace(/\W/g, "_");
         return (e.match(/^\d+/) ? "_" : "") + t
     }
 
-    function bh(e, t) {
-        return QE(e) ? `!(${bh(e.not,t)})` : JE(e) ? `(${e.and.map(n=>bh(n,t)).join(") && (")})` : KE(e) ? `(${e.or.map(n=>bh(n,t)).join(") || (")})` : t(e)
+    function oh(e, t) {
+        return vE(e) ? `!(${oh(e.not,t)})` : yE(e) ? `(${e.and.map(n=>oh(n,t)).join(") && (")})` : mE(e) ? `(${e.or.map(n=>oh(n,t)).join(") || (")})` : t(e)
     }
 
-    function em(e, t) {
+    function N0(e, t) {
         if (t.length === 0) return !0;
         const n = t.shift();
-        return n in e && em(e[n], t) && delete e[n], et(e)
+        return n in e && N0(e[n], t) && delete e[n], et(e)
     }
 
-    function zd(e) {
+    function $d(e) {
         return e.charAt(0).toUpperCase() + e.substr(1)
     }
 
-    function nO(e, t = "datum") {
-        const n = ca(e),
+    function wE(e, t = "datum") {
+        const n = ns(e),
             i = [];
         for (let r = 1; r <= n.length; r++) {
-            const a = `[${n.slice(0,r).map(Z).join("][")}]`;
-            i.push(`${t}${a}`)
+            const s = `[${n.slice(0,r).map(Z).join("][")}]`;
+            i.push(`${t}${s}`)
         }
         return i.join(" && ")
     }
 
-    function ij(e, t = "datum") {
-        return `${t}[${Z(ca(e).join("."))}]`
+    function pI(e, t = "datum") {
+        return `${t}[${Z(ns(e).join("."))}]`
     }
 
-    function Zce(e) {
+    function uce(e) {
         return e.replace(/(\[|\]|\.|'|")/g, "\\$1")
     }
 
-    function Bi(e) {
-        return `${ca(e).map(Zce).join("\\.")}`
+    function Pi(e) {
+        return `${ns(e).map(uce).join("\\.")}`
     }
 
-    function xl(e, t, n) {
+    function ll(e, t, n) {
         return e.replace(new RegExp(t.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&"), "g"), n)
     }
 
-    function iO(e) {
-        return `${ca(e).join(".")}`
+    function SE(e) {
+        return `${ns(e).join(".")}`
     }
 
-    function cc(e) {
-        return e ? ca(e).length : 0
+    function Zu(e) {
+        return e ? ns(e).length : 0
     }
 
-    function Tt(...e) {
+    function Ct(...e) {
         for (const t of e)
             if (t !== void 0) return t
     }
-    let rj = 42;
+    let mI = 42;
 
-    function aj(e) {
-        const t = ++rj;
+    function yI(e) {
+        const t = ++mI;
         return e ? String(e) + t : t
     }
 
-    function efe() {
-        rj = 42
+    function cce() {
+        mI = 42
     }
 
-    function sj(e) {
-        return oj(e) ? e : `__${e}`
+    function vI(e) {
+        return bI(e) ? e : `__${e}`
     }
 
-    function oj(e) {
+    function bI(e) {
         return e.startsWith("__")
     }
 
-    function Jh(e) {
+    function zh(e) {
         if (e !== void 0) return (e % 360 + 360) % 360
     }
 
-    function j1(e) {
-        return tt(e) ? !0 : !isNaN(e) && !isNaN(parseFloat(e))
+    function x1(e) {
+        return Ze(e) ? !0 : !isNaN(e) && !isNaN(parseFloat(e))
     }
-    var Bd = globalThis && globalThis.__rest || function(e, t) {
-        var n = {};
-        for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && t.indexOf(i) < 0 && (n[i] = e[i]);
-        if (e != null && typeof Object.getOwnPropertySymbols == "function")
-            for (var r = 0, i = Object.getOwnPropertySymbols(e); r < i.length; r++) t.indexOf(i[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, i[r]) && (n[i[r]] = e[i[r]]);
-        return n
-    };
-    const Ga = "row",
-        Ua = "column",
-        z1 = "facet",
-        yt = "x",
-        Yt = "y",
-        kr = "x2",
-        ga = "y2",
-        go = "xOffset",
-        Gc = "yOffset",
-        Ar = "radius",
-        is = "radius2",
-        Wi = "theta",
-        rs = "theta2",
-        pa = "latitude",
-        ma = "longitude",
-        Tr = "latitude2",
-        Gi = "longitude2",
-        oi = "color",
-        ya = "fill",
-        va = "stroke",
-        li = "shape",
-        as = "size",
-        Wl = "angle",
-        ss = "opacity",
-        po = "fillOpacity",
-        mo = "strokeOpacity",
-        yo = "strokeWidth",
-        vo = "strokeDash",
-        Gd = "text",
-        Ud = "order",
-        qd = "detail",
-        B1 = "key",
-        _l = "tooltip",
-        G1 = "href",
-        U1 = "url",
-        q1 = "description",
-        tfe = {
+    const Fs = "row",
+        Rs = "column",
+        _1 = "facet",
+        ht = "x",
+        Gt = "y",
+        xr = "x2",
+        as = "y2",
+        no = "xOffset",
+        Mc = "yOffset",
+        _r = "radius",
+        Xs = "radius2",
+        zi = "theta",
+        Vs = "theta2",
+        wr = "latitude",
+        Sr = "longitude",
+        Er = "latitude2",
+        Li = "longitude2",
+        si = "color",
+        os = "fill",
+        ls = "stroke",
+        ai = "shape",
+        Ks = "size",
+        Dl = "angle",
+        Js = "opacity",
+        io = "fillOpacity",
+        ro = "strokeOpacity",
+        so = "strokeWidth",
+        ao = "strokeDash",
+        Td = "text",
+        ec = "order",
+        Md = "detail",
+        w1 = "key",
+        ul = "tooltip",
+        S1 = "href",
+        E1 = "url",
+        C1 = "description",
+        fce = {
             x: 1,
             y: 1,
             x2: 1,
             y2: 1
         },
-        lj = {
+        xI = {
             theta: 1,
             theta2: 1,
             radius: 1,
             radius2: 1
         };
 
-    function uj(e) {
-        return e in lj
+    function _I(e) {
+        return e in xI
     }
-    const rO = {
+    const EE = {
         longitude: 1,
         longitude2: 1,
         latitude: 1,
         latitude2: 1
     };
 
-    function nfe(e) {
+    function wI(e) {
         switch (e) {
-            case pa:
+            case wr:
                 return "y";
-            case Tr:
+            case Er:
                 return "y2";
-            case ma:
+            case Sr:
                 return "x";
-            case Gi:
+            case Li:
                 return "x2"
         }
     }
 
-    function ife(e) {
-        return e in rO
+    function SI(e) {
+        return e in EE
     }
-    const rfe = Y(rO),
-        aO = Object.assign(Object.assign(Object.assign(Object.assign({}, tfe), lj), rO), {
+    const hce = H(EE),
+        CE = {
+            ...fce,
+            ...xI,
+            ...EE,
             xOffset: 1,
             yOffset: 1,
             color: 1,
             fill: 1,
             stroke: 1,
             opacity: 1,
             fillOpacity: 1,
@@ -36445,205 +36457,248 @@
             text: 1,
             detail: 1,
             key: 1,
             tooltip: 1,
             href: 1,
             url: 1,
             description: 1
-        });
+        };
 
-    function Nu(e) {
-        return e === oi || e === ya || e === va
+    function Cu(e) {
+        return e === si || e === os || e === ls
     }
-    const cj = {
+    const EI = {
             row: 1,
             column: 1,
             facet: 1
         },
-        Ri = Y(cj),
-        sO = Object.assign(Object.assign({}, aO), cj),
-        afe = Y(sO),
-        sfe = Bd(sO, ["order", "detail", "tooltip"]),
-        ofe = Bd(sfe, ["row", "column", "facet"]);
+        Ti = H(EI),
+        kE = {
+            ...CE,
+            ...EI
+        },
+        dce = H(kE),
+        {
+            order: Jbe,
+            detail: Qbe,
+            tooltip: Zbe,
+            ...gce
+        } = kE,
+        {
+            row: e2e,
+            column: t2e,
+            facet: n2e,
+            ...pce
+        } = gce;
 
-    function lfe(e) {
-        return !!ofe[e]
+    function mce(e) {
+        return !!pce[e]
     }
 
-    function fj(e) {
-        return !!sO[e]
+    function CI(e) {
+        return !!kE[e]
     }
-    const ufe = [kr, ga, Tr, Gi, rs, is];
+    const yce = [xr, as, Er, Li, Vs, Xs];
 
-    function hj(e) {
-        return Hl(e) !== e
+    function kI(e) {
+        return Nl(e) !== e
     }
 
-    function Hl(e) {
+    function Nl(e) {
         switch (e) {
-            case kr:
-                return yt;
-            case ga:
-                return Yt;
-            case Tr:
-                return pa;
-            case Gi:
-                return ma;
-            case rs:
-                return Wi;
-            case is:
-                return Ar
+            case xr:
+                return ht;
+            case as:
+                return Gt;
+            case Er:
+                return wr;
+            case Li:
+                return Sr;
+            case Vs:
+                return zi;
+            case Xs:
+                return _r
         }
         return e
     }
 
-    function Js(e) {
-        if (uj(e)) switch (e) {
-            case Wi:
+    function ja(e) {
+        if (_I(e)) switch (e) {
+            case zi:
                 return "startAngle";
-            case rs:
+            case Vs:
                 return "endAngle";
-            case Ar:
+            case _r:
                 return "outerRadius";
-            case is:
+            case Xs:
                 return "innerRadius"
         }
         return e
     }
 
-    function ba(e) {
+    function us(e) {
         switch (e) {
-            case yt:
-                return kr;
-            case Yt:
-                return ga;
-            case pa:
-                return Tr;
-            case ma:
-                return Gi;
-            case Wi:
-                return rs;
-            case Ar:
-                return is
+            case ht:
+                return xr;
+            case Gt:
+                return as;
+            case wr:
+                return Er;
+            case Sr:
+                return Li;
+            case zi:
+                return Vs;
+            case _r:
+                return Xs
         }
     }
 
-    function ui(e) {
+    function oi(e) {
         switch (e) {
-            case yt:
-            case kr:
+            case ht:
+            case xr:
                 return "width";
-            case Yt:
-            case ga:
+            case Gt:
+            case as:
                 return "height"
         }
     }
 
-    function cfe(e) {
+    function AI(e) {
         switch (e) {
-            case yt:
+            case ht:
                 return "xOffset";
-            case Yt:
+            case Gt:
                 return "yOffset";
-            case kr:
+            case xr:
                 return "x2Offset";
-            case ga:
+            case as:
                 return "y2Offset";
-            case Wi:
+            case zi:
                 return "thetaOffset";
-            case Ar:
+            case _r:
                 return "radiusOffset";
-            case rs:
+            case Vs:
                 return "theta2Offset";
-            case is:
+            case Xs:
                 return "radius2Offset"
         }
     }
 
-    function dj(e) {
+    function AE(e) {
         switch (e) {
-            case yt:
+            case ht:
                 return "xOffset";
-            case Yt:
+            case Gt:
                 return "yOffset"
         }
     }
 
-    function gj(e) {
+    function $I(e) {
         switch (e) {
             case "xOffset":
                 return "x";
             case "yOffset":
                 return "y"
         }
     }
-    const ffe = Y(aO),
-        oO = Bd(aO, ["x", "y", "x2", "y2", "xOffset", "yOffset", "latitude", "longitude", "latitude2", "longitude2", "theta", "theta2", "radius", "radius2"]),
-        hfe = Y(oO),
-        lO = {
+    const vce = H(CE),
+        {
+            x: i2e,
+            y: r2e,
+            x2: s2e,
+            y2: a2e,
+            xOffset: o2e,
+            yOffset: l2e,
+            latitude: u2e,
+            longitude: c2e,
+            latitude2: f2e,
+            longitude2: h2e,
+            theta: d2e,
+            theta2: g2e,
+            radius: p2e,
+            radius2: m2e,
+            ...$E
+        } = CE,
+        bce = H($E),
+        TE = {
             x: 1,
             y: 1
         },
-        xa = Y(lO);
+        cs = H(TE);
 
-    function Xt(e) {
-        return e in lO
+    function Wt(e) {
+        return e in TE
     }
-    const uO = {
+    const ME = {
             theta: 1,
             radius: 1
         },
-        dfe = Y(uO);
+        xce = H(ME);
 
-    function W1(e) {
-        return e === "width" ? yt : Yt
+    function k1(e) {
+        return e === "width" ? ht : Gt
     }
-    const pj = {
+    const TI = {
         xOffset: 1,
         yOffset: 1
     };
 
-    function Uc(e) {
-        return e in pj
+    function Oc(e) {
+        return e in TI
     }
-    const mj = Bd(oO, ["text", "tooltip", "href", "url", "description", "detail", "key", "order"]),
-        gfe = Y(mj);
+    const {
+        text: y2e,
+        tooltip: v2e,
+        href: b2e,
+        url: x2e,
+        description: _2e,
+        detail: w2e,
+        key: S2e,
+        order: E2e,
+        ...MI
+    } = $E, _ce = H(MI);
 
-    function pfe(e) {
-        return !!oO[e]
+    function wce(e) {
+        return !!$E[e]
     }
 
-    function mfe(e) {
+    function Sce(e) {
         switch (e) {
-            case oi:
-            case ya:
-            case va:
-            case as:
-            case li:
-            case ss:
-            case yo:
-            case vo:
+            case si:
+            case os:
+            case ls:
+            case Ks:
+            case ai:
+            case Js:
+            case so:
+            case ao:
                 return !0;
-            case po:
-            case mo:
-            case Wl:
+            case io:
+            case ro:
+            case Dl:
                 return !1
         }
     }
-    const yj = Object.assign(Object.assign(Object.assign(Object.assign({}, lO), uO), pj), mj),
-        H1 = Y(yj);
+    const OI = {
+            ...TE,
+            ...ME,
+            ...TI,
+            ...MI
+        },
+        A1 = H(OI);
 
-    function bo(e) {
-        return !!yj[e]
+    function Qs(e) {
+        return !!OI[e]
     }
 
-    function yfe(e, t) {
-        return bfe(e)[t]
+    function Ece(e, t) {
+        return kce(e)[t]
     }
-    const vj = {
+    const FI = {
             arc: "always",
             area: "always",
             bar: "always",
             circle: "always",
             geoshape: "always",
             image: "always",
             line: "always",
@@ -36651,134 +36706,137 @@
             point: "always",
             rect: "always",
             square: "always",
             trail: "always",
             text: "always",
             tick: "always"
         },
-        vfe = Bd(vj, ["geoshape"]);
+        {
+            geoshape: C2e,
+            ...Cce
+        } = FI;
 
-    function bfe(e) {
+    function kce(e) {
         switch (e) {
-            case oi:
-            case ya:
-            case va:
-            case q1:
-            case qd:
-            case B1:
-            case _l:
-            case G1:
-            case Ud:
-            case ss:
-            case po:
-            case mo:
-            case yo:
-            case z1:
-            case Ga:
-            case Ua:
-                return vj;
-            case yt:
-            case Yt:
-            case go:
-            case Gc:
-            case pa:
-            case ma:
-                return vfe;
-            case kr:
-            case ga:
-            case Tr:
-            case Gi:
+            case si:
+            case os:
+            case ls:
+            case C1:
+            case Md:
+            case w1:
+            case ul:
+            case S1:
+            case ec:
+            case Js:
+            case io:
+            case ro:
+            case so:
+            case _1:
+            case Fs:
+            case Rs:
+                return FI;
+            case ht:
+            case Gt:
+            case no:
+            case Mc:
+            case wr:
+            case Sr:
+                return Cce;
+            case xr:
+            case as:
+            case Er:
+            case Li:
                 return {
                     area: "always", bar: "always", image: "always", rect: "always", rule: "always", circle: "binned", point: "binned", square: "binned", tick: "binned", line: "binned", trail: "binned"
                 };
-            case as:
+            case Ks:
                 return {
                     point: "always", tick: "always", rule: "always", circle: "always", square: "always", bar: "always", text: "always", line: "always", trail: "always"
                 };
-            case vo:
+            case ao:
                 return {
                     line: "always", point: "always", tick: "always", rule: "always", circle: "always", square: "always", bar: "always", geoshape: "always"
                 };
-            case li:
+            case ai:
                 return {
                     point: "always", geoshape: "always"
                 };
-            case Gd:
+            case Td:
                 return {
                     text: "always"
                 };
-            case Wl:
+            case Dl:
                 return {
                     point: "always", square: "always", text: "always"
                 };
-            case U1:
+            case E1:
                 return {
                     image: "always"
                 };
-            case Wi:
+            case zi:
                 return {
                     text: "always", arc: "always"
                 };
-            case Ar:
+            case _r:
                 return {
                     text: "always", arc: "always"
                 };
-            case rs:
-            case is:
+            case Vs:
+            case Xs:
                 return {
                     arc: "always"
                 }
         }
     }
 
-    function Yv(e) {
+    function Cv(e) {
         switch (e) {
-            case yt:
-            case Yt:
-            case Wi:
-            case Ar:
-            case go:
-            case Gc:
+            case ht:
+            case Gt:
+            case zi:
+            case _r:
+            case no:
+            case Mc:
+            case Ks:
+            case Dl:
+            case so:
+            case Js:
+            case io:
+            case ro:
+            case xr:
             case as:
-            case Wl:
-            case yo:
-            case ss:
-            case po:
-            case mo:
-            case kr:
-            case ga:
-            case rs:
-            case is:
+            case Vs:
+            case Xs:
                 return;
-            case z1:
-            case Ga:
-            case Ua:
-            case li:
-            case vo:
-            case Gd:
-            case _l:
-            case G1:
-            case U1:
-            case q1:
+            case _1:
+            case Fs:
+            case Rs:
+            case ai:
+            case ao:
+            case Td:
+            case ul:
+            case S1:
+            case E1:
+            case C1:
                 return "discrete";
-            case oi:
-            case ya:
-            case va:
+            case si:
+            case os:
+            case ls:
                 return "flexible";
-            case pa:
-            case ma:
-            case Tr:
-            case Gi:
-            case qd:
-            case B1:
-            case Ud:
+            case wr:
+            case Sr:
+            case Er:
+            case Li:
+            case Md:
+            case w1:
+            case ec:
                 return
         }
     }
-    const xfe = {
+    const Ace = {
             argmax: 1,
             argmin: 1,
             average: 1,
             count: 1,
             distinct: 1,
             product: 1,
             max: 1,
@@ -36795,179 +36853,191 @@
             stdevp: 1,
             sum: 1,
             valid: 1,
             values: 1,
             variance: 1,
             variancep: 1
         },
-        _fe = {
+        $ce = {
             count: 1,
             min: 1,
             max: 1
         };
 
-    function Va(e) {
+    function Bs(e) {
         return !!e && !!e.argmin
     }
 
-    function xo(e) {
+    function oo(e) {
         return !!e && !!e.argmax
     }
 
-    function cO(e) {
-        return re(e) && !!xfe[e]
+    function OE(e) {
+        return re(e) && !!Ace[e]
     }
-    const wfe = new Set(["count", "valid", "missing", "distinct"]);
+    const Tce = new Set(["count", "valid", "missing", "distinct"]);
 
-    function bj(e) {
-        return re(e) && wfe.has(e)
+    function RI(e) {
+        return re(e) && Tce.has(e)
     }
 
-    function Sfe(e) {
-        return re(e) && Pe(["min", "max"], e)
+    function Mce(e) {
+        return re(e) && Fe(["min", "max"], e)
     }
-    const Efe = new Set(["count", "sum", "distinct", "valid", "missing"]),
-        Ofe = new Set(["mean", "average", "median", "q1", "q3", "min", "max"]);
+    const Oce = new Set(["count", "sum", "distinct", "valid", "missing"]),
+        Fce = new Set(["mean", "average", "median", "q1", "q3", "min", "max"]);
 
-    function xj(e) {
-        return co(e) && (e = iy(e, void 0)), "bin" + Y(e).map(t => Y1(e[t]) ? ht(`_${t}_${Ks(e[t])}`) : ht(`_${t}_${e[t]}`)).join("")
+    function DI(e) {
+        return Za(e) && (e = z1(e, void 0)), "bin" + H(e).map(t => $1(e[t]) ? ft(`_${t}_${Ba(e[t])}`) : ft(`_${t}_${e[t]}`)).join("")
     }
 
-    function lt(e) {
-        return e === !0 || Yl(e) && !e.binned
+    function ot(e) {
+        return e === !0 || Pl(e) && !e.binned
     }
 
-    function Qt(e) {
-        return e === "binned" || Yl(e) && e.binned === !0
+    function Xt(e) {
+        return e === "binned" || Pl(e) && e.binned === !0
     }
 
-    function Yl(e) {
-        return se(e)
+    function Pl(e) {
+        return ae(e)
     }
 
-    function Y1(e) {
+    function $1(e) {
         return e == null ? void 0 : e.param
     }
 
-    function l$(e) {
+    function w5(e) {
         switch (e) {
-            case Ga:
-            case Ua:
-            case as:
-            case oi:
-            case ya:
-            case va:
-            case yo:
-            case ss:
-            case po:
-            case mo:
-            case li:
+            case Fs:
+            case Rs:
+            case Ks:
+            case si:
+            case os:
+            case ls:
+            case so:
+            case Js:
+            case io:
+            case ro:
+            case ai:
                 return 6;
-            case vo:
+            case ao:
                 return 4;
             default:
                 return 10
         }
     }
 
-    function Wd(e) {
+    function Fc(e) {
         return !!(e != null && e.expr)
     }
 
-    function Xn(e) {
-        const t = Y(e || {}),
+    function Hn(e) {
+        const t = H(e || {}),
             n = {};
-        for (const i of t) n[i] = pi(e[i]);
+        for (const i of t) n[i] = di(e[i]);
         return n
     }
-    var Cfe = globalThis && globalThis.__rest || function(e, t) {
-        var n = {};
-        for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && t.indexOf(i) < 0 && (n[i] = e[i]);
-        if (e != null && typeof Object.getOwnPropertySymbols == "function")
-            for (var r = 0, i = Object.getOwnPropertySymbols(e); r < i.length; r++) t.indexOf(i[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, i[r]) && (n[i[r]] = e[i[r]]);
-        return n
-    };
 
-    function _j(e) {
+    function NI(e) {
         const {
             anchor: t,
             frame: n,
             offset: i,
             orient: r,
-            angle: a,
-            limit: s,
+            angle: s,
+            limit: a,
             color: o,
             subtitleColor: l,
             subtitleFont: u,
             subtitleFontSize: c,
             subtitleFontStyle: f,
             subtitleFontWeight: h,
             subtitleLineHeight: d,
-            subtitlePadding: g
-        } = e, p = Cfe(e, ["anchor", "frame", "offset", "orient", "angle", "limit", "color", "subtitleColor", "subtitleFont", "subtitleFontSize", "subtitleFontStyle", "subtitleFontWeight", "subtitleLineHeight", "subtitlePadding"]), m = Object.assign(Object.assign({}, p), o ? {
-            fill: o
-        } : {}), y = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, t ? {
-            anchor: t
-        } : {}), n ? {
-            frame: n
-        } : {}), i ? {
-            offset: i
-        } : {}), r ? {
-            orient: r
-        } : {}), a !== void 0 ? {
-            angle: a
-        } : {}), s !== void 0 ? {
-            limit: s
-        } : {}), v = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, l ? {
-            subtitleColor: l
-        } : {}), u ? {
-            subtitleFont: u
-        } : {}), c ? {
-            subtitleFontSize: c
-        } : {}), f ? {
-            subtitleFontStyle: f
-        } : {}), h ? {
-            subtitleFontWeight: h
-        } : {}), d ? {
-            subtitleLineHeight: d
-        } : {}), g ? {
-            subtitlePadding: g
-        } : {}), b = uc(e, ["align", "baseline", "dx", "dy", "limit"]);
+            subtitlePadding: g,
+            ...p
+        } = e, m = {
+            ...p,
+            ...o ? {
+                fill: o
+            } : {}
+        }, y = {
+            ...t ? {
+                anchor: t
+            } : {},
+            ...n ? {
+                frame: n
+            } : {},
+            ...i ? {
+                offset: i
+            } : {},
+            ...r ? {
+                orient: r
+            } : {},
+            ...s !== void 0 ? {
+                angle: s
+            } : {},
+            ...a !== void 0 ? {
+                limit: a
+            } : {}
+        }, v = {
+            ...l ? {
+                subtitleColor: l
+            } : {},
+            ...u ? {
+                subtitleFont: u
+            } : {},
+            ...c ? {
+                subtitleFontSize: c
+            } : {},
+            ...f ? {
+                subtitleFontStyle: f
+            } : {},
+            ...h ? {
+                subtitleFontWeight: h
+            } : {},
+            ...d ? {
+                subtitleLineHeight: d
+            } : {},
+            ...g ? {
+                subtitlePadding: g
+            } : {}
+        }, b = Qu(e, ["align", "baseline", "dx", "dy", "limit"]);
         return {
             titleMarkConfig: m,
             subtitleMarkConfig: b,
             nonMarkTitleProperties: y,
             subtitle: v
         }
     }
 
-    function xs(e) {
-        return re(e) || q(e) && re(e[0])
+    function ca(e) {
+        return re(e) || W(e) && re(e[0])
     }
 
-    function fe(e) {
+    function he(e) {
         return !!(e != null && e.signal)
     }
 
-    function _o(e) {
+    function lo(e) {
         return !!e.step
     }
 
-    function kfe(e) {
-        return q(e) ? !1 : "fields" in e && !("data" in e)
+    function Rce(e) {
+        return W(e) ? !1 : "fields" in e && !("data" in e)
     }
 
-    function Afe(e) {
-        return q(e) ? !1 : "fields" in e && "data" in e
+    function Dce(e) {
+        return W(e) ? !1 : "fields" in e && "data" in e
     }
 
-    function Ia(e) {
-        return q(e) ? !1 : "field" in e && "data" in e
+    function $s(e) {
+        return W(e) ? !1 : "field" in e && "data" in e
     }
-    const Tfe = {
+    const Nce = {
             aria: 1,
             description: 1,
             ariaRole: 1,
             ariaRoleDescription: 1,
             blend: 1,
             opacity: 1,
             fill: 1,
@@ -37018,807 +37088,825 @@
             cornerRadiusBottomRight: 1,
             aspect: 1,
             width: 1,
             height: 1,
             url: 1,
             smooth: 1
         },
-        $fe = Y(Tfe),
-        Mfe = {
+        Pce = H(Nce),
+        Lce = {
             arc: 1,
             area: 1,
             group: 1,
             image: 1,
             line: 1,
             path: 1,
             rect: 1,
             rule: 1,
             shape: 1,
             symbol: 1,
             text: 1,
             trail: 1
         },
-        bx = ["cornerRadius", "cornerRadiusTopLeft", "cornerRadiusTopRight", "cornerRadiusBottomLeft", "cornerRadiusBottomRight"];
-    var fO = globalThis && globalThis.__rest || function(e, t) {
-        var n = {};
-        for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && t.indexOf(i) < 0 && (n[i] = e[i]);
-        if (e != null && typeof Object.getOwnPropertySymbols == "function")
-            for (var r = 0, i = Object.getOwnPropertySymbols(e); r < i.length; r++) t.indexOf(i[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, i[r]) && (n[i[r]] = e[i[r]]);
-        return n
-    };
+        H2 = ["cornerRadius", "cornerRadiusTopLeft", "cornerRadiusTopRight", "cornerRadiusBottomLeft", "cornerRadiusBottomRight"];
 
-    function wj(e) {
-        const t = q(e.condition) ? e.condition.map(u$) : u$(e.condition);
-        return Object.assign(Object.assign({}, pi(e)), {
+    function PI(e) {
+        const t = W(e.condition) ? e.condition.map(S5) : S5(e.condition);
+        return {
+            ...di(e),
             condition: t
-        })
+        }
     }
 
-    function pi(e) {
-        if (Wd(e)) {
+    function di(e) {
+        if (Fc(e)) {
             const {
-                expr: t
-            } = e, n = fO(e, ["expr"]);
-            return Object.assign({
-                signal: t
-            }, n)
+                expr: t,
+                ...n
+            } = e;
+            return {
+                signal: t,
+                ...n
+            }
         }
         return e
     }
 
-    function u$(e) {
-        if (Wd(e)) {
+    function S5(e) {
+        if (Fc(e)) {
             const {
-                expr: t
-            } = e, n = fO(e, ["expr"]);
-            return Object.assign({
-                signal: t
-            }, n)
+                expr: t,
+                ...n
+            } = e;
+            return {
+                signal: t,
+                ...n
+            }
         }
         return e
     }
 
-    function ct(e) {
-        if (Wd(e)) {
+    function ut(e) {
+        if (Fc(e)) {
             const {
-                expr: t
-            } = e, n = fO(e, ["expr"]);
-            return Object.assign({
-                signal: t
-            }, n)
+                expr: t,
+                ...n
+            } = e;
+            return {
+                signal: t,
+                ...n
+            }
         }
-        return fe(e) ? e : e !== void 0 ? {
+        return he(e) ? e : e !== void 0 ? {
             value: e
         } : void 0
     }
 
-    function Ffe(e) {
-        return fe(e) ? e.signal : Z(e)
+    function Ice(e) {
+        return he(e) ? e.signal : Z(e)
     }
 
-    function c$(e) {
-        return fe(e) ? e.signal : Z(e.value)
+    function E5(e) {
+        return he(e) ? e.signal : Z(e.value)
     }
 
-    function qa(e) {
-        return fe(e) ? e.signal : e == null ? null : Z(e)
+    function Ds(e) {
+        return he(e) ? e.signal : e == null ? null : Z(e)
     }
 
-    function Dfe(e, t, n) {
+    function zce(e, t, n) {
         for (const i of n) {
-            const r = wl(i, t.markDef, t.config);
-            r !== void 0 && (e[i] = ct(r))
+            const r = cl(i, t.markDef, t.config);
+            r !== void 0 && (e[i] = ut(r))
         }
         return e
     }
 
-    function Sj(e) {
-        var t;
-        return [].concat(e.type, (t = e.style) !== null && t !== void 0 ? t : [])
+    function LI(e) {
+        return [].concat(e.type, e.style ?? [])
     }
 
-    function Ve(e, t, n, i = {}) {
+    function Xe(e, t, n, i = {}) {
         const {
             vgChannel: r,
-            ignoreVgConfig: a
+            ignoreVgConfig: s
         } = i;
-        return r && t[r] !== void 0 ? t[r] : t[e] !== void 0 ? t[e] : a && (!r || r === e) ? void 0 : wl(e, t, n, i)
+        return r && t[r] !== void 0 ? t[r] : t[e] !== void 0 ? t[e] : s && (!r || r === e) ? void 0 : cl(e, t, n, i)
     }
 
-    function wl(e, t, n, {
+    function cl(e, t, n, {
         vgChannel: i
     } = {}) {
-        return Tt(i ? tm(e, t, n.style) : void 0, tm(e, t, n.style), i ? n[t.type][i] : void 0, n[t.type][e], i ? n.mark[i] : n.mark[e])
+        return Ct(i ? P0(e, t, n.style) : void 0, P0(e, t, n.style), i ? n[t.type][i] : void 0, n[t.type][e], i ? n.mark[i] : n.mark[e])
     }
 
-    function tm(e, t, n) {
-        return Ej(e, Sj(t), n)
+    function P0(e, t, n) {
+        return II(e, LI(t), n)
     }
 
-    function Ej(e, t, n) {
-        t = ie(t);
+    function II(e, t, n) {
+        t = se(t);
         let i;
         for (const r of t) {
-            const a = n[r];
-            a && a[e] !== void 0 && (i = a[e])
+            const s = n[r];
+            s && s[e] !== void 0 && (i = s[e])
         }
         return i
     }
 
-    function Oj(e, t) {
-        return ie(e).reduce((n, i) => {
-            var r;
-            return n.field.push(ne(i, t)), n.order.push((r = i.sort) !== null && r !== void 0 ? r : "ascending"), n
-        }, {
+    function zI(e, t) {
+        return se(e).reduce((n, i) => (n.field.push(ie(i, t)), n.order.push(i.sort ?? "ascending"), n), {
             field: [],
             order: []
         })
     }
 
-    function Cj(e, t) {
+    function BI(e, t) {
         const n = [...e];
         return t.forEach(i => {
             for (const r of n)
-                if (Br(r, i)) return;
+                if (Nr(r, i)) return;
             n.push(i)
         }), n
     }
 
-    function kj(e, t) {
-        return Br(e, t) || !t ? e : e ? [...ie(e), ...ie(t)].join(", ") : t
+    function jI(e, t) {
+        return Nr(e, t) || !t ? e : e ? [...se(e), ...se(t)].join(", ") : t
     }
 
-    function Aj(e, t) {
+    function UI(e, t) {
         const n = e.value,
             i = t.value;
         if (n == null || i === null) return {
             explicit: e.explicit,
             value: null
         };
-        if ((xs(n) || fe(n)) && (xs(i) || fe(i))) return {
+        if ((ca(n) || he(n)) && (ca(i) || he(i))) return {
             explicit: e.explicit,
-            value: kj(n, i)
+            value: jI(n, i)
         };
-        if (xs(n) || fe(n)) return {
+        if (ca(n) || he(n)) return {
             explicit: e.explicit,
             value: n
         };
-        if (xs(i) || fe(i)) return {
+        if (ca(i) || he(i)) return {
             explicit: e.explicit,
             value: i
         };
-        if (!xs(n) && !fe(n) && !xs(i) && !fe(i)) return {
+        if (!ca(n) && !he(n) && !ca(i) && !he(i)) return {
             explicit: e.explicit,
-            value: Cj(n, i)
+            value: BI(n, i)
         };
         throw new Error("It should never reach here")
     }
 
-    function hO(e) {
-        return `Invalid specification ${ot(e)}. Make sure the specification includes at least one of the following properties: "mark", "layer", "facet", "hconcat", "vconcat", "concat", or "repeat".`
+    function FE(e) {
+        return `Invalid specification ${at(e)}. Make sure the specification includes at least one of the following properties: "mark", "layer", "facet", "hconcat", "vconcat", "concat", or "repeat".`
     }
-    const Rfe = 'Autosize "fit" only works for single views and layered views.';
+    const Bce = 'Autosize "fit" only works for single views and layered views.';
 
-    function f$(e) {
+    function C5(e) {
         return `${e=="width"?"Width":"Height"} "container" only works for single views and layered views.`
     }
 
-    function h$(e) {
+    function k5(e) {
         const t = e == "width" ? "Width" : "Height",
             n = e == "width" ? "x" : "y";
         return `${t} "container" only works well with autosize "fit" or "fit-${n}".`
     }
 
-    function d$(e) {
-        return e ? `Dropping "fit-${e}" because spec has discrete ${ui(e)}.` : 'Dropping "fit" because spec has discrete size.'
+    function A5(e) {
+        return e ? `Dropping "fit-${e}" because spec has discrete ${oi(e)}.` : 'Dropping "fit" because spec has discrete size.'
     }
 
-    function dO(e) {
+    function RE(e) {
         return `Unknown field for ${e}. Cannot calculate view size.`
     }
 
-    function g$(e) {
+    function $5(e) {
         return `Cannot project a selection on encoding channel "${e}", which has no field.`
     }
 
-    function Pfe(e, t) {
+    function jce(e, t) {
         return `Cannot project a selection on encoding channel "${e}" as it uses an aggregate function ("${t}").`
     }
 
-    function Nfe(e) {
+    function Uce(e) {
         return `The "nearest" transform is not supported for ${e} marks.`
     }
 
-    function Tj(e) {
+    function GI(e) {
         return `Selection not supported for ${e} yet.`
     }
 
-    function Lfe(e) {
+    function Gce(e) {
         return `Cannot find a selection named "${e}".`
     }
-    const Ife = "Scale bindings are currently only supported for scales with unbinned, continuous domains.",
-        jfe = "Legend bindings are only supported for selections over an individual field or encoding channel.";
+    const Wce = "Scale bindings are currently only supported for scales with unbinned, continuous domains.",
+        qce = "Legend bindings are only supported for selections over an individual field or encoding channel.";
 
-    function zfe(e) {
+    function Hce(e) {
         return `Lookups can only be performed on selection parameters. "${e}" is a variable parameter.`
     }
 
-    function Bfe(e) {
+    function Yce(e) {
         return `Cannot define and lookup the "${e}" selection in the same view. Try moving the lookup into a second, layered view?`
     }
-    const Gfe = "The same selection must be used to override scale domains in a layered view.",
-        Ufe = 'Interval selections should be initialized using "x" and/or "y" keys.';
+    const Xce = "The same selection must be used to override scale domains in a layered view.",
+        Vce = 'Interval selections should be initialized using "x", "y", "longitude", or "latitude" keys.';
 
-    function qfe(e) {
+    function Kce(e) {
         return `Unknown repeated value "${e}".`
     }
 
-    function p$(e) {
+    function T5(e) {
         return `The "columns" property cannot be used when "${e}" has nested row/column.`
     }
-    const Wfe = "Axes cannot be shared in concatenated or repeated views yet (https://github.com/vega/vega-lite/issues/2415).";
+    const Jce = "Axes cannot be shared in concatenated or repeated views yet (https://github.com/vega/vega-lite/issues/2415).";
 
-    function Hfe(e) {
+    function Qce(e) {
         return `Unrecognized parse "${e}".`
     }
 
-    function m$(e, t, n) {
+    function M5(e, t, n) {
         return `An ancestor parsed field "${e}" as ${n} but a child wants to parse the field as ${t}.`
     }
-    const Yfe = "Attempt to add the same child twice.";
+    const Zce = "Attempt to add the same child twice.";
 
-    function Xfe(e) {
-        return `Ignoring an invalid transform: ${ot(e)}.`
+    function efe(e) {
+        return `Ignoring an invalid transform: ${at(e)}.`
     }
-    const Vfe = 'If "from.fields" is not specified, "as" has to be a string that specifies the key to be used for the data from the secondary source.';
+    const tfe = 'If "from.fields" is not specified, "as" has to be a string that specifies the key to be used for the data from the secondary source.';
 
-    function y$(e) {
+    function O5(e) {
         return `Config.customFormatTypes is not true, thus custom format type and format for channel ${e} are dropped.`
     }
 
-    function Kfe(e) {
+    function nfe(e) {
         const {
             parentProjection: t,
             projection: n
         } = e;
-        return `Layer's shared projection ${ot(t)} is overridden by a child projection ${ot(n)}.`
+        return `Layer's shared projection ${at(t)} is overridden by a child projection ${at(n)}.`
     }
-    const Jfe = "Arc marks uses theta channel rather than angle, replacing angle with theta.";
+    const ife = "Arc marks uses theta channel rather than angle, replacing angle with theta.";
 
-    function Qfe(e) {
+    function rfe(e) {
         return `${e}Offset dropped because ${e} is continuous`
     }
 
-    function Zfe(e) {
+    function sfe(e) {
         return `There is no ${e} encoding. Replacing ${e}Offset encoding as ${e}.`
     }
 
-    function ehe(e, t, n) {
-        return `Channel ${e} is a ${t}. Converted to {value: ${ot(n)}}.`
+    function afe(e, t, n) {
+        return `Channel ${e} is a ${t}. Converted to {value: ${at(n)}}.`
     }
 
-    function $j(e) {
+    function WI(e) {
         return `Invalid field type "${e}".`
     }
 
-    function the(e, t) {
+    function ofe(e, t) {
         return `Invalid field type "${e}" for aggregate: "${t}", using "quantitative" instead.`
     }
 
-    function nhe(e) {
+    function lfe(e) {
         return `Invalid aggregation operator "${e}".`
     }
 
-    function Mj(e, t) {
+    function qI(e, t) {
         const {
             fill: n,
             stroke: i
         } = t;
         return `Dropping color ${e} as the plot also has ${n&&i?"fill and stroke":n?"fill":"stroke"}.`
     }
 
-    function ihe(e) {
+    function ufe(e) {
         return `Position range does not support relative band size for ${e}.`
     }
 
-    function xx(e, t) {
-        return `Dropping ${ot(e)} from channel "${t}" since it does not contain any data field, datum, value, or signal.`
+    function Y2(e, t) {
+        return `Dropping ${at(e)} from channel "${t}" since it does not contain any data field, datum, value, or signal.`
     }
-    const rhe = "Line marks cannot encode size with a non-groupby field. You may want to use trail marks instead.";
+    const cfe = "Line marks cannot encode size with a non-groupby field. You may want to use trail marks instead.";
 
-    function X1(e, t, n) {
+    function T1(e, t, n) {
         return `${e} dropped as it is incompatible with "${t}"${n?` when ${n}`:""}.`
     }
 
-    function ahe(e) {
+    function ffe(e) {
         return `${e} encoding has no scale, so specified scale is ignored.`
     }
 
-    function she(e) {
+    function hfe(e) {
         return `${e}-encoding is dropped as ${e} is not a valid encoding channel.`
     }
 
-    function ohe(e) {
+    function dfe(e) {
         return `${e} encoding should be discrete (ordinal / nominal / binned).`
     }
 
-    function lhe(e) {
+    function gfe(e) {
         return `${e} encoding should be discrete (ordinal / nominal / binned) or use a discretizing scale (e.g. threshold).`
     }
 
-    function uhe(e) {
+    function pfe(e) {
         return `Facet encoding dropped as ${e.join(" and ")} ${e.length>1?"are":"is"} also specified.`
     }
 
-    function Xv(e, t) {
+    function kv(e, t) {
         return `Using discrete channel "${e}" to encode "${t}" field can be misleading as it does not encode ${t==="ordinal"?"order":"magnitude"}.`
     }
 
-    function che(e) {
+    function mfe(e) {
         return `The ${e} for range marks cannot be an expression`
     }
 
-    function fhe(e, t) {
+    function yfe(e, t) {
         return `Line mark is for continuous lines and thus cannot be used with ${e&&t?"x2 and y2":e?"x2":"y2"}. We will use the rule mark (line segments) instead.`
     }
 
-    function hhe(e, t) {
+    function vfe(e, t) {
         return `Specified orient "${e}" overridden with "${t}".`
     }
 
-    function dhe(e) {
+    function bfe(e) {
         return `Cannot use the scale property "${e}" with non-color channel.`
     }
 
-    function ghe(e) {
+    function xfe(e) {
         return `Cannot use the relative band size with ${e} scale.`
     }
 
-    function phe(e) {
-        return `Using unaggregated domain with raw field has no effect (${ot(e)}).`
+    function _fe(e) {
+        return `Using unaggregated domain with raw field has no effect (${at(e)}).`
     }
 
-    function mhe(e) {
+    function wfe(e) {
         return `Unaggregated domain not applicable for "${e}" since it produces values outside the origin domain of the source data.`
     }
 
-    function yhe(e) {
-        return `Unaggregated domain is currently unsupported for log scale (${ot(e)}).`
+    function Sfe(e) {
+        return `Unaggregated domain is currently unsupported for log scale (${at(e)}).`
     }
 
-    function vhe(e) {
+    function Efe(e) {
         return `Cannot apply size to non-oriented mark "${e}".`
     }
 
-    function bhe(e, t, n) {
+    function Cfe(e, t, n) {
         return `Channel "${e}" does not work with "${t}" scale. We are using "${n}" scale instead.`
     }
 
-    function xhe(e, t) {
+    function kfe(e, t) {
         return `FieldDef does not work with "${e}" scale. We are using "${t}" scale instead.`
     }
 
-    function Fj(e, t, n) {
+    function HI(e, t, n) {
         return `${n}-scale's "${t}" is dropped as it does not work with ${e} scale.`
     }
 
-    function Dj(e) {
+    function YI(e) {
         return `The step for "${e}" is dropped because the ${e==="width"?"x":"y"} is continuous.`
     }
 
-    function _he(e, t, n, i) {
-        return `Conflicting ${t.toString()} property "${e.toString()}" (${ot(n)} and ${ot(i)}). Using ${ot(n)}.`
+    function Afe(e, t, n, i) {
+        return `Conflicting ${t.toString()} property "${e.toString()}" (${at(n)} and ${at(i)}). Using ${at(n)}.`
     }
 
-    function whe(e, t, n, i) {
-        return `Conflicting ${t.toString()} property "${e.toString()}" (${ot(n)} and ${ot(i)}). Using the union of the two domains.`
+    function $fe(e, t, n, i) {
+        return `Conflicting ${t.toString()} property "${e.toString()}" (${at(n)} and ${at(i)}). Using the union of the two domains.`
     }
 
-    function She(e) {
+    function Tfe(e) {
         return `Setting the scale to be independent for "${e}" means we also have to set the guide (axis or legend) to be independent.`
     }
 
-    function Ehe(e) {
-        return `Dropping sort property ${ot(e)} as unioned domains only support boolean or op "count", "min", and "max".`
+    function Mfe(e) {
+        return `Dropping sort property ${at(e)} as unioned domains only support boolean or op "count", "min", and "max".`
     }
-    const v$ = "Domains that should be unioned has conflicting sort properties. Sort will be set to true.",
-        Ohe = "Detected faceted independent scales that union domain of multiple fields from different data sources. We will use the first field. The result view size may be incorrect.",
-        Che = "Detected faceted independent scales that union domain of the same fields from different source. We will assume that this is the same field from a different fork of the same data source. However, if this is not the case, the result view size may be incorrect.",
-        khe = "Detected faceted independent scales that union domain of multiple fields from the same data source. We will use the first field. The result view size may be incorrect.";
+    const F5 = "Domains that should be unioned has conflicting sort properties. Sort will be set to true.",
+        Ofe = "Detected faceted independent scales that union domain of multiple fields from different data sources. We will use the first field. The result view size may be incorrect.",
+        Ffe = "Detected faceted independent scales that union domain of the same fields from different source. We will assume that this is the same field from a different fork of the same data source. However, if this is not the case, the result view size may be incorrect.",
+        Rfe = "Detected faceted independent scales that union domain of multiple fields from the same data source. We will use the first field. The result view size may be incorrect.";
 
-    function Ahe(e) {
+    function Dfe(e) {
         return `Cannot stack "${e}" if there is already "${e}2".`
     }
 
-    function The(e) {
+    function Nfe(e) {
         return `Cannot stack non-linear scale (${e}).`
     }
 
-    function $he(e) {
+    function Pfe(e) {
         return `Stacking is applied even though the aggregate function is non-summative ("${e}").`
     }
 
-    function nm(e, t) {
-        return `Invalid ${e}: ${ot(t)}.`
+    function L0(e, t) {
+        return `Invalid ${e}: ${at(t)}.`
     }
 
-    function Mhe(e) {
-        return `Dropping day from datetime ${ot(e)} as day cannot be combined with other units.`
+    function Lfe(e) {
+        return `Dropping day from datetime ${at(e)} as day cannot be combined with other units.`
     }
 
-    function Fhe(e, t) {
+    function Ife(e, t) {
         return `${t?"extent ":""}${t&&e?"and ":""}${e?"center ":""}${t&&e?"are ":"is "}not needed when data are aggregated.`
     }
 
-    function Dhe(e, t, n) {
+    function zfe(e, t, n) {
         return `${e} is not usually used with ${t} for ${n}.`
     }
 
-    function Rhe(e, t) {
+    function Bfe(e, t) {
         return `Continuous axis should not have customized aggregation function ${e}; ${t} already agregates the axis.`
     }
 
-    function b$(e) {
+    function R5(e) {
         return `1D error band does not support ${e}.`
     }
 
-    function Rj(e) {
+    function XI(e) {
         return `Channel ${e} is required for "binned" bin.`
     }
 
-    function Phe(e) {
+    function jfe(e) {
         return `Channel ${e} should not be used with "binned" bin.`
     }
 
-    function Nhe(e) {
+    function Ufe(e) {
         return `Domain for ${e} is required for threshold scale.`
     }
     globalThis && globalThis.__classPrivateFieldSet;
     globalThis && globalThis.__classPrivateFieldGet;
-    const Pj = G_(B_);
-    let fc = Pj;
+    const VI = o_(a_);
+    let tc = VI;
 
-    function Lhe(e) {
-        return fc = e, fc
+    function Gfe(e) {
+        return tc = e, tc
     }
 
-    function Ihe() {
-        return fc = Pj, fc
+    function Wfe() {
+        return tc = VI, tc
     }
 
     function X(...e) {
-        fc.warn(...e)
+        tc.warn(...e)
     }
 
-    function jhe(...e) {
-        fc.debug(...e)
+    function qfe(...e) {
+        tc.debug(...e)
     }
 
-    function Xl(e) {
-        if (e && se(e)) {
-            for (const t of pO)
+    function Ll(e) {
+        if (e && ae(e)) {
+            for (const t of NE)
                 if (t in e) return !0
         }
         return !1
     }
-    const Nj = ["january", "february", "march", "april", "may", "june", "july", "august", "september", "october", "november", "december"],
-        zhe = Nj.map(e => e.substr(0, 3)),
-        Lj = ["sunday", "monday", "tuesday", "wednesday", "thursday", "friday", "saturday"],
-        Bhe = Lj.map(e => e.substr(0, 3));
+    const KI = ["january", "february", "march", "april", "may", "june", "july", "august", "september", "october", "november", "december"],
+        Hfe = KI.map(e => e.substr(0, 3)),
+        JI = ["sunday", "monday", "tuesday", "wednesday", "thursday", "friday", "saturday"],
+        Yfe = JI.map(e => e.substr(0, 3));
 
-    function Ghe(e) {
-        if (j1(e) && (e = +e), tt(e)) return e > 4 && X(nm("quarter", e)), e - 1;
-        throw new Error(nm("quarter", e))
+    function Xfe(e) {
+        if (x1(e) && (e = +e), Ze(e)) return e > 4 && X(L0("quarter", e)), e - 1;
+        throw new Error(L0("quarter", e))
     }
 
-    function Uhe(e) {
-        if (j1(e) && (e = +e), tt(e)) return e - 1; {
+    function Vfe(e) {
+        if (x1(e) && (e = +e), Ze(e)) return e - 1; {
             const t = e.toLowerCase(),
-                n = Nj.indexOf(t);
+                n = KI.indexOf(t);
             if (n !== -1) return n;
             const i = t.substr(0, 3),
-                r = zhe.indexOf(i);
+                r = Hfe.indexOf(i);
             if (r !== -1) return r;
-            throw new Error(nm("month", e))
+            throw new Error(L0("month", e))
         }
     }
 
-    function qhe(e) {
-        if (j1(e) && (e = +e), tt(e)) return e % 7; {
+    function Kfe(e) {
+        if (x1(e) && (e = +e), Ze(e)) return e % 7; {
             const t = e.toLowerCase(),
-                n = Lj.indexOf(t);
+                n = JI.indexOf(t);
             if (n !== -1) return n;
             const i = t.substr(0, 3),
-                r = Bhe.indexOf(i);
+                r = Yfe.indexOf(i);
             if (r !== -1) return r;
-            throw new Error(nm("day", e))
+            throw new Error(L0("day", e))
         }
     }
 
-    function gO(e, t) {
+    function DE(e, t) {
         const n = [];
-        if (t && e.day !== void 0 && Y(e).length > 1 && (X(Mhe(e)), e = Ce(e), delete e.day), e.year !== void 0 ? n.push(e.year) : n.push(2012), e.month !== void 0) {
-            const i = t ? Uhe(e.month) : e.month;
+        if (t && e.day !== void 0 && H(e).length > 1 && (X(Lfe(e)), e = ke(e), delete e.day), e.year !== void 0 ? n.push(e.year) : n.push(2012), e.month !== void 0) {
+            const i = t ? Vfe(e.month) : e.month;
             n.push(i)
         } else if (e.quarter !== void 0) {
-            const i = t ? Ghe(e.quarter) : e.quarter;
-            n.push(tt(i) ? i * 3 : `${i}*3`)
+            const i = t ? Xfe(e.quarter) : e.quarter;
+            n.push(Ze(i) ? i * 3 : `${i}*3`)
         } else n.push(0);
         if (e.date !== void 0) n.push(e.date);
         else if (e.day !== void 0) {
-            const i = t ? qhe(e.day) : e.day;
-            n.push(tt(i) ? i + 1 : `${i}+1`)
+            const i = t ? Kfe(e.day) : e.day;
+            n.push(Ze(i) ? i + 1 : `${i}+1`)
         } else n.push(1);
         for (const i of ["hours", "minutes", "seconds", "milliseconds"]) {
             const r = e[i];
             n.push(typeof r > "u" ? 0 : r)
         }
         return n
     }
 
-    function Qh(e) {
-        const n = gO(e, !0).join(", ");
+    function fl(e) {
+        const n = DE(e, !0).join(", ");
         return e.utc ? `utc(${n})` : `datetime(${n})`
     }
 
-    function Whe(e) {
-        const n = gO(e, !1).join(", ");
+    function Jfe(e) {
+        const n = DE(e, !1).join(", ");
         return e.utc ? `utc(${n})` : `datetime(${n})`
     }
 
-    function Hhe(e) {
-        const t = gO(e, !0);
+    function Qfe(e) {
+        const t = DE(e, !0);
         return e.utc ? +new Date(Date.UTC(...t)) : +new Date(...t)
     }
-    var Yhe = globalThis && globalThis.__rest || function(e, t) {
-        var n = {};
-        for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && t.indexOf(i) < 0 && (n[i] = e[i]);
-        if (e != null && typeof Object.getOwnPropertySymbols == "function")
-            for (var r = 0, i = Object.getOwnPropertySymbols(e); r < i.length; r++) t.indexOf(i[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, i[r]) && (n[i[r]] = e[i[r]]);
-        return n
-    };
-    const Ij = {
+    const QI = {
             year: 1,
             quarter: 1,
             month: 1,
             week: 1,
             day: 1,
             dayofyear: 1,
             date: 1,
             hours: 1,
             minutes: 1,
             seconds: 1,
             milliseconds: 1
         },
-        pO = Y(Ij);
+        NE = H(QI);
 
-    function Xhe(e) {
-        return !!Ij[e]
+    function Zfe(e) {
+        return !!QI[e]
     }
 
-    function mO(e) {
+    function PE(e) {
         return e.startsWith("utc")
     }
 
-    function Vhe(e) {
+    function ehe(e) {
         return e.substr(3)
     }
-    const Khe = {
+    const the = {
         "year-month": "%b %Y ",
         "year-month-date": "%b %d, %Y "
     };
 
-    function yO(e) {
-        return pO.filter(t => jj(e, t))
+    function M1(e) {
+        return NE.filter(t => ZI(e, t))
     }
 
-    function jj(e, t) {
+    function nhe(e) {
+        const t = M1(e);
+        return t[t.length - 1]
+    }
+
+    function ZI(e, t) {
         const n = e.indexOf(t);
         return !(n < 0 || n > 0 && t === "seconds" && e.charAt(n - 1) === "i" || e.length > n + 3 && t === "day" && e.charAt(n + 3) === "o" || n > 0 && t === "year" && e.charAt(n - 1) === "f")
     }
 
-    function Jhe(e, t, {
+    function ihe(e, t, {
         end: n
     } = {
         end: !1
     }) {
-        const i = nO(t),
-            r = mO(e) ? "utc" : "";
+        const i = wE(t),
+            r = PE(e) ? "utc" : "";
 
-        function a(l) {
+        function s(l) {
             return l === "quarter" ? `(${r}quarter(${i})-1)` : `${r}${l}(${i})`
         }
-        let s;
+        let a;
         const o = {};
-        for (const l of pO) jj(e, l) && (o[l] = a(l), s = l);
-        return n && (o[s] += "+1"), Whe(o)
+        for (const l of NE) ZI(e, l) && (o[l] = s(l), a = l);
+        return n && (o[a] += "+1"), Jfe(o)
     }
 
-    function zj(e) {
+    function e6(e) {
         if (!e) return;
-        const t = yO(e);
-        return `timeUnitSpecifier(${ot(t)}, ${ot(Khe)})`
+        const t = M1(e);
+        return `timeUnitSpecifier(${at(t)}, ${at(the)})`
     }
 
-    function Qhe(e, t, n) {
+    function rhe(e, t, n) {
         if (!e) return;
-        const i = zj(e);
-        return `${n||mO(e)?"utc":"time"}Format(${t}, ${i})`
+        const i = e6(e);
+        return `${n||PE(e)?"utc":"time"}Format(${t}, ${i})`
     }
 
-    function En(e) {
+    function en(e) {
         if (!e) return;
         let t;
         return re(e) ? t = {
             unit: e
-        } : se(e) && (t = Object.assign(Object.assign({}, e), e.unit ? {
-            unit: e.unit
-        } : {})), mO(t.unit) && (t.utc = !0, t.unit = Vhe(t.unit)), t
+        } : ae(e) && (t = {
+            ...e,
+            ...e.unit ? {
+                unit: e.unit
+            } : {}
+        }), PE(t.unit) && (t.utc = !0, t.unit = ehe(t.unit)), t
     }
 
-    function Zhe(e) {
-        const t = En(e),
-            {
-                utc: n
-            } = t,
-            i = Yhe(t, ["utc"]);
-        return i.unit ? (n ? "utc" : "") + Y(i).map(r => ht(`${r==="unit"?"":`_${r}_`}${i[r]}`)).join("") : (n ? "utc" : "") + "timeunit" + Y(i).map(r => ht(`_${r}_${i[r]}`)).join("")
+    function she(e) {
+        const {
+            utc: t,
+            ...n
+        } = en(e);
+        return n.unit ? (t ? "utc" : "") + H(n).map(i => ft(`${i==="unit"?"":`_${i}_`}${n[i]}`)).join("") : (t ? "utc" : "") + "timeunit" + H(n).map(i => ft(`_${i}_${n[i]}`)).join("")
     }
 
-    function ede(e) {
+    function t6(e, t = n => n) {
+        const n = en(e),
+            i = nhe(n.unit);
+        if (i && i !== "day") {
+            const r = {
+                    year: 2001,
+                    month: 1,
+                    date: 1,
+                    hours: 0,
+                    minutes: 0,
+                    seconds: 0,
+                    milliseconds: 0
+                },
+                s = n.step || 1,
+                a = {
+                    ...r,
+                    ...i === "quarter" ? {
+                        month: +r.month + s * 3
+                    } : i === "week" ? {
+                        date: +r.date + s * 7
+                    } : {
+                        [i]: +r[i] + s
+                    }
+                };
+            return `${t(fl(a))} - ${t(fl(r))}`
+        }
+    }
+
+    function ahe(e) {
         return e == null ? void 0 : e.param
     }
 
-    function vO(e) {
+    function LE(e) {
         return !!(e != null && e.field) && e.equal !== void 0
     }
 
-    function bO(e) {
+    function IE(e) {
         return !!(e != null && e.field) && e.lt !== void 0
     }
 
-    function xO(e) {
+    function zE(e) {
         return !!(e != null && e.field) && e.lte !== void 0
     }
 
-    function _O(e) {
+    function BE(e) {
         return !!(e != null && e.field) && e.gt !== void 0
     }
 
-    function wO(e) {
+    function jE(e) {
         return !!(e != null && e.field) && e.gte !== void 0
     }
 
-    function SO(e) {
+    function UE(e) {
         if (e != null && e.field) {
-            if (q(e.range) && e.range.length === 2) return !0;
-            if (fe(e.range)) return !0
+            if (W(e.range) && e.range.length === 2) return !0;
+            if (he(e.range)) return !0
         }
         return !1
     }
 
-    function EO(e) {
-        return !!(e != null && e.field) && (q(e.oneOf) || q(e.in))
+    function GE(e) {
+        return !!(e != null && e.field) && (W(e.oneOf) || W(e.in))
     }
 
-    function tde(e) {
+    function ohe(e) {
         return !!(e != null && e.field) && e.valid !== void 0
     }
 
-    function Bj(e) {
-        return EO(e) || vO(e) || SO(e) || bO(e) || _O(e) || xO(e) || wO(e)
+    function n6(e) {
+        return GE(e) || LE(e) || UE(e) || IE(e) || BE(e) || zE(e) || jE(e)
     }
 
-    function Fr(e, t) {
-        return ry(e, {
+    function Ar(e, t) {
+        return B1(e, {
             timeUnit: t,
             wrapTime: !0
         })
     }
 
-    function nde(e, t) {
-        return e.map(n => Fr(n, t))
+    function lhe(e, t) {
+        return e.map(n => Ar(n, t))
     }
 
-    function Gj(e, t = !0) {
-        var n;
+    function i6(e, t = !0) {
+        var s;
         const {
-            field: i
-        } = e, r = (n = En(e.timeUnit)) === null || n === void 0 ? void 0 : n.unit, a = r ? `time(${Jhe(r,i)})` : ne(e, {
+            field: n
+        } = e, i = (s = en(e.timeUnit)) == null ? void 0 : s.unit, r = i ? `time(${ihe(i,n)})` : ie(e, {
             expr: "datum"
         });
-        if (vO(e)) return `${a}===${Fr(e.equal,r)}`;
-        if (bO(e)) {
-            const s = e.lt;
-            return `${a}<${Fr(s,r)}`
-        } else if (_O(e)) {
-            const s = e.gt;
-            return `${a}>${Fr(s,r)}`
-        } else if (xO(e)) {
-            const s = e.lte;
-            return `${a}<=${Fr(s,r)}`
-        } else if (wO(e)) {
-            const s = e.gte;
-            return `${a}>=${Fr(s,r)}`
+        if (LE(e)) return `${r}===${Ar(e.equal,i)}`;
+        if (IE(e)) {
+            const a = e.lt;
+            return `${r}<${Ar(a,i)}`
+        } else if (BE(e)) {
+            const a = e.gt;
+            return `${r}>${Ar(a,i)}`
+        } else if (zE(e)) {
+            const a = e.lte;
+            return `${r}<=${Ar(a,i)}`
+        } else if (jE(e)) {
+            const a = e.gte;
+            return `${r}>=${Ar(a,i)}`
         } else {
-            if (EO(e)) return `indexof([${nde(e.oneOf,r).join(",")}], ${a}) !== -1`;
-            if (tde(e)) return OO(a, e.valid);
-            if (SO(e)) {
+            if (GE(e)) return `indexof([${lhe(e.oneOf,i).join(",")}], ${r}) !== -1`;
+            if (ohe(e)) return WE(r, e.valid);
+            if (UE(e)) {
                 const {
-                    range: s
-                } = e, o = fe(s) ? {
-                    signal: `${s.signal}[0]`
-                } : s[0], l = fe(s) ? {
-                    signal: `${s.signal}[1]`
-                } : s[1];
-                if (o !== null && l !== null && t) return "inrange(" + a + ", [" + Fr(o, r) + ", " + Fr(l, r) + "])";
+                    range: a
+                } = e, o = he(a) ? {
+                    signal: `${a.signal}[0]`
+                } : a[0], l = he(a) ? {
+                    signal: `${a.signal}[1]`
+                } : a[1];
+                if (o !== null && l !== null && t) return "inrange(" + r + ", [" + Ar(o, i) + ", " + Ar(l, i) + "])";
                 const u = [];
-                return o !== null && u.push(`${a} >= ${Fr(o,r)}`), l !== null && u.push(`${a} <= ${Fr(l,r)}`), u.length > 0 ? u.join(" && ") : "true"
+                return o !== null && u.push(`${r} >= ${Ar(o,i)}`), l !== null && u.push(`${r} <= ${Ar(l,i)}`), u.length > 0 ? u.join(" && ") : "true"
             }
         }
-        throw new Error(`Invalid field predicate: ${ot(e)}`)
+        throw new Error(`Invalid field predicate: ${at(e)}`)
     }
 
-    function OO(e, t = !0) {
+    function WE(e, t = !0) {
         return t ? `isValid(${e}) && isFinite(+${e})` : `!isValid(${e}) || !isFinite(+${e})`
     }
 
-    function ide(e) {
+    function uhe(e) {
         var t;
-        return Bj(e) && e.timeUnit ? Object.assign(Object.assign({}, e), {
-            timeUnit: (t = En(e.timeUnit)) === null || t === void 0 ? void 0 : t.unit
-        }) : e
+        return n6(e) && e.timeUnit ? {
+            ...e,
+            timeUnit: (t = en(e.timeUnit)) == null ? void 0 : t.unit
+        } : e
     }
-    const Hd = {
+    const Od = {
         quantitative: "quantitative",
         ordinal: "ordinal",
         temporal: "temporal",
         nominal: "nominal",
         geojson: "geojson"
     };
 
-    function rde(e) {
+    function che(e) {
         return e === "quantitative" || e === "temporal"
     }
 
-    function Uj(e) {
+    function r6(e) {
         return e === "ordinal" || e === "nominal"
     }
-    const Sl = Hd.quantitative,
-        CO = Hd.ordinal,
-        hc = Hd.temporal,
-        kO = Hd.nominal,
-        qc = Hd.geojson;
+    const hl = Od.quantitative,
+        qE = Od.ordinal,
+        nc = Od.temporal,
+        HE = Od.nominal,
+        Rc = Od.geojson;
 
-    function ade(e) {
+    function fhe(e) {
         if (e) switch (e = e.toLowerCase(), e) {
             case "q":
-            case Sl:
+            case hl:
                 return "quantitative";
             case "t":
-            case hc:
+            case nc:
                 return "temporal";
             case "o":
-            case CO:
+            case qE:
                 return "ordinal";
             case "n":
-            case kO:
+            case HE:
                 return "nominal";
-            case qc:
+            case Rc:
                 return "geojson"
         }
     }
-    var sde = globalThis && globalThis.__rest || function(e, t) {
-        var n = {};
-        for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && t.indexOf(i) < 0 && (n[i] = e[i]);
-        if (e != null && typeof Object.getOwnPropertySymbols == "function")
-            for (var r = 0, i = Object.getOwnPropertySymbols(e); r < i.length; r++) t.indexOf(i[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, i[r]) && (n[i[r]] = e[i[r]]);
-        return n
-    };
-    const ei = {
+    const Qn = {
             LINEAR: "linear",
             LOG: "log",
             POW: "pow",
             SQRT: "sqrt",
             SYMLOG: "symlog",
             IDENTITY: "identity",
             SEQUENTIAL: "sequential",
@@ -37828,15 +37916,15 @@
             QUANTIZE: "quantize",
             THRESHOLD: "threshold",
             BIN_ORDINAL: "bin-ordinal",
             ORDINAL: "ordinal",
             POINT: "point",
             BAND: "band"
         },
-        _x = {
+        X2 = {
             linear: "numeric",
             log: "numeric",
             pow: "numeric",
             sqrt: "numeric",
             symlog: "numeric",
             identity: "numeric",
             sequential: "numeric",
@@ -37847,20 +37935,20 @@
             point: "ordinal-position",
             band: "ordinal-position",
             quantile: "discretizing",
             quantize: "discretizing",
             threshold: "discretizing"
         };
 
-    function ode(e, t) {
-        const n = _x[e],
-            i = _x[t];
+    function hhe(e, t) {
+        const n = X2[e],
+            i = X2[t];
         return n === i || n === "ordinal-position" && i === "time" || i === "ordinal-position" && n === "time"
     }
-    const lde = {
+    const dhe = {
         linear: 0,
         log: 1,
         pow: 1,
         sqrt: 1,
         symlog: 1,
         identity: 1,
         sequential: 1,
@@ -37871,43 +37959,43 @@
         ordinal: 0,
         "bin-ordinal": 0,
         quantile: 0,
         quantize: 0,
         threshold: 0
     };
 
-    function x$(e) {
-        return lde[e]
+    function D5(e) {
+        return dhe[e]
     }
-    const qj = new Set(["linear", "log", "pow", "sqrt", "symlog"]),
-        Wj = new Set([...qj, "time", "utc"]);
+    const s6 = new Set(["linear", "log", "pow", "sqrt", "symlog"]),
+        a6 = new Set([...s6, "time", "utc"]);
 
-    function Hj(e) {
-        return qj.has(e)
+    function o6(e) {
+        return s6.has(e)
     }
-    const Yj = new Set(["quantile", "quantize", "threshold"]),
-        ude = new Set([...Wj, ...Yj, "sequential", "identity"]),
-        cde = new Set(["ordinal", "bin-ordinal", "point", "band"]);
+    const l6 = new Set(["quantile", "quantize", "threshold"]),
+        ghe = new Set([...a6, ...l6, "sequential", "identity"]),
+        phe = new Set(["ordinal", "bin-ordinal", "point", "band"]);
 
-    function Vt(e) {
-        return cde.has(e)
+    function qt(e) {
+        return phe.has(e)
     }
 
-    function Ei(e) {
-        return ude.has(e)
+    function wi(e) {
+        return ghe.has(e)
     }
 
-    function fr(e) {
-        return Wj.has(e)
+    function ir(e) {
+        return a6.has(e)
     }
 
-    function dc(e) {
-        return Yj.has(e)
+    function ic(e) {
+        return l6.has(e)
     }
-    const fde = {
+    const mhe = {
         pointPadding: .5,
         barBandPaddingInner: .1,
         rectBandPaddingInner: 0,
         bandWithNestedOffsetPaddingInner: .2,
         bandWithNestedOffsetPaddingOuter: .2,
         minBandSize: 2,
         minFontSize: 8,
@@ -37918,30 +38006,30 @@
         minStrokeWidth: 1,
         maxStrokeWidth: 4,
         quantileCount: 4,
         quantizeCount: 4,
         zero: !0
     };
 
-    function hde(e) {
+    function yhe(e) {
         return !re(e) && !!e.name
     }
 
-    function Xj(e) {
+    function u6(e) {
         return e == null ? void 0 : e.param
     }
 
-    function dde(e) {
+    function vhe(e) {
         return e == null ? void 0 : e.unionWith
     }
 
-    function gde(e) {
-        return se(e) && "field" in e
+    function bhe(e) {
+        return ae(e) && "field" in e
     }
-    const pde = {
+    const xhe = {
             type: 1,
             domain: 1,
             domainMax: 1,
             domainMin: 1,
             domainMid: 1,
             align: 1,
             range: 1,
@@ -37958,64 +38046,72 @@
             constant: 1,
             interpolate: 1,
             zero: 1,
             padding: 1,
             paddingInner: 1,
             paddingOuter: 1
         },
-        mde = sde(pde, ["type", "domain", "range", "rangeMax", "rangeMin", "scheme"]),
-        yde = Y(mde);
+        {
+            type: k2e,
+            domain: A2e,
+            range: $2e,
+            rangeMax: T2e,
+            rangeMin: M2e,
+            scheme: O2e,
+            ..._he
+        } = xhe,
+        whe = H(_he);
 
-    function wx(e, t) {
+    function V2(e, t) {
         switch (t) {
             case "type":
             case "domain":
             case "reverse":
             case "range":
                 return !0;
             case "scheme":
             case "interpolate":
                 return !["point", "band", "identity"].includes(e);
             case "bins":
                 return !["point", "band", "identity", "ordinal"].includes(e);
             case "round":
-                return fr(e) || e === "band" || e === "point";
+                return ir(e) || e === "band" || e === "point";
             case "padding":
             case "rangeMin":
             case "rangeMax":
-                return fr(e) || ["point", "band"].includes(e);
+                return ir(e) || ["point", "band"].includes(e);
             case "paddingOuter":
             case "align":
                 return ["point", "band"].includes(e);
             case "paddingInner":
                 return e === "band";
             case "domainMax":
             case "domainMid":
             case "domainMin":
             case "clamp":
-                return fr(e);
+                return ir(e);
             case "nice":
-                return fr(e) || e === "quantize" || e === "threshold";
+                return ir(e) || e === "quantize" || e === "threshold";
             case "exponent":
                 return e === "pow";
             case "base":
                 return e === "log";
             case "constant":
                 return e === "symlog";
             case "zero":
-                return Ei(e) && !Pe(["log", "time", "utc", "threshold", "quantile"], e)
+                return wi(e) && !Fe(["log", "time", "utc", "threshold", "quantile"], e)
         }
     }
 
-    function Vj(e, t) {
+    function c6(e, t) {
         switch (t) {
             case "interpolate":
             case "scheme":
             case "domainMid":
-                return Nu(e) ? void 0 : dhe(t);
+                return Cu(e) ? void 0 : bfe(t);
             case "align":
             case "type":
             case "bins":
             case "domain":
             case "domainMax":
             case "domainMin":
             case "range":
@@ -38032,45 +38128,45 @@
             case "round":
             case "clamp":
             case "zero":
                 return
         }
     }
 
-    function vde(e, t) {
-        return Pe([CO, kO], t) ? e === void 0 || Vt(e) : t === hc ? Pe([ei.TIME, ei.UTC, void 0], e) : t === Sl ? Hj(e) || dc(e) || e === void 0 : !0
+    function She(e, t) {
+        return Fe([qE, HE], t) ? e === void 0 || qt(e) : t === nc ? Fe([Qn.TIME, Qn.UTC, void 0], e) : t === hl ? o6(e) || ic(e) || e === void 0 : !0
     }
 
-    function bde(e, t, n = !1) {
-        if (!bo(e)) return !1;
+    function Ehe(e, t, n = !1) {
+        if (!Qs(e)) return !1;
         switch (e) {
-            case yt:
-            case Yt:
-            case go:
-            case Gc:
-            case Wi:
-            case Ar:
-                return fr(t) || t === "band" ? !0 : t === "point" ? !n : !1;
-            case as:
-            case yo:
-            case ss:
-            case po:
-            case mo:
-            case Wl:
-                return fr(t) || dc(t) || Pe(["band", "point", "ordinal"], t);
-            case oi:
-            case ya:
-            case va:
+            case ht:
+            case Gt:
+            case no:
+            case Mc:
+            case zi:
+            case _r:
+                return ir(t) || t === "band" ? !0 : t === "point" ? !n : !1;
+            case Ks:
+            case so:
+            case Js:
+            case io:
+            case ro:
+            case Dl:
+                return ir(t) || ic(t) || Fe(["band", "point", "ordinal"], t);
+            case si:
+            case os:
+            case ls:
                 return t !== "band";
-            case vo:
-            case li:
-                return t === "ordinal" || dc(t)
+            case ao:
+            case ai:
+                return t === "ordinal" || ic(t)
         }
     }
-    const Un = {
+    const jn = {
             arc: "arc",
             area: "area",
             bar: "bar",
             image: "image",
             line: "line",
             point: "point",
             rect: "rect",
@@ -38078,68 +38174,68 @@
             text: "text",
             tick: "tick",
             trail: "trail",
             circle: "circle",
             square: "square",
             geoshape: "geoshape"
         },
-        Kj = Un.arc,
-        V1 = Un.area,
-        K1 = Un.bar,
-        xde = Un.image,
-        J1 = Un.line,
-        Q1 = Un.point,
-        _de = Un.rect,
-        im = Un.rule,
-        Jj = Un.text,
-        AO = Un.tick,
-        wde = Un.trail,
-        TO = Un.circle,
-        $O = Un.square,
-        Qj = Un.geoshape;
+        f6 = jn.arc,
+        O1 = jn.area,
+        F1 = jn.bar,
+        Che = jn.image,
+        R1 = jn.line,
+        D1 = jn.point,
+        khe = jn.rect,
+        I0 = jn.rule,
+        h6 = jn.text,
+        YE = jn.tick,
+        Ahe = jn.trail,
+        XE = jn.circle,
+        VE = jn.square,
+        d6 = jn.geoshape;
 
-    function wo(e) {
+    function uo(e) {
         return ["line", "area", "trail"].includes(e)
     }
 
-    function Zj(e) {
+    function g6(e) {
         return ["rect", "bar", "image", "arc"].includes(e)
     }
-    const Sde = new Set(Y(Un));
+    const $he = new Set(H(jn));
 
-    function na(e) {
+    function Vr(e) {
         return e.type
     }
-    const Ede = ["stroke", "strokeWidth", "strokeDash", "strokeDashOffset", "strokeOpacity", "strokeJoin", "strokeMiterLimit"],
-        Ode = ["fill", "fillOpacity"],
-        Cde = [...Ede, ...Ode],
-        kde = {
+    const The = ["stroke", "strokeWidth", "strokeDash", "strokeDashOffset", "strokeOpacity", "strokeJoin", "strokeMiterLimit"],
+        Mhe = ["fill", "fillOpacity"],
+        Ohe = [...The, ...Mhe],
+        Fhe = {
             color: 1,
             filled: 1,
             invalid: 1,
             order: 1,
             radius2: 1,
             theta2: 1,
             timeUnitBandSize: 1,
             timeUnitBandPosition: 1
         },
-        _$ = Y(kde),
-        Ade = {
+        N5 = H(Fhe),
+        Rhe = {
             area: ["line", "point"],
             bar: ["binSpacing", "continuousBandSize", "discreteBandSize"],
             rect: ["binSpacing", "continuousBandSize", "discreteBandSize"],
             line: ["point"],
             tick: ["bandSize", "thickness"]
         },
-        Tde = {
+        Dhe = {
             color: "#4c78a8",
             invalid: "filter",
             timeUnitBandSize: 1
         },
-        $de = {
+        Nhe = {
             mark: 1,
             arc: 1,
             area: 1,
             bar: 1,
             circle: 1,
             image: 1,
             line: 1,
@@ -38148,1055 +38244,1073 @@
             rule: 1,
             square: 1,
             text: 1,
             tick: 1,
             trail: 1,
             geoshape: 1
         },
-        e6 = Y($de);
+        p6 = H(Nhe);
 
-    function El(e) {
+    function dl(e) {
         return e && e.band != null
     }
-    const Mde = {
+    const Phe = {
             horizontal: ["cornerRadiusTopRight", "cornerRadiusBottomRight"],
             vertical: ["cornerRadiusTopLeft", "cornerRadiusTopRight"]
         },
-        t6 = 5,
-        Fde = {
+        m6 = 5,
+        Lhe = {
             binSpacing: 1,
-            continuousBandSize: t6,
+            continuousBandSize: m6,
             timeUnitBandPosition: .5
         },
-        Dde = {
+        Ihe = {
             binSpacing: 0,
-            continuousBandSize: t6,
+            continuousBandSize: m6,
             timeUnitBandPosition: .5
         },
-        Rde = {
+        zhe = {
             thickness: 1
         };
 
-    function Pde(e) {
-        return na(e) ? e.type : e
+    function Bhe(e) {
+        return Vr(e) ? e.type : e
     }
 
-    function MO(e) {
+    function KE(e) {
         const {
             channel: t,
             channelDef: n,
             markDef: i,
             scale: r,
-            config: a
-        } = e, s = DO(e);
-        return J(n) && !bj(n.aggregate) && r && fr(r.get("type")) ? Nde({
+            config: s
+        } = e, a = QE(e);
+        return K(n) && !RI(n.aggregate) && r && ir(r.get("type")) ? jhe({
             fieldDef: n,
             channel: t,
             markDef: i,
-            ref: s,
-            config: a
-        }) : s
+            ref: a,
+            config: s
+        }) : a
     }
 
-    function Nde({
+    function jhe({
         fieldDef: e,
         channel: t,
         markDef: n,
         ref: i,
         config: r
     }) {
-        return wo(n.type) ? i : Ve("invalid", n, r) === null ? [Lde(e, t), i] : i
+        return uo(n.type) ? i : Xe("invalid", n, r) === null ? [Uhe(e, t), i] : i
     }
 
-    function Lde(e, t) {
-        const n = FO(e, !0),
-            r = Hl(t) === "y" ? {
+    function Uhe(e, t) {
+        const n = JE(e, !0),
+            r = Nl(t) === "y" ? {
                 field: {
                     group: "height"
                 }
             } : {
                 value: 0
             };
-        return Object.assign({
-            test: n
-        }, r)
+        return {
+            test: n,
+            ...r
+        }
     }
 
-    function FO(e, t = !0) {
-        return OO(re(e) ? e : ne(e, {
+    function JE(e, t = !0) {
+        return WE(re(e) ? e : ie(e, {
             expr: "datum"
         }), !t)
     }
 
-    function Ide(e) {
+    function Ghe(e) {
         const {
             datum: t
         } = e;
-        return Xl(t) ? Qh(t) : `${ot(t)}`
+        return Ll(t) ? fl(t) : `${at(t)}`
     }
 
-    function rl(e, t, n, i) {
+    function qo(e, t, n, i) {
         const r = {};
-        if (t && (r.scale = t), _a(e)) {
+        if (t && (r.scale = t), fs(e)) {
             const {
-                datum: a
+                datum: s
             } = e;
-            Xl(a) ? r.signal = Qh(a) : fe(a) ? r.signal = a.signal : Wd(a) ? r.signal = a.expr : r.value = a
-        } else r.field = ne(e, n);
+            Ll(s) ? r.signal = fl(s) : he(s) ? r.signal = s.signal : Fc(s) ? r.signal = s.expr : r.value = s
+        } else r.field = ie(e, n);
         if (i) {
             const {
-                offset: a,
-                band: s
+                offset: s,
+                band: a
             } = i;
-            a && (r.offset = a), s && (r.band = s)
+            s && (r.offset = s), a && (r.band = a)
         }
         return r
     }
 
-    function rm({
+    function z0({
         scaleName: e,
         fieldOrDatumDef: t,
         fieldOrDatumDef2: n,
         offset: i,
         startSuffix: r,
-        bandPosition: a = .5
+        bandPosition: s = .5
     }) {
-        const s = 0 < a && a < 1 ? "datum" : void 0,
-            o = ne(t, {
-                expr: s,
+        const a = 0 < s && s < 1 ? "datum" : void 0,
+            o = ie(t, {
+                expr: a,
                 suffix: r
             }),
-            l = n !== void 0 ? ne(n, {
-                expr: s
-            }) : ne(t, {
+            l = n !== void 0 ? ie(n, {
+                expr: a
+            }) : ie(t, {
                 suffix: "end",
-                expr: s
+                expr: a
             }),
             u = {};
-        if (a === 0 || a === 1) {
+        if (s === 0 || s === 1) {
             u.scale = e;
-            const c = a === 0 ? o : l;
+            const c = s === 0 ? o : l;
             u.field = c
         } else {
-            const c = fe(a) ? `${a.signal} * ${o} + (1-${a.signal}) * ${l}` : `${a} * ${o} + ${1-a} * ${l}`;
+            const c = he(s) ? `${s.signal} * ${o} + (1-${s.signal}) * ${l}` : `${s} * ${o} + ${1-s} * ${l}`;
             u.signal = `scale("${e}", ${c})`
         }
         return i && (u.offset = i), u
     }
 
-    function DO({
+    function QE({
         channel: e,
         channelDef: t,
         channel2Def: n,
         markDef: i,
         config: r,
-        scaleName: a,
-        scale: s,
+        scaleName: s,
+        scale: a,
         stack: o,
         offset: l,
         defaultRef: u,
         bandPosition: c
     }) {
-        var f;
         if (t) {
-            if (Ee(t)) {
-                const h = s == null ? void 0 : s.get("type");
-                if (Ui(t)) {
-                    c ?? (c = u6({
+            if (Ce(t)) {
+                const f = a == null ? void 0 : a.get("type");
+                if (zn(t)) {
+                    c ?? (c = E6({
                         fieldDef: t,
                         fieldDef2: n,
                         markDef: i,
                         config: r
                     }));
                     const {
-                        bin: d,
-                        timeUnit: g,
-                        type: p
+                        bin: h,
+                        timeUnit: d,
+                        type: g
                     } = t;
-                    if (lt(d) || c && g && p === hc) return o != null && o.impute ? rl(t, a, {
+                    if (ot(h) || c && d && g === nc) return o != null && o.impute ? qo(t, s, {
                         binSuffix: "mid"
                     }, {
                         offset: l
-                    }) : c && !Vt(h) ? rm({
-                        scaleName: a,
+                    }) : c && !qt(f) ? z0({
+                        scaleName: s,
                         fieldOrDatumDef: t,
                         bandPosition: c,
                         offset: l
-                    }) : rl(t, a, Kd(t, e) ? {
+                    }) : qo(t, s, Nd(t, e) ? {
                         binSuffix: "range"
                     } : {}, {
                         offset: l
                     });
-                    if (Qt(d)) {
-                        if (J(n)) return rm({
-                            scaleName: a,
+                    if (Xt(h)) {
+                        if (K(n)) return z0({
+                            scaleName: s,
                             fieldOrDatumDef: t,
                             fieldOrDatumDef2: n,
                             bandPosition: c,
                             offset: l
                         });
-                        X(Rj(e === yt ? kr : ga))
+                        X(XI(e === ht ? xr : as))
                     }
                 }
-                return rl(t, a, Vt(h) ? {
+                return qo(t, s, qt(f) ? {
                     binSuffix: "range"
                 } : {}, {
                     offset: l,
-                    band: h === "band" ? (f = c ?? t.bandPosition) !== null && f !== void 0 ? f : .5 : void 0
+                    band: f === "band" ? c ?? t.bandPosition ?? .5 : void 0
                 })
-            } else if (wr(t)) {
-                const h = t.value,
-                    d = l ? {
+            } else if (gr(t)) {
+                const f = t.value,
+                    h = l ? {
                         offset: l
                     } : {};
-                return Object.assign(Object.assign({}, xh(e, h)), d)
+                return {
+                    ...lh(e, f),
+                    ...h
+                }
             }
         }
-        return Ae(u) && (u = u()), u && Object.assign(Object.assign({}, u), l ? {
-            offset: l
-        } : {})
+        return $e(u) && (u = u()), u && {
+            ...u,
+            ...l ? {
+                offset: l
+            } : {}
+        }
     }
 
-    function xh(e, t) {
-        return Pe(["x", "x2"], e) && t === "width" ? {
+    function lh(e, t) {
+        return Fe(["x", "x2"], e) && t === "width" ? {
             field: {
                 group: "width"
             }
-        } : Pe(["y", "y2"], e) && t === "height" ? {
+        } : Fe(["y", "y2"], e) && t === "height" ? {
             field: {
                 group: "height"
             }
-        } : ct(t)
+        } : ut(t)
     }
 
-    function Ol(e) {
+    function gl(e) {
         return e && e !== "number" && e !== "time"
     }
 
-    function n6(e, t, n) {
-        return `${e}(${t}${n?`, ${ot(n)}`:""})`
+    function y6(e, t, n) {
+        return `${e}(${t}${n?`, ${at(n)}`:""})`
     }
-    const jde = " – ";
+    const Whe = " – ";
 
-    function RO({
+    function ZE({
         fieldOrDatumDef: e,
         format: t,
         formatType: n,
         expr: i,
         normalizeStack: r,
-        config: a
+        config: s
     }) {
-        var s, o;
-        if (Ol(n)) return hr({
+        var l, u;
+        if (gl(n)) return rr({
             fieldOrDatumDef: e,
             format: t,
             formatType: n,
             expr: i,
-            config: a
+            config: s
         });
-        const l = i6(e, i, r),
-            u = gc(e);
-        if (t === void 0 && n === void 0 && a.customFormatTypes) {
-            if (u === "quantitative") {
-                if (r && a.normalizedNumberFormatType) return hr({
+        const a = v6(e, i, r),
+            o = rc(e);
+        if (t === void 0 && n === void 0 && s.customFormatTypes) {
+            if (o === "quantitative") {
+                if (r && s.normalizedNumberFormatType) return rr({
                     fieldOrDatumDef: e,
-                    format: a.normalizedNumberFormat,
-                    formatType: a.normalizedNumberFormatType,
+                    format: s.normalizedNumberFormat,
+                    formatType: s.normalizedNumberFormatType,
                     expr: i,
-                    config: a
+                    config: s
                 });
-                if (a.numberFormatType) return hr({
+                if (s.numberFormatType) return rr({
                     fieldOrDatumDef: e,
-                    format: a.numberFormat,
-                    formatType: a.numberFormatType,
+                    format: s.numberFormat,
+                    formatType: s.numberFormatType,
                     expr: i,
-                    config: a
+                    config: s
                 })
             }
-            if (u === "temporal" && a.timeFormatType && J(e) && e.timeUnit === void 0) return hr({
+            if (o === "temporal" && s.timeFormatType && K(e) && e.timeUnit === void 0) return rr({
                 fieldOrDatumDef: e,
-                format: a.timeFormat,
-                formatType: a.timeFormatType,
+                format: s.timeFormat,
+                formatType: s.timeFormatType,
                 expr: i,
-                config: a
+                config: s
             })
         }
-        if (mc(e)) {
-            const c = Bde({
-                field: l,
-                timeUnit: J(e) ? (s = En(e.timeUnit)) === null || s === void 0 ? void 0 : s.unit : void 0,
+        if (ac(e)) {
+            const c = Hhe({
+                field: a,
+                timeUnit: K(e) ? (l = en(e.timeUnit)) == null ? void 0 : l.unit : void 0,
                 format: t,
-                formatType: a.timeFormatType,
-                rawTimeFormat: a.timeFormat,
-                isUTCScale: Vl(e) && ((o = e.scale) === null || o === void 0 ? void 0 : o.type) === ei.UTC
+                formatType: s.timeFormatType,
+                rawTimeFormat: s.timeFormat,
+                isUTCScale: Il(e) && ((u = e.scale) == null ? void 0 : u.type) === Qn.UTC
             });
             return c ? {
                 signal: c
             } : void 0
         }
-        if (t = Sx({
-                type: u,
+        if (t = K2({
+                type: o,
                 specifiedFormat: t,
-                config: a,
+                config: s,
                 normalizeStack: r
-            }), J(e) && lt(e.bin)) {
-            const c = ne(e, {
+            }), K(e) && ot(e.bin)) {
+            const c = ie(e, {
                 expr: i,
                 binSuffix: "end"
             });
             return {
-                signal: Yd(l, c, t, n, a)
+                signal: Fd(a, c, t, n, s)
             }
-        } else return t || gc(e) === "quantitative" ? {
-            signal: `${s6(l,t)}`
+        } else return t || rc(e) === "quantitative" ? {
+            signal: `${_6(a,t)}`
         } : {
-            signal: `isValid(${l}) ? ${l} : ""+${l}`
+            signal: `isValid(${a}) ? ${a} : ""+${a}`
         }
     }
 
-    function i6(e, t, n) {
-        return J(e) ? n ? `${ne(e,{expr:t,suffix:"end"})}-${ne(e,{expr:t,suffix:"start"})}` : ne(e, {
+    function v6(e, t, n) {
+        return K(e) ? n ? `${ie(e,{expr:t,suffix:"end"})}-${ie(e,{expr:t,suffix:"start"})}` : ie(e, {
             expr: t
-        }) : Ide(e)
+        }) : Ghe(e)
     }
 
-    function hr({
+    function rr({
         fieldOrDatumDef: e,
         format: t,
         formatType: n,
         expr: i,
         normalizeStack: r,
-        config: a,
-        field: s
+        config: s,
+        field: a
     }) {
-        if (s ?? (s = i6(e, i, r)), s !== "datum.value" && J(e) && lt(e.bin)) {
-            const o = ne(e, {
+        if (a ?? (a = v6(e, i, r)), a !== "datum.value" && K(e) && ot(e.bin)) {
+            const o = ie(e, {
                 expr: i,
                 binSuffix: "end"
             });
             return {
-                signal: Yd(s, o, t, n, a)
+                signal: Fd(a, o, t, n, s)
             }
         }
         return {
-            signal: n6(n, s, t)
+            signal: y6(n, a, t)
         }
     }
 
-    function r6(e, t, n, i, r, a) {
-        var s;
-        if (!Ol(i) && !(n === void 0 && i === void 0 && r.customFormatTypes && gc(e) === "quantitative" && (r.normalizedNumberFormatType && pc(e) && e.stack === "normalize" || r.numberFormatType))) {
-            if (pc(e) && e.stack === "normalize" && r.normalizedNumberFormat) return Sx({
+    function b6(e, t, n, i, r, s) {
+        var a;
+        if (!(re(i) && gl(i)) && !(n === void 0 && i === void 0 && r.customFormatTypes && rc(e) === "quantitative" && (r.normalizedNumberFormatType && sc(e) && e.stack === "normalize" || r.numberFormatType))) {
+            if (sc(e) && e.stack === "normalize" && r.normalizedNumberFormat) return K2({
                 type: "quantitative",
                 config: r,
                 normalizeStack: !0
             });
-            if (mc(e)) {
-                const o = J(e) ? (s = En(e.timeUnit)) === null || s === void 0 ? void 0 : s.unit : void 0;
-                return o === void 0 && r.customFormatTypes && r.timeFormatType ? void 0 : zde({
+            if (ac(e)) {
+                const o = K(e) ? (a = en(e.timeUnit)) == null ? void 0 : a.unit : void 0;
+                return o === void 0 && r.customFormatTypes && r.timeFormatType ? void 0 : qhe({
                     specifiedFormat: n,
                     timeUnit: o,
                     config: r,
-                    omitTimeFormatConfig: a
+                    omitTimeFormatConfig: s
                 })
             }
-            return Sx({
+            return K2({
                 type: t,
                 specifiedFormat: n,
                 config: r
             })
         }
     }
 
-    function a6(e, t, n) {
+    function x6(e, t, n) {
         var i;
-        if (e && (fe(e) || e === "number" || e === "time")) return e;
-        if (mc(t) && n !== "time" && n !== "utc") return J(t) && (!((i = En(t == null ? void 0 : t.timeUnit)) === null || i === void 0) && i.utc) ? "utc" : "time"
+        if (e && (he(e) || e === "number" || e === "time")) return e;
+        if (ac(t) && n !== "time" && n !== "utc") return K(t) && ((i = en(t == null ? void 0 : t.timeUnit)) != null && i.utc) ? "utc" : "time"
     }
 
-    function Sx({
+    function K2({
         type: e,
         specifiedFormat: t,
         config: n,
         normalizeStack: i
     }) {
         if (re(t)) return t;
-        if (e === Sl) return i ? n.normalizedNumberFormat : n.numberFormat
+        if (e === hl) return i ? n.normalizedNumberFormat : n.numberFormat
     }
 
-    function zde({
+    function qhe({
         specifiedFormat: e,
         timeUnit: t,
         config: n,
         omitTimeFormatConfig: i
     }) {
         return e || (t ? {
-            signal: zj(t)
+            signal: e6(t)
         } : i ? void 0 : n.timeFormat)
     }
 
-    function s6(e, t) {
+    function _6(e, t) {
         return `format(${e}, "${t||""}")`
     }
 
-    function w$(e, t, n, i) {
-        var r;
-        return Ol(n) ? n6(n, e, t) : s6(e, (r = re(t) ? t : void 0) !== null && r !== void 0 ? r : i.numberFormat)
+    function P5(e, t, n, i) {
+        return gl(n) ? y6(n, e, t) : _6(e, (re(t) ? t : void 0) ?? i.numberFormat)
     }
 
-    function Yd(e, t, n, i, r) {
-        if (n === void 0 && i === void 0 && r.customFormatTypes && r.numberFormatType) return Yd(e, t, r.numberFormat, r.numberFormatType, r);
-        const a = w$(e, n, i, r),
-            s = w$(t, n, i, r);
-        return `${OO(e,!1)} ? "null" : ${a} + "${jde}" + ${s}`
+    function Fd(e, t, n, i, r) {
+        if (n === void 0 && i === void 0 && r.customFormatTypes && r.numberFormatType) return Fd(e, t, r.numberFormat, r.numberFormatType, r);
+        const s = P5(e, n, i, r),
+            a = P5(t, n, i, r);
+        return `${WE(e,!1)} ? "null" : ${s} + "${Whe}" + ${a}`
     }
 
-    function Bde({
+    function Hhe({
         field: e,
         timeUnit: t,
         format: n,
         formatType: i,
         rawTimeFormat: r,
-        isUTCScale: a
+        isUTCScale: s
     }) {
-        return !t || n ? !t && i ? `${i}(${e}, '${n}')` : (n = re(n) ? n : r, `${a?"utc":"time"}Format(${e}, '${n}')`) : Qhe(t, e, a)
+        return !t || n ? !t && i ? `${i}(${e}, '${n}')` : (n = re(n) ? n : r, `${s?"utc":"time"}Format(${e}, '${n}')`) : rhe(t, e, s)
     }
-    const Z1 = "min",
-        Gde = {
+    const N1 = "min",
+        Yhe = {
             x: 1,
             y: 1,
             color: 1,
             fill: 1,
             stroke: 1,
             strokeWidth: 1,
             size: 1,
             shape: 1,
             fillOpacity: 1,
             strokeOpacity: 1,
             opacity: 1,
             text: 1
         };
 
-    function S$(e) {
-        return e in Gde
+    function L5(e) {
+        return e in Yhe
     }
 
-    function o6(e) {
+    function w6(e) {
         return !!(e != null && e.encoding)
     }
 
-    function Yr(e) {
+    function Br(e) {
         return e && (e.op === "count" || !!e.field)
     }
 
-    function l6(e) {
-        return e && q(e)
+    function S6(e) {
+        return e && W(e)
     }
 
-    function Xd(e) {
+    function Rd(e) {
         return "row" in e || "column" in e
     }
 
-    function PO(e) {
+    function eC(e) {
         return !!e && "header" in e
     }
 
-    function ey(e) {
+    function P1(e) {
         return "facet" in e
     }
-    var Ex = globalThis && globalThis.__rest || function(e, t) {
-        var n = {};
-        for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && t.indexOf(i) < 0 && (n[i] = e[i]);
-        if (e != null && typeof Object.getOwnPropertySymbols == "function")
-            for (var r = 0, i = Object.getOwnPropertySymbols(e); r < i.length; r++) t.indexOf(i[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, i[r]) && (n[i[r]] = e[i[r]]);
-        return n
-    };
 
-    function Ude(e) {
+    function Xhe(e) {
         return e.param
     }
 
-    function qde(e) {
+    function Vhe(e) {
         return e && !re(e) && "repeat" in e
     }
 
-    function E$(e) {
+    function I5(e) {
         const {
             field: t,
             timeUnit: n,
             bin: i,
             aggregate: r
         } = e;
-        return Object.assign(Object.assign(Object.assign(Object.assign({}, n ? {
-            timeUnit: n
-        } : {}), i ? {
-            bin: i
-        } : {}), r ? {
-            aggregate: r
-        } : {}), {
+        return {
+            ...n ? {
+                timeUnit: n
+            } : {},
+            ...i ? {
+                bin: i
+            } : {},
+            ...r ? {
+                aggregate: r
+            } : {},
             field: t
-        })
+        }
     }
 
-    function NO(e) {
+    function tC(e) {
         return "sort" in e
     }
 
-    function u6({
+    function E6({
         fieldDef: e,
         fieldDef2: t,
         markDef: n,
         config: i
     }) {
-        if (Ee(e) && e.bandPosition !== void 0) return e.bandPosition;
-        if (J(e)) {
+        if (Ce(e) && e.bandPosition !== void 0) return e.bandPosition;
+        if (K(e)) {
             const {
                 timeUnit: r,
-                bin: a
+                bin: s
             } = e;
-            if (r && !t) return Zj(n.type) ? 0 : wl("timeUnitBandPosition", n, i);
-            if (lt(a)) return .5
+            if (r && !t) return g6(n.type) ? 0 : cl("timeUnitBandPosition", n, i);
+            if (ot(s)) return .5
         }
     }
 
-    function c6({
+    function C6({
         channel: e,
         fieldDef: t,
         fieldDef2: n,
         markDef: i,
         config: r,
-        scaleType: a,
-        useVlSizeChannel: s
+        scaleType: s,
+        useVlSizeChannel: a
     }) {
-        var o, l, u;
-        const c = ui(e),
-            f = Ve(s ? "size" : c, i, r, {
-                vgChannel: c
+        var u, c, f;
+        const o = oi(e),
+            l = Xe(a ? "size" : o, i, r, {
+                vgChannel: o
             });
-        if (f !== void 0) return f;
-        if (J(t)) {
+        if (l !== void 0) return l;
+        if (K(t)) {
             const {
                 timeUnit: h,
                 bin: d
             } = t;
             if (h && !n) return {
-                band: wl("timeUnitBandSize", i, r)
+                band: cl("timeUnitBandSize", i, r)
             };
-            if (lt(d) && !Vt(a)) return {
+            if (ot(d) && !qt(s)) return {
                 band: 1
             }
         }
-        if (Zj(i.type)) return a ? Vt(a) ? ((o = r[i.type]) === null || o === void 0 ? void 0 : o.discreteBandSize) || {
+        if (g6(i.type)) return s ? qt(s) ? ((u = r[i.type]) == null ? void 0 : u.discreteBandSize) || {
             band: 1
-        } : (l = r[i.type]) === null || l === void 0 ? void 0 : l.continuousBandSize : (u = r[i.type]) === null || u === void 0 ? void 0 : u.discreteBandSize
+        } : (c = r[i.type]) == null ? void 0 : c.continuousBandSize : (f = r[i.type]) == null ? void 0 : f.discreteBandSize
     }
 
-    function f6(e, t, n, i) {
-        return lt(e.bin) || e.timeUnit && Ui(e) && e.type === "temporal" ? u6({
+    function k6(e, t, n, i) {
+        return ot(e.bin) || e.timeUnit && zn(e) && e.type === "temporal" ? E6({
             fieldDef: e,
             fieldDef2: t,
             markDef: n,
             config: i
         }) !== void 0 : !1
     }
 
-    function ty(e) {
+    function A6(e) {
+        return e && !!e.sort && !e.field
+    }
+
+    function L1(e) {
         return e && "condition" in e
     }
 
-    function ny(e) {
+    function I1(e) {
         const t = e == null ? void 0 : e.condition;
-        return !!t && !q(t) && J(t)
+        return !!t && !W(t) && K(t)
     }
 
-    function Vd(e) {
+    function Dd(e) {
         const t = e == null ? void 0 : e.condition;
-        return !!t && !q(t) && Ee(t)
+        return !!t && !W(t) && Ce(t)
     }
 
-    function Wde(e) {
+    function Khe(e) {
         const t = e == null ? void 0 : e.condition;
-        return !!t && (q(t) || wr(t))
+        return !!t && (W(t) || gr(t))
     }
 
-    function J(e) {
+    function K(e) {
         return e && (!!e.field || e.aggregate === "count")
     }
 
-    function gc(e) {
+    function rc(e) {
         return e == null ? void 0 : e.type
     }
 
-    function _a(e) {
+    function fs(e) {
         return e && "datum" in e
     }
 
-    function Ur(e) {
-        return Ui(e) && !am(e) || Ox(e)
+    function _a(e) {
+        return zn(e) && !j0(e) || B0(e)
     }
 
-    function Ox(e) {
-        return _a(e) && tt(e.datum)
+    function z5(e) {
+        return zn(e) && e.type === "quantitative" && !e.bin || B0(e)
     }
 
-    function Ee(e) {
-        return J(e) || _a(e)
+    function B0(e) {
+        return fs(e) && Ze(e.datum)
     }
 
-    function Ui(e) {
+    function Ce(e) {
+        return K(e) || fs(e)
+    }
+
+    function zn(e) {
         return e && ("field" in e || e.aggregate === "count") && "type" in e
     }
 
-    function wr(e) {
+    function gr(e) {
         return e && "value" in e && "value" in e
     }
 
-    function Vl(e) {
+    function Il(e) {
         return e && ("scale" in e || "sort" in e)
     }
 
-    function pc(e) {
+    function sc(e) {
         return e && ("axis" in e || "stack" in e || "impute" in e)
     }
 
-    function h6(e) {
+    function $6(e) {
         return e && "legend" in e
     }
 
-    function d6(e) {
+    function T6(e) {
         return e && ("format" in e || "formatType" in e)
     }
 
-    function Hde(e) {
-        return Zn(e, ["legend", "axis", "header", "scale"])
+    function Jhe(e) {
+        return Jn(e, ["legend", "axis", "header", "scale"])
     }
 
-    function Yde(e) {
+    function Qhe(e) {
         return "op" in e
     }
 
-    function ne(e, t = {}) {
-        var n, i, r;
-        let a = e.field;
-        const s = t.prefix;
-        let o = t.suffix,
-            l = "";
-        if (Vde(e)) a = sj("count");
+    function ie(e, t = {}) {
+        let n = e.field;
+        const i = t.prefix;
+        let r = t.suffix,
+            s = "";
+        if (ede(e)) n = vI("count");
         else {
-            let u;
+            let a;
             if (!t.nofn)
-                if (Yde(e)) u = e.op;
+                if (Qhe(e)) a = e.op;
                 else {
                     const {
-                        bin: c,
-                        aggregate: f,
-                        timeUnit: h
+                        bin: o,
+                        aggregate: l,
+                        timeUnit: u
                     } = e;
-                    lt(c) ? (u = xj(c), o = ((n = t.binSuffix) !== null && n !== void 0 ? n : "") + ((i = t.suffix) !== null && i !== void 0 ? i : "")) : f ? xo(f) ? (l = `["${a}"]`, a = `argmax_${f.argmax}`) : Va(f) ? (l = `["${a}"]`, a = `argmin_${f.argmin}`) : u = String(f) : h && (u = Zhe(h), o = (!["range", "mid"].includes(t.binSuffix) && t.binSuffix || "") + ((r = t.suffix) !== null && r !== void 0 ? r : ""))
-                } u && (a = a ? `${u}_${a}` : u)
+                    ot(o) ? (a = DI(o), r = (t.binSuffix ?? "") + (t.suffix ?? "")) : l ? oo(l) ? (s = `["${n}"]`, n = `argmax_${l.argmax}`) : Bs(l) ? (s = `["${n}"]`, n = `argmin_${l.argmin}`) : a = String(l) : u && (a = she(u), r = (!["range", "mid"].includes(t.binSuffix) && t.binSuffix || "") + (t.suffix ?? ""))
+                } a && (n = n ? `${a}_${n}` : a)
         }
-        return o && (a = `${a}_${o}`), s && (a = `${s}_${a}`), t.forAs ? iO(a) : t.expr ? ij(a, t.expr) + l : Bi(a) + l
+        return r && (n = `${n}_${r}`), i && (n = `${i}_${n}`), t.forAs ? SE(n) : t.expr ? pI(n, t.expr) + s : Pi(n) + s
     }
 
-    function am(e) {
+    function j0(e) {
         switch (e.type) {
             case "nominal":
             case "ordinal":
             case "geojson":
                 return !0;
             case "quantitative":
-                return J(e) && !!e.bin;
+                return K(e) && !!e.bin;
             case "temporal":
                 return !1
         }
-        throw new Error($j(e.type))
+        throw new Error(WI(e.type))
     }
 
-    function Xde(e) {
+    function Zhe(e) {
         var t;
-        return Vl(e) && dc((t = e.scale) === null || t === void 0 ? void 0 : t.type)
+        return Il(e) && ic((t = e.scale) == null ? void 0 : t.type)
     }
 
-    function Vde(e) {
+    function ede(e) {
         return e.aggregate === "count"
     }
 
-    function Kde(e, t) {
-        var n;
+    function tde(e, t) {
+        var a;
         const {
-            field: i,
-            bin: r,
-            timeUnit: a,
+            field: n,
+            bin: i,
+            timeUnit: r,
             aggregate: s
         } = e;
         if (s === "count") return t.countTitle;
-        if (lt(r)) return `${i} (binned)`;
-        if (a) {
-            const o = (n = En(a)) === null || n === void 0 ? void 0 : n.unit;
-            if (o) return `${i} (${yO(o).join("-")})`
-        } else if (s) return xo(s) ? `${i} for max ${s.argmax}` : Va(s) ? `${i} for min ${s.argmin}` : `${zd(s)} of ${i}`;
-        return i
+        if (ot(i)) return `${n} (binned)`;
+        if (r) {
+            const o = (a = en(r)) == null ? void 0 : a.unit;
+            if (o) return `${n} (${M1(o).join("-")})`
+        } else if (s) return oo(s) ? `${n} for max ${s.argmax}` : Bs(s) ? `${n} for min ${s.argmin}` : `${$d(s)} of ${n}`;
+        return n
     }
 
-    function Jde(e) {
+    function nde(e) {
         const {
             aggregate: t,
             bin: n,
             timeUnit: i,
             field: r
         } = e;
-        if (xo(t)) return `${r} for argmax(${t.argmax})`;
-        if (Va(t)) return `${r} for argmin(${t.argmin})`;
-        const a = En(i),
-            s = t || (a == null ? void 0 : a.unit) || (a == null ? void 0 : a.maxbins) && "timeunit" || lt(n) && "bin";
-        return s ? `${s.toUpperCase()}(${r})` : r
+        if (oo(t)) return `${r} for argmax(${t.argmax})`;
+        if (Bs(t)) return `${r} for argmin(${t.argmin})`;
+        const s = en(i),
+            a = t || (s == null ? void 0 : s.unit) || (s == null ? void 0 : s.maxbins) && "timeunit" || ot(n) && "bin";
+        return a ? `${a.toUpperCase()}(${r})` : r
     }
-    const g6 = (e, t) => {
+    const M6 = (e, t) => {
         switch (t.fieldTitle) {
             case "plain":
                 return e.field;
             case "functional":
-                return Jde(e);
+                return nde(e);
             default:
-                return Kde(e, t)
+                return tde(e, t)
         }
     };
-    let p6 = g6;
+    let O6 = M6;
 
-    function m6(e) {
-        p6 = e
+    function F6(e) {
+        O6 = e
     }
 
-    function Qde() {
-        m6(g6)
+    function ide() {
+        F6(M6)
     }
 
-    function Lu(e, t, {
+    function ku(e, t, {
         allowDisabling: n,
         includeDefault: i = !0
     }) {
-        var r, a;
-        const s = (r = LO(e)) === null || r === void 0 ? void 0 : r.title;
-        if (!J(e)) return s ?? e.title;
-        const o = e,
-            l = i ? IO(o, t) : void 0;
-        return n ? Tt(s, o.title, l) : (a = s ?? o.title) !== null && a !== void 0 ? a : l
+        var o;
+        const r = (o = nC(e)) == null ? void 0 : o.title;
+        if (!K(e)) return r ?? e.title;
+        const s = e,
+            a = i ? iC(s, t) : void 0;
+        return n ? Ct(r, s.title, a) : r ?? s.title ?? a
     }
 
-    function LO(e) {
-        if (pc(e) && e.axis) return e.axis;
-        if (h6(e) && e.legend) return e.legend;
-        if (PO(e) && e.header) return e.header
+    function nC(e) {
+        if (sc(e) && e.axis) return e.axis;
+        if ($6(e) && e.legend) return e.legend;
+        if (eC(e) && e.header) return e.header
     }
 
-    function IO(e, t) {
-        return p6(e, t)
+    function iC(e, t) {
+        return O6(e, t)
     }
 
-    function sm(e) {
-        var t;
-        if (d6(e)) {
+    function U0(e) {
+        if (T6(e)) {
             const {
-                format: n,
-                formatType: i
+                format: t,
+                formatType: n
             } = e;
             return {
-                format: n,
-                formatType: i
+                format: t,
+                formatType: n
             }
         } else {
-            const n = (t = LO(e)) !== null && t !== void 0 ? t : {},
+            const t = nC(e) ?? {},
                 {
-                    format: i,
-                    formatType: r
-                } = n;
+                    format: n,
+                    formatType: i
+                } = t;
             return {
-                format: i,
-                formatType: r
+                format: n,
+                formatType: i
             }
         }
     }
 
-    function Zde(e, t) {
-        var n;
+    function rde(e, t) {
+        var s;
         switch (t) {
             case "latitude":
             case "longitude":
                 return "quantitative";
             case "row":
             case "column":
             case "facet":
             case "shape":
             case "strokeDash":
                 return "nominal";
             case "order":
                 return "ordinal"
         }
-        if (NO(e) && q(e.sort)) return "ordinal";
+        if (tC(e) && W(e.sort)) return "ordinal";
         const {
-            aggregate: i,
-            bin: r,
-            timeUnit: a
+            aggregate: n,
+            bin: i,
+            timeUnit: r
         } = e;
-        if (a) return "temporal";
-        if (r || i && !xo(i) && !Va(i)) return "quantitative";
-        if (Vl(e) && (!((n = e.scale) === null || n === void 0) && n.type)) switch (_x[e.scale.type]) {
+        if (r) return "temporal";
+        if (i || n && !oo(n) && !Bs(n)) return "quantitative";
+        if (Il(e) && ((s = e.scale) != null && s.type)) switch (X2[e.scale.type]) {
             case "numeric":
             case "discretizing":
                 return "quantitative";
             case "time":
                 return "temporal"
         }
         return "nominal"
     }
 
-    function ia(e) {
-        if (J(e)) return e;
-        if (ny(e)) return e.condition
+    function Kr(e) {
+        if (K(e)) return e;
+        if (I1(e)) return e.condition
     }
 
-    function Rt(e) {
-        if (Ee(e)) return e;
-        if (Vd(e)) return e.condition
+    function Mt(e) {
+        if (Ce(e)) return e;
+        if (Dd(e)) return e.condition
     }
 
-    function y6(e, t, n, i = {}) {
-        if (re(e) || tt(e) || co(e)) {
-            const r = re(e) ? "string" : tt(e) ? "number" : "boolean";
-            return X(ehe(t, r, e)), {
+    function R6(e, t, n, i = {}) {
+        if (re(e) || Ze(e) || Za(e)) {
+            const r = re(e) ? "string" : Ze(e) ? "number" : "boolean";
+            return X(afe(t, r, e)), {
                 value: e
             }
         }
-        return Ee(e) ? om(e, t, n, i) : Vd(e) ? Object.assign(Object.assign({}, e), {
-            condition: om(e.condition, t, n, i)
-        }) : e
+        return Ce(e) ? G0(e, t, n, i) : Dd(e) ? {
+            ...e,
+            condition: G0(e.condition, t, n, i)
+        } : e
     }
 
-    function om(e, t, n, i) {
-        if (d6(e)) {
+    function G0(e, t, n, i) {
+        if (T6(e)) {
             const {
                 format: r,
-                formatType: a
-            } = e, s = Ex(e, ["format", "formatType"]);
-            if (Ol(a) && !n.customFormatTypes) return X(y$(t)), om(s, t, n, i)
+                formatType: s,
+                ...a
+            } = e;
+            if (gl(s) && !n.customFormatTypes) return X(O5(t)), G0(a, t, n, i)
         } else {
-            const r = pc(e) ? "axis" : h6(e) ? "legend" : PO(e) ? "header" : null;
+            const r = sc(e) ? "axis" : $6(e) ? "legend" : eC(e) ? "header" : null;
             if (r && e[r]) {
-                const a = e[r],
-                    {
-                        format: s,
-                        formatType: o
-                    } = a,
-                    l = Ex(a, ["format", "formatType"]);
-                if (Ol(o) && !n.customFormatTypes) return X(y$(t)), om(Object.assign(Object.assign({}, e), {
-                    [r]: l
-                }), t, n, i)
+                const {
+                    format: s,
+                    formatType: a,
+                    ...o
+                } = e[r];
+                if (gl(a) && !n.customFormatTypes) return X(O5(t)), G0({
+                    ...e,
+                    [r]: o
+                }, t, n, i)
             }
         }
-        return J(e) ? jO(e, t, i) : ege(e)
+        return K(e) ? rC(e, t, i) : sde(e)
     }
 
-    function ege(e) {
+    function sde(e) {
         let t = e.type;
         if (t) return e;
         const {
             datum: n
         } = e;
-        return t = tt(n) ? "quantitative" : re(n) ? "nominal" : Xl(n) ? "temporal" : void 0, Object.assign(Object.assign({}, e), {
+        return t = Ze(n) ? "quantitative" : re(n) ? "nominal" : Ll(n) ? "temporal" : void 0, {
+            ...e,
             type: t
-        })
+        }
     }
 
-    function jO(e, t, {
+    function rC(e, t, {
         compositeMark: n = !1
     } = {}) {
         const {
             aggregate: i,
             timeUnit: r,
-            bin: a,
-            field: s
-        } = e, o = Object.assign({}, e);
-        if (!n && i && !cO(i) && !xo(i) && !Va(i) && (X(nhe(i)), delete o.aggregate), r && (o.timeUnit = En(r)), s && (o.field = `${s}`), lt(a) && (o.bin = iy(a, t)), Qt(a) && !Xt(t) && X(Phe(t)), Ui(o)) {
+            bin: s,
+            field: a
+        } = e, o = {
+            ...e
+        };
+        if (!n && i && !OE(i) && !oo(i) && !Bs(i) && (X(lfe(i)), delete o.aggregate), r && (o.timeUnit = en(r)), a && (o.field = `${a}`), ot(s) && (o.bin = z1(s, t)), Xt(s) && !Wt(t) && X(jfe(t)), zn(o)) {
             const {
                 type: l
-            } = o, u = ade(l);
-            l !== u && (o.type = u), l !== "quantitative" && bj(i) && (X(the(l, i)), o.type = "quantitative")
-        } else if (!hj(t)) {
-            const l = Zde(o, t);
+            } = o, u = fhe(l);
+            l !== u && (o.type = u), l !== "quantitative" && RI(i) && (X(ofe(l, i)), o.type = "quantitative")
+        } else if (!kI(t)) {
+            const l = rde(o, t);
             o.type = l
         }
-        if (Ui(o)) {
+        if (zn(o)) {
             const {
                 compatible: l,
                 warning: u
-            } = tge(o, t) || {};
+            } = ade(o, t) || {};
             l === !1 && X(u)
         }
-        if (NO(o) && re(o.sort)) {
+        if (tC(o) && re(o.sort)) {
             const {
                 sort: l
             } = o;
-            if (S$(l)) return Object.assign(Object.assign({}, o), {
+            if (L5(l)) return {
+                ...o,
                 sort: {
                     encoding: l
                 }
-            });
+            };
             const u = l.substr(1);
-            if (l.charAt(0) === "-" && S$(u)) return Object.assign(Object.assign({}, o), {
+            if (l.charAt(0) === "-" && L5(u)) return {
+                ...o,
                 sort: {
                     encoding: u,
                     order: "descending"
                 }
-            })
+            }
         }
-        if (PO(o)) {
+        if (eC(o)) {
             const {
                 header: l
             } = o;
             if (l) {
                 const {
-                    orient: u
-                } = l, c = Ex(l, ["orient"]);
-                if (u) return Object.assign(Object.assign({}, o), {
-                    header: Object.assign(Object.assign({}, c), {
+                    orient: u,
+                    ...c
+                } = l;
+                if (u) return {
+                    ...o,
+                    header: {
+                        ...c,
                         labelOrient: l.labelOrient || u,
                         titleOrient: l.titleOrient || u
-                    })
-                })
+                    }
+                }
             }
         }
         return o
     }
 
-    function iy(e, t) {
-        return co(e) ? {
-            maxbins: l$(t)
+    function z1(e, t) {
+        return Za(e) ? {
+            maxbins: w5(t)
         } : e === "binned" ? {
             binned: !0
-        } : !e.maxbins && !e.step ? Object.assign(Object.assign({}, e), {
-            maxbins: l$(t)
-        }) : e
+        } : !e.maxbins && !e.step ? {
+            ...e,
+            maxbins: w5(t)
+        } : e
     }
-    const fu = {
+    const eu = {
         compatible: !0
     };
 
-    function tge(e, t) {
+    function ade(e, t) {
         const n = e.type;
         if (n === "geojson" && t !== "shape") return {
             compatible: !1,
             warning: `Channel ${t} should not be used with a geojson data.`
         };
         switch (t) {
-            case Ga:
-            case Ua:
-            case z1:
-                return am(e) ? fu : {
+            case Fs:
+            case Rs:
+            case _1:
+                return j0(e) ? eu : {
                     compatible: !1,
-                    warning: ohe(t)
+                    warning: dfe(t)
                 };
-            case yt:
-            case Yt:
-            case go:
-            case Gc:
-            case oi:
-            case ya:
-            case va:
-            case Gd:
-            case qd:
-            case B1:
-            case _l:
-            case G1:
-            case U1:
-            case Wl:
-            case Wi:
-            case Ar:
-            case q1:
-                return fu;
-            case ma:
-            case Gi:
-            case pa:
-            case Tr:
-                return n !== Sl ? {
+            case ht:
+            case Gt:
+            case no:
+            case Mc:
+            case si:
+            case os:
+            case ls:
+            case Td:
+            case Md:
+            case w1:
+            case ul:
+            case S1:
+            case E1:
+            case Dl:
+            case zi:
+            case _r:
+            case C1:
+                return eu;
+            case Sr:
+            case Li:
+            case wr:
+            case Er:
+                return n !== hl ? {
                     compatible: !1,
                     warning: `Channel ${t} should be used with a quantitative field only, not ${e.type} field.`
-                } : fu;
-            case ss:
-            case po:
-            case mo:
-            case yo:
+                } : eu;
+            case Js:
+            case io:
+            case ro:
+            case so:
+            case Ks:
+            case Vs:
+            case Xs:
+            case xr:
             case as:
-            case rs:
-            case is:
-            case kr:
-            case ga:
                 return n === "nominal" && !e.sort ? {
                     compatible: !1,
                     warning: `Channel ${t} should not be used with an unsorted discrete field.`
-                } : fu;
-            case li:
-            case vo:
-                return !am(e) && !Xde(e) ? {
+                } : eu;
+            case ai:
+            case ao:
+                return !j0(e) && !Zhe(e) ? {
                     compatible: !1,
-                    warning: lhe(t)
-                } : fu;
-            case Ud:
+                    warning: gfe(t)
+                } : eu;
+            case ec:
                 return e.type === "nominal" && !("sort" in e) ? {
                     compatible: !1,
                     warning: "Channel order is inappropriate for nominal field, which has no inherent order."
-                } : fu
+                } : eu
         }
     }
 
-    function mc(e) {
+    function ac(e) {
         const {
             formatType: t
-        } = sm(e);
-        return t === "time" || !t && nge(e)
+        } = U0(e);
+        return t === "time" || !t && ode(e)
     }
 
-    function nge(e) {
-        return e && (e.type === "temporal" || J(e) && !!e.timeUnit)
+    function ode(e) {
+        return e && (e.type === "temporal" || K(e) && !!e.timeUnit)
     }
 
-    function ry(e, {
+    function B1(e, {
         timeUnit: t,
         type: n,
         wrapTime: i,
         undefinedIfExprNotRequired: r
     }) {
-        var a;
-        const s = t && ((a = En(t)) === null || a === void 0 ? void 0 : a.unit);
-        let o = s || n === "temporal",
-            l;
-        return Wd(e) ? l = e.expr : fe(e) ? l = e.signal : Xl(e) ? (o = !0, l = Qh(e)) : (re(e) || tt(e)) && o && (l = `datetime(${ot(e)})`, Xhe(s) && (tt(e) && e < 1e4 || re(e) && isNaN(Date.parse(e))) && (l = Qh({
+        var l;
+        const s = t && ((l = en(t)) == null ? void 0 : l.unit);
+        let a = s || n === "temporal",
+            o;
+        return Fc(e) ? o = e.expr : he(e) ? o = e.signal : Ll(e) ? (a = !0, o = fl(e)) : (re(e) || Ze(e)) && a && (o = `datetime(${at(e)})`, Zfe(s) && (Ze(e) && e < 1e4 || re(e) && isNaN(Date.parse(e))) && (o = fl({
             [s]: e
-        }))), l ? i && o ? `time(${l})` : l : r ? void 0 : ot(e)
+        }))), o ? i && a ? `time(${o})` : o : r ? void 0 : at(e)
     }
 
-    function v6(e, t) {
+    function D6(e, t) {
         const {
             type: n
         } = e;
         return t.map(i => {
-            const r = ry(i, {
-                timeUnit: J(e) ? e.timeUnit : void 0,
+            const r = B1(i, {
+                timeUnit: K(e) ? e.timeUnit : void 0,
                 type: n,
                 undefinedIfExprNotRequired: !0
             });
             return r !== void 0 ? {
                 signal: r
             } : i
         })
     }
 
-    function Kd(e, t) {
-        return lt(e.bin) ? bo(t) && ["ordinal", "nominal"].includes(e.type) : (console.warn("Only call this method for binned field defs."), !1)
+    function Nd(e, t) {
+        return ot(e.bin) ? Qs(t) && ["ordinal", "nominal"].includes(e.type) : (console.warn("Only call this method for binned field defs."), !1)
     }
-    const O$ = {
+    const B5 = {
         labelAlign: {
             part: "labels",
             vgProp: "align"
         },
         labelBaseline: {
             part: "labels",
             vgProp: "baseline"
@@ -39266,19 +39380,19 @@
         tickSize: null,
         tickWidth: {
             part: "ticks",
             vgProp: "strokeWidth"
         }
     };
 
-    function Jd(e) {
+    function Pd(e) {
         return e == null ? void 0 : e.condition
     }
-    const b6 = ["domain", "grid", "labels", "ticks", "title"],
-        ige = {
+    const N6 = ["domain", "grid", "labels", "ticks", "title"],
+        lde = {
             grid: "grid",
             gridCap: "grid",
             gridColor: "grid",
             gridDash: "grid",
             gridDashOffset: "grid",
             gridOpacity: "grid",
             gridScale: "grid",
@@ -39351,15 +39465,15 @@
             tickBand: "both",
             tickCount: "both",
             tickExtra: "both",
             translate: "both",
             values: "both",
             zindex: "both"
         },
-        x6 = {
+        P6 = {
             orient: 1,
             aria: 1,
             bandPosition: 1,
             description: 1,
             domain: 1,
             domainCap: 1,
             domainColor: 1,
@@ -39429,24 +39543,25 @@
             titlePadding: 1,
             titleX: 1,
             titleY: 1,
             translate: 1,
             values: 1,
             zindex: 1
         },
-        rge = Object.assign(Object.assign({}, x6), {
+        ude = {
+            ...P6,
             style: 1,
             labelExpr: 1,
             encoding: 1
-        });
+        };
 
-    function C$(e) {
-        return !!rge[e]
+    function j5(e) {
+        return !!ude[e]
     }
-    const age = {
+    const cde = {
             axis: 1,
             axisBand: 1,
             axisBottom: 1,
             axisDiscrete: 1,
             axisLeft: 1,
             axisPoint: 1,
             axisQuantitative: 1,
@@ -39462,977 +39577,997 @@
             axisY: 1,
             axisYBand: 1,
             axisYDiscrete: 1,
             axisYPoint: 1,
             axisYQuantitative: 1,
             axisYTemporal: 1
         },
-        _6 = Y(age);
+        L6 = H(cde);
 
-    function os(e) {
+    function Zs(e) {
         return "mark" in e
     }
-    class ay {
+    class j1 {
         constructor(t, n) {
             this.name = t, this.run = n
         }
         hasMatchingType(t) {
-            return os(t) ? Pde(t.mark) === this.name : !1
+            return Zs(t) ? Bhe(t.mark) === this.name : !1
         }
     }
-    var sge = globalThis && globalThis.__rest || function(e, t) {
-        var n = {};
-        for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && t.indexOf(i) < 0 && (n[i] = e[i]);
-        if (e != null && typeof Object.getOwnPropertySymbols == "function")
-            for (var r = 0, i = Object.getOwnPropertySymbols(e); r < i.length; r++) t.indexOf(i[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, i[r]) && (n[i[r]] = e[i[r]]);
-        return n
-    };
 
-    function al(e, t) {
+    function Ho(e, t) {
         const n = e && e[t];
-        return n ? q(n) ? bl(n, i => !!i.field) : J(n) || ny(n) : !1
+        return n ? W(n) ? ol(n, i => !!i.field) : K(n) || I1(n) : !1
     }
 
-    function w6(e, t) {
+    function I6(e, t) {
         const n = e && e[t];
-        return n ? q(n) ? bl(n, i => !!i.field) : J(n) || _a(n) || Vd(n) : !1
+        return n ? W(n) ? ol(n, i => !!i.field) : K(n) || fs(n) || Dd(n) : !1
     }
 
-    function Cx(e, t) {
-        if (Xt(t)) {
+    function J2(e, t) {
+        if (Wt(t)) {
             const n = e[t];
-            if ((J(n) || _a(n)) && Uj(n.type)) {
-                const i = dj(t);
-                return w6(e, i)
+            if ((K(n) || fs(n)) && (r6(n.type) || K(n) && n.timeUnit)) {
+                const i = AE(t);
+                return I6(e, i)
             }
         }
         return !1
     }
 
-    function zO(e) {
-        return bl(afe, t => {
-            if (al(e, t)) {
+    function sC(e) {
+        return ol(dce, t => {
+            if (Ho(e, t)) {
                 const n = e[t];
-                if (q(n)) return bl(n, i => !!i.aggregate); {
-                    const i = ia(n);
+                if (W(n)) return ol(n, i => !!i.aggregate); {
+                    const i = Kr(n);
                     return i && !!i.aggregate
                 }
             }
             return !1
         })
     }
 
-    function S6(e, t) {
+    function z6(e, t) {
         const n = [],
             i = [],
             r = [],
-            a = [],
-            s = {};
-        return BO(e, (o, l) => {
-            if (J(o)) {
+            s = [],
+            a = {};
+        return aC(e, (o, l) => {
+            if (K(o)) {
                 const {
                     field: u,
                     aggregate: c,
                     bin: f,
-                    timeUnit: h
-                } = o, d = sge(o, ["field", "aggregate", "bin", "timeUnit"]);
+                    timeUnit: h,
+                    ...d
+                } = o;
                 if (c || h || f) {
-                    const g = LO(o),
+                    const g = nC(o),
                         p = g == null ? void 0 : g.title;
-                    let m = ne(o, {
+                    let m = ie(o, {
                         forAs: !0
                     });
-                    const y = Object.assign(Object.assign(Object.assign({}, p ? [] : {
-                        title: Lu(o, t, {
-                            allowDisabling: !0
-                        })
-                    }), d), {
+                    const y = {
+                        ...p ? [] : {
+                            title: ku(o, t, {
+                                allowDisabling: !0
+                            })
+                        },
+                        ...d,
                         field: m
-                    });
+                    };
                     if (c) {
                         let v;
-                        if (xo(c) ? (v = "argmax", m = ne({
+                        if (oo(c) ? (v = "argmax", m = ie({
                                 op: "argmax",
                                 field: c.argmax
                             }, {
                                 forAs: !0
-                            }), y.field = `${m}.${u}`) : Va(c) ? (v = "argmin", m = ne({
+                            }), y.field = `${m}.${u}`) : Bs(c) ? (v = "argmin", m = ie({
                                 op: "argmin",
                                 field: c.argmin
                             }, {
                                 forAs: !0
                             }), y.field = `${m}.${u}`) : c !== "boxplot" && c !== "errorbar" && c !== "errorband" && (v = c), v) {
                             const b = {
                                 op: v,
                                 as: m
                             };
-                            u && (b.field = u), a.push(b)
+                            u && (b.field = u), s.push(b)
                         }
-                    } else if (n.push(m), Ui(o) && lt(f)) {
+                    } else if (n.push(m), zn(o) && ot(f)) {
                         if (i.push({
                                 bin: f,
                                 field: u,
                                 as: m
-                            }), n.push(ne(o, {
+                            }), n.push(ie(o, {
                                 binSuffix: "end"
-                            })), Kd(o, l) && n.push(ne(o, {
+                            })), Nd(o, l) && n.push(ie(o, {
                                 binSuffix: "range"
-                            })), Xt(l)) {
+                            })), Wt(l)) {
                             const v = {
                                 field: `${m}_end`
                             };
-                            s[`${l}2`] = v
+                            a[`${l}2`] = v
                         }
-                        y.bin = "binned", hj(l) || (y.type = Sl)
+                        y.bin = "binned", kI(l) || (y.type = hl)
                     } else if (h) {
                         r.push({
                             timeUnit: h,
                             field: u,
                             as: m
                         });
-                        const v = Ui(o) && o.type !== hc && "time";
-                        v && (l === Gd || l === _l ? y.formatType = v : pfe(l) ? y.legend = Object.assign({
-                            formatType: v
-                        }, y.legend) : Xt(l) && (y.axis = Object.assign({
-                            formatType: v
-                        }, y.axis)))
-                    }
-                    s[l] = y
-                } else n.push(u), s[l] = e[l]
-            } else s[l] = e[l]
+                        const v = zn(o) && o.type !== nc && "time";
+                        v && (l === Td || l === ul ? y.formatType = v : wce(l) ? y.legend = {
+                            formatType: v,
+                            ...y.legend
+                        } : Wt(l) && (y.axis = {
+                            formatType: v,
+                            ...y.axis
+                        }))
+                    }
+                    a[l] = y
+                } else n.push(u), a[l] = e[l]
+            } else a[l] = e[l]
         }), {
             bins: i,
             timeUnits: r,
-            aggregate: a,
+            aggregate: s,
             groupby: n,
-            encoding: s
+            encoding: a
         }
     }
 
-    function oge(e, t, n) {
-        const i = yfe(t, n);
+    function fde(e, t, n) {
+        const i = Ece(t, n);
         if (i) {
             if (i === "binned") {
-                const r = e[t === kr ? yt : Yt];
-                return !!(J(r) && J(e[t]) && Qt(r.bin))
+                const r = e[t === xr ? ht : Gt];
+                return !!(K(r) && K(e[t]) && Xt(r.bin))
             }
         } else return !1;
         return !0
     }
 
-    function lge(e, t, n, i) {
+    function hde(e, t, n, i) {
         const r = {};
-        for (const a of Y(e)) fj(a) || X(she(a));
-        for (let a of ffe) {
-            if (!e[a]) continue;
-            const s = e[a];
-            if (Uc(a)) {
-                const o = gj(a),
+        for (const s of H(e)) CI(s) || X(hfe(s));
+        for (let s of vce) {
+            if (!e[s]) continue;
+            const a = e[s];
+            if (Oc(s)) {
+                const o = $I(s),
                     l = r[o];
-                if (J(l)) {
-                    if (rde(l.type) && J(s)) {
-                        X(Qfe(o));
+                if (K(l)) {
+                    if (che(l.type) && K(a) && !l.timeUnit) {
+                        X(rfe(o));
                         continue
                     }
-                } else a = o, X(Zfe(o))
+                } else s = o, X(sfe(o))
             }
-            if (a === "angle" && t === "arc" && !e.theta && (X(Jfe), a = Wi), !oge(e, a, t)) {
-                X(X1(a, t));
+            if (s === "angle" && t === "arc" && !e.theta && (X(ife), s = zi), !fde(e, s, t)) {
+                X(T1(s, t));
                 continue
             }
-            if (a === as && t === "line") {
-                const o = ia(e[a]);
+            if (s === Ks && t === "line") {
+                const o = Kr(e[s]);
                 if (o != null && o.aggregate) {
-                    X(rhe);
+                    X(cfe);
                     continue
                 }
             }
-            if (a === oi && (n ? "fill" in e : "stroke" in e)) {
-                X(Mj("encoding", {
+            if (s === si && (n ? "fill" in e : "stroke" in e)) {
+                X(qI("encoding", {
                     fill: "fill" in e,
                     stroke: "stroke" in e
                 }));
                 continue
             }
-            if (a === qd || a === Ud && !q(s) && !wr(s) || a === _l && q(s)) s && (r[a] = ie(s).reduce((o, l) => (J(l) ? o.push(jO(l, a)) : X(xx(l, a)), o), []));
-            else {
-                if (a === _l && s === null) r[a] = null;
-                else if (!J(s) && !_a(s) && !wr(s) && !ty(s) && !fe(s)) {
-                    X(xx(s, a));
+            if (s === Md || s === ec && !W(a) && !gr(a) || s === ul && W(a)) {
+                if (a) {
+                    if (s === ec) {
+                        const o = e[s];
+                        if (A6(o)) {
+                            r[s] = o;
+                            continue
+                        }
+                    }
+                    r[s] = se(a).reduce((o, l) => (K(l) ? o.push(rC(l, s)) : X(Y2(l, s)), o), [])
+                }
+            } else {
+                if (s === ul && a === null) r[s] = null;
+                else if (!K(a) && !fs(a) && !gr(a) && !L1(a) && !he(a)) {
+                    X(Y2(a, s));
                     continue
                 }
-                r[a] = y6(s, a, i)
+                r[s] = R6(a, s, i)
             }
         }
         return r
     }
 
-    function sy(e, t) {
+    function U1(e, t) {
         const n = {};
-        for (const i of Y(e)) {
-            const r = y6(e[i], i, t, {
+        for (const i of H(e)) {
+            const r = R6(e[i], i, t, {
                 compositeMark: !0
             });
             n[i] = r
         }
         return n
     }
 
-    function uge(e) {
+    function dde(e) {
         const t = [];
-        for (const n of Y(e))
-            if (al(e, n)) {
+        for (const n of H(e))
+            if (Ho(e, n)) {
                 const i = e[n],
-                    r = ie(i);
-                for (const a of r) J(a) ? t.push(a) : ny(a) && t.push(a.condition)
+                    r = se(i);
+                for (const s of r) K(s) ? t.push(s) : I1(s) && t.push(s.condition)
             } return t
     }
 
-    function BO(e, t, n) {
+    function aC(e, t, n) {
         if (e)
-            for (const i of Y(e)) {
+            for (const i of H(e)) {
                 const r = e[i];
-                if (q(r))
-                    for (const a of r) t.call(n, a, i);
+                if (W(r))
+                    for (const s of r) t.call(n, s, i);
                 else t.call(n, r, i)
             }
     }
 
-    function cge(e, t, n, i) {
-        return e ? Y(e).reduce((r, a) => {
-            const s = e[a];
-            return q(s) ? s.reduce((o, l) => t.call(i, o, l, a), r) : t.call(i, r, s, a)
+    function gde(e, t, n, i) {
+        return e ? H(e).reduce((r, s) => {
+            const a = e[s];
+            return W(a) ? a.reduce((o, l) => t.call(i, o, l, s), r) : t.call(i, r, a, s)
         }, n) : n
     }
 
-    function E6(e, t) {
-        return Y(t).reduce((n, i) => {
+    function B6(e, t) {
+        return H(t).reduce((n, i) => {
             switch (i) {
-                case yt:
-                case Yt:
-                case G1:
-                case q1:
-                case U1:
-                case kr:
-                case ga:
-                case go:
-                case Gc:
-                case Wi:
-                case rs:
-                case Ar:
-                case is:
-                case pa:
-                case ma:
-                case Tr:
-                case Gi:
-                case Gd:
-                case li:
-                case Wl:
-                case _l:
+                case ht:
+                case Gt:
+                case S1:
+                case C1:
+                case E1:
+                case xr:
+                case as:
+                case no:
+                case Mc:
+                case zi:
+                case Vs:
+                case _r:
+                case Xs:
+                case wr:
+                case Sr:
+                case Er:
+                case Li:
+                case Td:
+                case ai:
+                case Dl:
+                case ul:
                     return n;
-                case Ud:
+                case ec:
                     if (e === "line" || e === "trail") return n;
-                case qd:
-                case B1: {
+                case Md:
+                case w1: {
                     const r = t[i];
-                    if (q(r) || J(r))
-                        for (const a of ie(r)) a.aggregate || n.push(ne(a, {}));
+                    if (W(r) || K(r))
+                        for (const s of se(r)) s.aggregate || n.push(ie(s, {}));
                     return n
                 }
-                case as:
+                case Ks:
                     if (e === "trail") return n;
-                case oi:
-                case ya:
-                case va:
-                case ss:
-                case po:
-                case mo:
-                case vo:
-                case yo: {
-                    const r = ia(t[i]);
-                    return r && !r.aggregate && n.push(ne(r, {})), n
+                case si:
+                case os:
+                case ls:
+                case Js:
+                case io:
+                case ro:
+                case ao:
+                case so: {
+                    const r = Kr(t[i]);
+                    return r && !r.aggregate && n.push(ie(r, {})), n
                 }
             }
         }, [])
     }
-    var O6 = globalThis && globalThis.__rest || function(e, t) {
-        var n = {};
-        for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && t.indexOf(i) < 0 && (n[i] = e[i]);
-        if (e != null && typeof Object.getOwnPropertySymbols == "function")
-            for (var r = 0, i = Object.getOwnPropertySymbols(e); r < i.length; r++) t.indexOf(i[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, i[r]) && (n[i[r]] = e[i[r]]);
-        return n
-    };
 
-    function fge(e) {
+    function pde(e) {
         const {
-            tooltip: t
-        } = e, n = O6(e, ["tooltip"]);
+            tooltip: t,
+            ...n
+        } = e;
         if (!t) return {
             filteredEncoding: n
         };
         let i, r;
-        if (q(t)) {
-            for (const a of t) a.aggregate ? (i || (i = []), i.push(a)) : (r || (r = []), r.push(a));
+        if (W(t)) {
+            for (const s of t) s.aggregate ? (i || (i = []), i.push(s)) : (r || (r = []), r.push(s));
             i && (n.tooltip = i)
         } else t.aggregate ? n.tooltip = t : r = t;
-        return q(r) && r.length === 1 && (r = r[0]), {
+        return W(r) && r.length === 1 && (r = r[0]), {
             customTooltipWithoutAggregatedField: r,
             filteredEncoding: n
         }
     }
 
-    function kx(e, t, n, i = !0) {
+    function Q2(e, t, n, i = !0) {
         if ("tooltip" in n) return {
             tooltip: n.tooltip
         };
         const r = e.map(({
-                fieldPrefix: s,
+                fieldPrefix: a,
                 titlePrefix: o
             }) => {
-                const l = i ? ` of ${GO(t)}` : "";
+                const l = i ? ` of ${oC(t)}` : "";
                 return {
-                    field: s + t.field,
+                    field: a + t.field,
                     type: t.type,
-                    title: fe(o) ? {
+                    title: he(o) ? {
                         signal: `${o}"${escape(l)}"`
                     } : o + l
                 }
             }),
-            a = uge(n).map(Hde);
+            s = dde(n).map(Jhe);
         return {
-            tooltip: [...r, ...Gr(a, Ie)]
+            tooltip: [...r, ...Pr(s, Ne)]
         }
     }
 
-    function GO(e) {
+    function oC(e) {
         const {
             title: t,
             field: n
         } = e;
-        return Tt(t, n)
+        return Ct(t, n)
     }
 
-    function UO(e, t, n, i, r) {
+    function lC(e, t, n, i, r) {
         const {
-            scale: a,
-            axis: s
+            scale: s,
+            axis: a
         } = n;
         return ({
             partName: o,
             mark: l,
             positionPrefix: u,
             endPositionPrefix: c = void 0,
             extraEncoding: f = {}
         }) => {
-            const h = GO(n);
-            return C6(e, o, r, {
+            const h = oC(n);
+            return j6(e, o, r, {
                 mark: l,
-                encoding: Object.assign(Object.assign(Object.assign({
-                    [t]: Object.assign(Object.assign(Object.assign({
+                encoding: {
+                    [t]: {
                         field: `${u}_${n.field}`,
-                        type: n.type
-                    }, h !== void 0 ? {
-                        title: h
-                    } : {}), a !== void 0 ? {
-                        scale: a
-                    } : {}), s !== void 0 ? {
-                        axis: s
-                    } : {})
-                }, re(c) ? {
-                    [`${t}2`]: {
-                        field: `${c}_${n.field}`
-                    }
-                } : {}), i), f)
+                        type: n.type,
+                        ...h !== void 0 ? {
+                            title: h
+                        } : {},
+                        ...s !== void 0 ? {
+                            scale: s
+                        } : {},
+                        ...a !== void 0 ? {
+                            axis: a
+                        } : {}
+                    },
+                    ...re(c) ? {
+                        [`${t}2`]: {
+                            field: `${c}_${n.field}`
+                        }
+                    } : {},
+                    ...i,
+                    ...f
+                }
             })
         }
     }
 
-    function C6(e, t, n, i) {
+    function j6(e, t, n, i) {
         const {
             clip: r,
-            color: a,
-            opacity: s
+            color: s,
+            opacity: a
         } = e, o = e.type;
-        return e[t] || e[t] === void 0 && n[t] ? [Object.assign(Object.assign({}, i), {
-            mark: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, n[t]), r ? {
-                clip: r
-            } : {}), a ? {
-                color: a
-            } : {}), s ? {
-                opacity: s
-            } : {}), na(i.mark) ? i.mark : {
-                type: i.mark
-            }), {
-                style: `${o}-${String(t)}`
-            }), co(e[t]) ? {} : e[t])
-        })] : []
+        return e[t] || e[t] === void 0 && n[t] ? [{
+            ...i,
+            mark: {
+                ...n[t],
+                ...r ? {
+                    clip: r
+                } : {},
+                ...s ? {
+                    color: s
+                } : {},
+                ...a ? {
+                    opacity: a
+                } : {},
+                ...Vr(i.mark) ? i.mark : {
+                    type: i.mark
+                },
+                style: `${o}-${String(t)}`,
+                ...Za(e[t]) ? {} : e[t]
+            }
+        }] : []
     }
 
-    function k6(e, t, n) {
+    function U6(e, t, n) {
         const {
             encoding: i
-        } = e, r = t === "vertical" ? "y" : "x", a = i[r], s = i[`${r}2`], o = i[`${r}Error`], l = i[`${r}Error2`];
+        } = e, r = t === "vertical" ? "y" : "x", s = i[r], a = i[`${r}2`], o = i[`${r}Error`], l = i[`${r}Error2`];
         return {
-            continuousAxisChannelDef: Ug(a, n),
-            continuousAxisChannelDef2: Ug(s, n),
-            continuousAxisChannelDefError: Ug(o, n),
-            continuousAxisChannelDefError2: Ug(l, n),
+            continuousAxisChannelDef: $g(s, n),
+            continuousAxisChannelDef2: $g(a, n),
+            continuousAxisChannelDefError: $g(o, n),
+            continuousAxisChannelDefError2: $g(l, n),
             continuousAxis: r
         }
     }
 
-    function Ug(e, t) {
+    function $g(e, t) {
         if (e != null && e.aggregate) {
             const {
-                aggregate: n
-            } = e, i = O6(e, ["aggregate"]);
-            return n !== t && X(Rhe(n, t)), i
+                aggregate: n,
+                ...i
+            } = e;
+            return n !== t && X(Bfe(n, t)), i
         } else return e
     }
 
-    function A6(e, t) {
+    function G6(e, t) {
         const {
             mark: n,
             encoding: i
         } = e, {
             x: r,
-            y: a
+            y: s
         } = i;
-        if (na(n) && n.orient) return n.orient;
-        if (Ur(r)) {
-            if (Ur(a)) {
-                const s = J(r) && r.aggregate,
-                    o = J(a) && a.aggregate;
-                if (!s && o === t) return "vertical";
-                if (!o && s === t) return "horizontal";
-                if (s === t && o === t) throw new Error("Both x and y cannot have aggregate");
-                return mc(a) && !mc(r) ? "horizontal" : "vertical"
+        if (Vr(n) && n.orient) return n.orient;
+        if (_a(r)) {
+            if (_a(s)) {
+                const a = K(r) && r.aggregate,
+                    o = K(s) && s.aggregate;
+                if (!a && o === t) return "vertical";
+                if (!o && a === t) return "horizontal";
+                if (a === t && o === t) throw new Error("Both x and y cannot have aggregate");
+                return ac(s) && !ac(r) ? "horizontal" : "vertical"
             }
             return "horizontal"
         } else {
-            if (Ur(a)) return "vertical";
+            if (_a(s)) return "vertical";
             throw new Error(`Need a valid continuous axis for ${t}s`)
         }
     }
-    var Dp = globalThis && globalThis.__rest || function(e, t) {
-        var n = {};
-        for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && t.indexOf(i) < 0 && (n[i] = e[i]);
-        if (e != null && typeof Object.getOwnPropertySymbols == "function")
-            for (var r = 0, i = Object.getOwnPropertySymbols(e); r < i.length; r++) t.indexOf(i[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, i[r]) && (n[i[r]] = e[i[r]]);
-        return n
-    };
-    const lm = "boxplot",
-        hge = ["box", "median", "outliers", "rule", "ticks"],
-        dge = new ay(lm, $6);
+    const W0 = "boxplot",
+        mde = ["box", "median", "outliers", "rule", "ticks"],
+        yde = new j1(W0, q6);
 
-    function T6(e) {
-        return tt(e) ? "tukey" : e
+    function W6(e) {
+        return Ze(e) ? "tukey" : e
     }
 
-    function $6(e, {
+    function q6(e, {
         config: t
     }) {
-        var n, i;
-        e = Object.assign(Object.assign({}, e), {
-            encoding: sy(e.encoding, t)
-        });
+        e = {
+            ...e,
+            encoding: U1(e.encoding, t)
+        };
         const {
-            mark: r,
-            encoding: a,
-            params: s,
-            projection: o
-        } = e, l = Dp(e, ["mark", "encoding", "params", "projection"]), u = na(r) ? r : {
-            type: r
-        };
-        s && X(Tj("boxplot"));
-        const c = (n = u.extent) !== null && n !== void 0 ? n : t.boxplot.extent,
-            f = Ve("size", u, t),
-            h = u.invalid,
-            d = T6(c),
+            mark: n,
+            encoding: i,
+            params: r,
+            projection: s,
+            ...a
+        } = e, o = Vr(n) ? n : {
+            type: n
+        };
+        r && X(GI("boxplot"));
+        const l = o.extent ?? t.boxplot.extent,
+            u = Xe("size", o, t),
+            c = o.invalid,
+            f = W6(l),
             {
-                bins: g,
-                timeUnits: p,
-                transform: m,
-                continuousAxisChannelDef: y,
-                continuousAxis: v,
-                groupby: b,
-                aggregate: x,
-                encodingWithoutContinuousAxis: _,
-                ticksOrient: S,
-                boxOrient: w,
-                customTooltipWithoutAggregatedField: O
-            } = gge(e, c, t),
+                bins: h,
+                timeUnits: d,
+                transform: g,
+                continuousAxisChannelDef: p,
+                continuousAxis: m,
+                groupby: y,
+                aggregate: v,
+                encodingWithoutContinuousAxis: b,
+                ticksOrient: x,
+                boxOrient: _,
+                customTooltipWithoutAggregatedField: S
+            } = vde(e, l, t),
             {
-                color: k,
-                size: C
-            } = _,
-            E = Dp(_, ["color", "size"]),
-            T = Oi => UO(u, v, y, Oi, t.boxplot),
-            A = T(E),
-            F = T(_),
-            $ = T(Object.assign(Object.assign({}, E), C ? {
-                size: C
-            } : {})),
-            D = kx([{
-                fieldPrefix: d === "min-max" ? "upper_whisker_" : "max_",
+                color: w,
+                size: E,
+                ...A
+            } = b,
+            C = Sn => lC(o, m, p, Sn, t.boxplot),
+            k = C(A),
+            R = C(b),
+            $ = C({
+                ...A,
+                ...E ? {
+                    size: E
+                } : {}
+            }),
+            T = Q2([{
+                fieldPrefix: f === "min-max" ? "upper_whisker_" : "max_",
                 titlePrefix: "Max"
             }, {
                 fieldPrefix: "upper_box_",
                 titlePrefix: "Q3"
             }, {
                 fieldPrefix: "mid_box_",
                 titlePrefix: "Median"
             }, {
                 fieldPrefix: "lower_box_",
                 titlePrefix: "Q1"
             }, {
-                fieldPrefix: d === "min-max" ? "lower_whisker_" : "min_",
+                fieldPrefix: f === "min-max" ? "lower_whisker_" : "min_",
                 titlePrefix: "Min"
-            }], y, _),
-            P = {
+            }], p, b),
+            M = {
                 type: "tick",
                 color: "black",
                 opacity: 1,
-                orient: S,
-                invalid: h,
+                orient: x,
+                invalid: c,
                 aria: !1
             },
-            N = d === "min-max" ? D : kx([{
+            F = f === "min-max" ? T : Q2([{
                 fieldPrefix: "upper_whisker_",
                 titlePrefix: "Upper Whisker"
             }, {
                 fieldPrefix: "lower_whisker_",
                 titlePrefix: "Lower Whisker"
-            }], y, _),
-            z = [...A({
+            }], p, b),
+            N = [...k({
                 partName: "rule",
                 mark: {
                     type: "rule",
-                    invalid: h,
+                    invalid: c,
                     aria: !1
                 },
                 positionPrefix: "lower_whisker",
                 endPositionPrefix: "lower_box",
-                extraEncoding: N
-            }), ...A({
+                extraEncoding: F
+            }), ...k({
                 partName: "rule",
                 mark: {
                     type: "rule",
-                    invalid: h,
+                    invalid: c,
                     aria: !1
                 },
                 positionPrefix: "upper_box",
                 endPositionPrefix: "upper_whisker",
-                extraEncoding: N
-            }), ...A({
+                extraEncoding: F
+            }), ...k({
                 partName: "ticks",
-                mark: P,
+                mark: M,
                 positionPrefix: "lower_whisker",
-                extraEncoding: N
-            }), ...A({
+                extraEncoding: F
+            }), ...k({
                 partName: "ticks",
-                mark: P,
+                mark: M,
                 positionPrefix: "upper_whisker",
-                extraEncoding: N
+                extraEncoding: F
             })],
-            I = [...d !== "tukey" ? z : [], ...F({
+            P = [...f !== "tukey" ? N : [], ...R({
                 partName: "box",
-                mark: Object.assign(Object.assign({
-                    type: "bar"
-                }, f ? {
-                    size: f
-                } : {}), {
-                    orient: w,
-                    invalid: h,
+                mark: {
+                    type: "bar",
+                    ...u ? {
+                        size: u
+                    } : {},
+                    orient: _,
+                    invalid: c,
                     ariaRoleDescription: "box"
-                }),
+                },
                 positionPrefix: "lower_box",
                 endPositionPrefix: "upper_box",
-                extraEncoding: D
+                extraEncoding: T
             }), ...$({
                 partName: "median",
-                mark: Object.assign(Object.assign(Object.assign({
+                mark: {
                     type: "tick",
-                    invalid: h
-                }, se(t.boxplot.median) && t.boxplot.median.color ? {
-                    color: t.boxplot.median.color
-                } : {}), f ? {
-                    size: f
-                } : {}), {
-                    orient: S,
+                    invalid: c,
+                    ...ae(t.boxplot.median) && t.boxplot.median.color ? {
+                        color: t.boxplot.median.color
+                    } : {},
+                    ...u ? {
+                        size: u
+                    } : {},
+                    orient: x,
                     aria: !1
-                }),
+                },
                 positionPrefix: "mid_box",
-                extraEncoding: D
+                extraEncoding: T
             })];
-        if (d === "min-max") return Object.assign(Object.assign({}, l), {
-            transform: ((i = l.transform) !== null && i !== void 0 ? i : []).concat(m),
-            layer: I
-        });
-        const ae = `datum["lower_box_${y.field}"]`,
-            ye = `datum["upper_box_${y.field}"]`,
-            we = `(${ye} - ${ae})`,
-            $e = `${ae} - ${c} * ${we}`,
-            Oe = `${ye} + ${c} * ${we}`,
-            Ye = `datum["${y.field}"]`,
-            St = {
-                joinaggregate: M6(y.field),
-                groupby: b
+        if (f === "min-max") return {
+            ...a,
+            transform: (a.transform ?? []).concat(g),
+            layer: P
+        };
+        const z = `datum["lower_box_${p.field}"]`,
+            I = `datum["upper_box_${p.field}"]`,
+            Q = `(${I} - ${z})`,
+            oe = `${z} - ${l} * ${Q}`,
+            Se = `${I} + ${l} * ${Q}`,
+            ye = `datum["${p.field}"]`,
+            Pe = {
+                joinaggregate: H6(p.field),
+                groupby: y
             },
-            dt = {
+            xt = {
                 transform: [{
-                    filter: `(${$e} <= ${Ye}) && (${Ye} <= ${Oe})`
+                    filter: `(${oe} <= ${ye}) && (${ye} <= ${Se})`
                 }, {
                     aggregate: [{
                         op: "min",
-                        field: y.field,
-                        as: `lower_whisker_${y.field}`
+                        field: p.field,
+                        as: `lower_whisker_${p.field}`
                     }, {
                         op: "max",
-                        field: y.field,
-                        as: `upper_whisker_${y.field}`
+                        field: p.field,
+                        as: `upper_whisker_${p.field}`
                     }, {
                         op: "min",
-                        field: `lower_box_${y.field}`,
-                        as: `lower_box_${y.field}`
+                        field: `lower_box_${p.field}`,
+                        as: `lower_box_${p.field}`
                     }, {
                         op: "max",
-                        field: `upper_box_${y.field}`,
-                        as: `upper_box_${y.field}`
-                    }, ...x],
-                    groupby: b
+                        field: `upper_box_${p.field}`,
+                        as: `upper_box_${p.field}`
+                    }, ...v],
+                    groupby: y
                 }],
-                layer: z
+                layer: N
             },
-            H = Dp(E, ["tooltip"]),
             {
-                scale: oe,
-                axis: me
-            } = y,
-            W = GO(y),
-            Fe = Zn(me, ["title"]),
-            ue = C6(u, "outliers", t.boxplot, {
+                tooltip: rn,
+                ...Un
+            } = A,
+            {
+                scale: Y,
+                axis: ue
+            } = p,
+            be = oC(p),
+            q = Jn(ue, ["title"]),
+            ze = j6(o, "outliers", t.boxplot, {
                 transform: [{
-                    filter: `(${Ye} < ${$e}) || (${Ye} > ${Oe})`
+                    filter: `(${ye} < ${oe}) || (${ye} > ${Se})`
                 }],
                 mark: "point",
-                encoding: Object.assign(Object.assign(Object.assign({
-                    [v]: Object.assign(Object.assign(Object.assign({
-                        field: y.field,
-                        type: y.type
-                    }, W !== void 0 ? {
-                        title: W
-                    } : {}), oe !== void 0 ? {
-                        scale: oe
-                    } : {}), et(Fe) ? {} : {
-                        axis: Fe
-                    })
-                }, H), k ? {
-                    color: k
-                } : {}), O ? {
-                    tooltip: O
-                } : {})
+                encoding: {
+                    [m]: {
+                        field: p.field,
+                        type: p.type,
+                        ...be !== void 0 ? {
+                            title: be
+                        } : {},
+                        ...Y !== void 0 ? {
+                            scale: Y
+                        } : {},
+                        ...et(q) ? {} : {
+                            axis: q
+                        }
+                    },
+                    ...Un,
+                    ...w ? {
+                        color: w
+                    } : {},
+                    ...S ? {
+                        tooltip: S
+                    } : {}
+                }
             })[0];
-        let Re;
-        const vt = [...g, ...p, St];
-        return ue ? Re = {
-            transform: vt,
-            layer: [ue, dt]
-        } : (Re = dt, Re.transform.unshift(...vt)), Object.assign(Object.assign({}, l), {
-            layer: [Re, {
-                transform: m,
-                layer: I
+        let fe;
+        const Be = [...h, ...d, Pe];
+        return ze ? fe = {
+            transform: Be,
+            layer: [ze, xt]
+        } : (fe = xt, fe.transform.unshift(...Be)), {
+            ...a,
+            layer: [fe, {
+                transform: g,
+                layer: P
             }]
-        })
+        }
     }
 
-    function M6(e) {
+    function H6(e) {
         return [{
             op: "q1",
             field: e,
             as: `lower_box_${e}`
         }, {
             op: "q3",
             field: e,
             as: `upper_box_${e}`
         }]
     }
 
-    function gge(e, t, n) {
-        const i = A6(e, lm),
+    function vde(e, t, n) {
+        const i = G6(e, W0),
             {
                 continuousAxisChannelDef: r,
-                continuousAxis: a
-            } = k6(e, i, lm),
-            s = r.field,
-            o = T6(t),
-            l = [...M6(s), {
+                continuousAxis: s
+            } = U6(e, i, W0),
+            a = r.field,
+            o = W6(t),
+            l = [...H6(a), {
                 op: "median",
-                field: s,
-                as: `mid_box_${s}`
+                field: a,
+                as: `mid_box_${a}`
             }, {
                 op: "min",
-                field: s,
-                as: (o === "min-max" ? "lower_whisker_" : "min_") + s
+                field: a,
+                as: (o === "min-max" ? "lower_whisker_" : "min_") + a
             }, {
                 op: "max",
-                field: s,
-                as: (o === "min-max" ? "upper_whisker_" : "max_") + s
+                field: a,
+                as: (o === "min-max" ? "upper_whisker_" : "max_") + a
             }],
             u = o === "min-max" || o === "tukey" ? [] : [{
-                calculate: `datum["upper_box_${s}"] - datum["lower_box_${s}"]`,
-                as: `iqr_${s}`
+                calculate: `datum["upper_box_${a}"] - datum["lower_box_${a}"]`,
+                as: `iqr_${a}`
             }, {
-                calculate: `min(datum["upper_box_${s}"] + datum["iqr_${s}"] * ${t}, datum["max_${s}"])`,
-                as: `upper_whisker_${s}`
+                calculate: `min(datum["upper_box_${a}"] + datum["iqr_${a}"] * ${t}, datum["max_${a}"])`,
+                as: `upper_whisker_${a}`
             }, {
-                calculate: `max(datum["lower_box_${s}"] - datum["iqr_${s}"] * ${t}, datum["min_${s}"])`,
-                as: `lower_whisker_${s}`
+                calculate: `max(datum["lower_box_${a}"] - datum["iqr_${a}"] * ${t}, datum["min_${a}"])`,
+                as: `lower_whisker_${a}`
             }],
-            c = e.encoding,
-            f = a;
-        c[f];
-        const h = Dp(c, [typeof f == "symbol" ? f : f + ""]),
             {
-                customTooltipWithoutAggregatedField: d,
-                filteredEncoding: g
-            } = fge(h),
+                [s]: c,
+                ...f
+            } = e.encoding,
+            {
+                customTooltipWithoutAggregatedField: h,
+                filteredEncoding: d
+            } = pde(f),
             {
-                bins: p,
-                timeUnits: m,
-                aggregate: y,
-                groupby: v,
-                encoding: b
-            } = S6(g, n),
-            x = i === "vertical" ? "horizontal" : "vertical",
-            _ = i,
-            S = [...p, ...m, {
-                aggregate: [...y, ...l],
-                groupby: v
+                bins: g,
+                timeUnits: p,
+                aggregate: m,
+                groupby: y,
+                encoding: v
+            } = z6(d, n),
+            b = i === "vertical" ? "horizontal" : "vertical",
+            x = i,
+            _ = [...g, ...p, {
+                aggregate: [...m, ...l],
+                groupby: y
             }, ...u];
         return {
-            bins: p,
-            timeUnits: m,
-            transform: S,
-            groupby: v,
-            aggregate: y,
+            bins: g,
+            timeUnits: p,
+            transform: _,
+            groupby: y,
+            aggregate: m,
             continuousAxisChannelDef: r,
-            continuousAxis: a,
-            encodingWithoutContinuousAxis: b,
-            ticksOrient: x,
-            boxOrient: _,
-            customTooltipWithoutAggregatedField: d
+            continuousAxis: s,
+            encodingWithoutContinuousAxis: v,
+            ticksOrient: b,
+            boxOrient: x,
+            customTooltipWithoutAggregatedField: h
         }
     }
-    var k$ = globalThis && globalThis.__rest || function(e, t) {
-        var n = {};
-        for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && t.indexOf(i) < 0 && (n[i] = e[i]);
-        if (e != null && typeof Object.getOwnPropertySymbols == "function")
-            for (var r = 0, i = Object.getOwnPropertySymbols(e); r < i.length; r++) t.indexOf(i[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, i[r]) && (n[i[r]] = e[i[r]]);
-        return n
-    };
-    const qO = "errorbar",
-        pge = ["ticks", "rule"],
-        mge = new ay(qO, F6);
+    const uC = "errorbar",
+        bde = ["ticks", "rule"],
+        xde = new j1(uC, Y6);
 
-    function F6(e, {
+    function Y6(e, {
         config: t
     }) {
-        e = Object.assign(Object.assign({}, e), {
-            encoding: sy(e.encoding, t)
-        });
+        e = {
+            ...e,
+            encoding: U1(e.encoding, t)
+        };
         const {
             transform: n,
             continuousAxisChannelDef: i,
             continuousAxis: r,
-            encodingWithoutContinuousAxis: a,
-            ticksOrient: s,
+            encodingWithoutContinuousAxis: s,
+            ticksOrient: a,
             markDef: o,
             outerSpec: l,
             tooltipEncoding: u
-        } = D6(e, qO, t);
-        delete a.size;
-        const c = UO(o, r, i, a, t.errorbar),
+        } = X6(e, uC, t);
+        delete s.size;
+        const c = lC(o, r, i, s, t.errorbar),
             f = o.thickness,
             h = o.size,
-            d = Object.assign(Object.assign({
+            d = {
                 type: "tick",
-                orient: s,
-                aria: !1
-            }, f !== void 0 ? {
-                thickness: f
-            } : {}), h !== void 0 ? {
-                size: h
-            } : {}),
+                orient: a,
+                aria: !1,
+                ...f !== void 0 ? {
+                    thickness: f
+                } : {},
+                ...h !== void 0 ? {
+                    size: h
+                } : {}
+            },
             g = [...c({
                 partName: "ticks",
                 mark: d,
                 positionPrefix: "lower",
                 extraEncoding: u
             }), ...c({
                 partName: "ticks",
                 mark: d,
                 positionPrefix: "upper",
                 extraEncoding: u
             }), ...c({
                 partName: "rule",
-                mark: Object.assign({
+                mark: {
                     type: "rule",
-                    ariaRoleDescription: "errorbar"
-                }, f !== void 0 ? {
-                    size: f
-                } : {}),
+                    ariaRoleDescription: "errorbar",
+                    ...f !== void 0 ? {
+                        size: f
+                    } : {}
+                },
                 positionPrefix: "lower",
                 endPositionPrefix: "upper",
                 extraEncoding: u
             })];
-        return Object.assign(Object.assign(Object.assign({}, l), {
-            transform: n
-        }), g.length > 1 ? {
-            layer: g
-        } : Object.assign({}, g[0]))
+        return {
+            ...l,
+            transform: n,
+            ...g.length > 1 ? {
+                layer: g
+            } : {
+                ...g[0]
+            }
+        }
     }
 
-    function yge(e, t) {
+    function _de(e, t) {
         const {
             encoding: n
         } = e;
-        if (vge(n)) return {
-            orient: A6(e, t),
+        if (wde(n)) return {
+            orient: G6(e, t),
             inputType: "raw"
         };
-        const i = bge(n),
-            r = xge(n),
-            a = n.x,
-            s = n.y;
+        const i = Sde(n),
+            r = Ede(n),
+            s = n.x,
+            a = n.y;
         if (i) {
             if (r) throw new Error(`${t} cannot be both type aggregated-upper-lower and aggregated-error`);
             const o = n.x2,
                 l = n.y2;
-            if (Ee(o) && Ee(l)) throw new Error(`${t} cannot have both x2 and y2`);
-            if (Ee(o)) {
-                if (Ur(a)) return {
+            if (Ce(o) && Ce(l)) throw new Error(`${t} cannot have both x2 and y2`);
+            if (Ce(o)) {
+                if (_a(s)) return {
                     orient: "horizontal",
                     inputType: "aggregated-upper-lower"
                 };
                 throw new Error(`Both x and x2 have to be quantitative in ${t}`)
-            } else if (Ee(l)) {
-                if (Ur(s)) return {
+            } else if (Ce(l)) {
+                if (_a(a)) return {
                     orient: "vertical",
                     inputType: "aggregated-upper-lower"
                 };
                 throw new Error(`Both y and y2 have to be quantitative in ${t}`)
             }
             throw new Error("No ranged axis")
         } else {
             const o = n.xError,
                 l = n.xError2,
                 u = n.yError,
                 c = n.yError2;
-            if (Ee(l) && !Ee(o)) throw new Error(`${t} cannot have xError2 without xError`);
-            if (Ee(c) && !Ee(u)) throw new Error(`${t} cannot have yError2 without yError`);
-            if (Ee(o) && Ee(u)) throw new Error(`${t} cannot have both xError and yError with both are quantiative`);
-            if (Ee(o)) {
-                if (Ur(a)) return {
+            if (Ce(l) && !Ce(o)) throw new Error(`${t} cannot have xError2 without xError`);
+            if (Ce(c) && !Ce(u)) throw new Error(`${t} cannot have yError2 without yError`);
+            if (Ce(o) && Ce(u)) throw new Error(`${t} cannot have both xError and yError with both are quantiative`);
+            if (Ce(o)) {
+                if (_a(s)) return {
                     orient: "horizontal",
                     inputType: "aggregated-error"
                 };
                 throw new Error("All x, xError, and xError2 (if exist) have to be quantitative")
-            } else if (Ee(u)) {
-                if (Ur(s)) return {
+            } else if (Ce(u)) {
+                if (_a(a)) return {
                     orient: "vertical",
                     inputType: "aggregated-error"
                 };
                 throw new Error("All y, yError, and yError2 (if exist) have to be quantitative")
             }
             throw new Error("No ranged axis")
         }
     }
 
-    function vge(e) {
-        return (Ee(e.x) || Ee(e.y)) && !Ee(e.x2) && !Ee(e.y2) && !Ee(e.xError) && !Ee(e.xError2) && !Ee(e.yError) && !Ee(e.yError2)
+    function wde(e) {
+        return (Ce(e.x) || Ce(e.y)) && !Ce(e.x2) && !Ce(e.y2) && !Ce(e.xError) && !Ce(e.xError2) && !Ce(e.yError) && !Ce(e.yError2)
     }
 
-    function bge(e) {
-        return Ee(e.x2) || Ee(e.y2)
+    function Sde(e) {
+        return Ce(e.x2) || Ce(e.y2)
     }
 
-    function xge(e) {
-        return Ee(e.xError) || Ee(e.xError2) || Ee(e.yError) || Ee(e.yError2)
+    function Ede(e) {
+        return Ce(e.xError) || Ce(e.xError2) || Ce(e.yError) || Ce(e.yError2)
     }
 
-    function D6(e, t, n) {
-        var i;
+    function X6(e, t, n) {
         const {
-            mark: r,
-            encoding: a,
+            mark: i,
+            encoding: r,
             params: s,
-            projection: o
-        } = e, l = k$(e, ["mark", "encoding", "params", "projection"]), u = na(r) ? r : {
-            type: r
-        };
-        s && X(Tj(t));
-        const {
-            orient: c,
-            inputType: f
-        } = yge(e, t), {
-            continuousAxisChannelDef: h,
-            continuousAxisChannelDef2: d,
-            continuousAxisChannelDefError: g,
-            continuousAxisChannelDefError2: p,
-            continuousAxis: m
-        } = k6(e, c, t), {
-            errorBarSpecificAggregate: y,
-            postAggregateCalculates: v,
-            tooltipSummary: b,
-            tooltipTitleWithFieldName: x
-        } = _ge(u, h, d, g, p, f, t, n), _ = a, S = m;
-        _[S];
-        const w = m === "x" ? "x2" : "y2";
-        _[w];
-        const O = m === "x" ? "xError" : "yError";
-        _[O];
-        const k = m === "x" ? "xError2" : "yError2";
-        _[k];
-        const C = k$(_, [typeof S == "symbol" ? S : S + "", typeof w == "symbol" ? w : w + "", typeof O == "symbol" ? O : O + "", typeof k == "symbol" ? k : k + ""]),
-            {
-                bins: E,
-                timeUnits: T,
-                aggregate: A,
-                groupby: F,
-                encoding: $
-            } = S6(C, n),
-            D = [...A, ...y],
-            P = f !== "raw" ? [] : F,
-            N = kx(b, h, $, x);
-        return {
-            transform: [...(i = l.transform) !== null && i !== void 0 ? i : [], ...E, ...T, ...D.length === 0 ? [] : [{
-                aggregate: D,
-                groupby: P
-            }], ...v],
-            groupby: P,
-            continuousAxisChannelDef: h,
-            continuousAxis: m,
+            projection: a,
+            ...o
+        } = e, l = Vr(i) ? i : {
+            type: i
+        };
+        s && X(GI(t));
+        const {
+            orient: u,
+            inputType: c
+        } = _de(e, t), {
+            continuousAxisChannelDef: f,
+            continuousAxisChannelDef2: h,
+            continuousAxisChannelDefError: d,
+            continuousAxisChannelDefError2: g,
+            continuousAxis: p
+        } = U6(e, u, t), {
+            errorBarSpecificAggregate: m,
+            postAggregateCalculates: y,
+            tooltipSummary: v,
+            tooltipTitleWithFieldName: b
+        } = Cde(l, f, h, d, g, c, t, n), {
+            [p]: x,
+            [p === "x" ? "x2" : "y2"]: _,
+            [p === "x" ? "xError" : "yError"]: S,
+            [p === "x" ? "xError2" : "yError2"]: w,
+            ...E
+        } = r, {
+            bins: A,
+            timeUnits: C,
+            aggregate: k,
+            groupby: R,
+            encoding: $
+        } = z6(E, n), T = [...k, ...m], M = c !== "raw" ? [] : R, F = Q2(v, f, $, b);
+        return {
+            transform: [...o.transform ?? [], ...A, ...C, ...T.length === 0 ? [] : [{
+                aggregate: T,
+                groupby: M
+            }], ...y],
+            groupby: M,
+            continuousAxisChannelDef: f,
+            continuousAxis: p,
             encodingWithoutContinuousAxis: $,
-            ticksOrient: c === "vertical" ? "horizontal" : "vertical",
-            markDef: u,
-            outerSpec: l,
-            tooltipEncoding: N
+            ticksOrient: u === "vertical" ? "horizontal" : "vertical",
+            markDef: l,
+            outerSpec: o,
+            tooltipEncoding: F
         }
     }
 
-    function _ge(e, t, n, i, r, a, s, o) {
+    function Cde(e, t, n, i, r, s, a, o) {
         let l = [],
             u = [];
         const c = t.field;
         let f, h = !1;
-        if (a === "raw") {
+        if (s === "raw") {
             const d = e.center ? e.center : e.extent ? e.extent === "iqr" ? "median" : "mean" : o.errorbar.center,
                 g = e.extent ? e.extent : d === "mean" ? "stderr" : "iqr";
-            if (d === "median" != (g === "iqr") && X(Dhe(d, g, s)), g === "stderr" || g === "stdev") l = [{
+            if (d === "median" != (g === "iqr") && X(zfe(d, g, a)), g === "stderr" || g === "stdev") l = [{
                 op: g,
                 field: c,
                 as: `extent_${c}`
             }, {
                 op: d,
                 field: c,
                 as: `center_${c}`
@@ -40440,21 +40575,21 @@
                 calculate: `datum["center_${c}"] + datum["extent_${c}"]`,
                 as: `upper_${c}`
             }, {
                 calculate: `datum["center_${c}"] - datum["extent_${c}"]`,
                 as: `lower_${c}`
             }], f = [{
                 fieldPrefix: "center_",
-                titlePrefix: zd(d)
+                titlePrefix: $d(d)
             }, {
                 fieldPrefix: "upper_",
-                titlePrefix: A$(d, g, "+")
+                titlePrefix: U5(d, g, "+")
             }, {
                 fieldPrefix: "lower_",
-                titlePrefix: A$(d, g, "-")
+                titlePrefix: U5(d, g, "-")
             }], h = !0;
             else {
                 let p, m, y;
                 g === "ci" ? (p = "mean", m = "ci0", y = "ci1") : (p = "median", m = "q1", y = "q3"), l = [{
                     op: m,
                     field: c,
                     as: `lower_${c}`
@@ -40464,112 +40599,121 @@
                     as: `upper_${c}`
                 }, {
                     op: p,
                     field: c,
                     as: `center_${c}`
                 }], f = [{
                     fieldPrefix: "upper_",
-                    titlePrefix: Lu({
+                    titlePrefix: ku({
                         field: c,
                         aggregate: y,
                         type: "quantitative"
                     }, o, {
                         allowDisabling: !1
                     })
                 }, {
                     fieldPrefix: "lower_",
-                    titlePrefix: Lu({
+                    titlePrefix: ku({
                         field: c,
                         aggregate: m,
                         type: "quantitative"
                     }, o, {
                         allowDisabling: !1
                     })
                 }, {
                     fieldPrefix: "center_",
-                    titlePrefix: Lu({
+                    titlePrefix: ku({
                         field: c,
                         aggregate: p,
                         type: "quantitative"
                     }, o, {
                         allowDisabling: !1
                     })
                 }]
             }
         } else {
-            (e.center || e.extent) && X(Fhe(e.center, e.extent)), a === "aggregated-upper-lower" ? (f = [], u = [{
+            (e.center || e.extent) && X(Ife(e.center, e.extent)), s === "aggregated-upper-lower" ? (f = [], u = [{
                 calculate: `datum["${n.field}"]`,
                 as: `upper_${c}`
             }, {
                 calculate: `datum["${c}"]`,
                 as: `lower_${c}`
-            }]) : a === "aggregated-error" && (f = [{
+            }]) : s === "aggregated-error" && (f = [{
                 fieldPrefix: "",
                 titlePrefix: c
             }], u = [{
                 calculate: `datum["${c}"] + datum["${i.field}"]`,
                 as: `upper_${c}`
             }], r ? u.push({
                 calculate: `datum["${c}"] + datum["${r.field}"]`,
                 as: `lower_${c}`
             }) : u.push({
                 calculate: `datum["${c}"] - datum["${i.field}"]`,
                 as: `lower_${c}`
             }));
             for (const d of u) f.push({
                 fieldPrefix: d.as.substring(0, 6),
-                titlePrefix: xl(xl(d.calculate, 'datum["', ""), '"]', "")
+                titlePrefix: ll(ll(d.calculate, 'datum["', ""), '"]', "")
             })
         }
         return {
             postAggregateCalculates: u,
             errorBarSpecificAggregate: l,
             tooltipSummary: f,
             tooltipTitleWithFieldName: h
         }
     }
 
-    function A$(e, t, n) {
-        return `${zd(e)} ${n} ${t}`
+    function U5(e, t, n) {
+        return `${$d(e)} ${n} ${t}`
     }
-    const WO = "errorband",
-        wge = ["band", "borders"],
-        Sge = new ay(WO, R6);
+    const cC = "errorband",
+        kde = ["band", "borders"],
+        Ade = new j1(cC, V6);
 
-    function R6(e, {
+    function V6(e, {
         config: t
     }) {
-        e = Object.assign(Object.assign({}, e), {
-            encoding: sy(e.encoding, t)
-        });
+        e = {
+            ...e,
+            encoding: U1(e.encoding, t)
+        };
         const {
             transform: n,
             continuousAxisChannelDef: i,
             continuousAxis: r,
-            encodingWithoutContinuousAxis: a,
-            markDef: s,
+            encodingWithoutContinuousAxis: s,
+            markDef: a,
             outerSpec: o,
             tooltipEncoding: l
-        } = D6(e, WO, t), u = s, c = UO(u, r, i, a, t.errorband), f = e.encoding.x !== void 0 && e.encoding.y !== void 0;
+        } = X6(e, cC, t), u = a, c = lC(u, r, i, s, t.errorband), f = e.encoding.x !== void 0 && e.encoding.y !== void 0;
         let h = {
                 type: f ? "area" : "rect"
             },
             d = {
                 type: f ? "line" : "rule"
             };
-        const g = Object.assign(Object.assign({}, u.interpolate ? {
-            interpolate: u.interpolate
-        } : {}), u.tension && u.interpolate ? {
-            tension: u.tension
-        } : {});
-        return f ? (h = Object.assign(Object.assign(Object.assign({}, h), g), {
+        const g = {
+            ...u.interpolate ? {
+                interpolate: u.interpolate
+            } : {},
+            ...u.tension && u.interpolate ? {
+                tension: u.tension
+            } : {}
+        };
+        return f ? (h = {
+            ...h,
+            ...g,
             ariaRoleDescription: "errorband"
-        }), d = Object.assign(Object.assign(Object.assign({}, d), g), {
+        }, d = {
+            ...d,
+            ...g,
             aria: !1
-        })) : u.interpolate ? X(b$("interpolate")) : u.tension && X(b$("tension")), Object.assign(Object.assign({}, o), {
+        }) : u.interpolate ? X(R5("interpolate")) : u.tension && X(R5("tension")), {
+            ...o,
             transform: n,
             layer: [...c({
                 partName: "band",
                 mark: h,
                 positionPrefix: "lower",
                 endPositionPrefix: "upper",
                 extraEncoding: l
@@ -40580,81 +40724,81 @@
                 extraEncoding: l
             }), ...c({
                 partName: "borders",
                 mark: d,
                 positionPrefix: "upper",
                 extraEncoding: l
             })]
-        })
+        }
     }
-    const P6 = {};
+    const K6 = {};
 
-    function HO(e, t, n) {
-        const i = new ay(e, t);
-        P6[e] = {
+    function fC(e, t, n) {
+        const i = new j1(e, t);
+        K6[e] = {
             normalizer: i,
             parts: n
         }
     }
 
-    function Ege() {
-        return Y(P6)
+    function $de() {
+        return H(K6)
     }
-    HO(lm, $6, hge);
-    HO(qO, F6, pge);
-    HO(WO, R6, wge);
-    const Oge = ["gradientHorizontalMaxLength", "gradientHorizontalMinLength", "gradientVerticalMaxLength", "gradientVerticalMinLength", "unselectedOpacity"],
-        N6 = {
+    fC(W0, q6, mde);
+    fC(uC, Y6, bde);
+    fC(cC, V6, kde);
+    const Tde = ["gradientHorizontalMaxLength", "gradientHorizontalMinLength", "gradientVerticalMaxLength", "gradientVerticalMinLength", "unselectedOpacity"],
+        J6 = {
             titleAlign: "align",
             titleAnchor: "anchor",
             titleAngle: "angle",
             titleBaseline: "baseline",
             titleColor: "color",
             titleFont: "font",
             titleFontSize: "fontSize",
             titleFontStyle: "fontStyle",
             titleFontWeight: "fontWeight",
             titleLimit: "limit",
             titleLineHeight: "lineHeight",
             titleOrient: "orient",
             titlePadding: "offset"
         },
-        L6 = {
+        Q6 = {
             labelAlign: "align",
             labelAnchor: "anchor",
             labelAngle: "angle",
             labelBaseline: "baseline",
             labelColor: "color",
             labelFont: "font",
             labelFontSize: "fontSize",
             labelFontStyle: "fontStyle",
             labelFontWeight: "fontWeight",
             labelLimit: "limit",
             labelLineHeight: "lineHeight",
             labelOrient: "orient",
             labelPadding: "offset"
         },
-        Cge = Y(N6),
-        kge = Y(L6),
-        Age = {
+        Mde = H(J6),
+        Ode = H(Q6),
+        Fde = {
             header: 1,
             headerRow: 1,
             headerColumn: 1,
             headerFacet: 1
         },
-        I6 = Y(Age),
-        j6 = ["size", "shape", "fill", "stroke", "strokeDash", "strokeWidth", "opacity"],
-        Tge = {
+        Z6 = H(Fde),
+        ez = ["size", "shape", "fill", "stroke", "strokeDash", "strokeWidth", "opacity"],
+        Rde = {
             gradientHorizontalMaxLength: 200,
             gradientHorizontalMinLength: 100,
             gradientVerticalMaxLength: 200,
             gradientVerticalMinLength: 64,
             unselectedOpacity: .35
         },
-        $ge = {
+        Dde = {
             aria: 1,
             clipHeight: 1,
             columnPadding: 1,
             columns: 1,
             cornerRadius: 1,
             description: 1,
             direction: 1,
@@ -40713,19 +40857,19 @@
             titleOpacity: 1,
             titleOrient: 1,
             titlePadding: 1,
             type: 1,
             values: 1,
             zindex: 1
         },
-        ra = "_vgsid_",
-        Mge = {
+        pr = "_vgsid_",
+        Nde = {
             point: {
                 on: "click",
-                fields: [ra],
+                fields: [pr],
                 toggle: "event.shiftKey",
                 resolve: "global",
                 clear: "dblclick"
             },
             interval: {
                 on: "[mousedown, window:mouseup] > window:mousemove!",
                 encodings: ["x", "y"],
@@ -40737,175 +40881,163 @@
                     stroke: "white"
                 },
                 resolve: "global",
                 clear: "dblclick"
             }
         };
 
-    function YO(e) {
+    function hC(e) {
         return e === "legend" || !!(e != null && e.legend)
     }
 
-    function Vv(e) {
-        return YO(e) && se(e)
+    function Av(e) {
+        return hC(e) && ae(e)
     }
 
-    function XO(e) {
+    function dC(e) {
         return !!(e != null && e.select)
     }
-    var Fge = globalThis && globalThis.__rest || function(e, t) {
-        var n = {};
-        for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && t.indexOf(i) < 0 && (n[i] = e[i]);
-        if (e != null && typeof Object.getOwnPropertySymbols == "function")
-            for (var r = 0, i = Object.getOwnPropertySymbols(e); r < i.length; r++) t.indexOf(i[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, i[r]) && (n[i[r]] = e[i[r]]);
-        return n
-    };
 
-    function z6(e) {
+    function tz(e) {
         const t = [];
         for (const n of e || []) {
-            if (XO(n)) continue;
+            if (dC(n)) continue;
             const {
                 expr: i,
-                bind: r
-            } = n, a = Fge(n, ["expr", "bind"]);
+                bind: r,
+                ...s
+            } = n;
             if (r && i) {
-                const s = Object.assign(Object.assign({}, a), {
+                const a = {
+                    ...s,
                     bind: r,
                     init: i
-                });
-                t.push(s)
+                };
+                t.push(a)
             } else {
-                const s = Object.assign(Object.assign(Object.assign({}, a), i ? {
-                    update: i
-                } : {}), r ? {
-                    bind: r
-                } : {});
-                t.push(s)
+                const a = {
+                    ...s,
+                    ...i ? {
+                        update: i
+                    } : {},
+                    ...r ? {
+                        bind: r
+                    } : {}
+                };
+                t.push(a)
             }
         }
         return t
     }
 
-    function Dge(e) {
-        return oy(e) || KO(e) || VO(e)
+    function Pde(e) {
+        return G1(e) || pC(e) || gC(e)
     }
 
-    function VO(e) {
+    function gC(e) {
         return "concat" in e
     }
 
-    function oy(e) {
+    function G1(e) {
         return "vconcat" in e
     }
 
-    function KO(e) {
+    function pC(e) {
         return "hconcat" in e
     }
 
-    function B6({
+    function nz({
         step: e,
         offsetIsDiscrete: t
     }) {
-        var n;
-        return t ? (n = e.for) !== null && n !== void 0 ? n : "offset" : "position"
+        return t ? e.for ?? "offset" : "position"
     }
 
-    function aa(e) {
-        return se(e) && e.step !== void 0
+    function Jr(e) {
+        return ae(e) && e.step !== void 0
     }
 
-    function T$(e) {
+    function G5(e) {
         return e.view || e.width || e.height
     }
-    const $$ = 20,
-        Rge = {
+    const W5 = 20,
+        Lde = {
             align: 1,
             bounds: 1,
             center: 1,
             columns: 1,
             spacing: 1
         },
-        Pge = Y(Rge);
+        Ide = H(Lde);
 
-    function Nge(e, t, n) {
-        var i, r;
-        const a = n[t],
-            s = {},
+    function zde(e, t, n) {
+        const i = n[t],
+            r = {},
             {
-                spacing: o,
-                columns: l
-            } = a;
-        o !== void 0 && (s.spacing = o), l !== void 0 && (ey(e) && !Xd(e.facet) || VO(e)) && (s.columns = l), oy(e) && (s.columns = 1);
-        for (const u of Pge)
-            if (e[u] !== void 0)
-                if (u === "spacing") {
-                    const c = e[u];
-                    s[u] = tt(c) ? c : {
-                        row: (i = c.row) !== null && i !== void 0 ? i : o,
-                        column: (r = c.column) !== null && r !== void 0 ? r : o
+                spacing: s,
+                columns: a
+            } = i;
+        s !== void 0 && (r.spacing = s), a !== void 0 && (P1(e) && !Rd(e.facet) || gC(e)) && (r.columns = a), G1(e) && (r.columns = 1);
+        for (const o of Ide)
+            if (e[o] !== void 0)
+                if (o === "spacing") {
+                    const l = e[o];
+                    r[o] = Ze(l) ? l : {
+                        row: l.row ?? s,
+                        column: l.column ?? s
                     }
-                } else s[u] = e[u];
-        return s
+                } else r[o] = e[o];
+        return r
     }
-    var Lge = globalThis && globalThis.__rest || function(e, t) {
-        var n = {};
-        for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && t.indexOf(i) < 0 && (n[i] = e[i]);
-        if (e != null && typeof Object.getOwnPropertySymbols == "function")
-            for (var r = 0, i = Object.getOwnPropertySymbols(e); r < i.length; r++) t.indexOf(i[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, i[r]) && (n[i[r]] = e[i[r]]);
-        return n
-    };
 
-    function Ax(e, t) {
-        var n;
-        return (n = e[t]) !== null && n !== void 0 ? n : e[t === "width" ? "continuousWidth" : "continuousHeight"]
+    function Z2(e, t) {
+        return e[t] ?? e[t === "width" ? "continuousWidth" : "continuousHeight"]
     }
 
-    function um(e, t) {
-        const n = cm(e, t);
-        return aa(n) ? n.step : G6
+    function q0(e, t) {
+        const n = H0(e, t);
+        return Jr(n) ? n.step : iz
     }
 
-    function cm(e, t) {
-        var n;
-        const i = (n = e[t]) !== null && n !== void 0 ? n : e[t === "width" ? "discreteWidth" : "discreteHeight"];
-        return Tt(i, {
+    function H0(e, t) {
+        const n = e[t] ?? e[t === "width" ? "discreteWidth" : "discreteHeight"];
+        return Ct(n, {
             step: e.step
         })
     }
-    const G6 = 20,
-        Ige = {
+    const iz = 20,
+        Bde = {
             continuousWidth: 200,
             continuousHeight: 200,
-            step: G6
+            step: iz
         },
-        jge = {
+        jde = {
             background: "white",
             padding: 5,
             timeFormat: "%b %d, %Y",
             countTitle: "Count of Records",
-            view: Ige,
-            mark: Tde,
+            view: Bde,
+            mark: Dhe,
             arc: {},
             area: {},
-            bar: Fde,
+            bar: Lhe,
             circle: {},
             geoshape: {},
             image: {},
             line: {},
             point: {},
-            rect: Dde,
+            rect: Ihe,
             rule: {
                 color: "black"
             },
             square: {},
             text: {
                 color: "black"
             },
-            tick: Rde,
+            tick: zhe,
             trail: {},
             boxplot: {
                 size: 14,
                 extent: 1.5,
                 box: {},
                 median: {
                     color: "white"
@@ -40921,53 +41053,53 @@
             },
             errorband: {
                 band: {
                     opacity: .3
                 },
                 borders: !1
             },
-            scale: fde,
+            scale: mhe,
             projection: {},
-            legend: Tge,
+            legend: Rde,
             header: {
                 titlePadding: 10,
                 labelPadding: 10
             },
             headerColumn: {},
             headerRow: {},
             headerFacet: {},
-            selection: Mge,
+            selection: Nde,
             style: {},
             title: {},
             facet: {
-                spacing: $$
+                spacing: W5
             },
             concat: {
-                spacing: $$
+                spacing: W5
             },
             normalizedNumberFormat: ".0%"
         },
-        Oa = ["#4c78a8", "#f58518", "#e45756", "#72b7b2", "#54a24b", "#eeca3b", "#b279a2", "#ff9da6", "#9d755d", "#bab0ac"],
-        M$ = {
+        ps = ["#4c78a8", "#f58518", "#e45756", "#72b7b2", "#54a24b", "#eeca3b", "#b279a2", "#ff9da6", "#9d755d", "#bab0ac"],
+        q5 = {
             text: 11,
             guideLabel: 10,
             guideTitle: 11,
             groupTitle: 13,
             groupSubtitle: 12
         },
-        F$ = {
-            blue: Oa[0],
-            orange: Oa[1],
-            red: Oa[2],
-            teal: Oa[3],
-            green: Oa[4],
-            yellow: Oa[5],
-            purple: Oa[6],
-            pink: Oa[7],
-            brown: Oa[8],
+        H5 = {
+            blue: ps[0],
+            orange: ps[1],
+            red: ps[2],
+            teal: ps[3],
+            green: ps[4],
+            yellow: ps[5],
+            purple: ps[6],
+            pink: ps[7],
+            brown: ps[8],
             gray0: "#000",
             gray1: "#111",
             gray2: "#222",
             gray3: "#333",
             gray4: "#444",
             gray5: "#555",
             gray6: "#666",
@@ -40978,19 +41110,22 @@
             gray11: "#bbb",
             gray12: "#ccc",
             gray13: "#ddd",
             gray14: "#eee",
             gray15: "#fff"
         };
 
-    function zge(e = {}) {
+    function Ude(e = {}) {
         return {
             signals: [{
                 name: "color",
-                value: se(e) ? Object.assign(Object.assign({}, F$), e) : F$
+                value: ae(e) ? {
+                    ...H5,
+                    ...e
+                } : H5
             }],
             mark: {
                 color: {
                     signal: "color.blue"
                 }
             },
             rule: {
@@ -41063,19 +41198,22 @@
                 }, {
                     signal: "color.grey8"
                 }]
             }
         }
     }
 
-    function Bge(e) {
+    function Gde(e) {
         return {
             signals: [{
                 name: "fontSize",
-                value: se(e) ? Object.assign(Object.assign({}, M$), e) : M$
+                value: ae(e) ? {
+                    ...q5,
+                    ...e
+                } : q5
             }],
             text: {
                 fontSize: {
                     signal: "fontSize.text"
                 }
             },
             style: {
@@ -41099,15 +41237,15 @@
                         signal: "fontSize.groupSubtitle"
                     }
                 }
             }
         }
     }
 
-    function Gge(e) {
+    function Wde(e) {
         return {
             text: {
                 font: e
             },
             style: {
                 "guide-label": {
                     font: e
@@ -41121,1110 +41259,1198 @@
                 "group-subtitle": {
                     font: e
                 }
             }
         }
     }
 
-    function U6(e) {
-        const t = Y(e || {}),
+    function rz(e) {
+        const t = H(e || {}),
             n = {};
         for (const i of t) {
             const r = e[i];
-            n[i] = Jd(r) ? wj(r) : pi(r)
+            n[i] = Pd(r) ? PI(r) : di(r)
         }
         return n
     }
 
-    function Uge(e) {
-        const t = Y(e),
+    function qde(e) {
+        const t = H(e),
             n = {};
-        for (const i of t) n[i] = U6(e[i]);
+        for (const i of t) n[i] = rz(e[i]);
         return n
     }
-    const qge = [...e6, ..._6, ...I6, "background", "padding", "legend", "lineBreak", "scale", "style", "title", "view"];
+    const Hde = [...p6, ...L6, ...Z6, "background", "padding", "legend", "lineBreak", "scale", "style", "title", "view"];
 
-    function q6(e = {}) {
+    function sz(e = {}) {
         const {
             color: t,
             font: n,
             fontSize: i,
-            selection: r
-        } = e, a = Lge(e, ["color", "font", "fontSize", "selection"]), s = Mc({}, Ce(jge), n ? Gge(n) : {}, t ? zge(t) : {}, i ? Bge(i) : {}, a || {});
-        r && Fc(s, "selection", r, !0);
-        const o = Zn(s, qge);
-        for (const l of ["background", "lineBreak", "padding"]) s[l] && (o[l] = pi(s[l]));
-        for (const l of e6) s[l] && (o[l] = Xn(s[l]));
-        for (const l of _6) s[l] && (o[l] = U6(s[l]));
-        for (const l of I6) s[l] && (o[l] = Xn(s[l]));
-        return s.legend && (o.legend = Xn(s.legend)), s.scale && (o.scale = Xn(s.scale)), s.style && (o.style = Uge(s.style)), s.title && (o.title = Xn(s.title)), s.view && (o.view = Xn(s.view)), o
-    }
-    const Wge = new Set(["view", ...Sde]),
-        Hge = ["color", "fontSize", "background", "padding", "facet", "concat", "numberFormat", "numberFormatType", "normalizedNumberFormat", "normalizedNumberFormatType", "timeFormat", "countTitle", "header", "axisQuantitative", "axisTemporal", "axisDiscrete", "axisPoint", "axisXBand", "axisXPoint", "axisXDiscrete", "axisXQuantitative", "axisXTemporal", "axisYBand", "axisYPoint", "axisYDiscrete", "axisYQuantitative", "axisYTemporal", "scale", "selection", "overlay"],
-        Yge = Object.assign({
-            view: ["continuousWidth", "continuousHeight", "discreteWidth", "discreteHeight", "step"]
-        }, Ade);
-
-    function Xge(e) {
-        e = Ce(e);
-        for (const t of Hge) delete e[t];
+            selection: r,
+            ...s
+        } = e, a = bc({}, ke(jde), n ? Wde(n) : {}, t ? Ude(t) : {}, i ? Gde(i) : {}, s || {});
+        r && xc(a, "selection", r, !0);
+        const o = Jn(a, Hde);
+        for (const l of ["background", "lineBreak", "padding"]) a[l] && (o[l] = di(a[l]));
+        for (const l of p6) a[l] && (o[l] = Hn(a[l]));
+        for (const l of L6) a[l] && (o[l] = rz(a[l]));
+        for (const l of Z6) a[l] && (o[l] = Hn(a[l]));
+        return a.legend && (o.legend = Hn(a.legend)), a.scale && (o.scale = Hn(a.scale)), a.style && (o.style = qde(a.style)), a.title && (o.title = Hn(a.title)), a.view && (o.view = Hn(a.view)), o
+    }
+    const Yde = new Set(["view", ...$he]),
+        Xde = ["color", "fontSize", "background", "padding", "facet", "concat", "numberFormat", "numberFormatType", "normalizedNumberFormat", "normalizedNumberFormatType", "timeFormat", "countTitle", "header", "axisQuantitative", "axisTemporal", "axisDiscrete", "axisPoint", "axisXBand", "axisXPoint", "axisXDiscrete", "axisXQuantitative", "axisXTemporal", "axisYBand", "axisYPoint", "axisYDiscrete", "axisYQuantitative", "axisYTemporal", "scale", "selection", "overlay"],
+        Vde = {
+            view: ["continuousWidth", "continuousHeight", "discreteWidth", "discreteHeight", "step"],
+            ...Rhe
+        };
+
+    function Kde(e) {
+        e = ke(e);
+        for (const t of Xde) delete e[t];
         if (e.axis)
-            for (const t in e.axis) Jd(e.axis[t]) && delete e.axis[t];
+            for (const t in e.axis) Pd(e.axis[t]) && delete e.axis[t];
         if (e.legend)
-            for (const t of Oge) delete e.legend[t];
+            for (const t of Tde) delete e.legend[t];
         if (e.mark) {
-            for (const t of _$) delete e.mark[t];
-            e.mark.tooltip && se(e.mark.tooltip) && delete e.mark.tooltip
+            for (const t of N5) delete e.mark[t];
+            e.mark.tooltip && ae(e.mark.tooltip) && delete e.mark.tooltip
         }
-        e.params && (e.signals = (e.signals || []).concat(z6(e.params)), delete e.params);
-        for (const t of Wge) {
-            for (const i of _$) delete e[t][i];
-            const n = Yge[t];
+        e.params && (e.signals = (e.signals || []).concat(tz(e.params)), delete e.params);
+        for (const t of Yde) {
+            for (const i of N5) delete e[t][i];
+            const n = Vde[t];
             if (n)
                 for (const i of n) delete e[t][i];
-            Kge(e, t)
+            Qde(e, t)
         }
-        for (const t of Ege()) delete e[t];
-        Vge(e);
-        for (const t in e) se(e[t]) && et(e[t]) && delete e[t];
+        for (const t of $de()) delete e[t];
+        Jde(e);
+        for (const t in e) ae(e[t]) && et(e[t]) && delete e[t];
         return et(e) ? void 0 : e
     }
 
-    function Vge(e) {
+    function Jde(e) {
         const {
             titleMarkConfig: t,
             subtitleMarkConfig: n,
             subtitle: i
-        } = _j(e.title);
-        et(t) || (e.style["group-title"] = Object.assign(Object.assign({}, e.style["group-title"]), t)), et(n) || (e.style["group-subtitle"] = Object.assign(Object.assign({}, e.style["group-subtitle"]), n)), et(i) ? delete e.title : e.title = i
+        } = NI(e.title);
+        et(t) || (e.style["group-title"] = {
+            ...e.style["group-title"],
+            ...t
+        }), et(n) || (e.style["group-subtitle"] = {
+            ...e.style["group-subtitle"],
+            ...n
+        }), et(i) ? delete e.title : e.title = i
     }
 
-    function Kge(e, t, n, i) {
+    function Qde(e, t, n, i) {
         const r = i ? e[t][i] : e[t];
         t === "view" && (n = "cell");
-        const a = Object.assign(Object.assign({}, r), e.style[n ?? t]);
-        et(a) || (e.style[n ?? t] = a), i || delete e[t]
+        const s = {
+            ...r,
+            ...e.style[n ?? t]
+        };
+        et(s) || (e.style[n ?? t] = s), i || delete e[t]
     }
 
-    function ly(e) {
+    function W1(e) {
         return "layer" in e
     }
 
-    function Jge(e) {
+    function Zde(e) {
         return "repeat" in e
     }
 
-    function Qge(e) {
-        return !q(e.repeat) && e.repeat.layer
+    function ege(e) {
+        return !W(e.repeat) && e.repeat.layer
     }
-    var Zge = globalThis && globalThis.__rest || function(e, t) {
-        var n = {};
-        for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && t.indexOf(i) < 0 && (n[i] = e[i]);
-        if (e != null && typeof Object.getOwnPropertySymbols == "function")
-            for (var r = 0, i = Object.getOwnPropertySymbols(e); r < i.length; r++) t.indexOf(i[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, i[r]) && (n[i[r]] = e[i[r]]);
-        return n
-    };
-    class JO {
+    class mC {
         map(t, n) {
-            return ey(t) ? this.mapFacet(t, n) : Jge(t) ? this.mapRepeat(t, n) : KO(t) ? this.mapHConcat(t, n) : oy(t) ? this.mapVConcat(t, n) : VO(t) ? this.mapConcat(t, n) : this.mapLayerOrUnit(t, n)
+            return P1(t) ? this.mapFacet(t, n) : Zde(t) ? this.mapRepeat(t, n) : pC(t) ? this.mapHConcat(t, n) : G1(t) ? this.mapVConcat(t, n) : gC(t) ? this.mapConcat(t, n) : this.mapLayerOrUnit(t, n)
         }
         mapLayerOrUnit(t, n) {
-            if (ly(t)) return this.mapLayer(t, n);
-            if (os(t)) return this.mapUnit(t, n);
-            throw new Error(hO(t))
+            if (W1(t)) return this.mapLayer(t, n);
+            if (Zs(t)) return this.mapUnit(t, n);
+            throw new Error(FE(t))
         }
         mapLayer(t, n) {
-            return Object.assign(Object.assign({}, t), {
+            return {
+                ...t,
                 layer: t.layer.map(i => this.mapLayerOrUnit(i, n))
-            })
+            }
         }
         mapHConcat(t, n) {
-            return Object.assign(Object.assign({}, t), {
+            return {
+                ...t,
                 hconcat: t.hconcat.map(i => this.map(i, n))
-            })
+            }
         }
         mapVConcat(t, n) {
-            return Object.assign(Object.assign({}, t), {
+            return {
+                ...t,
                 vconcat: t.vconcat.map(i => this.map(i, n))
-            })
+            }
         }
         mapConcat(t, n) {
             const {
-                concat: i
-            } = t, r = Zge(t, ["concat"]);
-            return Object.assign(Object.assign({}, r), {
-                concat: i.map(a => this.map(a, n))
-            })
+                concat: i,
+                ...r
+            } = t;
+            return {
+                ...r,
+                concat: i.map(s => this.map(s, n))
+            }
         }
         mapFacet(t, n) {
-            return Object.assign(Object.assign({}, t), {
+            return {
+                ...t,
                 spec: this.map(t.spec, n)
-            })
+            }
         }
         mapRepeat(t, n) {
-            return Object.assign(Object.assign({}, t), {
+            return {
+                ...t,
                 spec: this.map(t.spec, n)
-            })
+            }
         }
     }
-    const epe = {
+    const tge = {
         zero: 1,
         center: 1,
         normalize: 1
     };
 
-    function tpe(e) {
-        return e in epe
+    function nge(e) {
+        return e in tge
     }
-    const npe = new Set([Kj, K1, V1, im, Q1, TO, $O, J1, Jj, AO]),
-        ipe = new Set([K1, V1, Kj]);
+    const ige = new Set([f6, F1, O1, I0, D1, XE, VE, R1, h6, YE]),
+        rge = new Set([F1, O1, f6]);
 
-    function hu(e) {
-        return J(e) && gc(e) === "quantitative" && !e.bin
+    function tu(e) {
+        return K(e) && rc(e) === "quantitative" && !e.bin
     }
 
-    function D$(e, t) {
-        var n, i;
+    function Y5(e, t, {
+        orient: n,
+        type: i
+    }) {
         const r = t === "x" ? "y" : "radius",
+            s = t === "x",
             a = e[t],
-            s = e[r];
-        if (J(a) && J(s))
-            if (hu(a) && hu(s)) {
+            o = e[r];
+        if (K(a) && K(o))
+            if (tu(a) && tu(o)) {
                 if (a.stack) return t;
-                if (s.stack) return r;
-                const o = J(a) && !!a.aggregate,
-                    l = J(s) && !!s.aggregate;
-                if (o !== l) return o ? t : r; {
-                    const u = (n = a.scale) === null || n === void 0 ? void 0 : n.type,
-                        c = (i = s.scale) === null || i === void 0 ? void 0 : i.type;
-                    if (u && u !== "linear") return r;
-                    if (c && c !== "linear") return t
+                if (o.stack) return r;
+                const l = K(a) && !!a.aggregate,
+                    u = K(o) && !!o.aggregate;
+                if (l !== u) return l ? t : r;
+                if (s && i === "bar") {
+                    if (n === "vertical") return r;
+                    if (n === "horizontal") return t
                 }
             } else {
-                if (hu(a)) return t;
-                if (hu(s)) return r
+                if (tu(a)) return t;
+                if (tu(o)) return r
             }
         else {
-            if (hu(a)) return t;
-            if (hu(s)) return r
+            if (tu(a)) return t;
+            if (tu(o)) return r
         }
     }
 
-    function rpe(e) {
+    function sge(e) {
         switch (e) {
             case "x":
                 return "y";
             case "y":
                 return "x";
             case "theta":
                 return "radius";
             case "radius":
                 return "theta"
         }
     }
 
-    function W6(e, t) {
-        var n, i;
-        const r = na(e) ? e.type : e;
-        if (!npe.has(r)) return null;
-        const a = D$(t, "x") || D$(t, "theta");
-        if (!a) return null;
-        const s = t[a],
-            o = J(s) ? ne(s, {}) : void 0,
-            l = rpe(a),
-            u = [],
-            c = new Set;
-        if (t[l]) {
-            const d = t[l],
-                g = J(d) ? ne(d, {}) : void 0;
-            g && g !== o && (u.push(l), c.add(g));
-            const p = l === "x" ? "xOffset" : "yOffset",
-                m = t[p],
-                y = J(m) ? ne(m, {}) : void 0;
-            y && y !== o && (u.push(p), c.add(y))
-        }
-        const f = hfe.reduce((d, g) => {
-            if (g !== "tooltip" && al(t, g)) {
-                const p = t[g];
-                for (const m of ie(p)) {
-                    const y = ia(m);
-                    if (y.aggregate) continue;
-                    const v = ne(y, {});
-                    (!v || !c.has(v)) && d.push({
-                        channel: g,
-                        fieldDef: y
+    function az(e, t) {
+        var h, d;
+        const n = Vr(e) ? e : {
+                type: e
+            },
+            i = n.type;
+        if (!ige.has(i)) return null;
+        const r = Y5(t, "x", n) || Y5(t, "theta", n);
+        if (!r) return null;
+        const s = t[r],
+            a = K(s) ? ie(s, {}) : void 0,
+            o = sge(r),
+            l = [],
+            u = new Set;
+        if (t[o]) {
+            const g = t[o],
+                p = K(g) ? ie(g, {}) : void 0;
+            p && p !== a && (l.push(o), u.add(p));
+            const m = o === "x" ? "xOffset" : "yOffset",
+                y = t[m],
+                v = K(y) ? ie(y, {}) : void 0;
+            v && v !== a && (l.push(m), u.add(v))
+        }
+        const c = bce.reduce((g, p) => {
+            if (p !== "tooltip" && Ho(t, p)) {
+                const m = t[p];
+                for (const y of se(m)) {
+                    const v = Kr(y);
+                    if (v.aggregate) continue;
+                    const b = ie(v, {});
+                    (!b || !u.has(b)) && g.push({
+                        channel: p,
+                        fieldDef: v
                     })
                 }
             }
-            return d
+            return g
         }, []);
-        let h;
-        return s.stack !== void 0 ? co(s.stack) ? h = s.stack ? "zero" : null : h = s.stack : ipe.has(r) && (h = "zero"), !h || !tpe(h) || zO(t) && f.length === 0 ? null : !((n = s == null ? void 0 : s.scale) === null || n === void 0) && n.type && ((i = s == null ? void 0 : s.scale) === null || i === void 0 ? void 0 : i.type) !== ei.LINEAR ? (X(The(s.scale.type)), null) : Ee(t[ba(a)]) ? (s.stack !== void 0 && X(Ahe(a)), null) : (J(s) && s.aggregate && !Efe.has(s.aggregate) && X($he(s.aggregate)), {
-            groupbyChannels: u,
-            groupbyFields: c,
-            fieldChannel: a,
-            impute: s.impute === null ? !1 : wo(r),
-            stackBy: f,
-            offset: h
+        let f;
+        return s.stack !== void 0 ? Za(s.stack) ? f = s.stack ? "zero" : null : f = s.stack : rge.has(i) && (f = "zero"), !f || !nge(f) || sC(t) && c.length === 0 ? null : (h = s == null ? void 0 : s.scale) != null && h.type && ((d = s == null ? void 0 : s.scale) == null ? void 0 : d.type) !== Qn.LINEAR ? (s != null && s.stack && X(Nfe(s.scale.type)), null) : Ce(t[us(r)]) ? (s.stack !== void 0 && X(Dfe(r)), null) : (K(s) && s.aggregate && !Oce.has(s.aggregate) && X(Pfe(s.aggregate)), {
+            groupbyChannels: l,
+            groupbyFields: u,
+            fieldChannel: r,
+            impute: s.impute === null ? !1 : uo(i),
+            stackBy: c,
+            offset: f
         })
     }
-    var H6 = globalThis && globalThis.__rest || function(e, t) {
-        var n = {};
-        for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && t.indexOf(i) < 0 && (n[i] = e[i]);
-        if (e != null && typeof Object.getOwnPropertySymbols == "function")
-            for (var r = 0, i = Object.getOwnPropertySymbols(e); r < i.length; r++) t.indexOf(i[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, i[r]) && (n[i[r]] = e[i[r]]);
-        return n
-    };
 
-    function ape(e) {
-        const t = H6(e, ["point", "line"]);
-        return Y(t).length > 1 ? t : t.type
+    function age(e) {
+        const {
+            point: t,
+            line: n,
+            ...i
+        } = e;
+        return H(i).length > 1 ? i : i.type
     }
 
-    function spe(e) {
-        for (const t of ["line", "area", "rule", "trail"]) e[t] && (e = Object.assign(Object.assign({}, e), {
-            [t]: Zn(e[t], ["point", "line"])
-        }));
+    function oge(e) {
+        for (const t of ["line", "area", "rule", "trail"]) e[t] && (e = {
+            ...e,
+            [t]: Jn(e[t], ["point", "line"])
+        });
         return e
     }
 
-    function Kv(e, t = {}, n) {
+    function $v(e, t = {}, n) {
         return e.point === "transparent" ? {
             opacity: 0
-        } : e.point ? se(e.point) ? e.point : {} : e.point !== void 0 ? null : t.point || n.shape ? se(t.point) ? t.point : {} : void 0
+        } : e.point ? ae(e.point) ? e.point : {} : e.point !== void 0 ? null : t.point || n.shape ? ae(t.point) ? t.point : {} : void 0
     }
 
-    function R$(e, t = {}) {
+    function X5(e, t = {}) {
         return e.line ? e.line === !0 ? {} : e.line : e.line !== void 0 ? null : t.line ? t.line === !0 ? {} : t.line : void 0
     }
-    class ope {
+    class lge {
         constructor() {
             this.name = "path-overlay"
         }
         hasMatchingType(t, n) {
-            if (os(t)) {
+            if (Zs(t)) {
                 const {
                     mark: i,
                     encoding: r
-                } = t, a = na(i) ? i : {
+                } = t, s = Vr(i) ? i : {
                     type: i
                 };
-                switch (a.type) {
+                switch (s.type) {
                     case "line":
                     case "rule":
                     case "trail":
-                        return !!Kv(a, n[a.type], r);
+                        return !!$v(s, n[s.type], r);
                     case "area":
-                        return !!Kv(a, n[a.type], r) || !!R$(a, n[a.type])
+                        return !!$v(s, n[s.type], r) || !!X5(s, n[s.type])
                 }
             }
             return !1
         }
         run(t, n, i) {
             const {
                 config: r
             } = n, {
-                params: a,
-                projection: s,
+                params: s,
+                projection: a,
                 mark: o,
-                encoding: l
-            } = t, u = H6(t, ["params", "projection", "mark", "encoding"]), c = sy(l, r), f = na(o) ? o : {
+                name: l,
+                encoding: u,
+                ...c
+            } = t, f = U1(u, r), h = Vr(o) ? o : {
                 type: o
-            }, h = Kv(f, r[f.type], c), d = f.type === "area" && R$(f, r[f.type]), g = [Object.assign(Object.assign({}, a ? {
-                params: a
-            } : {}), {
-                mark: ape(Object.assign(Object.assign({}, f.type === "area" && f.opacity === void 0 && f.fillOpacity === void 0 ? {
-                    opacity: .7
-                } : {}), f)),
-                encoding: Zn(c, ["shape"])
-            })], p = W6(f, c);
-            let m = c;
-            if (p) {
+            }, d = $v(h, r[h.type], f), g = h.type === "area" && X5(h, r[h.type]), p = [{
+                name: l,
+                ...s ? {
+                    params: s
+                } : {},
+                mark: age({
+                    ...h.type === "area" && h.opacity === void 0 && h.fillOpacity === void 0 ? {
+                        opacity: .7
+                    } : {},
+                    ...h
+                }),
+                encoding: Jn(f, ["shape"])
+            }], m = az(h, f);
+            let y = f;
+            if (m) {
                 const {
-                    fieldChannel: y,
-                    offset: v
-                } = p;
-                m = Object.assign(Object.assign({}, c), {
-                    [y]: Object.assign(Object.assign({}, c[y]), v ? {
-                        stack: v
-                    } : {})
-                })
+                    fieldChannel: v,
+                    offset: b
+                } = m;
+                y = {
+                    ...f,
+                    [v]: {
+                        ...f[v],
+                        ...b ? {
+                            stack: b
+                        } : {}
+                    }
+                }
             }
-            return m = Zn(m, ["y2", "x2"]), d && g.push(Object.assign(Object.assign({}, s ? {
-                projection: s
-            } : {}), {
-                mark: Object.assign(Object.assign({
-                    type: "line"
-                }, uc(f, ["clip", "interpolate", "tension", "tooltip"])), d),
-                encoding: m
-            })), h && g.push(Object.assign(Object.assign({}, s ? {
-                projection: s
-            } : {}), {
-                mark: Object.assign(Object.assign({
+            return y = Jn(y, ["y2", "x2"]), g && p.push({
+                ...a ? {
+                    projection: a
+                } : {},
+                mark: {
+                    type: "line",
+                    ...Qu(h, ["clip", "interpolate", "tension", "tooltip"]),
+                    ...g
+                },
+                encoding: y
+            }), d && p.push({
+                ...a ? {
+                    projection: a
+                } : {},
+                mark: {
                     type: "point",
                     opacity: 1,
-                    filled: !0
-                }, uc(f, ["clip", "tooltip"])), h),
-                encoding: m
-            })), i(Object.assign(Object.assign({}, u), {
-                layer: g
-            }), Object.assign(Object.assign({}, n), {
-                config: spe(r)
-            }))
+                    filled: !0,
+                    ...Qu(h, ["clip", "tooltip"]),
+                    ...d
+                },
+                encoding: y
+            }), i({
+                ...c,
+                layer: p
+            }, {
+                ...n,
+                config: oge(r)
+            })
         }
     }
-    var lpe = globalThis && globalThis.__rest || function(e, t) {
-        var n = {};
-        for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && t.indexOf(i) < 0 && (n[i] = e[i]);
-        if (e != null && typeof Object.getOwnPropertySymbols == "function")
-            for (var r = 0, i = Object.getOwnPropertySymbols(e); r < i.length; r++) t.indexOf(i[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, i[r]) && (n[i[r]] = e[i[r]]);
-        return n
-    };
 
-    function upe(e, t) {
-        return t ? Xd(e) ? X6(e, t) : Y6(e, t) : e
+    function uge(e, t) {
+        return t ? Rd(e) ? lz(e, t) : oz(e, t) : e
     }
 
-    function Jv(e, t) {
-        return t ? X6(e, t) : e
+    function Tv(e, t) {
+        return t ? lz(e, t) : e
     }
 
-    function Tx(e, t, n) {
+    function ex(e, t, n) {
         const i = t[e];
-        if (qde(i)) {
-            if (i.repeat in n) return Object.assign(Object.assign({}, t), {
+        if (Vhe(i)) {
+            if (i.repeat in n) return {
+                ...t,
                 [e]: n[i.repeat]
-            });
-            X(qfe(i.repeat));
+            };
+            X(Kce(i.repeat));
             return
         }
         return t
     }
 
-    function Y6(e, t) {
-        if (e = Tx("field", e, t), e !== void 0) {
+    function oz(e, t) {
+        if (e = ex("field", e, t), e !== void 0) {
             if (e === null) return null;
-            if (NO(e) && Yr(e.sort)) {
-                const n = Tx("field", e.sort, t);
-                e = Object.assign(Object.assign({}, e), n ? {
-                    sort: n
-                } : {})
+            if (tC(e) && Br(e.sort)) {
+                const n = ex("field", e.sort, t);
+                e = {
+                    ...e,
+                    ...n ? {
+                        sort: n
+                    } : {}
+                }
             }
             return e
         }
     }
 
-    function P$(e, t) {
-        if (J(e)) return Y6(e, t); {
-            const n = Tx("datum", e, t);
+    function V5(e, t) {
+        if (K(e)) return oz(e, t); {
+            const n = ex("datum", e, t);
             return n !== e && !n.type && (n.type = "nominal"), n
         }
     }
 
-    function N$(e, t) {
-        if (Ee(e)) {
-            const n = P$(e, t);
+    function K5(e, t) {
+        if (Ce(e)) {
+            const n = V5(e, t);
             if (n) return n;
-            if (ty(e)) return {
+            if (L1(e)) return {
                 condition: e.condition
             }
         } else {
-            if (Vd(e)) {
-                const n = P$(e.condition, t);
-                return n ? Object.assign(Object.assign({}, e), {
+            if (Dd(e)) {
+                const n = V5(e.condition, t);
+                if (n) return {
+                    ...e,
                     condition: n
-                }) : lpe(e, ["condition"])
+                }; {
+                    const {
+                        condition: i,
+                        ...r
+                    } = e;
+                    return r
+                }
             }
             return e
         }
     }
 
-    function X6(e, t) {
+    function lz(e, t) {
         const n = {};
         for (const i in e)
-            if (pe(e, i)) {
+            if (me(e, i)) {
                 const r = e[i];
-                if (q(r)) n[i] = r.map(a => N$(a, t)).filter(a => a);
+                if (W(r)) n[i] = r.map(s => K5(s, t)).filter(s => s);
                 else {
-                    const a = N$(r, t);
-                    a !== void 0 && (n[i] = a)
+                    const s = K5(r, t);
+                    s !== void 0 && (n[i] = s)
                 }
             } return n
     }
-    class cpe {
+    class cge {
         constructor() {
             this.name = "RuleForRangedLine"
         }
         hasMatchingType(t) {
-            if (os(t)) {
+            if (Zs(t)) {
                 const {
                     encoding: n,
                     mark: i
                 } = t;
-                if (i === "line" || na(i) && i.type === "line")
-                    for (const r of ufe) {
-                        const a = Hl(r),
-                            s = n[a];
-                        if (n[r] && (J(s) && !Qt(s.bin) || _a(s))) return !0
+                if (i === "line" || Vr(i) && i.type === "line")
+                    for (const r of yce) {
+                        const s = Nl(r),
+                            a = n[s];
+                        if (n[r] && (K(a) && !Xt(a.bin) || fs(a))) return !0
                     }
             }
             return !1
         }
         run(t, n, i) {
             const {
                 encoding: r,
-                mark: a
+                mark: s
             } = t;
-            return X(fhe(!!r.x2, !!r.y2)), i(Object.assign(Object.assign({}, t), {
-                mark: se(a) ? Object.assign(Object.assign({}, a), {
+            return X(yfe(!!r.x2, !!r.y2)), i({
+                ...t,
+                mark: ae(s) ? {
+                    ...s,
                     type: "rule"
-                }) : "rule"
-            }), n)
+                } : "rule"
+            }, n)
         }
     }
-    var fs = globalThis && globalThis.__rest || function(e, t) {
-        var n = {};
-        for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && t.indexOf(i) < 0 && (n[i] = e[i]);
-        if (e != null && typeof Object.getOwnPropertySymbols == "function")
-            for (var r = 0, i = Object.getOwnPropertySymbols(e); r < i.length; r++) t.indexOf(i[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, i[r]) && (n[i[r]] = e[i[r]]);
-        return n
-    };
-    class fpe extends JO {
+    class fge extends mC {
         constructor() {
-            super(...arguments), this.nonFacetUnitNormalizers = [dge, mge, Sge, new ope, new cpe]
+            super(...arguments), this.nonFacetUnitNormalizers = [yde, xde, Ade, new lge, new cge]
         }
         map(t, n) {
-            if (os(t)) {
-                const i = al(t.encoding, Ga),
-                    r = al(t.encoding, Ua),
-                    a = al(t.encoding, z1);
-                if (i || r || a) return this.mapFacetedUnit(t, n)
+            if (Zs(t)) {
+                const i = Ho(t.encoding, Fs),
+                    r = Ho(t.encoding, Rs),
+                    s = Ho(t.encoding, _1);
+                if (i || r || s) return this.mapFacetedUnit(t, n)
             }
             return super.map(t, n)
         }
         mapUnit(t, n) {
             const {
                 parentEncoding: i,
                 parentProjection: r
-            } = n, a = Jv(t.encoding, n.repeater), s = Object.assign(Object.assign({}, t), a ? {
-                encoding: a
-            } : {});
-            if (i || r) return this.mapUnitWithParentEncodingOrProjection(s, n);
+            } = n, s = Tv(t.encoding, n.repeater), a = {
+                ...t,
+                ...t.name ? {
+                    name: [n.repeaterPrefix, t.name].filter(l => l).join("_")
+                } : {},
+                ...s ? {
+                    encoding: s
+                } : {}
+            };
+            if (i || r) return this.mapUnitWithParentEncodingOrProjection(a, n);
             const o = this.mapLayerOrUnit.bind(this);
             for (const l of this.nonFacetUnitNormalizers)
-                if (l.hasMatchingType(s, n.config)) return l.run(s, n, o);
-            return s
+                if (l.hasMatchingType(a, n.config)) return l.run(a, n, o);
+            return a
         }
         mapRepeat(t, n) {
-            return Qge(t) ? this.mapLayerRepeat(t, n) : this.mapNonLayerRepeat(t, n)
+            return ege(t) ? this.mapLayerRepeat(t, n) : this.mapNonLayerRepeat(t, n)
         }
         mapLayerRepeat(t, n) {
             const {
                 repeat: i,
-                spec: r
-            } = t, a = fs(t, ["repeat", "spec"]), {
-                row: s,
+                spec: r,
+                ...s
+            } = t, {
+                row: a,
                 column: o,
                 layer: l
             } = i, {
                 repeater: u = {},
                 repeaterPrefix: c = ""
             } = n;
-            return s || o ? this.mapRepeat(Object.assign(Object.assign({}, t), {
-                repeat: Object.assign(Object.assign({}, s ? {
-                    row: s
-                } : {}), o ? {
-                    column: o
-                } : {}),
+            return a || o ? this.mapRepeat({
+                ...t,
+                repeat: {
+                    ...a ? {
+                        row: a
+                    } : {},
+                    ...o ? {
+                        column: o
+                    } : {}
+                },
                 spec: {
                     repeat: {
                         layer: l
                     },
                     spec: r
                 }
-            }), n) : Object.assign(Object.assign({}, a), {
+            }, n) : {
+                ...s,
                 layer: l.map(f => {
-                    const h = Object.assign(Object.assign({}, u), {
+                    const h = {
+                            ...u,
                             layer: f
-                        }),
-                        d = `${(r.name||"")+c}child__layer_${ht(f)}`,
-                        g = this.mapLayerOrUnit(r, Object.assign(Object.assign({}, n), {
+                        },
+                        d = `${(r.name?`${r.name}_`:"")+c}child__layer_${ft(f)}`,
+                        g = this.mapLayerOrUnit(r, {
+                            ...n,
                             repeater: h,
                             repeaterPrefix: d
-                        }));
+                        });
                     return g.name = d, g
                 })
-            })
+            }
         }
         mapNonLayerRepeat(t, n) {
-            var i;
             const {
-                repeat: r,
-                spec: a,
-                data: s
-            } = t, o = fs(t, ["repeat", "spec", "data"]);
-            !q(r) && t.columns && (t = Zn(t, ["columns"]), X(p$("repeat")));
-            const l = [],
+                repeat: i,
+                spec: r,
+                data: s,
+                ...a
+            } = t;
+            !W(i) && t.columns && (t = Jn(t, ["columns"]), X(T5("repeat")));
+            const o = [],
                 {
-                    repeater: u = {},
-                    repeaterPrefix: c = ""
+                    repeater: l = {},
+                    repeaterPrefix: u = ""
                 } = n,
-                f = !q(r) && r.row || [u ? u.row : null],
-                h = !q(r) && r.column || [u ? u.column : null],
-                d = q(r) && r || [u ? u.repeat : null];
-            for (const p of d)
-                for (const m of f)
-                    for (const y of h) {
-                        const v = {
-                                repeat: p,
-                                row: m,
-                                column: y,
-                                layer: u.layer
+                c = !W(i) && i.row || [l ? l.row : null],
+                f = !W(i) && i.column || [l ? l.column : null],
+                h = W(i) && i || [l ? l.repeat : null];
+            for (const g of h)
+                for (const p of c)
+                    for (const m of f) {
+                        const y = {
+                                repeat: g,
+                                row: p,
+                                column: m,
+                                layer: l.layer
                             },
-                            b = (a.name || "") + c + "child__" + (q(r) ? `${ht(p)}` : (r.row ? `row_${ht(m)}` : "") + (r.column ? `column_${ht(y)}` : "")),
-                            x = this.map(a, Object.assign(Object.assign({}, n), {
-                                repeater: v,
-                                repeaterPrefix: b
-                            }));
-                        x.name = b, l.push(Zn(x, ["data"]))
-                    }
-            const g = q(r) ? t.columns : r.column ? r.column.length : 1;
-            return Object.assign(Object.assign({
-                data: (i = a.data) !== null && i !== void 0 ? i : s,
-                align: "all"
-            }, o), {
-                columns: g,
-                concat: l
-            })
+                            v = (r.name ? `${r.name}_` : "") + u + "child__" + (W(i) ? `${ft(g)}` : (i.row ? `row_${ft(p)}` : "") + (i.column ? `column_${ft(m)}` : "")),
+                            b = this.map(r, {
+                                ...n,
+                                repeater: y,
+                                repeaterPrefix: v
+                            });
+                        b.name = v, o.push(Jn(b, ["data"]))
+                    }
+            const d = W(i) ? t.columns : i.column ? i.column.length : 1;
+            return {
+                data: r.data ?? s,
+                align: "all",
+                ...a,
+                columns: d,
+                concat: o
+            }
         }
         mapFacet(t, n) {
             const {
                 facet: i
             } = t;
-            return Xd(i) && t.columns && (t = Zn(t, ["columns"]), X(p$("facet"))), super.mapFacet(t, n)
+            return Rd(i) && t.columns && (t = Jn(t, ["columns"]), X(T5("facet"))), super.mapFacet(t, n)
         }
         mapUnitWithParentEncodingOrProjection(t, n) {
             const {
                 encoding: i,
                 projection: r
             } = t, {
-                parentEncoding: a,
-                parentProjection: s,
+                parentEncoding: s,
+                parentProjection: a,
                 config: o
-            } = n, l = I$({
-                parentProjection: s,
+            } = n, l = Q5({
+                parentProjection: a,
                 projection: r
-            }), u = L$({
-                parentEncoding: a,
-                encoding: Jv(i, n.repeater)
+            }), u = J5({
+                parentEncoding: s,
+                encoding: Tv(i, n.repeater)
             });
-            return this.mapUnit(Object.assign(Object.assign(Object.assign({}, t), l ? {
-                projection: l
-            } : {}), u ? {
-                encoding: u
-            } : {}), {
+            return this.mapUnit({
+                ...t,
+                ...l ? {
+                    projection: l
+                } : {},
+                ...u ? {
+                    encoding: u
+                } : {}
+            }, {
                 config: o
             })
         }
         mapFacetedUnit(t, n) {
-            const i = t.encoding,
-                {
-                    row: r,
-                    column: a,
-                    facet: s
-                } = i,
-                o = fs(i, ["row", "column", "facet"]),
-                {
-                    mark: l,
-                    width: u,
-                    projection: c,
-                    height: f,
-                    view: h,
-                    params: d,
-                    encoding: g
-                } = t,
-                p = fs(t, ["mark", "width", "projection", "height", "view", "params", "encoding"]),
-                {
-                    facetMapping: m,
-                    layout: y
-                } = this.getFacetMappingAndLayout({
-                    row: r,
-                    column: a,
-                    facet: s
-                }, n),
-                v = Jv(o, n.repeater);
-            return this.mapFacet(Object.assign(Object.assign(Object.assign({}, p), y), {
-                facet: m,
-                spec: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, u ? {
-                    width: u
-                } : {}), f ? {
-                    height: f
-                } : {}), h ? {
-                    view: h
-                } : {}), c ? {
-                    projection: c
-                } : {}), {
-                    mark: l,
-                    encoding: v
-                }), d ? {
-                    params: d
-                } : {})
-            }), n)
+            const {
+                row: i,
+                column: r,
+                facet: s,
+                ...a
+            } = t.encoding, {
+                mark: o,
+                width: l,
+                projection: u,
+                height: c,
+                view: f,
+                params: h,
+                encoding: d,
+                ...g
+            } = t, {
+                facetMapping: p,
+                layout: m
+            } = this.getFacetMappingAndLayout({
+                row: i,
+                column: r,
+                facet: s
+            }, n), y = Tv(a, n.repeater);
+            return this.mapFacet({
+                ...g,
+                ...m,
+                facet: p,
+                spec: {
+                    ...l ? {
+                        width: l
+                    } : {},
+                    ...c ? {
+                        height: c
+                    } : {},
+                    ...f ? {
+                        view: f
+                    } : {},
+                    ...u ? {
+                        projection: u
+                    } : {},
+                    mark: o,
+                    encoding: y,
+                    ...h ? {
+                        params: h
+                    } : {}
+                }
+            }, n)
         }
         getFacetMappingAndLayout(t, n) {
-            var i;
             const {
-                row: r,
-                column: a,
+                row: i,
+                column: r,
                 facet: s
             } = t;
-            if (r || a) {
-                s && X(uhe([...r ? [Ga] : [], ...a ? [Ua] : []]));
-                const o = {},
-                    l = {};
-                for (const u of [Ga, Ua]) {
-                    const c = t[u];
-                    if (c) {
-                        const f = fs(c, ["align", "center", "spacing", "columns"]);
-                        o[u] = f;
-                        for (const h of ["align", "center", "spacing"]) c[h] !== void 0 && ((i = l[h]) !== null && i !== void 0 || (l[h] = {}), l[h][u] = c[h])
+            if (i || r) {
+                s && X(pfe([...i ? [Fs] : [], ...r ? [Rs] : []]));
+                const a = {},
+                    o = {};
+                for (const l of [Fs, Rs]) {
+                    const u = t[l];
+                    if (u) {
+                        const {
+                            align: c,
+                            center: f,
+                            spacing: h,
+                            columns: d,
+                            ...g
+                        } = u;
+                        a[l] = g;
+                        for (const p of ["align", "center", "spacing"]) u[p] !== void 0 && (o[p] ?? (o[p] = {}), o[p][l] = u[p])
                     }
                 }
                 return {
-                    facetMapping: o,
-                    layout: l
+                    facetMapping: a,
+                    layout: o
                 }
             } else {
                 const {
-                    align: o,
-                    center: l,
-                    spacing: u,
-                    columns: c
-                } = s, f = fs(s, ["align", "center", "spacing", "columns"]);
+                    align: a,
+                    center: o,
+                    spacing: l,
+                    columns: u,
+                    ...c
+                } = s;
                 return {
-                    facetMapping: upe(f, n.repeater),
-                    layout: Object.assign(Object.assign(Object.assign(Object.assign({}, o ? {
-                        align: o
-                    } : {}), l ? {
-                        center: l
-                    } : {}), u ? {
-                        spacing: u
-                    } : {}), c ? {
-                        columns: c
-                    } : {})
+                    facetMapping: uge(c, n.repeater),
+                    layout: {
+                        ...a ? {
+                            align: a
+                        } : {},
+                        ...o ? {
+                            center: o
+                        } : {},
+                        ...l ? {
+                            spacing: l
+                        } : {},
+                        ...u ? {
+                            columns: u
+                        } : {}
+                    }
                 }
             }
         }
-        mapLayer(t, n) {
-            var {
-                parentEncoding: i,
-                parentProjection: r
-            } = n, a = fs(n, ["parentEncoding", "parentProjection"]);
+        mapLayer(t, {
+            parentEncoding: n,
+            parentProjection: i,
+            ...r
+        }) {
             const {
                 encoding: s,
-                projection: o
-            } = t, l = fs(t, ["encoding", "projection"]), u = Object.assign(Object.assign({}, a), {
-                parentEncoding: L$({
-                    parentEncoding: i,
+                projection: a,
+                ...o
+            } = t, l = {
+                ...r,
+                parentEncoding: J5({
+                    parentEncoding: n,
                     encoding: s,
                     layer: !0
                 }),
-                parentProjection: I$({
-                    parentProjection: r,
-                    projection: o
+                parentProjection: Q5({
+                    parentProjection: i,
+                    projection: a
                 })
-            });
-            return super.mapLayer(l, u)
+            };
+            return super.mapLayer({
+                ...o,
+                ...t.name ? {
+                    name: [l.repeaterPrefix, t.name].filter(u => u).join("_")
+                } : {}
+            }, l)
         }
     }
 
-    function L$({
+    function J5({
         parentEncoding: e,
         encoding: t = {},
         layer: n
     }) {
         let i = {};
         if (e) {
-            const r = new Set([...Y(e), ...Y(t)]);
-            for (const a of r) {
-                const s = t[a],
-                    o = e[a];
-                if (Ee(s)) {
-                    const l = Object.assign(Object.assign({}, o), s);
-                    i[a] = l
-                } else Vd(s) ? i[a] = Object.assign(Object.assign({}, s), {
-                    condition: Object.assign(Object.assign({}, o), s.condition)
-                }) : s || s === null ? i[a] = s : (n || wr(o) || fe(o) || Ee(o) || q(o)) && (i[a] = o)
+            const r = new Set([...H(e), ...H(t)]);
+            for (const s of r) {
+                const a = t[s],
+                    o = e[s];
+                if (Ce(a)) {
+                    const l = {
+                        ...o,
+                        ...a
+                    };
+                    i[s] = l
+                } else Dd(a) ? i[s] = {
+                    ...a,
+                    condition: {
+                        ...o,
+                        ...a.condition
+                    }
+                } : a || a === null ? i[s] = a : (n || gr(o) || he(o) || Ce(o) || W(o)) && (i[s] = o)
             }
         } else i = t;
         return !i || et(i) ? void 0 : i
     }
 
-    function I$(e) {
+    function Q5(e) {
         const {
             parentProjection: t,
             projection: n
         } = e;
-        return t && n && X(Kfe({
+        return t && n && X(nfe({
             parentProjection: t,
             projection: n
         })), n ?? t
     }
 
-    function QO(e) {
+    function yC(e) {
         return "filter" in e
     }
 
-    function hpe(e) {
+    function hge(e) {
         return (e == null ? void 0 : e.stop) !== void 0
     }
 
-    function V6(e) {
+    function uz(e) {
         return "lookup" in e
     }
 
-    function dpe(e) {
+    function dge(e) {
         return "data" in e
     }
 
-    function gpe(e) {
+    function gge(e) {
         return "param" in e
     }
 
-    function ppe(e) {
+    function pge(e) {
         return "pivot" in e
     }
 
-    function mpe(e) {
+    function mge(e) {
         return "density" in e
     }
 
-    function ype(e) {
+    function yge(e) {
         return "quantile" in e
     }
 
-    function vpe(e) {
+    function vge(e) {
         return "regression" in e
     }
 
-    function bpe(e) {
+    function bge(e) {
         return "loess" in e
     }
 
-    function xpe(e) {
+    function xge(e) {
         return "sample" in e
     }
 
-    function _pe(e) {
+    function _ge(e) {
         return "window" in e
     }
 
-    function wpe(e) {
+    function wge(e) {
         return "joinaggregate" in e
     }
 
-    function Spe(e) {
+    function Sge(e) {
         return "flatten" in e
     }
 
-    function Epe(e) {
+    function Ege(e) {
         return "calculate" in e
     }
 
-    function K6(e) {
+    function cz(e) {
         return "bin" in e
     }
 
-    function Ope(e) {
+    function Cge(e) {
         return "impute" in e
     }
 
-    function Cpe(e) {
+    function kge(e) {
         return "timeUnit" in e
     }
 
-    function kpe(e) {
+    function Age(e) {
         return "aggregate" in e
     }
 
-    function Ape(e) {
+    function $ge(e) {
         return "stack" in e
     }
 
-    function Tpe(e) {
+    function Tge(e) {
         return "fold" in e
     }
 
-    function $pe(e) {
-        return e.map(t => QO(t) ? {
-            filter: Pu(t.filter, ide)
+    function Mge(e) {
+        return e.map(t => yC(t) ? {
+            filter: Eu(t.filter, uhe)
         } : t)
     }
-    var Ls = globalThis && globalThis.__rest || function(e, t) {
-        var n = {};
-        for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && t.indexOf(i) < 0 && (n[i] = e[i]);
-        if (e != null && typeof Object.getOwnPropertySymbols == "function")
-            for (var r = 0, i = Object.getOwnPropertySymbols(e); r < i.length; r++) t.indexOf(i[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, i[r]) && (n[i[r]] = e[i[r]]);
-        return n
-    };
-    class Mpe extends JO {
+    class Oge extends mC {
         map(t, n) {
-            var i, r;
-            return (i = n.emptySelections) !== null && i !== void 0 || (n.emptySelections = {}), (r = n.selectionPredicates) !== null && r !== void 0 || (n.selectionPredicates = {}), t = j$(t, n), super.map(t, n)
+            return n.emptySelections ?? (n.emptySelections = {}), n.selectionPredicates ?? (n.selectionPredicates = {}), t = Z5(t, n), super.map(t, n)
         }
         mapLayerOrUnit(t, n) {
-            if (t = j$(t, n), t.encoding) {
+            if (t = Z5(t, n), t.encoding) {
                 const i = {};
-                for (const [r, a] of Ks(t.encoding)) i[r] = J6(a, n);
-                t = Object.assign(Object.assign({}, t), {
+                for (const [r, s] of Ba(t.encoding)) i[r] = fz(s, n);
+                t = {
+                    ...t,
                     encoding: i
-                })
+                }
             }
             return super.mapLayerOrUnit(t, n)
         }
         mapUnit(t, n) {
-            const i = t,
-                {
-                    selection: r
-                } = i,
-                a = Ls(i, ["selection"]);
-            return r ? Object.assign(Object.assign({}, a), {
-                params: Ks(r).map(([s, o]) => {
-                    var l;
-                    const u = o,
-                        {
-                            init: c,
-                            bind: f,
-                            empty: h
-                        } = u,
-                        d = Ls(u, ["init", "bind", "empty"]);
-                    d.type === "single" ? (d.type = "point", d.toggle = !1) : d.type === "multi" && (d.type = "point"), n.emptySelections[s] = h !== "none";
-                    for (const g of _n((l = n.selectionPredicates[s]) !== null && l !== void 0 ? l : {})) g.empty = h !== "none";
+            const {
+                selection: i,
+                ...r
+            } = t;
+            return i ? {
+                ...r,
+                params: Ba(i).map(([s, a]) => {
+                    const {
+                        init: o,
+                        bind: l,
+                        empty: u,
+                        ...c
+                    } = a;
+                    c.type === "single" ? (c.type = "point", c.toggle = !1) : c.type === "multi" && (c.type = "point"), n.emptySelections[s] = u !== "none";
+                    for (const f of Qt(n.selectionPredicates[s] ?? {})) f.empty = u !== "none";
                     return {
                         name: s,
-                        value: c,
-                        select: d,
-                        bind: f
+                        value: o,
+                        select: c,
+                        bind: l
                     }
                 })
-            }) : t
+            } : t
         }
     }
 
-    function j$(e, t) {
+    function Z5(e, t) {
         const {
-            transform: n
-        } = e, i = Ls(e, ["transform"]);
+            transform: n,
+            ...i
+        } = e;
         if (n) {
-            const r = n.map(a => {
-                if (QO(a)) return {
-                    filter: $x(a, t)
+            const r = n.map(s => {
+                if (yC(s)) return {
+                    filter: tx(s, t)
                 };
-                if (K6(a) && Yl(a.bin)) return Object.assign(Object.assign({}, a), {
-                    bin: Q6(a.bin)
-                });
-                if (V6(a)) {
-                    const s = a.from,
-                        {
-                            selection: o
-                        } = s,
-                        l = Ls(s, ["selection"]);
-                    return o ? Object.assign(Object.assign({}, a), {
-                        from: Object.assign({
-                            param: o
-                        }, l)
-                    }) : a
+                if (cz(s) && Pl(s.bin)) return {
+                    ...s,
+                    bin: hz(s.bin)
+                };
+                if (uz(s)) {
+                    const {
+                        selection: a,
+                        ...o
+                    } = s.from;
+                    return a ? {
+                        ...s,
+                        from: {
+                            param: a,
+                            ...o
+                        }
+                    } : s
                 }
-                return a
+                return s
             });
-            return Object.assign(Object.assign({}, i), {
+            return {
+                ...i,
                 transform: r
-            })
+            }
         }
         return e
     }
 
-    function J6(e, t) {
-        var n, i;
-        const r = Ce(e);
-        if (J(r) && Yl(r.bin) && (r.bin = Q6(r.bin)), Vl(r) && (!((i = (n = r.scale) === null || n === void 0 ? void 0 : n.domain) === null || i === void 0) && i.selection)) {
-            const a = r.scale.domain,
-                {
-                    selection: s
-                } = a,
-                o = Ls(a, ["selection"]);
-            r.scale.domain = Object.assign(Object.assign({}, o), s ? {
-                param: s
-            } : {})
+    function fz(e, t) {
+        var i, r;
+        const n = ke(e);
+        if (K(n) && Pl(n.bin) && (n.bin = hz(n.bin)), Il(n) && ((r = (i = n.scale) == null ? void 0 : i.domain) != null && r.selection)) {
+            const {
+                selection: s,
+                ...a
+            } = n.scale.domain;
+            n.scale.domain = {
+                ...a,
+                ...s ? {
+                    param: s
+                } : {}
+            }
         }
-        if (ty(r))
-            if (q(r.condition)) r.condition = r.condition.map(a => {
+        if (L1(n))
+            if (W(n.condition)) n.condition = n.condition.map(s => {
                 const {
-                    selection: s,
+                    selection: a,
                     param: o,
-                    test: l
-                } = a, u = Ls(a, ["selection", "param", "test"]);
-                return o ? a : Object.assign(Object.assign({}, u), {
-                    test: $x(a, t)
-                })
+                    test: l,
+                    ...u
+                } = s;
+                return o ? s : {
+                    ...u,
+                    test: tx(s, t)
+                }
             });
             else {
-                const a = J6(r.condition, t),
-                    {
-                        selection: s,
-                        param: o,
-                        test: l
-                    } = a,
-                    u = Ls(a, ["selection", "param", "test"]);
-                r.condition = o ? r.condition : Object.assign(Object.assign({}, u), {
-                    test: $x(r.condition, t)
-                })
-            } return r
+                const {
+                    selection: s,
+                    param: a,
+                    test: o,
+                    ...l
+                } = fz(n.condition, t);
+                n.condition = a ? n.condition : {
+                    ...l,
+                    test: tx(n.condition, t)
+                }
+            } return n
     }
 
-    function Q6(e) {
+    function hz(e) {
         const t = e.extent;
         if (t != null && t.selection) {
             const {
-                selection: n
-            } = t, i = Ls(t, ["selection"]);
-            return Object.assign(Object.assign({}, e), {
-                extent: Object.assign(Object.assign({}, i), {
+                selection: n,
+                ...i
+            } = t;
+            return {
+                ...e,
+                extent: {
+                    ...i,
                     param: n
-                })
-            })
+                }
+            }
         }
         return e
     }
 
-    function $x(e, t) {
-        const n = i => Pu(i, r => {
-            var a, s, o;
-            const l = (a = t.emptySelections[r]) !== null && a !== void 0 ? a : !0,
-                u = {
+    function tx(e, t) {
+        const n = i => Eu(i, r => {
+            var s;
+            const a = t.emptySelections[r] ?? !0,
+                o = {
                     param: r,
-                    empty: l
+                    empty: a
                 };
-            return (s = (o = t.selectionPredicates)[r]) !== null && s !== void 0 || (o[r] = []), t.selectionPredicates[r].push(u), u
+            return (s = t.selectionPredicates)[r] ?? (s[r] = []), t.selectionPredicates[r].push(o), o
         });
-        return e.selection ? n(e.selection) : Pu(e.test || e.filter, i => i.selection ? n(i.selection) : i)
+        return e.selection ? n(e.selection) : Eu(e.test || e.filter, i => i.selection ? n(i.selection) : i)
     }
-    class Mx extends JO {
+    class nx extends mC {
         map(t, n) {
-            var i;
-            const r = (i = n.selections) !== null && i !== void 0 ? i : [];
-            if (t.params && !os(t)) {
-                const a = [];
-                for (const s of t.params) XO(s) ? r.push(s) : a.push(s);
-                t.params = a
+            const i = n.selections ?? [];
+            if (t.params && !Zs(t)) {
+                const r = [];
+                for (const s of t.params) dC(s) ? i.push(s) : r.push(s);
+                t.params = r
             }
-            return n.selections = r, super.map(t, Z6(t, n))
+            return n.selections = i, super.map(t, n)
         }
         mapUnit(t, n) {
-            var i;
-            const r = n.selections;
-            if (!r || !r.length) return t;
-            const a = ((i = n.path) !== null && i !== void 0 ? i : []).concat(t.name),
+            const i = n.selections;
+            if (!i || !i.length) return t;
+            const r = (n.path ?? []).concat(t.name),
                 s = [];
-            for (const o of r)
-                if (!o.views || !o.views.length) s.push(o);
+            for (const a of i)
+                if (!a.views || !a.views.length) s.push(a);
                 else
-                    for (const l of o.views)(re(l) && (l === t.name || a.indexOf(l) >= 0) || q(l) && l.map(u => a.indexOf(u)).every((u, c, f) => u !== -1 && (c === 0 || u > f[c - 1]))) && s.push(o);
+                    for (const o of a.views)(re(o) && (o === t.name || r.includes(o)) || W(o) && o.map(l => r.indexOf(l)).every((l, u, c) => l !== -1 && (u === 0 || l > c[u - 1]))) && s.push(a);
             return s.length && (t.params = s), t
         }
     }
     for (const e of ["mapFacet", "mapRepeat", "mapHConcat", "mapVConcat", "mapLayer"]) {
-        const t = Mx.prototype[e];
-        Mx.prototype[e] = function(n, i) {
-            return t.call(this, n, Z6(n, i))
+        const t = nx.prototype[e];
+        nx.prototype[e] = function(n, i) {
+            return t.call(this, n, Fge(n, i))
         }
     }
 
-    function Z6(e, t) {
-        var n;
-        return e.name ? Object.assign(Object.assign({}, t), {
-            path: ((n = t.path) !== null && n !== void 0 ? n : []).concat(e.name)
-        }) : t
+    function Fge(e, t) {
+        return e.name ? {
+            ...t,
+            path: (t.path ?? []).concat(e.name)
+        } : t
     }
 
-    function ez(e, t) {
-        t === void 0 && (t = q6(e.config));
-        const n = Ppe(e, t),
+    function dz(e, t) {
+        t === void 0 && (t = sz(e.config));
+        const n = Pge(e, t),
             {
                 width: i,
                 height: r
             } = e,
-            a = Npe(n, {
+            s = Lge(n, {
                 width: i,
                 height: r,
                 autosize: e.autosize
             }, t);
-        return Object.assign(Object.assign({}, n), a ? {
-            autosize: a
-        } : {})
+        return {
+            ...n,
+            ...s ? {
+                autosize: s
+            } : {}
+        }
     }
-    const Fpe = new fpe,
-        Dpe = new Mpe,
-        Rpe = new Mx;
+    const Rge = new fge,
+        Dge = new Oge,
+        Nge = new nx;
 
-    function Ppe(e, t = {}) {
+    function Pge(e, t = {}) {
         const n = {
             config: t
         };
-        return Rpe.map(Fpe.map(Dpe.map(e, n), n), n)
+        return Nge.map(Rge.map(Dge.map(e, n), n), n)
     }
 
-    function z$(e) {
+    function e3(e) {
         return re(e) ? {
             type: e
         } : e ?? {}
     }
 
-    function Npe(e, t, n) {
+    function Lge(e, t, n) {
         let {
             width: i,
             height: r
         } = t;
-        const a = os(e) || ly(e),
-            s = {};
-        a ? i == "container" && r == "container" ? (s.type = "fit", s.contains = "padding") : i == "container" ? (s.type = "fit-x", s.contains = "padding") : r == "container" && (s.type = "fit-y", s.contains = "padding") : (i == "container" && (X(f$("width")), i = void 0), r == "container" && (X(f$("height")), r = void 0));
-        const o = Object.assign(Object.assign(Object.assign({
-            type: "pad"
-        }, s), n ? z$(n.autosize) : {}), z$(e.autosize));
-        if (o.type === "fit" && !a && (X(Rfe), o.type = "pad"), i == "container" && !(o.type == "fit" || o.type == "fit-x") && X(h$("width")), r == "container" && !(o.type == "fit" || o.type == "fit-y") && X(h$("height")), !Br(o, {
+        const s = Zs(e) || W1(e),
+            a = {};
+        s ? i == "container" && r == "container" ? (a.type = "fit", a.contains = "padding") : i == "container" ? (a.type = "fit-x", a.contains = "padding") : r == "container" && (a.type = "fit-y", a.contains = "padding") : (i == "container" && (X(C5("width")), i = void 0), r == "container" && (X(C5("height")), r = void 0));
+        const o = {
+            type: "pad",
+            ...a,
+            ...n ? e3(n.autosize) : {},
+            ...e3(e.autosize)
+        };
+        if (o.type === "fit" && !s && (X(Bce), o.type = "pad"), i == "container" && !(o.type == "fit" || o.type == "fit-x") && X(k5("width")), r == "container" && !(o.type == "fit" || o.type == "fit-y") && X(k5("height")), !Nr(o, {
                 type: "pad"
             })) return o
     }
 
-    function Lpe(e) {
+    function Ige(e) {
         return e === "fit" || e === "fit-x" || e === "fit-y"
     }
 
-    function Ipe(e) {
-        return e ? `fit-${W1(e)}` : "fit"
+    function zge(e) {
+        return e ? `fit-${k1(e)}` : "fit"
     }
-    const jpe = ["background", "padding"];
+    const Bge = ["background", "padding"];
 
-    function B$(e, t) {
+    function t3(e, t) {
         const n = {};
-        for (const i of jpe) e && e[i] !== void 0 && (n[i] = pi(e[i]));
+        for (const i of Bge) e && e[i] !== void 0 && (n[i] = di(e[i]));
         return t && (n.params = e.params), n
     }
-    class ls {
+    class ea {
         constructor(t = {}, n = {}) {
             this.explicit = t, this.implicit = n
         }
         clone() {
-            return new ls(Ce(this.explicit), Ce(this.implicit))
+            return new ea(ke(this.explicit), ke(this.implicit))
         }
         combine() {
-            return Object.assign(Object.assign({}, this.explicit), this.implicit)
+            return {
+                ...this.explicit,
+                ...this.implicit
+            }
         }
         get(t) {
-            return Tt(this.explicit[t], this.implicit[t])
+            return Ct(this.explicit[t], this.implicit[t])
         }
         getWithExplicit(t) {
             return this.explicit[t] !== void 0 ? {
                 explicit: !0,
                 value: this.explicit[t]
             } : this.implicit[t] !== void 0 ? {
                 explicit: !1,
@@ -42249,221 +42475,220 @@
         }) {
             n[t] !== void 0 ? this.set(t, n[t], !0) : i[t] !== void 0 && this.set(t, i[t], !1)
         }
         copyKeyFromObject(t, n) {
             n[t] !== void 0 && this.set(t, n[t], !0)
         }
         copyAll(t) {
-            for (const n of Y(t.combine())) {
+            for (const n of H(t.combine())) {
                 const i = t.getWithExplicit(n);
                 this.setWithExplicit(n, i)
             }
         }
     }
 
-    function Pr(e) {
+    function Mr(e) {
         return {
             explicit: !0,
             value: e
         }
     }
 
-    function hi(e) {
+    function ci(e) {
         return {
             explicit: !1,
             value: e
         }
     }
 
-    function tz(e) {
+    function gz(e) {
         return (t, n, i, r) => {
-            const a = e(t.value, n.value);
-            return a > 0 ? t : a < 0 ? n : uy(t, n, i, r)
+            const s = e(t.value, n.value);
+            return s > 0 ? t : s < 0 ? n : q1(t, n, i, r)
         }
     }
 
-    function uy(e, t, n, i) {
-        return e.explicit && t.explicit && X(_he(n, i, e.value, t.value)), e
+    function q1(e, t, n, i) {
+        return e.explicit && t.explicit && X(Afe(n, i, e.value, t.value)), e
     }
 
-    function Qs(e, t, n, i, r = uy) {
-        return e === void 0 || e.value === void 0 ? t : e.explicit && !t.explicit ? e : t.explicit && !e.explicit ? t : Br(e.value, t.value) ? e : r(e, t, n, i)
+    function Ua(e, t, n, i, r = q1) {
+        return e === void 0 || e.value === void 0 ? t : e.explicit && !t.explicit ? e : t.explicit && !e.explicit ? t : Nr(e.value, t.value) ? e : r(e, t, n, i)
     }
-    class zpe extends ls {
+    class jge extends ea {
         constructor(t = {}, n = {}, i = !1) {
             super(t, n), this.explicit = t, this.implicit = n, this.parseNothing = i
         }
         clone() {
             const t = super.clone();
             return t.parseNothing = this.parseNothing, t
         }
     }
 
-    function yc(e) {
+    function oc(e) {
         return "url" in e
     }
 
-    function Zh(e) {
+    function Bh(e) {
         return "values" in e
     }
 
-    function nz(e) {
-        return "name" in e && !yc(e) && !Zh(e) && !Is(e)
+    function pz(e) {
+        return "name" in e && !oc(e) && !Bh(e) && !$a(e)
     }
 
-    function Is(e) {
-        return e && (iz(e) || rz(e) || ZO(e))
+    function $a(e) {
+        return e && (mz(e) || yz(e) || vC(e))
     }
 
-    function iz(e) {
+    function mz(e) {
         return "sequence" in e
     }
 
-    function rz(e) {
+    function yz(e) {
         return "sphere" in e
     }
 
-    function ZO(e) {
+    function vC(e) {
         return "graticule" in e
     }
     var st;
     (function(e) {
         e[e.Raw = 0] = "Raw", e[e.Main = 1] = "Main", e[e.Row = 2] = "Row", e[e.Column = 3] = "Column", e[e.Lookup = 4] = "Lookup"
     })(st || (st = {}));
-    var Bpe = globalThis && globalThis.__rest || function(e, t) {
-        var n = {};
-        for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && t.indexOf(i) < 0 && (n[i] = e[i]);
-        if (e != null && typeof Object.getOwnPropertySymbols == "function")
-            for (var r = 0, i = Object.getOwnPropertySymbols(e); r < i.length; r++) t.indexOf(i[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, i[r]) && (n[i[r]] = e[i[r]]);
-        return n
-    };
 
-    function Cl(e, t = !0, n = wn) {
-        if (q(e)) {
-            const i = e.map(r => Cl(r, t, n));
+    function vz(e) {
+        const {
+            signals: t,
+            hasLegend: n,
+            index: i,
+            ...r
+        } = e;
+        return r.field = Pi(r.field), r
+    }
+
+    function pl(e, t = !0, n = bn) {
+        if (W(e)) {
+            const i = e.map(r => pl(r, t, n));
             return t ? `[${i.join(", ")}]` : i
-        } else if (Xl(e)) return n(t ? Qh(e) : Hhe(e));
-        return t ? n(ot(e)) : e
+        } else if (Ll(e)) return n(t ? fl(e) : Qfe(e));
+        return t ? n(at(e)) : e
     }
 
-    function Gpe(e, t) {
-        var n;
-        for (const i of _n((n = e.component.selection) !== null && n !== void 0 ? n : {})) {
-            const r = i.name;
-            let a = `${r}${to}, ${i.resolve==="global"?"true":`{unit: ${vc(e)}}`}`;
-            for (const s of fy) s.defined(i) && (s.signals && (t = s.signals(e, i, t)), s.modifyExpr && (a = s.modifyExpr(e, i, a)));
+    function Uge(e, t) {
+        for (const n of Qt(e.component.selection ?? {})) {
+            const i = n.name;
+            let r = `${i}${Wa}, ${n.resolve==="global"?"true":`{unit: ${Yo(e)}}`}`;
+            for (const s of Y1) s.defined(n) && (s.signals && (t = s.signals(e, n, t)), s.modifyExpr && (r = s.modifyExpr(e, n, r)));
             t.push({
-                name: r + _0e,
+                name: i + xpe,
                 on: [{
                     events: {
-                        signal: i.name + to
+                        signal: n.name + Wa
                     },
-                    update: `modify(${Z(i.name+kl)}, ${a})`
+                    update: `modify(${Z(n.name+ml)}, ${r})`
                 }]
             })
         }
-        return eC(t)
+        return bC(t)
     }
 
-    function Upe(e, t) {
-        if (e.component.selection && Y(e.component.selection).length) {
+    function Gge(e, t) {
+        if (e.component.selection && H(e.component.selection).length) {
             const n = Z(e.getName("cell"));
             t.unshift({
                 name: "facet",
                 value: {},
                 on: [{
-                    events: ho("mousemove", "scope"),
+                    events: to("mousemove", "scope"),
                     update: `isTuple(facet) ? facet : group(${n}).datum`
                 }]
             })
         }
-        return eC(t)
+        return bC(t)
     }
 
-    function qpe(e, t) {
-        var n;
-        let i = !1;
-        for (const r of _n((n = e.component.selection) !== null && n !== void 0 ? n : {})) {
-            const a = r.name,
-                s = Z(a + kl);
-            if (t.filter(l => l.name === a).length === 0) {
-                const l = r.resolve === "global" ? "union" : r.resolve,
-                    u = r.type === "point" ? ", true, true)" : ")";
+    function Wge(e, t) {
+        let n = !1;
+        for (const i of Qt(e.component.selection ?? {})) {
+            const r = i.name,
+                s = Z(r + ml);
+            if (t.filter(o => o.name === r).length === 0) {
+                const o = i.resolve === "global" ? "union" : i.resolve,
+                    l = i.type === "point" ? ", true, true)" : ")";
                 t.push({
-                    name: r.name,
-                    update: `${xz}(${s}, ${Z(l)}${u}`
+                    name: i.name,
+                    update: `${Nz}(${s}, ${Z(o)}${l}`
                 })
             }
-            i = !0;
-            for (const l of fy) l.defined(r) && l.topLevelSignals && (t = l.topLevelSignals(e, r, t))
+            n = !0;
+            for (const o of Y1) o.defined(i) && o.topLevelSignals && (t = o.topLevelSignals(e, i, t))
         }
-        return i && t.filter(a => a.name === "unit").length === 0 && t.unshift({
+        return n && t.filter(r => r.name === "unit").length === 0 && t.unshift({
             name: "unit",
             value: {},
             on: [{
                 events: "mousemove",
                 update: "isTuple(group()) ? group() : unit"
             }]
-        }), eC(t)
+        }), bC(t)
     }
 
-    function Wpe(e, t) {
-        var n;
-        const i = [...t],
-            r = vc(e, {
+    function qge(e, t) {
+        const n = [...t],
+            i = Yo(e, {
                 escape: !1
             });
-        for (const a of _n((n = e.component.selection) !== null && n !== void 0 ? n : {})) {
+        for (const r of Qt(e.component.selection ?? {})) {
             const s = {
-                name: a.name + kl
+                name: r.name + ml
             };
-            if (a.project.hasSelectionId && (s.transform = [{
+            if (r.project.hasSelectionId && (s.transform = [{
                     type: "collect",
                     sort: {
-                        field: ra
+                        field: pr
                     }
-                }]), a.init) {
-                const l = a.project.items.map(u => Bpe(u, ["signals"]));
-                s.values = a.project.hasSelectionId ? a.init.map(u => ({
-                    unit: r,
-                    [ra]: Cl(u, !1)[0]
-                })) : a.init.map(u => ({
-                    unit: r,
-                    fields: l,
-                    values: Cl(u, !1)
+                }]), r.init) {
+                const o = r.project.items.map(vz);
+                s.values = r.project.hasSelectionId ? r.init.map(l => ({
+                    unit: i,
+                    [pr]: pl(l, !1)[0]
+                })) : r.init.map(l => ({
+                    unit: i,
+                    fields: o,
+                    values: pl(l, !1)
                 }))
             }
-            i.filter(l => l.name === a.name + kl).length || i.push(s)
+            n.filter(o => o.name === r.name + ml).length || n.push(s)
         }
-        return i
+        return n
     }
 
-    function az(e, t) {
-        var n;
-        for (const i of _n((n = e.component.selection) !== null && n !== void 0 ? n : {}))
-            for (const r of fy) r.defined(i) && r.marks && (t = r.marks(e, i, t));
+    function bz(e, t) {
+        for (const n of Qt(e.component.selection ?? {}))
+            for (const i of Y1) i.defined(n) && i.marks && (t = i.marks(e, n, t));
         return t
     }
 
-    function Hpe(e, t) {
-        for (const n of e.children) kt(n) && (t = az(n, t));
+    function Hge(e, t) {
+        for (const n of e.children) Et(n) && (t = bz(n, t));
         return t
     }
 
-    function Ype(e, t, n, i) {
-        const r = Oz(e, t.param, t);
+    function Yge(e, t, n, i) {
+        const r = Bz(e, t.param, t);
         return {
-            signal: Ei(n.get("type")) && q(i) && i[0] > i[1] ? `isValid(${r}) && reverse(${r})` : r
+            signal: wi(n.get("type")) && W(i) && i[0] > i[1] ? `isValid(${r}) && reverse(${r})` : r
         }
     }
 
-    function eC(e) {
+    function bC(e) {
         return e.map(t => (t.on && !t.on.length && delete t.on, t))
     }
-    class it {
+    class nt {
         constructor(t, n) {
             this.debugName = n, this._children = [], this._parent = null, t && (this.parent = t)
         }
         clone() {
             throw new Error("Cannot clone node")
         }
         get parent() {
@@ -42476,15 +42701,15 @@
             return this._children
         }
         numChildren() {
             return this._children.length
         }
         addChild(t, n) {
             if (this._children.includes(t)) {
-                X(Yfe);
+                X(Zce);
                 return
             }
             n !== void 0 ? this._children.splice(n, 0, t) : this._children.push(t)
         }
         removeChild(t) {
             const n = this._children.indexOf(t);
             return this._children.splice(n, 1), n
@@ -42502,939 +42727,1012 @@
                 n = t.parent;
             for (const r of this._children) r.parent = t;
             this._children = [], t.removeChild(this);
             const i = t.parent.removeChild(t);
             this._parent = n, n.addChild(this, i), t.parent = this
         }
     }
-    class Ln extends it {
+    class Dn extends nt {
         clone() {
             const t = new this.constructor;
             return t.debugName = `clone_${this.debugName}`, t._source = this._source, t._name = `clone_${this._name}`, t.type = this.type, t.refCounts = this.refCounts, t.refCounts[t._name] = 0, t
         }
         constructor(t, n, i, r) {
             super(t, n), this.type = i, this.refCounts = r, this._source = this._name = n, this.refCounts && !(this._name in this.refCounts) && (this.refCounts[this._name] = 0)
         }
         dependentFields() {
             return new Set
         }
         producedFields() {
             return new Set
         }
         hash() {
-            return this._hash === void 0 && (this._hash = `Output ${aj()}`), this._hash
+            return this._hash === void 0 && (this._hash = `Output ${yI()}`), this._hash
         }
         getSource() {
             return this.refCounts[this._name]++, this._source
         }
         isRequired() {
             return !!this.refCounts[this._name]
         }
         setSource(t) {
             this._source = t
         }
     }
-    var G$ = globalThis && globalThis.__rest || function(e, t) {
-        var n = {};
-        for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && t.indexOf(i) < 0 && (n[i] = e[i]);
-        if (e != null && typeof Object.getOwnPropertySymbols == "function")
-            for (var r = 0, i = Object.getOwnPropertySymbols(e); r < i.length; r++) t.indexOf(i[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, i[r]) && (n[i[r]] = e[i[r]]);
-        return n
-    };
-    class Xr extends it {
+    class jr extends nt {
         clone() {
-            return new Xr(null, Ce(this.formula))
+            return new jr(null, ke(this.formula))
         }
         constructor(t, n) {
             super(t), this.formula = n
         }
         static makeFromEncoding(t, n) {
-            const i = n.reduceFieldDef((r, a) => {
+            const i = n.reduceFieldDef((r, s) => {
                 const {
-                    field: s,
+                    field: a,
                     timeUnit: o
-                } = a;
+                } = s;
                 if (o) {
-                    const l = ne(a, {
+                    const l = ie(s, {
                         forAs: !0
                     });
-                    r[Ie({
+                    r[Ne({
                         as: l,
-                        field: s,
+                        field: a,
                         timeUnit: o
                     })] = {
                         as: l,
-                        field: s,
+                        field: a,
                         timeUnit: o
                     }
                 }
                 return r
             }, {});
-            return et(i) ? null : new Xr(t, i)
+            return et(i) ? null : new jr(t, i)
         }
         static makeFromTransform(t, n) {
-            const i = Object.assign({}, n),
-                {
-                    timeUnit: r
-                } = i,
-                a = G$(i, ["timeUnit"]),
-                s = En(r),
-                o = Object.assign(Object.assign({}, a), {
-                    timeUnit: s
-                });
-            return new Xr(t, {
-                [Ie(o)]: o
+            const {
+                timeUnit: i,
+                ...r
+            } = {
+                ...n
+            }, s = en(i), a = {
+                ...r,
+                timeUnit: s
+            };
+            return new jr(t, {
+                [Ne(a)]: a
             })
         }
         merge(t) {
-            this.formula = Object.assign({}, this.formula);
+            this.formula = {
+                ...this.formula
+            };
             for (const n in t.formula) this.formula[n] || (this.formula[n] = t.formula[n]);
             for (const n of t.children) t.removeChild(n), n.parent = this;
             t.remove()
         }
         removeFormulas(t) {
             const n = {};
-            for (const [i, r] of Ks(this.formula)) t.has(r.as) || (n[i] = r);
+            for (const [i, r] of Ba(this.formula)) t.has(r.as) || (n[i] = r);
             this.formula = n
         }
         producedFields() {
-            return new Set(_n(this.formula).map(t => t.as))
+            return new Set(Qt(this.formula).map(t => t.as))
         }
         dependentFields() {
-            return new Set(_n(this.formula).map(t => t.field))
+            return new Set(Qt(this.formula).map(t => t.field))
         }
         hash() {
-            return `TimeUnit ${Ie(this.formula)}`
+            return `TimeUnit ${Ne(this.formula)}`
         }
         assemble() {
             const t = [];
-            for (const n of _n(this.formula)) {
+            for (const n of Qt(this.formula)) {
                 const {
                     field: i,
                     as: r,
-                    timeUnit: a
-                } = n, s = En(a), {
-                    unit: o,
-                    utc: l
-                } = s, u = G$(s, ["unit", "utc"]);
-                t.push(Object.assign(Object.assign(Object.assign(Object.assign({
-                    field: Bi(i),
-                    type: "timeunit"
-                }, o ? {
-                    units: yO(o)
-                } : {}), l ? {
-                    timezone: "utc"
-                } : {}), u), {
+                    timeUnit: s
+                } = n, {
+                    unit: a,
+                    utc: o,
+                    ...l
+                } = en(s);
+                t.push({
+                    field: Pi(i),
+                    type: "timeunit",
+                    ...a ? {
+                        units: M1(a)
+                    } : {},
+                    ...o ? {
+                        timezone: "utc"
+                    } : {},
+                    ...l,
                     as: [r, `${r}_end`]
-                }))
+                })
             }
             return t
         }
     }
-    var Xpe = globalThis && globalThis.__rest || function(e, t) {
-        var n = {};
-        for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && t.indexOf(i) < 0 && (n[i] = e[i]);
-        if (e != null && typeof Object.getOwnPropertySymbols == "function")
-            for (var r = 0, i = Object.getOwnPropertySymbols(e); r < i.length; r++) t.indexOf(i[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, i[r]) && (n[i[r]] = e[i[r]]);
-        return n
-    };
-    const Qd = "_tuple_fields";
-    class Vpe {
+    const Ld = "_tuple_fields";
+    class Xge {
         constructor(...t) {
             this.items = t, this.hasChannel = {}, this.hasField = {}, this.hasSelectionId = !1
         }
     }
-    const Kpe = {
+    const Vge = {
             defined: () => !0,
             parse: (e, t, n) => {
-                var i;
-                const r = t.name,
-                    a = (i = t.project) !== null && i !== void 0 ? i : t.project = new Vpe,
+                const i = t.name,
+                    r = t.project ?? (t.project = new Xge),
                     s = {},
-                    o = {},
-                    l = new Set,
-                    u = (p, m) => {
-                        const y = m === "visual" ? p.channel : p.field;
-                        let v = ht(`${r}_${y}`);
-                        for (let b = 1; l.has(v); b++) v = ht(`${r}_${y}_${b}`);
-                        return l.add(v), {
-                            [m]: v
+                    a = {},
+                    o = new Set,
+                    l = (g, p) => {
+                        const m = p === "visual" ? g.channel : g.field;
+                        let y = ft(`${i}_${m}`);
+                        for (let v = 1; o.has(y); v++) y = ft(`${i}_${m}_${v}`);
+                        return o.add(y), {
+                            [p]: y
                         }
                     },
-                    c = t.type,
-                    f = e.config.selection[c],
-                    h = n.value !== void 0 ? ie(n.value) : null;
+                    u = t.type,
+                    c = e.config.selection[u],
+                    f = n.value !== void 0 ? se(n.value) : null;
                 let {
-                    fields: d,
-                    encodings: g
-                } = se(n.select) ? n.select : {};
-                if (!d && !g && h) {
-                    for (const p of h)
-                        if (se(p))
-                            for (const m of Y(p)) lfe(m) ? (g || (g = [])).push(m) : c === "interval" ? (X(Ufe), g = f.encodings) : (d || (d = [])).push(m)
-                }!d && !g && (g = f.encodings, "fields" in f && (d = f.fields));
-                for (const p of g ?? []) {
-                    const m = e.fieldDef(p);
-                    if (m) {
-                        let y = m.field;
-                        if (m.aggregate) {
-                            X(Pfe(p, m.aggregate));
+                    fields: h,
+                    encodings: d
+                } = ae(n.select) ? n.select : {};
+                if (!h && !d && f) {
+                    for (const g of f)
+                        if (ae(g))
+                            for (const p of H(g)) mce(p) ? (d || (d = [])).push(p) : u === "interval" ? (X(Vce), d = c.encodings) : (h ?? (h = [])).push(p)
+                }!h && !d && (d = c.encodings, "fields" in c && (h = c.fields));
+                for (const g of d ?? []) {
+                    const p = e.fieldDef(g);
+                    if (p) {
+                        let m = p.field;
+                        if (p.aggregate) {
+                            X(jce(g, p.aggregate));
                             continue
-                        } else if (!y) {
-                            X(g$(p));
+                        } else if (!m) {
+                            X($5(g));
                             continue
                         }
-                        if (m.timeUnit) {
-                            y = e.vgField(p);
-                            const v = {
-                                timeUnit: m.timeUnit,
-                                as: y,
-                                field: m.field
+                        if (p.timeUnit) {
+                            m = e.vgField(g);
+                            const y = {
+                                timeUnit: p.timeUnit,
+                                as: m,
+                                field: p.field
                             };
-                            o[Ie(v)] = v
+                            a[Ne(y)] = y
                         }
-                        if (!s[y]) {
-                            let v = "E";
-                            if (c === "interval") {
-                                const x = e.getScaleComponent(p).get("type");
-                                Ei(x) && (v = "R")
-                            } else m.bin && (v = "R-RE");
-                            const b = {
-                                field: y,
-                                channel: p,
-                                type: v
-                            };
-                            b.signals = Object.assign(Object.assign({}, u(b, "data")), u(b, "visual")), a.items.push(s[y] = b), a.hasField[y] = a.hasChannel[p] = s[y], a.hasSelectionId = a.hasSelectionId || y === ra
+                        if (!s[m]) {
+                            const y = u === "interval" && Qs(g) && wi(e.getScaleComponent(g).get("type")) ? "R" : p.bin ? "R-RE" : "E",
+                                v = {
+                                    field: m,
+                                    channel: g,
+                                    type: y,
+                                    index: r.items.length
+                                };
+                            v.signals = {
+                                ...l(v, "data"),
+                                ...l(v, "visual")
+                            }, r.items.push(s[m] = v), r.hasField[m] = s[m], r.hasSelectionId = r.hasSelectionId || m === pr, SI(g) ? (v.geoChannel = g, v.channel = wI(g), r.hasChannel[v.channel] = s[m]) : r.hasChannel[g] = s[m]
                         }
-                    } else X(g$(p))
+                    } else X($5(g))
                 }
-                for (const p of d ?? []) {
-                    if (a.hasField[p]) continue;
-                    const m = {
+                for (const g of h ?? []) {
+                    if (r.hasField[g]) continue;
+                    const p = {
                         type: "E",
-                        field: p
+                        field: g,
+                        index: r.items.length
                     };
-                    m.signals = Object.assign({}, u(m, "data")), a.items.push(m), a.hasField[p] = m, a.hasSelectionId = a.hasSelectionId || p === ra
+                    p.signals = {
+                        ...l(p, "data")
+                    }, r.items.push(p), r.hasField[g] = p, r.hasSelectionId = r.hasSelectionId || g === pr
                 }
-                h && (t.init = h.map(p => a.items.map(m => se(p) ? p[m.channel] !== void 0 ? p[m.channel] : p[m.field] : p))), et(o) || (a.timeUnit = new Xr(null, o))
+                f && (t.init = f.map(g => r.items.map(p => ae(g) ? g[p.geoChannel || p.channel] !== void 0 ? g[p.geoChannel || p.channel] : g[p.field] : g))), et(a) || (r.timeUnit = new jr(null, a))
             },
             signals: (e, t, n) => {
-                const i = t.name + Qd;
-                return n.filter(a => a.name === i).length > 0 || t.project.hasSelectionId ? n : n.concat({
+                const i = t.name + Ld;
+                return n.filter(s => s.name === i).length > 0 || t.project.hasSelectionId ? n : n.concat({
                     name: i,
-                    value: t.project.items.map(a => {
-                        const s = Xpe(a, ["signals", "hasLegend"]);
-                        return s.field = Bi(s.field), s
-                    })
+                    value: t.project.items.map(vz)
                 })
             }
         },
-        Zs = {
+        Ns = {
             defined: e => e.type === "interval" && e.resolve === "global" && e.bind && e.bind === "scales",
             parse: (e, t) => {
                 const n = t.scales = [];
                 for (const i of t.project.items) {
                     const r = i.channel;
-                    if (!bo(r)) continue;
-                    const a = e.getScaleComponent(r),
-                        s = a ? a.get("type") : void 0;
-                    if (!a || !Ei(s)) {
-                        X(Ife);
+                    if (!Qs(r)) continue;
+                    const s = e.getScaleComponent(r),
+                        a = s ? s.get("type") : void 0;
+                    if (!s || !wi(a)) {
+                        X(Wce);
                         continue
                     }
-                    a.set("selectionExtent", {
+                    s.set("selectionExtent", {
                         param: t.name,
                         field: i.field
                     }, !0), n.push(i)
                 }
             },
             topLevelSignals: (e, t, n) => {
-                const i = t.scales.filter(s => n.filter(o => o.name === s.signals.data).length === 0);
-                if (!e.parent || Dx(e) || i.length === 0) return n;
-                const r = n.filter(s => s.name === t.name)[0];
-                let a = r.update;
-                if (a.indexOf(xz) >= 0) r.update = `{${i.map(s=>`${Z(Bi(s.field))}: ${s.signals.data}`).join(", ")}}`;
+                const i = t.scales.filter(a => n.filter(o => o.name === a.signals.data).length === 0);
+                if (!e.parent || n3(e) || i.length === 0) return n;
+                const r = n.filter(a => a.name === t.name)[0];
+                let s = r.update;
+                if (s.indexOf(Nz) >= 0) r.update = `{${i.map(a=>`${Z(Pi(a.field))}: ${a.signals.data}`).join(", ")}}`;
                 else {
-                    for (const s of i) {
-                        const o = `${Z(Bi(s.field))}: ${s.signals.data}`;
-                        a.includes(o) || (a = `${a.substring(0,a.length-1)}, ${o}}`)
+                    for (const a of i) {
+                        const o = `${Z(Pi(a.field))}: ${a.signals.data}`;
+                        s.includes(o) || (s = `${s.substring(0,s.length-1)}, ${o}}`)
                     }
-                    r.update = a
+                    r.update = s
                 }
-                return n.concat(i.map(s => ({
-                    name: s.signals.data
+                return n.concat(i.map(a => ({
+                    name: a.signals.data
                 })))
             },
             signals: (e, t, n) => {
-                if (e.parent && !Dx(e))
+                if (e.parent && !n3(e))
                     for (const i of t.scales) {
-                        const r = n.filter(a => a.name === i.signals.data)[0];
+                        const r = n.filter(s => s.name === i.signals.data)[0];
                         r.push = "outer", delete r.value, delete r.update
                     }
                 return n
             }
         };
 
-    function Fx(e, t) {
+    function ix(e, t) {
         return `domain(${Z(e.scaleName(t))})`
     }
 
-    function Dx(e) {
-        var t;
-        return e.parent && Vc(e.parent) && ((t = !e.parent.parent) !== null && t !== void 0 ? t : Dx(e.parent.parent))
+    function n3(e) {
+        return e.parent && Ic(e.parent) && !e.parent.parent
     }
-    var Jpe = globalThis && globalThis.__rest || function(e, t) {
-        var n = {};
-        for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && t.indexOf(i) < 0 && (n[i] = e[i]);
-        if (e != null && typeof Object.getOwnPropertySymbols == "function")
-            for (var r = 0, i = Object.getOwnPropertySymbols(e); r < i.length; r++) t.indexOf(i[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, i[r]) && (n[i[r]] = e[i[r]]);
-        return n
-    };
-    const Iu = "_brush",
-        Rx = "_scale_trigger",
-        Qpe = {
+    const Au = "_brush",
+        xz = "_scale_trigger",
+        ff = "geo_interval_init_tick",
+        _z = "_init",
+        Kge = "_center",
+        Jge = {
             defined: e => e.type === "interval",
+            parse: (e, t, n) => {
+                var i;
+                if (e.hasProjection) {
+                    const r = {
+                        ...ae(n.select) ? n.select : {}
+                    };
+                    r.fields = [pr], r.encodings || (r.encodings = n.value ? H(n.value) : [Sr, wr]), n.select = {
+                        type: "interval",
+                        ...r
+                    }
+                }
+                if (t.translate && !Ns.defined(t)) {
+                    const r = `!event.item || event.item.mark.name !== ${Z(t.name+Au)}`;
+                    for (const s of t.events) {
+                        if (!s.between) {
+                            X(`${s} is not an ordered event stream for interval selections.`);
+                            continue
+                        }
+                        const a = se((i = s.between[0]).filter ?? (i.filter = []));
+                        a.indexOf(r) < 0 && a.push(r)
+                    }
+                }
+            },
             signals: (e, t, n) => {
                 const i = t.name,
-                    r = i + Qd,
-                    a = Zs.defined(t),
-                    s = t.init ? t.init[0] : null,
-                    o = [],
-                    l = [];
-                if (t.translate && !a) {
-                    const c = `!event.item || event.item.mark.name !== ${Z(i+Iu)}`;
-                    sz(t, (f, h) => {
-                        var d, g;
-                        const p = ie((d = (g = h.between[0]).filter) !== null && d !== void 0 ? d : g.filter = []);
-                        return p.includes(c) || p.push(c), f
+                    r = i + Wa,
+                    s = Qt(t.project.hasChannel).filter(o => o.channel === ht || o.channel === Gt),
+                    a = t.init ? t.init[0] : null;
+                if (n.push(...s.reduce((o, l) => o.concat(Qge(e, t, l, a && a[l.index])), [])), e.hasProjection) {
+                    const o = Z(e.projectionName()),
+                        l = e.projectionName() + Kge,
+                        {
+                            x: u,
+                            y: c
+                        } = t.project.hasChannel,
+                        f = u && u.signals.visual,
+                        h = c && c.signals.visual,
+                        d = u ? a && a[u.index] : `${l}[0]`,
+                        g = c ? a && a[c.index] : `${l}[1]`,
+                        p = _ => e.getSizeSignalRef(_).signal,
+                        m = `[[${f?f+"[0]":"0"}, ${h?h+"[0]":"0"}],[${f?f+"[1]":p("width")}, ${h?h+"[1]":p("height")}]]`;
+                    a && (n.unshift({
+                        name: i + _z,
+                        init: `[scale(${o}, [${u?d[0]:d}, ${c?g[0]:g}]), scale(${o}, [${u?d[1]:d}, ${c?g[1]:g}])]`
+                    }), (!u || !c) && (n.find(S => S.name === l) || n.unshift({
+                        name: l,
+                        update: `invert(${o}, [${p("width")}/2, ${p("height")}/2])`
+                    })));
+                    const y = `intersect(${m}, {markname: ${Z(e.getName("marks"))}}, unit.mark)`,
+                        v = `{unit: ${Yo(e)}}`,
+                        b = `vlSelectionTuples(${y}, ${v})`,
+                        x = s.map(_ => _.signals.visual);
+                    return n.concat({
+                        name: r,
+                        on: [{
+                            events: [...x.length ? [{
+                                signal: x.join(" || ")
+                            }] : [], ...a ? [{
+                                signal: ff
+                            }] : []],
+                            update: b
+                        }]
                     })
-                }
-                t.project.items.forEach((c, f) => {
-                    const h = c.channel;
-                    if (h !== yt && h !== Yt) {
-                        X("Interval selections only support x and y encoding channels.");
-                        return
+                } else {
+                    if (!Ns.defined(t)) {
+                        const u = i + xz,
+                            c = s.map(f => {
+                                const h = f.channel,
+                                    {
+                                        data: d,
+                                        visual: g
+                                    } = f.signals,
+                                    p = Z(e.scaleName(h)),
+                                    m = e.getScaleComponent(h).get("type"),
+                                    y = wi(m) ? "+" : "";
+                                return `(!isArray(${d}) || (${y}invert(${p}, ${g})[0] === ${y}${d}[0] && ${y}invert(${p}, ${g})[1] === ${y}${d}[1]))`
+                            });
+                        c.length && n.push({
+                            name: u,
+                            value: {},
+                            on: [{
+                                events: s.map(f => ({
+                                    scale: e.scaleName(f.channel)
+                                })),
+                                update: c.join(" && ") + ` ? ${u} : {}`
+                            }]
+                        })
                     }
-                    const d = s ? s[f] : null,
-                        g = Zpe(e, t, c, d),
-                        p = c.signals.data,
-                        m = c.signals.visual,
-                        y = Z(e.scaleName(h)),
-                        v = e.getScaleComponent(h).get("type"),
-                        b = Ei(v) ? "+" : "";
-                    n.push(...g), o.push(p), l.push({
-                        scaleName: e.scaleName(h),
-                        expr: `(!isArray(${p}) || (${b}invert(${y}, ${m})[0] === ${b}${p}[0] && ${b}invert(${y}, ${m})[1] === ${b}${p}[1]))`
+                    const o = s.map(u => u.signals.data),
+                        l = `unit: ${Yo(e)}, fields: ${i+Ld}, values`;
+                    return n.concat({
+                        name: r,
+                        ...a ? {
+                            init: `{${l}: ${pl(a)}}`
+                        } : {},
+                        ...o.length ? {
+                            on: [{
+                                events: [{
+                                    signal: o.join(" || ")
+                                }],
+                                update: `${o.join(" && ")} ? {${l}: [${o}]} : null`
+                            }]
+                        } : {}
                     })
-                }), !a && l.length && n.push({
-                    name: i + Rx,
-                    value: {},
-                    on: [{
-                        events: l.map(c => ({
-                            scale: c.scaleName
-                        })),
-                        update: `${l.map(c=>c.expr).join(" && ")} ? ${i+Rx} : {}`
-                    }]
-                });
-                const u = `unit: ${vc(e)}, fields: ${r}, values`;
-                return n.concat(Object.assign(Object.assign({
-                    name: i + to
-                }, s ? {
-                    init: `{${u}: ${Cl(s)}}`
-                } : {}), o.length ? {
-                    on: [{
-                        events: [{
-                            signal: o.join(" || ")
-                        }],
-                        update: `${o.join(" && ")} ? {${u}: [${o}]} : null`
-                    }]
-                } : {}))
+                }
             },
+            topLevelSignals: (e, t, n) => (Et(e) && e.hasProjection && t.init && (n.filter(r => r.name === ff).length || n.unshift({
+                name: ff,
+                value: null,
+                on: [{
+                    events: "timer{1}",
+                    update: `${ff} === null ? {} : ${ff}`
+                }]
+            })), n),
             marks: (e, t, n) => {
                 const i = t.name,
                     {
                         x: r,
-                        y: a
+                        y: s
                     } = t.project.hasChannel,
-                    s = r == null ? void 0 : r.signals.visual,
-                    o = a == null ? void 0 : a.signals.visual,
-                    l = `data(${Z(t.name+kl)})`;
-                if (Zs.defined(t) || !r && !a) return n;
+                    a = r == null ? void 0 : r.signals.visual,
+                    o = s == null ? void 0 : s.signals.visual,
+                    l = `data(${Z(t.name+ml)})`;
+                if (Ns.defined(t) || !r && !s) return n;
                 const u = {
                     x: r !== void 0 ? {
-                        signal: `${s}[0]`
+                        signal: `${a}[0]`
                     } : {
                         value: 0
                     },
-                    y: a !== void 0 ? {
+                    y: s !== void 0 ? {
                         signal: `${o}[0]`
                     } : {
                         value: 0
                     },
                     x2: r !== void 0 ? {
-                        signal: `${s}[1]`
+                        signal: `${a}[1]`
                     } : {
                         field: {
                             group: "width"
                         }
                     },
-                    y2: a !== void 0 ? {
+                    y2: s !== void 0 ? {
                         signal: `${o}[1]`
                     } : {
                         field: {
                             group: "height"
                         }
                     }
                 };
                 if (t.resolve === "global")
-                    for (const m of Y(u)) u[m] = [Object.assign({
-                        test: `${l}.length && ${l}[0].unit === ${vc(e)}`
-                    }, u[m]), {
+                    for (const p of H(u)) u[p] = [{
+                        test: `${l}.length && ${l}[0].unit === ${Yo(e)}`,
+                        ...u[p]
+                    }, {
                         value: 0
                     }];
-                const c = t.mark,
-                    {
-                        fill: f,
-                        fillOpacity: h,
-                        cursor: d
-                    } = c,
-                    g = Jpe(c, ["fill", "fillOpacity", "cursor"]),
-                    p = Y(g).reduce((m, y) => (m[y] = [{
-                        test: [r !== void 0 && `${s}[0] !== ${s}[1]`, a !== void 0 && `${o}[0] !== ${o}[1]`].filter(v => v).join(" && "),
-                        value: g[y]
-                    }, {
-                        value: null
-                    }], m), {});
+                const {
+                    fill: c,
+                    fillOpacity: f,
+                    cursor: h,
+                    ...d
+                } = t.mark, g = H(d).reduce((p, m) => (p[m] = [{
+                    test: [r !== void 0 && `${a}[0] !== ${a}[1]`, s !== void 0 && `${o}[0] !== ${o}[1]`].filter(y => y).join(" && "),
+                    value: d[m]
+                }, {
+                    value: null
+                }], p), {});
                 return [{
-                    name: `${i+Iu}_bg`,
+                    name: `${i+Au}_bg`,
                     type: "rect",
                     clip: !0,
                     encode: {
                         enter: {
                             fill: {
-                                value: f
+                                value: c
                             },
                             fillOpacity: {
-                                value: h
+                                value: f
                             }
                         },
                         update: u
                     }
                 }, ...n, {
-                    name: i + Iu,
+                    name: i + Au,
                     type: "rect",
                     clip: !0,
                     encode: {
-                        enter: Object.assign(Object.assign({}, d ? {
-                            cursor: {
-                                value: d
-                            }
-                        } : {}), {
+                        enter: {
+                            ...h ? {
+                                cursor: {
+                                    value: h
+                                }
+                            } : {},
                             fill: {
                                 value: "transparent"
                             }
-                        }),
-                        update: Object.assign(Object.assign({}, u), p)
+                        },
+                        update: {
+                            ...u,
+                            ...g
+                        }
                     }
                 }]
             }
         };
 
-    function Zpe(e, t, n, i) {
-        const r = n.channel,
+    function Qge(e, t, n, i) {
+        const r = !e.hasProjection,
+            s = n.channel,
             a = n.signals.visual,
-            s = n.signals.data,
-            o = Zs.defined(t),
-            l = Z(e.scaleName(r)),
-            u = e.getScaleComponent(r),
-            c = u ? u.get("type") : void 0,
-            f = p => `scale(${l}, ${p})`,
-            h = e.getSizeSignalRef(r === yt ? "width" : "height").signal,
-            d = `${r}(unit)`,
-            g = sz(t, (p, m) => [...p, {
-                events: m.between[0],
-                update: `[${d}, ${d}]`
+            o = Z(r ? e.scaleName(s) : e.projectionName()),
+            l = h => `scale(${o}, ${h})`,
+            u = e.getSizeSignalRef(s === ht ? "width" : "height").signal,
+            c = `${s}(unit)`,
+            f = t.events.reduce((h, d) => [...h, {
+                events: d.between[0],
+                update: `[${c}, ${c}]`
             }, {
-                events: m,
-                update: `[${a}[0], clamp(${d}, 0, ${h})]`
-            }]);
-        return g.push({
-            events: {
-                signal: t.name + Rx
-            },
-            update: Ei(c) ? `[${f(`${s}[0]`)}, ${f(`${s}[1]`)}]` : "[0, 0]"
-        }), o ? [{
-            name: s,
-            on: []
-        }] : [Object.assign(Object.assign({
-            name: a
-        }, i ? {
-            init: Cl(i, !0, f)
-        } : {
-            value: []
-        }), {
-            on: g
-        }), Object.assign(Object.assign({
-            name: s
-        }, i ? {
-            init: Cl(i)
-        } : {}), {
-            on: [{
+                events: d,
+                update: `[${a}[0], clamp(${c}, 0, ${u})]`
+            }], []);
+        if (r) {
+            const h = n.signals.data,
+                d = Ns.defined(t),
+                g = e.getScaleComponent(s),
+                p = g ? g.get("type") : void 0,
+                m = i ? {
+                    init: pl(i, !0, l)
+                } : {
+                    value: []
+                };
+            return f.push({
                 events: {
-                    signal: a
+                    signal: t.name + xz
                 },
-                update: `${a}[0] === ${a}[1] ? null : invert(${l}, ${a})`
+                update: wi(p) ? `[${l(`${h}[0]`)}, ${l(`${h}[1]`)}]` : "[0, 0]"
+            }), d ? [{
+                name: h,
+                on: []
+            }] : [{
+                name: a,
+                ...m,
+                on: f
+            }, {
+                name: h,
+                ...i ? {
+                    init: pl(i)
+                } : {},
+                on: [{
+                    events: {
+                        signal: a
+                    },
+                    update: `${a}[0] === ${a}[1] ? null : invert(${o}, ${a})`
+                }]
             }]
-        })]
-    }
-
-    function sz(e, t) {
-        return e.events.reduce((n, i) => i.between ? t(n, i) : (X(`${i} is not an ordered event stream for interval selections.`), n), [])
+        } else {
+            const h = s === ht ? 0 : 1,
+                d = t.name + _z,
+                g = i ? {
+                    init: `[${d}[0][${h}], ${d}[1][${h}]]`
+                } : {
+                    value: []
+                };
+            return [{
+                name: a,
+                ...g,
+                on: f
+            }]
+        }
     }
-    const e0e = {
+    const Zge = {
         defined: e => e.type === "point",
         signals: (e, t, n) => {
-            var i;
-            const r = t.name,
-                a = r + Qd,
+            const i = t.name,
+                r = i + Ld,
                 s = t.project,
-                o = "(item().isVoronoi ? datum.datum : datum)",
-                l = _n((i = e.component.selection) !== null && i !== void 0 ? i : {}).reduce((h, d) => d.type === "interval" ? h.concat(d.name + Iu) : h, []).map(h => `indexof(item().mark.name, '${h}') < 0`).join(" && "),
-                u = `datum && item().mark.marktype !== 'group' && indexof(item().mark.role, 'legend') < 0${l?` && ${l}`:""}`;
-            let c = `unit: ${vc(e)}, `;
-            if (t.project.hasSelectionId) c += `${ra}: ${o}[${Z(ra)}]`;
+                a = "(item().isVoronoi ? datum.datum : datum)",
+                o = Qt(e.component.selection ?? {}).reduce((f, h) => h.type === "interval" ? f.concat(h.name + Au) : f, []).map(f => `indexof(item().mark.name, '${f}') < 0`).join(" && "),
+                l = `datum && item().mark.marktype !== 'group' && indexof(item().mark.role, 'legend') < 0${o?` && ${o}`:""}`;
+            let u = `unit: ${Yo(e)}, `;
+            if (t.project.hasSelectionId) u += `${pr}: ${a}[${Z(pr)}]`;
             else {
-                const h = s.items.map(d => {
-                    const g = e.fieldDef(d.channel);
-                    return g != null && g.bin ? `[${o}[${Z(e.vgField(d.channel,{}))}], ${o}[${Z(e.vgField(d.channel,{binSuffix:"end"}))}]]` : `${o}[${Z(d.field)}]`
+                const f = s.items.map(h => {
+                    const d = e.fieldDef(h.channel);
+                    return d != null && d.bin ? `[${a}[${Z(e.vgField(h.channel,{}))}], ${a}[${Z(e.vgField(h.channel,{binSuffix:"end"}))}]]` : `${a}[${Z(h.field)}]`
                 }).join(", ");
-                c += `fields: ${a}, values: [${h}]`
+                u += `fields: ${r}, values: [${f}]`
             }
-            const f = t.events;
+            const c = t.events;
             return n.concat([{
-                name: r + to,
-                on: f ? [{
-                    events: f,
-                    update: `${u} ? {${c}} : null`,
+                name: i + Wa,
+                on: c ? [{
+                    events: c,
+                    update: `${l} ? {${u}} : null`,
                     force: !0
                 }] : []
             }])
         }
     };
 
-    function Wc(e, t, n, i) {
-        const r = ty(t) && t.condition,
-            a = i(t);
+    function Dc(e, t, n, i) {
+        const r = L1(t) && t.condition,
+            s = i(t);
         if (r) {
-            const o = ie(r).map(l => {
+            const o = se(r).map(l => {
                 const u = i(l);
-                if (Ude(l)) {
+                if (Xhe(l)) {
                     const {
                         param: c,
                         empty: f
-                    } = l, h = Ez(e, {
-                        param: c,
-                        empty: f
-                    });
-                    return Object.assign({
-                        test: h
-                    }, u)
-                } else {
-                    const c = dm(e, l.test);
-                    return Object.assign({
-                        test: c
-                    }, u)
+                    } = l;
+                    return {
+                        test: zz(e, {
+                            param: c,
+                            empty: f
+                        }),
+                        ...u
+                    }
+                } else return {
+                    test: V0(e, l.test),
+                    ...u
                 }
             });
             return {
-                [n]: [...o, ...a !== void 0 ? [a] : []]
+                [n]: [...o, ...s !== void 0 ? [s] : []]
             }
-        } else return a !== void 0 ? {
-            [n]: a
+        } else return s !== void 0 ? {
+            [n]: s
         } : {}
     }
 
-    function tC(e, t = "text") {
+    function xC(e, t = "text") {
         const n = e.encoding[t];
-        return Wc(e, n, t, i => cy(i, e.config))
+        return Dc(e, n, t, i => H1(i, e.config))
     }
 
-    function cy(e, t, n = "datum") {
+    function H1(e, t, n = "datum") {
         if (e) {
-            if (wr(e)) return ct(e.value);
-            if (Ee(e)) {
+            if (gr(e)) return ut(e.value);
+            if (Ce(e)) {
                 const {
                     format: i,
                     formatType: r
-                } = sm(e);
-                return RO({
+                } = U0(e);
+                return ZE({
                     fieldOrDatumDef: e,
                     format: i,
                     formatType: r,
                     expr: n,
                     config: t
                 })
             }
         }
     }
 
-    function oz(e, t = {}) {
+    function wz(e, t = {}) {
         const {
             encoding: n,
             markDef: i,
             config: r,
-            stack: a
-        } = e, s = n.tooltip;
-        if (q(s)) return {
-            tooltip: U$({
-                tooltip: s
-            }, a, r, t)
+            stack: s
+        } = e, a = n.tooltip;
+        if (W(a)) return {
+            tooltip: i3({
+                tooltip: a
+            }, s, r, t)
         }; {
             const o = t.reactiveGeom ? "datum.datum" : "datum";
-            return Wc(e, s, "tooltip", l => {
-                const u = cy(l, r, o);
+            return Dc(e, a, "tooltip", l => {
+                const u = H1(l, r, o);
                 if (u) return u;
                 if (l === null) return;
-                let c = Ve("tooltip", i, r);
+                let c = Xe("tooltip", i, r);
                 if (c === !0 && (c = {
                         content: "encoding"
                     }), re(c)) return {
                     value: c
                 };
-                if (se(c)) return fe(c) ? c : c.content === "encoding" ? U$(n, a, r, t) : {
+                if (ae(c)) return he(c) ? c : c.content === "encoding" ? i3(n, s, r, t) : {
                     signal: o
                 }
             })
         }
     }
 
-    function lz(e, t, n, {
+    function Sz(e, t, n, {
         reactiveGeom: i
     } = {}) {
-        const r = {},
+        const r = {
+                ...n,
+                ...n.tooltipFormat
+            },
+            s = {},
             a = i ? "datum.datum" : "datum",
-            s = [];
+            o = [];
 
-        function o(u, c) {
-            const f = Hl(c),
-                h = Ui(u) ? u : Object.assign(Object.assign({}, u), {
-                    type: e[f].type
-                }),
-                d = h.title || IO(h, n),
-                g = ie(d).join(", ");
-            let p;
-            if (Xt(c)) {
-                const m = c === "x" ? "x2" : "y2",
-                    y = ia(e[m]);
-                if (Qt(h.bin) && y) {
-                    const v = ne(h, {
+        function l(c, f) {
+            const h = Nl(f),
+                d = zn(c) ? c : {
+                    ...c,
+                    type: e[h].type
+                },
+                g = d.title || iC(d, r),
+                p = se(g).join(", ");
+            let m;
+            if (Wt(f)) {
+                const y = f === "x" ? "x2" : "y2",
+                    v = Kr(e[y]);
+                if (Xt(d.bin) && v) {
+                    const b = ie(d, {
                             expr: a
                         }),
-                        b = ne(y, {
+                        x = ie(v, {
                             expr: a
                         }),
                         {
-                            format: x,
-                            formatType: _
-                        } = sm(h);
-                    p = Yd(v, b, x, _, n), r[m] = !0
+                            format: _,
+                            formatType: S
+                        } = U0(d);
+                    m = Fd(b, x, _, S, r), s[y] = !0
                 }
             }
-            if ((Xt(c) || c === Wi || c === Ar) && t && t.fieldChannel === c && t.offset === "normalize") {
+            if ((Wt(f) || f === zi || f === _r) && t && t.fieldChannel === f && t.offset === "normalize") {
                 const {
-                    format: m,
-                    formatType: y
-                } = sm(h);
-                p = RO({
-                    fieldOrDatumDef: h,
-                    format: m,
-                    formatType: y,
+                    format: y,
+                    formatType: v
+                } = U0(d);
+                m = ZE({
+                    fieldOrDatumDef: d,
+                    format: y,
+                    formatType: v,
                     expr: a,
-                    config: n,
+                    config: r,
                     normalizeStack: !0
                 }).signal
             }
-            p ?? (p = cy(h, n, a).signal), s.push({
-                channel: c,
-                key: g,
-                value: p
+            m ?? (m = H1(d, r, a).signal), o.push({
+                channel: f,
+                key: p,
+                value: m
             })
         }
-        BO(e, (u, c) => {
-            J(u) ? o(u, c) : ny(u) && o(u.condition, c)
+        aC(e, (c, f) => {
+            K(c) ? l(c, f) : I1(c) && l(c.condition, f)
         });
-        const l = {};
+        const u = {};
         for (const {
-                channel: u,
-                key: c,
-                value: f
+                channel: c,
+                key: f,
+                value: h
             }
-            of s) !r[u] && !l[c] && (l[c] = f);
-        return l
+            of o) !s[c] && !u[f] && (u[f] = h);
+        return u
     }
 
-    function U$(e, t, n, {
+    function i3(e, t, n, {
         reactiveGeom: i
     } = {}) {
-        const r = lz(e, t, n, {
+        const r = Sz(e, t, n, {
                 reactiveGeom: i
             }),
-            a = Ks(r).map(([s, o]) => `"${s}": ${o}`);
-        return a.length > 0 ? {
-            signal: `{${a.join(", ")}}`
+            s = Ba(r).map(([a, o]) => `"${a}": ${o}`);
+        return s.length > 0 ? {
+            signal: `{${s.join(", ")}}`
         } : void 0
     }
 
-    function t0e(e) {
+    function epe(e) {
         const {
             markDef: t,
             config: n
-        } = e, i = Ve("aria", t, n);
-        return i === !1 ? {} : Object.assign(Object.assign(Object.assign({}, i ? {
-            aria: i
-        } : {}), n0e(e)), i0e(e))
+        } = e, i = Xe("aria", t, n);
+        return i === !1 ? {} : {
+            ...i ? {
+                aria: i
+            } : {},
+            ...tpe(e),
+            ...npe(e)
+        }
     }
 
-    function n0e(e) {
+    function tpe(e) {
         const {
             mark: t,
             markDef: n,
             config: i
         } = e;
         if (i.aria === !1) return {};
-        const r = Ve("ariaRoleDescription", n, i);
+        const r = Xe("ariaRoleDescription", n, i);
         return r != null ? {
             ariaRoleDescription: {
                 value: r
             }
-        } : t in Mfe ? {} : {
+        } : t in Lce ? {} : {
             ariaRoleDescription: {
                 value: t
             }
         }
     }
 
-    function i0e(e) {
+    function npe(e) {
         const {
             encoding: t,
             markDef: n,
             config: i,
             stack: r
-        } = e, a = t.description;
-        if (a) return Wc(e, a, "description", l => cy(l, e.config));
-        const s = Ve("description", n, i);
-        if (s != null) return {
-            description: ct(s)
+        } = e, s = t.description;
+        if (s) return Dc(e, s, "description", l => H1(l, e.config));
+        const a = Xe("description", n, i);
+        if (a != null) return {
+            description: ut(a)
         };
         if (i.aria === !1) return {};
-        const o = lz(t, r, i);
+        const o = Sz(t, r, i);
         if (!et(o)) return {
             description: {
-                signal: Ks(o).map(([l, u], c) => `"${c>0?"; ":""}${l}: " + (${u})`).join(" + ")
+                signal: Ba(o).map(([l, u], c) => `"${c>0?"; ":""}${l}: " + (${u})`).join(" + ")
             }
         }
     }
 
-    function Bt(e, t, n = {}) {
+    function Lt(e, t, n = {}) {
         const {
             markDef: i,
             encoding: r,
-            config: a
+            config: s
         } = t, {
-            vgChannel: s
+            vgChannel: a
         } = n;
         let {
             defaultRef: o,
             defaultValue: l
         } = n;
-        o === void 0 && (l ?? (l = Ve(e, i, a, {
-            vgChannel: s,
+        o === void 0 && (l ?? (l = Xe(e, i, s, {
+            vgChannel: a,
             ignoreVgConfig: !0
-        })), l !== void 0 && (o = ct(l)));
+        })), l !== void 0 && (o = ut(l)));
         const u = r[e];
-        return Wc(t, u, s ?? e, c => DO({
+        return Dc(t, u, a ?? e, c => QE({
             channel: e,
             channelDef: c,
             markDef: i,
-            config: a,
+            config: s,
             scaleName: t.scaleName(e),
             scale: t.getScaleComponent(e),
             stack: null,
             defaultRef: o
         }))
     }
 
-    function uz(e, t = {
+    function Ez(e, t = {
         filled: void 0
     }) {
-        var n, i, r, a;
         const {
-            markDef: s,
-            encoding: o,
-            config: l
+            markDef: n,
+            encoding: i,
+            config: r
         } = e, {
-            type: u
-        } = s, c = (n = t.filled) !== null && n !== void 0 ? n : Ve("filled", s, l), f = Pe(["bar", "point", "circle", "square", "geoshape"], u) ? "transparent" : void 0, h = (r = (i = Ve(c === !0 ? "color" : void 0, s, l, {
+            type: s
+        } = n, a = t.filled ?? Xe("filled", n, r), o = Fe(["bar", "point", "circle", "square", "geoshape"], s) ? "transparent" : void 0, l = Xe(a === !0 ? "color" : void 0, n, r, {
             vgChannel: "fill"
-        })) !== null && i !== void 0 ? i : l.mark[c === !0 && "color"]) !== null && r !== void 0 ? r : f, d = (a = Ve(c === !1 ? "color" : void 0, s, l, {
+        }) ?? r.mark[a === !0 && "color"] ?? o, u = Xe(a === !1 ? "color" : void 0, n, r, {
             vgChannel: "stroke"
-        })) !== null && a !== void 0 ? a : l.mark[c === !1 && "color"], g = c ? "fill" : "stroke", p = Object.assign(Object.assign({}, h ? {
-            fill: ct(h)
-        } : {}), d ? {
-            stroke: ct(d)
-        } : {});
-        return s.color && (c ? s.fill : s.stroke) && X(Mj("property", {
-            fill: "fill" in s,
-            stroke: "stroke" in s
-        })), Object.assign(Object.assign(Object.assign(Object.assign({}, p), Bt("color", e, {
-            vgChannel: g,
-            defaultValue: c ? h : d
-        })), Bt("fill", e, {
-            defaultValue: o.fill ? h : void 0
-        })), Bt("stroke", e, {
-            defaultValue: o.stroke ? d : void 0
-        }))
+        }) ?? r.mark[a === !1 && "color"], c = a ? "fill" : "stroke", f = {
+            ...l ? {
+                fill: ut(l)
+            } : {},
+            ...u ? {
+                stroke: ut(u)
+            } : {}
+        };
+        return n.color && (a ? n.fill : n.stroke) && X(qI("property", {
+            fill: "fill" in n,
+            stroke: "stroke" in n
+        })), {
+            ...f,
+            ...Lt("color", e, {
+                vgChannel: c,
+                defaultValue: a ? l : u
+            }),
+            ...Lt("fill", e, {
+                defaultValue: i.fill ? l : void 0
+            }),
+            ...Lt("stroke", e, {
+                defaultValue: i.stroke ? u : void 0
+            })
+        }
     }
 
-    function r0e(e) {
+    function ipe(e) {
         const {
             encoding: t,
             mark: n
         } = e, i = t.order;
-        return !wo(n) && wr(i) ? Wc(e, i, "zindex", r => ct(r.value)) : {}
+        return !uo(n) && gr(i) ? Dc(e, i, "zindex", r => ut(r.value)) : {}
     }
 
-    function ed({
+    function jh({
         channel: e,
         markDef: t,
         encoding: n = {},
         model: i,
         bandPosition: r
     }) {
-        const a = `${e}Offset`,
-            s = t[a],
-            o = n[a];
-        if ((a === "xOffset" || a === "yOffset") && o) return {
+        const s = `${e}Offset`,
+            a = t[s],
+            o = n[s];
+        if ((s === "xOffset" || s === "yOffset") && o) return {
             offsetType: "encoding",
-            offset: DO({
-                channel: a,
+            offset: QE({
+                channel: s,
                 channelDef: o,
                 markDef: t,
                 config: i == null ? void 0 : i.config,
-                scaleName: i.scaleName(a),
-                scale: i.getScaleComponent(a),
+                scaleName: i.scaleName(s),
+                scale: i.getScaleComponent(s),
                 stack: null,
-                defaultRef: ct(s),
+                defaultRef: ut(a),
                 bandPosition: r
             })
         };
-        const l = t[a];
+        const l = t[s];
         return l ? {
             offsetType: "visual",
             offset: l
         } : {}
     }
 
-    function pn(e, t, {
+    function dn(e, t, {
         defaultPos: n,
         vgChannel: i
     }) {
         const {
             encoding: r,
-            markDef: a,
-            config: s,
+            markDef: s,
+            config: a,
             stack: o
-        } = t, l = r[e], u = r[ba(e)], c = t.scaleName(e), f = t.getScaleComponent(e), {
+        } = t, l = r[e], u = r[us(e)], c = t.scaleName(e), f = t.getScaleComponent(e), {
             offset: h,
             offsetType: d
-        } = ed({
+        } = jh({
             channel: e,
-            markDef: a,
+            markDef: s,
             encoding: r,
             model: t,
             bandPosition: .5
-        }), g = nC({
+        }), g = _C({
             model: t,
             defaultPos: n,
             channel: e,
             scaleName: c,
             scale: f
-        }), p = !l && Xt(e) && (r.latitude || r.longitude) ? {
+        }), p = !l && Wt(e) && (r.latitude || r.longitude) ? {
             field: t.getName(e)
-        } : a0e({
+        } : rpe({
             channel: e,
             channelDef: l,
             channel2Def: u,
-            markDef: a,
-            config: s,
+            markDef: s,
+            config: a,
             scaleName: c,
             scale: f,
             stack: o,
             offset: h,
             defaultRef: g,
             bandPosition: d === "encoding" ? 0 : void 0
         });
         return p ? {
             [i || e]: p
         } : void 0
     }
 
-    function a0e(e) {
+    function rpe(e) {
         const {
             channel: t,
             channelDef: n,
             scaleName: i,
             stack: r,
-            offset: a,
-            markDef: s
+            offset: s,
+            markDef: a
         } = e;
-        if (Ee(n) && r && t === r.fieldChannel) {
-            if (J(n)) {
+        if (Ce(n) && r && t === r.fieldChannel) {
+            if (K(n)) {
                 let o = n.bandPosition;
-                if (o === void 0 && s.type === "text" && (t === "radius" || t === "theta") && (o = .5), o !== void 0) return rm({
+                if (o === void 0 && a.type === "text" && (t === "radius" || t === "theta") && (o = .5), o !== void 0) return z0({
                     scaleName: i,
                     fieldOrDatumDef: n,
                     startSuffix: "start",
                     bandPosition: o,
-                    offset: a
+                    offset: s
                 })
             }
-            return rl(n, i, {
+            return qo(n, i, {
                 suffix: "end"
             }, {
-                offset: a
+                offset: s
             })
         }
-        return MO(e)
+        return KE(e)
     }
 
-    function nC({
+    function _C({
         model: e,
         defaultPos: t,
         channel: n,
         scaleName: i,
         scale: r
     }) {
         const {
-            markDef: a,
-            config: s
+            markDef: s,
+            config: a
         } = e;
         return () => {
-            const o = Hl(n),
-                l = Js(n),
-                u = Ve(n, a, s, {
+            const o = Nl(n),
+                l = ja(n),
+                u = Xe(n, s, a, {
                     vgChannel: l
                 });
-            if (u !== void 0) return xh(n, u);
+            if (u !== void 0) return lh(n, u);
             switch (t) {
                 case "zeroOrMin":
                 case "zeroOrMax":
                     if (i) {
                         const c = r.get("type");
-                        if (!Pe([ei.LOG, ei.TIME, ei.UTC], c)) {
+                        if (!Fe([Qn.LOG, Qn.TIME, Qn.UTC], c)) {
                             if (r.domainDefinitelyIncludesZero()) return {
                                 scale: i,
                                 value: 0
                             }
                         }
                     }
                     if (t === "zeroOrMin") return o === "y" ? {
@@ -43461,543 +43759,577 @@
                             };
                         case "y":
                             return {
                                 value: 0
                             }
                     }
                     break;
-                case "mid": {
-                    const c = e[ui(n)];
-                    return Object.assign(Object.assign({}, c), {
-                        mult: .5
-                    })
-                }
+                case "mid":
+                    return {
+                        ...e[oi(n)], mult: .5
+                    }
             }
         }
     }
-    const s0e = {
+    const spe = {
             left: "x",
             center: "xc",
             right: "x2"
         },
-        o0e = {
+        ape = {
             top: "y",
             middle: "yc",
             bottom: "y2"
         };
 
-    function cz(e, t, n, i = "middle") {
-        if (e === "radius" || e === "theta") return Js(e);
+    function Cz(e, t, n, i = "middle") {
+        if (e === "radius" || e === "theta") return ja(e);
         const r = e === "x" ? "align" : "baseline",
-            a = Ve(r, t, n);
-        let s;
-        return fe(a) ? (X(che(r)), s = void 0) : s = a, e === "x" ? s0e[s || (i === "top" ? "left" : "center")] : o0e[s || i]
+            s = Xe(r, t, n);
+        let a;
+        return he(s) ? (X(mfe(r)), a = void 0) : a = s, e === "x" ? spe[a || (i === "top" ? "left" : "center")] : ape[a || i]
     }
 
-    function fm(e, t, {
+    function Y0(e, t, {
         defaultPos: n,
         defaultPos2: i,
         range: r
     }) {
-        return r ? fz(e, t, {
+        return r ? kz(e, t, {
             defaultPos: n,
             defaultPos2: i
-        }) : pn(e, t, {
+        }) : dn(e, t, {
             defaultPos: n
         })
     }
 
-    function fz(e, t, {
+    function kz(e, t, {
         defaultPos: n,
         defaultPos2: i
     }) {
         const {
             markDef: r,
-            config: a
-        } = t, s = ba(e), o = ui(e), l = l0e(t, i, s), u = l[o] ? cz(e, r, a) : Js(e);
-        return Object.assign(Object.assign({}, pn(e, t, {
-            defaultPos: n,
-            vgChannel: u
-        })), l)
+            config: s
+        } = t, a = us(e), o = oi(e), l = ope(t, i, a), u = l[o] ? Cz(e, r, s) : ja(e);
+        return {
+            ...dn(e, t, {
+                defaultPos: n,
+                vgChannel: u
+            }),
+            ...l
+        }
     }
 
-    function l0e(e, t, n) {
+    function ope(e, t, n) {
         const {
             encoding: i,
             mark: r,
-            markDef: a,
-            stack: s,
+            markDef: s,
+            stack: a,
             config: o
-        } = e, l = Hl(n), u = ui(n), c = Js(n), f = i[l], h = e.scaleName(l), d = e.getScaleComponent(l), {
+        } = e, l = Nl(n), u = oi(n), c = ja(n), f = i[l], h = e.scaleName(l), d = e.getScaleComponent(l), {
             offset: g
-        } = n in i || n in a ? ed({
+        } = n in i || n in s ? jh({
             channel: n,
-            markDef: a,
+            markDef: s,
             encoding: i,
             model: e
-        }) : ed({
+        }) : jh({
             channel: l,
-            markDef: a,
+            markDef: s,
             encoding: i,
             model: e
         });
         if (!f && (n === "x2" || n === "y2") && (i.latitude || i.longitude)) {
-            const m = ui(n),
+            const m = oi(n),
                 y = e.markDef[m];
             return y != null ? {
                 [m]: {
                     value: y
                 }
             } : {
                 [c]: {
                     field: e.getName(n)
                 }
             }
         }
-        const p = u0e({
+        const p = lpe({
             channel: n,
             channelDef: f,
             channel2Def: i[n],
-            markDef: a,
+            markDef: s,
             config: o,
             scaleName: h,
             scale: d,
-            stack: s,
+            stack: a,
             offset: g,
             defaultRef: void 0
         });
         return p !== void 0 ? {
             [c]: p
-        } : qg(n, a) || qg(n, {
-            [n]: tm(n, a, o.style),
-            [u]: tm(u, a, o.style)
-        }) || qg(n, o[r]) || qg(n, o.mark) || {
-            [c]: nC({
+        } : Tg(n, s) || Tg(n, {
+            [n]: P0(n, s, o.style),
+            [u]: P0(u, s, o.style)
+        }) || Tg(n, o[r]) || Tg(n, o.mark) || {
+            [c]: _C({
                 model: e,
                 defaultPos: t,
                 channel: n,
                 scaleName: h,
                 scale: d
             })()
         }
     }
 
-    function u0e({
+    function lpe({
         channel: e,
         channelDef: t,
         channel2Def: n,
         markDef: i,
         config: r,
-        scaleName: a,
-        scale: s,
+        scaleName: s,
+        scale: a,
         stack: o,
         offset: l,
         defaultRef: u
     }) {
-        return Ee(t) && o && e.charAt(0) === o.fieldChannel.charAt(0) ? rl(t, a, {
+        return Ce(t) && o && e.charAt(0) === o.fieldChannel.charAt(0) ? qo(t, s, {
             suffix: "start"
         }, {
             offset: l
-        }) : MO({
+        }) : KE({
             channel: e,
             channelDef: n,
-            scaleName: a,
-            scale: s,
+            scaleName: s,
+            scale: a,
             stack: o,
             markDef: i,
             config: r,
             offset: l,
             defaultRef: u
         })
     }
 
-    function qg(e, t) {
-        const n = ui(e),
-            i = Js(e);
+    function Tg(e, t) {
+        const n = oi(e),
+            i = ja(e);
         if (t[i] !== void 0) return {
-            [i]: xh(e, t[i])
+            [i]: lh(e, t[i])
         };
         if (t[e] !== void 0) return {
-            [i]: xh(e, t[e])
+            [i]: lh(e, t[e])
         };
         if (t[n]) {
             const r = t[n];
-            if (El(r)) X(ihe(n));
+            if (dl(r)) X(ufe(n));
             else return {
-                [n]: xh(e, r)
+                [n]: lh(e, r)
             }
         }
     }
 
-    function eo(e, t) {
-        var n, i;
+    function Ga(e, t) {
         const {
-            config: r,
-            encoding: a,
-            markDef: s
-        } = e, o = s.type, l = ba(t), u = ui(t), c = a[t], f = a[l], h = e.getScaleComponent(t), d = h ? h.get("type") : void 0, g = s.orient, p = (i = (n = a[u]) !== null && n !== void 0 ? n : a.size) !== null && i !== void 0 ? i : Ve("size", s, r, {
-            vgChannel: u
-        }), m = o === "bar" && (t === "x" ? g === "vertical" : g === "horizontal");
-        return J(c) && (lt(c.bin) || Qt(c.bin) || c.timeUnit && !f) && !(p && !El(p)) && !Vt(d) ? h0e({
-            fieldDef: c,
-            fieldDef2: f,
+            config: n,
+            encoding: i,
+            markDef: r
+        } = e, s = r.type, a = us(t), o = oi(t), l = i[t], u = i[a], c = e.getScaleComponent(t), f = c ? c.get("type") : void 0, h = r.orient, d = i[o] ?? i.size ?? Xe("size", r, n, {
+            vgChannel: o
+        }), g = AI(t), p = s === "bar" && (t === "x" ? h === "vertical" : h === "horizontal");
+        return K(l) && (ot(l.bin) || Xt(l.bin) || l.timeUnit && !u) && !(d && !dl(d)) && !i[g] && !qt(f) ? fpe({
+            fieldDef: l,
+            fieldDef2: u,
             channel: t,
             model: e
-        }) : (Ee(c) && Vt(d) || m) && !f ? f0e(c, t, e) : fz(t, e, {
+        }) : (Ce(l) && qt(f) || p) && !u ? cpe(l, t, e) : kz(t, e, {
             defaultPos: "zeroOrMax",
             defaultPos2: "zeroOrMin"
         })
     }
 
-    function c0e(e, t, n, i, r) {
-        if (El(r))
+    function upe(e, t, n, i, r, s, a) {
+        if (dl(r))
             if (n) {
-                const s = n.get("type");
-                if (s === "band") {
-                    let o = `bandwidth('${t}')`;
-                    return r.band !== 1 && (o = `${r.band} * ${o}`), {
-                        signal: `max(0.25, ${o})`
+                const l = n.get("type");
+                if (l === "band") {
+                    let u = `bandwidth('${t}')`;
+                    return r.band !== 1 && (u = `${r.band} * ${u}`), {
+                        signal: `max(0.25, ${u})`
                     }
-                } else r.band !== 1 && (X(ghe(s)), r = void 0)
+                } else r.band !== 1 && (X(xfe(l)), r = void 0)
             } else return {
                 mult: r.band,
                 field: {
                     group: e
                 }
             };
         else {
-            if (fe(r)) return r;
+            if (he(r)) return r;
             if (r) return {
                 value: r
             }
         }
         if (n) {
-            const s = n.get("range");
-            if (_o(s) && tt(s.step)) return {
-                value: s.step - 2
+            const l = n.get("range");
+            if (lo(l) && Ze(l.step)) return {
+                value: l.step - 2
+            }
+        }
+        if (!s) {
+            const {
+                bandPaddingInner: l,
+                barBandPaddingInner: u,
+                rectBandPaddingInner: c
+            } = i.scale, f = Ct(l, a === "bar" ? u : c);
+            if (he(f)) return {
+                signal: `(1 - (${f.signal})) * ${e}`
+            };
+            if (Ze(f)) return {
+                signal: `${1-f} * ${e}`
+            };
+            if (Fc(f)) return {
+                signal: `(1 - (${f.expr})) * ${e}`
             }
         }
         return {
-            value: um(i.view, e) - 2
+            value: q0(i.view, e) - 2
         }
     }
 
-    function f0e(e, t, n) {
+    function cpe(e, t, n) {
         const {
             markDef: i,
             encoding: r,
-            config: a,
-            stack: s
-        } = n, o = i.orient, l = n.scaleName(t), u = n.getScaleComponent(t), c = ui(t), f = ba(t), h = cfe(t), d = n.scaleName(h), g = o === "horizontal" && t === "y" || o === "vertical" && t === "x";
-        let p;
-        (r.size || i.size) && (g ? p = Bt("size", n, {
+            config: s,
+            stack: a
+        } = n, o = i.orient, l = n.scaleName(t), u = n.getScaleComponent(t), c = oi(t), f = us(t), h = AI(t), d = n.scaleName(h), g = n.getScaleComponent(AE(t)), p = o === "horizontal" && t === "y" || o === "vertical" && t === "x";
+        let m;
+        (r.size || i.size) && (p ? m = Lt("size", n, {
             vgChannel: c,
-            defaultRef: ct(i.size)
-        }) : X(vhe(i.type)));
-        const m = !!p,
-            y = c6({
+            defaultRef: ut(i.size)
+        }) : X(Efe(i.type)));
+        const y = !!m,
+            v = C6({
                 channel: t,
                 fieldDef: e,
                 markDef: i,
-                config: a,
+                config: s,
                 scaleType: u == null ? void 0 : u.get("type"),
-                useVlSizeChannel: g
+                useVlSizeChannel: p
             });
-        p = p || {
-            [c]: c0e(c, d || l, u, a, y)
+        m = m || {
+            [c]: upe(c, d || l, g || u, s, v, !!e, i.type)
         };
-        const v = (u == null ? void 0 : u.get("type")) === "band" && El(y) && !m ? "top" : "middle",
-            b = cz(t, i, a, v),
-            x = b === "xc" || b === "yc",
+        const b = (u == null ? void 0 : u.get("type")) === "band" && dl(v) && !y ? "top" : "middle",
+            x = Cz(t, i, s, b),
+            _ = x === "xc" || x === "yc",
             {
-                offset: _,
-                offsetType: S
-            } = ed({
+                offset: S,
+                offsetType: w
+            } = jh({
                 channel: t,
                 markDef: i,
                 encoding: r,
                 model: n,
-                bandPosition: x ? .5 : 0
+                bandPosition: _ ? .5 : 0
             }),
-            w = MO({
+            E = KE({
                 channel: t,
                 channelDef: e,
                 markDef: i,
-                config: a,
+                config: s,
                 scaleName: l,
                 scale: u,
-                stack: s,
-                offset: _,
-                defaultRef: nC({
+                stack: a,
+                offset: S,
+                defaultRef: _C({
                     model: n,
                     defaultPos: "mid",
                     channel: t,
                     scaleName: l,
                     scale: u
                 }),
-                bandPosition: x ? S === "encoding" ? 0 : .5 : fe(y) ? {
-                    signal: `(1-${y})/2`
-                } : El(y) ? (1 - y.band) / 2 : 0
+                bandPosition: _ ? w === "encoding" ? 0 : .5 : he(v) ? {
+                    signal: `(1-${v})/2`
+                } : dl(v) ? (1 - v.band) / 2 : 0
             });
-        if (c) return Object.assign({
-            [b]: w
-        }, p); {
-            const O = Js(f),
-                k = p[c],
-                C = _ ? Object.assign(Object.assign({}, k), {
-                    offset: _
-                }) : k;
-            return {
-                [b]: w,
-                [O]: q(w) ? [w[0], Object.assign(Object.assign({}, w[1]), {
-                    offset: C
-                })] : Object.assign(Object.assign({}, w), {
-                    offset: C
-                })
+        if (c) return {
+            [x]: E,
+            ...m
+        }; {
+            const A = ja(f),
+                C = m[c],
+                k = S ? {
+                    ...C,
+                    offset: S
+                } : C;
+            return {
+                [x]: E,
+                [A]: W(E) ? [E[0], {
+                    ...E[1],
+                    offset: k
+                }] : {
+                    ...E,
+                    offset: k
+                }
             }
         }
     }
 
-    function Ef(e, t, n, i, r) {
-        if (uj(e)) return 0;
-        const a = e === "x" || e === "y2" ? -t / 2 : t / 2;
-        if (fe(n) || fe(r) || fe(i)) {
-            const s = qa(n),
-                o = qa(r),
-                l = qa(i),
+    function hf(e, t, n, i, r) {
+        if (_I(e)) return 0;
+        const s = e === "x" || e === "y2" ? -t / 2 : t / 2;
+        if (he(n) || he(r) || he(i)) {
+            const a = Ds(n),
+                o = Ds(r),
+                l = Ds(i),
                 u = l ? `${l} + ` : "",
-                c = s ? `(${s} ? -1 : 1) * ` : "",
-                f = o ? `(${o} + ${a})` : a;
+                c = a ? `(${a} ? -1 : 1) * ` : "",
+                f = o ? `(${o} + ${s})` : s;
             return {
                 signal: u + c + f
             }
-        } else return r = r || 0, i + (n ? -r - a : +r + a)
+        } else return r = r || 0, i + (n ? -r - s : +r + s)
     }
 
-    function h0e({
+    function fpe({
         fieldDef: e,
         fieldDef2: t,
         channel: n,
         model: i
     }) {
-        var r, a, s;
+        var x;
         const {
-            config: o,
-            markDef: l,
-            encoding: u
-        } = i, c = i.getScaleComponent(n), f = i.scaleName(n), h = c ? c.get("type") : void 0, d = c.get("reverse"), g = c6({
+            config: r,
+            markDef: s,
+            encoding: a
+        } = i, o = i.getScaleComponent(n), l = i.scaleName(n), u = o ? o.get("type") : void 0, c = o.get("reverse"), f = C6({
             channel: n,
             fieldDef: e,
-            markDef: l,
-            config: o,
-            scaleType: h
-        }), p = (r = i.component.axes[n]) === null || r === void 0 ? void 0 : r[0], m = (a = p == null ? void 0 : p.get("translate")) !== null && a !== void 0 ? a : .5, y = Xt(n) && (s = Ve("binSpacing", l, o)) !== null && s !== void 0 ? s : 0, v = ba(n), b = Js(n), x = Js(v), {
-            offset: _
-        } = ed({
+            markDef: s,
+            config: r,
+            scaleType: u
+        }), h = (x = i.component.axes[n]) == null ? void 0 : x[0], d = (h == null ? void 0 : h.get("translate")) ?? .5, g = Wt(n) ? Xe("binSpacing", s, r) ?? 0 : 0, p = us(n), m = ja(n), y = ja(p), {
+            offset: v
+        } = jh({
             channel: n,
-            markDef: l,
-            encoding: u,
+            markDef: s,
+            encoding: a,
             model: i,
             bandPosition: 0
-        }), S = fe(g) ? {
-            signal: `(1-${g.signal})/2`
-        } : El(g) ? (1 - g.band) / 2 : .5;
-        if (lt(e.bin) || e.timeUnit) return {
-            [x]: q$({
+        }), b = he(f) ? {
+            signal: `(1-${f.signal})/2`
+        } : dl(f) ? (1 - f.band) / 2 : .5;
+        if (ot(e.bin) || e.timeUnit) return {
+            [y]: r3({
                 fieldDef: e,
-                scaleName: f,
-                bandPosition: S,
-                offset: Ef(v, y, d, m, _)
+                scaleName: l,
+                bandPosition: b,
+                offset: hf(p, g, c, d, v)
             }),
-            [b]: q$({
+            [m]: r3({
                 fieldDef: e,
-                scaleName: f,
-                bandPosition: fe(S) ? {
-                    signal: `1-${S.signal}`
-                } : 1 - S,
-                offset: Ef(n, y, d, m, _)
+                scaleName: l,
+                bandPosition: he(b) ? {
+                    signal: `1-${b.signal}`
+                } : 1 - b,
+                offset: hf(n, g, c, d, v)
             })
         };
-        if (Qt(e.bin)) {
-            const w = rl(e, f, {}, {
-                offset: Ef(v, y, d, m, _)
+        if (Xt(e.bin)) {
+            const _ = qo(e, l, {}, {
+                offset: hf(p, g, c, d, v)
             });
-            if (J(t)) return {
-                [x]: w,
-                [b]: rl(t, f, {}, {
-                    offset: Ef(n, y, d, m, _)
+            if (K(t)) return {
+                [y]: _,
+                [m]: qo(t, l, {}, {
+                    offset: hf(n, g, c, d, v)
                 })
             };
-            if (Yl(e.bin) && e.bin.step) return {
-                [x]: w,
-                [b]: {
-                    signal: `scale("${f}", ${ne(e,{expr:"datum"})} + ${e.bin.step})`,
-                    offset: Ef(n, y, d, m, _)
+            if (Pl(e.bin) && e.bin.step) return {
+                [y]: _,
+                [m]: {
+                    signal: `scale("${l}", ${ie(e,{expr:"datum"})} + ${e.bin.step})`,
+                    offset: hf(n, g, c, d, v)
                 }
             }
         }
-        X(Rj(v))
+        X(XI(p))
     }
 
-    function q$({
+    function r3({
         fieldDef: e,
         scaleName: t,
         bandPosition: n,
         offset: i
     }) {
-        return rm({
+        return z0({
             scaleName: t,
             fieldOrDatumDef: e,
             bandPosition: n,
             offset: i
         })
     }
-    const d0e = new Set(["aria", "width", "height"]);
+    const hpe = new Set(["aria", "width", "height"]);
 
-    function Hi(e, t) {
+    function Bi(e, t) {
         const {
             fill: n = void 0,
             stroke: i = void 0
-        } = t.color === "include" ? uz(e) : {};
-        return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, g0e(e.markDef, t)), W$(e, "fill", n)), W$(e, "stroke", i)), Bt("opacity", e)), Bt("fillOpacity", e)), Bt("strokeOpacity", e)), Bt("strokeWidth", e)), Bt("strokeDash", e)), r0e(e)), oz(e)), tC(e, "href")), t0e(e))
+        } = t.color === "include" ? Ez(e) : {};
+        return {
+            ...dpe(e.markDef, t),
+            ...s3(e, "fill", n),
+            ...s3(e, "stroke", i),
+            ...Lt("opacity", e),
+            ...Lt("fillOpacity", e),
+            ...Lt("strokeOpacity", e),
+            ...Lt("strokeWidth", e),
+            ...Lt("strokeDash", e),
+            ...ipe(e),
+            ...wz(e),
+            ...xC(e, "href"),
+            ...epe(e)
+        }
     }
 
-    function W$(e, t, n) {
+    function s3(e, t, n) {
         const {
             config: i,
             mark: r,
-            markDef: a
+            markDef: s
         } = e;
-        if (Ve("invalid", a, i) === "hide" && n && !wo(r)) {
-            const o = p0e(e, {
+        if (Xe("invalid", s, i) === "hide" && n && !uo(r)) {
+            const o = gpe(e, {
                 invalid: !0,
-                channels: H1
+                channels: A1
             });
             if (o) return {
                 [t]: [{
                     test: o,
                     value: null
-                }, ...ie(n)]
+                }, ...se(n)]
             }
         }
         return n ? {
             [t]: n
         } : {}
     }
 
-    function g0e(e, t) {
-        return $fe.reduce((n, i) => (!d0e.has(i) && e[i] !== void 0 && t[i] !== "ignore" && (n[i] = ct(e[i])), n), {})
+    function dpe(e, t) {
+        return Pce.reduce((n, i) => (!hpe.has(i) && e[i] !== void 0 && t[i] !== "ignore" && (n[i] = ut(e[i])), n), {})
     }
 
-    function p0e(e, {
+    function gpe(e, {
         invalid: t = !1,
         channels: n
     }) {
-        const i = n.reduce((a, s) => {
-                const o = e.getScaleComponent(s);
+        const i = n.reduce((s, a) => {
+                const o = e.getScaleComponent(a);
                 if (o) {
                     const l = o.get("type"),
-                        u = e.vgField(s, {
+                        u = e.vgField(a, {
                             expr: "datum"
                         });
-                    u && Ei(l) && (a[u] = !0)
+                    u && wi(l) && (s[u] = !0)
                 }
-                return a
+                return s
             }, {}),
-            r = Y(i);
+            r = H(i);
         if (r.length > 0) {
-            const a = t ? "||" : "&&";
-            return r.map(s => FO(s, t)).join(` ${a} `)
+            const s = t ? "||" : "&&";
+            return r.map(a => JE(a, t)).join(` ${s} `)
         }
     }
 
-    function iC(e) {
+    function wC(e) {
         const {
             config: t,
             markDef: n
         } = e;
-        if (Ve("invalid", n, t)) {
-            const r = m0e(e, {
-                channels: xa
+        if (Xe("invalid", n, t)) {
+            const r = ppe(e, {
+                channels: cs
             });
             if (r) return {
                 defined: {
                     signal: r
                 }
             }
         }
         return {}
     }
 
-    function m0e(e, {
+    function ppe(e, {
         invalid: t = !1,
         channels: n
     }) {
-        const i = n.reduce((a, s) => {
-                var o;
-                const l = e.getScaleComponent(s);
-                if (l) {
-                    const u = l.get("type"),
-                        c = e.vgField(s, {
+        const i = n.reduce((s, a) => {
+                var l;
+                const o = e.getScaleComponent(a);
+                if (o) {
+                    const u = o.get("type"),
+                        c = e.vgField(a, {
                             expr: "datum",
-                            binSuffix: !((o = e.stack) === null || o === void 0) && o.impute ? "mid" : void 0
+                            binSuffix: (l = e.stack) != null && l.impute ? "mid" : void 0
                         });
-                    c && Ei(u) && (a[c] = !0)
+                    c && wi(u) && (s[c] = !0)
                 }
-                return a
+                return s
             }, {}),
-            r = Y(i);
+            r = H(i);
         if (r.length > 0) {
-            const a = t ? "||" : "&&";
-            return r.map(s => FO(s, t)).join(` ${a} `)
+            const s = t ? "||" : "&&";
+            return r.map(a => JE(a, t)).join(` ${s} `)
         }
     }
 
-    function H$(e, t) {
+    function a3(e, t) {
         if (t !== void 0) return {
-            [e]: ct(t)
+            [e]: ut(t)
         }
     }
-    const Qv = "voronoi",
-        hz = {
+    const Mv = "voronoi",
+        Az = {
             defined: e => e.type === "point" && e.nearest,
             parse: (e, t) => {
                 if (t.events)
-                    for (const n of t.events) n.markname = e.getName(Qv)
+                    for (const n of t.events) n.markname = e.getName(Mv)
             },
             marks: (e, t, n) => {
                 const {
                     x: i,
                     y: r
-                } = t.project.hasChannel, a = e.mark;
-                if (wo(a)) return X(Nfe(a)), n;
-                const s = {
-                    name: e.getName(Qv),
+                } = t.project.hasChannel, s = e.mark;
+                if (uo(s)) return X(Uce(s)), n;
+                const a = {
+                    name: e.getName(Mv),
                     type: "path",
                     interactive: !0,
                     from: {
                         data: e.getName("marks")
                     },
                     encode: {
-                        update: Object.assign({
+                        update: {
                             fill: {
                                 value: "transparent"
                             },
                             strokeWidth: {
                                 value: .35
                             },
                             stroke: {
                                 value: "transparent"
                             },
                             isVoronoi: {
                                 value: !0
-                            }
-                        }, oz(e, {
-                            reactiveGeom: !0
-                        }))
+                            },
+                            ...wz(e, {
+                                reactiveGeom: !0
+                            })
+                        }
                     },
                     transform: [{
                         type: "voronoi",
                         x: {
                             expr: i || !r ? "datum.datum.x || 0" : "0"
                         },
                         y: {
@@ -44005,370 +44337,366 @@
                         },
                         size: [e.getSizeSignalRef("width"), e.getSizeSignalRef("height")]
                     }]
                 };
                 let o = 0,
                     l = !1;
                 return n.forEach((u, c) => {
-                    var f;
-                    const h = (f = u.name) !== null && f !== void 0 ? f : "";
-                    h === e.component.mark[0].name ? o = c : h.indexOf(Qv) >= 0 && (l = !0)
-                }), l || n.splice(o + 1, 0, s), n
+                    const f = u.name ?? "";
+                    f === e.component.mark[0].name ? o = c : f.indexOf(Mv) >= 0 && (l = !0)
+                }), l || n.splice(o + 1, 0, a), n
             }
         },
-        dz = {
-            defined: e => e.type === "point" && e.resolve === "global" && e.bind && e.bind !== "scales" && !YO(e.bind),
-            parse: (e, t, n) => _z(t, n),
+        $z = {
+            defined: e => e.type === "point" && e.resolve === "global" && e.bind && e.bind !== "scales" && !hC(e.bind),
+            parse: (e, t, n) => Pz(t, n),
             topLevelSignals: (e, t, n) => {
                 const i = t.name,
                     r = t.project,
-                    a = t.bind,
-                    s = t.init && t.init[0],
-                    o = hz.defined(t) ? "(item().isVoronoi ? datum.datum : datum)" : "datum";
+                    s = t.bind,
+                    a = t.init && t.init[0],
+                    o = Az.defined(t) ? "(item().isVoronoi ? datum.datum : datum)" : "datum";
                 return r.items.forEach((l, u) => {
-                    var c, f;
-                    const h = ht(`${i}_${l.field}`);
-                    n.filter(g => g.name === h).length || n.unshift(Object.assign(Object.assign({
-                        name: h
-                    }, s ? {
-                        init: Cl(s[u])
-                    } : {
-                        value: null
-                    }), {
+                    const c = ft(`${i}_${l.field}`);
+                    n.filter(h => h.name === c).length || n.unshift({
+                        name: c,
+                        ...a ? {
+                            init: pl(a[u])
+                        } : {
+                            value: null
+                        },
                         on: t.events ? [{
                             events: t.events,
                             update: `datum && item().mark.marktype !== 'group' ? ${o}[${Z(l.field)}] : null`
                         }] : [],
-                        bind: (f = (c = a[l.field]) !== null && c !== void 0 ? c : a[l.channel]) !== null && f !== void 0 ? f : a
-                    }))
+                        bind: s[l.field] ?? s[l.channel] ?? s
+                    })
                 }), n
             },
             signals: (e, t, n) => {
                 const i = t.name,
                     r = t.project,
-                    a = n.filter(u => u.name === i + to)[0],
-                    s = i + Qd,
-                    o = r.items.map(u => ht(`${i}_${u.field}`)),
+                    s = n.filter(u => u.name === i + Wa)[0],
+                    a = i + Ld,
+                    o = r.items.map(u => ft(`${i}_${u.field}`)),
                     l = o.map(u => `${u} !== null`).join(" && ");
-                return o.length && (a.update = `${l} ? {fields: ${s}, values: [${o.join(", ")}]} : null`), delete a.value, delete a.on, n
+                return o.length && (s.update = `${l} ? {fields: ${a}, values: [${o.join(", ")}]} : null`), delete s.value, delete s.on, n
             }
         },
-        hm = "_toggle",
-        gz = {
+        X0 = "_toggle",
+        Tz = {
             defined: e => e.type === "point" && !!e.toggle,
             signals: (e, t, n) => n.concat({
-                name: t.name + hm,
+                name: t.name + X0,
                 value: !1,
                 on: [{
                     events: t.events,
                     update: t.toggle
                 }]
             }),
             modifyExpr: (e, t) => {
-                const n = t.name + to,
-                    i = t.name + hm;
-                return `${i} ? null : ${n}, ` + (t.resolve === "global" ? `${i} ? null : true, ` : `${i} ? null : {unit: ${vc(e)}}, `) + `${i} ? ${n} : null`
+                const n = t.name + Wa,
+                    i = t.name + X0;
+                return `${i} ? null : ${n}, ` + (t.resolve === "global" ? `${i} ? null : true, ` : `${i} ? null : {unit: ${Yo(e)}}, `) + `${i} ? ${n} : null`
             }
         },
-        y0e = {
+        mpe = {
             defined: e => e.clear !== void 0 && e.clear !== !1,
             parse: (e, t) => {
-                t.clear && (t.clear = re(t.clear) ? ho(t.clear, "view") : t.clear)
+                t.clear && (t.clear = re(t.clear) ? to(t.clear, "view") : t.clear)
             },
             topLevelSignals: (e, t, n) => {
-                if (dz.defined(t))
+                if ($z.defined(t))
                     for (const i of t.project.items) {
-                        const r = n.findIndex(a => a.name === ht(`${t.name}_${i.field}`));
+                        const r = n.findIndex(s => s.name === ft(`${t.name}_${i.field}`));
                         r !== -1 && n[r].on.push({
                             events: t.clear,
                             update: "null"
                         })
                     }
                 return n
             },
             signals: (e, t, n) => {
-                function i(r, a) {
+                function i(r, s) {
                     r !== -1 && n[r].on && n[r].on.push({
                         events: t.clear,
-                        update: a
+                        update: s
                     })
                 }
                 if (t.type === "interval")
                     for (const r of t.project.items) {
-                        const a = n.findIndex(s => s.name === r.signals.visual);
-                        if (i(a, "[0, 0]"), a === -1) {
-                            const s = n.findIndex(o => o.name === r.signals.data);
-                            i(s, "null")
+                        const s = n.findIndex(a => a.name === r.signals.visual);
+                        if (i(s, "[0, 0]"), s === -1) {
+                            const a = n.findIndex(o => o.name === r.signals.data);
+                            i(a, "null")
                         }
                     } else {
-                        let r = n.findIndex(a => a.name === t.name + to);
-                        i(r, "null"), gz.defined(t) && (r = n.findIndex(a => a.name === t.name + hm), i(r, "false"))
+                        let r = n.findIndex(s => s.name === t.name + Wa);
+                        i(r, "null"), Tz.defined(t) && (r = n.findIndex(s => s.name === t.name + X0), i(r, "false"))
                     }
                 return n
             }
         },
-        pz = {
+        Mz = {
             defined: e => {
-                const t = e.resolve === "global" && e.bind && YO(e.bind),
-                    n = e.project.items.length === 1 && e.project.items[0].field !== ra;
-                return t && !n && X(jfe), t && n
+                const t = e.resolve === "global" && e.bind && hC(e.bind),
+                    n = e.project.items.length === 1 && e.project.items[0].field !== pr;
+                return t && !n && X(qce), t && n
             },
             parse: (e, t, n) => {
-                var i;
-                const r = Ce(n);
-                if (r.select = re(r.select) ? {
-                        type: r.select,
+                const i = ke(n);
+                if (i.select = re(i.select) ? {
+                        type: i.select,
                         toggle: t.toggle
-                    } : Object.assign(Object.assign({}, r.select), {
+                    } : {
+                        ...i.select,
                         toggle: t.toggle
-                    }), _z(t, r), se(n.select) && (n.select.on || n.select.clear)) {
-                    const o = 'event.item && indexof(event.item.mark.role, "legend") < 0';
-                    for (const l of t.events) l.filter = ie((i = l.filter) !== null && i !== void 0 ? i : []), l.filter.includes(o) || l.filter.push(o)
+                    }, Pz(t, i), ae(n.select) && (n.select.on || n.select.clear)) {
+                    const a = 'event.item && indexof(event.item.mark.role, "legend") < 0';
+                    for (const o of t.events) o.filter = se(o.filter ?? []), o.filter.includes(a) || o.filter.push(a)
                 }
-                const a = Vv(t.bind) ? t.bind.legend : "click",
-                    s = re(a) ? ho(a, "view") : ie(a);
+                const r = Av(t.bind) ? t.bind.legend : "click",
+                    s = re(r) ? to(r, "view") : se(r);
                 t.bind = {
                     legend: {
                         merge: s
                     }
                 }
             },
             topLevelSignals: (e, t, n) => {
                 const i = t.name,
-                    r = Vv(t.bind) && t.bind.legend,
-                    a = s => o => {
-                        const l = Ce(o);
-                        return l.markname = s, l
+                    r = Av(t.bind) && t.bind.legend,
+                    s = a => o => {
+                        const l = ke(o);
+                        return l.markname = a, l
                     };
-                for (const s of t.project.items) {
-                    if (!s.hasLegend) continue;
-                    const o = `${ht(s.field)}_legend`,
+                for (const a of t.project.items) {
+                    if (!a.hasLegend) continue;
+                    const o = `${ft(a.field)}_legend`,
                         l = `${i}_${o}`;
                     if (n.filter(c => c.name === l).length === 0) {
-                        const c = r.merge.map(a(`${o}_symbols`)).concat(r.merge.map(a(`${o}_labels`))).concat(r.merge.map(a(`${o}_entries`)));
-                        n.unshift(Object.assign(Object.assign({
-                            name: l
-                        }, t.init ? {} : {
-                            value: null
-                        }), {
+                        const c = r.merge.map(s(`${o}_symbols`)).concat(r.merge.map(s(`${o}_labels`))).concat(r.merge.map(s(`${o}_entries`)));
+                        n.unshift({
+                            name: l,
+                            ...t.init ? {} : {
+                                value: null
+                            },
                             on: [{
                                 events: c,
-                                update: "datum.value || item().items[0].items[0].datum.value",
+                                update: "isDefined(datum.value) ? datum.value : item().items[0].items[0].datum.value",
                                 force: !0
                             }, {
                                 events: r.merge,
                                 update: `!event.item || !datum ? null : ${l}`,
                                 force: !0
                             }]
-                        }))
+                        })
                     }
                 }
                 return n
             },
             signals: (e, t, n) => {
                 const i = t.name,
                     r = t.project,
-                    a = n.find(h => h.name === i + to),
-                    s = i + Qd,
-                    o = r.items.filter(h => h.hasLegend).map(h => ht(`${i}_${ht(h.field)}_legend`)),
-                    u = `${o.map(h=>`${h} !== null`).join(" && ")} ? {fields: ${s}, values: [${o.join(", ")}]} : null`;
-                t.events && o.length > 0 ? a.on.push({
+                    s = n.find(h => h.name === i + Wa),
+                    a = i + Ld,
+                    o = r.items.filter(h => h.hasLegend).map(h => ft(`${i}_${ft(h.field)}_legend`)),
+                    u = `${o.map(h=>`${h} !== null`).join(" && ")} ? {fields: ${a}, values: [${o.join(", ")}]} : null`;
+                t.events && o.length > 0 ? s.on.push({
                     events: o.map(h => ({
                         signal: h
                     })),
                     update: u
-                }) : o.length > 0 && (a.update = u, delete a.value, delete a.on);
-                const c = n.find(h => h.name === i + hm),
-                    f = Vv(t.bind) && t.bind.legend;
-                return c && (t.events ? c.on.push(Object.assign(Object.assign({}, c.on[0]), {
+                }) : o.length > 0 && (s.update = u, delete s.value, delete s.on);
+                const c = n.find(h => h.name === i + X0),
+                    f = Av(t.bind) && t.bind.legend;
+                return c && (t.events ? c.on.push({
+                    ...c.on[0],
                     events: f
-                })) : c.on[0].events = f), n
+                }) : c.on[0].events = f), n
             }
         };
 
-    function v0e(e, t, n) {
-        var i, r, a, s;
-        const o = (i = e.fieldDef(t)) === null || i === void 0 ? void 0 : i.field;
-        for (const l of _n((r = e.component.selection) !== null && r !== void 0 ? r : {})) {
-            const u = (a = l.project.hasField[o]) !== null && a !== void 0 ? a : l.project.hasChannel[t];
-            if (u && pz.defined(l)) {
-                const c = (s = n.get("selections")) !== null && s !== void 0 ? s : [];
-                c.push(l.name), n.set("selections", c, !1), u.hasLegend = !0
+    function ype(e, t, n) {
+        var r;
+        const i = (r = e.fieldDef(t)) == null ? void 0 : r.field;
+        for (const s of Qt(e.component.selection ?? {})) {
+            const a = s.project.hasField[i] ?? s.project.hasChannel[t];
+            if (a && Mz.defined(s)) {
+                const o = n.get("selections") ?? [];
+                o.push(s.name), n.set("selections", o, !1), a.hasLegend = !0
             }
         }
     }
-    const mz = "_translate_anchor",
-        yz = "_translate_delta",
-        b0e = {
+    const Oz = "_translate_anchor",
+        Fz = "_translate_delta",
+        vpe = {
             defined: e => e.type === "interval" && e.translate,
             signals: (e, t, n) => {
                 const i = t.name,
-                    r = Zs.defined(t),
-                    a = i + mz,
+                    r = Ns.defined(t),
+                    s = i + Oz,
                     {
-                        x: s,
+                        x: a,
                         y: o
                     } = t.project.hasChannel;
-                let l = ho(t.translate, "scope");
-                return r || (l = l.map(u => (u.between[0].markname = i + Iu, u))), n.push({
-                    name: a,
+                let l = to(t.translate, "scope");
+                return r || (l = l.map(u => (u.between[0].markname = i + Au, u))), n.push({
+                    name: s,
                     value: {},
                     on: [{
                         events: l.map(u => u.between[0]),
-                        update: "{x: x(unit), y: y(unit)" + (s !== void 0 ? `, extent_x: ${r?Fx(e,yt):`slice(${s.signals.visual})`}` : "") + (o !== void 0 ? `, extent_y: ${r?Fx(e,Yt):`slice(${o.signals.visual})`}` : "") + "}"
+                        update: "{x: x(unit), y: y(unit)" + (a !== void 0 ? `, extent_x: ${r?ix(e,ht):`slice(${a.signals.visual})`}` : "") + (o !== void 0 ? `, extent_y: ${r?ix(e,Gt):`slice(${o.signals.visual})`}` : "") + "}"
                     }]
                 }, {
-                    name: i + yz,
+                    name: i + Fz,
                     value: {},
                     on: [{
                         events: l,
-                        update: `{x: ${a}.x - x(unit), y: ${a}.y - y(unit)}`
+                        update: `{x: ${s}.x - x(unit), y: ${s}.y - y(unit)}`
                     }]
-                }), s !== void 0 && Y$(e, t, s, "width", n), o !== void 0 && Y$(e, t, o, "height", n), n
+                }), a !== void 0 && o3(e, t, a, "width", n), o !== void 0 && o3(e, t, o, "height", n), n
             }
         };
 
-    function Y$(e, t, n, i, r) {
-        var a, s;
-        const o = t.name,
-            l = o + mz,
-            u = o + yz,
-            c = n.channel,
-            f = Zs.defined(t),
-            h = r.filter(w => w.name === n.signals[f ? "data" : "visual"])[0],
-            d = e.getSizeSignalRef(i).signal,
-            g = e.getScaleComponent(c),
-            p = g.get("type"),
-            m = g.get("reverse"),
-            y = f ? c === yt ? m ? "" : "-" : m ? "-" : "" : "",
-            v = `${l}.extent_${c}`,
-            b = `${y}${u}.${c} / ${f?`${d}`:`span(${v})`}`,
-            x = f ? p === "log" ? "panLog" : p === "symlog" ? "panSymlog" : p === "pow" ? "panPow" : "panLinear" : "panLinear",
-            _ = f ? p === "pow" ? `, ${(a=g.get("exponent"))!==null&&a!==void 0?a:1}` : p === "symlog" ? `, ${(s=g.get("constant"))!==null&&s!==void 0?s:1}` : "" : "",
-            S = `${x}(${v}, ${b}${_})`;
-        h.on.push({
+    function o3(e, t, n, i, r) {
+        const s = t.name,
+            a = s + Oz,
+            o = s + Fz,
+            l = n.channel,
+            u = Ns.defined(t),
+            c = r.filter(_ => _.name === n.signals[u ? "data" : "visual"])[0],
+            f = e.getSizeSignalRef(i).signal,
+            h = e.getScaleComponent(l),
+            d = h && h.get("type"),
+            g = h && h.get("reverse"),
+            p = u ? l === ht ? g ? "" : "-" : g ? "-" : "" : "",
+            m = `${a}.extent_${l}`,
+            y = `${p}${o}.${l} / ${u?`${f}`:`span(${m})`}`,
+            v = !u || !h ? "panLinear" : d === "log" ? "panLog" : d === "symlog" ? "panSymlog" : d === "pow" ? "panPow" : "panLinear",
+            b = u ? d === "pow" ? `, ${h.get("exponent")??1}` : d === "symlog" ? `, ${h.get("constant")??1}` : "" : "",
+            x = `${v}(${m}, ${y}${b})`;
+        c.on.push({
             events: {
-                signal: u
+                signal: o
             },
-            update: f ? S : `clampRange(${S}, 0, ${d})`
+            update: u ? x : `clampRange(${x}, 0, ${f})`
         })
     }
-    const vz = "_zoom_anchor",
-        bz = "_zoom_delta",
-        x0e = {
+    const Rz = "_zoom_anchor",
+        Dz = "_zoom_delta",
+        bpe = {
             defined: e => e.type === "interval" && e.zoom,
             signals: (e, t, n) => {
                 const i = t.name,
-                    r = Zs.defined(t),
-                    a = i + bz,
+                    r = Ns.defined(t),
+                    s = i + Dz,
                     {
-                        x: s,
+                        x: a,
                         y: o
                     } = t.project.hasChannel,
-                    l = Z(e.scaleName(yt)),
-                    u = Z(e.scaleName(Yt));
-                let c = ho(t.zoom, "scope");
-                return r || (c = c.map(f => (f.markname = i + Iu, f))), n.push({
-                    name: i + vz,
+                    l = Z(e.scaleName(ht)),
+                    u = Z(e.scaleName(Gt));
+                let c = to(t.zoom, "scope");
+                return r || (c = c.map(f => (f.markname = i + Au, f))), n.push({
+                    name: i + Rz,
                     on: [{
                         events: c,
-                        update: r ? "{" + [l ? `x: invert(${l}, x(unit))` : "", u ? `y: invert(${u}, y(unit))` : ""].filter(f => !!f).join(", ") + "}" : "{x: x(unit), y: y(unit)}"
+                        update: r ? "{" + [l ? `x: invert(${l}, x(unit))` : "", u ? `y: invert(${u}, y(unit))` : ""].filter(f => f).join(", ") + "}" : "{x: x(unit), y: y(unit)}"
                     }]
                 }, {
-                    name: a,
+                    name: s,
                     on: [{
                         events: c,
                         force: !0,
                         update: "pow(1.001, event.deltaY * pow(16, event.deltaMode))"
                     }]
-                }), s !== void 0 && X$(e, t, s, "width", n), o !== void 0 && X$(e, t, o, "height", n), n
+                }), a !== void 0 && l3(e, t, a, "width", n), o !== void 0 && l3(e, t, o, "height", n), n
             }
         };
 
-    function X$(e, t, n, i, r) {
-        var a, s;
-        const o = t.name,
-            l = n.channel,
-            u = Zs.defined(t),
-            c = r.filter(x => x.name === n.signals[u ? "data" : "visual"])[0],
-            f = e.getSizeSignalRef(i).signal,
-            h = e.getScaleComponent(l),
-            d = h.get("type"),
-            g = u ? Fx(e, l) : c.name,
-            p = o + bz,
-            m = `${o}${vz}.${l}`,
-            y = u ? d === "log" ? "zoomLog" : d === "symlog" ? "zoomSymlog" : d === "pow" ? "zoomPow" : "zoomLinear" : "zoomLinear",
-            v = u ? d === "pow" ? `, ${(a=h.get("exponent"))!==null&&a!==void 0?a:1}` : d === "symlog" ? `, ${(s=h.get("constant"))!==null&&s!==void 0?s:1}` : "" : "",
-            b = `${y}(${g}, ${m}, ${p}${v})`;
-        c.on.push({
+    function l3(e, t, n, i, r) {
+        const s = t.name,
+            a = n.channel,
+            o = Ns.defined(t),
+            l = r.filter(v => v.name === n.signals[o ? "data" : "visual"])[0],
+            u = e.getSizeSignalRef(i).signal,
+            c = e.getScaleComponent(a),
+            f = c && c.get("type"),
+            h = o ? ix(e, a) : l.name,
+            d = s + Dz,
+            g = `${s}${Rz}.${a}`,
+            p = !o || !c ? "zoomLinear" : f === "log" ? "zoomLog" : f === "symlog" ? "zoomSymlog" : f === "pow" ? "zoomPow" : "zoomLinear",
+            m = o ? f === "pow" ? `, ${c.get("exponent")??1}` : f === "symlog" ? `, ${c.get("constant")??1}` : "" : "",
+            y = `${p}(${h}, ${g}, ${d}${m})`;
+        l.on.push({
             events: {
-                signal: p
+                signal: d
             },
-            update: u ? b : `clampRange(${b}, 0, ${f})`
+            update: o ? y : `clampRange(${y}, 0, ${u})`
         })
     }
-    const kl = "_store",
-        to = "_tuple",
-        _0e = "_modify",
-        xz = "vlSelectionResolve",
-        fy = [e0e, Qpe, Kpe, gz, dz, Zs, pz, y0e, b0e, x0e, hz];
+    const ml = "_store",
+        Wa = "_tuple",
+        xpe = "_modify",
+        Nz = "vlSelectionResolve",
+        Y1 = [Zge, Jge, Vge, Tz, $z, Ns, Mz, mpe, vpe, bpe, Az];
 
-    function w0e(e) {
+    function _pe(e) {
         let t = e.parent;
-        for (; t && !mr(t);) t = t.parent;
+        for (; t && !lr(t);) t = t.parent;
         return t
     }
 
-    function vc(e, {
+    function Yo(e, {
         escape: t
     } = {
         escape: !0
     }) {
         let n = t ? Z(e.name) : e.name;
-        const i = w0e(e);
+        const i = _pe(e);
         if (i) {
             const {
                 facet: r
             } = i;
-            for (const a of Ri) r[a] && (n += ` + '__facet_${a}_' + (facet[${Z(i.vgField(a))}])`)
+            for (const s of Ti) r[s] && (n += ` + '__facet_${s}_' + (facet[${Z(i.vgField(s))}])`)
         }
         return n
     }
 
-    function rC(e) {
-        var t;
-        return _n((t = e.component.selection) !== null && t !== void 0 ? t : {}).reduce((n, i) => n || i.project.hasSelectionId, !1)
+    function SC(e) {
+        return Qt(e.component.selection ?? {}).reduce((t, n) => t || n.project.hasSelectionId, !1)
     }
 
-    function _z(e, t) {
+    function Pz(e, t) {
         (re(t.select) || !t.select.on) && delete e.events, (re(t.select) || !t.select.clear) && delete e.clear, (re(t.select) || !t.select.toggle) && delete e.toggle
     }
 
-    function Px(e) {
+    function rx(e) {
         const t = [];
-        return e.type === "Identifier" ? [e.name] : e.type === "Literal" ? [e.value] : (e.type === "MemberExpression" && (t.push(...Px(e.object)), t.push(...Px(e.property))), t)
+        return e.type === "Identifier" ? [e.name] : e.type === "Literal" ? [e.value] : (e.type === "MemberExpression" && (t.push(...rx(e.object)), t.push(...rx(e.property))), t)
     }
 
-    function wz(e) {
-        return e.object.type === "MemberExpression" ? wz(e.object) : e.object.name === "datum"
+    function Lz(e) {
+        return e.object.type === "MemberExpression" ? Lz(e.object) : e.object.name === "datum"
     }
 
-    function Sz(e) {
-        const t = _E(e),
+    function Iz(e) {
+        const t = jS(e),
             n = new Set;
         return t.visit(i => {
-            i.type === "MemberExpression" && wz(i) && n.add(Px(i).slice(1).join("."))
+            i.type === "MemberExpression" && Lz(i) && n.add(rx(i).slice(1).join("."))
         }), n
     }
-    class Hc extends it {
+    class Nc extends nt {
         clone() {
-            return new Hc(null, this.model, Ce(this.filter))
+            return new Nc(null, this.model, ke(this.filter))
         }
         constructor(t, n, i) {
-            super(t), this.model = n, this.filter = i, this.expr = dm(this.model, this.filter, this), this._dependentFields = Sz(this.expr)
+            super(t), this.model = n, this.filter = i, this.expr = V0(this.model, this.filter, this), this._dependentFields = Iz(this.expr)
         }
         dependentFields() {
             return this._dependentFields
         }
         producedFields() {
             return new Set
         }
@@ -44379,571 +44707,565 @@
             }
         }
         hash() {
             return `Filter ${this.expr}`
         }
     }
 
-    function S0e(e, t) {
-        var n;
-        const i = {},
-            r = e.config.selection;
-        if (!t || !t.length) return i;
-        for (const a of t) {
-            const s = ht(a.name),
-                o = a.select,
-                l = re(o) ? o : o.type,
-                u = se(o) ? Ce(o) : {
-                    type: l
-                },
-                c = r[l];
-            for (const h in c) h === "fields" || h === "encodings" || (h === "mark" && (u[h] = Object.assign(Object.assign({}, c[h]), u[h])), (u[h] === void 0 || u[h] === !0) && (u[h] = (n = c[h]) !== null && n !== void 0 ? n : u[h]));
-            const f = i[s] = Object.assign(Object.assign({}, u), {
-                name: s,
-                type: l,
-                init: a.value,
-                bind: a.bind,
-                events: re(u.on) ? ho(u.on, "scope") : ie(Ce(u.on))
-            });
-            for (const h of fy) h.defined(f) && h.parse && h.parse(e, f, a)
+    function wpe(e, t) {
+        const n = {},
+            i = e.config.selection;
+        if (!t || !t.length) return n;
+        for (const r of t) {
+            const s = ft(r.name),
+                a = r.select,
+                o = re(a) ? a : a.type,
+                l = ae(a) ? ke(a) : {
+                    type: o
+                },
+                u = i[o];
+            for (const h in u) h === "fields" || h === "encodings" || (h === "mark" && (l[h] = {
+                ...u[h],
+                ...l[h]
+            }), (l[h] === void 0 || l[h] === !0) && (l[h] = ke(u[h] ?? l[h])));
+            const c = n[s] = {
+                    ...l,
+                    name: s,
+                    type: o,
+                    init: r.value,
+                    bind: r.bind,
+                    events: re(l.on) ? to(l.on, "scope") : se(ke(l.on))
+                },
+                f = ke(r);
+            for (const h of Y1) h.defined(c) && h.parse && h.parse(e, c, f)
         }
-        return i
+        return n
     }
 
-    function Ez(e, t, n, i = "datum") {
+    function zz(e, t, n, i = "datum") {
         const r = re(t) ? t : t.param,
-            a = ht(r),
-            s = Z(a + kl);
+            s = ft(r),
+            a = Z(s + ml);
         let o;
         try {
-            o = e.getSelectionComponent(a, r)
+            o = e.getSelectionComponent(s, r)
         } catch {
-            return `!!${a}`
+            return `!!${s}`
         }
         if (o.project.timeUnit) {
             const h = n ?? e.component.data.raw,
                 d = o.project.timeUnit.clone();
             h.parent ? d.insertAsParentOf(h) : h.parent = d
         }
         const l = o.project.hasSelectionId ? "vlSelectionIdTest(" : "vlSelectionTest(",
             u = o.resolve === "global" ? ")" : `, ${Z(o.resolve)})`,
-            c = `${l}${s}, ${i}${u}`,
-            f = `length(data(${s}))`;
+            c = `${l}${a}, ${i}${u}`,
+            f = `length(data(${a}))`;
         return t.empty === !1 ? `${f} && ${c}` : `!${f} || ${c}`
     }
 
-    function Oz(e, t, n) {
-        const i = ht(t),
+    function Bz(e, t, n) {
+        const i = ft(t),
             r = n.encoding;
-        let a = n.field,
-            s;
+        let s = n.field,
+            a;
         try {
-            s = e.getSelectionComponent(i, t)
+            a = e.getSelectionComponent(i, t)
         } catch {
             return i
         }
-        if (!r && !a) a = s.project.items[0].field, s.project.items.length > 1 && X(`A "field" or "encoding" must be specified when using a selection as a scale domain. Using "field": ${Z(a)}.`);
-        else if (r && !a) {
-            const o = s.project.items.filter(l => l.channel === r);
-            !o.length || o.length > 1 ? (a = s.project.items[0].field, X((o.length ? "Multiple " : "No ") + `matching ${Z(r)} encoding found for selection ${Z(n.param)}. Using "field": ${Z(a)}.`)) : a = o[0].field
+        if (!r && !s) s = a.project.items[0].field, a.project.items.length > 1 && X(`A "field" or "encoding" must be specified when using a selection as a scale domain. Using "field": ${Z(s)}.`);
+        else if (r && !s) {
+            const o = a.project.items.filter(l => l.channel === r);
+            !o.length || o.length > 1 ? (s = a.project.items[0].field, X((o.length ? "Multiple " : "No ") + `matching ${Z(r)} encoding found for selection ${Z(n.param)}. Using "field": ${Z(s)}.`)) : s = o[0].field
         }
-        return `${s.name}[${Z(Bi(a))}]`
+        return `${a.name}[${Z(Pi(s))}]`
     }
 
-    function E0e(e, t) {
-        var n;
-        for (const [i, r] of Ks((n = e.component.selection) !== null && n !== void 0 ? n : {})) {
-            const a = e.getName(`lookup_${i}`);
-            e.component.data.outputNodes[a] = r.materialized = new Ln(new Hc(t, e, {
-                param: i
-            }), a, st.Lookup, e.component.data.outputNodeRefCounts)
+    function Spe(e, t) {
+        for (const [n, i] of Ba(e.component.selection ?? {})) {
+            const r = e.getName(`lookup_${n}`);
+            e.component.data.outputNodes[r] = i.materialized = new Dn(new Nc(t, e, {
+                param: n
+            }), r, st.Lookup, e.component.data.outputNodeRefCounts)
         }
     }
 
-    function dm(e, t, n) {
-        return bh(t, i => re(i) ? i : ede(i) ? Ez(e, i, n) : Gj(i))
-    }
-    var Wg = globalThis && globalThis.__rest || function(e, t) {
-        var n = {};
-        for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && t.indexOf(i) < 0 && (n[i] = e[i]);
-        if (e != null && typeof Object.getOwnPropertySymbols == "function")
-            for (var r = 0, i = Object.getOwnPropertySymbols(e); r < i.length; r++) t.indexOf(i[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, i[r]) && (n[i[r]] = e[i[r]]);
-        return n
-    };
+    function V0(e, t, n) {
+        return oh(t, i => re(i) ? i : ahe(i) ? zz(e, i, n) : i6(i))
+    }
 
-    function O0e(e, t) {
-        if (e) return q(e) && !xs(e) ? e.map(n => IO(n, t)).join(", ") : e
+    function Epe(e, t) {
+        if (e) return W(e) && !ca(e) ? e.map(n => iC(n, t)).join(", ") : e
     }
 
-    function Zv(e, t, n, i) {
-        var r, a, s, o, l;
-        (r = e.encode) !== null && r !== void 0 || (e.encode = {}), (a = (o = e.encode)[t]) !== null && a !== void 0 || (o[t] = {}), (s = (l = e.encode[t]).update) !== null && s !== void 0 || (l.update = {}), e.encode[t].update[n] = i
+    function Ov(e, t, n, i) {
+        var r, s;
+        e.encode ?? (e.encode = {}), (r = e.encode)[t] ?? (r[t] = {}), (s = e.encode[t]).update ?? (s.update = {}), e.encode[t].update[n] = i
     }
 
-    function th(e, t, n, i = {
+    function Gf(e, t, n, i = {
         header: !1
     }) {
-        var r, a;
-        const s = e.combine(),
-            {
-                disable: o,
-                orient: l,
-                scale: u,
-                labelExpr: c,
-                title: f,
-                zindex: h
-            } = s,
-            d = Wg(s, ["disable", "orient", "scale", "labelExpr", "title", "zindex"]);
-        if (!o) {
-            for (const g in d) {
-                const p = ige[g],
-                    m = d[g];
-                if (p && p !== t && p !== "both") delete d[g];
-                else if (Jd(m)) {
+        var f, h;
+        const {
+            disable: r,
+            orient: s,
+            scale: a,
+            labelExpr: o,
+            title: l,
+            zindex: u,
+            ...c
+        } = e.combine();
+        if (!r) {
+            for (const d in c) {
+                const g = lde[d],
+                    p = c[d];
+                if (g && g !== t && g !== "both") delete c[d];
+                else if (Pd(p)) {
                     const {
-                        condition: y
-                    } = m, v = Wg(m, ["condition"]), b = ie(y), x = O$[g];
-                    if (x) {
+                        condition: m,
+                        ...y
+                    } = p, v = se(m), b = B5[d];
+                    if (b) {
                         const {
-                            vgProp: _,
-                            part: S
-                        } = x, w = [...b.map(O => {
+                            vgProp: x,
+                            part: _
+                        } = b, S = [...v.map(w => {
                             const {
-                                test: k
-                            } = O, C = Wg(O, ["test"]);
-                            return Object.assign({
-                                test: dm(null, k)
-                            }, C)
-                        }), v];
-                        Zv(d, S, _, w), delete d[g]
-                    } else if (x === null) {
-                        const _ = {
-                            signal: b.map(S => {
+                                test: E,
+                                ...A
+                            } = w;
+                            return {
+                                test: V0(null, E),
+                                ...A
+                            }
+                        }), y];
+                        Ov(c, _, x, S), delete c[d]
+                    } else if (b === null) {
+                        const x = {
+                            signal: v.map(_ => {
                                 const {
-                                    test: w
-                                } = S, O = Wg(S, ["test"]);
-                                return `${dm(null,w)} ? ${c$(O)} : `
-                            }).join("") + c$(v)
+                                    test: S,
+                                    ...w
+                                } = _;
+                                return `${V0(null,S)} ? ${E5(w)} : `
+                            }).join("") + E5(y)
                         };
-                        d[g] = _
+                        c[d] = x
                     }
-                } else if (fe(m)) {
-                    const y = O$[g];
-                    if (y) {
+                } else if (he(p)) {
+                    const m = B5[d];
+                    if (m) {
                         const {
-                            vgProp: v,
-                            part: b
-                        } = y;
-                        Zv(d, b, v, m), delete d[g]
+                            vgProp: y,
+                            part: v
+                        } = m;
+                        Ov(c, v, y, p), delete c[d]
                     }
                 }
-                Pe(["labelAlign", "labelBaseline"], g) && d[g] === null && delete d[g]
+                Fe(["labelAlign", "labelBaseline"], d) && c[d] === null && delete c[d]
             }
             if (t === "grid") {
-                if (!d.grid) return;
-                if (d.encode) {
+                if (!c.grid) return;
+                if (c.encode) {
                     const {
-                        grid: g
-                    } = d.encode;
-                    d.encode = Object.assign({}, g ? {
-                        grid: g
-                    } : {}), et(d.encode) && delete d.encode
-                }
-                return Object.assign(Object.assign({
-                    scale: u,
-                    orient: l
-                }, d), {
+                        grid: d
+                    } = c.encode;
+                    c.encode = {
+                        ...d ? {
+                            grid: d
+                        } : {}
+                    }, et(c.encode) && delete c.encode
+                }
+                return {
+                    scale: a,
+                    orient: s,
+                    ...c,
                     domain: !1,
                     labels: !1,
                     aria: !1,
                     maxExtent: 0,
                     minExtent: 0,
                     ticks: !1,
-                    zindex: Tt(h, 0)
-                })
+                    zindex: Ct(u, 0)
+                }
             } else {
                 if (!i.header && e.mainExtracted) return;
-                if (c !== void 0) {
-                    let p = c;
-                    !((a = (r = d.encode) === null || r === void 0 ? void 0 : r.labels) === null || a === void 0) && a.update && fe(d.encode.labels.update.text) && (p = xl(c, "datum.label", d.encode.labels.update.text.signal)), Zv(d, "labels", "text", {
-                        signal: p
+                if (o !== void 0) {
+                    let g = o;
+                    (h = (f = c.encode) == null ? void 0 : f.labels) != null && h.update && he(c.encode.labels.update.text) && (g = ll(o, "datum.label", c.encode.labels.update.text.signal)), Ov(c, "labels", "text", {
+                        signal: g
                     })
                 }
-                if (d.labelAlign === null && delete d.labelAlign, d.encode) {
-                    for (const p of b6) e.hasAxisPart(p) || delete d.encode[p];
-                    et(d.encode) && delete d.encode
-                }
-                const g = O0e(f, n);
-                return Object.assign(Object.assign(Object.assign(Object.assign({
-                    scale: u,
-                    orient: l,
-                    grid: !1
-                }, g ? {
-                    title: g
-                } : {}), d), n.aria === !1 ? {
-                    aria: !1
-                } : {}), {
-                    zindex: Tt(h, 0)
-                })
+                if (c.labelAlign === null && delete c.labelAlign, c.encode) {
+                    for (const g of N6) e.hasAxisPart(g) || delete c.encode[g];
+                    et(c.encode) && delete c.encode
+                }
+                const d = Epe(l, n);
+                return {
+                    scale: a,
+                    orient: s,
+                    grid: !1,
+                    ...d ? {
+                        title: d
+                    } : {},
+                    ...c,
+                    ...n.aria === !1 ? {
+                        aria: !1
+                    } : {},
+                    zindex: Ct(u, 0)
+                }
             }
         }
     }
 
-    function Cz(e) {
+    function jz(e) {
         const {
             axes: t
         } = e.component, n = [];
-        for (const i of xa)
+        for (const i of cs)
             if (t[i]) {
                 for (const r of t[i])
                     if (!r.get("disable") && !r.get("gridScale")) {
-                        const a = i === "x" ? "height" : "width",
-                            s = e.getSizeSignalRef(a).signal;
-                        a !== s && n.push({
-                            name: a,
-                            update: s
+                        const s = i === "x" ? "height" : "width",
+                            a = e.getSizeSignalRef(s).signal;
+                        s !== a && n.push({
+                            name: s,
+                            update: a
                         })
                     }
             } return n
     }
 
-    function C0e(e, t) {
+    function Cpe(e, t) {
         const {
             x: n = [],
             y: i = []
         } = e;
-        return [...n.map(r => th(r, "grid", t)), ...i.map(r => th(r, "grid", t)), ...n.map(r => th(r, "main", t)), ...i.map(r => th(r, "main", t))].filter(r => r)
+        return [...n.map(r => Gf(r, "grid", t)), ...i.map(r => Gf(r, "grid", t)), ...n.map(r => Gf(r, "main", t)), ...i.map(r => Gf(r, "main", t))].filter(r => r)
     }
 
-    function V$(e, t, n, i) {
+    function u3(e, t, n, i) {
         return Object.assign.apply(null, [{}, ...e.map(r => {
             if (r === "axisOrient") {
-                const a = n === "x" ? "bottom" : "left",
-                    s = t[n === "x" ? "axisBottom" : "axisLeft"] || {},
+                const s = n === "x" ? "bottom" : "left",
+                    a = t[n === "x" ? "axisBottom" : "axisLeft"] || {},
                     o = t[n === "x" ? "axisTop" : "axisRight"] || {},
-                    l = new Set([...Y(s), ...Y(o)]),
+                    l = new Set([...H(a), ...H(o)]),
                     u = {};
                 for (const c of l.values()) u[c] = {
-                    signal: `${i.signal} === "${a}" ? ${qa(s[c])} : ${qa(o[c])}`
+                    signal: `${i.signal} === "${s}" ? ${Ds(a[c])} : ${Ds(o[c])}`
                 };
                 return u
             }
             return t[r]
         })])
     }
 
-    function k0e(e, t, n, i) {
-        const r = t === "band" ? ["axisDiscrete", "axisBand"] : t === "point" ? ["axisDiscrete", "axisPoint"] : Hj(t) ? ["axisQuantitative"] : t === "time" || t === "utc" ? ["axisTemporal"] : [],
-            a = e === "x" ? "axisX" : "axisY",
-            s = fe(n) ? "axisOrient" : `axis${zd(n)}`,
-            o = [...r, ...r.map(u => a + u.substr(4))],
-            l = ["axis", s, a];
+    function kpe(e, t, n, i) {
+        const r = t === "band" ? ["axisDiscrete", "axisBand"] : t === "point" ? ["axisDiscrete", "axisPoint"] : o6(t) ? ["axisQuantitative"] : t === "time" || t === "utc" ? ["axisTemporal"] : [],
+            s = e === "x" ? "axisX" : "axisY",
+            a = he(n) ? "axisOrient" : `axis${$d(n)}`,
+            o = [...r, ...r.map(u => s + u.substr(4))],
+            l = ["axis", a, s];
         return {
-            vlOnlyAxisConfig: V$(o, i, e, n),
-            vgAxisConfig: V$(l, i, e, n),
-            axisConfigStyle: A0e([...l, ...o], i)
+            vlOnlyAxisConfig: u3(o, i, e, n),
+            vgAxisConfig: u3(l, i, e, n),
+            axisConfigStyle: Ape([...l, ...o], i)
         }
     }
 
-    function A0e(e, t) {
-        var n;
-        const i = [{}];
+    function Ape(e, t) {
+        var i;
+        const n = [{}];
         for (const r of e) {
-            let a = (n = t[r]) === null || n === void 0 ? void 0 : n.style;
-            if (a) {
-                a = ie(a);
-                for (const s of a) i.push(t.style[s])
+            let s = (i = t[r]) == null ? void 0 : i.style;
+            if (s) {
+                s = se(s);
+                for (const a of s) n.push(t.style[a])
             }
         }
-        return Object.assign.apply(null, i)
+        return Object.assign.apply(null, n)
     }
 
-    function Nx(e, t, n, i = {}) {
-        var r;
-        const a = Ej(e, n, t);
-        if (a !== void 0) return {
+    function sx(e, t, n, i = {}) {
+        var s;
+        const r = II(e, n, t);
+        if (r !== void 0) return {
             configFrom: "style",
-            configValue: a
+            configValue: r
         };
-        for (const s of ["vlOnlyAxisConfig", "vgAxisConfig", "axisConfigStyle"])
-            if (((r = i[s]) === null || r === void 0 ? void 0 : r[e]) !== void 0) return {
-                configFrom: s,
-                configValue: i[s][e]
+        for (const a of ["vlOnlyAxisConfig", "vgAxisConfig", "axisConfigStyle"])
+            if (((s = i[a]) == null ? void 0 : s[e]) !== void 0) return {
+                configFrom: a,
+                configValue: i[a][e]
             };
         return {}
     }
-    const K$ = {
+    const c3 = {
         scale: ({
             model: e,
             channel: t
         }) => e.scaleName(t),
         format: ({
-            fieldOrDatumDef: e,
-            config: t,
-            axis: n
-        }) => {
-            const {
-                format: i,
-                formatType: r
-            } = n;
-            return r6(e, e.type, i, r, t, !0)
-        },
+            format: e
+        }) => e,
         formatType: ({
-            axis: e,
-            fieldOrDatumDef: t,
-            scaleType: n
-        }) => {
-            const {
-                formatType: i
-            } = e;
-            return a6(i, t, n)
-        },
+            formatType: e
+        }) => e,
         grid: ({
             fieldOrDatumDef: e,
             axis: t,
             scaleType: n
-        }) => {
-            var i;
-            return (i = t.grid) !== null && i !== void 0 ? i : T0e(n, e)
-        },
+        }) => t.grid ?? $pe(n, e),
         gridScale: ({
             model: e,
             channel: t
-        }) => $0e(e, t),
+        }) => Tpe(e, t),
         labelAlign: ({
             axis: e,
             labelAngle: t,
             orient: n,
             channel: i
-        }) => e.labelAlign || Az(t, n, i),
+        }) => e.labelAlign || Gz(t, n, i),
         labelAngle: ({
             labelAngle: e
         }) => e,
         labelBaseline: ({
             axis: e,
             labelAngle: t,
             orient: n,
             channel: i
-        }) => e.labelBaseline || kz(t, n, i),
+        }) => e.labelBaseline || Uz(t, n, i),
         labelFlush: ({
             axis: e,
             fieldOrDatumDef: t,
             channel: n
-        }) => {
-            var i;
-            return (i = e.labelFlush) !== null && i !== void 0 ? i : F0e(t.type, n)
-        },
+        }) => e.labelFlush ?? Ope(t.type, n),
         labelOverlap: ({
             axis: e,
             fieldOrDatumDef: t,
             scaleType: n
-        }) => {
-            var i;
-            return (i = e.labelOverlap) !== null && i !== void 0 ? i : D0e(t.type, n, J(t) && !!t.timeUnit, J(t) ? t.sort : void 0)
-        },
+        }) => e.labelOverlap ?? Fpe(t.type, n, K(t) && !!t.timeUnit, K(t) ? t.sort : void 0),
         orient: ({
             orient: e
         }) => e,
         tickCount: ({
             channel: e,
             model: t,
             axis: n,
             fieldOrDatumDef: i,
             scaleType: r
         }) => {
-            var a;
             const s = e === "x" ? "width" : e === "y" ? "height" : void 0,
-                o = s ? t.getSizeSignalRef(s) : void 0;
-            return (a = n.tickCount) !== null && a !== void 0 ? a : P0e({
+                a = s ? t.getSizeSignalRef(s) : void 0;
+            return n.tickCount ?? Dpe({
                 fieldOrDatumDef: i,
                 scaleType: r,
-                size: o,
+                size: a,
                 values: n.values
             })
         },
+        tickMinStep: Npe,
         title: ({
             axis: e,
             model: t,
             channel: n
         }) => {
             if (e.title !== void 0) return e.title;
-            const i = Tz(t, n);
+            const i = Wz(t, n);
             if (i !== void 0) return i;
             const r = t.typedFieldDef(n),
-                a = n === "x" ? "x2" : "y2",
-                s = t.fieldDef(a);
-            return Cj(r ? [E$(r)] : [], J(s) ? [E$(s)] : [])
+                s = n === "x" ? "x2" : "y2",
+                a = t.fieldDef(s);
+            return BI(r ? [I5(r)] : [], K(a) ? [I5(a)] : [])
         },
         values: ({
             axis: e,
             fieldOrDatumDef: t
-        }) => N0e(e, t),
+        }) => Ppe(e, t),
         zindex: ({
             axis: e,
             fieldOrDatumDef: t,
             mark: n
-        }) => {
-            var i;
-            return (i = e.zindex) !== null && i !== void 0 ? i : L0e(n, t)
-        }
+        }) => e.zindex ?? Lpe(n, t)
     };
 
-    function T0e(e, t) {
-        return !Vt(e) && J(t) && !lt(t == null ? void 0 : t.bin) && !Qt(t == null ? void 0 : t.bin)
+    function $pe(e, t) {
+        return !qt(e) && K(t) && !ot(t == null ? void 0 : t.bin) && !Xt(t == null ? void 0 : t.bin)
     }
 
-    function $0e(e, t) {
+    function Tpe(e, t) {
         const n = t === "x" ? "y" : "x";
         if (e.getScaleComponent(n)) return e.scaleName(n)
     }
 
-    function M0e(e, t, n, i, r) {
-        const a = t == null ? void 0 : t.labelAngle;
-        if (a !== void 0) return fe(a) ? a : Jh(a); {
+    function Mpe(e, t, n, i, r) {
+        const s = t == null ? void 0 : t.labelAngle;
+        if (s !== void 0) return he(s) ? s : zh(s); {
             const {
-                configValue: s
-            } = Nx("labelAngle", i, t == null ? void 0 : t.style, r);
-            return s !== void 0 ? Jh(s) : n === yt && Pe([kO, CO], e.type) && !(J(e) && e.timeUnit) ? 270 : void 0
+                configValue: a
+            } = sx("labelAngle", i, t == null ? void 0 : t.style, r);
+            return a !== void 0 ? zh(a) : n === ht && Fe([HE, qE], e.type) && !(K(e) && e.timeUnit) ? 270 : void 0
         }
     }
 
-    function Lx(e) {
+    function ax(e) {
         return `(((${e.signal} % 360) + 360) % 360)`
     }
 
-    function kz(e, t, n, i) {
+    function Uz(e, t, n, i) {
         if (e !== void 0)
             if (n === "x") {
-                if (fe(e)) {
-                    const r = Lx(e),
-                        a = fe(t) ? `(${t.signal} === "top")` : t === "top";
+                if (he(e)) {
+                    const r = ax(e),
+                        s = he(t) ? `(${t.signal} === "top")` : t === "top";
                     return {
-                        signal: `(45 < ${r} && ${r} < 135) || (225 < ${r} && ${r} < 315) ? "middle" :(${r} <= 45 || 315 <= ${r}) === ${a} ? "bottom" : "top"`
+                        signal: `(45 < ${r} && ${r} < 135) || (225 < ${r} && ${r} < 315) ? "middle" :(${r} <= 45 || 315 <= ${r}) === ${s} ? "bottom" : "top"`
                     }
                 }
                 if (45 < e && e < 135 || 225 < e && e < 315) return "middle";
-                if (fe(t)) {
+                if (he(t)) {
                     const r = e <= 45 || 315 <= e ? "===" : "!==";
                     return {
                         signal: `${t.signal} ${r} "top" ? "bottom" : "top"`
                     }
                 }
                 return (e <= 45 || 315 <= e) == (t === "top") ? "bottom" : "top"
             } else {
-                if (fe(e)) {
-                    const r = Lx(e),
-                        a = fe(t) ? `(${t.signal} === "left")` : t === "left";
+                if (he(e)) {
+                    const r = ax(e),
+                        s = he(t) ? `(${t.signal} === "left")` : t === "left";
                     return {
-                        signal: `${r} <= 45 || 315 <= ${r} || (135 <= ${r} && ${r} <= 225) ? ${i?'"middle"':"null"} : (45 <= ${r} && ${r} <= 135) === ${a} ? "top" : "bottom"`
+                        signal: `${r} <= 45 || 315 <= ${r} || (135 <= ${r} && ${r} <= 225) ? ${i?'"middle"':"null"} : (45 <= ${r} && ${r} <= 135) === ${s} ? "top" : "bottom"`
                     }
                 }
                 if (e <= 45 || 315 <= e || 135 <= e && e <= 225) return i ? "middle" : null;
-                if (fe(t)) {
+                if (he(t)) {
                     const r = 45 <= e && e <= 135 ? "===" : "!==";
                     return {
                         signal: `${t.signal} ${r} "left" ? "top" : "bottom"`
                     }
                 }
                 return (45 <= e && e <= 135) == (t === "left") ? "top" : "bottom"
             }
     }
 
-    function Az(e, t, n) {
+    function Gz(e, t, n) {
         if (e === void 0) return;
         const i = n === "x",
             r = i ? 0 : 90,
-            a = i ? "bottom" : "left";
-        if (fe(e)) {
-            const s = Lx(e),
-                o = fe(t) ? `(${t.signal} === "${a}")` : t === a;
+            s = i ? "bottom" : "left";
+        if (he(e)) {
+            const a = ax(e),
+                o = he(t) ? `(${t.signal} === "${s}")` : t === s;
             return {
-                signal: `(${r?`(${s} + 90)`:s} % 180 === 0) ? ${i?null:'"center"'} :(${r} < ${s} && ${s} < ${180+r}) === ${o} ? "left" : "right"`
+                signal: `(${r?`(${a} + 90)`:a} % 180 === 0) ? ${i?null:'"center"'} :(${r} < ${a} && ${a} < ${180+r}) === ${o} ? "left" : "right"`
             }
         }
         if ((e + r) % 180 === 0) return i ? null : "center";
-        if (fe(t)) {
-            const s = r < e && e < 180 + r ? "===" : "!==";
+        if (he(t)) {
+            const a = r < e && e < 180 + r ? "===" : "!==";
             return {
-                signal: `${`${t.signal} ${s} "${a}"`} ? "left" : "right"`
+                signal: `${`${t.signal} ${a} "${s}"`} ? "left" : "right"`
             }
         }
-        return (r < e && e < 180 + r) == (t === a) ? "left" : "right"
+        return (r < e && e < 180 + r) == (t === s) ? "left" : "right"
     }
 
-    function F0e(e, t) {
-        if (t === "x" && Pe(["quantitative", "temporal"], e)) return !0
+    function Ope(e, t) {
+        if (t === "x" && Fe(["quantitative", "temporal"], e)) return !0
     }
 
-    function D0e(e, t, n, i) {
-        if (n && !se(i) || e !== "nominal" && e !== "ordinal") return t === "log" || t === "symlog" ? "greedy" : !0
+    function Fpe(e, t, n, i) {
+        if (n && !ae(i) || e !== "nominal" && e !== "ordinal") return t === "log" || t === "symlog" ? "greedy" : !0
     }
 
-    function R0e(e) {
+    function Rpe(e) {
         return e === "x" ? "bottom" : "left"
     }
 
-    function P0e({
+    function Dpe({
         fieldOrDatumDef: e,
         scaleType: t,
         size: n,
         values: i
     }) {
         var r;
-        if (!i && !Vt(t) && t !== "log") {
-            if (J(e)) {
-                if (lt(e.bin)) return {
+        if (!i && !qt(t) && t !== "log") {
+            if (K(e)) {
+                if (ot(e.bin)) return {
                     signal: `ceil(${n.signal}/10)`
                 };
-                if (e.timeUnit && Pe(["month", "hours", "day", "quarter"], (r = En(e.timeUnit)) === null || r === void 0 ? void 0 : r.unit)) return
+                if (e.timeUnit && Fe(["month", "hours", "day", "quarter"], (r = en(e.timeUnit)) == null ? void 0 : r.unit)) return
             }
             return {
                 signal: `ceil(${n.signal}/40)`
             }
         }
     }
 
-    function Tz(e, t) {
+    function Npe({
+        format: e,
+        fieldOrDatumDef: t
+    }) {
+        if (e === "d") return 1;
+        if (K(t)) {
+            const {
+                timeUnit: n
+            } = t;
+            if (n) {
+                const i = t6(n);
+                if (i) return {
+                    signal: i
+                }
+            }
+        }
+    }
+
+    function Wz(e, t) {
         const n = t === "x" ? "x2" : "y2",
             i = e.fieldDef(t),
             r = e.fieldDef(n),
-            a = i ? i.title : void 0,
-            s = r ? r.title : void 0;
-        if (a && s) return kj(a, s);
-        if (a) return a;
+            s = i ? i.title : void 0,
+            a = r ? r.title : void 0;
+        if (s && a) return jI(s, a);
         if (s) return s;
-        if (a !== void 0) return a;
-        if (s !== void 0) return s
+        if (a) return a;
+        if (s !== void 0) return s;
+        if (a !== void 0) return a
     }
 
-    function N0e(e, t) {
+    function Ppe(e, t) {
         const n = e.values;
-        if (q(n)) return v6(t, n);
-        if (fe(n)) return n
+        if (W(n)) return D6(t, n);
+        if (he(n)) return n
     }
 
-    function L0e(e, t) {
-        return e === "rect" && am(t) ? 1 : 0
+    function Lpe(e, t) {
+        return e === "rect" && j0(t) ? 1 : 0
     }
-    class bc extends it {
+    class lc extends nt {
         clone() {
-            return new bc(null, Ce(this.transform))
+            return new lc(null, ke(this.transform))
         }
         constructor(t, n) {
-            super(t), this.transform = n, this._dependentFields = Sz(this.transform.calculate)
+            super(t), this.transform = n, this._dependentFields = Iz(this.transform.calculate)
         }
         static parseAllForSortIndex(t, n) {
             return n.forEachFieldDef((i, r) => {
-                if (Vl(i) && l6(i.sort)) {
+                if (Il(i) && S6(i.sort)) {
                     const {
-                        field: a,
-                        timeUnit: s
-                    } = i, o = i.sort, l = o.map((u, c) => `${Gj({field:a,timeUnit:s,equal:u})} ? ${c} : `).join("") + o.length;
-                    t = new bc(t, {
+                        field: s,
+                        timeUnit: a
+                    } = i, o = i.sort, l = o.map((u, c) => `${i6({field:s,timeUnit:a,equal:u})} ? ${c} : `).join("") + o.length;
+                    t = new lc(t, {
                         calculate: l,
-                        as: xc(i, r, {
+                        as: uc(i, r, {
                             forAs: !0
                         })
                     })
                 }
             }), t
         }
         producedFields() {
@@ -44956,575 +45278,595 @@
             return {
                 type: "formula",
                 expr: this.transform.calculate,
                 as: this.transform.as
             }
         }
         hash() {
-            return `Calculate ${Ie(this.transform)}`
+            return `Calculate ${Ne(this.transform)}`
         }
     }
 
-    function xc(e, t, n) {
-        return ne(e, Object.assign({
+    function uc(e, t, n) {
+        return ie(e, {
             prefix: t,
-            suffix: "sort_index"
-        }, n ?? {}))
+            suffix: "sort_index",
+            ...n ?? {}
+        })
     }
 
-    function hy(e, t) {
-        return Pe(["top", "bottom"], t) ? "column" : Pe(["left", "right"], t) || e === "row" ? "row" : "column"
+    function X1(e, t) {
+        return Fe(["top", "bottom"], t) ? "column" : Fe(["left", "right"], t) || e === "row" ? "row" : "column"
     }
 
-    function _c(e, t, n, i) {
+    function cc(e, t, n, i) {
         const r = i === "row" ? n.headerRow : i === "column" ? n.headerColumn : n.headerFacet;
-        return Tt((t || {})[e], r[e], n.header[e])
+        return Ct((t || {})[e], r[e], n.header[e])
     }
 
-    function dy(e, t, n, i) {
+    function V1(e, t, n, i) {
         const r = {};
-        for (const a of e) {
-            const s = _c(a, t || {}, n, i);
-            s !== void 0 && (r[a] = s)
+        for (const s of e) {
+            const a = cc(s, t || {}, n, i);
+            a !== void 0 && (r[s] = a)
         }
         return r
     }
-    const aC = ["row", "column"],
-        sC = ["header", "footer"];
+    const EC = ["row", "column"],
+        CC = ["header", "footer"];
 
-    function I0e(e, t) {
+    function Ipe(e, t) {
         const n = e.component.layoutHeaders[t].title,
             i = e.config ? e.config : void 0,
             r = e.component.layoutHeaders[t].facetFieldDef ? e.component.layoutHeaders[t].facetFieldDef : void 0,
             {
-                titleAnchor: a,
-                titleAngle: s,
+                titleAnchor: s,
+                titleAngle: a,
                 titleOrient: o
-            } = dy(["titleAnchor", "titleAngle", "titleOrient"], r.header, i, t),
-            l = hy(t, o),
-            u = Jh(s);
+            } = V1(["titleAnchor", "titleAngle", "titleOrient"], r.header, i, t),
+            l = X1(t, o),
+            u = zh(a);
         return {
             name: `${t}-title`,
             type: "group",
             role: `${l}-title`,
-            title: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({
-                text: n
-            }, t === "row" ? {
-                orient: "left"
-            } : {}), {
-                style: "guide-title"
-            }), Mz(u, l)), $z(l, u, a)), Fz(i, r, t, Cge, N6))
+            title: {
+                text: n,
+                ...t === "row" ? {
+                    orient: "left"
+                } : {},
+                style: "guide-title",
+                ...Hz(u, l),
+                ...qz(l, u, s),
+                ...Yz(i, r, t, Mde, J6)
+            }
         }
     }
 
-    function $z(e, t, n = "middle") {
+    function qz(e, t, n = "middle") {
         switch (n) {
             case "start":
                 return {
                     align: "left"
                 };
             case "end":
                 return {
                     align: "right"
                 }
         }
-        const i = Az(t, e === "row" ? "left" : "top", e === "row" ? "y" : "x");
+        const i = Gz(t, e === "row" ? "left" : "top", e === "row" ? "y" : "x");
         return i ? {
             align: i
         } : {}
     }
 
-    function Mz(e, t) {
-        const n = kz(e, t === "row" ? "left" : "top", t === "row" ? "y" : "x", !0);
+    function Hz(e, t) {
+        const n = Uz(e, t === "row" ? "left" : "top", t === "row" ? "y" : "x", !0);
         return n ? {
             baseline: n
         } : {}
     }
 
-    function j0e(e, t) {
+    function zpe(e, t) {
         const n = e.component.layoutHeaders[t],
             i = [];
-        for (const r of sC)
+        for (const r of CC)
             if (n[r])
-                for (const a of n[r]) {
-                    const s = B0e(e, t, r, n, a);
-                    s != null && i.push(s)
+                for (const s of n[r]) {
+                    const a = jpe(e, t, r, n, s);
+                    a != null && i.push(a)
                 }
         return i
     }
 
-    function z0e(e, t) {
-        var n;
+    function Bpe(e, t) {
         const {
-            sort: i
+            sort: n
         } = e;
-        return Yr(i) ? {
-            field: ne(i, {
+        return Br(n) ? {
+            field: ie(n, {
                 expr: "datum"
             }),
-            order: (n = i.order) !== null && n !== void 0 ? n : "ascending"
-        } : q(i) ? {
-            field: xc(e, t, {
+            order: n.order ?? "ascending"
+        } : W(n) ? {
+            field: uc(e, t, {
                 expr: "datum"
             }),
             order: "ascending"
         } : {
-            field: ne(e, {
+            field: ie(e, {
                 expr: "datum"
             }),
-            order: i ?? "ascending"
+            order: n ?? "ascending"
         }
     }
 
-    function Ix(e, t, n) {
+    function ox(e, t, n) {
         const {
             format: i,
             formatType: r,
-            labelAngle: a,
-            labelAnchor: s,
+            labelAngle: s,
+            labelAnchor: a,
             labelOrient: o,
             labelExpr: l
-        } = dy(["format", "formatType", "labelAngle", "labelAnchor", "labelOrient", "labelExpr"], e.header, n, t), u = RO({
+        } = V1(["format", "formatType", "labelAngle", "labelAnchor", "labelOrient", "labelExpr"], e.header, n, t), u = ZE({
             fieldOrDatumDef: e,
             format: i,
             formatType: r,
             expr: "parent",
             config: n
-        }).signal, c = hy(t, o);
-        return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({
+        }).signal, c = X1(t, o);
+        return {
             text: {
-                signal: l ? xl(xl(l, "datum.label", u), "datum.value", ne(e, {
+                signal: l ? ll(ll(l, "datum.label", u), "datum.value", ie(e, {
                     expr: "parent"
                 })) : u
-            }
-        }, t === "row" ? {
-            orient: "left"
-        } : {}), {
+            },
+            ...t === "row" ? {
+                orient: "left"
+            } : {},
             style: "guide-label",
-            frame: "group"
-        }), Mz(a, c)), $z(c, a, s)), Fz(n, e, t, kge, L6))
+            frame: "group",
+            ...Hz(s, c),
+            ...qz(c, s, a),
+            ...Yz(n, e, t, Ode, Q6)
+        }
     }
 
-    function B0e(e, t, n, i, r) {
+    function jpe(e, t, n, i, r) {
         if (r) {
-            let a = null;
+            let s = null;
             const {
-                facetFieldDef: s
+                facetFieldDef: a
             } = i, o = e.config ? e.config : void 0;
-            if (s && r.labels) {
+            if (a && r.labels) {
                 const {
                     labelOrient: f
-                } = dy(["labelOrient"], s.header, o, t);
-                (t === "row" && !Pe(["top", "bottom"], f) || t === "column" && !Pe(["left", "right"], f)) && (a = Ix(s, t, o))
+                } = V1(["labelOrient"], a.header, o, t);
+                (t === "row" && !Fe(["top", "bottom"], f) || t === "column" && !Fe(["left", "right"], f)) && (s = ox(a, t, o))
             }
-            const l = mr(e) && !Xd(e.facet),
+            const l = lr(e) && !Rd(e.facet),
                 u = r.axes,
                 c = (u == null ? void 0 : u.length) > 0;
-            if (a || c) {
+            if (s || c) {
                 const f = t === "row" ? "height" : "width";
-                return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({
+                return {
                     name: e.getName(`${t}_${n}`),
                     type: "group",
-                    role: `${t}-${n}`
-                }, i.facetFieldDef ? {
-                    from: {
-                        data: e.getName(`${t}_domain`)
-                    },
-                    sort: z0e(s, t)
-                } : {}), c && l ? {
-                    from: {
-                        data: e.getName(`facet_domain_${t}`)
-                    }
-                } : {}), a ? {
-                    title: a
-                } : {}), r.sizeSignal ? {
-                    encode: {
-                        update: {
-                            [f]: r.sizeSignal
+                    role: `${t}-${n}`,
+                    ...i.facetFieldDef ? {
+                        from: {
+                            data: e.getName(`${t}_domain`)
+                        },
+                        sort: Bpe(a, t)
+                    } : {},
+                    ...c && l ? {
+                        from: {
+                            data: e.getName(`facet_domain_${t}`)
                         }
-                    }
-                } : {}), c ? {
-                    axes: u
-                } : {})
+                    } : {},
+                    ...s ? {
+                        title: s
+                    } : {},
+                    ...r.sizeSignal ? {
+                        encode: {
+                            update: {
+                                [f]: r.sizeSignal
+                            }
+                        }
+                    } : {},
+                    ...c ? {
+                        axes: u
+                    } : {}
+                }
             }
         }
         return null
     }
-    const G0e = {
+    const Upe = {
         column: {
             start: 0,
             end: 1
         },
         row: {
             start: 1,
             end: 0
         }
     };
 
-    function U0e(e, t) {
-        return G0e[t][e]
+    function Gpe(e, t) {
+        return Upe[t][e]
     }
 
-    function q0e(e, t) {
+    function Wpe(e, t) {
         const n = {};
-        for (const i of Ri) {
+        for (const i of Ti) {
             const r = e[i];
             if (r != null && r.facetFieldDef) {
                 const {
-                    titleAnchor: a,
-                    titleOrient: s
-                } = dy(["titleAnchor", "titleOrient"], r.facetFieldDef.header, t, i), o = hy(i, s), l = U0e(a, o);
+                    titleAnchor: s,
+                    titleOrient: a
+                } = V1(["titleAnchor", "titleOrient"], r.facetFieldDef.header, t, i), o = X1(i, a), l = Gpe(s, o);
                 l !== void 0 && (n[o] = l)
             }
         }
         return et(n) ? void 0 : n
     }
 
-    function Fz(e, t, n, i, r) {
-        const a = {};
-        for (const s of i) {
-            if (!r[s]) continue;
-            const o = _c(s, t == null ? void 0 : t.header, e, n);
-            o !== void 0 && (a[r[s]] = o)
+    function Yz(e, t, n, i, r) {
+        const s = {};
+        for (const a of i) {
+            if (!r[a]) continue;
+            const o = cc(a, t == null ? void 0 : t.header, e, n);
+            o !== void 0 && (s[r[a]] = o)
         }
-        return a
+        return s
     }
 
-    function oC(e) {
-        return [...Hg(e, "width"), ...Hg(e, "height"), ...Hg(e, "childWidth"), ...Hg(e, "childHeight")]
+    function kC(e) {
+        return [...Mg(e, "width"), ...Mg(e, "height"), ...Mg(e, "childWidth"), ...Mg(e, "childHeight")]
     }
 
-    function Hg(e, t) {
+    function Mg(e, t) {
         const n = t === "width" ? "x" : "y",
             i = e.component.layoutSize.get(t);
         if (!i || i === "merged") return [];
         const r = e.getSizeSignalRef(t).signal;
         if (i === "step") {
-            const a = e.getScaleComponent(n);
-            if (a) {
-                const s = a.get("type"),
-                    o = a.get("range");
-                if (Vt(s) && _o(o)) {
+            const s = e.getScaleComponent(n);
+            if (s) {
+                const a = s.get("type"),
+                    o = s.get("range");
+                if (qt(a) && lo(o)) {
                     const l = e.scaleName(n);
-                    return mr(e.parent) && e.parent.component.resolve.scale[n] === "independent" ? [J$(l, o)] : [J$(l, o), {
+                    return lr(e.parent) && e.parent.component.resolve.scale[n] === "independent" ? [f3(l, o)] : [f3(l, o), {
                         name: r,
-                        update: Dz(l, a, `domain('${l}').length`)
+                        update: Xz(l, s, `domain('${l}').length`)
                     }]
                 }
             }
             throw new Error("layout size is step although width/height is not step.")
         } else if (i == "container") {
-            const a = r.endsWith("width"),
-                s = a ? "containerSize()[0]" : "containerSize()[1]",
-                o = Ax(e.config.view, a ? "width" : "height"),
-                l = `isFinite(${s}) ? ${s} : ${o}`;
+            const s = r.endsWith("width"),
+                a = s ? "containerSize()[0]" : "containerSize()[1]",
+                o = Z2(e.config.view, s ? "width" : "height"),
+                l = `isFinite(${a}) ? ${a} : ${o}`;
             return [{
                 name: r,
                 init: l,
                 on: [{
                     update: l,
                     events: "window:resize"
                 }]
             }]
         } else return [{
             name: r,
             value: i
         }]
     }
 
-    function J$(e, t) {
+    function f3(e, t) {
         const n = `${e}_step`;
-        return fe(t.step) ? {
+        return he(t.step) ? {
             name: n,
             update: t.step.signal
         } : {
             name: n,
             value: t.step
         }
     }
 
-    function Dz(e, t, n) {
+    function Xz(e, t, n) {
         const i = t.get("type"),
             r = t.get("padding"),
-            a = Tt(t.get("paddingOuter"), r);
-        let s = t.get("paddingInner");
-        return s = i === "band" ? s !== void 0 ? s : r : 1, `bandspace(${n}, ${qa(s)}, ${qa(a)}) * ${e}_step`
+            s = Ct(t.get("paddingOuter"), r);
+        let a = t.get("paddingInner");
+        return a = i === "band" ? a !== void 0 ? a : r : 1, `bandspace(${n}, ${Ds(a)}, ${Ds(s)}) * ${e}_step`
     }
 
-    function Rz(e) {
+    function Vz(e) {
         return e === "childWidth" ? "width" : e === "childHeight" ? "height" : e
     }
 
-    function Pz(e, t) {
-        return Y(e).reduce((n, i) => {
+    function Kz(e, t) {
+        return H(e).reduce((n, i) => {
             const r = e[i];
-            return Object.assign(Object.assign({}, n), Wc(t, r, i, a => ct(a.value)))
+            return {
+                ...n,
+                ...Dc(t, r, i, s => ut(s.value))
+            }
         }, {})
     }
 
-    function Nz(e, t) {
-        if (mr(t)) return e === "theta" ? "independent" : "shared";
-        if (Vc(t)) return "shared";
-        if (gC(t)) return Xt(e) || e === "theta" || e === "radius" ? "independent" : "shared";
+    function Jz(e, t) {
+        if (lr(t)) return e === "theta" ? "independent" : "shared";
+        if (Ic(t)) return "shared";
+        if (RC(t)) return Wt(e) || e === "theta" || e === "radius" ? "independent" : "shared";
         throw new Error("invalid model type for resolve")
     }
 
-    function lC(e, t) {
+    function AC(e, t) {
         const n = e.scale[t],
-            i = Xt(t) ? "axis" : "legend";
-        return n === "independent" ? (e[i][t] === "shared" && X(She(t)), "independent") : e[i][t] || "shared"
+            i = Wt(t) ? "axis" : "legend";
+        return n === "independent" ? (e[i][t] === "shared" && X(Tfe(t)), "independent") : e[i][t] || "shared"
     }
-    const W0e = Object.assign(Object.assign({}, $ge), {
+    const qpe = {
+            ...Dde,
             disable: 1,
             labelExpr: 1,
             selections: 1,
             opacity: 1,
             shape: 1,
             stroke: 1,
             fill: 1,
             size: 1,
             strokeWidth: 1,
             strokeDash: 1,
             encode: 1
-        }),
-        Lz = Y(W0e);
-    class H0e extends ls {}
-    const Q$ = {
-        symbols: Y0e,
-        gradient: X0e,
-        labels: V0e,
-        entries: K0e
+        },
+        Qz = H(qpe);
+    class Hpe extends ea {}
+    const h3 = {
+        symbols: Ype,
+        gradient: Xpe,
+        labels: Vpe,
+        entries: Kpe
     };
 
-    function Y0e(e, {
+    function Ype(e, {
         fieldOrDatumDef: t,
         model: n,
         channel: i,
         legendCmpt: r,
-        legendType: a
+        legendType: s
     }) {
-        var s, o, l, u, c, f, h, d;
-        if (a !== "symbol") return;
+        if (s !== "symbol") return;
         const {
-            markDef: g,
-            encoding: p,
-            config: m,
-            mark: y
-        } = n, v = g.filled && y !== "trail";
-        let b = Object.assign(Object.assign({}, Dfe({}, n, Cde)), uz(n, {
-            filled: v
-        }));
-        const x = (s = r.get("symbolOpacity")) !== null && s !== void 0 ? s : m.legend.symbolOpacity,
-            _ = (o = r.get("symbolFillColor")) !== null && o !== void 0 ? o : m.legend.symbolFillColor,
-            S = (l = r.get("symbolStrokeColor")) !== null && l !== void 0 ? l : m.legend.symbolStrokeColor,
-            w = x === void 0 ? (u = Iz(p.opacity)) !== null && u !== void 0 ? u : g.opacity : void 0;
-        if (b.fill) {
-            if (i === "fill" || v && i === oi) delete b.fill;
-            else if (b.fill.field) _ ? delete b.fill : (b.fill = ct((c = m.legend.symbolBaseFillColor) !== null && c !== void 0 ? c : "black"), b.fillOpacity = ct(w ?? 1));
-            else if (q(b.fill)) {
-                const O = (d = (h = jx((f = p.fill) !== null && f !== void 0 ? f : p.color)) !== null && h !== void 0 ? h : g.fill) !== null && d !== void 0 ? d : v && g.color;
-                O && (b.fill = ct(O))
-            }
-        }
-        if (b.stroke) {
-            if (i === "stroke" || !v && i === oi) delete b.stroke;
-            else if (b.stroke.field || S) delete b.stroke;
-            else if (q(b.stroke)) {
-                const O = Tt(jx(p.stroke || p.color), g.stroke, v ? g.color : void 0);
-                O && (b.stroke = {
-                    value: O
+            markDef: a,
+            encoding: o,
+            config: l,
+            mark: u
+        } = n, c = a.filled && u !== "trail";
+        let f = {
+            ...zce({}, n, Ohe),
+            ...Ez(n, {
+                filled: c
+            })
+        };
+        const h = r.get("symbolOpacity") ?? l.legend.symbolOpacity,
+            d = r.get("symbolFillColor") ?? l.legend.symbolFillColor,
+            g = r.get("symbolStrokeColor") ?? l.legend.symbolStrokeColor,
+            p = h === void 0 ? Zz(o.opacity) ?? a.opacity : void 0;
+        if (f.fill) {
+            if (i === "fill" || c && i === si) delete f.fill;
+            else if (f.fill.field) d ? delete f.fill : (f.fill = ut(l.legend.symbolBaseFillColor ?? "black"), f.fillOpacity = ut(p ?? 1));
+            else if (W(f.fill)) {
+                const m = lx(o.fill ?? o.color) ?? a.fill ?? (c && a.color);
+                m && (f.fill = ut(m))
+            }
+        }
+        if (f.stroke) {
+            if (i === "stroke" || !c && i === si) delete f.stroke;
+            else if (f.stroke.field || g) delete f.stroke;
+            else if (W(f.stroke)) {
+                const m = Ct(lx(o.stroke || o.color), a.stroke, c ? a.color : void 0);
+                m && (f.stroke = {
+                    value: m
                 })
             }
         }
-        if (i !== ss) {
-            const O = J(t) && zz(n, r, t);
-            O ? b.opacity = [Object.assign({
-                test: O
-            }, ct(w ?? 1)), ct(m.legend.unselectedOpacity)] : w && (b.opacity = ct(w))
-        }
-        return b = Object.assign(Object.assign({}, b), e), et(b) ? void 0 : b
+        if (i !== Js) {
+            const m = K(t) && t8(n, r, t);
+            m ? f.opacity = [{
+                test: m,
+                ...ut(p ?? 1)
+            }, ut(l.legend.unselectedOpacity)] : p && (f.opacity = ut(p))
+        }
+        return f = {
+            ...f,
+            ...e
+        }, et(f) ? void 0 : f
     }
 
-    function X0e(e, {
+    function Xpe(e, {
         model: t,
         legendType: n,
         legendCmpt: i
     }) {
-        var r;
         if (n !== "gradient") return;
         const {
-            config: a,
+            config: r,
             markDef: s,
-            encoding: o
+            encoding: a
         } = t;
-        let l = {};
-        const c = ((r = i.get("gradientOpacity")) !== null && r !== void 0 ? r : a.legend.gradientOpacity) === void 0 ? Iz(o.opacity) || s.opacity : void 0;
-        return c && (l.opacity = ct(c)), l = Object.assign(Object.assign({}, l), e), et(l) ? void 0 : l
+        let o = {};
+        const u = (i.get("gradientOpacity") ?? r.legend.gradientOpacity) === void 0 ? Zz(a.opacity) || s.opacity : void 0;
+        return u && (o.opacity = ut(u)), o = {
+            ...o,
+            ...e
+        }, et(o) ? void 0 : o
     }
 
-    function V0e(e, {
+    function Vpe(e, {
         fieldOrDatumDef: t,
         model: n,
         channel: i,
         legendCmpt: r
     }) {
-        const a = n.legend(i) || {},
-            s = n.config,
-            o = J(t) ? zz(n, r, t) : void 0,
+        const s = n.legend(i) || {},
+            a = n.config,
+            o = K(t) ? t8(n, r, t) : void 0,
             l = o ? [{
                 test: o,
                 value: 1
             }, {
-                value: s.legend.unselectedOpacity
+                value: a.legend.unselectedOpacity
             }] : void 0,
             {
                 format: u,
                 formatType: c
-            } = a;
+            } = s;
         let f;
-        Ol(c) ? f = hr({
+        gl(c) ? f = rr({
             fieldOrDatumDef: t,
             field: "datum.value",
             format: u,
             formatType: c,
-            config: s
-        }) : u === void 0 && c === void 0 && s.customFormatTypes && (t.type === "quantitative" && s.numberFormatType ? f = hr({
+            config: a
+        }) : u === void 0 && c === void 0 && a.customFormatTypes && (t.type === "quantitative" && a.numberFormatType ? f = rr({
             fieldOrDatumDef: t,
             field: "datum.value",
-            format: s.numberFormat,
-            formatType: s.numberFormatType,
-            config: s
-        }) : t.type === "temporal" && s.timeFormatType && J(t) && t.timeUnit === void 0 && (f = hr({
+            format: a.numberFormat,
+            formatType: a.numberFormatType,
+            config: a
+        }) : t.type === "temporal" && a.timeFormatType && K(t) && t.timeUnit === void 0 && (f = rr({
             fieldOrDatumDef: t,
             field: "datum.value",
-            format: s.timeFormat,
-            formatType: s.timeFormatType,
-            config: s
+            format: a.timeFormat,
+            formatType: a.timeFormatType,
+            config: a
         })));
-        const h = Object.assign(Object.assign(Object.assign({}, l ? {
-            opacity: l
-        } : {}), f ? {
-            text: f
-        } : {}), e);
+        const h = {
+            ...l ? {
+                opacity: l
+            } : {},
+            ...f ? {
+                text: f
+            } : {},
+            ...e
+        };
         return et(h) ? void 0 : h
     }
 
-    function K0e(e, {
+    function Kpe(e, {
         legendCmpt: t
     }) {
         const n = t.get("selections");
-        return n != null && n.length ? Object.assign(Object.assign({}, e), {
+        return n != null && n.length ? {
+            ...e,
             fill: {
                 value: "transparent"
             }
-        }) : e
+        } : e
     }
 
-    function Iz(e) {
-        return jz(e, (t, n) => Math.max(t, n.value))
+    function Zz(e) {
+        return e8(e, (t, n) => Math.max(t, n.value))
     }
 
-    function jx(e) {
-        return jz(e, (t, n) => Tt(t, n.value))
+    function lx(e) {
+        return e8(e, (t, n) => Ct(t, n.value))
     }
 
-    function jz(e, t) {
-        if (Wde(e)) return ie(e.condition).reduce(t, e.value);
-        if (wr(e)) return e.value
+    function e8(e, t) {
+        if (Khe(e)) return se(e.condition).reduce(t, e.value);
+        if (gr(e)) return e.value
     }
 
-    function zz(e, t, n) {
+    function t8(e, t, n) {
         const i = t.get("selections");
         if (!(i != null && i.length)) return;
         const r = Z(n.field);
-        return i.map(a => `(!length(data(${Z(ht(a)+kl)})) || (${a}[${r}] && indexof(${a}[${r}], datum.value) >= 0))`).join(" || ")
+        return i.map(s => `(!length(data(${Z(ft(s)+ml)})) || (${s}[${r}] && indexof(${s}[${r}], datum.value) >= 0))`).join(" || ")
     }
-    const Z$ = {
+    const d3 = {
         direction: ({
             direction: e
         }) => e,
         format: ({
             fieldOrDatumDef: e,
             legend: t,
             config: n
         }) => {
             const {
                 format: i,
                 formatType: r
             } = t;
-            return r6(e, e.type, i, r, n, !1)
+            return b6(e, e.type, i, r, n, !1)
         },
         formatType: ({
             legend: e,
             fieldOrDatumDef: t,
             scaleType: n
         }) => {
             const {
                 formatType: i
             } = e;
-            return a6(i, t, n)
+            return x6(i, t, n)
         },
         gradientLength: e => {
-            var t, n;
             const {
-                legend: i,
-                legendConfig: r
+                legend: t,
+                legendConfig: n
             } = e;
-            return (n = (t = i.gradientLength) !== null && t !== void 0 ? t : r.gradientLength) !== null && n !== void 0 ? n : ime(e)
+            return t.gradientLength ?? n.gradientLength ?? i0e(e)
         },
         labelOverlap: ({
             legend: e,
             legendConfig: t,
             scaleType: n
-        }) => {
-            var i, r;
-            return (r = (i = e.labelOverlap) !== null && i !== void 0 ? i : t.labelOverlap) !== null && r !== void 0 ? r : rme(n)
-        },
+        }) => e.labelOverlap ?? t.labelOverlap ?? r0e(n),
         symbolType: ({
             legend: e,
             markDef: t,
             channel: n,
             encoding: i
-        }) => {
-            var r;
-            return (r = e.symbolType) !== null && r !== void 0 ? r : Q0e(t.type, n, i.shape, t.shape)
-        },
+        }) => e.symbolType ?? Qpe(t.type, n, i.shape, t.shape),
         title: ({
             fieldOrDatumDef: e,
             config: t
-        }) => Lu(e, t, {
+        }) => ku(e, t, {
             allowDisabling: !0
         }),
         type: ({
             legendType: e,
             scaleType: t,
             channel: n
         }) => {
-            if (Nu(n) && fr(t)) {
+            if (Cu(n) && ir(t)) {
                 if (e === "gradient") return
             } else if (e === "symbol") return;
             return e
         },
         values: ({
             fieldOrDatumDef: e,
             legend: t
-        }) => J0e(t, e)
+        }) => Jpe(t, e)
     };
 
-    function J0e(e, t) {
+    function Jpe(e, t) {
         const n = e.values;
-        if (q(n)) return v6(t, n);
-        if (fe(n)) return n
+        if (W(n)) return D6(t, n);
+        if (he(n)) return n
     }
 
-    function Q0e(e, t, n, i) {
-        var r;
+    function Qpe(e, t, n, i) {
         if (t !== "shape") {
-            const a = (r = jx(n)) !== null && r !== void 0 ? r : i;
-            if (a) return a
+            const r = lx(n) ?? i;
+            if (r) return r
         }
         switch (e) {
             case "bar":
             case "rect":
             case "image":
             case "square":
                 return "square";
@@ -45539,101 +45881,100 @@
             case "geoshape":
             case "area":
             case "text":
                 return "circle"
         }
     }
 
-    function Z0e(e) {
+    function Zpe(e) {
         const {
             legend: t
         } = e;
-        return Tt(t.type, eme(e))
+        return Ct(t.type, e0e(e))
     }
 
-    function eme({
+    function e0e({
         channel: e,
         timeUnit: t,
         scaleType: n
     }) {
-        if (Nu(e)) {
-            if (Pe(["quarter", "month", "day"], t)) return "symbol";
-            if (fr(n)) return "gradient"
+        if (Cu(e)) {
+            if (Fe(["quarter", "month", "day"], t)) return "symbol";
+            if (ir(n)) return "gradient"
         }
         return "symbol"
     }
 
-    function tme({
+    function t0e({
         legendConfig: e,
         legendType: t,
         orient: n,
         legend: i
     }) {
-        var r, a;
-        return (a = (r = i.direction) !== null && r !== void 0 ? r : e[t ? "gradientDirection" : "symbolDirection"]) !== null && a !== void 0 ? a : nme(n, t)
+        return i.direction ?? e[t ? "gradientDirection" : "symbolDirection"] ?? n0e(n, t)
     }
 
-    function nme(e, t) {
+    function n0e(e, t) {
         switch (e) {
             case "top":
             case "bottom":
                 return "horizontal";
             case "left":
             case "right":
             case "none":
             case void 0:
                 return;
             default:
                 return t === "gradient" ? "horizontal" : void 0
         }
     }
 
-    function ime({
+    function i0e({
         legendConfig: e,
         model: t,
         direction: n,
         orient: i,
         scaleType: r
     }) {
         const {
-            gradientHorizontalMaxLength: a,
-            gradientHorizontalMinLength: s,
+            gradientHorizontalMaxLength: s,
+            gradientHorizontalMinLength: a,
             gradientVerticalMaxLength: o,
             gradientVerticalMinLength: l
         } = e;
-        if (fr(r)) return n === "horizontal" ? i === "top" || i === "bottom" ? e5(t, "width", s, a) : s : e5(t, "height", l, o)
+        if (ir(r)) return n === "horizontal" ? i === "top" || i === "bottom" ? g3(t, "width", a, s) : a : g3(t, "height", l, o)
     }
 
-    function e5(e, t, n, i) {
+    function g3(e, t, n, i) {
         return {
             signal: `clamp(${e.getSizeSignalRef(t).signal}, ${n}, ${i})`
         }
     }
 
-    function rme(e) {
-        if (Pe(["quantile", "threshold", "log", "symlog"], e)) return "greedy"
+    function r0e(e) {
+        if (Fe(["quantile", "threshold", "log", "symlog"], e)) return "greedy"
     }
 
-    function Bz(e) {
-        const t = kt(e) ? ame(e) : ume(e);
+    function n8(e) {
+        const t = Et(e) ? s0e(e) : u0e(e);
         return e.component.legends = t, t
     }
 
-    function ame(e) {
+    function s0e(e) {
         const {
             encoding: t
         } = e, n = {};
-        for (const i of [oi, ...j6]) {
-            const r = Rt(t[i]);
-            !r || !e.getScaleComponent(i) || i === li && J(r) && r.type === qc || (n[i] = lme(e, i))
+        for (const i of [si, ...ez]) {
+            const r = Mt(t[i]);
+            !r || !e.getScaleComponent(i) || i === ai && K(r) && r.type === Rc || (n[i] = l0e(e, i))
         }
         return n
     }
 
-    function sme(e, t) {
+    function a0e(e, t) {
         const n = e.scaleName(t);
         if (e.mark === "trail") {
             if (t === "color") return {
                 stroke: n
             };
             if (t === "size") return {
                 strokeWidth: n
@@ -45644,1019 +45985,1024 @@
         } : {
             stroke: n
         } : {
             [t]: n
         }
     }
 
-    function ome(e, t, n, i) {
+    function o0e(e, t, n, i) {
         switch (t) {
             case "disable":
                 return n !== void 0;
             case "values":
                 return !!(n != null && n.values);
             case "title":
                 if (t === "title" && e === (i == null ? void 0 : i.title)) return !0
         }
         return e === (n || {})[t]
     }
 
-    function lme(e, t) {
-        var n, i, r;
-        let a = e.legend(t);
+    function l0e(e, t) {
+        var x;
+        let n = e.legend(t);
         const {
-            markDef: s,
-            encoding: o,
-            config: l
-        } = e, u = l.legend, c = new H0e({}, sme(e, t));
-        v0e(e, t, c);
-        const f = a !== void 0 ? !a : u.disable;
-        if (c.set("disable", f, a !== void 0), f) return c;
-        a = a || {};
-        const h = e.getScaleComponent(t).get("type"),
-            d = Rt(o[t]),
-            g = J(d) ? (n = En(d.timeUnit)) === null || n === void 0 ? void 0 : n.unit : void 0,
-            p = a.orient || l.legend.orient || "right",
-            m = Z0e({
-                legend: a,
+            markDef: i,
+            encoding: r,
+            config: s
+        } = e, a = s.legend, o = new Hpe({}, a0e(e, t));
+        ype(e, t, o);
+        const l = n !== void 0 ? !n : a.disable;
+        if (o.set("disable", l, n !== void 0), l) return o;
+        n = n || {};
+        const u = e.getScaleComponent(t).get("type"),
+            c = Mt(r[t]),
+            f = K(c) ? (x = en(c.timeUnit)) == null ? void 0 : x.unit : void 0,
+            h = n.orient || s.legend.orient || "right",
+            d = Zpe({
+                legend: n,
                 channel: t,
-                timeUnit: g,
-                scaleType: h
+                timeUnit: f,
+                scaleType: u
             }),
-            y = tme({
-                legend: a,
-                legendType: m,
-                orient: p,
-                legendConfig: u
+            g = t0e({
+                legend: n,
+                legendType: d,
+                orient: h,
+                legendConfig: a
             }),
-            v = {
-                legend: a,
+            p = {
+                legend: n,
                 channel: t,
                 model: e,
-                markDef: s,
-                encoding: o,
-                fieldOrDatumDef: d,
-                legendConfig: u,
-                config: l,
-                scaleType: h,
-                orient: p,
-                legendType: m,
-                direction: y
+                markDef: i,
+                encoding: r,
+                fieldOrDatumDef: c,
+                legendConfig: a,
+                config: s,
+                scaleType: u,
+                orient: h,
+                legendType: d,
+                direction: g
             };
-        for (const w of Lz) {
-            if (m === "gradient" && w.startsWith("symbol") || m === "symbol" && w.startsWith("gradient")) continue;
-            const O = w in Z$ ? Z$[w](v) : a[w];
-            if (O !== void 0) {
-                const k = ome(O, w, a, e.fieldDef(t));
-                (k || l.legend[w] === void 0) && c.set(w, O, k)
+        for (const _ of Qz) {
+            if (d === "gradient" && _.startsWith("symbol") || d === "symbol" && _.startsWith("gradient")) continue;
+            const S = _ in d3 ? d3[_](p) : n[_];
+            if (S !== void 0) {
+                const w = o0e(S, _, n, e.fieldDef(t));
+                (w || s.legend[_] === void 0) && o.set(_, S, w)
             }
         }
-        const b = (i = a == null ? void 0 : a.encoding) !== null && i !== void 0 ? i : {},
-            x = c.get("selections"),
-            _ = {},
-            S = {
-                fieldOrDatumDef: d,
+        const m = (n == null ? void 0 : n.encoding) ?? {},
+            y = o.get("selections"),
+            v = {},
+            b = {
+                fieldOrDatumDef: c,
                 model: e,
                 channel: t,
-                legendCmpt: c,
-                legendType: m
+                legendCmpt: o,
+                legendType: d
             };
-        for (const w of ["labels", "legend", "title", "symbols", "gradient", "entries"]) {
-            const O = Pz((r = b[w]) !== null && r !== void 0 ? r : {}, e),
-                k = w in Q$ ? Q$[w](O, S) : O;
-            k !== void 0 && !et(k) && (_[w] = Object.assign(Object.assign(Object.assign({}, x != null && x.length && J(d) ? {
-                name: `${ht(d.field)}_legend_${w}`
-            } : {}), x != null && x.length ? {
-                interactive: !!x
-            } : {}), {
-                update: k
-            }))
+        for (const _ of ["labels", "legend", "title", "symbols", "gradient", "entries"]) {
+            const S = Kz(m[_] ?? {}, e),
+                w = _ in h3 ? h3[_](S, b) : S;
+            w !== void 0 && !et(w) && (v[_] = {
+                ...y != null && y.length && K(c) ? {
+                    name: `${ft(c.field)}_legend_${_}`
+                } : {},
+                ...y != null && y.length ? {
+                    interactive: !!y
+                } : {},
+                update: w
+            })
         }
-        return et(_) || c.set("encode", _, !!(a != null && a.encoding)), c
+        return et(v) || o.set("encode", v, !!(n != null && n.encoding)), o
     }
 
-    function ume(e) {
+    function u0e(e) {
         const {
             legends: t,
             resolve: n
         } = e.component;
         for (const i of e.children) {
-            Bz(i);
-            for (const r of Y(i.component.legends)) n.legend[r] = lC(e.component.resolve, r), n.legend[r] === "shared" && (t[r] = Gz(t[r], i.component.legends[r]), t[r] || (n.legend[r] = "independent", delete t[r]))
+            n8(i);
+            for (const r of H(i.component.legends)) n.legend[r] = AC(e.component.resolve, r), n.legend[r] === "shared" && (t[r] = i8(t[r], i.component.legends[r]), t[r] || (n.legend[r] = "independent", delete t[r]))
         }
-        for (const i of Y(t))
+        for (const i of H(t))
             for (const r of e.children) r.component.legends[i] && n.legend[i] === "shared" && delete r.component.legends[i];
         return t
     }
 
-    function Gz(e, t) {
-        var n, i, r, a;
+    function i8(e, t) {
+        var s, a, o, l;
         if (!e) return t.clone();
-        const s = e.getWithExplicit("orient"),
-            o = t.getWithExplicit("orient");
-        if (s.explicit && o.explicit && s.value !== o.value) return;
-        let l = !1;
-        for (const u of Lz) {
-            const c = Qs(e.getWithExplicit(u), t.getWithExplicit(u), u, "legend", (f, h) => {
+        const n = e.getWithExplicit("orient"),
+            i = t.getWithExplicit("orient");
+        if (n.explicit && i.explicit && n.value !== i.value) return;
+        let r = !1;
+        for (const u of Qz) {
+            const c = Ua(e.getWithExplicit(u), t.getWithExplicit(u), u, "legend", (f, h) => {
                 switch (u) {
                     case "symbolType":
-                        return cme(f, h);
+                        return c0e(f, h);
                     case "title":
-                        return Aj(f, h);
+                        return UI(f, h);
                     case "type":
-                        return l = !0, hi("symbol")
+                        return r = !0, ci("symbol")
                 }
-                return uy(f, h, u, "legend")
+                return q1(f, h, u, "legend")
             });
             e.setWithExplicit(u, c)
         }
-        return l && (!((i = (n = e.implicit) === null || n === void 0 ? void 0 : n.encode) === null || i === void 0) && i.gradient && em(e.implicit, ["encode", "gradient"]), !((a = (r = e.explicit) === null || r === void 0 ? void 0 : r.encode) === null || a === void 0) && a.gradient && em(e.explicit, ["encode", "gradient"])), e
+        return r && ((a = (s = e.implicit) == null ? void 0 : s.encode) != null && a.gradient && N0(e.implicit, ["encode", "gradient"]), (l = (o = e.explicit) == null ? void 0 : o.encode) != null && l.gradient && N0(e.explicit, ["encode", "gradient"])), e
     }
 
-    function cme(e, t) {
+    function c0e(e, t) {
         return t.value === "circle" ? t : e
     }
-    var fme = globalThis && globalThis.__rest || function(e, t) {
-        var n = {};
-        for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && t.indexOf(i) < 0 && (n[i] = e[i]);
-        if (e != null && typeof Object.getOwnPropertySymbols == "function")
-            for (var r = 0, i = Object.getOwnPropertySymbols(e); r < i.length; r++) t.indexOf(i[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, i[r]) && (n[i[r]] = e[i[r]]);
-        return n
-    };
 
-    function hme(e, t, n, i) {
-        var r, a, s, o, l;
-        (r = e.encode) !== null && r !== void 0 || (e.encode = {}), (a = (o = e.encode)[t]) !== null && a !== void 0 || (o[t] = {}), (s = (l = e.encode[t]).update) !== null && s !== void 0 || (l.update = {}), e.encode[t].update[n] = i
+    function f0e(e, t, n, i) {
+        var r, s;
+        e.encode ?? (e.encode = {}), (r = e.encode)[t] ?? (r[t] = {}), (s = e.encode[t]).update ?? (s.update = {}), e.encode[t].update[n] = i
     }
 
-    function Uz(e) {
+    function r8(e) {
         const t = e.component.legends,
             n = {};
-        for (const r of Y(t)) {
-            const a = e.getScaleComponent(r),
-                s = ot(a.get("domains"));
-            if (n[s])
-                for (const o of n[s]) Gz(o, t[r]) || n[s].push(t[r]);
-            else n[s] = [t[r].clone()]
-        }
-        return _n(n).flat().map(r => dme(r, e.config)).filter(r => r !== void 0)
-    }
-
-    function dme(e, t) {
-        var n, i, r;
-        const a = e.combine(),
-            {
-                disable: s,
-                labelExpr: o,
-                selections: l
-            } = a,
-            u = fme(a, ["disable", "labelExpr", "selections"]);
-        if (!s) {
-            if (t.aria === !1 && u.aria == null && (u.aria = !1), !((n = u.encode) === null || n === void 0) && n.symbols) {
-                const c = u.encode.symbols.update;
-                c.fill && c.fill.value !== "transparent" && !c.stroke && !u.stroke && (c.stroke = {
+        for (const r of H(t)) {
+            const s = e.getScaleComponent(r),
+                a = at(s.get("domains"));
+            if (n[a])
+                for (const o of n[a]) i8(o, t[r]) || n[a].push(t[r]);
+            else n[a] = [t[r].clone()]
+        }
+        return Qt(n).flat().map(r => h0e(r, e.config)).filter(r => r !== void 0)
+    }
+
+    function h0e(e, t) {
+        var a, o, l;
+        const {
+            disable: n,
+            labelExpr: i,
+            selections: r,
+            ...s
+        } = e.combine();
+        if (!n) {
+            if (t.aria === !1 && s.aria == null && (s.aria = !1), (a = s.encode) != null && a.symbols) {
+                const u = s.encode.symbols.update;
+                u.fill && u.fill.value !== "transparent" && !u.stroke && !s.stroke && (u.stroke = {
                     value: "transparent"
                 });
-                for (const f of j6) u[f] && delete c[f]
+                for (const c of ez) s[c] && delete u[c]
             }
-            if (u.title || delete u.title, o !== void 0) {
-                let c = o;
-                !((r = (i = u.encode) === null || i === void 0 ? void 0 : i.labels) === null || r === void 0) && r.update && fe(u.encode.labels.update.text) && (c = xl(o, "datum.label", u.encode.labels.update.text.signal)), hme(u, "labels", "text", {
-                    signal: c
+            if (s.title || delete s.title, i !== void 0) {
+                let u = i;
+                (l = (o = s.encode) == null ? void 0 : o.labels) != null && l.update && he(s.encode.labels.update.text) && (u = ll(i, "datum.label", s.encode.labels.update.text.signal)), f0e(s, "labels", "text", {
+                    signal: u
                 })
             }
-            return u
+            return s
         }
     }
 
-    function gme(e) {
-        return Vc(e) || gC(e) ? pme(e) : qz(e)
+    function d0e(e) {
+        return Ic(e) || RC(e) ? g0e(e) : s8(e)
     }
 
-    function pme(e) {
-        return e.children.reduce((t, n) => t.concat(n.assembleProjections()), qz(e))
+    function g0e(e) {
+        return e.children.reduce((t, n) => t.concat(n.assembleProjections()), s8(e))
     }
 
-    function qz(e) {
+    function s8(e) {
         const t = e.component.projection;
         if (!t || t.merged) return [];
         const n = t.combine(),
             {
                 name: i
             } = n;
         if (t.data) {
             const r = {
-                    signal: `[${t.size.map(s=>s.signal).join(", ")}]`
+                    signal: `[${t.size.map(a=>a.signal).join(", ")}]`
                 },
-                a = t.data.reduce((s, o) => {
-                    const l = fe(o) ? o.signal : `data('${e.lookupDataSource(o)}')`;
-                    return Pe(s, l) || s.push(l), s
+                s = t.data.reduce((a, o) => {
+                    const l = he(o) ? o.signal : `data('${e.lookupDataSource(o)}')`;
+                    return Fe(a, l) || a.push(l), a
                 }, []);
-            if (a.length <= 0) throw new Error("Projection's fit didn't find any data sources");
-            return [Object.assign({
+            if (s.length <= 0) throw new Error("Projection's fit didn't find any data sources");
+            return [{
                 name: i,
                 size: r,
                 fit: {
-                    signal: a.length > 1 ? `[${a.join(", ")}]` : a[0]
-                }
-            }, n)]
-        } else return [Object.assign(Object.assign({
-            name: i
-        }, {
+                    signal: s.length > 1 ? `[${s.join(", ")}]` : s[0]
+                },
+                ...n
+            }]
+        } else return [{
+            name: i,
             translate: {
                 signal: "[width / 2, height / 2]"
-            }
-        }), n)]
+            },
+            ...n
+        }]
     }
-    const mme = ["type", "clipAngle", "clipExtent", "center", "rotate", "precision", "reflectX", "reflectY", "coefficient", "distance", "fraction", "lobes", "parallel", "radius", "ratio", "spacing", "tilt"];
-    class Wz extends ls {
+    const p0e = ["type", "clipAngle", "clipExtent", "center", "rotate", "precision", "reflectX", "reflectY", "coefficient", "distance", "fraction", "lobes", "parallel", "radius", "ratio", "spacing", "tilt"];
+    class a8 extends ea {
         constructor(t, n, i, r) {
-            super(Object.assign({}, n), {
+            super({
+                ...n
+            }, {
                 name: t
             }), this.specifiedProjection = n, this.size = i, this.data = r, this.merged = !1
         }
         get isFit() {
             return !!this.data
         }
     }
 
-    function Hz(e) {
-        e.component.projection = kt(e) ? yme(e) : xme(e)
+    function o8(e) {
+        e.component.projection = Et(e) ? m0e(e) : b0e(e)
     }
 
-    function yme(e) {
-        var t;
+    function m0e(e) {
         if (e.hasProjection) {
-            const n = Xn(e.specifiedProjection),
-                i = !(n && (n.scale != null || n.translate != null)),
-                r = i ? [e.getSizeSignalRef("width"), e.getSizeSignalRef("height")] : void 0,
-                a = i ? vme(e) : void 0,
-                s = new Wz(e.projectionName(!0), Object.assign(Object.assign({}, (t = Xn(e.config.projection)) !== null && t !== void 0 ? t : {}), n ?? {}), r, a);
+            const t = Hn(e.specifiedProjection),
+                n = !(t && (t.scale != null || t.translate != null)),
+                i = n ? [e.getSizeSignalRef("width"), e.getSizeSignalRef("height")] : void 0,
+                r = n ? y0e(e) : void 0,
+                s = new a8(e.projectionName(!0), {
+                    ...Hn(e.config.projection) ?? {},
+                    ...t ?? {}
+                }, i, r);
             return s.get("type") || s.set("type", "equalEarth", !1), s
         }
     }
 
-    function vme(e) {
+    function y0e(e) {
         const t = [],
             {
                 encoding: n
             } = e;
         for (const i of [
-                [ma, pa],
-                [Gi, Tr]
-            ])(Rt(n[i[0]]) || Rt(n[i[1]])) && t.push({
+                [Sr, wr],
+                [Li, Er]
+            ])(Mt(n[i[0]]) || Mt(n[i[1]])) && t.push({
             signal: e.getName(`geojson_${t.length}`)
         });
-        return e.channelHasField(li) && e.typedFieldDef(li).type === qc && t.push({
+        return e.channelHasField(ai) && e.typedFieldDef(ai).type === Rc && t.push({
             signal: e.getName(`geojson_${t.length}`)
         }), t.length === 0 && t.push(e.requestDataName(st.Main)), t
     }
 
-    function bme(e, t) {
-        const n = ZE(mme, r => !!(!pe(e.explicit, r) && !pe(t.explicit, r) || pe(e.explicit, r) && pe(t.explicit, r) && Br(e.get(r), t.get(r))));
-        if (Br(e.size, t.size)) {
+    function v0e(e, t) {
+        const n = bE(p0e, r => !!(!me(e.explicit, r) && !me(t.explicit, r) || me(e.explicit, r) && me(t.explicit, r) && Nr(e.get(r), t.get(r))));
+        if (Nr(e.size, t.size)) {
             if (n) return e;
-            if (Br(e.explicit, {})) return t;
-            if (Br(t.explicit, {})) return e
+            if (Nr(e.explicit, {})) return t;
+            if (Nr(t.explicit, {})) return e
         }
         return null
     }
 
-    function xme(e) {
+    function b0e(e) {
         if (e.children.length === 0) return;
         let t;
-        for (const i of e.children) Hz(i);
-        const n = ZE(e.children, i => {
+        for (const i of e.children) o8(i);
+        const n = bE(e.children, i => {
             const r = i.component.projection;
             if (r)
                 if (t) {
-                    const a = bme(t, r);
-                    return a && (t = a), !!a
+                    const s = v0e(t, r);
+                    return s && (t = s), !!s
                 } else return t = r, !0;
             else return !0
         });
         if (t && n) {
             const i = e.projectionName(!0),
-                r = new Wz(i, t.specifiedProjection, t.size, Ce(t.data));
-            for (const a of e.children) {
-                const s = a.component.projection;
-                s && (s.isFit && r.data.push(...a.component.projection.data), a.renameProjection(s.get("name"), i), s.merged = !0)
+                r = new a8(i, t.specifiedProjection, t.size, ke(t.data));
+            for (const s of e.children) {
+                const a = s.component.projection;
+                a && (a.isFit && r.data.push(...s.component.projection.data), s.renameProjection(a.get("name"), i), a.merged = !0)
             }
             return r
         }
     }
-    var _me = globalThis && globalThis.__rest || function(e, t) {
-        var n = {};
-        for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && t.indexOf(i) < 0 && (n[i] = e[i]);
-        if (e != null && typeof Object.getOwnPropertySymbols == "function")
-            for (var r = 0, i = Object.getOwnPropertySymbols(e); r < i.length; r++) t.indexOf(i[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, i[r]) && (n[i[r]] = e[i[r]]);
-        return n
-    };
 
-    function wme(e, t, n, i) {
-        var r, a;
-        if (Kd(t, n)) {
-            const s = kt(e) ? (a = (r = e.axis(n)) !== null && r !== void 0 ? r : e.legend(n)) !== null && a !== void 0 ? a : {} : {},
-                o = ne(t, {
+    function x0e(e, t, n, i) {
+        if (Nd(t, n)) {
+            const r = Et(e) ? e.axis(n) ?? e.legend(n) ?? {} : {},
+                s = ie(t, {
                     expr: "datum"
                 }),
-                l = ne(t, {
+                a = ie(t, {
                     expr: "datum",
                     binSuffix: "end"
                 });
             return {
-                formulaAs: ne(t, {
+                formulaAs: ie(t, {
                     binSuffix: "range",
                     forAs: !0
                 }),
-                formula: Yd(o, l, s.format, s.formatType, i)
+                formula: Fd(s, a, r.format, r.formatType, i)
             }
         }
         return {}
     }
 
-    function Yz(e, t) {
-        return `${xj(e)}_${t}`
+    function l8(e, t) {
+        return `${DI(e)}_${t}`
     }
 
-    function Sme(e, t) {
+    function _0e(e, t) {
         return {
             signal: e.getName(`${t}_bins`),
             extentSignal: e.getName(`${t}_extent`)
         }
     }
 
-    function uC(e, t, n) {
-        var i;
-        const r = (i = iy(n, void 0)) !== null && i !== void 0 ? i : {},
-            a = Yz(r, t);
-        return e.getName(`${a}_bins`)
+    function $C(e, t, n) {
+        const i = z1(n, void 0) ?? {},
+            r = l8(i, t);
+        return e.getName(`${r}_bins`)
     }
 
-    function Eme(e) {
+    function w0e(e) {
         return "as" in e
     }
 
-    function t5(e, t, n) {
+    function p3(e, t, n) {
         let i, r;
-        Eme(e) ? i = re(e.as) ? [e.as, `${e.as}_end`] : [e.as[0], e.as[1]] : i = [ne(e, {
+        w0e(e) ? i = re(e.as) ? [e.as, `${e.as}_end`] : [e.as[0], e.as[1]] : i = [ie(e, {
             forAs: !0
-        }), ne(e, {
+        }), ie(e, {
             binSuffix: "end",
             forAs: !0
         })];
-        const a = Object.assign({}, iy(t, void 0)),
-            s = Yz(a, e.field),
+        const s = {
+                ...z1(t, void 0)
+            },
+            a = l8(s, e.field),
             {
                 signal: o,
                 extentSignal: l
-            } = Sme(n, s);
-        if (Y1(a.extent)) {
-            const c = a.extent;
-            r = Oz(n, c.param, c), delete a.extent
+            } = _0e(n, a);
+        if ($1(s.extent)) {
+            const c = s.extent;
+            r = Bz(n, c.param, c), delete s.extent
         }
-        const u = Object.assign(Object.assign(Object.assign({
-            bin: a,
+        const u = {
+            bin: s,
             field: e.field,
-            as: [i]
-        }, o ? {
-            signal: o
-        } : {}), l ? {
-            extentSignal: l
-        } : {}), r ? {
-            span: r
-        } : {});
+            as: [i],
+            ...o ? {
+                signal: o
+            } : {},
+            ...l ? {
+                extentSignal: l
+            } : {},
+            ...r ? {
+                span: r
+            } : {}
+        };
         return {
-            key: s,
+            key: a,
             binComponent: u
         }
     }
-    class Vr extends it {
+    class Ur extends nt {
         clone() {
-            return new Vr(null, Ce(this.bins))
+            return new Ur(null, ke(this.bins))
         }
         constructor(t, n) {
             super(t), this.bins = n
         }
         static makeFromEncoding(t, n) {
-            const i = n.reduceFieldDef((r, a, s) => {
-                if (Ui(a) && lt(a.bin)) {
+            const i = n.reduceFieldDef((r, s, a) => {
+                if (zn(s) && ot(s.bin)) {
                     const {
                         key: o,
                         binComponent: l
-                    } = t5(a, a.bin, n);
-                    r[o] = Object.assign(Object.assign(Object.assign({}, l), r[o]), wme(n, a, s, n.config))
+                    } = p3(s, s.bin, n);
+                    r[o] = {
+                        ...l,
+                        ...r[o],
+                        ...x0e(n, s, a, n.config)
+                    }
                 }
                 return r
             }, {});
-            return et(i) ? null : new Vr(t, i)
+            return et(i) ? null : new Ur(t, i)
         }
         static makeFromTransform(t, n, i) {
             const {
                 key: r,
-                binComponent: a
-            } = t5(n, n.bin, i);
-            return new Vr(t, {
-                [r]: a
+                binComponent: s
+            } = p3(n, n.bin, i);
+            return new Ur(t, {
+                [r]: s
             })
         }
         merge(t, n) {
-            for (const i of Y(t.bins)) i in this.bins ? (n(t.bins[i].signal, this.bins[i].signal), this.bins[i].as = Gr([...this.bins[i].as, ...t.bins[i].as], Ie)) : this.bins[i] = t.bins[i];
+            for (const i of H(t.bins)) i in this.bins ? (n(t.bins[i].signal, this.bins[i].signal), this.bins[i].as = Pr([...this.bins[i].as, ...t.bins[i].as], Ne)) : this.bins[i] = t.bins[i];
             for (const i of t.children) t.removeChild(i), i.parent = this;
             t.remove()
         }
         producedFields() {
-            return new Set(_n(this.bins).map(t => t.as).flat(2))
+            return new Set(Qt(this.bins).map(t => t.as).flat(2))
         }
         dependentFields() {
-            return new Set(_n(this.bins).map(t => t.field))
+            return new Set(Qt(this.bins).map(t => t.field))
         }
         hash() {
-            return `Bin ${Ie(this.bins)}`
+            return `Bin ${Ne(this.bins)}`
         }
         assemble() {
-            return _n(this.bins).flatMap(t => {
+            return Qt(this.bins).flatMap(t => {
                 const n = [],
                     [i, ...r] = t.as,
-                    a = t.bin,
                     {
-                        extent: s
-                    } = a,
-                    o = _me(a, ["extent"]),
-                    l = Object.assign(Object.assign(Object.assign({
+                        extent: s,
+                        ...a
+                    } = t.bin,
+                    o = {
                         type: "bin",
-                        field: Bi(t.field),
+                        field: Pi(t.field),
                         as: i,
-                        signal: t.signal
-                    }, Y1(s) ? {
-                        extent: null
-                    } : {
-                        extent: s
-                    }), t.span ? {
-                        span: {
-                            signal: `span(${t.span})`
-                        }
-                    } : {}), o);
+                        signal: t.signal,
+                        ...$1(s) ? {
+                            extent: null
+                        } : {
+                            extent: s
+                        },
+                        ...t.span ? {
+                            span: {
+                                signal: `span(${t.span})`
+                            }
+                        } : {},
+                        ...a
+                    };
                 !s && t.extentSignal && (n.push({
                     type: "extent",
-                    field: Bi(t.field),
+                    field: Pi(t.field),
                     signal: t.extentSignal
-                }), l.extent = {
+                }), o.extent = {
                     signal: t.extentSignal
-                }), n.push(l);
-                for (const u of r)
-                    for (let c = 0; c < 2; c++) n.push({
+                }), n.push(o);
+                for (const l of r)
+                    for (let u = 0; u < 2; u++) n.push({
                         type: "formula",
-                        expr: ne({
-                            field: i[c]
+                        expr: ie({
+                            field: i[u]
                         }, {
                             expr: "datum"
                         }),
-                        as: u[c]
+                        as: l[u]
                     });
                 return t.formula && n.push({
                     type: "formula",
                     expr: t.formula,
                     as: t.formulaAs
                 }), n
             })
         }
     }
 
-    function Ome(e, t, n, i) {
-        var r;
-        const a = kt(i) ? i.encoding[ba(t)] : void 0;
-        if (Ui(n) && kt(i) && f6(n, a, i.markDef, i.config)) e.add(ne(n, {})), e.add(ne(n, {
+    function S0e(e, t, n, i) {
+        var s;
+        const r = Et(i) ? i.encoding[us(t)] : void 0;
+        if (zn(n) && Et(i) && k6(n, r, i.markDef, i.config)) e.add(ie(n, {})), e.add(ie(n, {
             suffix: "end"
-        })), n.bin && Kd(n, t) && e.add(ne(n, {
+        })), n.bin && Nd(n, t) && e.add(ie(n, {
             binSuffix: "range"
         }));
-        else if (ife(t)) {
-            const s = nfe(t);
-            e.add(i.getName(s))
-        } else e.add(ne(n));
-        return Vl(n) && gde((r = n.scale) === null || r === void 0 ? void 0 : r.range) && e.add(n.scale.range.field), e
+        else if (SI(t)) {
+            const a = wI(t);
+            e.add(i.getName(a))
+        } else e.add(ie(n));
+        return Il(n) && bhe((s = n.scale) == null ? void 0 : s.range) && e.add(n.scale.range.field), e
     }
 
-    function Cme(e, t) {
-        var n;
-        for (const i of Y(t)) {
-            const r = t[i];
-            for (const a of Y(r)) i in e ? e[i][a] = new Set([...(n = e[i][a]) !== null && n !== void 0 ? n : [], ...r[a]]) : e[i] = {
-                [a]: r[a]
+    function E0e(e, t) {
+        for (const n of H(t)) {
+            const i = t[n];
+            for (const r of H(i)) n in e ? e[n][r] = new Set([...e[n][r] ?? [], ...i[r]]) : e[n] = {
+                [r]: i[r]
             }
         }
     }
-    class pr extends it {
+    class or extends nt {
         clone() {
-            return new pr(null, new Set(this.dimensions), Ce(this.measures))
+            return new or(null, new Set(this.dimensions), ke(this.measures))
         }
         constructor(t, n, i) {
             super(t), this.dimensions = n, this.measures = i
         }
         get groupBy() {
             return this.dimensions
         }
         static makeFromEncoding(t, n) {
             let i = !1;
-            n.forEachFieldDef(s => {
-                s.aggregate && (i = !0)
+            n.forEachFieldDef(a => {
+                a.aggregate && (i = !0)
             });
             const r = {},
-                a = new Set;
-            return !i || (n.forEachFieldDef((s, o) => {
-                var l, u, c, f;
+                s = new Set;
+            return !i || (n.forEachFieldDef((a, o) => {
                 const {
-                    aggregate: h,
-                    field: d
-                } = s;
-                if (h)
-                    if (h === "count")(l = r["*"]) !== null && l !== void 0 || (r["*"] = {}), r["*"].count = new Set([ne(s, {
+                    aggregate: l,
+                    field: u
+                } = a;
+                if (l)
+                    if (l === "count") r["*"] ?? (r["*"] = {}), r["*"].count = new Set([ie(a, {
                         forAs: !0
                     })]);
                     else {
-                        if (Va(h) || xo(h)) {
-                            const g = Va(h) ? "argmin" : "argmax",
-                                p = h[g];
-                            (u = r[p]) !== null && u !== void 0 || (r[p] = {}), r[p][g] = new Set([ne({
-                                op: g,
-                                field: p
+                        if (Bs(l) || oo(l)) {
+                            const c = Bs(l) ? "argmin" : "argmax",
+                                f = l[c];
+                            r[f] ?? (r[f] = {}), r[f][c] = new Set([ie({
+                                op: c,
+                                field: f
                             }, {
                                 forAs: !0
                             })])
-                        } else(c = r[d]) !== null && c !== void 0 || (r[d] = {}), r[d][h] = new Set([ne(s, {
+                        } else r[u] ?? (r[u] = {}), r[u][l] = new Set([ie(a, {
                             forAs: !0
                         })]);
-                        bo(o) && n.scaleDomain(o) === "unaggregated" && ((f = r[d]) !== null && f !== void 0 || (r[d] = {}), r[d].min = new Set([ne({
-                            field: d,
+                        Qs(o) && n.scaleDomain(o) === "unaggregated" && (r[u] ?? (r[u] = {}), r[u].min = new Set([ie({
+                            field: u,
                             aggregate: "min"
                         }, {
                             forAs: !0
-                        })]), r[d].max = new Set([ne({
-                            field: d,
+                        })]), r[u].max = new Set([ie({
+                            field: u,
                             aggregate: "max"
                         }, {
                             forAs: !0
                         })]))
                     }
-                else Ome(a, o, s, n)
-            }), a.size + Y(r).length === 0) ? null : new pr(t, a, r)
+                else S0e(s, o, a, n)
+            }), s.size + H(r).length === 0) ? null : new or(t, s, r)
         }
         static makeFromTransform(t, n) {
-            var i, r, a;
-            const s = new Set,
-                o = {};
-            for (const l of n.aggregate) {
+            const i = new Set,
+                r = {};
+            for (const s of n.aggregate) {
                 const {
-                    op: u,
-                    field: c,
-                    as: f
-                } = l;
-                u && (u === "count" ? ((i = o["*"]) !== null && i !== void 0 || (o["*"] = {}), o["*"].count = new Set([f || ne(l, {
+                    op: a,
+                    field: o,
+                    as: l
+                } = s;
+                a && (a === "count" ? (r["*"] ?? (r["*"] = {}), r["*"].count = new Set([l || ie(s, {
                     forAs: !0
-                })])) : ((r = o[c]) !== null && r !== void 0 || (o[c] = {}), o[c][u] = new Set([f || ne(l, {
+                })])) : (r[o] ?? (r[o] = {}), r[o][a] = new Set([l || ie(s, {
                     forAs: !0
                 })])))
             }
-            for (const l of (a = n.groupby) !== null && a !== void 0 ? a : []) s.add(l);
-            return s.size + Y(o).length === 0 ? null : new pr(t, s, o)
+            for (const s of n.groupby ?? []) i.add(s);
+            return i.size + H(r).length === 0 ? null : new or(t, i, r)
         }
         merge(t) {
-            return nj(this.dimensions, t.dimensions) ? (Cme(this.measures, t.measures), !0) : (jhe("different dimensions, cannot merge"), !1)
+            return gI(this.dimensions, t.dimensions) ? (E0e(this.measures, t.measures), !0) : (qfe("different dimensions, cannot merge"), !1)
         }
         addDimensions(t) {
             t.forEach(this.dimensions.add, this.dimensions)
         }
         dependentFields() {
-            return new Set([...this.dimensions, ...Y(this.measures)])
+            return new Set([...this.dimensions, ...H(this.measures)])
         }
         producedFields() {
             const t = new Set;
-            for (const n of Y(this.measures))
-                for (const i of Y(this.measures[n])) {
+            for (const n of H(this.measures))
+                for (const i of H(this.measures[n])) {
                     const r = this.measures[n][i];
                     r.size === 0 ? t.add(`${i}_${n}`) : r.forEach(t.add, t)
                 }
             return t
         }
         hash() {
-            return `Aggregate ${Ie({dimensions:this.dimensions,measures:this.measures})}`
+            return `Aggregate ${Ne({dimensions:this.dimensions,measures:this.measures})}`
         }
         assemble() {
             const t = [],
                 n = [],
                 i = [];
-            for (const a of Y(this.measures))
-                for (const s of Y(this.measures[a]))
-                    for (const o of this.measures[a][s]) i.push(o), t.push(s), n.push(a === "*" ? null : Bi(a));
+            for (const s of H(this.measures))
+                for (const a of H(this.measures[s]))
+                    for (const o of this.measures[s][a]) i.push(o), t.push(a), n.push(s === "*" ? null : Pi(s));
             return {
                 type: "aggregate",
-                groupby: [...this.dimensions].map(Bi),
+                groupby: [...this.dimensions].map(Pi),
                 ops: t,
                 fields: n,
                 as: i
             }
         }
     }
-    class Yc extends it {
+    class Pc extends nt {
         constructor(t, n, i, r) {
             super(t), this.model = n, this.name = i, this.data = r;
-            for (const a of Ri) {
-                const s = n.facet[a];
-                if (s) {
+            for (const s of Ti) {
+                const a = n.facet[s];
+                if (a) {
                     const {
                         bin: o,
                         sort: l
-                    } = s;
-                    this[a] = Object.assign({
-                        name: n.getName(`${a}_domain`),
-                        fields: [ne(s), ...lt(o) ? [ne(s, {
+                    } = a;
+                    this[s] = {
+                        name: n.getName(`${s}_domain`),
+                        fields: [ie(a), ...ot(o) ? [ie(a, {
                             binSuffix: "end"
-                        })] : []]
-                    }, Yr(l) ? {
-                        sortField: l
-                    } : q(l) ? {
-                        sortIndexField: xc(s, a)
-                    } : {})
+                        })] : []],
+                        ...Br(l) ? {
+                            sortField: l
+                        } : W(l) ? {
+                            sortIndexField: uc(a, s)
+                        } : {}
+                    }
                 }
             }
             this.childModel = n.child
         }
         hash() {
             let t = "Facet";
-            for (const n of Ri) this[n] && (t += ` ${n.charAt(0)}:${Ie(this[n])}`);
+            for (const n of Ti) this[n] && (t += ` ${n.charAt(0)}:${Ne(this[n])}`);
             return t
         }
         get fields() {
-            var t;
-            const n = [];
-            for (const i of Ri) !((t = this[i]) === null || t === void 0) && t.fields && n.push(...this[i].fields);
-            return n
+            var n;
+            const t = [];
+            for (const i of Ti)(n = this[i]) != null && n.fields && t.push(...this[i].fields);
+            return t
         }
         dependentFields() {
             const t = new Set(this.fields);
-            for (const n of Ri) this[n] && (this[n].sortField && t.add(this[n].sortField.field), this[n].sortIndexField && t.add(this[n].sortIndexField));
+            for (const n of Ti) this[n] && (this[n].sortField && t.add(this[n].sortField.field), this[n].sortIndexField && t.add(this[n].sortIndexField));
             return t
         }
         producedFields() {
             return new Set
         }
         getSource() {
             return this.name
         }
         getChildIndependentFieldsWithStep() {
             const t = {};
-            for (const n of xa) {
+            for (const n of cs) {
                 const i = this.childModel.component.scales[n];
                 if (i && !i.merged) {
                     const r = i.get("type"),
-                        a = i.get("range");
-                    if (Vt(r) && _o(a)) {
-                        const s = gy(this.childModel, n),
-                            o = dC(s);
-                        o ? t[n] = o : X(dO(n))
+                        s = i.get("range");
+                    if (qt(r) && lo(s)) {
+                        const a = K1(this.childModel, n),
+                            o = FC(a);
+                        o ? t[n] = o : X(RE(n))
                     }
                 }
             }
             return t
         }
         assembleRowColumnHeaderData(t, n, i) {
             const r = {
                     row: "y",
                     column: "x",
                     facet: void 0
                 } [t],
-                a = [],
                 s = [],
+                a = [],
                 o = [];
-            r && i && i[r] && (n ? (a.push(`distinct_${i[r]}`), s.push("max")) : (a.push(i[r]), s.push("distinct")), o.push(`distinct_${i[r]}`));
+            r && i && i[r] && (n ? (s.push(`distinct_${i[r]}`), a.push("max")) : (s.push(i[r]), a.push("distinct")), o.push(`distinct_${i[r]}`));
             const {
                 sortField: l,
                 sortIndexField: u
             } = this[t];
             if (l) {
                 const {
-                    op: c = Z1,
+                    op: c = N1,
                     field: f
                 } = l;
-                a.push(f), s.push(c), o.push(ne(l, {
+                s.push(f), a.push(c), o.push(ie(l, {
                     forAs: !0
                 }))
-            } else u && (a.push(u), s.push("max"), o.push(u));
+            } else u && (s.push(u), a.push("max"), o.push(u));
             return {
                 name: this[t].name,
                 source: n ?? this.data,
-                transform: [Object.assign({
+                transform: [{
                     type: "aggregate",
-                    groupby: this[t].fields
-                }, a.length ? {
-                    fields: a,
-                    ops: s,
-                    as: o
-                } : {})]
+                    groupby: this[t].fields,
+                    ...s.length ? {
+                        fields: s,
+                        ops: a,
+                        as: o
+                    } : {}
+                }]
             }
         }
         assembleFacetHeaderData(t) {
-            var n, i;
+            var l;
             const {
-                columns: r
+                columns: n
             } = this.model.layout, {
-                layoutHeaders: a
-            } = this.model.component, s = [], o = {};
-            for (const c of aC) {
-                for (const f of sC) {
-                    const h = (n = a[c] && a[c][f]) !== null && n !== void 0 ? n : [];
-                    for (const d of h)
-                        if (((i = d.axes) === null || i === void 0 ? void 0 : i.length) > 0) {
-                            o[c] = !0;
+                layoutHeaders: i
+            } = this.model.component, r = [], s = {};
+            for (const u of EC) {
+                for (const c of CC) {
+                    const f = (i[u] && i[u][c]) ?? [];
+                    for (const h of f)
+                        if (((l = h.axes) == null ? void 0 : l.length) > 0) {
+                            s[u] = !0;
                             break
                         }
                 }
-                if (o[c]) {
-                    const f = `length(data("${this.facet.name}"))`,
-                        h = c === "row" ? r ? {
-                            signal: `ceil(${f} / ${r})`
-                        } : 1 : r ? {
-                            signal: `min(${f}, ${r})`
+                if (s[u]) {
+                    const c = `length(data("${this.facet.name}"))`,
+                        f = u === "row" ? n ? {
+                            signal: `ceil(${c} / ${n})`
+                        } : 1 : n ? {
+                            signal: `min(${c}, ${n})`
                         } : {
-                            signal: f
+                            signal: c
                         };
-                    s.push({
-                        name: `${this.facet.name}_${c}`,
+                    r.push({
+                        name: `${this.facet.name}_${u}`,
                         transform: [{
                             type: "sequence",
                             start: 0,
-                            stop: h
+                            stop: f
                         }]
                     })
                 }
             }
             const {
-                row: l,
-                column: u
-            } = o;
-            return (l || u) && s.unshift(this.assembleRowColumnHeaderData("facet", null, t)), s
+                row: a,
+                column: o
+            } = s;
+            return (a || o) && r.unshift(this.assembleRowColumnHeaderData("facet", null, t)), r
         }
         assemble() {
-            var t, n;
-            const i = [];
-            let r = null;
-            const a = this.getChildIndependentFieldsWithStep(),
+            const t = [];
+            let n = null;
+            const i = this.getChildIndependentFieldsWithStep(),
                 {
-                    column: s,
-                    row: o,
-                    facet: l
+                    column: r,
+                    row: s,
+                    facet: a
                 } = this;
-            if (s && o && (a.x || a.y)) {
-                r = `cross_${this.column.name}_${this.row.name}`;
-                const u = [].concat((t = a.x) !== null && t !== void 0 ? t : [], (n = a.y) !== null && n !== void 0 ? n : []),
-                    c = u.map(() => "distinct");
-                i.push({
-                    name: r,
+            if (r && s && (i.x || i.y)) {
+                n = `cross_${this.column.name}_${this.row.name}`;
+                const o = [].concat(i.x ?? [], i.y ?? []),
+                    l = o.map(() => "distinct");
+                t.push({
+                    name: n,
                     source: this.data,
                     transform: [{
                         type: "aggregate",
                         groupby: this.fields,
-                        fields: u,
-                        ops: c
+                        fields: o,
+                        ops: l
                     }]
                 })
             }
-            for (const u of [Ua, Ga]) this[u] && i.push(this.assembleRowColumnHeaderData(u, r, a));
-            if (l) {
-                const u = this.assembleFacetHeaderData(a);
-                u && i.push(...u)
+            for (const o of [Rs, Fs]) this[o] && t.push(this.assembleRowColumnHeaderData(o, n, i));
+            if (a) {
+                const o = this.assembleFacetHeaderData(i);
+                o && t.push(...o)
             }
-            return i
+            return t
         }
     }
 
-    function n5(e) {
+    function m3(e) {
         return e.startsWith("'") && e.endsWith("'") || e.startsWith('"') && e.endsWith('"') ? e.slice(1, -1) : e
     }
 
-    function kme(e, t) {
-        const n = nO(e);
+    function C0e(e, t) {
+        const n = wE(e);
         if (t === "number") return `toNumber(${n})`;
         if (t === "boolean") return `toBoolean(${n})`;
         if (t === "string") return `toString(${n})`;
         if (t === "date") return `toDate(${n})`;
         if (t === "flatten") return n;
         if (t.startsWith("date:")) {
-            const i = n5(t.slice(5, t.length));
+            const i = m3(t.slice(5, t.length));
             return `timeParse(${n},'${i}')`
         } else if (t.startsWith("utc:")) {
-            const i = n5(t.slice(4, t.length));
+            const i = m3(t.slice(4, t.length));
             return `utcParse(${n},'${i}')`
-        } else return X(Hfe(t)), null
+        } else return X(Qce(t)), null
     }
 
-    function Ame(e) {
+    function k0e(e) {
         const t = {};
-        return Fp(e.filter, n => {
-            var i;
-            if (Bj(n)) {
-                let r = null;
-                vO(n) ? r = pi(n.equal) : xO(n) ? r = pi(n.lte) : bO(n) ? r = pi(n.lt) : _O(n) ? r = pi(n.gt) : wO(n) ? r = pi(n.gte) : SO(n) ? r = n.range[0] : EO(n) && (r = ((i = n.oneOf) !== null && i !== void 0 ? i : n.in)[0]), r && (Xl(r) ? t[n.field] = "date" : tt(r) ? t[n.field] = "number" : re(r) && (t[n.field] = "string")), n.timeUnit && (t[n.field] = "date")
+        return gp(e.filter, n => {
+            if (n6(n)) {
+                let i = null;
+                LE(n) ? i = di(n.equal) : zE(n) ? i = di(n.lte) : IE(n) ? i = di(n.lt) : BE(n) ? i = di(n.gt) : jE(n) ? i = di(n.gte) : UE(n) ? i = n.range[0] : GE(n) && (i = (n.oneOf ?? n.in)[0]), i && (Ll(i) ? t[n.field] = "date" : Ze(i) ? t[n.field] = "number" : re(i) && (t[n.field] = "string")), n.timeUnit && (t[n.field] = "date")
             }
         }), t
     }
 
-    function Tme(e) {
+    function A0e(e) {
         const t = {};
 
         function n(i) {
-            mc(i) ? t[i.field] = "date" : i.type === "quantitative" && Sfe(i.aggregate) ? t[i.field] = "number" : cc(i.field) > 1 ? i.field in t || (t[i.field] = "flatten") : Vl(i) && Yr(i.sort) && cc(i.sort.field) > 1 && (i.sort.field in t || (t[i.sort.field] = "flatten"))
+            ac(i) ? t[i.field] = "date" : i.type === "quantitative" && Mce(i.aggregate) ? t[i.field] = "number" : Zu(i.field) > 1 ? i.field in t || (t[i.field] = "flatten") : Il(i) && Br(i.sort) && Zu(i.sort.field) > 1 && (i.sort.field in t || (t[i.sort.field] = "flatten"))
         }
-        if ((kt(e) || mr(e)) && e.forEachFieldDef((i, r) => {
-                if (Ui(i)) n(i);
+        if ((Et(e) || lr(e)) && e.forEachFieldDef((i, r) => {
+                if (zn(i)) n(i);
                 else {
-                    const a = Hl(r),
-                        s = e.fieldDef(a);
-                    n(Object.assign(Object.assign({}, i), {
-                        type: s.type
-                    }))
+                    const s = Nl(r),
+                        a = e.fieldDef(s);
+                    n({
+                        ...i,
+                        type: a.type
+                    })
                 }
-            }), kt(e)) {
+            }), Et(e)) {
             const {
                 mark: i,
                 markDef: r,
-                encoding: a
+                encoding: s
             } = e;
-            if (wo(i) && !e.encoding.order) {
-                const s = r.orient === "horizontal" ? "y" : "x",
-                    o = a[s];
-                J(o) && o.type === "quantitative" && !(o.field in t) && (t[o.field] = "number")
+            if (uo(i) && !e.encoding.order) {
+                const a = r.orient === "horizontal" ? "y" : "x",
+                    o = s[a];
+                K(o) && o.type === "quantitative" && !(o.field in t) && (t[o.field] = "number")
             }
         }
         return t
     }
 
-    function $me(e) {
+    function $0e(e) {
         const t = {};
-        if (kt(e) && e.component.selection)
-            for (const n of Y(e.component.selection)) {
+        if (Et(e) && e.component.selection)
+            for (const n of H(e.component.selection)) {
                 const i = e.component.selection[n];
-                for (const r of i.project.items) !r.channel && cc(r.field) > 1 && (t[r.field] = "flatten")
+                for (const r of i.project.items) !r.channel && Zu(r.field) > 1 && (t[r.field] = "flatten")
             }
         return t
     }
-    class mn extends it {
+    class gn extends nt {
         clone() {
-            return new mn(null, Ce(this._parse))
+            return new gn(null, ke(this._parse))
         }
         constructor(t, n) {
             super(t), this._parse = n
         }
         hash() {
-            return `Parse ${Ie(this._parse)}`
+            return `Parse ${Ne(this._parse)}`
         }
         static makeExplicit(t, n, i) {
-            var r;
-            let a = {};
+            var a;
+            let r = {};
             const s = n.data;
-            return !Is(s) && (!((r = s == null ? void 0 : s.format) === null || r === void 0) && r.parse) && (a = s.format.parse), this.makeWithAncestors(t, a, {}, i)
+            return !$a(s) && ((a = s == null ? void 0 : s.format) != null && a.parse) && (r = s.format.parse), this.makeWithAncestors(t, r, {}, i)
         }
         static makeWithAncestors(t, n, i, r) {
-            for (const o of Y(i)) {
+            for (const o of H(i)) {
                 const l = r.getWithExplicit(o);
-                l.value !== void 0 && (l.explicit || l.value === i[o] || l.value === "derived" || i[o] === "flatten" ? delete i[o] : X(m$(o, i[o], l.value)))
+                l.value !== void 0 && (l.explicit || l.value === i[o] || l.value === "derived" || i[o] === "flatten" ? delete i[o] : X(M5(o, i[o], l.value)))
             }
-            for (const o of Y(n)) {
+            for (const o of H(n)) {
                 const l = r.get(o);
-                l !== void 0 && (l === n[o] ? delete n[o] : X(m$(o, n[o], l)))
+                l !== void 0 && (l === n[o] ? delete n[o] : X(M5(o, n[o], l)))
             }
-            const a = new ls(n, i);
-            r.copyAll(a);
-            const s = {};
-            for (const o of Y(a.combine())) {
-                const l = a.get(o);
-                l !== null && (s[o] = l)
+            const s = new ea(n, i);
+            r.copyAll(s);
+            const a = {};
+            for (const o of H(s.combine())) {
+                const l = s.get(o);
+                l !== null && (a[o] = l)
             }
-            return Y(s).length === 0 || r.parseNothing ? null : new mn(t, s)
+            return H(a).length === 0 || r.parseNothing ? null : new gn(t, a)
         }
         get parse() {
             return this._parse
         }
         merge(t) {
-            this._parse = Object.assign(Object.assign({}, this._parse), t.parse), t.remove()
+            this._parse = {
+                ...this._parse,
+                ...t.parse
+            }, t.remove()
         }
         assembleFormatParse() {
             const t = {};
-            for (const n of Y(this._parse)) {
+            for (const n of H(this._parse)) {
                 const i = this._parse[n];
-                cc(n) === 1 && (t[n] = i)
+                Zu(n) === 1 && (t[n] = i)
             }
             return t
         }
         producedFields() {
-            return new Set(Y(this._parse))
+            return new Set(H(this._parse))
         }
         dependentFields() {
-            return new Set(Y(this._parse))
+            return new Set(H(this._parse))
         }
         assembleTransforms(t = !1) {
-            return Y(this._parse).filter(n => t ? cc(n) > 1 : !0).map(n => {
-                const i = kme(n, this._parse[n]);
+            return H(this._parse).filter(n => t ? Zu(n) > 1 : !0).map(n => {
+                const i = C0e(n, this._parse[n]);
                 return i ? {
                     type: "formula",
                     expr: i,
-                    as: iO(n)
+                    as: SE(n)
                 } : null
             }).filter(n => n !== null)
         }
     }
-    class no extends it {
+    class qa extends nt {
         clone() {
-            return new no(null)
+            return new qa(null)
         }
         constructor(t) {
             super(t)
         }
         dependentFields() {
             return new Set
         }
         producedFields() {
-            return new Set([ra])
+            return new Set([pr])
         }
         hash() {
             return "Identifier"
         }
         assemble() {
             return {
                 type: "identifier",
-                as: ra
+                as: pr
             }
         }
     }
-    class Zd extends it {
+    class Id extends nt {
         clone() {
-            return new Zd(null, this.params)
+            return new Id(null, this.params)
         }
         constructor(t, n) {
             super(t), this.params = n
         }
         dependentFields() {
             return new Set
         }
         producedFields() {}
         hash() {
-            return `Graticule ${Ie(this.params)}`
+            return `Graticule ${Ne(this.params)}`
         }
         assemble() {
-            return Object.assign({
-                type: "graticule"
-            }, this.params === !0 ? {} : this.params)
+            return {
+                type: "graticule",
+                ...this.params === !0 ? {} : this.params
+            }
         }
     }
-    class eg extends it {
+    class zd extends nt {
         clone() {
-            return new eg(null, this.params)
+            return new zd(null, this.params)
         }
         constructor(t, n) {
             super(t), this.params = n
         }
         dependentFields() {
             return new Set
         }
         producedFields() {
-            var t;
-            return new Set([(t = this.params.as) !== null && t !== void 0 ? t : "data"])
+            return new Set([this.params.as ?? "data"])
         }
         hash() {
-            return `Hash ${Ie(this.params)}`
+            return `Hash ${Ne(this.params)}`
         }
         assemble() {
-            return Object.assign({
-                type: "sequence"
-            }, this.params)
+            return {
+                type: "sequence",
+                ...this.params
+            }
         }
     }
-    class Al extends it {
+    class yl extends nt {
         constructor(t) {
             super(null), t ?? (t = {
                 name: "source"
             });
             let n;
-            if (Is(t) || (n = t.format ? Object.assign({}, Zn(t.format, ["parse"])) : {}), Zh(t)) this._data = {
+            if ($a(t) || (n = t.format ? {
+                    ...Jn(t.format, ["parse"])
+                } : {}), Bh(t)) this._data = {
                 values: t.values
             };
-            else if (yc(t)) {
+            else if (oc(t)) {
                 if (this._data = {
                         url: t.url
                     }, !n.type) {
                     let i = /(?:\.([^.]+))?$/.exec(t.url)[1];
-                    Pe(["json", "csv", "tsv", "dsv", "topojson"], i) || (i = "json"), n.type = i
+                    Fe(["json", "csv", "tsv", "dsv", "topojson"], i) || (i = "json"), n.type = i
                 }
-            } else rz(t) ? this._data = {
+            } else yz(t) ? this._data = {
                 values: [{
                     type: "Sphere"
                 }]
-            } : (nz(t) || Is(t)) && (this._data = {});
-            this._generator = Is(t), t.name && (this._name = t.name), n && !et(n) && (this._data.format = n)
+            } : (pz(t) || $a(t)) && (this._data = {});
+            this._generator = $a(t), t.name && (this._name = t.name), n && !et(n) && (this._data.format = n)
         }
         dependentFields() {
             return new Set
         }
         producedFields() {}
         get data() {
             return this._data
@@ -46679,329 +47025,334 @@
         remove() {
             throw new Error("Source nodes are roots and cannot be removed.")
         }
         hash() {
             throw new Error("Cannot hash sources")
         }
         assemble() {
-            return Object.assign(Object.assign({
-                name: this._name
-            }, this._data), {
+            return {
+                name: this._name,
+                ...this._data,
                 transform: []
-            })
+            }
         }
     }
-    var i5 = globalThis && globalThis.__classPrivateFieldSet || function(e, t, n, i, r) {
+    var y3 = globalThis && globalThis.__classPrivateFieldSet || function(e, t, n, i, r) {
             if (i === "m") throw new TypeError("Private method is not writable");
             if (i === "a" && !r) throw new TypeError("Private accessor was defined without a setter");
             if (typeof t == "function" ? e !== t || !r : !t.has(e)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
             return i === "a" ? r.call(e, n) : r ? r.value = n : t.set(e, n), n
         },
-        Mme = globalThis && globalThis.__classPrivateFieldGet || function(e, t, n, i) {
+        T0e = globalThis && globalThis.__classPrivateFieldGet || function(e, t, n, i) {
             if (n === "a" && !i) throw new TypeError("Private accessor was defined without a getter");
             if (typeof t == "function" ? e !== t || !i : !t.has(e)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
             return n === "m" ? i : n === "a" ? i.call(e) : i ? i.value : t.get(e)
         },
-        nh;
+        Wf;
 
-    function cC(e) {
-        return e instanceof Al || e instanceof Zd || e instanceof eg
+    function TC(e) {
+        return e instanceof yl || e instanceof Id || e instanceof zd
     }
-    class fC {
+    class MC {
         constructor() {
-            nh.set(this, void 0), i5(this, nh, !1, "f")
+            Wf.set(this, void 0), y3(this, Wf, !1, "f")
         }
         setModified() {
-            i5(this, nh, !0, "f")
+            y3(this, Wf, !0, "f")
         }
         get modifiedFlag() {
-            return Mme(this, nh, "f")
+            return T0e(this, Wf, "f")
         }
     }
-    nh = new WeakMap;
-    class Kl extends fC {
+    Wf = new WeakMap;
+    class zl extends MC {
         getNodeDepths(t, n, i) {
             i.set(t, n);
             for (const r of t.children) this.getNodeDepths(r, n + 1, i);
             return i
         }
         optimize(t) {
-            const i = [...this.getNodeDepths(t, 0, new Map).entries()].sort((r, a) => a[1] - r[1]);
+            const i = [...this.getNodeDepths(t, 0, new Map).entries()].sort((r, s) => s[1] - r[1]);
             for (const r of i) this.run(r[0]);
             return this.modifiedFlag
         }
     }
-    class hC extends fC {
+    class OC extends MC {
         optimize(t) {
             this.run(t);
             for (const n of t.children) this.optimize(n);
             return this.modifiedFlag
         }
     }
-    class Fme extends hC {
+    class M0e extends OC {
         mergeNodes(t, n) {
             const i = n.shift();
             for (const r of n) t.removeChild(r), r.parent = i, r.remove()
         }
         run(t) {
             const n = t.children.map(r => r.hash()),
                 i = {};
             for (let r = 0; r < n.length; r++) i[n[r]] === void 0 ? i[n[r]] = [t.children[r]] : i[n[r]].push(t.children[r]);
-            for (const r of Y(i)) i[r].length > 1 && (this.setModified(), this.mergeNodes(t, i[r]))
+            for (const r of H(i)) i[r].length > 1 && (this.setModified(), this.mergeNodes(t, i[r]))
         }
     }
-    class Dme extends hC {
+    class O0e extends OC {
         constructor(t) {
-            super(), this.requiresSelectionId = t && rC(t)
+            super(), this.requiresSelectionId = t && SC(t)
         }
         run(t) {
-            t instanceof no && (this.requiresSelectionId && (cC(t.parent) || t.parent instanceof pr || t.parent instanceof mn) || (this.setModified(), t.remove()))
+            t instanceof qa && (this.requiresSelectionId && (TC(t.parent) || t.parent instanceof or || t.parent instanceof gn) || (this.setModified(), t.remove()))
         }
     }
-    class Rme extends fC {
+    class F0e extends MC {
         optimize(t) {
             return this.run(t, new Set), this.modifiedFlag
         }
         run(t, n) {
             let i = new Set;
-            t instanceof Xr && (i = t.producedFields(), eO(i, n) && (this.setModified(), t.removeFormulas(n), t.producedFields.length === 0 && t.remove()));
+            t instanceof jr && (i = t.producedFields(), xE(i, n) && (this.setModified(), t.removeFormulas(n), t.producedFields.length === 0 && t.remove()));
             for (const r of t.children) this.run(r, new Set([...n, ...i]))
         }
     }
-    class Pme extends hC {
+    class R0e extends OC {
         constructor() {
             super()
         }
         run(t) {
-            t instanceof Ln && !t.isRequired() && (this.setModified(), t.remove())
+            t instanceof Dn && !t.isRequired() && (this.setModified(), t.remove())
         }
     }
-    class Nme extends Kl {
+    class D0e extends zl {
         run(t) {
-            if (!cC(t) && !(t.numChildren() > 1)) {
+            if (!TC(t) && !(t.numChildren() > 1)) {
                 for (const n of t.children)
-                    if (n instanceof mn)
-                        if (t instanceof mn) this.setModified(), t.merge(n);
+                    if (n instanceof gn)
+                        if (t instanceof gn) this.setModified(), t.merge(n);
                         else {
-                            if (tO(t.producedFields(), n.dependentFields())) continue;
+                            if (_E(t.producedFields(), n.dependentFields())) continue;
                             this.setModified(), n.swapWithParent()
                         }
             }
         }
     }
-    class Lme extends Kl {
+    class N0e extends zl {
         run(t) {
             const n = [...t.children],
-                i = t.children.filter(r => r instanceof mn);
+                i = t.children.filter(r => r instanceof gn);
             if (t.numChildren() > 1 && i.length >= 1) {
                 const r = {},
-                    a = new Set;
-                for (const s of i) {
-                    const o = s.parse;
-                    for (const l of Y(o)) l in r ? r[l] !== o[l] && a.add(l) : r[l] = o[l]
+                    s = new Set;
+                for (const a of i) {
+                    const o = a.parse;
+                    for (const l of H(o)) l in r ? r[l] !== o[l] && s.add(l) : r[l] = o[l]
                 }
-                for (const s of a) delete r[s];
+                for (const a of s) delete r[a];
                 if (!et(r)) {
                     this.setModified();
-                    const s = new mn(t, r);
+                    const a = new gn(t, r);
                     for (const o of n) {
-                        if (o instanceof mn)
-                            for (const l of Y(r)) delete o.parse[l];
-                        t.removeChild(o), o.parent = s, o instanceof mn && Y(o.parse).length === 0 && o.remove()
+                        if (o instanceof gn)
+                            for (const l of H(r)) delete o.parse[l];
+                        t.removeChild(o), o.parent = a, o instanceof gn && H(o.parse).length === 0 && o.remove()
                     }
                 }
             }
         }
     }
-    class Ime extends Kl {
+    class P0e extends zl {
         run(t) {
-            t instanceof Ln || t.numChildren() > 0 || t instanceof Yc || t instanceof Al || (this.setModified(), t.remove())
+            t instanceof Dn || t.numChildren() > 0 || t instanceof Pc || t instanceof yl || (this.setModified(), t.remove())
         }
     }
-    class jme extends Kl {
+    class L0e extends zl {
         run(t) {
-            const n = t.children.filter(r => r instanceof Xr),
+            const n = t.children.filter(r => r instanceof jr),
                 i = n.pop();
             for (const r of n) this.setModified(), i.merge(r)
         }
     }
-    class zme extends Kl {
+    class I0e extends zl {
         run(t) {
-            const n = t.children.filter(r => r instanceof pr),
+            const n = t.children.filter(r => r instanceof or),
                 i = {};
             for (const r of n) {
-                const a = Ie(r.groupBy);
-                a in i || (i[a] = []), i[a].push(r)
+                const s = Ne(r.groupBy);
+                s in i || (i[s] = []), i[s].push(r)
             }
-            for (const r of Y(i)) {
-                const a = i[r];
-                if (a.length > 1) {
-                    const s = a.pop();
-                    for (const o of a) s.merge(o) && (t.removeChild(o), o.parent = s, o.remove(), this.setModified())
+            for (const r of H(i)) {
+                const s = i[r];
+                if (s.length > 1) {
+                    const a = s.pop();
+                    for (const o of s) a.merge(o) && (t.removeChild(o), o.parent = a, o.remove(), this.setModified())
                 }
             }
         }
     }
-    class Bme extends Kl {
+    class z0e extends zl {
         constructor(t) {
             super(), this.model = t
         }
         run(t) {
-            const n = !(cC(t) || t instanceof Hc || t instanceof mn || t instanceof no),
+            const n = !(TC(t) || t instanceof Nc || t instanceof gn || t instanceof qa),
                 i = [],
                 r = [];
-            for (const a of t.children) a instanceof Vr && (n && !tO(t.producedFields(), a.dependentFields()) ? i.push(a) : r.push(a));
+            for (const s of t.children) s instanceof Ur && (n && !_E(t.producedFields(), s.dependentFields()) ? i.push(s) : r.push(s));
             if (i.length > 0) {
-                const a = i.pop();
-                for (const s of i) a.merge(s, this.model.renameSignal.bind(this.model));
-                this.setModified(), t instanceof Vr ? t.merge(a, this.model.renameSignal.bind(this.model)) : a.swapWithParent()
+                const s = i.pop();
+                for (const a of i) s.merge(a, this.model.renameSignal.bind(this.model));
+                this.setModified(), t instanceof Ur ? t.merge(s, this.model.renameSignal.bind(this.model)) : s.swapWithParent()
             }
             if (r.length > 1) {
-                const a = r.pop();
-                for (const s of r) a.merge(s, this.model.renameSignal.bind(this.model));
+                const s = r.pop();
+                for (const a of r) s.merge(a, this.model.renameSignal.bind(this.model));
                 this.setModified()
             }
         }
     }
-    class Gme extends Kl {
+    class B0e extends zl {
         run(t) {
             const n = [...t.children];
-            if (!bl(n, s => s instanceof Ln) || t.numChildren() <= 1) return;
+            if (!ol(n, a => a instanceof Dn) || t.numChildren() <= 1) return;
             const r = [];
-            let a;
-            for (const s of n)
-                if (s instanceof Ln) {
-                    let o = s;
+            let s;
+            for (const a of n)
+                if (a instanceof Dn) {
+                    let o = a;
                     for (; o.numChildren() === 1;) {
                         const [l] = o.children;
-                        if (l instanceof Ln) o = l;
+                        if (l instanceof Dn) o = l;
                         else break
                     }
-                    r.push(...o.children), a ? (t.removeChild(s), s.parent = a.parent, a.parent.removeChild(a), a.parent = o, this.setModified()) : a = o
-                } else r.push(s);
+                    r.push(...o.children), s ? (t.removeChild(a), a.parent = s.parent, s.parent.removeChild(s), s.parent = o, this.setModified()) : s = o
+                } else r.push(a);
             if (r.length) {
                 this.setModified();
-                for (const s of r) s.parent.removeChild(s), s.parent = a
+                for (const a of r) a.parent.removeChild(a), a.parent = s
             }
         }
     }
-    class Jl extends it {
+    class Bl extends nt {
         clone() {
-            return new Jl(null, Ce(this.transform))
+            return new Bl(null, ke(this.transform))
         }
         constructor(t, n) {
             super(t), this.transform = n
         }
         addDimensions(t) {
-            this.transform.groupby = Gr(this.transform.groupby.concat(t), n => n)
+            this.transform.groupby = Pr(this.transform.groupby.concat(t), n => n)
         }
         dependentFields() {
             const t = new Set;
             return this.transform.groupby && this.transform.groupby.forEach(t.add, t), this.transform.joinaggregate.map(n => n.field).filter(n => n !== void 0).forEach(t.add, t), t
         }
         producedFields() {
             return new Set(this.transform.joinaggregate.map(this.getDefaultName))
         }
         getDefaultName(t) {
-            var n;
-            return (n = t.as) !== null && n !== void 0 ? n : ne(t)
+            return t.as ?? ie(t)
         }
         hash() {
-            return `JoinAggregateTransform ${Ie(this.transform)}`
+            return `JoinAggregateTransform ${Ne(this.transform)}`
         }
         assemble() {
             const t = [],
                 n = [],
                 i = [];
-            for (const a of this.transform.joinaggregate) n.push(a.op), i.push(this.getDefaultName(a)), t.push(a.field === void 0 ? null : a.field);
+            for (const s of this.transform.joinaggregate) n.push(s.op), i.push(this.getDefaultName(s)), t.push(s.field === void 0 ? null : s.field);
             const r = this.transform.groupby;
-            return Object.assign({
+            return {
                 type: "joinaggregate",
                 as: i,
                 ops: n,
-                fields: t
-            }, r !== void 0 ? {
-                groupby: r
-            } : {})
+                fields: t,
+                ...r !== void 0 ? {
+                    groupby: r
+                } : {}
+            }
         }
     }
 
-    function Ume(e) {
+    function j0e(e) {
         return e.stack.stackBy.reduce((t, n) => {
             const i = n.fieldDef,
-                r = ne(i);
+                r = ie(i);
             return r && t.push(r), t
         }, [])
     }
 
-    function qme(e) {
-        return q(e) && e.every(t => re(t)) && e.length > 1
+    function U0e(e) {
+        return W(e) && e.every(t => re(t)) && e.length > 1
     }
-    class Wa extends it {
+    class Ps extends nt {
         clone() {
-            return new Wa(null, Ce(this._stack))
+            return new Ps(null, ke(this._stack))
         }
         constructor(t, n) {
             super(t), this._stack = n
         }
         static makeFromTransform(t, n) {
             const {
                 stack: i,
                 groupby: r,
-                as: a,
-                offset: s = "zero"
+                as: s,
+                offset: a = "zero"
             } = n, o = [], l = [];
             if (n.sort !== void 0)
-                for (const f of n.sort) o.push(f.field), l.push(Tt(f.order, "ascending"));
+                for (const f of n.sort) o.push(f.field), l.push(Ct(f.order, "ascending"));
             const u = {
                 field: o,
                 order: l
             };
             let c;
-            return qme(a) ? c = a : re(a) ? c = [a, `${a}_end`] : c = [`${n.stack}_start`, `${n.stack}_end`], new Wa(t, {
+            return U0e(s) ? c = s : re(s) ? c = [s, `${s}_end`] : c = [`${n.stack}_start`, `${n.stack}_end`], new Ps(t, {
                 dimensionFieldDefs: [],
                 stackField: i,
                 groupby: r,
-                offset: s,
+                offset: a,
                 sort: u,
                 facetby: [],
                 as: c
             })
         }
         static makeFromEncoding(t, n) {
             const i = n.stack,
                 {
                     encoding: r
                 } = n;
             if (!i) return null;
             const {
-                groupbyChannels: a,
-                fieldChannel: s,
+                groupbyChannels: s,
+                fieldChannel: a,
                 offset: o,
                 impute: l
-            } = i, u = a.map(d => {
+            } = i, u = s.map(d => {
                 const g = r[d];
-                return ia(g)
-            }).filter(d => !!d), c = Ume(n), f = n.encoding.order;
+                return Kr(g)
+            }).filter(d => !!d), c = j0e(n), f = n.encoding.order;
             let h;
-            return q(f) || J(f) ? h = Oj(f) : h = c.reduce((d, g) => (d.field.push(g), d.order.push(s === "y" ? "descending" : "ascending"), d), {
-                field: [],
-                order: []
-            }), new Wa(t, {
+            if (W(f) || K(f)) h = zI(f);
+            else {
+                const d = A6(f) ? f.sort : a === "y" ? "descending" : "ascending";
+                h = c.reduce((g, p) => (g.field.push(p), g.order.push(d), g), {
+                    field: [],
+                    order: []
+                })
+            }
+            return new Ps(t, {
                 dimensionFieldDefs: u,
-                stackField: n.vgField(s),
+                stackField: n.vgField(a),
                 facetby: [],
                 stackby: c,
                 sort: h,
                 offset: o,
                 impute: l,
-                as: [n.vgField(s, {
+                as: [n.vgField(a, {
                     suffix: "start",
                     forAs: !0
-                }), n.vgField(s, {
+                }), n.vgField(a, {
                     suffix: "end",
                     forAs: !0
                 })]
             })
         }
         get stack() {
             return this._stack
@@ -47013,892 +47364,920 @@
             const t = new Set;
             return t.add(this._stack.stackField), this.getGroupbyFields().forEach(t.add, t), this._stack.facetby.forEach(t.add, t), this._stack.sort.field.forEach(t.add, t), t
         }
         producedFields() {
             return new Set(this._stack.as)
         }
         hash() {
-            return `Stack ${Ie(this._stack)}`
+            return `Stack ${Ne(this._stack)}`
         }
         getGroupbyFields() {
             const {
                 dimensionFieldDefs: t,
                 impute: n,
                 groupby: i
             } = this._stack;
-            return t.length > 0 ? t.map(r => r.bin ? n ? [ne(r, {
+            return t.length > 0 ? t.map(r => r.bin ? n ? [ie(r, {
                 binSuffix: "mid"
-            })] : [ne(r, {}), ne(r, {
+            })] : [ie(r, {}), ie(r, {
                 binSuffix: "end"
-            })] : [ne(r)]).flat() : i ?? []
+            })] : [ie(r)]).flat() : i ?? []
         }
         assemble() {
             const t = [],
                 {
                     facetby: n,
                     dimensionFieldDefs: i,
                     stackField: r,
-                    stackby: a,
-                    sort: s,
+                    stackby: s,
+                    sort: a,
                     offset: o,
                     impute: l,
                     as: u
                 } = this._stack;
             if (l)
                 for (const c of i) {
                     const {
                         bandPosition: f = .5,
                         bin: h
                     } = c;
                     if (h) {
-                        const d = ne(c, {
+                        const d = ie(c, {
                                 expr: "datum"
                             }),
-                            g = ne(c, {
+                            g = ie(c, {
                                 expr: "datum",
                                 binSuffix: "end"
                             });
                         t.push({
                             type: "formula",
                             expr: `${f}*${d}+${1-f}*${g}`,
-                            as: ne(c, {
+                            as: ie(c, {
                                 binSuffix: "mid",
                                 forAs: !0
                             })
                         })
                     }
                     t.push({
                         type: "impute",
                         field: r,
-                        groupby: [...a, ...n],
-                        key: ne(c, {
+                        groupby: [...s, ...n],
+                        key: ie(c, {
                             binSuffix: "mid"
                         }),
                         method: "value",
                         value: 0
                     })
                 }
             return t.push({
                 type: "stack",
                 groupby: [...this.getGroupbyFields(), ...n],
                 field: r,
-                sort: s,
+                sort: a,
                 as: u,
                 offset: o
             }), t
         }
     }
-    class Xc extends it {
+    class Lc extends nt {
         clone() {
-            return new Xc(null, Ce(this.transform))
+            return new Lc(null, ke(this.transform))
         }
         constructor(t, n) {
             super(t), this.transform = n
         }
         addDimensions(t) {
-            this.transform.groupby = Gr(this.transform.groupby.concat(t), n => n)
+            this.transform.groupby = Pr(this.transform.groupby.concat(t), n => n)
         }
         dependentFields() {
-            var t, n;
-            const i = new Set;
-            return ((t = this.transform.groupby) !== null && t !== void 0 ? t : []).forEach(i.add, i), ((n = this.transform.sort) !== null && n !== void 0 ? n : []).forEach(r => i.add(r.field)), this.transform.window.map(r => r.field).filter(r => r !== void 0).forEach(i.add, i), i
+            const t = new Set;
+            return (this.transform.groupby ?? []).forEach(t.add, t), (this.transform.sort ?? []).forEach(n => t.add(n.field)), this.transform.window.map(n => n.field).filter(n => n !== void 0).forEach(t.add, t), t
         }
         producedFields() {
             return new Set(this.transform.window.map(this.getDefaultName))
         }
         getDefaultName(t) {
-            var n;
-            return (n = t.as) !== null && n !== void 0 ? n : ne(t)
+            return t.as ?? ie(t)
         }
         hash() {
-            return `WindowTransform ${Ie(this.transform)}`
+            return `WindowTransform ${Ne(this.transform)}`
         }
         assemble() {
-            var t;
-            const n = [],
+            const t = [],
+                n = [],
                 i = [],
-                r = [],
-                a = [];
-            for (const h of this.transform.window) i.push(h.op), r.push(this.getDefaultName(h)), a.push(h.param === void 0 ? null : h.param), n.push(h.field === void 0 ? null : h.field);
+                r = [];
+            for (const f of this.transform.window) n.push(f.op), i.push(this.getDefaultName(f)), r.push(f.param === void 0 ? null : f.param), t.push(f.field === void 0 ? null : f.field);
             const s = this.transform.frame,
-                o = this.transform.groupby;
-            if (s && s[0] === null && s[1] === null && i.every(h => cO(h))) return Object.assign({
+                a = this.transform.groupby;
+            if (s && s[0] === null && s[1] === null && n.every(f => OE(f))) return {
                 type: "joinaggregate",
-                as: r,
-                ops: i,
-                fields: n
-            }, o !== void 0 ? {
-                groupby: o
-            } : {});
-            const l = [],
-                u = [];
+                as: i,
+                ops: n,
+                fields: t,
+                ...a !== void 0 ? {
+                    groupby: a
+                } : {}
+            };
+            const o = [],
+                l = [];
             if (this.transform.sort !== void 0)
-                for (const h of this.transform.sort) l.push(h.field), u.push((t = h.order) !== null && t !== void 0 ? t : "ascending");
-            const c = {
-                    field: l,
-                    order: u
+                for (const f of this.transform.sort) o.push(f.field), l.push(f.order ?? "ascending");
+            const u = {
+                    field: o,
+                    order: l
                 },
-                f = this.transform.ignorePeers;
-            return Object.assign(Object.assign(Object.assign({
+                c = this.transform.ignorePeers;
+            return {
                 type: "window",
-                params: a,
-                as: r,
-                ops: i,
-                fields: n,
-                sort: c
-            }, f !== void 0 ? {
-                ignorePeers: f
-            } : {}), o !== void 0 ? {
-                groupby: o
-            } : {}), s !== void 0 ? {
-                frame: s
-            } : {})
+                params: r,
+                as: i,
+                ops: n,
+                fields: t,
+                sort: u,
+                ...c !== void 0 ? {
+                    ignorePeers: c
+                } : {},
+                ...a !== void 0 ? {
+                    groupby: a
+                } : {},
+                ...s !== void 0 ? {
+                    frame: s
+                } : {}
+            }
         }
     }
 
-    function Wme(e) {
+    function G0e(e) {
         function t(n) {
-            if (!(n instanceof Yc)) {
+            if (!(n instanceof Pc)) {
                 const i = n.clone();
-                if (i instanceof Ln) {
-                    const r = Bx + i.getSource();
+                if (i instanceof Dn) {
+                    const r = cx + i.getSource();
                     i.setSource(r), e.model.component.data.outputNodes[r] = i
-                } else(i instanceof pr || i instanceof Wa || i instanceof Xc || i instanceof Jl) && i.addDimensions(e.fields);
+                } else(i instanceof or || i instanceof Ps || i instanceof Lc || i instanceof Bl) && i.addDimensions(e.fields);
                 for (const r of n.children.flatMap(t)) r.parent = i;
                 return [i]
             }
             return n.children.flatMap(t)
         }
         return t
     }
 
-    function zx(e) {
-        if (e instanceof Yc)
-            if (e.numChildren() === 1 && !(e.children[0] instanceof Ln)) {
+    function ux(e) {
+        if (e instanceof Pc)
+            if (e.numChildren() === 1 && !(e.children[0] instanceof Dn)) {
                 const t = e.children[0];
-                (t instanceof pr || t instanceof Wa || t instanceof Xc || t instanceof Jl) && t.addDimensions(e.fields), t.swapWithParent(), zx(e)
+                (t instanceof or || t instanceof Ps || t instanceof Lc || t instanceof Bl) && t.addDimensions(e.fields), t.swapWithParent(), ux(e)
             } else {
                 const t = e.model.component.data.main;
-                Xz(t);
-                const n = Wme(e),
+                u8(t);
+                const n = G0e(e),
                     i = e.children.map(n).flat();
                 for (const r of i) r.parent = t
             }
-        else e.children.map(zx)
+        else e.children.map(ux)
     }
 
-    function Xz(e) {
-        if (e instanceof Ln && e.type === st.Main && e.numChildren() === 1) {
+    function u8(e) {
+        if (e instanceof Dn && e.type === st.Main && e.numChildren() === 1) {
             const t = e.children[0];
-            t instanceof Yc || (t.swapWithParent(), Xz(e))
+            t instanceof Pc || (t.swapWithParent(), u8(e))
         }
     }
-    const Bx = "scale_",
-        Yg = 5;
+    const cx = "scale_",
+        Og = 5;
 
-    function Gx(e) {
+    function fx(e) {
         for (const t of e) {
             for (const n of t.children)
                 if (n.parent !== t) return !1;
-            if (!Gx(t.children)) return !1
+            if (!fx(t.children)) return !1
         }
         return !0
     }
 
-    function Xi(e, t) {
+    function ji(e, t) {
         let n = !1;
         for (const i of t) n = e.optimize(i) || n;
         return n
     }
 
-    function r5(e, t, n) {
+    function v3(e, t, n) {
         let i = e.sources,
             r = !1;
-        return r = Xi(new Pme, i) || r, r = Xi(new Dme(t), i) || r, i = i.filter(a => a.numChildren() > 0), r = Xi(new Ime, i) || r, i = i.filter(a => a.numChildren() > 0), n || (r = Xi(new Nme, i) || r, r = Xi(new Bme(t), i) || r, r = Xi(new Rme, i) || r, r = Xi(new Lme, i) || r, r = Xi(new zme, i) || r, r = Xi(new jme, i) || r, r = Xi(new Fme, i) || r, r = Xi(new Gme, i) || r), e.sources = i, r
+        return r = ji(new R0e, i) || r, r = ji(new O0e(t), i) || r, i = i.filter(s => s.numChildren() > 0), r = ji(new P0e, i) || r, i = i.filter(s => s.numChildren() > 0), n || (r = ji(new D0e, i) || r, r = ji(new z0e(t), i) || r, r = ji(new F0e, i) || r, r = ji(new N0e, i) || r, r = ji(new I0e, i) || r, r = ji(new L0e, i) || r, r = ji(new M0e, i) || r, r = ji(new B0e, i) || r), e.sources = i, r
     }
 
-    function Hme(e, t) {
-        Gx(e.sources);
+    function W0e(e, t) {
+        fx(e.sources);
         let n = 0,
             i = 0;
-        for (let r = 0; r < Yg && r5(e, t, !0); r++) n++;
-        e.sources.map(zx);
-        for (let r = 0; r < Yg && r5(e, t, !1); r++) i++;
-        Gx(e.sources), Math.max(n, i) === Yg && X(`Maximum optimization runs(${Yg}) reached.`)
+        for (let r = 0; r < Og && v3(e, t, !0); r++) n++;
+        e.sources.map(ux);
+        for (let r = 0; r < Og && v3(e, t, !1); r++) i++;
+        fx(e.sources), Math.max(n, i) === Og && X(`Maximum optimization runs(${Og}) reached.`)
     }
-    class ti {
+    class Zn {
         constructor(t) {
             Object.defineProperty(this, "signal", {
                 enumerable: !0,
                 get: t
             })
         }
         static fromName(t, n) {
-            return new ti(() => t(n))
+            return new Zn(() => t(n))
         }
     }
-    var Yme = globalThis && globalThis.__rest || function(e, t) {
-        var n = {};
-        for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && t.indexOf(i) < 0 && (n[i] = e[i]);
-        if (e != null && typeof Object.getOwnPropertySymbols == "function")
-            for (var r = 0, i = Object.getOwnPropertySymbols(e); r < i.length; r++) t.indexOf(i[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, i[r]) && (n[i[r]] = e[i[r]]);
-        return n
-    };
 
-    function Vz(e) {
-        kt(e) ? Xme(e) : Vme(e)
+    function c8(e) {
+        Et(e) ? q0e(e) : H0e(e)
     }
 
-    function Xme(e) {
+    function q0e(e) {
         const t = e.component.scales;
-        for (const n of Y(t)) {
-            const i = Jme(e, n);
-            if (t[n].setWithExplicit("domains", i), Zme(e, n), e.component.data.isFaceted) {
-                let a = e;
-                for (; !mr(a) && a.parent;) a = a.parent;
-                if (a.component.resolve.scale[n] === "shared")
-                    for (const o of i.value) Ia(o) && (o.data = Bx + o.data.replace(Bx, ""))
+        for (const n of H(t)) {
+            const i = X0e(e, n);
+            if (t[n].setWithExplicit("domains", i), K0e(e, n), e.component.data.isFaceted) {
+                let s = e;
+                for (; !lr(s) && s.parent;) s = s.parent;
+                if (s.component.resolve.scale[n] === "shared")
+                    for (const o of i.value) $s(o) && (o.data = cx + o.data.replace(cx, ""))
             }
         }
     }
 
-    function Vme(e) {
-        for (const n of e.children) Vz(n);
+    function H0e(e) {
+        for (const n of e.children) c8(n);
         const t = e.component.scales;
-        for (const n of Y(t)) {
+        for (const n of H(t)) {
             let i, r = null;
-            for (const a of e.children) {
-                const s = a.component.scales[n];
-                if (s) {
-                    i === void 0 ? i = s.getWithExplicit("domains") : i = Qs(i, s.getWithExplicit("domains"), "domains", "scale", Ux);
-                    const o = s.get("selectionExtent");
-                    r && o && r.param !== o.param && X(Gfe), r = o
+            for (const s of e.children) {
+                const a = s.component.scales[n];
+                if (a) {
+                    i === void 0 ? i = a.getWithExplicit("domains") : i = Ua(i, a.getWithExplicit("domains"), "domains", "scale", hx);
+                    const o = a.get("selectionExtent");
+                    r && o && r.param !== o.param && X(Xce), r = o
                 }
             }
             t[n].setWithExplicit("domains", i), r && t[n].set("selectionExtent", r, !0)
         }
     }
 
-    function Kme(e, t, n, i) {
+    function Y0e(e, t, n, i) {
         if (e === "unaggregated") {
             const {
                 valid: r,
-                reason: a
-            } = a5(t, n);
+                reason: s
+            } = b3(t, n);
             if (!r) {
-                X(a);
+                X(s);
                 return
             }
         } else if (e === void 0 && i.useUnaggregatedDomain) {
             const {
                 valid: r
-            } = a5(t, n);
+            } = b3(t, n);
             if (r) return "unaggregated"
         }
         return e
     }
 
-    function Jme(e, t) {
+    function X0e(e, t) {
         const n = e.getScaleComponent(t).get("type"),
             {
                 encoding: i
             } = e,
-            r = Kme(e.scaleDomain(t), e.typedFieldDef(t), n, e.config.scale);
-        return r !== e.scaleDomain(t) && (e.specifiedScales[t] = Object.assign(Object.assign({}, e.specifiedScales[t]), {
+            r = Y0e(e.scaleDomain(t), e.typedFieldDef(t), n, e.config.scale);
+        return r !== e.scaleDomain(t) && (e.specifiedScales[t] = {
+            ...e.specifiedScales[t],
             domain: r
-        })), t === "x" && Rt(i.x2) ? Rt(i.x) ? Qs(ps(n, r, e, "x"), ps(n, r, e, "x2"), "domain", "scale", Ux) : ps(n, r, e, "x2") : t === "y" && Rt(i.y2) ? Rt(i.y) ? Qs(ps(n, r, e, "y"), ps(n, r, e, "y2"), "domain", "scale", Ux) : ps(n, r, e, "y2") : ps(n, r, e, t)
+        }), t === "x" && Mt(i.x2) ? Mt(i.x) ? Ua(sa(n, r, e, "x"), sa(n, r, e, "x2"), "domain", "scale", hx) : sa(n, r, e, "x2") : t === "y" && Mt(i.y2) ? Mt(i.y) ? Ua(sa(n, r, e, "y"), sa(n, r, e, "y2"), "domain", "scale", hx) : sa(n, r, e, "y2") : sa(n, r, e, t)
     }
 
-    function Qme(e, t, n) {
+    function V0e(e, t, n) {
         return e.map(i => ({
-            signal: `{data: ${ry(i,{timeUnit:n,type:t})}}`
+            signal: `{data: ${B1(i,{timeUnit:n,type:t})}}`
         }))
     }
 
-    function eb(e, t, n) {
-        var i;
-        const r = (i = En(n)) === null || i === void 0 ? void 0 : i.unit;
-        return t === "temporal" || r ? Qme(e, t, r) : [e]
+    function Fv(e, t, n) {
+        var r;
+        const i = (r = en(n)) == null ? void 0 : r.unit;
+        return t === "temporal" || i ? V0e(e, t, i) : [e]
     }
 
-    function ps(e, t, n, i) {
+    function sa(e, t, n, i) {
         const {
             encoding: r
-        } = n, a = Rt(r[i]), {
-            type: s
-        } = a, o = a.timeUnit;
-        if (dde(t)) {
-            const f = ps(e, void 0, n, i),
-                h = eb(t.unionWith, s, o);
-            return Pr([...h, ...f.value])
+        } = n, s = Mt(r[i]), {
+            type: a
+        } = s, o = s.timeUnit;
+        if (vhe(t)) {
+            const f = sa(e, void 0, n, i),
+                h = Fv(t.unionWith, a, o);
+            return Mr([...h, ...f.value])
         } else {
-            if (fe(t)) return Pr([t]);
-            if (t && t !== "unaggregated" && !Xj(t)) return Pr(eb(t, s, o))
+            if (he(t)) return Mr([t]);
+            if (t && t !== "unaggregated" && !u6(t)) return Mr(Fv(t, a, o))
         }
         const l = n.stack;
         if (l && i === l.fieldChannel) {
-            if (l.offset === "normalize") return hi([
+            if (l.offset === "normalize") return ci([
                 [0, 1]
             ]);
             const f = n.requestDataName(st.Main);
-            return hi([{
+            return ci([{
                 data: f,
                 field: n.vgField(i, {
                     suffix: "start"
                 })
             }, {
                 data: f,
                 field: n.vgField(i, {
                     suffix: "end"
                 })
             }])
         }
-        const u = bo(i) && J(a) ? e1e(n, i, e) : void 0;
-        if (_a(a)) {
-            const f = eb([a.datum], s, o);
-            return hi(f)
+        const u = Qs(i) && K(s) ? J0e(n, i, e) : void 0;
+        if (fs(s)) {
+            const f = Fv([s.datum], a, o);
+            return ci(f)
         }
-        const c = a;
+        const c = s;
         if (t === "unaggregated") {
             const f = n.requestDataName(st.Main),
                 {
                     field: h
-                } = a;
-            return hi([{
+                } = s;
+            return ci([{
                 data: f,
-                field: ne({
+                field: ie({
                     field: h,
                     aggregate: "min"
                 })
             }, {
                 data: f,
-                field: ne({
+                field: ie({
                     field: h,
                     aggregate: "max"
                 })
             }])
-        } else if (lt(c.bin)) {
-            if (Vt(e)) return hi(e === "bin-ordinal" ? [] : [{
-                data: Kh(u) ? n.requestDataName(st.Main) : n.requestDataName(st.Raw),
-                field: n.vgField(i, Kd(c, i) ? {
+        } else if (ot(c.bin)) {
+            if (qt(e)) return ci(e === "bin-ordinal" ? [] : [{
+                data: Ih(u) ? n.requestDataName(st.Main) : n.requestDataName(st.Raw),
+                field: n.vgField(i, Nd(c, i) ? {
                     binSuffix: "range"
                 } : {}),
-                sort: u === !0 || !se(u) ? {
+                sort: u === !0 || !ae(u) ? {
                     field: n.vgField(i, {}),
                     op: "min"
                 } : u
             }]); {
                 const {
                     bin: f
                 } = c;
-                if (lt(f)) {
-                    const h = uC(n, c.field, f);
-                    return hi([new ti(() => {
+                if (ot(f)) {
+                    const h = $C(n, c.field, f);
+                    return ci([new Zn(() => {
                         const d = n.getSignalName(h);
                         return `[${d}.start, ${d}.stop]`
                     })])
-                } else return hi([{
+                } else return ci([{
                     data: n.requestDataName(st.Main),
                     field: n.vgField(i, {})
                 }])
             }
-        } else if (c.timeUnit && Pe(["time", "utc"], e) && f6(c, kt(n) ? n.encoding[ba(i)] : void 0, n.markDef, n.config)) {
+        } else if (c.timeUnit && Fe(["time", "utc"], e) && k6(c, Et(n) ? n.encoding[us(i)] : void 0, n.markDef, n.config)) {
             const f = n.requestDataName(st.Main);
-            return hi([{
+            return ci([{
                 data: f,
                 field: n.vgField(i)
             }, {
                 data: f,
                 field: n.vgField(i, {
                     suffix: "end"
                 })
             }])
-        } else return hi(u ? [{
-            data: Kh(u) ? n.requestDataName(st.Main) : n.requestDataName(st.Raw),
+        } else return ci(u ? [{
+            data: Ih(u) ? n.requestDataName(st.Main) : n.requestDataName(st.Raw),
             field: n.vgField(i),
             sort: u
         }] : [{
             data: n.requestDataName(st.Main),
             field: n.vgField(i)
         }])
     }
 
-    function tb(e, t) {
+    function Rv(e, t) {
         const {
             op: n,
             field: i,
             order: r
         } = e;
-        return Object.assign(Object.assign({
-            op: n ?? (t ? "sum" : Z1)
-        }, i ? {
-            field: Bi(i)
-        } : {}), r ? {
-            order: r
-        } : {})
+        return {
+            op: n ?? (t ? "sum" : N1),
+            ...i ? {
+                field: Pi(i)
+            } : {},
+            ...r ? {
+                order: r
+            } : {}
+        }
     }
 
-    function Zme(e, t) {
-        var n;
-        const i = e.component.scales[t],
-            r = e.specifiedScales[t].domain,
-            a = (n = e.fieldDef(t)) === null || n === void 0 ? void 0 : n.bin,
-            s = Xj(r) && r,
-            o = Yl(a) && Y1(a.extent) && a.extent;
-        (s || o) && i.set("selectionExtent", s ?? o, !0)
+    function K0e(e, t) {
+        var o;
+        const n = e.component.scales[t],
+            i = e.specifiedScales[t].domain,
+            r = (o = e.fieldDef(t)) == null ? void 0 : o.bin,
+            s = u6(i) && i,
+            a = Pl(r) && $1(r.extent) && r.extent;
+        (s || a) && n.set("selectionExtent", s ?? a, !0)
     }
 
-    function e1e(e, t, n) {
-        if (!Vt(n)) return;
+    function J0e(e, t, n) {
+        if (!qt(n)) return;
         const i = e.fieldDef(t),
             r = i.sort;
-        if (l6(r)) return {
+        if (S6(r)) return {
             op: "min",
-            field: xc(i, t),
+            field: uc(i, t),
             order: "ascending"
         };
         const {
-            stack: a
-        } = e, s = a ? new Set([...a.groupbyFields, ...a.stackBy.map(o => o.fieldDef.field)]) : void 0;
-        if (Yr(r)) {
-            const o = a && !s.has(r.field);
-            return tb(r, o)
-        } else if (o6(r)) {
+            stack: s
+        } = e, a = s ? new Set([...s.groupbyFields, ...s.stackBy.map(o => o.fieldDef.field)]) : void 0;
+        if (Br(r)) {
+            const o = s && !a.has(r.field);
+            return Rv(r, o)
+        } else if (w6(r)) {
             const {
                 encoding: o,
                 order: l
             } = r, u = e.fieldDef(o), {
                 aggregate: c,
                 field: f
-            } = u, h = a && !s.has(f);
-            if (Va(c) || xo(c)) return tb({
-                field: ne(u),
+            } = u, h = s && !a.has(f);
+            if (Bs(c) || oo(c)) return Rv({
+                field: ie(u),
                 order: l
             }, h);
-            if (cO(c) || !c) return tb({
+            if (OE(c) || !c) return Rv({
                 op: c,
                 field: f,
                 order: l
             }, h)
         } else {
             if (r === "descending") return {
                 op: "min",
                 field: e.vgField(t),
                 order: "descending"
             };
-            if (Pe(["ascending", void 0], r)) return !0
+            if (Fe(["ascending", void 0], r)) return !0
         }
     }
 
-    function a5(e, t) {
+    function b3(e, t) {
         const {
             aggregate: n,
             type: i
         } = e;
-        return n ? re(n) && !Ofe.has(n) ? {
+        return n ? re(n) && !Fce.has(n) ? {
             valid: !1,
-            reason: mhe(n)
+            reason: wfe(n)
         } : i === "quantitative" && t === "log" ? {
             valid: !1,
-            reason: yhe(e)
+            reason: Sfe(e)
         } : {
             valid: !0
         } : {
             valid: !1,
-            reason: phe(e)
+            reason: _fe(e)
         }
     }
 
-    function Ux(e, t, n, i) {
-        return e.explicit && t.explicit && X(whe(n, i, e.value, t.value)), {
+    function hx(e, t, n, i) {
+        return e.explicit && t.explicit && X($fe(n, i, e.value, t.value)), {
             explicit: e.explicit,
             value: [...e.value, ...t.value]
         }
     }
 
-    function t1e(e) {
-        const t = Gr(e.map(s => Ia(s) ? Yme(s, ["sort"]) : s), Ie),
-            n = Gr(e.map(s => {
-                if (Ia(s)) {
-                    const o = s.sort;
-                    return o !== void 0 && !Kh(o) && ("op" in o && o.op === "count" && delete o.field, o.order === "ascending" && delete o.order), o
+    function Q0e(e) {
+        const t = Pr(e.map(a => {
+                if ($s(a)) {
+                    const {
+                        sort: o,
+                        ...l
+                    } = a;
+                    return l
                 }
-            }).filter(s => s !== void 0), Ie);
+                return a
+            }), Ne),
+            n = Pr(e.map(a => {
+                if ($s(a)) {
+                    const o = a.sort;
+                    return o !== void 0 && !Ih(o) && ("op" in o && o.op === "count" && delete o.field, o.order === "ascending" && delete o.order), o
+                }
+            }).filter(a => a !== void 0), Ne);
         if (t.length === 0) return;
         if (t.length === 1) {
-            const s = e[0];
-            if (Ia(s) && n.length > 0) {
+            const a = e[0];
+            if ($s(a) && n.length > 0) {
                 let o = n[0];
-                if (n.length > 1) X(v$), o = !0;
-                else if (se(o) && "field" in o) {
+                if (n.length > 1) {
+                    X(F5);
+                    const l = n.filter(u => ae(u) && "op" in u && u.op !== "min");
+                    n.every(u => ae(u) && "op" in u) && l.length === 1 ? o = l[0] : o = !0
+                } else if (ae(o) && "field" in o) {
                     const l = o.field;
-                    s.field === l && (o = o.order ? {
+                    a.field === l && (o = o.order ? {
                         order: o.order
                     } : !0)
                 }
-                return Object.assign(Object.assign({}, s), {
+                return {
+                    ...a,
                     sort: o
-                })
+                }
             }
-            return s
+            return a
         }
-        const i = Gr(n.map(s => Kh(s) || !("op" in s) || re(s.op) && s.op in _fe ? s : (X(Ehe(s)), !0)), Ie);
+        const i = Pr(n.map(a => Ih(a) || !("op" in a) || re(a.op) && a.op in $ce ? a : (X(Mfe(a)), !0)), Ne);
         let r;
-        i.length === 1 ? r = i[0] : i.length > 1 && (X(v$), r = !0);
-        const a = Gr(e.map(s => Ia(s) ? s.data : null), s => s);
-        return a.length === 1 && a[0] !== null ? Object.assign({
-            data: a[0],
-            fields: t.map(o => o.field)
-        }, r ? {
-            sort: r
-        } : {}) : Object.assign({
-            fields: t
-        }, r ? {
-            sort: r
-        } : {})
+        i.length === 1 ? r = i[0] : i.length > 1 && (X(F5), r = !0);
+        const s = Pr(e.map(a => $s(a) ? a.data : null), a => a);
+        return s.length === 1 && s[0] !== null ? {
+            data: s[0],
+            fields: t.map(o => o.field),
+            ...r ? {
+                sort: r
+            } : {}
+        } : {
+            fields: t,
+            ...r ? {
+                sort: r
+            } : {}
+        }
     }
 
-    function dC(e) {
-        if (Ia(e) && re(e.field)) return e.field;
-        if (kfe(e)) {
+    function FC(e) {
+        if ($s(e) && re(e.field)) return e.field;
+        if (Rce(e)) {
             let t;
             for (const n of e.fields)
-                if (Ia(n) && re(n.field)) {
+                if ($s(n) && re(n.field)) {
                     if (!t) t = n.field;
-                    else if (t !== n.field) return X(Ohe), t
-                } return X(Che), t
-        } else if (Afe(e)) {
-            X(khe);
+                    else if (t !== n.field) return X(Ofe), t
+                } return X(Ffe), t
+        } else if (Dce(e)) {
+            X(Rfe);
             const t = e.fields[0];
             return re(t) ? t : void 0
         }
     }
 
-    function gy(e, t) {
-        const i = e.component.scales[t].get("domains").map(r => (Ia(r) && (r.data = e.lookupDataSource(r.data)), r));
-        return t1e(i)
-    }
-    var n1e = globalThis && globalThis.__rest || function(e, t) {
-        var n = {};
-        for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && t.indexOf(i) < 0 && (n[i] = e[i]);
-        if (e != null && typeof Object.getOwnPropertySymbols == "function")
-            for (var r = 0, i = Object.getOwnPropertySymbols(e); r < i.length; r++) t.indexOf(i[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, i[r]) && (n[i[r]] = e[i[r]]);
-        return n
-    };
+    function K1(e, t) {
+        const i = e.component.scales[t].get("domains").map(r => ($s(r) && (r.data = e.lookupDataSource(r.data)), r));
+        return Q0e(i)
+    }
 
-    function Kz(e) {
-        return Vc(e) || gC(e) ? e.children.reduce((t, n) => t.concat(Kz(n)), s5(e)) : s5(e)
+    function f8(e) {
+        return Ic(e) || RC(e) ? e.children.reduce((t, n) => t.concat(f8(n)), x3(e)) : x3(e)
     }
 
-    function s5(e) {
-        return Y(e.component.scales).reduce((t, n) => {
+    function x3(e) {
+        return H(e.component.scales).reduce((t, n) => {
             const i = e.component.scales[n];
             if (i.merged) return t;
             const r = i.combine(),
                 {
-                    name: a,
-                    type: s,
+                    name: s,
+                    type: a,
                     selectionExtent: o,
                     domains: l,
                     range: u,
-                    reverse: c
+                    reverse: c,
+                    ...f
                 } = r,
-                f = n1e(r, ["name", "type", "selectionExtent", "domains", "range", "reverse"]),
-                h = i1e(r.range, a, n, e),
-                d = gy(e, n),
-                g = o ? Ype(e, o, i, d) : null;
-            return t.push(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({
-                name: a,
-                type: s
-            }, d ? {
-                domain: d
-            } : {}), g ? {
-                domainRaw: g
-            } : {}), {
-                range: h
-            }), c !== void 0 ? {
-                reverse: c
-            } : {}), f)), t
+                h = Z0e(r.range, s, n, e),
+                d = K1(e, n),
+                g = o ? Yge(e, o, i, d) : null;
+            return t.push({
+                name: s,
+                type: a,
+                ...d ? {
+                    domain: d
+                } : {},
+                ...g ? {
+                    domainRaw: g
+                } : {},
+                range: h,
+                ...c !== void 0 ? {
+                    reverse: c
+                } : {},
+                ...f
+            }), t
         }, [])
     }
 
-    function i1e(e, t, n, i) {
-        if (Xt(n)) {
-            if (_o(e)) return {
+    function Z0e(e, t, n, i) {
+        if (Wt(n)) {
+            if (lo(e)) return {
                 step: {
                     signal: `${t}_step`
                 }
             }
-        } else if (se(e) && Ia(e)) return Object.assign(Object.assign({}, e), {
+        } else if (ae(e) && $s(e)) return {
+            ...e,
             data: i.lookupDataSource(e.data)
-        });
+        };
         return e
     }
-    class Jz extends ls {
+    class h8 extends ea {
         constructor(t, n) {
             super({}, {
                 name: t
             }), this.merged = !1, this.setWithExplicit("type", n)
         }
         domainDefinitelyIncludesZero() {
-            return this.get("zero") !== !1 ? !0 : bl(this.get("domains"), t => q(t) && t.length === 2 && t[0] <= 0 && t[1] >= 0)
+            return this.get("zero") !== !1 ? !0 : ol(this.get("domains"), t => W(t) && t.length === 2 && t[0] <= 0 && t[1] >= 0)
         }
     }
-    const r1e = ["range", "scheme"];
+    const eme = ["range", "scheme"];
 
-    function a1e(e) {
+    function tme(e) {
         const t = e.component.scales;
-        for (const n of H1) {
+        for (const n of A1) {
             const i = t[n];
             if (!i) continue;
-            const r = s1e(n, e);
+            const r = nme(n, e);
             i.setWithExplicit("range", r)
         }
     }
 
-    function o5(e, t) {
+    function _3(e, t) {
         const n = e.fieldDef(t);
         if (n != null && n.bin) {
             const {
                 bin: i,
                 field: r
-            } = n, a = ui(t), s = e.getName(a);
-            if (se(i) && i.binned && i.step !== void 0) return new ti(() => {
+            } = n, s = oi(t), a = e.getName(s);
+            if (ae(i) && i.binned && i.step !== void 0) return new Zn(() => {
                 const o = e.scaleName(t),
                     l = `(domain("${o}")[1] - domain("${o}")[0]) / ${i.step}`;
-                return `${e.getSignalName(s)} / (${l})`
+                return `${e.getSignalName(a)} / (${l})`
             });
-            if (lt(i)) {
-                const o = uC(e, r, i);
-                return new ti(() => {
+            if (ot(i)) {
+                const o = $C(e, r, i);
+                return new Zn(() => {
                     const l = e.getSignalName(o),
                         u = `(${l}.stop - ${l}.start) / ${l}.step`;
-                    return `${e.getSignalName(s)} / (${u})`
+                    return `${e.getSignalName(a)} / (${u})`
                 })
             }
         }
     }
 
-    function s1e(e, t) {
+    function nme(e, t) {
         const n = t.specifiedScales[e],
             {
                 size: i
             } = t,
-            a = t.getScaleComponent(e).get("type");
-        for (const f of r1e)
+            s = t.getScaleComponent(e).get("type");
+        for (const f of eme)
             if (n[f] !== void 0) {
-                const h = wx(a, f),
-                    d = Vj(e, f);
-                if (!h) X(Fj(a, f, e));
+                const h = V2(s, f),
+                    d = c6(e, f);
+                if (!h) X(HI(s, f, e));
                 else if (d) X(d);
                 else switch (f) {
                     case "range": {
                         const g = n.range;
-                        if (q(g)) {
-                            if (Xt(e)) return Pr(g.map(p => {
+                        if (W(g)) {
+                            if (Wt(e)) return Mr(g.map(p => {
                                 if (p === "width" || p === "height") {
                                     const m = t.getName(p),
                                         y = t.getSignalName.bind(t);
-                                    return ti.fromName(y, m)
+                                    return Zn.fromName(y, m)
                                 }
                                 return p
                             }))
-                        } else if (se(g)) return Pr({
+                        } else if (ae(g)) return Mr({
                             data: t.requestDataName(st.Main),
                             field: g.field,
                             sort: {
                                 op: "min",
                                 field: t.vgField(e)
                             }
                         });
-                        return Pr(g)
+                        return Mr(g)
                     }
                     case "scheme":
-                        return Pr(o1e(n[f]))
+                        return Mr(ime(n[f]))
                 }
-            } const s = e === yt || e === "xOffset" ? "width" : "height",
-            o = i[s];
-        if (aa(o)) {
-            if (Xt(e))
-                if (Vt(a)) {
-                    const f = Qz(o, t, e);
-                    if (f) return Pr({
+            } const a = e === ht || e === "xOffset" ? "width" : "height",
+            o = i[a];
+        if (Jr(o)) {
+            if (Wt(e))
+                if (qt(s)) {
+                    const f = d8(o, t, e);
+                    if (f) return Mr({
                         step: f
                     })
-                } else X(Dj(s));
-            else if (Uc(e)) {
-                const f = e === go ? "x" : "y";
+                } else X(YI(a));
+            else if (Oc(e)) {
+                const f = e === no ? "x" : "y";
                 if (t.getScaleComponent(f).get("type") === "band") {
-                    const g = Zz(o, a);
-                    if (g) return Pr(g)
+                    const g = g8(o, s);
+                    if (g) return Mr(g)
                 }
             }
         }
         const {
             rangeMin: l,
             rangeMax: u
-        } = n, c = l1e(e, t);
-        return (l !== void 0 || u !== void 0) && wx(a, "rangeMin") && q(c) && c.length === 2 ? Pr([l ?? c[0], u ?? c[1]]) : hi(c)
+        } = n, c = rme(e, t);
+        return (l !== void 0 || u !== void 0) && V2(s, "rangeMin") && W(c) && c.length === 2 ? Mr([l ?? c[0], u ?? c[1]]) : ci(c)
     }
 
-    function o1e(e) {
-        return hde(e) ? Object.assign({
-            scheme: e.name
-        }, Zn(e, ["name"])) : {
+    function ime(e) {
+        return yhe(e) ? {
+            scheme: e.name,
+            ...Jn(e, ["name"])
+        } : {
             scheme: e
         }
     }
 
-    function l1e(e, t) {
+    function rme(e, t) {
         const {
             size: n,
             config: i,
             mark: r,
-            encoding: a
-        } = t, s = t.getSignalName.bind(t), {
+            encoding: s
+        } = t, a = t.getSignalName.bind(t), {
             type: o
-        } = Rt(a[e]), u = t.getScaleComponent(e).get("type"), {
+        } = Mt(s[e]), u = t.getScaleComponent(e).get("type"), {
             domain: c,
             domainMid: f
         } = t.specifiedScales[e];
         switch (e) {
-            case yt:
-            case Yt: {
-                if (Pe(["point", "band"], u)) {
-                    const g = e8(e, n, i.view);
-                    if (aa(g)) return {
-                        step: Qz(g, t, e)
+            case ht:
+            case Gt: {
+                if (Fe(["point", "band"], u)) {
+                    const g = p8(e, n, i.view);
+                    if (Jr(g)) return {
+                        step: d8(g, t, e)
                     }
                 }
-                const h = ui(e),
+                const h = oi(e),
                     d = t.getName(h);
-                return e === Yt && Ei(u) ? [ti.fromName(s, d), 0] : [0, ti.fromName(s, d)]
+                return e === Gt && wi(u) ? [Zn.fromName(a, d), 0] : [0, Zn.fromName(a, d)]
             }
-            case go:
-            case Gc:
-                return u1e(e, t, u);
-            case as: {
+            case no:
+            case Mc:
+                return sme(e, t, u);
+            case Ks: {
                 const h = t.component.scales[e].get("zero"),
-                    d = t8(r, h, i),
-                    g = h1e(r, n, t, i);
-                return dc(u) ? f1e(d, g, c1e(u, i, c, e)) : [d, g]
+                    d = m8(r, h, i),
+                    g = lme(r, n, t, i);
+                return ic(u) ? ome(d, g, ame(u, i, c, e)) : [d, g]
             }
-            case Wi:
+            case zi:
                 return [0, Math.PI * 2];
-            case Wl:
+            case Dl:
                 return [0, 360];
-            case Ar:
-                return [0, new ti(() => {
+            case _r:
+                return [0, new Zn(() => {
                     const h = t.getSignalName("width"),
                         d = t.getSignalName("height");
                     return `min(${h},${d})/2`
                 })];
-            case yo:
+            case so:
                 return [i.scale.minStrokeWidth, i.scale.maxStrokeWidth];
-            case vo:
+            case ao:
                 return [
                     [1, 0],
                     [4, 2],
                     [2, 1],
                     [1, 1],
                     [1, 2, 4, 2]
                 ];
-            case li:
+            case ai:
                 return "symbol";
-            case oi:
-            case ya:
-            case va:
+            case si:
+            case os:
+            case ls:
                 return u === "ordinal" ? o === "nominal" ? "category" : "ordinal" : f !== void 0 ? "diverging" : r === "rect" || r === "geoshape" ? "heatmap" : "ramp";
-            case ss:
-            case po:
-            case mo:
+            case Js:
+            case io:
+            case ro:
                 return [i.scale.minOpacity, i.scale.maxOpacity]
         }
     }
 
-    function Qz(e, t, n) {
-        var i, r, a, s, o;
+    function d8(e, t, n) {
         const {
-            encoding: l
-        } = t, u = t.getScaleComponent(n), c = dj(n), f = l[c];
-        if (B6({
+            encoding: i
+        } = t, r = t.getScaleComponent(n), s = AE(n), a = i[s];
+        if (nz({
                 step: e,
-                offsetIsDiscrete: Ee(f) && Uj(f.type)
-            }) === "offset" && w6(l, c)) {
-            const d = t.getScaleComponent(c);
-            let p = `domain('${t.scaleName(c)}').length`;
-            if (d.get("type") === "band") {
-                const y = (r = (i = d.get("paddingInner")) !== null && i !== void 0 ? i : d.get("padding")) !== null && r !== void 0 ? r : 0,
-                    v = (s = (a = d.get("paddingOuter")) !== null && a !== void 0 ? a : d.get("padding")) !== null && s !== void 0 ? s : 0;
-                p = `bandspace(${p}, ${y}, ${v})`
+                offsetIsDiscrete: Ce(a) && r6(a.type)
+            }) === "offset" && I6(i, s)) {
+            const l = t.getScaleComponent(s);
+            let c = `domain('${t.scaleName(s)}').length`;
+            if (l.get("type") === "band") {
+                const h = l.get("paddingInner") ?? l.get("padding") ?? 0,
+                    d = l.get("paddingOuter") ?? l.get("padding") ?? 0;
+                c = `bandspace(${c}, ${h}, ${d})`
             }
-            const m = (o = u.get("paddingInner")) !== null && o !== void 0 ? o : u.get("padding");
+            const f = r.get("paddingInner") ?? r.get("padding");
             return {
-                signal: `${e.step} * ${p} / (1-${Ffe(m)})`
+                signal: `${e.step} * ${c} / (1-${Ice(f)})`
             }
         } else return e.step
     }
 
-    function Zz(e, t) {
-        if (B6({
+    function g8(e, t) {
+        if (nz({
                 step: e,
-                offsetIsDiscrete: Vt(t)
+                offsetIsDiscrete: qt(t)
             }) === "offset") return {
             step: e.step
         }
     }
 
-    function u1e(e, t, n) {
-        const i = e === go ? "x" : "y",
-            a = t.getScaleComponent(i).get("type"),
-            s = t.scaleName(i);
-        if (a === "band") {
-            const o = e8(i, t.size, t.config.view);
-            if (aa(o)) {
-                const l = Zz(o, n);
+    function sme(e, t, n) {
+        const i = e === no ? "x" : "y",
+            s = t.getScaleComponent(i).get("type"),
+            a = t.scaleName(i);
+        if (s === "band") {
+            const o = p8(i, t.size, t.config.view);
+            if (Jr(o)) {
+                const l = g8(o, n);
                 if (l) return l
             }
             return [0, {
-                signal: `bandwidth('${s}')`
+                signal: `bandwidth('${a}')`
             }]
-        } else return ej(`Cannot use ${e} scale if ${i} scale is not discrete.`)
+        } else {
+            const o = t.encoding[i];
+            if (K(o) && o.timeUnit) {
+                const l = t6(o.timeUnit, c => `scale('${a}', ${c})`),
+                    u = t.config.scale.bandWithNestedOffsetPaddingInner;
+                if (u) {
+                    const c = he(u) ? `${u.signal}/2` : `${u/2}`,
+                        f = he(u) ? `(1 - ${u.signal}/2)` : `${1-u/2}`;
+                    return [{
+                        signal: `${c} * (${l})`
+                    }, {
+                        signal: `${f} * (${l})`
+                    }]
+                }
+                return [0, {
+                    signal: l
+                }]
+            }
+            return hI(`Cannot use ${e} scale if ${i} scale is not discrete.`)
+        }
     }
 
-    function e8(e, t, n) {
-        const i = e === yt ? "width" : "height",
+    function p8(e, t, n) {
+        const i = e === ht ? "width" : "height",
             r = t[i];
-        return r || cm(n, i)
+        return r || H0(n, i)
     }
 
-    function c1e(e, t, n, i) {
+    function ame(e, t, n, i) {
         switch (e) {
             case "quantile":
                 return t.scale.quantileCount;
             case "quantize":
                 return t.scale.quantizeCount;
             case "threshold":
-                return n !== void 0 && q(n) ? n.length + 1 : (X(Nhe(i)), 3)
+                return n !== void 0 && W(n) ? n.length + 1 : (X(Ufe(i)), 3)
         }
     }
 
-    function f1e(e, t, n) {
+    function ome(e, t, n) {
         const i = () => {
-            const r = qa(t),
-                a = qa(e),
-                s = `(${r} - ${a}) / (${n} - 1)`;
-            return `sequence(${a}, ${r} + ${s}, ${s})`
+            const r = Ds(t),
+                s = Ds(e),
+                a = `(${r} - ${s}) / (${n} - 1)`;
+            return `sequence(${s}, ${r} + ${a}, ${a})`
         };
-        return fe(t) ? new ti(i) : {
+        return he(t) ? new Zn(i) : {
             signal: i()
         }
     }
 
-    function t8(e, t, n) {
-        if (t) return fe(t) ? {
-            signal: `${t.signal} ? 0 : ${t8(e,!1,n)}`
+    function m8(e, t, n) {
+        if (t) return he(t) ? {
+            signal: `${t.signal} ? 0 : ${m8(e,!1,n)}`
         } : 0;
         switch (e) {
             case "bar":
             case "tick":
                 return n.scale.minBandSize;
             case "line":
             case "trail":
@@ -47907,397 +48286,390 @@
             case "text":
                 return n.scale.minFontSize;
             case "point":
             case "square":
             case "circle":
                 return n.scale.minSize
         }
-        throw new Error(X1("size", e))
+        throw new Error(T1("size", e))
     }
-    const l5 = .95;
+    const w3 = .95;
 
-    function h1e(e, t, n, i) {
+    function lme(e, t, n, i) {
         const r = {
-            x: o5(n, "x"),
-            y: o5(n, "y")
+            x: _3(n, "x"),
+            y: _3(n, "y")
         };
         switch (e) {
             case "bar":
             case "tick": {
                 if (i.scale.maxBandSize !== void 0) return i.scale.maxBandSize;
-                const a = u5(t, r, i.view);
-                return tt(a) ? a - 1 : new ti(() => `${a.signal} - 1`)
+                const s = S3(t, r, i.view);
+                return Ze(s) ? s - 1 : new Zn(() => `${s.signal} - 1`)
             }
             case "line":
             case "trail":
             case "rule":
                 return i.scale.maxStrokeWidth;
             case "text":
                 return i.scale.maxFontSize;
             case "point":
             case "square":
             case "circle": {
                 if (i.scale.maxSize) return i.scale.maxSize;
-                const a = u5(t, r, i.view);
-                return tt(a) ? Math.pow(l5 * a, 2) : new ti(() => `pow(${l5} * ${a.signal}, 2)`)
+                const s = S3(t, r, i.view);
+                return Ze(s) ? Math.pow(w3 * s, 2) : new Zn(() => `pow(${w3} * ${s.signal}, 2)`)
             }
         }
-        throw new Error(X1("size", e))
+        throw new Error(T1("size", e))
     }
 
-    function u5(e, t, n) {
-        const i = aa(e.width) ? e.width.step : um(n, "width"),
-            r = aa(e.height) ? e.height.step : um(n, "height");
-        return t.x || t.y ? new ti(() => `min(${[t.x?t.x.signal:i,t.y?t.y.signal:r].join(", ")})`) : Math.min(i, r)
+    function S3(e, t, n) {
+        const i = Jr(e.width) ? e.width.step : q0(n, "width"),
+            r = Jr(e.height) ? e.height.step : q0(n, "height");
+        return t.x || t.y ? new Zn(() => `min(${[t.x?t.x.signal:i,t.y?t.y.signal:r].join(", ")})`) : Math.min(i, r)
     }
 
-    function n8(e, t) {
-        kt(e) ? d1e(e, t) : r8(e, t)
+    function y8(e, t) {
+        Et(e) ? ume(e, t) : b8(e, t)
     }
 
-    function d1e(e, t) {
+    function ume(e, t) {
         const n = e.component.scales,
             {
                 config: i,
                 encoding: r,
-                markDef: a,
-                specifiedScales: s
+                markDef: s,
+                specifiedScales: a
             } = e;
-        for (const o of Y(n)) {
-            const l = s[o],
+        for (const o of H(n)) {
+            const l = a[o],
                 u = n[o],
                 c = e.getScaleComponent(o),
-                f = Rt(r[o]),
+                f = Mt(r[o]),
                 h = l[t],
                 d = c.get("type"),
                 g = c.get("padding"),
                 p = c.get("paddingInner"),
-                m = wx(d, t),
-                y = Vj(o, t);
-            if (h !== void 0 && (m ? y && X(y) : X(Fj(d, t, o))), m && y === void 0)
+                m = V2(d, t),
+                y = c6(o, t);
+            if (h !== void 0 && (m ? y && X(y) : X(HI(d, t, o))), m && y === void 0)
                 if (h !== void 0) {
                     const v = f.timeUnit,
                         b = f.type;
                     switch (t) {
                         case "domainMax":
                         case "domainMin":
-                            Xl(l[t]) || b === "temporal" || v ? u.set(t, {
-                                signal: ry(l[t], {
+                            Ll(l[t]) || b === "temporal" || v ? u.set(t, {
+                                signal: B1(l[t], {
                                     type: b,
                                     timeUnit: v
                                 })
                             }, !0) : u.set(t, l[t], !0);
                             break;
                         default:
                             u.copyKeyFromObject(t, l)
                     }
                 } else {
-                    const v = t in c5 ? c5[t]({
+                    const v = t in E3 ? E3[t]({
                         model: e,
                         channel: o,
                         fieldOrDatumDef: f,
                         scaleType: d,
                         scalePadding: g,
                         scalePaddingInner: p,
                         domain: l.domain,
                         domainMin: l.domainMin,
                         domainMax: l.domainMax,
-                        markDef: a,
+                        markDef: s,
                         config: i,
-                        hasNestedOffsetScale: Cx(r, o),
-                        hasSecondaryRangeChannel: !!r[ba(o)]
+                        hasNestedOffsetScale: J2(r, o),
+                        hasSecondaryRangeChannel: !!r[us(o)]
                     }) : i.scale[t];
                     v !== void 0 && u.set(t, v, !1)
                 }
         }
     }
-    const c5 = {
+    const E3 = {
         bins: ({
             model: e,
             fieldOrDatumDef: t
-        }) => J(t) ? g1e(e, t) : void 0,
+        }) => K(t) ? cme(e, t) : void 0,
         interpolate: ({
             channel: e,
             fieldOrDatumDef: t
-        }) => p1e(e, t.type),
+        }) => fme(e, t.type),
         nice: ({
             scaleType: e,
             channel: t,
             domain: n,
             domainMin: i,
             domainMax: r,
-            fieldOrDatumDef: a
-        }) => m1e(e, t, n, i, r, a),
+            fieldOrDatumDef: s
+        }) => hme(e, t, n, i, r, s),
         padding: ({
             channel: e,
             scaleType: t,
             fieldOrDatumDef: n,
             markDef: i,
             config: r
-        }) => y1e(e, t, r.scale, n, i, r.bar),
+        }) => dme(e, t, r.scale, n, i, r.bar),
         paddingInner: ({
             scalePadding: e,
             channel: t,
             markDef: n,
             scaleType: i,
             config: r,
-            hasNestedOffsetScale: a
-        }) => v1e(e, t, n.type, i, r.scale, a),
+            hasNestedOffsetScale: s
+        }) => gme(e, t, n.type, i, r.scale, s),
         paddingOuter: ({
             scalePadding: e,
             channel: t,
             scaleType: n,
             scalePaddingInner: i,
             config: r,
-            hasNestedOffsetScale: a
-        }) => b1e(e, t, n, i, r.scale, a),
+            hasNestedOffsetScale: s
+        }) => pme(e, t, n, i, r.scale, s),
         reverse: ({
             fieldOrDatumDef: e,
             scaleType: t,
             channel: n,
             config: i
         }) => {
-            const r = J(e) ? e.sort : void 0;
-            return x1e(t, r, n, i.scale)
+            const r = K(e) ? e.sort : void 0;
+            return mme(t, r, n, i.scale)
         },
         zero: ({
             channel: e,
             fieldOrDatumDef: t,
             domain: n,
             markDef: i,
             scaleType: r,
-            config: a,
-            hasSecondaryRangeChannel: s
-        }) => _1e(e, t, n, i, r, a.scale, s)
+            config: s,
+            hasSecondaryRangeChannel: a
+        }) => yme(e, t, n, i, r, s.scale, a)
     };
 
-    function i8(e) {
-        kt(e) ? a1e(e) : r8(e, "range")
+    function v8(e) {
+        Et(e) ? tme(e) : b8(e, "range")
     }
 
-    function r8(e, t) {
+    function b8(e, t) {
         const n = e.component.scales;
-        for (const i of e.children) t === "range" ? i8(i) : n8(i, t);
-        for (const i of Y(n)) {
+        for (const i of e.children) t === "range" ? v8(i) : y8(i, t);
+        for (const i of H(n)) {
             let r;
-            for (const a of e.children) {
-                const s = a.component.scales[i];
-                if (s) {
-                    const o = s.getWithExplicit(t);
-                    r = Qs(r, o, t, "scale", tz((l, u) => {
+            for (const s of e.children) {
+                const a = s.component.scales[i];
+                if (a) {
+                    const o = a.getWithExplicit(t);
+                    r = Ua(r, o, t, "scale", gz((l, u) => {
                         switch (t) {
                             case "range":
                                 return l.step && u.step ? l.step - u.step : 0
                         }
                         return 0
                     }))
                 }
             }
             n[i].setWithExplicit(t, r)
         }
     }
 
-    function g1e(e, t) {
+    function cme(e, t) {
         const n = t.bin;
-        if (lt(n)) {
-            const i = uC(e, t.field, n);
-            return new ti(() => e.getSignalName(i))
-        } else if (Qt(n) && Yl(n) && n.step !== void 0) return {
+        if (ot(n)) {
+            const i = $C(e, t.field, n);
+            return new Zn(() => e.getSignalName(i))
+        } else if (Xt(n) && Pl(n) && n.step !== void 0) return {
             step: n.step
         }
     }
 
-    function p1e(e, t) {
-        if (Pe([oi, ya, va], e) && t !== "nominal") return "hcl"
+    function fme(e, t) {
+        if (Fe([si, os, ls], e) && t !== "nominal") return "hcl"
     }
 
-    function m1e(e, t, n, i, r, a) {
-        var s;
-        if (!(!((s = ia(a)) === null || s === void 0) && s.bin || q(n) || r != null || i != null || Pe([ei.TIME, ei.UTC], e))) return Xt(t) ? !0 : void 0
+    function hme(e, t, n, i, r, s) {
+        var a;
+        if (!((a = Kr(s)) != null && a.bin || W(n) || r != null || i != null || Fe([Qn.TIME, Qn.UTC], e))) return Wt(t) ? !0 : void 0
     }
 
-    function y1e(e, t, n, i, r, a) {
-        if (Xt(e)) {
-            if (fr(t)) {
+    function dme(e, t, n, i, r, s) {
+        if (Wt(e)) {
+            if (ir(t)) {
                 if (n.continuousPadding !== void 0) return n.continuousPadding;
                 const {
-                    type: s,
+                    type: a,
                     orient: o
                 } = r;
-                if (s === "bar" && !(J(i) && (i.bin || i.timeUnit)) && (o === "vertical" && e === "x" || o === "horizontal" && e === "y")) return a.continuousBandSize
+                if (a === "bar" && !(K(i) && (i.bin || i.timeUnit)) && (o === "vertical" && e === "x" || o === "horizontal" && e === "y")) return s.continuousBandSize
             }
-            if (t === ei.POINT) return n.pointPadding
+            if (t === Qn.POINT) return n.pointPadding
         }
     }
 
-    function v1e(e, t, n, i, r, a = !1) {
+    function gme(e, t, n, i, r, s = !1) {
         if (e === void 0) {
-            if (Xt(t)) {
+            if (Wt(t)) {
                 const {
-                    bandPaddingInner: s,
+                    bandPaddingInner: a,
                     barBandPaddingInner: o,
                     rectBandPaddingInner: l,
                     bandWithNestedOffsetPaddingInner: u
                 } = r;
-                return a ? u : Tt(s, n === "bar" ? o : l)
-            } else if (Uc(t) && i === ei.BAND) return r.offsetBandPaddingInner
+                return s ? u : Ct(a, n === "bar" ? o : l)
+            } else if (Oc(t) && i === Qn.BAND) return r.offsetBandPaddingInner
         }
     }
 
-    function b1e(e, t, n, i, r, a = !1) {
+    function pme(e, t, n, i, r, s = !1) {
         if (e === void 0) {
-            if (Xt(t)) {
+            if (Wt(t)) {
                 const {
-                    bandPaddingOuter: s,
+                    bandPaddingOuter: a,
                     bandWithNestedOffsetPaddingOuter: o
                 } = r;
-                if (a) return o;
-                if (n === ei.BAND) return Tt(s, fe(i) ? {
+                if (s) return o;
+                if (n === Qn.BAND) return Ct(a, he(i) ? {
                     signal: `${i.signal}/2`
                 } : i / 2)
-            } else if (Uc(t)) {
-                if (n === ei.POINT) return .5;
-                if (n === ei.BAND) return r.offsetBandPaddingOuter
+            } else if (Oc(t)) {
+                if (n === Qn.POINT) return .5;
+                if (n === Qn.BAND) return r.offsetBandPaddingOuter
             }
         }
     }
 
-    function x1e(e, t, n, i) {
-        if (n === "x" && i.xReverse !== void 0) return Ei(e) && t === "descending" ? fe(i.xReverse) ? {
+    function mme(e, t, n, i) {
+        if (n === "x" && i.xReverse !== void 0) return wi(e) && t === "descending" ? he(i.xReverse) ? {
             signal: `!${i.xReverse.signal}`
         } : !i.xReverse : i.xReverse;
-        if (Ei(e) && t === "descending") return !0
+        if (wi(e) && t === "descending") return !0
     }
 
-    function _1e(e, t, n, i, r, a, s) {
-        if (!!n && n !== "unaggregated" && Ei(r)) {
-            if (q(n)) {
+    function yme(e, t, n, i, r, s, a) {
+        if (!!n && n !== "unaggregated" && wi(r)) {
+            if (W(n)) {
                 const l = n[0],
                     u = n[n.length - 1];
                 if (l <= 0 && u >= 0) return !0
             }
             return !1
         }
-        if (e === "size" && t.type === "quantitative" && !dc(r)) return !0;
-        if (!(J(t) && t.bin) && Pe([...xa, ...dfe], e)) {
+        if (e === "size" && t.type === "quantitative" && !ic(r)) return !0;
+        if (!(K(t) && t.bin) && Fe([...cs, ...xce], e)) {
             const {
                 orient: l,
                 type: u
             } = i;
-            return Pe(["bar", "area", "line", "trail"], u) && (l === "horizontal" && e === "y" || l === "vertical" && e === "x") ? !1 : Pe(["bar", "area"], u) && !s ? !0 : a == null ? void 0 : a.zero
+            return Fe(["bar", "area", "line", "trail"], u) && (l === "horizontal" && e === "y" || l === "vertical" && e === "x") ? !1 : Fe(["bar", "area"], u) && !a ? !0 : s == null ? void 0 : s.zero
         }
         return !1
     }
 
-    function w1e(e, t, n, i, r = !1) {
-        const a = S1e(t, n, i, r),
+    function vme(e, t, n, i, r = !1) {
+        const s = bme(t, n, i, r),
             {
-                type: s
+                type: a
             } = e;
-        return bo(t) ? s !== void 0 ? bde(t, s) ? J(n) && !vde(s, n.type) ? (X(xhe(s, a)), a) : s : (X(bhe(t, s, a)), a) : a : null
+        return Qs(t) ? a !== void 0 ? Ehe(t, a) ? K(n) && !She(a, n.type) ? (X(kfe(a, s)), s) : a : (X(Cfe(t, a, s)), s) : s : null
     }
 
-    function S1e(e, t, n, i) {
+    function bme(e, t, n, i) {
         var r;
         switch (t.type) {
             case "nominal":
             case "ordinal": {
-                if (Nu(e) || Yv(e) === "discrete") return e === "shape" && t.type === "ordinal" && X(Xv(e, "ordinal")), "ordinal";
-                if (Xt(e) || Uc(e)) {
-                    if (Pe(["rect", "bar", "image", "rule"], n.type) || i) return "band"
-                } else if (n.type === "arc" && e in uO) return "band";
-                const a = n[ui(e)];
-                return El(a) || pc(t) && (!((r = t.axis) === null || r === void 0) && r.tickBand) ? "band" : "point"
+                if (Cu(e) || Cv(e) === "discrete") return e === "shape" && t.type === "ordinal" && X(kv(e, "ordinal")), "ordinal";
+                if (Wt(e) || Oc(e)) {
+                    if (Fe(["rect", "bar", "image", "rule"], n.type) || i) return "band"
+                } else if (n.type === "arc" && e in ME) return "band";
+                const s = n[oi(e)];
+                return dl(s) || sc(t) && ((r = t.axis) != null && r.tickBand) ? "band" : "point"
             }
             case "temporal":
-                return Nu(e) ? "time" : Yv(e) === "discrete" ? (X(Xv(e, "temporal")), "ordinal") : J(t) && t.timeUnit && En(t.timeUnit).utc ? "utc" : "time";
+                return Cu(e) ? "time" : Cv(e) === "discrete" ? (X(kv(e, "temporal")), "ordinal") : K(t) && t.timeUnit && en(t.timeUnit).utc ? "utc" : "time";
             case "quantitative":
-                return Nu(e) ? J(t) && lt(t.bin) ? "bin-ordinal" : "linear" : Yv(e) === "discrete" ? (X(Xv(e, "quantitative")), "ordinal") : "linear";
+                return Cu(e) ? K(t) && ot(t.bin) ? "bin-ordinal" : "linear" : Cv(e) === "discrete" ? (X(kv(e, "quantitative")), "ordinal") : "linear";
             case "geojson":
                 return
         }
-        throw new Error($j(t.type))
+        throw new Error(WI(t.type))
     }
 
-    function E1e(e, {
+    function xme(e, {
         ignoreRange: t
     } = {}) {
-        a8(e), Vz(e);
-        for (const n of yde) n8(e, n);
-        t || i8(e)
+        x8(e), c8(e);
+        for (const n of whe) y8(e, n);
+        t || v8(e)
     }
 
-    function a8(e) {
-        kt(e) ? e.component.scales = O1e(e) : e.component.scales = k1e(e)
+    function x8(e) {
+        Et(e) ? e.component.scales = _me(e) : e.component.scales = Sme(e)
     }
 
-    function O1e(e) {
+    function _me(e) {
         const {
             encoding: t,
             mark: n,
             markDef: i
         } = e, r = {};
-        for (const a of H1) {
-            const s = Rt(t[a]);
-            if (s && n === Qj && a === li && s.type === qc) continue;
-            let o = s && s.scale;
-            if (Uc(a)) {
-                const l = gj(a);
-                if (!Cx(t, l)) {
-                    o && X(ahe(a));
+        for (const s of A1) {
+            const a = Mt(t[s]);
+            if (a && n === d6 && s === ai && a.type === Rc) continue;
+            let o = a && a.scale;
+            if (Oc(s)) {
+                const l = $I(s);
+                if (!J2(t, l)) {
+                    o && X(ffe(s));
                     continue
                 }
             }
-            if (s && o !== null && o !== !1) {
+            if (a && o !== null && o !== !1) {
                 o ?? (o = {});
-                const l = Cx(t, a),
-                    u = w1e(o, a, s, i, l);
-                r[a] = new Jz(e.scaleName(`${a}`, !0), {
+                const l = J2(t, s),
+                    u = vme(o, s, a, i, l);
+                r[s] = new h8(e.scaleName(`${s}`, !0), {
                     value: u,
                     explicit: o.type === u
                 })
             }
         }
         return r
     }
-    const C1e = tz((e, t) => x$(e) - x$(t));
+    const wme = gz((e, t) => D5(e) - D5(t));
 
-    function k1e(e) {
-        var t, n;
-        const i = e.component.scales = {},
-            r = {},
-            a = e.component.resolve;
+    function Sme(e) {
+        var t;
+        const n = e.component.scales = {},
+            i = {},
+            r = e.component.resolve;
         for (const s of e.children) {
-            a8(s);
-            for (const o of Y(s.component.scales))
-                if ((t = (n = a.scale)[o]) !== null && t !== void 0 || (n[o] = Nz(o, e)), a.scale[o] === "shared") {
-                    const l = r[o],
-                        u = s.component.scales[o].getWithExplicit("type");
-                    l ? ode(l.value, u.value) ? r[o] = Qs(l, u, "type", "scale", C1e) : (a.scale[o] = "independent", delete r[o]) : r[o] = u
+            x8(s);
+            for (const a of H(s.component.scales))
+                if ((t = r.scale)[a] ?? (t[a] = Jz(a, e)), r.scale[a] === "shared") {
+                    const o = i[a],
+                        l = s.component.scales[a].getWithExplicit("type");
+                    o ? hhe(o.value, l.value) ? i[a] = Ua(o, l, "type", "scale", wme) : (r.scale[a] = "independent", delete i[a]) : i[a] = l
                 }
         }
-        for (const s of Y(r)) {
-            const o = e.scaleName(s, !0),
-                l = r[s];
-            i[s] = new Jz(o, l);
-            for (const u of e.children) {
-                const c = u.component.scales[s];
-                c && (u.renameScale(c.get("name"), o), c.merged = !0)
+        for (const s of H(i)) {
+            const a = e.scaleName(s, !0),
+                o = i[s];
+            n[s] = new h8(a, o);
+            for (const l of e.children) {
+                const u = l.component.scales[s];
+                u && (l.renameScale(u.get("name"), a), u.merged = !0)
             }
         }
-        return i
-    }
-    var nb = globalThis && globalThis.__rest || function(e, t) {
-        var n = {};
-        for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && t.indexOf(i) < 0 && (n[i] = e[i]);
-        if (e != null && typeof Object.getOwnPropertySymbols == "function")
-            for (var r = 0, i = Object.getOwnPropertySymbols(e); r < i.length; r++) t.indexOf(i[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, i[r]) && (n[i[r]] = e[i[r]]);
         return n
-    };
-    class ib {
+    }
+    class Dv {
         constructor() {
             this.nameMap = {}
         }
         rename(t, n) {
             this.nameMap[t] = n
         }
         has(t) {
@@ -48305,56 +48677,56 @@
         }
         get(t) {
             for (; this.nameMap[t] && t !== this.nameMap[t];) t = this.nameMap[t];
             return t
         }
     }
 
-    function kt(e) {
+    function Et(e) {
         return (e == null ? void 0 : e.type) === "unit"
     }
 
-    function mr(e) {
+    function lr(e) {
         return (e == null ? void 0 : e.type) === "facet"
     }
 
-    function gC(e) {
+    function RC(e) {
         return (e == null ? void 0 : e.type) === "concat"
     }
 
-    function Vc(e) {
+    function Ic(e) {
         return (e == null ? void 0 : e.type) === "layer"
     }
-    class pC {
-        constructor(t, n, i, r, a, s, o) {
-            var l, u;
-            this.type = n, this.parent = i, this.config = a, this.correctDataNames = c => {
-                var f, h, d;
-                return !((f = c.from) === null || f === void 0) && f.data && (c.from.data = this.lookupDataSource(c.from.data)), !((d = (h = c.from) === null || h === void 0 ? void 0 : h.facet) === null || d === void 0) && d.data && (c.from.facet.data = this.lookupDataSource(c.from.facet.data)), c
-            }, this.parent = i, this.config = a, this.view = Xn(o), this.name = (l = t.name) !== null && l !== void 0 ? l : r, this.title = xs(t.title) ? {
+    class DC {
+        constructor(t, n, i, r, s, a, o) {
+            this.type = n, this.parent = i, this.config = s, this.correctDataNames = l => {
+                var u, c, f;
+                return (u = l.from) != null && u.data && (l.from.data = this.lookupDataSource(l.from.data)), (f = (c = l.from) == null ? void 0 : c.facet) != null && f.data && (l.from.facet.data = this.lookupDataSource(l.from.facet.data)), l
+            }, this.parent = i, this.config = s, this.view = Hn(o), this.name = t.name ?? r, this.title = ca(t.title) ? {
                 text: t.title
-            } : t.title ? Xn(t.title) : void 0, this.scaleNameMap = i ? i.scaleNameMap : new ib, this.projectionNameMap = i ? i.projectionNameMap : new ib, this.signalNameMap = i ? i.signalNameMap : new ib, this.data = t.data, this.description = t.description, this.transforms = $pe((u = t.transform) !== null && u !== void 0 ? u : []), this.layout = n === "layer" || n === "unit" ? {} : Nge(t, n, a), this.component = {
+            } : t.title ? Hn(t.title) : void 0, this.scaleNameMap = i ? i.scaleNameMap : new Dv, this.projectionNameMap = i ? i.projectionNameMap : new Dv, this.signalNameMap = i ? i.signalNameMap : new Dv, this.data = t.data, this.description = t.description, this.transforms = Mge(t.transform ?? []), this.layout = n === "layer" || n === "unit" ? {} : zde(t, n, s), this.component = {
                 data: {
                     sources: i ? i.component.data.sources : [],
                     outputNodes: i ? i.component.data.outputNodes : {},
                     outputNodeRefCounts: i ? i.component.data.outputNodeRefCounts : {},
-                    isFaceted: ey(t) || (i == null ? void 0 : i.component.data.isFaceted) && t.data === void 0
+                    isFaceted: P1(t) || (i == null ? void 0 : i.component.data.isFaceted) && t.data === void 0
                 },
-                layoutSize: new ls,
+                layoutSize: new ea,
                 layoutHeaders: {
                     row: {},
                     column: {},
                     facet: {}
                 },
                 mark: null,
-                resolve: Object.assign({
+                resolve: {
                     scale: {},
                     axis: {},
-                    legend: {}
-                }, s ? Ce(s) : {}),
+                    legend: {},
+                    ...a ? ke(a) : {}
+                },
                 selection: null,
                 scales: null,
                 projection: null,
                 axes: {},
                 legends: {}
             }
         }
@@ -48364,140 +48736,144 @@
         get height() {
             return this.getSizeSignalRef("height")
         }
         parse() {
             this.parseScale(), this.parseLayoutSize(), this.renameTopLevelLayoutSizeSignal(), this.parseSelections(), this.parseProjection(), this.parseData(), this.parseAxesAndHeaders(), this.parseLegends(), this.parseMarkGroup()
         }
         parseScale() {
-            E1e(this)
+            xme(this)
         }
         parseProjection() {
-            Hz(this)
+            o8(this)
         }
         renameTopLevelLayoutSizeSignal() {
             this.getName("width") !== "width" && this.renameSignal(this.getName("width"), "width"), this.getName("height") !== "height" && this.renameSignal(this.getName("height"), "height")
         }
         parseLegends() {
-            Bz(this)
+            n8(this)
         }
         assembleEncodeFromView(t) {
-            const n = nb(t, ["style"]),
-                i = {};
-            for (const r of Y(n)) {
-                const a = n[r];
-                a !== void 0 && (i[r] = ct(a))
+            const {
+                style: n,
+                ...i
+            } = t, r = {};
+            for (const s of H(i)) {
+                const a = i[s];
+                a !== void 0 && (r[s] = ut(a))
             }
-            return i
+            return r
         }
         assembleGroupEncodeEntry(t) {
             let n = {};
-            return this.view && (n = this.assembleEncodeFromView(this.view)), !t && (this.description && (n.description = ct(this.description)), this.type === "unit" || this.type === "layer") ? Object.assign({
+            return this.view && (n = this.assembleEncodeFromView(this.view)), !t && (this.description && (n.description = ut(this.description)), this.type === "unit" || this.type === "layer") ? {
                 width: this.getSizeSignalRef("width"),
-                height: this.getSizeSignalRef("height")
-            }, n ?? {}) : et(n) ? void 0 : n
+                height: this.getSizeSignalRef("height"),
+                ...n ?? {}
+            } : et(n) ? void 0 : n
         }
         assembleLayout() {
             if (!this.layout) return;
-            const t = this.layout,
-                {
-                    spacing: n
-                } = t,
-                i = nb(t, ["spacing"]),
-                {
-                    component: r,
-                    config: a
-                } = this,
-                s = q0e(r.layoutHeaders, a);
-            return Object.assign(Object.assign(Object.assign({
-                padding: n
-            }, this.assembleDefaultLayout()), i), s ? {
-                titleBand: s
-            } : {})
+            const {
+                spacing: t,
+                ...n
+            } = this.layout, {
+                component: i,
+                config: r
+            } = this, s = Wpe(i.layoutHeaders, r);
+            return {
+                padding: t,
+                ...this.assembleDefaultLayout(),
+                ...n,
+                ...s ? {
+                    titleBand: s
+                } : {}
+            }
         }
         assembleDefaultLayout() {
             return {}
         }
         assembleHeaderMarks() {
             const {
                 layoutHeaders: t
             } = this.component;
             let n = [];
-            for (const i of Ri) t[i].title && n.push(I0e(this, i));
-            for (const i of aC) n = n.concat(j0e(this, i));
+            for (const i of Ti) t[i].title && n.push(Ipe(this, i));
+            for (const i of EC) n = n.concat(zpe(this, i));
             return n
         }
         assembleAxes() {
-            return C0e(this.component.axes, this.config)
+            return Cpe(this.component.axes, this.config)
         }
         assembleLegends() {
-            return Uz(this)
+            return r8(this)
         }
         assembleProjections() {
-            return gme(this)
+            return d0e(this)
         }
         assembleTitle() {
-            var t, n, i;
-            const r = (t = this.title) !== null && t !== void 0 ? t : {},
-                {
-                    encoding: a
-                } = r,
-                s = nb(r, ["encoding"]),
-                o = Object.assign(Object.assign(Object.assign({}, _j(this.config.title).nonMarkTitleProperties), s), a ? {
+            const {
+                encoding: t,
+                ...n
+            } = this.title ?? {}, i = {
+                ...NI(this.config.title).nonMarkTitleProperties,
+                ...n,
+                ...t ? {
                     encode: {
-                        update: a
+                        update: t
                     }
-                } : {});
-            if (o.text) return Pe(["unit", "layer"], this.type) ? Pe(["middle", void 0], o.anchor) && ((n = o.frame) !== null && n !== void 0 || (o.frame = "group")) : (i = o.anchor) !== null && i !== void 0 || (o.anchor = "start"), et(o) ? void 0 : o
+                } : {}
+            };
+            if (i.text) return Fe(["unit", "layer"], this.type) ? Fe(["middle", void 0], i.anchor) && (i.frame ?? (i.frame = "group")) : i.anchor ?? (i.anchor = "start"), et(i) ? void 0 : i
         }
         assembleGroup(t = []) {
             const n = {};
             t = t.concat(this.assembleSignals()), t.length > 0 && (n.signals = t);
             const i = this.assembleLayout();
             i && (n.layout = i), n.marks = [].concat(this.assembleHeaderMarks(), this.assembleMarks());
-            const r = !this.parent || mr(this.parent) ? Kz(this) : [];
+            const r = !this.parent || lr(this.parent) ? f8(this) : [];
             r.length > 0 && (n.scales = r);
-            const a = this.assembleAxes();
-            a.length > 0 && (n.axes = a);
-            const s = this.assembleLegends();
-            return s.length > 0 && (n.legends = s), n
+            const s = this.assembleAxes();
+            s.length > 0 && (n.axes = s);
+            const a = this.assembleLegends();
+            return a.length > 0 && (n.legends = a), n
         }
         getName(t) {
-            return ht((this.name ? `${this.name}_` : "") + t)
+            return ft((this.name ? `${this.name}_` : "") + t)
         }
         getDataName(t) {
             return this.getName(st[t].toLowerCase())
         }
         requestDataName(t) {
             const n = this.getDataName(t),
                 i = this.component.data.outputNodeRefCounts;
             return i[n] = (i[n] || 0) + 1, n
         }
         getSizeSignalRef(t) {
-            if (mr(this.parent)) {
-                const n = Rz(t),
-                    i = W1(n),
+            if (lr(this.parent)) {
+                const n = Vz(t),
+                    i = k1(n),
                     r = this.component.scales[i];
                 if (r && !r.merged) {
-                    const a = r.get("type"),
-                        s = r.get("range");
-                    if (Vt(a) && _o(s)) {
+                    const s = r.get("type"),
+                        a = r.get("range");
+                    if (qt(s) && lo(a)) {
                         const o = r.get("name"),
-                            l = gy(this, i),
-                            u = dC(l);
+                            l = K1(this, i),
+                            u = FC(l);
                         if (u) {
-                            const c = ne({
+                            const c = ie({
                                 aggregate: "distinct",
                                 field: u
                             }, {
                                 expr: "datum"
                             });
                             return {
-                                signal: Dz(o, r, c)
+                                signal: Xz(o, r, c)
                             }
-                        } else return X(dO(i)), null
+                        } else return X(RE(i)), null
                     }
                 }
             }
             return {
                 signal: this.signalNameMap.get(this.getName(t))
             }
         }
@@ -48515,316 +48891,304 @@
             this.scaleNameMap.rename(t, n)
         }
         renameProjection(t, n) {
             this.projectionNameMap.rename(t, n)
         }
         scaleName(t, n) {
             if (n) return this.getName(t);
-            if (fj(t) && bo(t) && this.component.scales[t] || this.scaleNameMap.has(this.getName(t))) return this.scaleNameMap.get(this.getName(t))
+            if (CI(t) && Qs(t) && this.component.scales[t] || this.scaleNameMap.has(this.getName(t))) return this.scaleNameMap.get(this.getName(t))
         }
         projectionName(t) {
             if (t) return this.getName("projection");
             if (this.component.projection && !this.component.projection.merged || this.projectionNameMap.has(this.getName("projection"))) return this.projectionNameMap.get(this.getName("projection"))
         }
         getScaleComponent(t) {
             if (!this.component.scales) throw new Error("getScaleComponent cannot be called before parseScale(). Make sure you have called parseScale or use parseUnitModelWithScale().");
             const n = this.component.scales[t];
             return n && !n.merged ? n : this.parent ? this.parent.getScaleComponent(t) : void 0
         }
         getSelectionComponent(t, n) {
             let i = this.component.selection[t];
-            if (!i && this.parent && (i = this.parent.getSelectionComponent(t, n)), !i) throw new Error(Lfe(n));
+            if (!i && this.parent && (i = this.parent.getSelectionComponent(t, n)), !i) throw new Error(Gce(n));
             return i
         }
         hasAxisOrientSignalRef() {
             var t, n;
-            return ((t = this.component.axes.x) === null || t === void 0 ? void 0 : t.some(i => i.hasOrientSignalRef())) || ((n = this.component.axes.y) === null || n === void 0 ? void 0 : n.some(i => i.hasOrientSignalRef()))
+            return ((t = this.component.axes.x) == null ? void 0 : t.some(i => i.hasOrientSignalRef())) || ((n = this.component.axes.y) == null ? void 0 : n.some(i => i.hasOrientSignalRef()))
         }
     }
-    class s8 extends pC {
+    class _8 extends DC {
         vgField(t, n = {}) {
             const i = this.fieldDef(t);
-            if (i) return ne(i, n)
+            if (i) return ie(i, n)
         }
         reduceFieldDef(t, n) {
-            return cge(this.getMapping(), (i, r, a) => {
-                const s = ia(r);
-                return s ? t(i, s, a) : i
+            return gde(this.getMapping(), (i, r, s) => {
+                const a = Kr(r);
+                return a ? t(i, a, s) : i
             }, n)
         }
         forEachFieldDef(t, n) {
-            BO(this.getMapping(), (i, r) => {
-                const a = ia(i);
-                a && t(a, r)
+            aC(this.getMapping(), (i, r) => {
+                const s = Kr(i);
+                s && t(s, r)
             }, n)
         }
     }
-    var A1e = globalThis && globalThis.__rest || function(e, t) {
-        var n = {};
-        for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && t.indexOf(i) < 0 && (n[i] = e[i]);
-        if (e != null && typeof Object.getOwnPropertySymbols == "function")
-            for (var r = 0, i = Object.getOwnPropertySymbols(e); r < i.length; r++) t.indexOf(i[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, i[r]) && (n[i[r]] = e[i[r]]);
-        return n
-    };
-    class py extends it {
+    class J1 extends nt {
         clone() {
-            return new py(null, Ce(this.transform))
+            return new J1(null, ke(this.transform))
         }
         constructor(t, n) {
-            var i, r, a;
-            super(t), this.transform = n, this.transform = Ce(n);
-            const s = (i = this.transform.as) !== null && i !== void 0 ? i : [void 0, void 0];
-            this.transform.as = [(r = s[0]) !== null && r !== void 0 ? r : "value", (a = s[1]) !== null && a !== void 0 ? a : "density"], n.groupby && n.minsteps == null && n.maxsteps == null && n.steps == null && (this.transform.steps = 200)
+            super(t), this.transform = n, this.transform = ke(n);
+            const i = this.transform.as ?? [void 0, void 0];
+            this.transform.as = [i[0] ?? "value", i[1] ?? "density"], n.groupby && n.minsteps == null && n.maxsteps == null && n.steps == null && (this.transform.steps = 200)
         }
         dependentFields() {
-            var t;
-            return new Set([this.transform.density, ...(t = this.transform.groupby) !== null && t !== void 0 ? t : []])
+            return new Set([this.transform.density, ...this.transform.groupby ?? []])
         }
         producedFields() {
             return new Set(this.transform.as)
         }
         hash() {
-            return `DensityTransform ${Ie(this.transform)}`
+            return `DensityTransform ${Ne(this.transform)}`
         }
         assemble() {
-            const t = this.transform,
-                {
-                    density: n
-                } = t,
-                i = A1e(t, ["density"]);
-            return Object.assign({
+            const {
+                density: t,
+                ...n
+            } = this.transform;
+            return {
                 type: "kde",
-                field: n
-            }, i)
+                field: t,
+                ...n
+            }
         }
     }
-    class td extends it {
+    class Uh extends nt {
         clone() {
-            return new td(null, Object.assign({}, this.filter))
+            return new Uh(null, {
+                ...this.filter
+            })
         }
         constructor(t, n) {
             super(t), this.filter = n
         }
         static make(t, n) {
             const {
                 config: i,
                 mark: r,
-                markDef: a
+                markDef: s
             } = n;
-            if (Ve("invalid", a, i) !== "filter") return null;
+            if (Xe("invalid", s, i) !== "filter") return null;
             const o = n.reduceFieldDef((l, u, c) => {
-                const f = bo(c) && n.getScaleComponent(c);
+                const f = Qs(c) && n.getScaleComponent(c);
                 if (f) {
                     const h = f.get("type");
-                    Ei(h) && u.aggregate !== "count" && !wo(r) && (l[u.field] = u)
+                    wi(h) && u.aggregate !== "count" && !uo(r) && (l[u.field] = u)
                 }
                 return l
             }, {});
-            return Y(o).length ? new td(t, o) : null
+            return H(o).length ? new Uh(t, o) : null
         }
         dependentFields() {
-            return new Set(Y(this.filter))
+            return new Set(H(this.filter))
         }
         producedFields() {
             return new Set
         }
         hash() {
-            return `FilterInvalid ${Ie(this.filter)}`
+            return `FilterInvalid ${Ne(this.filter)}`
         }
         assemble() {
-            const t = Y(this.filter).reduce((n, i) => {
+            const t = H(this.filter).reduce((n, i) => {
                 const r = this.filter[i],
-                    a = ne(r, {
+                    s = ie(r, {
                         expr: "datum"
                     });
-                return r !== null && (r.type === "temporal" ? n.push(`(isDate(${a}) || (isValid(${a}) && isFinite(+${a})))`) : r.type === "quantitative" && (n.push(`isValid(${a})`), n.push(`isFinite(+${a})`))), n
+                return r !== null && (r.type === "temporal" ? n.push(`(isDate(${s}) || (isValid(${s}) && isFinite(+${s})))`) : r.type === "quantitative" && (n.push(`isValid(${s})`), n.push(`isFinite(+${s})`))), n
             }, []);
             return t.length > 0 ? {
                 type: "filter",
                 expr: t.join(" && ")
             } : null
         }
     }
-    class my extends it {
+    class Q1 extends nt {
         clone() {
-            return new my(this.parent, Ce(this.transform))
+            return new Q1(this.parent, ke(this.transform))
         }
         constructor(t, n) {
-            super(t), this.transform = n, this.transform = Ce(n);
+            super(t), this.transform = n, this.transform = ke(n);
             const {
                 flatten: i,
                 as: r = []
             } = this.transform;
-            this.transform.as = i.map((a, s) => {
-                var o;
-                return (o = r[s]) !== null && o !== void 0 ? o : a
-            })
+            this.transform.as = i.map((s, a) => r[a] ?? s)
         }
         dependentFields() {
             return new Set(this.transform.flatten)
         }
         producedFields() {
             return new Set(this.transform.as)
         }
         hash() {
-            return `FlattenTransform ${Ie(this.transform)}`
+            return `FlattenTransform ${Ne(this.transform)}`
         }
         assemble() {
             const {
                 flatten: t,
                 as: n
             } = this.transform;
             return {
                 type: "flatten",
                 fields: t,
                 as: n
             }
         }
     }
-    class yy extends it {
+    class Z1 extends nt {
         clone() {
-            return new yy(null, Ce(this.transform))
+            return new Z1(null, ke(this.transform))
         }
         constructor(t, n) {
-            var i, r, a;
-            super(t), this.transform = n, this.transform = Ce(n);
-            const s = (i = this.transform.as) !== null && i !== void 0 ? i : [void 0, void 0];
-            this.transform.as = [(r = s[0]) !== null && r !== void 0 ? r : "key", (a = s[1]) !== null && a !== void 0 ? a : "value"]
+            super(t), this.transform = n, this.transform = ke(n);
+            const i = this.transform.as ?? [void 0, void 0];
+            this.transform.as = [i[0] ?? "key", i[1] ?? "value"]
         }
         dependentFields() {
             return new Set(this.transform.fold)
         }
         producedFields() {
             return new Set(this.transform.as)
         }
         hash() {
-            return `FoldTransform ${Ie(this.transform)}`
+            return `FoldTransform ${Ne(this.transform)}`
         }
         assemble() {
             const {
                 fold: t,
                 as: n
             } = this.transform;
             return {
                 type: "fold",
                 fields: t,
                 as: n
             }
         }
     }
-    class ju extends it {
+    class $u extends nt {
         clone() {
-            return new ju(null, Ce(this.fields), this.geojson, this.signal)
+            return new $u(null, ke(this.fields), this.geojson, this.signal)
         }
         static parseAll(t, n) {
             if (n.component.projection && !n.component.projection.isFit) return t;
             let i = 0;
             for (const r of [
-                    [ma, pa],
-                    [Gi, Tr]
+                    [Sr, wr],
+                    [Li, Er]
                 ]) {
-                const a = r.map(s => {
-                    const o = Rt(n.encoding[s]);
-                    return J(o) ? o.field : _a(o) ? {
+                const s = r.map(a => {
+                    const o = Mt(n.encoding[a]);
+                    return K(o) ? o.field : fs(o) ? {
                         expr: `${o.datum}`
-                    } : wr(o) ? {
+                    } : gr(o) ? {
                         expr: `${o.value}`
                     } : void 0
                 });
-                (a[0] || a[1]) && (t = new ju(t, a, null, n.getName(`geojson_${i++}`)))
+                (s[0] || s[1]) && (t = new $u(t, s, null, n.getName(`geojson_${i++}`)))
             }
-            if (n.channelHasField(li)) {
-                const r = n.typedFieldDef(li);
-                r.type === qc && (t = new ju(t, null, r.field, n.getName(`geojson_${i++}`)))
+            if (n.channelHasField(ai)) {
+                const r = n.typedFieldDef(ai);
+                r.type === Rc && (t = new $u(t, null, r.field, n.getName(`geojson_${i++}`)))
             }
             return t
         }
         constructor(t, n, i, r) {
             super(t), this.fields = n, this.geojson = i, this.signal = r
         }
         dependentFields() {
-            var t;
-            const n = ((t = this.fields) !== null && t !== void 0 ? t : []).filter(re);
-            return new Set([...this.geojson ? [this.geojson] : [], ...n])
+            const t = (this.fields ?? []).filter(re);
+            return new Set([...this.geojson ? [this.geojson] : [], ...t])
         }
         producedFields() {
             return new Set
         }
         hash() {
-            return `GeoJSON ${this.geojson} ${this.signal} ${Ie(this.fields)}`
+            return `GeoJSON ${this.geojson} ${this.signal} ${Ne(this.fields)}`
         }
         assemble() {
             return [...this.geojson ? [{
                 type: "filter",
                 expr: `isValid(datum["${this.geojson}"])`
-            }] : [], Object.assign(Object.assign(Object.assign({
-                type: "geojson"
-            }, this.fields ? {
-                fields: this.fields
-            } : {}), this.geojson ? {
-                geojson: this.geojson
-            } : {}), {
+            }] : [], {
+                type: "geojson",
+                ...this.fields ? {
+                    fields: this.fields
+                } : {},
+                ...this.geojson ? {
+                    geojson: this.geojson
+                } : {},
                 signal: this.signal
-            })]
+            }]
         }
     }
-    class nd extends it {
+    class Gh extends nt {
         clone() {
-            return new nd(null, this.projection, Ce(this.fields), Ce(this.as))
+            return new Gh(null, this.projection, ke(this.fields), ke(this.as))
         }
         constructor(t, n, i, r) {
             super(t), this.projection = n, this.fields = i, this.as = r
         }
         static parseAll(t, n) {
             if (!n.projectionName()) return t;
             for (const i of [
-                    [ma, pa],
-                    [Gi, Tr]
+                    [Sr, wr],
+                    [Li, Er]
                 ]) {
-                const r = i.map(s => {
-                        const o = Rt(n.encoding[s]);
-                        return J(o) ? o.field : _a(o) ? {
+                const r = i.map(a => {
+                        const o = Mt(n.encoding[a]);
+                        return K(o) ? o.field : fs(o) ? {
                             expr: `${o.datum}`
-                        } : wr(o) ? {
+                        } : gr(o) ? {
                             expr: `${o.value}`
                         } : void 0
                     }),
-                    a = i[0] === Gi ? "2" : "";
-                (r[0] || r[1]) && (t = new nd(t, n.projectionName(), r, [n.getName(`x${a}`), n.getName(`y${a}`)]))
+                    s = i[0] === Li ? "2" : "";
+                (r[0] || r[1]) && (t = new Gh(t, n.projectionName(), r, [n.getName(`x${s}`), n.getName(`y${s}`)]))
             }
             return t
         }
         dependentFields() {
             return new Set(this.fields.filter(re))
         }
         producedFields() {
             return new Set(this.as)
         }
         hash() {
-            return `Geopoint ${this.projection} ${Ie(this.fields)} ${Ie(this.as)}`
+            return `Geopoint ${this.projection} ${Ne(this.fields)} ${Ne(this.as)}`
         }
         assemble() {
             return {
                 type: "geopoint",
                 projection: this.projection,
                 fields: this.fields,
                 as: this.as
             }
         }
     }
-    class sl extends it {
+    class Xo extends nt {
         clone() {
-            return new sl(null, Ce(this.transform))
+            return new Xo(null, ke(this.transform))
         }
         constructor(t, n) {
             super(t), this.transform = n
         }
         dependentFields() {
-            var t;
-            return new Set([this.transform.impute, this.transform.key, ...(t = this.transform.groupby) !== null && t !== void 0 ? t : []])
+            return new Set([this.transform.impute, this.transform.key, ...this.transform.groupby ?? []])
         }
         producedFields() {
             return new Set([this.transform.impute])
         }
         processSequence(t) {
             const {
                 start: n = 0,
@@ -48832,709 +49196,695 @@
                 step: r
             } = t;
             return {
                 signal: `sequence(${[n,i,...r?[r]:[]].join(",")})`
             }
         }
         static makeFromTransform(t, n) {
-            return new sl(t, n)
+            return new Xo(t, n)
         }
         static makeFromEncoding(t, n) {
             const i = n.encoding,
                 r = i.x,
-                a = i.y;
-            if (J(r) && J(a)) {
-                const s = r.impute ? r : a.impute ? a : void 0;
-                if (s === void 0) return;
-                const o = r.impute ? a : a.impute ? r : void 0,
+                s = i.y;
+            if (K(r) && K(s)) {
+                const a = r.impute ? r : s.impute ? s : void 0;
+                if (a === void 0) return;
+                const o = r.impute ? s : s.impute ? r : void 0,
                     {
                         method: l,
                         value: u,
                         frame: c,
                         keyvals: f
-                    } = s.impute,
-                    h = E6(n.mark, i);
-                return new sl(t, Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({
-                    impute: s.field,
-                    key: o.field
-                }, l ? {
-                    method: l
-                } : {}), u !== void 0 ? {
-                    value: u
-                } : {}), c ? {
-                    frame: c
-                } : {}), f !== void 0 ? {
-                    keyvals: f
-                } : {}), h.length ? {
-                    groupby: h
-                } : {}))
+                    } = a.impute,
+                    h = B6(n.mark, i);
+                return new Xo(t, {
+                    impute: a.field,
+                    key: o.field,
+                    ...l ? {
+                        method: l
+                    } : {},
+                    ...u !== void 0 ? {
+                        value: u
+                    } : {},
+                    ...c ? {
+                        frame: c
+                    } : {},
+                    ...f !== void 0 ? {
+                        keyvals: f
+                    } : {},
+                    ...h.length ? {
+                        groupby: h
+                    } : {}
+                })
             }
             return null
         }
         hash() {
-            return `Impute ${Ie(this.transform)}`
+            return `Impute ${Ne(this.transform)}`
         }
         assemble() {
             const {
                 impute: t,
                 key: n,
                 keyvals: i,
                 method: r,
-                groupby: a,
-                value: s,
+                groupby: s,
+                value: a,
                 frame: o = [null, null]
-            } = this.transform, l = Object.assign(Object.assign(Object.assign(Object.assign({
+            } = this.transform, l = {
                 type: "impute",
                 field: t,
-                key: n
-            }, i ? {
-                keyvals: hpe(i) ? this.processSequence(i) : i
-            } : {}), {
-                method: "value"
-            }), a ? {
-                groupby: a
-            } : {}), {
-                value: !r || r === "value" ? s : null
-            });
+                key: n,
+                ...i ? {
+                    keyvals: hge(i) ? this.processSequence(i) : i
+                } : {},
+                method: "value",
+                ...s ? {
+                    groupby: s
+                } : {},
+                value: !r || r === "value" ? a : null
+            };
             if (r && r !== "value") {
-                const u = Object.assign({
+                const u = {
                         type: "window",
                         as: [`imputed_${t}_value`],
                         ops: [r],
                         fields: [t],
                         frame: o,
-                        ignorePeers: !1
-                    }, a ? {
-                        groupby: a
-                    } : {}),
+                        ignorePeers: !1,
+                        ...s ? {
+                            groupby: s
+                        } : {}
+                    },
                     c = {
                         type: "formula",
                         expr: `datum.${t} === null ? datum.imputed_${t}_value : datum.${t}`,
                         as: t
                     };
                 return [l, u, c]
             } else return [l]
         }
     }
-    var T1e = globalThis && globalThis.__rest || function(e, t) {
-        var n = {};
-        for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && t.indexOf(i) < 0 && (n[i] = e[i]);
-        if (e != null && typeof Object.getOwnPropertySymbols == "function")
-            for (var r = 0, i = Object.getOwnPropertySymbols(e); r < i.length; r++) t.indexOf(i[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, i[r]) && (n[i[r]] = e[i[r]]);
-        return n
-    };
-    class vy extends it {
+    class ey extends nt {
         clone() {
-            return new vy(null, Ce(this.transform))
+            return new ey(null, ke(this.transform))
         }
         constructor(t, n) {
-            var i, r, a;
-            super(t), this.transform = n, this.transform = Ce(n);
-            const s = (i = this.transform.as) !== null && i !== void 0 ? i : [void 0, void 0];
-            this.transform.as = [(r = s[0]) !== null && r !== void 0 ? r : n.on, (a = s[1]) !== null && a !== void 0 ? a : n.loess]
+            super(t), this.transform = n, this.transform = ke(n);
+            const i = this.transform.as ?? [void 0, void 0];
+            this.transform.as = [i[0] ?? n.on, i[1] ?? n.loess]
         }
         dependentFields() {
-            var t;
-            return new Set([this.transform.loess, this.transform.on, ...(t = this.transform.groupby) !== null && t !== void 0 ? t : []])
+            return new Set([this.transform.loess, this.transform.on, ...this.transform.groupby ?? []])
         }
         producedFields() {
             return new Set(this.transform.as)
         }
         hash() {
-            return `LoessTransform ${Ie(this.transform)}`
+            return `LoessTransform ${Ne(this.transform)}`
         }
         assemble() {
-            const t = this.transform,
-                {
-                    loess: n,
-                    on: i
-                } = t,
-                r = T1e(t, ["loess", "on"]);
-            return Object.assign({
+            const {
+                loess: t,
+                on: n,
+                ...i
+            } = this.transform;
+            return {
                 type: "loess",
-                x: i,
-                y: n
-            }, r)
+                x: n,
+                y: t,
+                ...i
+            }
         }
     }
-    class id extends it {
+    class Wh extends nt {
         clone() {
-            return new id(null, Ce(this.transform), this.secondary)
+            return new Wh(null, ke(this.transform), this.secondary)
         }
         constructor(t, n, i) {
             super(t), this.transform = n, this.secondary = i
         }
         static make(t, n, i, r) {
-            const a = n.component.data.sources,
+            const s = n.component.data.sources,
                 {
-                    from: s
+                    from: a
                 } = i;
             let o = null;
-            if (dpe(s)) {
-                let l = u8(s.data, a);
-                l || (l = new Al(s.data), a.push(l));
+            if (dge(a)) {
+                let l = E8(a.data, s);
+                l || (l = new yl(a.data), s.push(l));
                 const u = n.getName(`lookup_${r}`);
-                o = new Ln(l, u, st.Lookup, n.component.data.outputNodeRefCounts), n.component.data.outputNodes[u] = o
-            } else if (gpe(s)) {
-                const l = s.param;
-                i = Object.assign({
-                    as: l
-                }, i);
+                o = new Dn(l, u, st.Lookup, n.component.data.outputNodeRefCounts), n.component.data.outputNodes[u] = o
+            } else if (gge(a)) {
+                const l = a.param;
+                i = {
+                    as: l,
+                    ...i
+                };
                 let u;
                 try {
-                    u = n.getSelectionComponent(ht(l), l)
+                    u = n.getSelectionComponent(ft(l), l)
                 } catch {
-                    throw new Error(zfe(l))
+                    throw new Error(Hce(l))
                 }
-                if (o = u.materialized, !o) throw new Error(Bfe(l))
+                if (o = u.materialized, !o) throw new Error(Yce(l))
             }
-            return new id(t, i, o.getSource())
+            return new Wh(t, i, o.getSource())
         }
         dependentFields() {
             return new Set([this.transform.lookup])
         }
         producedFields() {
-            return new Set(this.transform.as ? ie(this.transform.as) : this.transform.from.fields)
+            return new Set(this.transform.as ? se(this.transform.as) : this.transform.from.fields)
         }
         hash() {
-            return `Lookup ${Ie({transform:this.transform,secondary:this.secondary})}`
+            return `Lookup ${Ne({transform:this.transform,secondary:this.secondary})}`
         }
         assemble() {
             let t;
-            if (this.transform.from.fields) t = Object.assign({
-                values: this.transform.from.fields
-            }, this.transform.as ? {
-                as: ie(this.transform.as)
-            } : {});
+            if (this.transform.from.fields) t = {
+                values: this.transform.from.fields,
+                ...this.transform.as ? {
+                    as: se(this.transform.as)
+                } : {}
+            };
             else {
                 let n = this.transform.as;
-                re(n) || (X(Vfe), n = "_lookup"), t = {
+                re(n) || (X(tfe), n = "_lookup"), t = {
                     as: [n]
                 }
             }
-            return Object.assign(Object.assign({
+            return {
                 type: "lookup",
                 from: this.secondary,
                 key: this.transform.from.key,
-                fields: [this.transform.lookup]
-            }, t), this.transform.default ? {
-                default: this.transform.default
-            } : {})
+                fields: [this.transform.lookup],
+                ...t,
+                ...this.transform.default ? {
+                    default: this.transform.default
+                } : {}
+            }
         }
     }
-    var $1e = globalThis && globalThis.__rest || function(e, t) {
-        var n = {};
-        for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && t.indexOf(i) < 0 && (n[i] = e[i]);
-        if (e != null && typeof Object.getOwnPropertySymbols == "function")
-            for (var r = 0, i = Object.getOwnPropertySymbols(e); r < i.length; r++) t.indexOf(i[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, i[r]) && (n[i[r]] = e[i[r]]);
-        return n
-    };
-    class by extends it {
+    class ty extends nt {
         clone() {
-            return new by(null, Ce(this.transform))
+            return new ty(null, ke(this.transform))
         }
         constructor(t, n) {
-            var i, r, a;
-            super(t), this.transform = n, this.transform = Ce(n);
-            const s = (i = this.transform.as) !== null && i !== void 0 ? i : [void 0, void 0];
-            this.transform.as = [(r = s[0]) !== null && r !== void 0 ? r : "prob", (a = s[1]) !== null && a !== void 0 ? a : "value"]
+            super(t), this.transform = n, this.transform = ke(n);
+            const i = this.transform.as ?? [void 0, void 0];
+            this.transform.as = [i[0] ?? "prob", i[1] ?? "value"]
         }
         dependentFields() {
-            var t;
-            return new Set([this.transform.quantile, ...(t = this.transform.groupby) !== null && t !== void 0 ? t : []])
+            return new Set([this.transform.quantile, ...this.transform.groupby ?? []])
         }
         producedFields() {
             return new Set(this.transform.as)
         }
         hash() {
-            return `QuantileTransform ${Ie(this.transform)}`
+            return `QuantileTransform ${Ne(this.transform)}`
         }
         assemble() {
-            const t = this.transform,
-                {
-                    quantile: n
-                } = t,
-                i = $1e(t, ["quantile"]);
-            return Object.assign({
+            const {
+                quantile: t,
+                ...n
+            } = this.transform;
+            return {
                 type: "quantile",
-                field: n
-            }, i)
+                field: t,
+                ...n
+            }
         }
     }
-    var M1e = globalThis && globalThis.__rest || function(e, t) {
-        var n = {};
-        for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && t.indexOf(i) < 0 && (n[i] = e[i]);
-        if (e != null && typeof Object.getOwnPropertySymbols == "function")
-            for (var r = 0, i = Object.getOwnPropertySymbols(e); r < i.length; r++) t.indexOf(i[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, i[r]) && (n[i[r]] = e[i[r]]);
-        return n
-    };
-    class xy extends it {
+    class ny extends nt {
         clone() {
-            return new xy(null, Ce(this.transform))
+            return new ny(null, ke(this.transform))
         }
         constructor(t, n) {
-            var i, r, a;
-            super(t), this.transform = n, this.transform = Ce(n);
-            const s = (i = this.transform.as) !== null && i !== void 0 ? i : [void 0, void 0];
-            this.transform.as = [(r = s[0]) !== null && r !== void 0 ? r : n.on, (a = s[1]) !== null && a !== void 0 ? a : n.regression]
+            super(t), this.transform = n, this.transform = ke(n);
+            const i = this.transform.as ?? [void 0, void 0];
+            this.transform.as = [i[0] ?? n.on, i[1] ?? n.regression]
         }
         dependentFields() {
-            var t;
-            return new Set([this.transform.regression, this.transform.on, ...(t = this.transform.groupby) !== null && t !== void 0 ? t : []])
+            return new Set([this.transform.regression, this.transform.on, ...this.transform.groupby ?? []])
         }
         producedFields() {
             return new Set(this.transform.as)
         }
         hash() {
-            return `RegressionTransform ${Ie(this.transform)}`
+            return `RegressionTransform ${Ne(this.transform)}`
         }
         assemble() {
-            const t = this.transform,
-                {
-                    regression: n,
-                    on: i
-                } = t,
-                r = M1e(t, ["regression", "on"]);
-            return Object.assign({
+            const {
+                regression: t,
+                on: n,
+                ...i
+            } = this.transform;
+            return {
                 type: "regression",
-                x: i,
-                y: n
-            }, r)
+                x: n,
+                y: t,
+                ...i
+            }
         }
     }
-    class _y extends it {
+    class iy extends nt {
         clone() {
-            return new _y(null, Ce(this.transform))
+            return new iy(null, ke(this.transform))
         }
         constructor(t, n) {
             super(t), this.transform = n
         }
         addDimensions(t) {
-            var n;
-            this.transform.groupby = Gr(((n = this.transform.groupby) !== null && n !== void 0 ? n : []).concat(t), i => i)
+            this.transform.groupby = Pr((this.transform.groupby ?? []).concat(t), n => n)
         }
         producedFields() {}
         dependentFields() {
-            var t;
-            return new Set([this.transform.pivot, this.transform.value, ...(t = this.transform.groupby) !== null && t !== void 0 ? t : []])
+            return new Set([this.transform.pivot, this.transform.value, ...this.transform.groupby ?? []])
         }
         hash() {
-            return `PivotTransform ${Ie(this.transform)}`
+            return `PivotTransform ${Ne(this.transform)}`
         }
         assemble() {
             const {
                 pivot: t,
                 value: n,
                 groupby: i,
                 limit: r,
-                op: a
+                op: s
             } = this.transform;
-            return Object.assign(Object.assign(Object.assign({
+            return {
                 type: "pivot",
                 field: t,
-                value: n
-            }, r !== void 0 ? {
-                limit: r
-            } : {}), a !== void 0 ? {
-                op: a
-            } : {}), i !== void 0 ? {
-                groupby: i
-            } : {})
+                value: n,
+                ...r !== void 0 ? {
+                    limit: r
+                } : {},
+                ...s !== void 0 ? {
+                    op: s
+                } : {},
+                ...i !== void 0 ? {
+                    groupby: i
+                } : {}
+            }
         }
     }
-    class wy extends it {
+    class ry extends nt {
         clone() {
-            return new wy(null, Ce(this.transform))
+            return new ry(null, ke(this.transform))
         }
         constructor(t, n) {
             super(t), this.transform = n
         }
         dependentFields() {
             return new Set
         }
         producedFields() {
             return new Set
         }
         hash() {
-            return `SampleTransform ${Ie(this.transform)}`
+            return `SampleTransform ${Ne(this.transform)}`
         }
         assemble() {
             return {
                 type: "sample",
                 size: this.transform.sample
             }
         }
     }
 
-    function o8(e) {
+    function w8(e) {
         let t = 0;
 
         function n(i, r) {
-            var a;
-            if (i instanceof Al && !i.isGenerator && !yc(i.data) && (e.push(r), r = {
+            if (i instanceof yl && !i.isGenerator && !oc(i.data) && (e.push(r), r = {
                     name: null,
                     source: r.name,
                     transform: []
-                }), i instanceof mn && (i.parent instanceof Al && !r.source ? (r.format = Object.assign(Object.assign({}, (a = r.format) !== null && a !== void 0 ? a : {}), {
+                }), i instanceof gn && (i.parent instanceof yl && !r.source ? (r.format = {
+                    ...r.format ?? {},
                     parse: i.assembleFormatParse()
-                }), r.transform.push(...i.assembleTransforms(!0))) : r.transform.push(...i.assembleTransforms())), i instanceof Yc) {
+                }, r.transform.push(...i.assembleTransforms(!0))) : r.transform.push(...i.assembleTransforms())), i instanceof Pc) {
                 r.name || (r.name = `data_${t++}`), !r.source || r.transform.length > 0 ? (e.push(r), i.data = r.name) : i.data = r.source, e.push(...i.assemble());
                 return
             }
-            switch ((i instanceof Zd || i instanceof eg || i instanceof td || i instanceof Hc || i instanceof bc || i instanceof nd || i instanceof pr || i instanceof id || i instanceof Xc || i instanceof Jl || i instanceof yy || i instanceof my || i instanceof py || i instanceof vy || i instanceof by || i instanceof xy || i instanceof no || i instanceof wy || i instanceof _y) && r.transform.push(i.assemble()), (i instanceof Vr || i instanceof Xr || i instanceof sl || i instanceof Wa || i instanceof ju) && r.transform.push(...i.assemble()), i instanceof Ln && (r.source && r.transform.length === 0 ? i.setSource(r.source) : i.parent instanceof Ln ? i.setSource(r.name) : (r.name || (r.name = `data_${t++}`), i.setSource(r.name), i.numChildren() === 1 && (e.push(r), r = {
+            switch ((i instanceof Id || i instanceof zd || i instanceof Uh || i instanceof Nc || i instanceof lc || i instanceof Gh || i instanceof or || i instanceof Wh || i instanceof Lc || i instanceof Bl || i instanceof Z1 || i instanceof Q1 || i instanceof J1 || i instanceof ey || i instanceof ty || i instanceof ny || i instanceof qa || i instanceof ry || i instanceof iy) && r.transform.push(i.assemble()), (i instanceof Ur || i instanceof jr || i instanceof Xo || i instanceof Ps || i instanceof $u) && r.transform.push(...i.assemble()), i instanceof Dn && (r.source && r.transform.length === 0 ? i.setSource(r.source) : i.parent instanceof Dn ? i.setSource(r.name) : (r.name || (r.name = `data_${t++}`), i.setSource(r.name), i.numChildren() === 1 && (e.push(r), r = {
                     name: null,
                     source: r.name,
                     transform: []
                 }))), i.numChildren()) {
                 case 0:
-                    i instanceof Ln && (!r.source || r.transform.length > 0) && e.push(r);
+                    i instanceof Dn && (!r.source || r.transform.length > 0) && e.push(r);
                     break;
                 case 1:
                     n(i.children[0], r);
                     break;
                 default: {
                     r.name || (r.name = `data_${t++}`);
                     let s = r.name;
                     !r.source || r.transform.length > 0 ? e.push(r) : s = r.source;
-                    for (const o of i.children) n(o, {
+                    for (const a of i.children) n(a, {
                         name: null,
                         source: s,
                         transform: []
                     });
                     break
                 }
             }
         }
         return n
     }
 
-    function F1e(e) {
+    function Eme(e) {
         const t = [],
-            n = o8(t);
+            n = w8(t);
         for (const i of e.children) n(i, {
             source: e.name,
             name: null,
             transform: []
         });
         return t
     }
 
-    function D1e(e, t) {
-        var n, i;
-        const r = [],
-            a = o8(r);
-        let s = 0;
-        for (const l of e.sources) {
-            l.hasName() || (l.dataName = `source_${s++}`);
-            const u = l.assemble();
-            a(l, u)
+    function Cme(e, t) {
+        const n = [],
+            i = w8(n);
+        let r = 0;
+        for (const a of e.sources) {
+            a.hasName() || (a.dataName = `source_${r++}`);
+            const o = a.assemble();
+            i(a, o)
         }
-        for (const l of r) l.transform.length === 0 && delete l.transform;
-        let o = 0;
-        for (const [l, u] of r.entries())((n = u.transform) !== null && n !== void 0 ? n : []).length === 0 && !u.source && r.splice(o++, 0, r.splice(l, 1)[0]);
-        for (const l of r)
-            for (const u of (i = l.transform) !== null && i !== void 0 ? i : []) u.type === "lookup" && (u.from = e.outputNodes[u.from].getSource());
-        for (const l of r) l.name in t && (l.values = t[l.name]);
-        return r
+        for (const a of n) a.transform.length === 0 && delete a.transform;
+        let s = 0;
+        for (const [a, o] of n.entries())(o.transform ?? []).length === 0 && !o.source && n.splice(s++, 0, n.splice(a, 1)[0]);
+        for (const a of n)
+            for (const o of a.transform ?? []) o.type === "lookup" && (o.from = e.outputNodes[o.from].getSource());
+        for (const a of n) a.name in t && (a.values = t[a.name]);
+        return n
     }
 
-    function R1e(e) {
-        return e === "top" || e === "left" || fe(e) ? "header" : "footer"
+    function kme(e) {
+        return e === "top" || e === "left" || he(e) ? "header" : "footer"
     }
 
-    function P1e(e) {
-        for (const t of Ri) N1e(e, t);
-        f5(e, "x"), f5(e, "y")
+    function Ame(e) {
+        for (const t of Ti) $me(e, t);
+        C3(e, "x"), C3(e, "y")
     }
 
-    function N1e(e, t) {
-        var n;
+    function $me(e, t) {
+        var a;
         const {
-            facet: i,
-            config: r,
-            child: a,
+            facet: n,
+            config: i,
+            child: r,
             component: s
         } = e;
         if (e.channelHasField(t)) {
-            const o = i[t],
-                l = _c("title", null, r, t);
-            let u = Lu(o, r, {
+            const o = n[t],
+                l = cc("title", null, i, t);
+            let u = ku(o, i, {
                 allowDisabling: !0,
                 includeDefault: l === void 0 || !!l
             });
-            a.component.layoutHeaders[t].title && (u = q(u) ? u.join(", ") : u, u += ` / ${a.component.layoutHeaders[t].title}`, a.component.layoutHeaders[t].title = null);
-            const c = _c("labelOrient", o.header, r, t),
-                f = o.header !== null ? Tt((n = o.header) === null || n === void 0 ? void 0 : n.labels, r.header.labels, !0) : !1,
-                h = Pe(["bottom", "right"], c) ? "footer" : "header";
+            r.component.layoutHeaders[t].title && (u = W(u) ? u.join(", ") : u, u += ` / ${r.component.layoutHeaders[t].title}`, r.component.layoutHeaders[t].title = null);
+            const c = cc("labelOrient", o.header, i, t),
+                f = o.header !== null ? Ct((a = o.header) == null ? void 0 : a.labels, i.header.labels, !0) : !1,
+                h = Fe(["bottom", "right"], c) ? "footer" : "header";
             s.layoutHeaders[t] = {
                 title: o.header !== null ? u : null,
                 facetFieldDef: o,
-                [h]: t === "facet" ? [] : [l8(e, t, f)]
+                [h]: t === "facet" ? [] : [S8(e, t, f)]
             }
         }
     }
 
-    function l8(e, t, n) {
+    function S8(e, t, n) {
         const i = t === "row" ? "height" : "width";
         return {
             labels: n,
             sizeSignal: e.child.component.layoutSize.get(i) ? e.child.getSizeSignalRef(i) : void 0,
             axes: []
         }
     }
 
-    function f5(e, t) {
-        var n;
+    function C3(e, t) {
         const {
-            child: i
+            child: n
         } = e;
-        if (i.component.axes[t]) {
+        if (n.component.axes[t]) {
             const {
-                layoutHeaders: r,
-                resolve: a
+                layoutHeaders: i,
+                resolve: r
             } = e.component;
-            if (a.axis[t] = lC(a, t), a.axis[t] === "shared") {
+            if (r.axis[t] = AC(r, t), r.axis[t] === "shared") {
                 const s = t === "x" ? "column" : "row",
-                    o = r[s];
-                for (const l of i.component.axes[t]) {
-                    const u = R1e(l.get("orient"));
-                    (n = o[u]) !== null && n !== void 0 || (o[u] = [l8(e, s, !1)]);
-                    const c = th(l, "main", e.config, {
+                    a = i[s];
+                for (const o of n.component.axes[t]) {
+                    const l = kme(o.get("orient"));
+                    a[l] ?? (a[l] = [S8(e, s, !1)]);
+                    const u = Gf(o, "main", e.config, {
                         header: !0
                     });
-                    c && o[u][0].axes.push(c), l.mainExtracted = !0
+                    u && a[l][0].axes.push(u), o.mainExtracted = !0
                 }
             }
         }
     }
 
-    function L1e(e) {
-        mC(e), gm(e, "width"), gm(e, "height")
+    function Tme(e) {
+        NC(e), K0(e, "width"), K0(e, "height")
     }
 
-    function I1e(e) {
-        mC(e);
+    function Mme(e) {
+        NC(e);
         const t = e.layout.columns === 1 ? "width" : "childWidth",
             n = e.layout.columns === void 0 ? "height" : "childHeight";
-        gm(e, t), gm(e, n)
+        K0(e, t), K0(e, n)
     }
 
-    function mC(e) {
+    function NC(e) {
         for (const t of e.children) t.parseLayoutSize()
     }
 
-    function gm(e, t) {
-        var n;
-        const i = Rz(t),
-            r = W1(i),
-            a = e.component.resolve,
+    function K0(e, t) {
+        const n = Vz(t),
+            i = k1(n),
+            r = e.component.resolve,
             s = e.component.layoutSize;
-        let o;
-        for (const l of e.children) {
-            const u = l.component.layoutSize.getWithExplicit(i),
-                c = (n = a.scale[r]) !== null && n !== void 0 ? n : Nz(r, e);
-            if (c === "independent" && u.value === "step") {
-                o = void 0;
+        let a;
+        for (const o of e.children) {
+            const l = o.component.layoutSize.getWithExplicit(n),
+                u = r.scale[i] ?? Jz(i, e);
+            if (u === "independent" && l.value === "step") {
+                a = void 0;
                 break
             }
-            if (o) {
-                if (c === "independent" && o.value !== u.value) {
-                    o = void 0;
+            if (a) {
+                if (u === "independent" && a.value !== l.value) {
+                    a = void 0;
                     break
                 }
-                o = Qs(o, u, i, "")
-            } else o = u
+                a = Ua(a, l, n, "")
+            } else a = l
         }
-        if (o) {
-            for (const l of e.children) e.renameSignal(l.getName(i), e.getName(t)), l.component.layoutSize.set(i, "merged", !1);
-            s.setWithExplicit(t, o)
+        if (a) {
+            for (const o of e.children) e.renameSignal(o.getName(n), e.getName(t)), o.component.layoutSize.set(n, "merged", !1);
+            s.setWithExplicit(t, a)
         } else s.setWithExplicit(t, {
             explicit: !1,
             value: void 0
         })
     }
 
-    function j1e(e) {
+    function Ome(e) {
         const {
             size: t,
             component: n
         } = e;
-        for (const i of xa) {
-            const r = ui(i);
+        for (const i of cs) {
+            const r = oi(i);
             if (t[r]) {
-                const a = t[r];
-                n.layoutSize.set(r, aa(a) ? "step" : a, !0)
+                const s = t[r];
+                n.layoutSize.set(r, Jr(s) ? "step" : s, !0)
             } else {
-                const a = z1e(e, r);
-                n.layoutSize.set(r, a, !1)
+                const s = Fme(e, r);
+                n.layoutSize.set(r, s, !1)
             }
         }
     }
 
-    function z1e(e, t) {
+    function Fme(e, t) {
         const n = t === "width" ? "x" : "y",
             i = e.config,
             r = e.getScaleComponent(n);
         if (r) {
-            const a = r.get("type"),
-                s = r.get("range");
-            if (Vt(a)) {
-                const o = cm(i.view, t);
-                return _o(s) || aa(o) ? "step" : o
-            } else return Ax(i.view, t)
+            const s = r.get("type"),
+                a = r.get("range");
+            if (qt(s)) {
+                const o = H0(i.view, t);
+                return lo(a) || Jr(o) ? "step" : o
+            } else return Z2(i.view, t)
         } else {
-            if (e.hasProjection || e.mark === "arc") return Ax(i.view, t); {
-                const a = cm(i.view, t);
-                return aa(a) ? a.step : a
+            if (e.hasProjection || e.mark === "arc") return Z2(i.view, t); {
+                const s = H0(i.view, t);
+                return Jr(s) ? s.step : s
             }
         }
     }
 
-    function qx(e, t, n) {
-        return ne(t, Object.assign({
-            suffix: `by_${ne(e)}`
-        }, n ?? {}))
+    function dx(e, t, n) {
+        return ie(t, {
+            suffix: `by_${ie(e)}`,
+            ...n ?? {}
+        })
     }
-    class _h extends s8 {
+    class uh extends _8 {
         constructor(t, n, i, r) {
-            super(t, "facet", n, i, r, t.resolve), this.child = _C(t.spec, this, this.getName("child"), void 0, r), this.children = [this.child], this.facet = this.initFacet(t.facet)
+            super(t, "facet", n, i, r, t.resolve), this.child = BC(t.spec, this, this.getName("child"), void 0, r), this.children = [this.child], this.facet = this.initFacet(t.facet)
         }
         initFacet(t) {
-            if (!Xd(t)) return {
+            if (!Rd(t)) return {
                 facet: this.initFacetFieldDef(t, "facet")
             };
-            const n = Y(t),
+            const n = H(t),
                 i = {};
             for (const r of n) {
-                if (![Ga, Ua].includes(r)) {
-                    X(X1(r, "facet"));
+                if (![Fs, Rs].includes(r)) {
+                    X(T1(r, "facet"));
                     break
                 }
-                const a = t[r];
-                if (a.field === void 0) {
-                    X(xx(a, r));
+                const s = t[r];
+                if (s.field === void 0) {
+                    X(Y2(s, r));
                     break
                 }
-                i[r] = this.initFacetFieldDef(a, r)
+                i[r] = this.initFacetFieldDef(s, r)
             }
             return i
         }
         initFacetFieldDef(t, n) {
-            const i = jO(t, n);
-            return i.header ? i.header = Xn(i.header) : i.header === null && (i.header = null), i
+            const i = rC(t, n);
+            return i.header ? i.header = Hn(i.header) : i.header === null && (i.header = null), i
         }
         channelHasField(t) {
             return !!this.facet[t]
         }
         fieldDef(t) {
             return this.facet[t]
         }
         parseData() {
-            this.component.data = Sy(this), this.child.parseData()
+            this.component.data = sy(this), this.child.parseData()
         }
         parseLayoutSize() {
-            mC(this)
+            NC(this)
         }
         parseSelections() {
             this.child.parseSelections(), this.component.selection = this.child.component.selection
         }
         parseMarkGroup() {
             this.child.parseMarkGroup()
         }
         parseAxesAndHeaders() {
-            this.child.parseAxesAndHeaders(), P1e(this)
+            this.child.parseAxesAndHeaders(), Ame(this)
         }
         assembleSelectionTopLevelSignals(t) {
             return this.child.assembleSelectionTopLevelSignals(t)
         }
         assembleSignals() {
             return this.child.assembleSignals(), []
         }
         assembleSelectionData(t) {
             return this.child.assembleSelectionData(t)
         }
         getHeaderLayoutMixins() {
-            var t, n, i;
-            const r = {};
-            for (const a of Ri)
-                for (const s of sC) {
-                    const o = this.component.layoutHeaders[a],
-                        l = o[s],
+            const t = {};
+            for (const n of Ti)
+                for (const i of CC) {
+                    const r = this.component.layoutHeaders[n],
+                        s = r[i],
                         {
-                            facetFieldDef: u
-                        } = o;
-                    if (u) {
-                        const c = _c("titleOrient", u.header, this.config, a);
-                        if (["right", "bottom"].includes(c)) {
-                            const f = hy(a, c);
-                            (t = r.titleAnchor) !== null && t !== void 0 || (r.titleAnchor = {}), r.titleAnchor[f] = "end"
+                            facetFieldDef: a
+                        } = r;
+                    if (a) {
+                        const o = cc("titleOrient", a.header, this.config, n);
+                        if (["right", "bottom"].includes(o)) {
+                            const l = X1(n, o);
+                            t.titleAnchor ?? (t.titleAnchor = {}), t.titleAnchor[l] = "end"
                         }
                     }
-                    if (l != null && l[0]) {
-                        const c = a === "row" ? "height" : "width",
-                            f = s === "header" ? "headerBand" : "footerBand";
-                        a !== "facet" && !this.child.component.layoutSize.get(c) && ((n = r[f]) !== null && n !== void 0 || (r[f] = {}), r[f][a] = .5), o.title && ((i = r.offset) !== null && i !== void 0 || (r.offset = {}), r.offset[a === "row" ? "rowTitle" : "columnTitle"] = 10)
+                    if (s != null && s[0]) {
+                        const o = n === "row" ? "height" : "width",
+                            l = i === "header" ? "headerBand" : "footerBand";
+                        n !== "facet" && !this.child.component.layoutSize.get(o) && (t[l] ?? (t[l] = {}), t[l][n] = .5), r.title && (t.offset ?? (t.offset = {}), t.offset[n === "row" ? "rowTitle" : "columnTitle"] = 10)
                     }
                 }
-            return r
+            return t
         }
         assembleDefaultLayout() {
             const {
                 column: t,
                 row: n
             } = this.facet, i = t ? this.columnDistinctSignal() : n ? 1 : void 0;
             let r = "all";
-            return (!n && this.component.resolve.scale.x === "independent" || !t && this.component.resolve.scale.y === "independent") && (r = "none"), Object.assign(Object.assign(Object.assign({}, this.getHeaderLayoutMixins()), i ? {
-                columns: i
-            } : {}), {
+            return (!n && this.component.resolve.scale.x === "independent" || !t && this.component.resolve.scale.y === "independent") && (r = "none"), {
+                ...this.getHeaderLayoutMixins(),
+                ...i ? {
+                    columns: i
+                } : {},
                 bounds: "full",
                 align: r
-            })
+            }
         }
         assembleLayoutSignals() {
             return this.child.assembleLayoutSignals()
         }
         columnDistinctSignal() {
-            if (!(this.parent && this.parent instanceof _h)) return {
+            if (!(this.parent && this.parent instanceof uh)) return {
                 signal: `length(data('${this.getName("column_domain")}'))`
             }
         }
         assembleGroupStyle() {}
         assembleGroup(t) {
-            return this.parent && this.parent instanceof _h ? Object.assign(Object.assign({}, this.channelHasField("column") ? {
-                encode: {
-                    update: {
-                        columns: {
-                            field: ne(this.facet.column, {
-                                prefix: "distinct"
-                            })
+            return this.parent && this.parent instanceof uh ? {
+                ...this.channelHasField("column") ? {
+                    encode: {
+                        update: {
+                            columns: {
+                                field: ie(this.facet.column, {
+                                    prefix: "distinct"
+                                })
+                            }
                         }
                     }
-                }
-            } : {}), super.assembleGroup(t)) : super.assembleGroup(t)
+                } : {},
+                ...super.assembleGroup(t)
+            } : super.assembleGroup(t)
         }
         getCardinalityAggregateForChild() {
             const t = [],
                 n = [],
                 i = [];
-            if (this.child instanceof _h) {
+            if (this.child instanceof uh) {
                 if (this.child.channelHasField("column")) {
-                    const r = ne(this.child.facet.column);
+                    const r = ie(this.child.facet.column);
                     t.push(r), n.push("distinct"), i.push(`distinct_${r}`)
                 }
             } else
-                for (const r of xa) {
-                    const a = this.child.component.scales[r];
-                    if (a && !a.merged) {
-                        const s = a.get("type"),
-                            o = a.get("range");
-                        if (Vt(s) && _o(o)) {
-                            const l = gy(this.child, r),
-                                u = dC(l);
-                            u ? (t.push(u), n.push("distinct"), i.push(`distinct_${u}`)) : X(dO(r))
+                for (const r of cs) {
+                    const s = this.child.component.scales[r];
+                    if (s && !s.merged) {
+                        const a = s.get("type"),
+                            o = s.get("range");
+                        if (qt(a) && lo(o)) {
+                            const l = K1(this.child, r),
+                                u = FC(l);
+                            u ? (t.push(u), n.push("distinct"), i.push(`distinct_${u}`)) : X(RE(r))
                         }
                     }
                 }
             return {
                 fields: t,
                 ops: n,
                 as: i
@@ -49544,976 +49894,1062 @@
             const {
                 name: t,
                 data: n
             } = this.component.data.facetRoot, {
                 row: i,
                 column: r
             } = this.facet, {
-                fields: a,
-                ops: s,
+                fields: s,
+                ops: a,
                 as: o
             } = this.getCardinalityAggregateForChild(), l = [];
-            for (const c of Ri) {
+            for (const c of Ti) {
                 const f = this.facet[c];
                 if (f) {
-                    l.push(ne(f));
+                    l.push(ie(f));
                     const {
                         bin: h,
                         sort: d
                     } = f;
-                    if (lt(h) && l.push(ne(f, {
+                    if (ot(h) && l.push(ie(f, {
                             binSuffix: "end"
-                        })), Yr(d)) {
+                        })), Br(d)) {
                         const {
                             field: g,
-                            op: p = Z1
-                        } = d, m = qx(f, d);
-                        i && r ? (a.push(m), s.push("max"), o.push(m)) : (a.push(g), s.push(p), o.push(m))
-                    } else if (q(d)) {
-                        const g = xc(f, c);
-                        a.push(g), s.push("max"), o.push(g)
+                            op: p = N1
+                        } = d, m = dx(f, d);
+                        i && r ? (s.push(m), a.push("max"), o.push(m)) : (s.push(g), a.push(p), o.push(m))
+                    } else if (W(d)) {
+                        const g = uc(f, c);
+                        s.push(g), a.push("max"), o.push(g)
                     }
                 }
             }
             const u = !!i && !!r;
-            return Object.assign({
+            return {
                 name: t,
                 data: n,
-                groupby: l
-            }, u || a.length > 0 ? {
-                aggregate: Object.assign(Object.assign({}, u ? {
-                    cross: u
-                } : {}), a.length ? {
-                    fields: a,
-                    ops: s,
-                    as: o
-                } : {})
-            } : {})
+                groupby: l,
+                ...u || s.length > 0 ? {
+                    aggregate: {
+                        ...u ? {
+                            cross: u
+                        } : {},
+                        ...s.length ? {
+                            fields: s,
+                            ops: a,
+                            as: o
+                        } : {}
+                    }
+                } : {}
+            }
         }
         facetSortFields(t) {
             const {
                 facet: n
             } = this, i = n[t];
-            return i ? Yr(i.sort) ? [qx(i, i.sort, {
+            return i ? Br(i.sort) ? [dx(i, i.sort, {
                 expr: "datum"
-            })] : q(i.sort) ? [xc(i, t, {
+            })] : W(i.sort) ? [uc(i, t, {
                 expr: "datum"
-            })] : [ne(i, {
+            })] : [ie(i, {
                 expr: "datum"
             })] : []
         }
         facetSortOrder(t) {
             const {
                 facet: n
             } = this, i = n[t];
             if (i) {
                 const {
                     sort: r
                 } = i;
-                return [(Yr(r) ? r.order : !q(r) && r) || "ascending"]
+                return [(Br(r) ? r.order : !W(r) && r) || "ascending"]
             }
             return []
         }
         assembleLabelTitle() {
-            var t;
+            var r;
             const {
-                facet: n,
-                config: i
+                facet: t,
+                config: n
             } = this;
-            if (n.facet) return Ix(n.facet, "facet", i);
-            const r = {
+            if (t.facet) return ox(t.facet, "facet", n);
+            const i = {
                 row: ["top", "bottom"],
                 column: ["left", "right"]
             };
-            for (const a of aC)
-                if (n[a]) {
-                    const s = _c("labelOrient", (t = n[a]) === null || t === void 0 ? void 0 : t.header, i, a);
-                    if (r[a].includes(s)) return Ix(n[a], a, i)
+            for (const s of EC)
+                if (t[s]) {
+                    const a = cc("labelOrient", (r = t[s]) == null ? void 0 : r.header, n, s);
+                    if (i[s].includes(a)) return ox(t[s], s, n)
                 }
         }
         assembleMarks() {
             const {
                 child: t
-            } = this, n = this.component.data.facetRoot, i = F1e(n), r = t.assembleGroupEncodeEntry(!1), a = this.assembleLabelTitle() || t.assembleTitle(), s = t.assembleGroupStyle();
-            return [Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({
+            } = this, n = this.component.data.facetRoot, i = Eme(n), r = t.assembleGroupEncodeEntry(!1), s = this.assembleLabelTitle() || t.assembleTitle(), a = t.assembleGroupStyle();
+            return [{
                 name: this.getName("cell"),
-                type: "group"
-            }, a ? {
-                title: a
-            } : {}), s ? {
-                style: s
-            } : {}), {
+                type: "group",
+                ...s ? {
+                    title: s
+                } : {},
+                ...a ? {
+                    style: a
+                } : {},
                 from: {
                     facet: this.assembleFacet()
                 },
                 sort: {
-                    field: Ri.map(l => this.facetSortFields(l)).flat(),
-                    order: Ri.map(l => this.facetSortOrder(l)).flat()
-                }
-            }), i.length > 0 ? {
-                data: i
-            } : {}), r ? {
-                encode: {
-                    update: r
-                }
-            } : {}), t.assembleGroup(Upe(this, [])))]
+                    field: Ti.map(l => this.facetSortFields(l)).flat(),
+                    order: Ti.map(l => this.facetSortOrder(l)).flat()
+                },
+                ...i.length > 0 ? {
+                    data: i
+                } : {},
+                ...r ? {
+                    encode: {
+                        update: r
+                    }
+                } : {},
+                ...t.assembleGroup(Gge(this, []))
+            }]
         }
         getMapping() {
             return this.facet
         }
     }
 
-    function B1e(e, t) {
+    function Rme(e, t) {
         const {
             row: n,
             column: i
         } = t;
         if (n && i) {
             let r = null;
-            for (const a of [n, i])
-                if (Yr(a.sort)) {
+            for (const s of [n, i])
+                if (Br(s.sort)) {
                     const {
-                        field: s,
-                        op: o = Z1
-                    } = a.sort;
-                    e = r = new Jl(e, {
+                        field: a,
+                        op: o = N1
+                    } = s.sort;
+                    e = r = new Bl(e, {
                         joinaggregate: [{
                             op: o,
-                            field: s,
-                            as: qx(a, a.sort, {
+                            field: a,
+                            as: dx(s, s.sort, {
                                 forAs: !0
                             })
                         }],
-                        groupby: [ne(a)]
+                        groupby: [ie(s)]
                     })
                 } return r
         }
         return null
     }
 
-    function u8(e, t) {
-        var n, i, r, a;
-        for (const s of t) {
-            const o = s.data;
-            if (e.name && s.hasName() && e.name !== s.dataName) continue;
-            const l = (n = e.format) === null || n === void 0 ? void 0 : n.mesh,
-                u = (i = o.format) === null || i === void 0 ? void 0 : i.feature;
+    function E8(e, t) {
+        var n, i, r, s;
+        for (const a of t) {
+            const o = a.data;
+            if (e.name && a.hasName() && e.name !== a.dataName) continue;
+            const l = (n = e.format) == null ? void 0 : n.mesh,
+                u = (i = o.format) == null ? void 0 : i.feature;
             if (l && u) continue;
-            const c = (r = e.format) === null || r === void 0 ? void 0 : r.feature;
+            const c = (r = e.format) == null ? void 0 : r.feature;
             if ((c || u) && c !== u) continue;
-            const f = (a = o.format) === null || a === void 0 ? void 0 : a.mesh;
+            const f = (s = o.format) == null ? void 0 : s.mesh;
             if (!((l || f) && l !== f)) {
-                if (Zh(e) && Zh(o)) {
-                    if (Br(e.values, o.values)) return s
-                } else if (yc(e) && yc(o)) {
-                    if (e.url === o.url) return s
-                } else if (nz(e) && e.name === s.dataName) return s
+                if (Bh(e) && Bh(o)) {
+                    if (Nr(e.values, o.values)) return a
+                } else if (oc(e) && oc(o)) {
+                    if (e.url === o.url) return a
+                } else if (pz(e) && e.name === a.dataName) return a
             }
         }
         return null
     }
 
-    function G1e(e, t) {
+    function Dme(e, t) {
         if (e.data || !e.parent) {
             if (e.data === null) {
-                const i = new Al({
+                const i = new yl({
                     values: []
                 });
                 return t.push(i), i
             }
-            const n = u8(e.data, t);
-            if (n) return Is(e.data) || (n.data.format = tj({}, e.data.format, n.data.format)), !n.hasName() && e.data.name && (n.dataName = e.data.name), n; {
-                const i = new Al(e.data);
+            const n = E8(e.data, t);
+            if (n) return $a(e.data) || (n.data.format = dI({}, e.data.format, n.data.format)), !n.hasName() && e.data.name && (n.dataName = e.data.name), n; {
+                const i = new yl(e.data);
                 return t.push(i), i
             }
         } else return e.parent.component.data.facetRoot ? e.parent.component.data.facetRoot : e.parent.component.data.main
     }
 
-    function U1e(e, t, n) {
-        var i, r;
-        let a = 0;
-        for (const s of t.transforms) {
-            let o, l;
-            if (Epe(s)) l = e = new bc(e, s), o = "derived";
-            else if (QO(s)) {
-                const u = Ame(s);
-                l = e = (i = mn.makeWithAncestors(e, {}, u, n)) !== null && i !== void 0 ? i : e, e = new Hc(e, t, s.filter)
-            } else if (K6(s)) l = e = Vr.makeFromTransform(e, s, t), o = "number";
-            else if (Cpe(s)) o = "date", n.getWithExplicit(s.field).value === void 0 && (e = new mn(e, {
-                [s.field]: o
-            }), n.set(s.field, o, !1)), l = e = Xr.makeFromTransform(e, s);
-            else if (kpe(s)) l = e = pr.makeFromTransform(e, s), o = "number", rC(t) && (e = new no(e));
-            else if (V6(s)) l = e = id.make(e, t, s, a++), o = "derived";
-            else if (_pe(s)) l = e = new Xc(e, s), o = "number";
-            else if (wpe(s)) l = e = new Jl(e, s), o = "number";
-            else if (Ape(s)) l = e = Wa.makeFromTransform(e, s), o = "derived";
-            else if (Tpe(s)) l = e = new yy(e, s), o = "derived";
-            else if (Spe(s)) l = e = new my(e, s), o = "derived";
-            else if (ppe(s)) l = e = new _y(e, s), o = "derived";
-            else if (xpe(s)) e = new wy(e, s);
-            else if (Ope(s)) l = e = sl.makeFromTransform(e, s), o = "derived";
-            else if (mpe(s)) l = e = new py(e, s), o = "derived";
-            else if (ype(s)) l = e = new by(e, s), o = "derived";
-            else if (vpe(s)) l = e = new xy(e, s), o = "derived";
-            else if (bpe(s)) l = e = new vy(e, s), o = "derived";
+    function Nme(e, t, n) {
+        let i = 0;
+        for (const r of t.transforms) {
+            let s, a;
+            if (Ege(r)) a = e = new lc(e, r), s = "derived";
+            else if (yC(r)) {
+                const o = k0e(r);
+                a = e = gn.makeWithAncestors(e, {}, o, n) ?? e, e = new Nc(e, t, r.filter)
+            } else if (cz(r)) a = e = Ur.makeFromTransform(e, r, t), s = "number";
+            else if (kge(r)) s = "date", n.getWithExplicit(r.field).value === void 0 && (e = new gn(e, {
+                [r.field]: s
+            }), n.set(r.field, s, !1)), a = e = jr.makeFromTransform(e, r);
+            else if (Age(r)) a = e = or.makeFromTransform(e, r), s = "number", SC(t) && (e = new qa(e));
+            else if (uz(r)) a = e = Wh.make(e, t, r, i++), s = "derived";
+            else if (_ge(r)) a = e = new Lc(e, r), s = "number";
+            else if (wge(r)) a = e = new Bl(e, r), s = "number";
+            else if ($ge(r)) a = e = Ps.makeFromTransform(e, r), s = "derived";
+            else if (Tge(r)) a = e = new Z1(e, r), s = "derived";
+            else if (Sge(r)) a = e = new Q1(e, r), s = "derived";
+            else if (pge(r)) a = e = new iy(e, r), s = "derived";
+            else if (xge(r)) e = new ry(e, r);
+            else if (Cge(r)) a = e = Xo.makeFromTransform(e, r), s = "derived";
+            else if (mge(r)) a = e = new J1(e, r), s = "derived";
+            else if (yge(r)) a = e = new ty(e, r), s = "derived";
+            else if (vge(r)) a = e = new ny(e, r), s = "derived";
+            else if (bge(r)) a = e = new ey(e, r), s = "derived";
             else {
-                X(Xfe(s));
+                X(efe(r));
                 continue
             }
-            if (l && o !== void 0)
-                for (const u of (r = l.producedFields()) !== null && r !== void 0 ? r : []) n.set(u, o, !1)
+            if (a && s !== void 0)
+                for (const o of a.producedFields() ?? []) n.set(o, s, !1)
         }
         return e
     }
 
-    function Sy(e) {
-        var t, n, i, r, a, s, o, l, u, c;
-        let f = G1e(e, e.component.data.sources);
-        const {
-            outputNodes: h,
-            outputNodeRefCounts: d
-        } = e.component.data, g = e.data, m = !(g && (Is(g) || yc(g) || Zh(g))) && e.parent ? e.parent.component.data.ancestorParse.clone() : new zpe;
-        Is(g) ? (iz(g) ? f = new eg(f, g.sequence) : ZO(g) && (f = new Zd(f, g.graticule)), m.parseNothing = !0) : ((t = g == null ? void 0 : g.format) === null || t === void 0 ? void 0 : t.parse) === null && (m.parseNothing = !0), f = (n = mn.makeExplicit(f, e, m)) !== null && n !== void 0 ? n : f, f = new no(f);
-        const y = e.parent && Vc(e.parent);
-        (kt(e) || mr(e)) && y && (f = (i = Vr.makeFromEncoding(f, e)) !== null && i !== void 0 ? i : f), e.transforms.length > 0 && (f = U1e(f, e, m));
-        const v = $me(e),
-            b = Tme(e);
-        f = (r = mn.makeWithAncestors(f, {}, Object.assign(Object.assign({}, v), b), m)) !== null && r !== void 0 ? r : f, kt(e) && (f = ju.parseAll(f, e), f = nd.parseAll(f, e)), (kt(e) || mr(e)) && (y || (f = (a = Vr.makeFromEncoding(f, e)) !== null && a !== void 0 ? a : f), f = (s = Xr.makeFromEncoding(f, e)) !== null && s !== void 0 ? s : f, f = bc.parseAllForSortIndex(f, e));
-        const x = e.getDataName(st.Raw),
-            _ = new Ln(f, x, st.Raw, d);
-        if (h[x] = _, f = _, kt(e)) {
-            const k = pr.makeFromEncoding(f, e);
-            k && (f = k, rC(e) && (f = new no(f))), f = (o = sl.makeFromEncoding(f, e)) !== null && o !== void 0 ? o : f, f = (l = Wa.makeFromEncoding(f, e)) !== null && l !== void 0 ? l : f
-        }
-        kt(e) && (f = (u = td.make(f, e)) !== null && u !== void 0 ? u : f);
-        const S = e.getDataName(st.Main),
-            w = new Ln(f, S, st.Main, d);
-        h[S] = w, f = w, kt(e) && E0e(e, w);
-        let O = null;
-        if (mr(e)) {
-            const k = e.getName("facet");
-            f = (c = B1e(f, e.facet)) !== null && c !== void 0 ? c : f, O = new Yc(f, e, k, w.getSource()), h[k] = O
-        }
-        return Object.assign(Object.assign({}, e.component.data), {
-            outputNodes: h,
-            outputNodeRefCounts: d,
-            raw: _,
-            main: w,
-            facetRoot: O,
-            ancestorParse: m
-        })
+    function sy(e) {
+        var p;
+        let t = Dme(e, e.component.data.sources);
+        const {
+            outputNodes: n,
+            outputNodeRefCounts: i
+        } = e.component.data, r = e.data, a = !(r && ($a(r) || oc(r) || Bh(r))) && e.parent ? e.parent.component.data.ancestorParse.clone() : new jge;
+        $a(r) ? (mz(r) ? t = new zd(t, r.sequence) : vC(r) && (t = new Id(t, r.graticule)), a.parseNothing = !0) : ((p = r == null ? void 0 : r.format) == null ? void 0 : p.parse) === null && (a.parseNothing = !0), t = gn.makeExplicit(t, e, a) ?? t, t = new qa(t);
+        const o = e.parent && Ic(e.parent);
+        (Et(e) || lr(e)) && o && (t = Ur.makeFromEncoding(t, e) ?? t), e.transforms.length > 0 && (t = Nme(t, e, a));
+        const l = $0e(e),
+            u = A0e(e);
+        t = gn.makeWithAncestors(t, {}, {
+            ...l,
+            ...u
+        }, a) ?? t, Et(e) && (t = $u.parseAll(t, e), t = Gh.parseAll(t, e)), (Et(e) || lr(e)) && (o || (t = Ur.makeFromEncoding(t, e) ?? t), t = jr.makeFromEncoding(t, e) ?? t, t = lc.parseAllForSortIndex(t, e));
+        const c = e.getDataName(st.Raw),
+            f = new Dn(t, c, st.Raw, i);
+        if (n[c] = f, t = f, Et(e)) {
+            const m = or.makeFromEncoding(t, e);
+            m && (t = m, SC(e) && (t = new qa(t))), t = Xo.makeFromEncoding(t, e) ?? t, t = Ps.makeFromEncoding(t, e) ?? t
+        }
+        Et(e) && (t = Uh.make(t, e) ?? t);
+        const h = e.getDataName(st.Main),
+            d = new Dn(t, h, st.Main, i);
+        n[h] = d, t = d, Et(e) && Spe(e, d);
+        let g = null;
+        if (lr(e)) {
+            const m = e.getName("facet");
+            t = Rme(t, e.facet) ?? t, g = new Pc(t, e, m, d.getSource()), n[m] = g
+        }
+        return {
+            ...e.component.data,
+            outputNodes: n,
+            outputNodeRefCounts: i,
+            raw: f,
+            main: d,
+            facetRoot: g,
+            ancestorParse: a
+        }
     }
-    class q1e extends pC {
+    class Pme extends DC {
         constructor(t, n, i, r) {
-            var a, s, o, l;
-            super(t, "concat", n, i, r, t.resolve), (((s = (a = t.resolve) === null || a === void 0 ? void 0 : a.axis) === null || s === void 0 ? void 0 : s.x) === "shared" || ((l = (o = t.resolve) === null || o === void 0 ? void 0 : o.axis) === null || l === void 0 ? void 0 : l.y) === "shared") && X(Wfe), this.children = this.getChildren(t).map((u, c) => _C(u, this, this.getName(`concat_${c}`), void 0, r))
+            var s, a, o, l;
+            super(t, "concat", n, i, r, t.resolve), (((a = (s = t.resolve) == null ? void 0 : s.axis) == null ? void 0 : a.x) === "shared" || ((l = (o = t.resolve) == null ? void 0 : o.axis) == null ? void 0 : l.y) === "shared") && X(Jce), this.children = this.getChildren(t).map((u, c) => BC(u, this, this.getName(`concat_${c}`), void 0, r))
         }
         parseData() {
-            this.component.data = Sy(this);
+            this.component.data = sy(this);
             for (const t of this.children) t.parseData()
         }
         parseSelections() {
             this.component.selection = {};
             for (const t of this.children) {
                 t.parseSelections();
-                for (const n of Y(t.component.selection)) this.component.selection[n] = t.component.selection[n]
+                for (const n of H(t.component.selection)) this.component.selection[n] = t.component.selection[n]
             }
         }
         parseMarkGroup() {
             for (const t of this.children) t.parseMarkGroup()
         }
         parseAxesAndHeaders() {
             for (const t of this.children) t.parseAxesAndHeaders()
         }
         getChildren(t) {
-            return oy(t) ? t.vconcat : KO(t) ? t.hconcat : t.concat
+            return G1(t) ? t.vconcat : pC(t) ? t.hconcat : t.concat
         }
         parseLayoutSize() {
-            I1e(this)
+            Mme(this)
         }
         parseAxisGroup() {
             return null
         }
         assembleSelectionTopLevelSignals(t) {
             return this.children.reduce((n, i) => i.assembleSelectionTopLevelSignals(n), t)
         }
         assembleSignals() {
             return this.children.forEach(t => t.assembleSignals()), []
         }
         assembleLayoutSignals() {
-            const t = oC(this);
+            const t = kC(this);
             for (const n of this.children) t.push(...n.assembleLayoutSignals());
             return t
         }
         assembleSelectionData(t) {
             return this.children.reduce((n, i) => i.assembleSelectionData(n), t)
         }
         assembleMarks() {
             return this.children.map(t => {
                 const n = t.assembleTitle(),
                     i = t.assembleGroupStyle(),
                     r = t.assembleGroupEncodeEntry(!1);
-                return Object.assign(Object.assign(Object.assign(Object.assign({
+                return {
                     type: "group",
-                    name: t.getName("group")
-                }, n ? {
-                    title: n
-                } : {}), i ? {
-                    style: i
-                } : {}), r ? {
-                    encode: {
-                        update: r
-                    }
-                } : {}), t.assembleGroup())
+                    name: t.getName("group"),
+                    ...n ? {
+                        title: n
+                    } : {},
+                    ...i ? {
+                        style: i
+                    } : {},
+                    ...r ? {
+                        encode: {
+                            update: r
+                        }
+                    } : {},
+                    ...t.assembleGroup()
+                }
             })
         }
         assembleGroupStyle() {}
         assembleDefaultLayout() {
             const t = this.layout.columns;
-            return Object.assign(Object.assign({}, t != null ? {
-                columns: t
-            } : {}), {
+            return {
+                ...t != null ? {
+                    columns: t
+                } : {},
                 bounds: "full",
                 align: "each"
-            })
+            }
         }
     }
 
-    function W1e(e) {
+    function Lme(e) {
         return e === !1 || e === null
     }
-    const H1e = Object.assign(Object.assign({
+    const Ime = {
             disable: 1,
             gridScale: 1,
-            scale: 1
-        }, x6), {
+            scale: 1,
+            ...P6,
             labelExpr: 1,
             encode: 1
-        }),
-        c8 = Y(H1e);
-    class yC extends ls {
+        },
+        C8 = H(Ime);
+    class PC extends ea {
         constructor(t = {}, n = {}, i = !1) {
             super(), this.explicit = t, this.implicit = n, this.mainExtracted = i
         }
         clone() {
-            return new yC(Ce(this.explicit), Ce(this.implicit), this.mainExtracted)
+            return new PC(ke(this.explicit), ke(this.implicit), this.mainExtracted)
         }
         hasAxisPart(t) {
-            return t === "axis" ? !0 : t === "grid" || t === "title" ? !!this.get(t) : !W1e(this.get(t))
+            return t === "axis" ? !0 : t === "grid" || t === "title" ? !!this.get(t) : !Lme(this.get(t))
         }
         hasOrientSignalRef() {
-            return fe(this.explicit.orient)
+            return he(this.explicit.orient)
         }
     }
 
-    function Y1e(e, t, n) {
-        var i;
+    function zme(e, t, n) {
         const {
-            encoding: r,
-            config: a
-        } = e, s = (i = Rt(r[t])) !== null && i !== void 0 ? i : Rt(r[ba(t)]), o = e.axis(t) || {}, {
-            format: l,
-            formatType: u
-        } = o;
-        if (Ol(u)) return Object.assign({
-            text: hr({
+            encoding: i,
+            config: r
+        } = e, s = Mt(i[t]) ?? Mt(i[us(t)]), a = e.axis(t) || {}, {
+            format: o,
+            formatType: l
+        } = a;
+        if (gl(l)) return {
+            text: rr({
                 fieldOrDatumDef: s,
                 field: "datum.value",
-                format: l,
-                formatType: u,
-                config: a
-            })
-        }, n);
-        if (l === void 0 && u === void 0 && a.customFormatTypes) {
-            if (gc(s) === "quantitative") {
-                if (pc(s) && s.stack === "normalize" && a.normalizedNumberFormatType) return Object.assign({
-                    text: hr({
+                format: o,
+                formatType: l,
+                config: r
+            }),
+            ...n
+        };
+        if (o === void 0 && l === void 0 && r.customFormatTypes) {
+            if (rc(s) === "quantitative") {
+                if (sc(s) && s.stack === "normalize" && r.normalizedNumberFormatType) return {
+                    text: rr({
                         fieldOrDatumDef: s,
                         field: "datum.value",
-                        format: a.normalizedNumberFormat,
-                        formatType: a.normalizedNumberFormatType,
-                        config: a
-                    })
-                }, n);
-                if (a.numberFormatType) return Object.assign({
-                    text: hr({
+                        format: r.normalizedNumberFormat,
+                        formatType: r.normalizedNumberFormatType,
+                        config: r
+                    }),
+                    ...n
+                };
+                if (r.numberFormatType) return {
+                    text: rr({
                         fieldOrDatumDef: s,
                         field: "datum.value",
-                        format: a.numberFormat,
-                        formatType: a.numberFormatType,
-                        config: a
-                    })
-                }, n)
+                        format: r.numberFormat,
+                        formatType: r.numberFormatType,
+                        config: r
+                    }),
+                    ...n
+                }
             }
-            if (gc(s) === "temporal" && a.timeFormatType && J(s) && !s.timeUnit) return Object.assign({
-                text: hr({
+            if (rc(s) === "temporal" && r.timeFormatType && K(s) && !s.timeUnit) return {
+                text: rr({
                     fieldOrDatumDef: s,
                     field: "datum.value",
-                    format: a.timeFormat,
-                    formatType: a.timeFormatType,
-                    config: a
-                })
-            }, n)
+                    format: r.timeFormat,
+                    formatType: r.timeFormatType,
+                    config: r
+                }),
+                ...n
+            }
         }
         return n
     }
 
-    function X1e(e) {
-        return xa.reduce((t, n) => (e.component.scales[n] && (t[n] = [tye(n, e)]), t), {})
+    function Bme(e) {
+        return cs.reduce((t, n) => (e.component.scales[n] && (t[n] = [Yme(n, e)]), t), {})
     }
-    const V1e = {
+    const jme = {
         bottom: "top",
         top: "bottom",
         left: "right",
         right: "left"
     };
 
-    function K1e(e) {
-        var t;
+    function Ume(e) {
         const {
-            axes: n,
-            resolve: i
-        } = e.component, r = {
+            axes: t,
+            resolve: n
+        } = e.component, i = {
             top: 0,
             bottom: 0,
             right: 0,
             left: 0
         };
-        for (const a of e.children) {
-            a.parseAxesAndHeaders();
-            for (const s of Y(a.component.axes)) i.axis[s] = lC(e.component.resolve, s), i.axis[s] === "shared" && (n[s] = J1e(n[s], a.component.axes[s]), n[s] || (i.axis[s] = "independent", delete n[s]))
+        for (const r of e.children) {
+            r.parseAxesAndHeaders();
+            for (const s of H(r.component.axes)) n.axis[s] = AC(e.component.resolve, s), n.axis[s] === "shared" && (t[s] = Gme(t[s], r.component.axes[s]), t[s] || (n.axis[s] = "independent", delete t[s]))
         }
-        for (const a of xa) {
+        for (const r of cs) {
             for (const s of e.children)
-                if (s.component.axes[a]) {
-                    if (i.axis[a] === "independent") {
-                        n[a] = ((t = n[a]) !== null && t !== void 0 ? t : []).concat(s.component.axes[a]);
-                        for (const o of s.component.axes[a]) {
+                if (s.component.axes[r]) {
+                    if (n.axis[r] === "independent") {
+                        t[r] = (t[r] ?? []).concat(s.component.axes[r]);
+                        for (const a of s.component.axes[r]) {
                             const {
-                                value: l,
-                                explicit: u
-                            } = o.getWithExplicit("orient");
-                            if (!fe(l)) {
-                                if (r[l] > 0 && !u) {
-                                    const c = V1e[l];
-                                    r[l] > r[c] && o.set("orient", c, !1)
+                                value: o,
+                                explicit: l
+                            } = a.getWithExplicit("orient");
+                            if (!he(o)) {
+                                if (i[o] > 0 && !l) {
+                                    const u = jme[o];
+                                    i[o] > i[u] && a.set("orient", u, !1)
                                 }
-                                r[l]++
+                                i[o]++
                             }
                         }
                     }
-                    delete s.component.axes[a]
-                } if (i.axis[a] === "independent" && n[a] && n[a].length > 1)
-                for (const s of n[a]) s.get("grid") && !s.explicit.grid && (s.implicit.grid = !1)
+                    delete s.component.axes[r]
+                } if (n.axis[r] === "independent" && t[r] && t[r].length > 1)
+                for (const s of t[r]) s.get("grid") && !s.explicit.grid && (s.implicit.grid = !1)
         }
     }
 
-    function J1e(e, t) {
+    function Gme(e, t) {
         if (e) {
             if (e.length !== t.length) return;
             const n = e.length;
             for (let i = 0; i < n; i++) {
                 const r = e[i],
-                    a = t[i];
-                if (!!r != !!a) return;
-                if (r && a) {
-                    const s = r.getWithExplicit("orient"),
-                        o = a.getWithExplicit("orient");
-                    if (s.explicit && o.explicit && s.value !== o.value) return;
-                    e[i] = Q1e(r, a)
+                    s = t[i];
+                if (!!r != !!s) return;
+                if (r && s) {
+                    const a = r.getWithExplicit("orient"),
+                        o = s.getWithExplicit("orient");
+                    if (a.explicit && o.explicit && a.value !== o.value) return;
+                    e[i] = Wme(r, s)
                 }
             }
         } else return t.map(n => n.clone());
         return e
     }
 
-    function Q1e(e, t) {
-        for (const n of c8) {
-            const i = Qs(e.getWithExplicit(n), t.getWithExplicit(n), n, "axis", (r, a) => {
+    function Wme(e, t) {
+        for (const n of C8) {
+            const i = Ua(e.getWithExplicit(n), t.getWithExplicit(n), n, "axis", (r, s) => {
                 switch (n) {
                     case "title":
-                        return Aj(r, a);
+                        return UI(r, s);
                     case "gridScale":
                         return {
-                            explicit: r.explicit, value: Tt(r.value, a.value)
+                            explicit: r.explicit, value: Ct(r.value, s.value)
                         }
                 }
-                return uy(r, a, n, "axis")
+                return q1(r, s, n, "axis")
             });
             e.setWithExplicit(n, i)
         }
         return e
     }
 
-    function Z1e(e, t, n, i, r) {
+    function qme(e, t, n, i, r) {
         if (t === "disable") return n !== void 0;
         switch (n = n || {}, t) {
             case "titleAngle":
             case "labelAngle":
-                return e === (fe(n.labelAngle) ? n.labelAngle : Jh(n.labelAngle));
+                return e === (he(n.labelAngle) ? n.labelAngle : zh(n.labelAngle));
             case "values":
                 return !!n.values;
             case "encode":
                 return !!n.encoding || !!n.labelAngle;
             case "title":
-                if (e === Tz(i, r)) return !0
+                if (e === Wz(i, r)) return !0
         }
         return e === n[t]
     }
-    const eye = new Set(["grid", "translate", "format", "formatType", "orient", "labelExpr", "tickCount", "position", "tickMinStep"]);
+    const Hme = new Set(["grid", "translate", "format", "formatType", "orient", "labelExpr", "tickCount", "position", "tickMinStep"]);
 
-    function tye(e, t) {
-        var n, i, r;
-        let a = t.axis(e);
-        const s = new yC,
-            o = Rt(t.encoding[e]),
+    function Yme(e, t) {
+        var y, v;
+        let n = t.axis(e);
+        const i = new PC,
+            r = Mt(t.encoding[e]),
             {
-                mark: l,
-                config: u
+                mark: s,
+                config: a
             } = t,
-            c = (a == null ? void 0 : a.orient) || ((n = u[e === "x" ? "axisX" : "axisY"]) === null || n === void 0 ? void 0 : n.orient) || ((i = u.axis) === null || i === void 0 ? void 0 : i.orient) || R0e(e),
-            f = t.getScaleComponent(e).get("type"),
-            h = k0e(e, f, c, t.config),
-            d = a !== void 0 ? !a : Nx("disable", u.style, a == null ? void 0 : a.style, h).configValue;
-        if (s.set("disable", d, a !== void 0), d) return s;
-        a = a || {};
-        const g = M0e(o, a, e, u.style, h),
-            p = {
-                fieldOrDatumDef: o,
-                axis: a,
+            o = (n == null ? void 0 : n.orient) || ((y = a[e === "x" ? "axisX" : "axisY"]) == null ? void 0 : y.orient) || ((v = a.axis) == null ? void 0 : v.orient) || Rpe(e),
+            l = t.getScaleComponent(e).get("type"),
+            u = kpe(e, l, o, t.config),
+            c = n !== void 0 ? !n : sx("disable", a.style, n == null ? void 0 : n.style, u).configValue;
+        if (i.set("disable", c, n !== void 0), c) return i;
+        n = n || {};
+        const f = Mpe(r, n, e, a.style, u),
+            h = x6(n.formatType, r, l),
+            d = b6(r, r.type, n.format, n.formatType, a, !0),
+            g = {
+                fieldOrDatumDef: r,
+                axis: n,
                 channel: e,
                 model: t,
-                scaleType: f,
-                orient: c,
-                labelAngle: g,
-                mark: l,
-                config: u
+                scaleType: l,
+                orient: o,
+                labelAngle: f,
+                format: d,
+                formatType: h,
+                mark: s,
+                config: a
             };
-        for (const v of c8) {
-            const b = v in K$ ? K$[v](p) : C$(v) ? a[v] : void 0,
-                x = b !== void 0,
-                _ = Z1e(b, v, a, t, e);
-            if (x && _) s.set(v, b, _);
+        for (const b of C8) {
+            const x = b in c3 ? c3[b](g) : j5(b) ? n[b] : void 0,
+                _ = x !== void 0,
+                S = qme(x, b, n, t, e);
+            if (_ && S) i.set(b, x, S);
             else {
                 const {
-                    configValue: S = void 0,
-                    configFrom: w = void 0
-                } = C$(v) && v !== "values" ? Nx(v, u.style, a.style, h) : {}, O = S !== void 0;
-                x && !O ? s.set(v, b, _) : (w !== "vgAxisConfig" || eye.has(v) && O || Jd(S) || fe(S)) && s.set(v, S, !1)
+                    configValue: w = void 0,
+                    configFrom: E = void 0
+                } = j5(b) && b !== "values" ? sx(b, a.style, n.style, u) : {}, A = w !== void 0;
+                _ && !A ? i.set(b, x, S) : (E !== "vgAxisConfig" || Hme.has(b) && A || Pd(w) || he(w)) && i.set(b, w, !1)
             }
         }
-        const m = (r = a.encoding) !== null && r !== void 0 ? r : {},
-            y = b6.reduce((v, b) => {
-                var x;
-                if (!s.hasAxisPart(b)) return v;
-                const _ = Pz((x = m[b]) !== null && x !== void 0 ? x : {}, t),
-                    S = b === "labels" ? Y1e(t, e, _) : _;
-                return S !== void 0 && !et(S) && (v[b] = {
+        const p = n.encoding ?? {},
+            m = N6.reduce((b, x) => {
+                if (!i.hasAxisPart(x)) return b;
+                const _ = Kz(p[x] ?? {}, t),
+                    S = x === "labels" ? zme(t, e, _) : _;
+                return S !== void 0 && !et(S) && (b[x] = {
                     update: S
-                }), v
+                }), b
             }, {});
-        return et(y) || s.set("encode", y, !!a.encoding || a.labelAngle !== void 0), s
+        return et(m) || i.set("encode", m, !!n.encoding || n.labelAngle !== void 0), i
     }
 
-    function nye({
+    function Xme({
         encoding: e,
         size: t
     }) {
-        for (const n of xa) {
-            const i = ui(n);
-            aa(t[i]) && Ur(e[n]) && (delete t[i], X(Dj(i)))
+        for (const n of cs) {
+            const i = oi(n);
+            Jr(t[i]) && _a(e[n]) && (delete t[i], X(YI(i)))
         }
         return t
     }
 
-    function iye(e, t, n) {
-        const i = Xn(e),
-            r = Ve("orient", i, n);
-        if (i.orient = oye(i.type, t, r), r !== void 0 && r !== i.orient && X(hhe(i.orient, r)), i.type === "bar" && i.orient) {
-            const o = Ve("cornerRadiusEnd", i, n);
+    function Vme(e, t, n) {
+        const i = Hn(e),
+            r = Xe("orient", i, n);
+        if (i.orient = Zme(i.type, t, r), r !== void 0 && r !== i.orient && X(vfe(i.orient, r)), i.type === "bar" && i.orient) {
+            const o = Xe("cornerRadiusEnd", i, n);
             if (o !== void 0) {
-                const l = i.orient === "horizontal" && t.x2 || i.orient === "vertical" && t.y2 ? ["cornerRadius"] : Mde[i.orient];
+                const l = i.orient === "horizontal" && t.x2 || i.orient === "vertical" && t.y2 ? ["cornerRadius"] : Phe[i.orient];
                 for (const u of l) i[u] = o;
                 i.cornerRadiusEnd !== void 0 && delete i.cornerRadiusEnd
             }
         }
-        return Ve("opacity", i, n) === void 0 && (i.opacity = aye(i.type, t)), Ve("cursor", i, n) === void 0 && (i.cursor = rye(i, t, n)), i
+        return Xe("opacity", i, n) === void 0 && (i.opacity = Jme(i.type, t)), Xe("cursor", i, n) === void 0 && (i.cursor = Kme(i, t, n)), i
     }
 
-    function rye(e, t, n) {
-        return t.href || e.href || Ve("href", e, n) ? "pointer" : e.cursor
+    function Kme(e, t, n) {
+        return t.href || e.href || Xe("href", e, n) ? "pointer" : e.cursor
     }
 
-    function aye(e, t) {
-        if (Pe([Q1, AO, TO, $O], e) && !zO(t)) return .7
+    function Jme(e, t) {
+        if (Fe([D1, YE, XE, VE], e) && !sC(t)) return .7
     }
 
-    function sye(e, t, {
+    function Qme(e, t, {
         graticule: n
     }) {
         if (n) return !1;
-        const i = wl("filled", e, t),
+        const i = cl("filled", e, t),
             r = e.type;
-        return Tt(i, r !== Q1 && r !== J1 && r !== im)
+        return Ct(i, r !== D1 && r !== R1 && r !== I0)
     }
 
-    function oye(e, t, n) {
+    function Zme(e, t, n) {
         switch (e) {
-            case Q1:
-            case TO:
-            case $O:
-            case Jj:
-            case _de:
-            case xde:
+            case D1:
+            case XE:
+            case VE:
+            case h6:
+            case khe:
+            case Che:
                 return
         }
         const {
             x: i,
             y: r,
-            x2: a,
-            y2: s
+            x2: s,
+            y2: a
         } = t;
         switch (e) {
-            case K1:
-                if (J(i) && (Qt(i.bin) || J(r) && r.aggregate && !i.aggregate)) return "vertical";
-                if (J(r) && (Qt(r.bin) || J(i) && i.aggregate && !r.aggregate)) return "horizontal";
-                if (s || a) {
+            case F1:
+                if (K(i) && (Xt(i.bin) || K(r) && r.aggregate && !i.aggregate)) return "vertical";
+                if (K(r) && (Xt(r.bin) || K(i) && i.aggregate && !r.aggregate)) return "horizontal";
+                if (a || s) {
                     if (n) return n;
-                    if (!a) return (J(i) && i.type === Sl && !lt(i.bin) || Ox(i)) && J(r) && Qt(r.bin) ? "horizontal" : "vertical";
-                    if (!s) return (J(r) && r.type === Sl && !lt(r.bin) || Ox(r)) && J(i) && Qt(i.bin) ? "vertical" : "horizontal"
+                    if (!s) return (K(i) && i.type === hl && !ot(i.bin) || B0(i)) && K(r) && Xt(r.bin) ? "horizontal" : "vertical";
+                    if (!a) return (K(r) && r.type === hl && !ot(r.bin) || B0(r)) && K(i) && Xt(i.bin) ? "vertical" : "horizontal"
                 }
-            case im:
-                if (a && !(J(i) && Qt(i.bin)) && s && !(J(r) && Qt(r.bin))) return;
-            case V1:
-                if (s) return J(r) && Qt(r.bin) ? "horizontal" : "vertical";
-                if (a) return J(i) && Qt(i.bin) ? "vertical" : "horizontal";
-                if (e === im) {
+            case I0:
+                if (s && !(K(i) && Xt(i.bin)) && a && !(K(r) && Xt(r.bin))) return;
+            case O1:
+                if (a) return K(r) && Xt(r.bin) ? "horizontal" : "vertical";
+                if (s) return K(i) && Xt(i.bin) ? "vertical" : "horizontal";
+                if (e === I0) {
                     if (i && !r) return "vertical";
                     if (r && !i) return "horizontal"
                 }
-            case J1:
-            case AO: {
-                const o = Ur(i),
-                    l = Ur(r);
+            case R1:
+            case YE: {
+                const o = z5(i),
+                    l = z5(r);
                 if (n) return n;
                 if (o && !l) return e !== "tick" ? "horizontal" : "vertical";
                 if (!o && l) return e !== "tick" ? "vertical" : "horizontal";
-                if (o && l) {
-                    const u = i,
-                        c = r,
-                        f = u.type === hc,
-                        h = c.type === hc;
-                    return f && !h ? e !== "tick" ? "vertical" : "horizontal" : !f && h ? e !== "tick" ? "horizontal" : "vertical" : !u.aggregate && c.aggregate ? e !== "tick" ? "vertical" : "horizontal" : u.aggregate && !c.aggregate && e !== "tick" ? "horizontal" : "vertical"
-                } else return
+                if (o && l) return "vertical"; {
+                    const u = zn(i) && i.type === nc,
+                        c = zn(r) && r.type === nc;
+                    if (u && !c) return "vertical";
+                    if (!u && c) return "horizontal"
+                }
+                return
             }
         }
         return "vertical"
     }
-    const lye = {
+    const e1e = {
             vgMark: "arc",
-            encodeEntry: e => Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, Hi(e, {
-                align: "ignore",
-                baseline: "ignore",
-                color: "include",
-                size: "ignore",
-                orient: "ignore",
-                theta: "ignore"
-            })), pn("x", e, {
-                defaultPos: "mid"
-            })), pn("y", e, {
-                defaultPos: "mid"
-            })), eo(e, "radius")), eo(e, "theta"))
+            encodeEntry: e => ({
+                ...Bi(e, {
+                    align: "ignore",
+                    baseline: "ignore",
+                    color: "include",
+                    size: "ignore",
+                    orient: "ignore",
+                    theta: "ignore"
+                }),
+                ...dn("x", e, {
+                    defaultPos: "mid"
+                }),
+                ...dn("y", e, {
+                    defaultPos: "mid"
+                }),
+                ...Ga(e, "radius"),
+                ...Ga(e, "theta")
+            })
         },
-        uye = {
+        t1e = {
             vgMark: "area",
-            encodeEntry: e => Object.assign(Object.assign(Object.assign(Object.assign({}, Hi(e, {
-                align: "ignore",
-                baseline: "ignore",
-                color: "include",
-                orient: "include",
-                size: "ignore",
-                theta: "ignore"
-            })), fm("x", e, {
-                defaultPos: "zeroOrMin",
-                defaultPos2: "zeroOrMin",
-                range: e.markDef.orient === "horizontal"
-            })), fm("y", e, {
-                defaultPos: "zeroOrMin",
-                defaultPos2: "zeroOrMin",
-                range: e.markDef.orient === "vertical"
-            })), iC(e))
+            encodeEntry: e => ({
+                ...Bi(e, {
+                    align: "ignore",
+                    baseline: "ignore",
+                    color: "include",
+                    orient: "include",
+                    size: "ignore",
+                    theta: "ignore"
+                }),
+                ...Y0("x", e, {
+                    defaultPos: "zeroOrMin",
+                    defaultPos2: "zeroOrMin",
+                    range: e.markDef.orient === "horizontal"
+                }),
+                ...Y0("y", e, {
+                    defaultPos: "zeroOrMin",
+                    defaultPos2: "zeroOrMin",
+                    range: e.markDef.orient === "vertical"
+                }),
+                ...wC(e)
+            })
         },
-        cye = {
+        n1e = {
             vgMark: "rect",
-            encodeEntry: e => Object.assign(Object.assign(Object.assign({}, Hi(e, {
-                align: "ignore",
-                baseline: "ignore",
-                color: "include",
-                orient: "ignore",
-                size: "ignore",
-                theta: "ignore"
-            })), eo(e, "x")), eo(e, "y"))
+            encodeEntry: e => ({
+                ...Bi(e, {
+                    align: "ignore",
+                    baseline: "ignore",
+                    color: "include",
+                    orient: "ignore",
+                    size: "ignore",
+                    theta: "ignore"
+                }),
+                ...Ga(e, "x"),
+                ...Ga(e, "y")
+            })
         },
-        fye = {
+        i1e = {
             vgMark: "shape",
-            encodeEntry: e => Object.assign({}, Hi(e, {
-                align: "ignore",
-                baseline: "ignore",
-                color: "include",
-                size: "ignore",
-                orient: "ignore",
-                theta: "ignore"
-            })),
+            encodeEntry: e => ({
+                ...Bi(e, {
+                    align: "ignore",
+                    baseline: "ignore",
+                    color: "include",
+                    size: "ignore",
+                    orient: "ignore",
+                    theta: "ignore"
+                })
+            }),
             postEncodingTransform: e => {
                 const {
                     encoding: t
                 } = e, n = t.shape;
-                return [Object.assign({
+                return [{
                     type: "geoshape",
-                    projection: e.projectionName()
-                }, n && J(n) && n.type === qc ? {
-                    field: ne(n, {
-                        expr: "datum"
-                    })
-                } : {})]
+                    projection: e.projectionName(),
+                    ...n && K(n) && n.type === Rc ? {
+                        field: ie(n, {
+                            expr: "datum"
+                        })
+                    } : {}
+                }]
             }
         },
-        hye = {
+        r1e = {
             vgMark: "image",
-            encodeEntry: e => Object.assign(Object.assign(Object.assign(Object.assign({}, Hi(e, {
-                align: "ignore",
-                baseline: "ignore",
-                color: "ignore",
-                orient: "ignore",
-                size: "ignore",
-                theta: "ignore"
-            })), eo(e, "x")), eo(e, "y")), tC(e, "url"))
+            encodeEntry: e => ({
+                ...Bi(e, {
+                    align: "ignore",
+                    baseline: "ignore",
+                    color: "ignore",
+                    orient: "ignore",
+                    size: "ignore",
+                    theta: "ignore"
+                }),
+                ...Ga(e, "x"),
+                ...Ga(e, "y"),
+                ...xC(e, "url")
+            })
         },
-        dye = {
+        s1e = {
             vgMark: "line",
-            encodeEntry: e => Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, Hi(e, {
-                align: "ignore",
-                baseline: "ignore",
-                color: "include",
-                size: "ignore",
-                orient: "ignore",
-                theta: "ignore"
-            })), pn("x", e, {
-                defaultPos: "mid"
-            })), pn("y", e, {
-                defaultPos: "mid"
-            })), Bt("size", e, {
-                vgChannel: "strokeWidth"
-            })), iC(e))
+            encodeEntry: e => ({
+                ...Bi(e, {
+                    align: "ignore",
+                    baseline: "ignore",
+                    color: "include",
+                    size: "ignore",
+                    orient: "ignore",
+                    theta: "ignore"
+                }),
+                ...dn("x", e, {
+                    defaultPos: "mid"
+                }),
+                ...dn("y", e, {
+                    defaultPos: "mid"
+                }),
+                ...Lt("size", e, {
+                    vgChannel: "strokeWidth"
+                }),
+                ...wC(e)
+            })
         },
-        gye = {
+        a1e = {
             vgMark: "trail",
-            encodeEntry: e => Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, Hi(e, {
+            encodeEntry: e => ({
+                ...Bi(e, {
+                    align: "ignore",
+                    baseline: "ignore",
+                    color: "include",
+                    size: "include",
+                    orient: "ignore",
+                    theta: "ignore"
+                }),
+                ...dn("x", e, {
+                    defaultPos: "mid"
+                }),
+                ...dn("y", e, {
+                    defaultPos: "mid"
+                }),
+                ...Lt("size", e),
+                ...wC(e)
+            })
+        };
+
+    function LC(e, t) {
+        const {
+            config: n
+        } = e;
+        return {
+            ...Bi(e, {
                 align: "ignore",
                 baseline: "ignore",
                 color: "include",
                 size: "include",
                 orient: "ignore",
                 theta: "ignore"
-            })), pn("x", e, {
+            }),
+            ...dn("x", e, {
                 defaultPos: "mid"
-            })), pn("y", e, {
+            }),
+            ...dn("y", e, {
                 defaultPos: "mid"
-            })), Bt("size", e)), iC(e))
-        };
-
-    function vC(e, t) {
-        const {
-            config: n
-        } = e;
-        return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, Hi(e, {
-            align: "ignore",
-            baseline: "ignore",
-            color: "include",
-            size: "include",
-            orient: "ignore",
-            theta: "ignore"
-        })), pn("x", e, {
-            defaultPos: "mid"
-        })), pn("y", e, {
-            defaultPos: "mid"
-        })), Bt("size", e)), Bt("angle", e)), pye(e, n, t))
+            }),
+            ...Lt("size", e),
+            ...Lt("angle", e),
+            ...o1e(e, n, t)
+        }
     }
 
-    function pye(e, t, n) {
+    function o1e(e, t, n) {
         return n ? {
             shape: {
                 value: n
             }
-        } : Bt("shape", e)
+        } : Lt("shape", e)
     }
-    const mye = {
+    const l1e = {
             vgMark: "symbol",
-            encodeEntry: e => vC(e)
+            encodeEntry: e => LC(e)
         },
-        yye = {
+        u1e = {
             vgMark: "symbol",
-            encodeEntry: e => vC(e, "circle")
+            encodeEntry: e => LC(e, "circle")
         },
-        vye = {
+        c1e = {
             vgMark: "symbol",
-            encodeEntry: e => vC(e, "square")
+            encodeEntry: e => LC(e, "square")
         },
-        bye = {
+        f1e = {
             vgMark: "rect",
-            encodeEntry: e => Object.assign(Object.assign(Object.assign({}, Hi(e, {
-                align: "ignore",
-                baseline: "ignore",
-                color: "include",
-                orient: "ignore",
-                size: "ignore",
-                theta: "ignore"
-            })), eo(e, "x")), eo(e, "y"))
-        },
-        xye = {
-            vgMark: "rule",
-            encodeEntry: e => {
-                const {
-                    markDef: t
-                } = e, n = t.orient;
-                return !e.encoding.x && !e.encoding.y && !e.encoding.latitude && !e.encoding.longitude ? {} : Object.assign(Object.assign(Object.assign(Object.assign({}, Hi(e, {
+            encodeEntry: e => ({
+                ...Bi(e, {
                     align: "ignore",
                     baseline: "ignore",
                     color: "include",
                     orient: "ignore",
                     size: "ignore",
                     theta: "ignore"
-                })), fm("x", e, {
-                    defaultPos: n === "horizontal" ? "zeroOrMax" : "mid",
-                    defaultPos2: "zeroOrMin",
-                    range: n !== "vertical"
-                })), fm("y", e, {
-                    defaultPos: n === "vertical" ? "zeroOrMax" : "mid",
-                    defaultPos2: "zeroOrMin",
-                    range: n !== "horizontal"
-                })), Bt("size", e, {
-                    vgChannel: "strokeWidth"
-                }))
+                }),
+                ...Ga(e, "x"),
+                ...Ga(e, "y")
+            })
+        },
+        h1e = {
+            vgMark: "rule",
+            encodeEntry: e => {
+                const {
+                    markDef: t
+                } = e, n = t.orient;
+                return !e.encoding.x && !e.encoding.y && !e.encoding.latitude && !e.encoding.longitude ? {} : {
+                    ...Bi(e, {
+                        align: "ignore",
+                        baseline: "ignore",
+                        color: "include",
+                        orient: "ignore",
+                        size: "ignore",
+                        theta: "ignore"
+                    }),
+                    ...Y0("x", e, {
+                        defaultPos: n === "horizontal" ? "zeroOrMax" : "mid",
+                        defaultPos2: "zeroOrMin",
+                        range: n !== "vertical"
+                    }),
+                    ...Y0("y", e, {
+                        defaultPos: n === "vertical" ? "zeroOrMax" : "mid",
+                        defaultPos2: "zeroOrMin",
+                        range: n !== "horizontal"
+                    }),
+                    ...Lt("size", e, {
+                        vgChannel: "strokeWidth"
+                    })
+                }
             }
         },
-        _ye = {
+        d1e = {
             vgMark: "text",
             encodeEntry: e => {
                 const {
                     config: t,
                     encoding: n
                 } = e;
-                return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, Hi(e, {
-                    align: "include",
-                    baseline: "include",
-                    color: "include",
-                    size: "ignore",
-                    orient: "ignore",
-                    theta: "include"
-                })), pn("x", e, {
-                    defaultPos: "mid"
-                })), pn("y", e, {
-                    defaultPos: "mid"
-                })), tC(e)), Bt("size", e, {
-                    vgChannel: "fontSize"
-                })), Bt("angle", e)), H$("align", wye(e.markDef, n, t))), H$("baseline", Sye(e.markDef, n, t))), pn("radius", e, {
-                    defaultPos: null
-                })), pn("theta", e, {
-                    defaultPos: null
-                }))
+                return {
+                    ...Bi(e, {
+                        align: "include",
+                        baseline: "include",
+                        color: "include",
+                        size: "ignore",
+                        orient: "ignore",
+                        theta: "include"
+                    }),
+                    ...dn("x", e, {
+                        defaultPos: "mid"
+                    }),
+                    ...dn("y", e, {
+                        defaultPos: "mid"
+                    }),
+                    ...xC(e),
+                    ...Lt("size", e, {
+                        vgChannel: "fontSize"
+                    }),
+                    ...Lt("angle", e),
+                    ...a3("align", g1e(e.markDef, n, t)),
+                    ...a3("baseline", p1e(e.markDef, n, t)),
+                    ...dn("radius", e, {
+                        defaultPos: null
+                    }),
+                    ...dn("theta", e, {
+                        defaultPos: null
+                    })
+                }
             }
         };
 
-    function wye(e, t, n) {
-        if (Ve("align", e, n) === void 0) return "center"
+    function g1e(e, t, n) {
+        if (Xe("align", e, n) === void 0) return "center"
     }
 
-    function Sye(e, t, n) {
-        if (Ve("baseline", e, n) === void 0) return "middle"
+    function p1e(e, t, n) {
+        if (Xe("baseline", e, n) === void 0) return "middle"
     }
-    const Eye = {
+    const m1e = {
         vgMark: "rect",
         encodeEntry: e => {
             const {
                 config: t,
                 markDef: n
-            } = e, i = n.orient, r = i === "horizontal" ? "width" : "height", a = i === "horizontal" ? "height" : "width";
-            return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, Hi(e, {
-                align: "ignore",
-                baseline: "ignore",
-                color: "include",
-                orient: "ignore",
-                size: "ignore",
-                theta: "ignore"
-            })), pn("x", e, {
-                defaultPos: "mid",
-                vgChannel: "xc"
-            })), pn("y", e, {
-                defaultPos: "mid",
-                vgChannel: "yc"
-            })), Bt("size", e, {
-                defaultValue: Oye(e),
-                vgChannel: r
-            })), {
-                [a]: ct(Ve("thickness", n, t))
-            })
+            } = e, i = n.orient, r = i === "horizontal" ? "width" : "height", s = i === "horizontal" ? "height" : "width";
+            return {
+                ...Bi(e, {
+                    align: "ignore",
+                    baseline: "ignore",
+                    color: "include",
+                    orient: "ignore",
+                    size: "ignore",
+                    theta: "ignore"
+                }),
+                ...dn("x", e, {
+                    defaultPos: "mid",
+                    vgChannel: "xc"
+                }),
+                ...dn("y", e, {
+                    defaultPos: "mid",
+                    vgChannel: "yc"
+                }),
+                ...Lt("size", e, {
+                    defaultValue: y1e(e),
+                    vgChannel: r
+                }),
+                [s]: ut(Xe("thickness", n, t))
+            }
         }
     };
 
-    function Oye(e) {
-        var t;
+    function y1e(e) {
         const {
-            config: n,
-            markDef: i
+            config: t,
+            markDef: n
         } = e, {
-            orient: r
-        } = i, a = r === "horizontal" ? "width" : "height", s = e.getScaleComponent(r === "horizontal" ? "x" : "y"), o = (t = Ve("size", i, n, {
-            vgChannel: a
-        })) !== null && t !== void 0 ? t : n.tick.bandSize;
-        if (o !== void 0) return o; {
-            const l = s ? s.get("range") : void 0;
-            return l && _o(l) && tt(l.step) ? l.step * 3 / 4 : um(n.view, a) * 3 / 4
-        }
-    }
-    const Xg = {
-        arc: lye,
-        area: uye,
-        bar: cye,
-        circle: yye,
-        geoshape: fye,
-        image: hye,
-        line: dye,
-        point: mye,
-        rect: bye,
-        rule: xye,
-        square: vye,
-        text: _ye,
-        tick: Eye,
-        trail: gye
-    };
-
-    function Cye(e) {
-        if (Pe([J1, V1, wde], e.mark)) {
-            const t = E6(e.mark, e.encoding);
-            if (t.length > 0) return kye(e, t)
-        } else if (e.mark === K1) {
-            const t = bx.some(n => Ve(n, e.markDef, e.config));
-            if (e.stack && !e.fieldDef("size") && t) return Aye(e)
+            orient: i
+        } = n, r = i === "horizontal" ? "width" : "height", s = e.getScaleComponent(i === "horizontal" ? "x" : "y"), a = Xe("size", n, t, {
+            vgChannel: r
+        }) ?? t.tick.bandSize;
+        if (a !== void 0) return a; {
+            const o = s ? s.get("range") : void 0;
+            return o && lo(o) && Ze(o.step) ? o.step * 3 / 4 : q0(t.view, r) * 3 / 4
         }
-        return bC(e)
     }
-    const h5 = "faceted_path_";
+    const Fg = {
+        arc: e1e,
+        area: t1e,
+        bar: n1e,
+        circle: u1e,
+        geoshape: i1e,
+        image: r1e,
+        line: s1e,
+        point: l1e,
+        rect: f1e,
+        rule: h1e,
+        square: c1e,
+        text: d1e,
+        tick: m1e,
+        trail: a1e
+    };
+
+    function v1e(e) {
+        if (Fe([R1, O1, Ahe], e.mark)) {
+            const t = B6(e.mark, e.encoding);
+            if (t.length > 0) return b1e(e, t)
+        } else if (e.mark === F1) {
+            const t = H2.some(n => Xe(n, e.markDef, e.config));
+            if (e.stack && !e.fieldDef("size") && t) return x1e(e)
+        }
+        return IC(e)
+    }
+    const k3 = "faceted_path_";
 
-    function kye(e, t) {
+    function b1e(e, t) {
         return [{
             name: e.getName("pathgroup"),
             type: "group",
             from: {
                 facet: {
-                    name: h5 + e.requestDataName(st.Main),
+                    name: k3 + e.requestDataName(st.Main),
                     data: e.requestDataName(st.Main),
                     groupby: t
                 }
             },
             encode: {
                 update: {
                     width: {
@@ -50524,766 +50960,799 @@
                     height: {
                         field: {
                             group: "height"
                         }
                     }
                 }
             },
-            marks: bC(e, {
-                fromPrefix: h5
+            marks: IC(e, {
+                fromPrefix: k3
             })
         }]
     }
-    const d5 = "stack_group_";
+    const A3 = "stack_group_";
 
-    function Aye(e) {
-        var t;
-        const [n] = bC(e, {
-            fromPrefix: d5
-        }), i = e.scaleName(e.stack.fieldChannel), r = (c = {}) => e.vgField(e.stack.fieldChannel, c), a = (c, f) => {
-            const h = [r({
+    function x1e(e) {
+        var u;
+        const [t] = IC(e, {
+            fromPrefix: A3
+        }), n = e.scaleName(e.stack.fieldChannel), i = (c = {}) => e.vgField(e.stack.fieldChannel, c), r = (c, f) => {
+            const h = [i({
                 prefix: "min",
                 suffix: "start",
                 expr: f
-            }), r({
+            }), i({
                 prefix: "max",
                 suffix: "start",
                 expr: f
-            }), r({
+            }), i({
                 prefix: "min",
                 suffix: "end",
                 expr: f
-            }), r({
+            }), i({
                 prefix: "max",
                 suffix: "end",
                 expr: f
             })];
-            return `${c}(${h.map(d=>`scale('${i}',${d})`).join(",")})`
+            return `${c}(${h.map(d=>`scale('${n}',${d})`).join(",")})`
         };
-        let s, o;
-        e.stack.fieldChannel === "x" ? (s = Object.assign(Object.assign({}, uc(n.encode.update, ["y", "yc", "y2", "height", ...bx])), {
+        let s, a;
+        e.stack.fieldChannel === "x" ? (s = {
+            ...Qu(t.encode.update, ["y", "yc", "y2", "height", ...H2]),
             x: {
-                signal: a("min", "datum")
+                signal: r("min", "datum")
             },
             x2: {
-                signal: a("max", "datum")
+                signal: r("max", "datum")
             },
             clip: {
                 value: !0
             }
-        }), o = {
+        }, a = {
             x: {
                 field: {
                     group: "x"
                 },
                 mult: -1
             },
             height: {
                 field: {
                     group: "height"
                 }
             }
-        }, n.encode.update = Object.assign(Object.assign({}, Zn(n.encode.update, ["y", "yc", "y2"])), {
+        }, t.encode.update = {
+            ...Jn(t.encode.update, ["y", "yc", "y2"]),
             height: {
                 field: {
                     group: "height"
                 }
             }
-        })) : (s = Object.assign(Object.assign({}, uc(n.encode.update, ["x", "xc", "x2", "width"])), {
+        }) : (s = {
+            ...Qu(t.encode.update, ["x", "xc", "x2", "width"]),
             y: {
-                signal: a("min", "datum")
+                signal: r("min", "datum")
             },
             y2: {
-                signal: a("max", "datum")
+                signal: r("max", "datum")
             },
             clip: {
                 value: !0
             }
-        }), o = {
+        }, a = {
             y: {
                 field: {
                     group: "y"
                 },
                 mult: -1
             },
             width: {
                 field: {
                     group: "width"
                 }
             }
-        }, n.encode.update = Object.assign(Object.assign({}, Zn(n.encode.update, ["x", "xc", "x2"])), {
+        }, t.encode.update = {
+            ...Jn(t.encode.update, ["x", "xc", "x2"]),
             width: {
                 field: {
                     group: "width"
                 }
             }
-        }));
-        for (const c of bx) {
-            const f = wl(c, e.markDef, e.config);
-            n.encode.update[c] ? (s[c] = n.encode.update[c], delete n.encode.update[c]) : f && (s[c] = ct(f)), f && (n.encode.update[c] = {
+        });
+        for (const c of H2) {
+            const f = cl(c, e.markDef, e.config);
+            t.encode.update[c] ? (s[c] = t.encode.update[c], delete t.encode.update[c]) : f && (s[c] = ut(f)), f && (t.encode.update[c] = {
                 value: 0
             })
         }
-        const l = [];
-        if (((t = e.stack.groupbyChannels) === null || t === void 0 ? void 0 : t.length) > 0)
+        const o = [];
+        if (((u = e.stack.groupbyChannels) == null ? void 0 : u.length) > 0)
             for (const c of e.stack.groupbyChannels) {
                 const f = e.fieldDef(c),
-                    h = ne(f);
-                h && l.push(h), (f != null && f.bin || f != null && f.timeUnit) && l.push(ne(f, {
+                    h = ie(f);
+                h && o.push(h), (f != null && f.bin || f != null && f.timeUnit) && o.push(ie(f, {
                     binSuffix: "end"
                 }))
             }
         return s = ["stroke", "strokeWidth", "strokeJoin", "strokeCap", "strokeDash", "strokeDashOffset", "strokeMiterLimit", "strokeOpacity"].reduce((c, f) => {
-            if (n.encode.update[f]) return Object.assign(Object.assign({}, c), {
-                [f]: n.encode.update[f]
-            }); {
-                const h = wl(f, e.markDef, e.config);
-                return h !== void 0 ? Object.assign(Object.assign({}, c), {
-                    [f]: ct(h)
-                }) : c
+            if (t.encode.update[f]) return {
+                ...c,
+                [f]: t.encode.update[f]
+            }; {
+                const h = cl(f, e.markDef, e.config);
+                return h !== void 0 ? {
+                    ...c,
+                    [f]: ut(h)
+                } : c
             }
         }, s), s.stroke && (s.strokeForeground = {
             value: !0
         }, s.strokeOffset = {
             value: 0
         }), [{
             type: "group",
             from: {
                 facet: {
                     data: e.requestDataName(st.Main),
-                    name: d5 + e.requestDataName(st.Main),
-                    groupby: l,
+                    name: A3 + e.requestDataName(st.Main),
+                    groupby: o,
                     aggregate: {
-                        fields: [r({
+                        fields: [i({
                             suffix: "start"
-                        }), r({
+                        }), i({
                             suffix: "start"
-                        }), r({
+                        }), i({
                             suffix: "end"
-                        }), r({
+                        }), i({
                             suffix: "end"
                         })],
                         ops: ["min", "max", "min", "max"]
                     }
                 }
             },
             encode: {
                 update: s
             },
             marks: [{
                 type: "group",
                 encode: {
-                    update: o
+                    update: a
                 },
-                marks: [n]
+                marks: [t]
             }]
         }]
     }
 
-    function Tye(e) {
-        var t;
+    function _1e(e) {
+        var o;
         const {
-            encoding: n,
-            stack: i,
-            mark: r,
-            markDef: a,
+            encoding: t,
+            stack: n,
+            mark: i,
+            markDef: r,
             config: s
-        } = e, o = n.order;
-        if (!(!q(o) && wr(o) && yx(o.value) || !o && yx(Ve("order", a, s)))) {
-            if ((q(o) || J(o)) && !i) return Oj(o, {
+        } = e, a = t.order;
+        if (!(!W(a) && gr(a) && W2(a.value) || !a && W2(Xe("order", r, s)))) {
+            if ((W(a) || K(a)) && !n) return zI(a, {
                 expr: "datum"
             });
-            if (wo(r)) {
-                const l = a.orient === "horizontal" ? "y" : "x",
-                    u = n[l];
-                if (J(u)) {
+            if (uo(i)) {
+                const l = r.orient === "horizontal" ? "y" : "x",
+                    u = t[l];
+                if (K(u)) {
                     const c = u.sort;
-                    if (q(c)) return {
-                        field: ne(u, {
+                    if (W(c)) return {
+                        field: ie(u, {
                             prefix: l,
                             suffix: "sort_index",
                             expr: "datum"
                         })
                     };
-                    if (Yr(c)) return {
-                        field: ne({
-                            aggregate: zO(e.encoding) ? c.op : void 0,
+                    if (Br(c)) return {
+                        field: ie({
+                            aggregate: sC(e.encoding) ? c.op : void 0,
                             field: c.field
                         }, {
                             expr: "datum"
                         })
                     };
-                    if (o6(c)) {
+                    if (w6(c)) {
                         const f = e.fieldDef(c.encoding);
                         return {
-                            field: ne(f, {
+                            field: ie(f, {
                                 expr: "datum"
                             }),
                             order: c.order
                         }
                     } else return c === null ? void 0 : {
-                        field: ne(u, {
-                            binSuffix: !((t = e.stack) === null || t === void 0) && t.impute ? "mid" : void 0,
+                        field: ie(u, {
+                            binSuffix: (o = e.stack) != null && o.impute ? "mid" : void 0,
                             expr: "datum"
                         })
                     }
                 }
                 return
             }
         }
     }
 
-    function bC(e, t = {
+    function IC(e, t = {
         fromPrefix: ""
     }) {
         const {
             mark: n,
             markDef: i,
             encoding: r,
-            config: a
-        } = e, s = Tt(i.clip, $ye(e), Mye(e)), o = Sj(i), l = r.key, u = Tye(e), c = Fye(e), f = Ve("aria", i, a), h = Xg[n].postEncodingTransform ? Xg[n].postEncodingTransform(e) : null;
-        return [Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({
+            config: s
+        } = e, a = Ct(i.clip, w1e(e), S1e(e)), o = LI(i), l = r.key, u = _1e(e), c = E1e(e), f = Xe("aria", i, s), h = Fg[n].postEncodingTransform ? Fg[n].postEncodingTransform(e) : null;
+        return [{
             name: e.getName("marks"),
-            type: Xg[n].vgMark
-        }, s ? {
-            clip: !0
-        } : {}), o ? {
-            style: o
-        } : {}), l ? {
-            key: l.field
-        } : {}), u ? {
-            sort: u
-        } : {}), c || {}), f === !1 ? {
-            aria: f
-        } : {}), {
+            type: Fg[n].vgMark,
+            ...a ? {
+                clip: !0
+            } : {},
+            ...o ? {
+                style: o
+            } : {},
+            ...l ? {
+                key: l.field
+            } : {},
+            ...u ? {
+                sort: u
+            } : {},
+            ...c || {},
+            ...f === !1 ? {
+                aria: f
+            } : {},
             from: {
                 data: t.fromPrefix + e.requestDataName(st.Main)
             },
             encode: {
-                update: Xg[n].encodeEntry(e)
-            }
-        }), h ? {
-            transform: h
-        } : {})]
+                update: Fg[n].encodeEntry(e)
+            },
+            ...h ? {
+                transform: h
+            } : {}
+        }]
     }
 
-    function $ye(e) {
+    function w1e(e) {
         const t = e.getScaleComponent("x"),
             n = e.getScaleComponent("y");
         return t != null && t.get("selectionExtent") || n != null && n.get("selectionExtent") ? !0 : void 0
     }
 
-    function Mye(e) {
+    function S1e(e) {
         const t = e.component.projection;
         return t && !t.isFit ? !0 : void 0
     }
 
-    function Fye(e) {
+    function E1e(e) {
         if (!e.component.selection) return null;
-        const t = Y(e.component.selection).length;
+        const t = H(e.component.selection).length;
         let n = t,
             i = e.parent;
-        for (; i && n === 0;) n = Y(i.component.selection).length, i = i.parent;
+        for (; i && n === 0;) n = H(i.component.selection).length, i = i.parent;
         return n ? {
-            interactive: t > 0 || !!e.encoding.tooltip
+            interactive: t > 0 || e.mark === "geoshape" || !!e.encoding.tooltip
         } : null
     }
-    class f8 extends s8 {
-        constructor(t, n, i, r = {}, a) {
-            var s;
-            super(t, "unit", n, i, a, void 0, T$(t) ? t.view : void 0), this.specifiedScales = {}, this.specifiedAxes = {}, this.specifiedLegends = {}, this.specifiedProjection = {}, this.selection = [], this.children = [];
-            const o = na(t.mark) ? Object.assign({}, t.mark) : {
+    class k8 extends _8 {
+        constructor(t, n, i, r = {}, s) {
+            super(t, "unit", n, i, s, void 0, G5(t) ? t.view : void 0), this.specifiedScales = {}, this.specifiedAxes = {}, this.specifiedLegends = {}, this.specifiedProjection = {}, this.selection = [], this.children = [];
+            const a = Vr(t.mark) ? {
+                    ...t.mark
+                } : {
                     type: t.mark
                 },
-                l = o.type;
-            o.filled === void 0 && (o.filled = sye(o, a, {
-                graticule: t.data && ZO(t.data)
+                o = a.type;
+            a.filled === void 0 && (a.filled = Qme(a, s, {
+                graticule: t.data && vC(t.data)
             }));
-            const u = this.encoding = lge(t.encoding || {}, l, o.filled, a);
-            this.markDef = iye(o, u, a), this.size = nye({
-                encoding: u,
-                size: T$(t) ? Object.assign(Object.assign(Object.assign({}, r), t.width ? {
-                    width: t.width
-                } : {}), t.height ? {
-                    height: t.height
-                } : {}) : r
-            }), this.stack = W6(l, u), this.specifiedScales = this.initScales(l, u), this.specifiedAxes = this.initAxes(u), this.specifiedLegends = this.initLegends(u), this.specifiedProjection = t.projection, this.selection = ((s = t.params) !== null && s !== void 0 ? s : []).filter(c => XO(c))
+            const l = this.encoding = hde(t.encoding || {}, o, a.filled, s);
+            this.markDef = Vme(a, l, s), this.size = Xme({
+                encoding: l,
+                size: G5(t) ? {
+                    ...r,
+                    ...t.width ? {
+                        width: t.width
+                    } : {},
+                    ...t.height ? {
+                        height: t.height
+                    } : {}
+                } : r
+            }), this.stack = az(this.markDef, l), this.specifiedScales = this.initScales(o, l), this.specifiedAxes = this.initAxes(l), this.specifiedLegends = this.initLegends(l), this.specifiedProjection = t.projection, this.selection = (t.params ?? []).filter(u => dC(u))
         }
         get hasProjection() {
             const {
                 encoding: t
-            } = this, n = this.mark === Qj, i = t && rfe.some(r => Ee(t[r]));
+            } = this, n = this.mark === d6, i = t && hce.some(r => Ce(t[r]));
             return n || i
         }
         scaleDomain(t) {
             const n = this.specifiedScales[t];
             return n ? n.domain : void 0
         }
         axis(t) {
             return this.specifiedAxes[t]
         }
         legend(t) {
             return this.specifiedLegends[t]
         }
         initScales(t, n) {
-            return H1.reduce((i, r) => {
-                var a;
-                const s = Rt(n[r]);
-                return s && (i[r] = this.initScale((a = s.scale) !== null && a !== void 0 ? a : {})), i
+            return A1.reduce((i, r) => {
+                const s = Mt(n[r]);
+                return s && (i[r] = this.initScale(s.scale ?? {})), i
             }, {})
         }
         initScale(t) {
             const {
                 domain: n,
                 range: i
-            } = t, r = Xn(t);
-            return q(n) && (r.domain = n.map(pi)), q(i) && (r.range = i.map(pi)), r
+            } = t, r = Hn(t);
+            return W(n) && (r.domain = n.map(di)), W(i) && (r.range = i.map(di)), r
         }
         initAxes(t) {
-            return xa.reduce((n, i) => {
+            return cs.reduce((n, i) => {
                 const r = t[i];
-                if (Ee(r) || i === yt && Ee(t.x2) || i === Yt && Ee(t.y2)) {
-                    const a = Ee(r) ? r.axis : void 0;
-                    n[i] = a && this.initAxis(Object.assign({}, a))
+                if (Ce(r) || i === ht && Ce(t.x2) || i === Gt && Ce(t.y2)) {
+                    const s = Ce(r) ? r.axis : void 0;
+                    n[i] = s && this.initAxis({
+                        ...s
+                    })
                 }
                 return n
             }, {})
         }
         initAxis(t) {
-            const n = Y(t),
+            const n = H(t),
                 i = {};
             for (const r of n) {
-                const a = t[r];
-                i[r] = Jd(a) ? wj(a) : pi(a)
+                const s = t[r];
+                i[r] = Pd(s) ? PI(s) : di(s)
             }
             return i
         }
         initLegends(t) {
-            return gfe.reduce((n, i) => {
-                const r = Rt(t[i]);
-                if (r && mfe(i)) {
-                    const a = r.legend;
-                    n[i] = a && Xn(a)
+            return _ce.reduce((n, i) => {
+                const r = Mt(t[i]);
+                if (r && Sce(i)) {
+                    const s = r.legend;
+                    n[i] = s && Hn(s)
                 }
                 return n
             }, {})
         }
         parseData() {
-            this.component.data = Sy(this)
+            this.component.data = sy(this)
         }
         parseLayoutSize() {
-            j1e(this)
+            Ome(this)
         }
         parseSelections() {
-            this.component.selection = S0e(this, this.selection)
+            this.component.selection = wpe(this, this.selection)
         }
         parseMarkGroup() {
-            this.component.mark = Cye(this)
+            this.component.mark = v1e(this)
         }
         parseAxesAndHeaders() {
-            this.component.axes = X1e(this)
+            this.component.axes = Bme(this)
         }
         assembleSelectionTopLevelSignals(t) {
-            return qpe(this, t)
+            return Wge(this, t)
         }
         assembleSignals() {
-            return [...Cz(this), ...Gpe(this, [])]
+            return [...jz(this), ...Uge(this, [])]
         }
         assembleSelectionData(t) {
-            return Wpe(this, t)
+            return qge(this, t)
         }
         assembleLayout() {
             return null
         }
         assembleLayoutSignals() {
-            return oC(this)
+            return kC(this)
         }
         assembleMarks() {
-            var t;
-            let n = (t = this.component.mark) !== null && t !== void 0 ? t : [];
-            return (!this.parent || !Vc(this.parent)) && (n = az(this, n)), n.map(this.correctDataNames)
+            let t = this.component.mark ?? [];
+            return (!this.parent || !Ic(this.parent)) && (t = bz(this, t)), t.map(this.correctDataNames)
         }
         assembleGroupStyle() {
             const {
                 style: t
             } = this.view || {};
-            if (t !== void 0) return t;
-            if (this.encoding.x || this.encoding.y) return "cell"
+            return t !== void 0 ? t : this.encoding.x || this.encoding.y ? "cell" : "view"
         }
         getMapping() {
             return this.encoding
         }
         get mark() {
             return this.markDef.type
         }
         channelHasField(t) {
-            return al(this.encoding, t)
+            return Ho(this.encoding, t)
         }
         fieldDef(t) {
             const n = this.encoding[t];
-            return ia(n)
+            return Kr(n)
         }
         typedFieldDef(t) {
             const n = this.fieldDef(t);
-            return Ui(n) ? n : null
+            return zn(n) ? n : null
         }
     }
-    class xC extends pC {
-        constructor(t, n, i, r, a) {
-            super(t, "layer", n, i, a, t.resolve, t.view);
-            const s = Object.assign(Object.assign(Object.assign({}, r), t.width ? {
-                width: t.width
-            } : {}), t.height ? {
-                height: t.height
-            } : {});
+    class zC extends DC {
+        constructor(t, n, i, r, s) {
+            super(t, "layer", n, i, s, t.resolve, t.view);
+            const a = {
+                ...r,
+                ...t.width ? {
+                    width: t.width
+                } : {},
+                ...t.height ? {
+                    height: t.height
+                } : {}
+            };
             this.children = t.layer.map((o, l) => {
-                if (ly(o)) return new xC(o, this, this.getName(`layer_${l}`), s, a);
-                if (os(o)) return new f8(o, this, this.getName(`layer_${l}`), s, a);
-                throw new Error(hO(o))
+                if (W1(o)) return new zC(o, this, this.getName(`layer_${l}`), a, s);
+                if (Zs(o)) return new k8(o, this, this.getName(`layer_${l}`), a, s);
+                throw new Error(FE(o))
             })
         }
         parseData() {
-            this.component.data = Sy(this);
+            this.component.data = sy(this);
             for (const t of this.children) t.parseData()
         }
         parseLayoutSize() {
-            L1e(this)
+            Tme(this)
         }
         parseSelections() {
             this.component.selection = {};
             for (const t of this.children) {
                 t.parseSelections();
-                for (const n of Y(t.component.selection)) this.component.selection[n] = t.component.selection[n]
+                for (const n of H(t.component.selection)) this.component.selection[n] = t.component.selection[n]
             }
         }
         parseMarkGroup() {
             for (const t of this.children) t.parseMarkGroup()
         }
         parseAxesAndHeaders() {
-            K1e(this)
+            Ume(this)
         }
         assembleSelectionTopLevelSignals(t) {
             return this.children.reduce((n, i) => i.assembleSelectionTopLevelSignals(n), t)
         }
         assembleSignals() {
-            return this.children.reduce((t, n) => t.concat(n.assembleSignals()), Cz(this))
+            return this.children.reduce((t, n) => t.concat(n.assembleSignals()), jz(this))
         }
         assembleLayoutSignals() {
-            return this.children.reduce((t, n) => t.concat(n.assembleLayoutSignals()), oC(this))
+            return this.children.reduce((t, n) => t.concat(n.assembleLayoutSignals()), kC(this))
         }
         assembleSelectionData(t) {
             return this.children.reduce((n, i) => i.assembleSelectionData(n), t)
         }
         assembleGroupStyle() {
             const t = new Set;
             for (const i of this.children)
-                for (const r of ie(i.assembleGroupStyle())) t.add(r);
+                for (const r of se(i.assembleGroupStyle())) t.add(r);
             const n = Array.from(t);
             return n.length > 1 ? n : n.length === 1 ? n[0] : void 0
         }
         assembleTitle() {
             let t = super.assembleTitle();
             if (t) return t;
             for (const n of this.children)
                 if (t = n.assembleTitle(), t) return t
         }
         assembleLayout() {
             return null
         }
         assembleMarks() {
-            return Hpe(this, this.children.flatMap(t => t.assembleMarks()))
+            return Hge(this, this.children.flatMap(t => t.assembleMarks()))
         }
         assembleLegends() {
-            return this.children.reduce((t, n) => t.concat(n.assembleLegends()), Uz(this))
+            return this.children.reduce((t, n) => t.concat(n.assembleLegends()), r8(this))
         }
     }
 
-    function _C(e, t, n, i, r) {
-        if (ey(e)) return new _h(e, t, n, r);
-        if (ly(e)) return new xC(e, t, n, i, r);
-        if (os(e)) return new f8(e, t, n, i, r);
-        if (Dge(e)) return new q1e(e, t, n, r);
-        throw new Error(hO(e))
-    }
-    var Dye = globalThis && globalThis.__rest || function(e, t) {
-        var n = {};
-        for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && t.indexOf(i) < 0 && (n[i] = e[i]);
-        if (e != null && typeof Object.getOwnPropertySymbols == "function")
-            for (var r = 0, i = Object.getOwnPropertySymbols(e); r < i.length; r++) t.indexOf(i[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, i[r]) && (n[i[r]] = e[i[r]]);
-        return n
-    };
+    function BC(e, t, n, i, r) {
+        if (P1(e)) return new uh(e, t, n, r);
+        if (W1(e)) return new zC(e, t, n, i, r);
+        if (Zs(e)) return new k8(e, t, n, i, r);
+        if (Pde(e)) return new Pme(e, t, n, r);
+        throw new Error(FE(e))
+    }
 
-    function Rye(e, t = {}) {
-        t.logger && Lhe(t.logger), t.fieldTitle && m6(t.fieldTitle);
+    function C1e(e, t = {}) {
+        t.logger && Gfe(t.logger), t.fieldTitle && F6(t.fieldTitle);
         try {
-            const n = q6(Mc(t.config, e.config)),
-                i = ez(e, n),
-                r = _C(i, null, "", void 0, n);
-            return r.parse(), Hme(r.component.data, r), {
-                spec: Nye(r, Pye(e, i.autosize, n, r), e.datasets, e.usermeta),
+            const n = sz(bc(t.config, e.config)),
+                i = dz(e, n),
+                r = BC(i, null, "", void 0, n);
+            return r.parse(), W0e(r.component.data, r), {
+                spec: A1e(r, k1e(e, i.autosize, n, r), e.datasets, e.usermeta),
                 normalized: i
             }
         } finally {
-            t.logger && Ihe(), t.fieldTitle && Qde()
+            t.logger && Wfe(), t.fieldTitle && ide()
         }
     }
 
-    function Pye(e, t, n, i) {
+    function k1e(e, t, n, i) {
         const r = i.component.layoutSize.get("width"),
-            a = i.component.layoutSize.get("height");
+            s = i.component.layoutSize.get("height");
         if (t === void 0 ? (t = {
                 type: "pad"
             }, i.hasAxisOrientSignalRef() && (t.resize = !0)) : re(t) && (t = {
                 type: t
-            }), r && a && Lpe(t.type)) {
-            if (r === "step" && a === "step") X(d$()), t.type = "pad";
-            else if (r === "step" || a === "step") {
-                const s = r === "step" ? "width" : "height";
-                X(d$(W1(s)));
-                const o = s === "width" ? "height" : "width";
-                t.type = Ipe(o)
+            }), r && s && Ige(t.type)) {
+            if (r === "step" && s === "step") X(A5()), t.type = "pad";
+            else if (r === "step" || s === "step") {
+                const a = r === "step" ? "width" : "height";
+                X(A5(k1(a)));
+                const o = a === "width" ? "height" : "width";
+                t.type = zge(o)
             }
         }
-        return Object.assign(Object.assign(Object.assign({}, Y(t).length === 1 && t.type ? t.type === "pad" ? {} : {
-            autosize: t.type
-        } : {
-            autosize: t
-        }), B$(n, !1)), B$(e, !0))
+        return {
+            ...H(t).length === 1 && t.type ? t.type === "pad" ? {} : {
+                autosize: t.type
+            } : {
+                autosize: t
+            },
+            ...t3(n, !1),
+            ...t3(e, !0)
+        }
     }
 
-    function Nye(e, t, n = {}, i) {
-        const r = e.config ? Xge(e.config) : void 0,
-            a = [].concat(e.assembleSelectionData([]), D1e(e.component.data, n)),
-            s = e.assembleProjections(),
+    function A1e(e, t, n = {}, i) {
+        const r = e.config ? Kde(e.config) : void 0,
+            s = [].concat(e.assembleSelectionData([]), Cme(e.component.data, n)),
+            a = e.assembleProjections(),
             o = e.assembleTitle(),
             l = e.assembleGroupStyle(),
             u = e.assembleGroupEncodeEntry(!0);
         let c = e.assembleLayoutSignals();
         c = c.filter(d => (d.name === "width" || d.name === "height") && d.value !== void 0 ? (t[d.name] = +d.value, !1) : !0);
         const {
-            params: f
-        } = t, h = Dye(t, ["params"]);
-        return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({
-            $schema: "https://vega.github.io/schema/vega/v5.json"
-        }, e.description ? {
-            description: e.description
-        } : {}), h), o ? {
-            title: o
-        } : {}), l ? {
-            style: l
-        } : {}), u ? {
-            encode: {
-                update: u
-            }
-        } : {}), {
-            data: a
-        }), s.length > 0 ? {
-            projections: s
-        } : {}), e.assembleGroup([...c, ...e.assembleSelectionTopLevelSignals([]), ...z6(f)])), r ? {
-            config: r
-        } : {}), i ? {
-            usermeta: i
-        } : {})
+            params: f,
+            ...h
+        } = t;
+        return {
+            $schema: "https://vega.github.io/schema/vega/v5.json",
+            ...e.description ? {
+                description: e.description
+            } : {},
+            ...h,
+            ...o ? {
+                title: o
+            } : {},
+            ...l ? {
+                style: l
+            } : {},
+            ...u ? {
+                encode: {
+                    update: u
+                }
+            } : {},
+            data: s,
+            ...a.length > 0 ? {
+                projections: a
+            } : {},
+            ...e.assembleGroup([...c, ...e.assembleSelectionTopLevelSignals([]), ...tz(f)]),
+            ...r ? {
+                config: r
+            } : {},
+            ...i ? {
+                usermeta: i
+            } : {}
+        }
     }
-    const Lye = Xce.version,
-        Iye = Object.freeze(Object.defineProperty({
+    const $1e = nce.version,
+        T1e = Object.freeze(Object.defineProperty({
             __proto__: null,
-            accessPathDepth: cc,
-            accessPathWithDatum: nO,
-            compile: Rye,
-            contains: Pe,
-            deepEqual: Br,
-            deleteNestedProperty: em,
-            duplicate: Ce,
-            entries: Ks,
-            every: ZE,
-            fieldIntersection: tO,
-            flatAccessWithDatum: ij,
-            getFirstDefined: Tt,
-            hasIntersection: eO,
-            hash: Ie,
-            internalField: sj,
-            isBoolean: Kh,
+            accessPathDepth: Zu,
+            accessPathWithDatum: wE,
+            compile: C1e,
+            contains: Fe,
+            deepEqual: Nr,
+            deleteNestedProperty: N0,
+            duplicate: ke,
+            entries: Ba,
+            every: bE,
+            fieldIntersection: _E,
+            flatAccessWithDatum: pI,
+            getFirstDefined: Ct,
+            hasIntersection: xE,
+            hash: Ne,
+            internalField: vI,
+            isBoolean: Ih,
             isEmpty: et,
-            isEqual: Qce,
-            isInternalField: oj,
-            isNullOrFalse: yx,
-            isNumeric: j1,
-            keys: Y,
-            logicalExpr: bh,
-            mergeDeep: tj,
-            never: ej,
-            normalize: ez,
-            normalizeAngle: Jh,
-            omit: Zn,
-            pick: uc,
-            prefixGenerator: vx,
-            removePathFromField: iO,
-            replaceAll: xl,
-            replacePathInField: Bi,
-            resetIdCounter: efe,
-            setEqual: nj,
-            some: bl,
-            stringify: ot,
-            titleCase: zd,
-            unique: Gr,
-            uniqueId: aj,
-            vals: _n,
-            varName: ht,
-            version: Lye
+            isEqual: lce,
+            isInternalField: bI,
+            isNullOrFalse: W2,
+            isNumeric: x1,
+            keys: H,
+            logicalExpr: oh,
+            mergeDeep: dI,
+            never: hI,
+            normalize: dz,
+            normalizeAngle: zh,
+            omit: Jn,
+            pick: Qu,
+            prefixGenerator: q2,
+            removePathFromField: SE,
+            replaceAll: ll,
+            replacePathInField: Pi,
+            resetIdCounter: cce,
+            setEqual: gI,
+            some: ol,
+            stringify: at,
+            titleCase: $d,
+            unique: Pr,
+            uniqueId: yI,
+            vals: Qt,
+            varName: ft,
+            version: $1e
         }, Symbol.toStringTag, {
             value: "Module"
         }));
 
-    function h8(e) {
+    function A8(e) {
         const [t, n] = /schema\/([\w-]+)\/([\w\.\-]+)\.json$/g.exec(e).slice(1, 3);
         return {
             library: t,
             version: n
         }
     }
-    var jye = "vega-themes",
-        zye = "2.12.1",
-        Bye = "Themes for stylized Vega and Vega-Lite visualizations.",
-        Gye = ["vega", "vega-lite", "themes", "style"],
-        Uye = "BSD-3-Clause",
-        qye = {
+    var M1e = "vega-themes",
+        O1e = "2.13.0",
+        F1e = "Themes for stylized Vega and Vega-Lite visualizations.",
+        R1e = ["vega", "vega-lite", "themes", "style"],
+        D1e = "BSD-3-Clause",
+        N1e = {
             name: "UW Interactive Data Lab",
             url: "https://idl.cs.washington.edu"
         },
-        Wye = [{
+        P1e = [{
             name: "Emily Gu",
             url: "https://github.com/emilygu"
         }, {
             name: "Arvind Satyanarayan",
             url: "http://arvindsatya.com"
         }, {
             name: "Jeffrey Heer",
             url: "https://idl.cs.washington.edu"
         }, {
             name: "Dominik Moritz",
             url: "https://www.domoritz.de"
         }],
-        Hye = "build/vega-themes.js",
-        wC = "build/vega-themes.module.js",
-        Yye = "build/vega-themes.min.js",
-        Xye = "build/vega-themes.min.js",
-        Vye = "build/vega-themes.module.d.ts",
-        Kye = {
+        L1e = "build/vega-themes.js",
+        jC = "build/vega-themes.module.js",
+        I1e = "build/vega-themes.min.js",
+        z1e = "build/vega-themes.min.js",
+        B1e = "build/vega-themes.module.d.ts",
+        j1e = {
             type: "git",
             url: "https://github.com/vega/vega-themes.git"
         },
-        Jye = ["src", "build"],
-        Qye = {
+        U1e = ["src", "build"],
+        G1e = {
             prebuild: "yarn clean",
             build: "rollup -c",
             clean: "rimraf build && rimraf examples/build",
             "copy:data": "rsync -r node_modules/vega-datasets/data/* examples/data",
             "copy:build": "rsync -r build/* examples/build",
             "deploy:gh": "yarn build && mkdir -p examples/build && rsync -r build/* examples/build && gh-pages -d examples",
             preversion: "yarn lint",
             serve: "browser-sync start -s -f build examples --serveStatic examples",
             start: "yarn build && concurrently --kill-others -n Server,Rollup 'yarn serve' 'rollup -c -w'",
-            prepare: "beemo create-config",
-            eslintbase: "beemo eslint .",
-            format: "yarn eslintbase --fix",
-            lint: "yarn eslintbase",
+            format: "eslint . --fix",
+            lint: "eslint .",
             release: "release-it"
         },
-        Zye = {
+        W1e = {
+            "@babel/core": "^7.21.4",
+            "@babel/plugin-transform-runtime": "^7.21.4",
+            "@babel/preset-env": "^7.21.4",
+            "@babel/preset-typescript": "^7.21.4",
             "@release-it/conventional-changelog": "^5.1.1",
             "@rollup/plugin-json": "^6.0.0",
-            "@rollup/plugin-node-resolve": "^15.0.1",
-            "@rollup/plugin-terser": "^0.4.0",
-            "browser-sync": "^2.27.10",
-            concurrently: "^7.3.0",
+            "@rollup/plugin-node-resolve": "^15.0.2",
+            "@rollup/plugin-terser": "^0.4.1",
+            "@typescript-eslint/eslint-plugin": "^5.59.0",
+            "@typescript-eslint/parser": "^5.59.0",
+            "browser-sync": "^2.29.1",
+            concurrently: "^8.0.1",
+            eslint: "^8.38.0",
+            "eslint-config-prettier": "^8.8.0",
+            "eslint-plugin-prettier": "^4.2.1",
             "gh-pages": "^5.0.0",
-            "release-it": "^15.6.0",
+            prettier: "^2.8.7",
+            "release-it": "^15.10.1",
+            rollup: "^3.20.6",
             "rollup-plugin-bundle-size": "^1.0.3",
-            "rollup-plugin-ts": "^3.0.2",
-            rollup: "^3.15.0",
-            typescript: "^4.7.4",
-            "vega-lite-dev-config": "^0.21.0",
-            "vega-lite": "^5.0.0",
-            vega: "^5.19.1"
+            "rollup-plugin-ts": "^3.2.0",
+            typescript: "^5.0.4",
+            vega: "^5.24.0",
+            "vega-lite": "^5.7.1"
         },
-        eve = {
+        q1e = {
             vega: "*",
             "vega-lite": "*"
         },
-        tve = {},
-        nve = {
-            name: jye,
-            version: zye,
-            description: Bye,
-            keywords: Gye,
-            license: Uye,
-            author: qye,
-            contributors: Wye,
-            main: Hye,
-            module: wC,
-            unpkg: Yye,
-            jsdelivr: Xye,
-            types: Vye,
-            repository: Kye,
-            files: Jye,
-            scripts: Qye,
-            devDependencies: Zye,
-            peerDependencies: eve,
-            dependencies: tve
-        };
-    const du = "#fff",
-        g5 = "#888",
-        ive = {
+        H1e = {},
+        Y1e = {
+            name: M1e,
+            version: O1e,
+            description: F1e,
+            keywords: R1e,
+            license: D1e,
+            author: N1e,
+            contributors: P1e,
+            main: L1e,
+            module: jC,
+            unpkg: I1e,
+            jsdelivr: z1e,
+            types: B1e,
+            repository: j1e,
+            files: U1e,
+            scripts: G1e,
+            devDependencies: W1e,
+            peerDependencies: q1e,
+            dependencies: H1e
+        };
+    const nu = "#fff",
+        $3 = "#888",
+        X1e = {
             background: "#333",
             view: {
-                stroke: g5
+                stroke: $3
             },
             title: {
-                color: du,
-                subtitleColor: du
+                color: nu,
+                subtitleColor: nu
             },
             style: {
                 "guide-label": {
-                    fill: du
+                    fill: nu
                 },
                 "guide-title": {
-                    fill: du
+                    fill: nu
                 }
             },
             axis: {
-                domainColor: du,
-                gridColor: g5,
-                tickColor: du
+                domainColor: nu,
+                gridColor: $3,
+                tickColor: nu
             }
         },
-        To = "#4572a7",
-        rve = {
+        yo = "#4572a7",
+        V1e = {
             background: "#fff",
             arc: {
-                fill: To
+                fill: yo
             },
             area: {
-                fill: To
+                fill: yo
             },
             line: {
-                stroke: To,
+                stroke: yo,
                 strokeWidth: 2
             },
             path: {
-                stroke: To
+                stroke: yo
             },
             rect: {
-                fill: To
+                fill: yo
             },
             shape: {
-                stroke: To
+                stroke: yo
             },
             symbol: {
-                fill: To,
+                fill: yo,
                 strokeWidth: 1.5,
                 size: 50
             },
             axis: {
                 bandPosition: .5,
                 grid: !0,
                 gridColor: "#000000",
@@ -51303,118 +51772,118 @@
                 symbolSize: 50,
                 symbolType: "square"
             },
             range: {
                 category: ["#4572a7", "#aa4643", "#8aa453", "#71598e", "#4598ae", "#d98445", "#94aace", "#d09393", "#b9cc98", "#a99cbc"]
             }
         },
-        $o = "#30a2da",
-        rb = "#cbcbcb",
-        ave = "#999",
-        sve = "#333",
-        p5 = "#f0f0f0",
-        m5 = "#333",
-        ove = {
+        vo = "#30a2da",
+        Nv = "#cbcbcb",
+        K1e = "#999",
+        J1e = "#333",
+        T3 = "#f0f0f0",
+        M3 = "#333",
+        Q1e = {
             arc: {
-                fill: $o
+                fill: vo
             },
             area: {
-                fill: $o
+                fill: vo
             },
             axis: {
-                domainColor: rb,
+                domainColor: Nv,
                 grid: !0,
-                gridColor: rb,
+                gridColor: Nv,
                 gridWidth: 1,
-                labelColor: ave,
+                labelColor: K1e,
                 labelFontSize: 10,
-                titleColor: sve,
-                tickColor: rb,
+                titleColor: J1e,
+                tickColor: Nv,
                 tickSize: 10,
                 titleFontSize: 14,
                 titlePadding: 10,
                 labelPadding: 4
             },
             axisBand: {
                 grid: !1
             },
-            background: p5,
+            background: T3,
             group: {
-                fill: p5
+                fill: T3
             },
             legend: {
-                labelColor: m5,
+                labelColor: M3,
                 labelFontSize: 11,
                 padding: 1,
                 symbolSize: 30,
                 symbolType: "square",
-                titleColor: m5,
+                titleColor: M3,
                 titleFontSize: 14,
                 titlePadding: 10
             },
             line: {
-                stroke: $o,
+                stroke: vo,
                 strokeWidth: 2
             },
             path: {
-                stroke: $o,
+                stroke: vo,
                 strokeWidth: .5
             },
             rect: {
-                fill: $o
+                fill: vo
             },
             range: {
                 category: ["#30a2da", "#fc4f30", "#e5ae38", "#6d904f", "#8b8b8b", "#b96db8", "#ff9e27", "#56cc60", "#52d2ca", "#52689e", "#545454", "#9fe4f8"],
                 diverging: ["#cc0020", "#e77866", "#f6e7e1", "#d6e8ed", "#91bfd9", "#1d78b5"],
                 heatmap: ["#d6e8ed", "#cee0e5", "#91bfd9", "#549cc6", "#1d78b5"]
             },
             point: {
                 filled: !0,
                 shape: "circle"
             },
             shape: {
-                stroke: $o
+                stroke: vo
             },
             bar: {
                 binSpacing: 2,
-                fill: $o,
+                fill: vo,
                 stroke: null
             },
             title: {
                 anchor: "start",
                 fontSize: 24,
                 fontWeight: 600,
                 offset: 20
             }
         },
-        Mo = "#000",
-        lve = {
+        bo = "#000",
+        Z1e = {
             group: {
                 fill: "#e5e5e5"
             },
             arc: {
-                fill: Mo
+                fill: bo
             },
             area: {
-                fill: Mo
+                fill: bo
             },
             line: {
-                stroke: Mo
+                stroke: bo
             },
             path: {
-                stroke: Mo
+                stroke: bo
             },
             rect: {
-                fill: Mo
+                fill: bo
             },
             shape: {
-                stroke: Mo
+                stroke: bo
             },
             symbol: {
-                fill: Mo,
+                fill: bo,
                 size: 40
             },
             axis: {
                 domain: !1,
                 grid: !0,
                 gridColor: "#FFFFFF",
                 gridOpacity: 1,
@@ -51430,68 +51899,68 @@
                 labelFontSize: 11,
                 symbolSize: 40
             },
             range: {
                 category: ["#000000", "#7F7F7F", "#1A1A1A", "#999999", "#333333", "#B0B0B0", "#4D4D4D", "#C9C9C9", "#666666", "#DCDCDC"]
             }
         },
-        uve = 22,
-        cve = "normal",
-        y5 = "Benton Gothic, sans-serif",
-        v5 = 11.5,
-        fve = "normal",
-        Fo = "#82c6df",
-        ab = "Benton Gothic Bold, sans-serif",
-        b5 = "normal",
-        x5 = 13,
-        Of = {
+        eye = 22,
+        tye = "normal",
+        O3 = "Benton Gothic, sans-serif",
+        F3 = 11.5,
+        nye = "normal",
+        xo = "#82c6df",
+        Pv = "Benton Gothic Bold, sans-serif",
+        R3 = "normal",
+        D3 = 13,
+        df = {
             "category-6": ["#ec8431", "#829eb1", "#c89d29", "#3580b1", "#adc839", "#ab7fb4"],
             "fire-7": ["#fbf2c7", "#f9e39c", "#f8d36e", "#f4bb6a", "#e68a4f", "#d15a40", "#ab4232"],
             "fireandice-6": ["#e68a4f", "#f4bb6a", "#f9e39c", "#dadfe2", "#a6b7c6", "#849eae"],
             "ice-7": ["#edefee", "#dadfe2", "#c4ccd2", "#a6b7c6", "#849eae", "#607785", "#47525d"]
         },
-        hve = {
+        iye = {
             background: "#ffffff",
             title: {
                 anchor: "start",
                 color: "#000000",
-                font: ab,
-                fontSize: uve,
-                fontWeight: cve
+                font: Pv,
+                fontSize: eye,
+                fontWeight: tye
             },
             arc: {
-                fill: Fo
+                fill: xo
             },
             area: {
-                fill: Fo
+                fill: xo
             },
             line: {
-                stroke: Fo,
+                stroke: xo,
                 strokeWidth: 2
             },
             path: {
-                stroke: Fo
+                stroke: xo
             },
             rect: {
-                fill: Fo
+                fill: xo
             },
             shape: {
-                stroke: Fo
+                stroke: xo
             },
             symbol: {
-                fill: Fo,
+                fill: xo,
                 size: 30
             },
             axis: {
-                labelFont: y5,
-                labelFontSize: v5,
-                labelFontWeight: fve,
-                titleFont: ab,
-                titleFontSize: x5,
-                titleFontWeight: b5
+                labelFont: O3,
+                labelFontSize: F3,
+                labelFontWeight: nye,
+                titleFont: Pv,
+                titleFontSize: D3,
+                titleFontWeight: R3
             },
             axisX: {
                 labelAngle: 0,
                 labelPadding: 4,
                 tickSize: 3
             },
             axisY: {
@@ -51501,63 +51970,63 @@
                 tickSize: 2,
                 titleAlign: "left",
                 titleAngle: 0,
                 titleX: -45,
                 titleY: -11
             },
             legend: {
-                labelFont: y5,
-                labelFontSize: v5,
+                labelFont: O3,
+                labelFontSize: F3,
                 symbolType: "square",
-                titleFont: ab,
-                titleFontSize: x5,
-                titleFontWeight: b5
+                titleFont: Pv,
+                titleFontSize: D3,
+                titleFontWeight: R3
             },
             range: {
-                category: Of["category-6"],
-                diverging: Of["fireandice-6"],
-                heatmap: Of["fire-7"],
-                ordinal: Of["fire-7"],
-                ramp: Of["fire-7"]
+                category: df["category-6"],
+                diverging: df["fireandice-6"],
+                heatmap: df["fire-7"],
+                ordinal: df["fire-7"],
+                ramp: df["fire-7"]
             }
         },
-        Do = "#ab5787",
-        Vg = "#979797",
-        dve = {
+        _o = "#ab5787",
+        Rg = "#979797",
+        rye = {
             background: "#f9f9f9",
             arc: {
-                fill: Do
+                fill: _o
             },
             area: {
-                fill: Do
+                fill: _o
             },
             line: {
-                stroke: Do
+                stroke: _o
             },
             path: {
-                stroke: Do
+                stroke: _o
             },
             rect: {
-                fill: Do
+                fill: _o
             },
             shape: {
-                stroke: Do
+                stroke: _o
             },
             symbol: {
-                fill: Do,
+                fill: _o,
                 size: 30
             },
             axis: {
-                domainColor: Vg,
+                domainColor: Rg,
                 domainWidth: .5,
                 gridWidth: .2,
-                labelColor: Vg,
-                tickColor: Vg,
+                labelColor: Rg,
+                tickColor: Rg,
                 tickWidth: .2,
-                titleColor: Vg
+                titleColor: Rg
             },
             axisBand: {
                 grid: !1
             },
             axisX: {
                 grid: !0,
                 tickSize: 10
@@ -51573,37 +52042,37 @@
                 symbolSize: 30,
                 symbolType: "square"
             },
             range: {
                 category: ["#ab5787", "#51b2e5", "#703c5c", "#168dd9", "#d190b6", "#00609f", "#d365ba", "#154866", "#666666", "#c4c4c4"]
             }
         },
-        Ro = "#3e5c69",
-        gve = {
+        wo = "#3e5c69",
+        sye = {
             background: "#fff",
             arc: {
-                fill: Ro
+                fill: wo
             },
             area: {
-                fill: Ro
+                fill: wo
             },
             line: {
-                stroke: Ro
+                stroke: wo
             },
             path: {
-                stroke: Ro
+                stroke: wo
             },
             rect: {
-                fill: Ro
+                fill: wo
             },
             shape: {
-                stroke: Ro
+                stroke: wo
             },
             symbol: {
-                fill: Ro
+                fill: wo
             },
             axis: {
                 domainWidth: .5,
                 grid: !0,
                 labelPadding: 2,
                 tickSize: 5,
                 tickWidth: .5,
@@ -51624,23 +52093,23 @@
                 padding: 1,
                 symbolType: "square"
             },
             range: {
                 category: ["#3e5c69", "#6793a6", "#182429", "#0570b0", "#3690c0", "#74a9cf", "#a6bddb", "#e2ddf2"]
             }
         },
-        ki = "#1696d2",
-        _5 = "#000000",
-        pve = "#FFFFFF",
-        Kg = "Lato",
-        sb = "Lato",
-        mve = "Lato",
-        yve = "#DEDDDD",
-        vve = 18,
-        Cf = {
+        Ei = "#1696d2",
+        N3 = "#000000",
+        aye = "#FFFFFF",
+        Dg = "Lato",
+        Lv = "Lato",
+        oye = "Lato",
+        lye = "#DEDDDD",
+        uye = 18,
+        gf = {
             "main-colors": ["#1696d2", "#d2d2d2", "#000000", "#fdbf11", "#ec008b", "#55b748", "#5c5859", "#db2b27"],
             "shades-blue": ["#CFE8F3", "#A2D4EC", "#73BFE2", "#46ABDB", "#1696D2", "#12719E", "#0A4C6A", "#062635"],
             "shades-gray": ["#F5F5F5", "#ECECEC", "#E3E3E3", "#DCDBDB", "#D2D2D2", "#9D9D9D", "#696969", "#353535"],
             "shades-yellow": ["#FFF2CF", "#FCE39E", "#FDD870", "#FCCB41", "#FDBF11", "#E88E2D", "#CA5800", "#843215"],
             "shades-magenta": ["#F5CBDF", "#EB99C2", "#E46AA7", "#E54096", "#EC008B", "#AF1F6B", "#761548", "#351123"],
             "shades-green": ["#DCEDD9", "#BCDEB4", "#98CF90", "#78C26D", "#55B748", "#408941", "#2C5C2D", "#1A2E19"],
             "shades-black": ["#D5D5D4", "#ADABAC", "#848081", "#5C5859", "#332D2F", "#262223", "#1A1717", "#0E0C0D"],
@@ -51659,370 +52128,417 @@
             "five-groups-cat-2": ["#1696d2", "#0a4c6a", "#d2d2d2", "#fdbf11", "#332d2f"],
             "five-groups-seq": ["#cfe8f3", "#73bf42", "#1696d2", "#0a4c6a", "#000000"],
             "six-groups-cat-1": ["#1696d2", "#ec008b", "#fdbf11", "#000000", "#d2d2d2", "#55b748"],
             "six-groups-cat-2": ["#1696d2", "#d2d2d2", "#ec008b", "#fdbf11", "#332d2f", "#0a4c6a"],
             "six-groups-seq": ["#cfe8f3", "#a2d4ec", "#73bfe2", "#46abdb", "#1696d2", "#12719e"],
             "diverging-colors": ["#ca5800", "#fdbf11", "#fdd870", "#fff2cf", "#cfe8f3", "#73bfe2", "#1696d2", "#0a4c6a"]
         },
-        bve = {
-            background: pve,
+        cye = {
+            background: aye,
             title: {
                 anchor: "start",
-                fontSize: vve,
-                font: Kg
+                fontSize: uye,
+                font: Dg
             },
             axisX: {
                 domain: !0,
-                domainColor: _5,
+                domainColor: N3,
                 domainWidth: 1,
                 grid: !1,
                 labelFontSize: 12,
-                labelFont: sb,
+                labelFont: Lv,
                 labelAngle: 0,
-                tickColor: _5,
+                tickColor: N3,
                 tickSize: 5,
                 titleFontSize: 12,
                 titlePadding: 10,
-                titleFont: Kg
+                titleFont: Dg
             },
             axisY: {
                 domain: !1,
                 domainWidth: 1,
                 grid: !0,
-                gridColor: yve,
+                gridColor: lye,
                 gridWidth: 1,
                 labelFontSize: 12,
-                labelFont: sb,
+                labelFont: Lv,
                 labelPadding: 8,
                 ticks: !1,
                 titleFontSize: 12,
                 titlePadding: 10,
-                titleFont: Kg,
+                titleFont: Dg,
                 titleAngle: 0,
                 titleY: -10,
                 titleX: 18
             },
             legend: {
                 labelFontSize: 12,
-                labelFont: sb,
+                labelFont: Lv,
                 symbolSize: 100,
                 titleFontSize: 12,
                 titlePadding: 10,
-                titleFont: Kg,
+                titleFont: Dg,
                 orient: "right",
                 offset: 10
             },
             view: {
                 stroke: "transparent"
             },
             range: {
-                category: Cf["six-groups-cat-1"],
-                diverging: Cf["diverging-colors"],
-                heatmap: Cf["diverging-colors"],
-                ordinal: Cf["six-groups-seq"],
-                ramp: Cf["shades-blue"]
+                category: gf["six-groups-cat-1"],
+                diverging: gf["diverging-colors"],
+                heatmap: gf["diverging-colors"],
+                ordinal: gf["six-groups-seq"],
+                ramp: gf["shades-blue"]
             },
             area: {
-                fill: ki
+                fill: Ei
             },
             rect: {
-                fill: ki
+                fill: Ei
             },
             line: {
-                color: ki,
-                stroke: ki,
+                color: Ei,
+                stroke: Ei,
                 strokeWidth: 5
             },
             trail: {
-                color: ki,
-                stroke: ki,
+                color: Ei,
+                stroke: Ei,
                 strokeWidth: 0,
                 size: 1
             },
             path: {
-                stroke: ki,
+                stroke: Ei,
                 strokeWidth: .5
             },
             point: {
                 filled: !0
             },
             text: {
-                font: mve,
-                color: ki,
+                font: oye,
+                color: Ei,
                 fontSize: 11,
                 align: "center",
                 fontWeight: 400,
                 size: 11
             },
             style: {
                 bar: {
-                    fill: ki,
+                    fill: Ei,
                     stroke: null
                 }
             },
             arc: {
-                fill: ki
+                fill: Ei
             },
             shape: {
-                stroke: ki
+                stroke: Ei
             },
             symbol: {
-                fill: ki,
+                fill: Ei,
                 size: 30
             }
         },
-        Po = "#3366CC",
-        w5 = "#ccc",
-        Jg = "Arial, sans-serif",
-        xve = {
+        So = "#3366CC",
+        P3 = "#ccc",
+        Ng = "Arial, sans-serif",
+        fye = {
             arc: {
-                fill: Po
+                fill: So
             },
             area: {
-                fill: Po
+                fill: So
             },
             path: {
-                stroke: Po
+                stroke: So
             },
             rect: {
-                fill: Po
+                fill: So
             },
             shape: {
-                stroke: Po
+                stroke: So
             },
             symbol: {
-                stroke: Po
+                stroke: So
             },
             circle: {
-                fill: Po
+                fill: So
             },
             background: "#fff",
             padding: {
                 top: 10,
                 right: 10,
                 bottom: 10,
                 left: 10
             },
             style: {
                 "guide-label": {
-                    font: Jg,
+                    font: Ng,
                     fontSize: 12
                 },
                 "guide-title": {
-                    font: Jg,
+                    font: Ng,
                     fontSize: 12
                 },
                 "group-title": {
-                    font: Jg,
+                    font: Ng,
                     fontSize: 12
                 }
             },
             title: {
-                font: Jg,
+                font: Ng,
                 fontSize: 14,
                 fontWeight: "bold",
                 dy: -3,
                 anchor: "start"
             },
             axis: {
-                gridColor: w5,
-                tickColor: w5,
+                gridColor: P3,
+                tickColor: P3,
                 domain: !1,
                 grid: !0
             },
             range: {
                 category: ["#4285F4", "#DB4437", "#F4B400", "#0F9D58", "#AB47BC", "#00ACC1", "#FF7043", "#9E9D24", "#5C6BC0", "#F06292", "#00796B", "#C2185B"],
                 heatmap: ["#c6dafc", "#5e97f6", "#2a56c6"]
             }
         },
-        SC = e => e * (1 / 3 + 1),
-        S5 = SC(9),
-        E5 = SC(10),
-        O5 = SC(12),
-        kf = "Segoe UI",
-        C5 = "wf_standard-font, helvetica, arial, sans-serif",
-        k5 = "#252423",
-        Af = "#605E5C",
-        A5 = "transparent",
-        _ve = "#C8C6C4",
-        Ji = "#118DFF",
-        wve = "#12239E",
-        Sve = "#E66C37",
-        Eve = "#6B007B",
-        Ove = "#E044A7",
-        Cve = "#744EC2",
-        kve = "#D9B300",
-        Ave = "#D64550",
-        d8 = Ji,
-        g8 = "#DEEFFF",
-        T5 = [g8, d8],
-        Tve = [g8, "#c7e4ff", "#b0d9ff", "#9aceff", "#83c3ff", "#6cb9ff", "#55aeff", "#3fa3ff", "#2898ff", d8],
-        $ve = {
+        UC = e => e * (1 / 3 + 1),
+        L3 = UC(9),
+        I3 = UC(10),
+        z3 = UC(12),
+        pf = "Segoe UI",
+        B3 = "wf_standard-font, helvetica, arial, sans-serif",
+        j3 = "#252423",
+        mf = "#605E5C",
+        U3 = "transparent",
+        hye = "#C8C6C4",
+        Wi = "#118DFF",
+        dye = "#12239E",
+        gye = "#E66C37",
+        pye = "#6B007B",
+        mye = "#E044A7",
+        yye = "#744EC2",
+        vye = "#D9B300",
+        bye = "#D64550",
+        $8 = Wi,
+        T8 = "#DEEFFF",
+        G3 = [T8, $8],
+        xye = [T8, "#c7e4ff", "#b0d9ff", "#9aceff", "#83c3ff", "#6cb9ff", "#55aeff", "#3fa3ff", "#2898ff", $8],
+        _ye = {
             view: {
-                stroke: A5
+                stroke: U3
             },
-            background: A5,
-            font: kf,
+            background: U3,
+            font: pf,
             header: {
-                titleFont: C5,
-                titleFontSize: O5,
-                titleColor: k5,
-                labelFont: kf,
-                labelFontSize: E5,
-                labelColor: Af
+                titleFont: B3,
+                titleFontSize: z3,
+                titleColor: j3,
+                labelFont: pf,
+                labelFontSize: I3,
+                labelColor: mf
             },
             axis: {
                 ticks: !1,
                 grid: !1,
                 domain: !1,
-                labelColor: Af,
-                labelFontSize: S5,
-                titleFont: C5,
-                titleColor: k5,
-                titleFontSize: O5,
+                labelColor: mf,
+                labelFontSize: L3,
+                titleFont: B3,
+                titleColor: j3,
+                titleFontSize: z3,
                 titleFontWeight: "normal"
             },
             axisQuantitative: {
                 tickCount: 3,
                 grid: !0,
-                gridColor: _ve,
+                gridColor: hye,
                 gridDash: [1, 5],
                 labelFlush: !1
             },
             axisBand: {
                 tickExtra: !0
             },
             axisX: {
                 labelPadding: 5
             },
             axisY: {
                 labelPadding: 10
             },
             bar: {
-                fill: Ji
+                fill: Wi
             },
             line: {
-                stroke: Ji,
+                stroke: Wi,
                 strokeWidth: 3,
                 strokeCap: "round",
                 strokeJoin: "round"
             },
             text: {
-                font: kf,
-                fontSize: S5,
-                fill: Af
+                font: pf,
+                fontSize: L3,
+                fill: mf
             },
             arc: {
-                fill: Ji
+                fill: Wi
             },
             area: {
-                fill: Ji,
+                fill: Wi,
                 line: !0,
                 opacity: .6
             },
             path: {
-                stroke: Ji
+                stroke: Wi
             },
             rect: {
-                fill: Ji
+                fill: Wi
             },
             point: {
-                fill: Ji,
+                fill: Wi,
                 filled: !0,
                 size: 75
             },
             shape: {
-                stroke: Ji
+                stroke: Wi
             },
             symbol: {
-                fill: Ji,
+                fill: Wi,
                 strokeWidth: 1.5,
                 size: 50
             },
             legend: {
-                titleFont: kf,
+                titleFont: pf,
                 titleFontWeight: "bold",
-                titleColor: Af,
-                labelFont: kf,
-                labelFontSize: E5,
-                labelColor: Af,
+                titleColor: mf,
+                labelFont: pf,
+                labelFontSize: I3,
+                labelColor: mf,
                 symbolType: "circle",
                 symbolSize: 75
             },
             range: {
-                category: [Ji, wve, Sve, Eve, Ove, Cve, kve, Ave],
-                diverging: T5,
-                heatmap: T5,
-                ordinal: Tve
+                category: [Wi, dye, gye, pye, mye, yye, vye, bye],
+                diverging: G3,
+                heatmap: G3,
+                ordinal: xye
             }
         },
-        Mve = nve.version,
-        Fve = Object.freeze(Object.defineProperty({
+        wye = Y1e.version,
+        Sye = Object.freeze(Object.defineProperty({
             __proto__: null,
-            dark: ive,
-            excel: rve,
-            fivethirtyeight: ove,
-            ggplot2: lve,
-            googlecharts: xve,
-            latimes: hve,
-            powerbi: $ve,
-            quartz: dve,
-            urbaninstitute: bve,
-            version: Mve,
-            vox: gve
+            dark: X1e,
+            excel: V1e,
+            fivethirtyeight: Q1e,
+            ggplot2: Z1e,
+            googlecharts: fye,
+            latimes: iye,
+            powerbi: _ye,
+            quartz: rye,
+            urbaninstitute: cye,
+            version: wye,
+            vox: sye
         }, Symbol.toStringTag, {
             value: "Module"
         }));
 
-    function Dve(e, t) {
-        var n = {};
-        for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && t.indexOf(i) < 0 && (n[i] = e[i]);
-        if (e != null && typeof Object.getOwnPropertySymbols == "function")
-            for (var r = 0, i = Object.getOwnPropertySymbols(e); r < i.length; r++) t.indexOf(i[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, i[r]) && (n[i[r]] = e[i[r]]);
+    function qh(e) {
+        "@babel/helpers - typeof";
+        return qh = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
+            return typeof t
+        } : function(t) {
+            return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
+        }, qh(e)
+    }
+
+    function Eye(e, t) {
+        if (qh(e) !== "object" || e === null) return e;
+        var n = e[Symbol.toPrimitive];
+        if (n !== void 0) {
+            var i = n.call(e, t || "default");
+            if (qh(i) !== "object") return i;
+            throw new TypeError("@@toPrimitive must return a primitive value.")
+        }
+        return (t === "string" ? String : Number)(e)
+    }
+
+    function Cye(e) {
+        var t = Eye(e, "string");
+        return qh(t) === "symbol" ? t : String(t)
+    }
+
+    function kye(e, t, n) {
+        return t = Cye(t), t in e ? Object.defineProperty(e, t, {
+            value: n,
+            enumerable: !0,
+            configurable: !0,
+            writable: !0
+        }) : e[t] = n, e
+    }
+
+    function Aye(e, t) {
+        if (e == null) return {};
+        var n = {},
+            i = Object.keys(e),
+            r, s;
+        for (s = 0; s < i.length; s++) r = i[s], !(t.indexOf(r) >= 0) && (n[r] = e[r]);
         return n
     }
 
-    function Rve(e, t, n) {
-        if (q(e)) return `[${e.map(i=>t(re(i)?i:$5(i,n))).join(", ")}]`;
-        if (se(e)) {
+    function $ye(e, t) {
+        if (e == null) return {};
+        var n = Aye(e, t),
+            i, r;
+        if (Object.getOwnPropertySymbols) {
+            var s = Object.getOwnPropertySymbols(e);
+            for (r = 0; r < s.length; r++) i = s[r], !(t.indexOf(i) >= 0) && Object.prototype.propertyIsEnumerable.call(e, i) && (n[i] = e[i])
+        }
+        return n
+    }
+    const Tye = ["title", "image"];
+
+    function Mye(e, t, n) {
+        if (W(e)) return `[${e.map(i=>t(re(i)?i:W3(i,n))).join(", ")}]`;
+        if (ae(e)) {
             let i = "";
             const r = e,
                 {
-                    title: a,
-                    image: s
+                    title: s,
+                    image: a
                 } = r,
-                o = Dve(r, ["title", "image"]);
-            a && (i += `<h2>${t(a)}</h2>`), s && (i += `<img src="${t(s)}">`);
+                o = $ye(r, Tye);
+            s && (i += `<h2>${t(s)}</h2>`), a && (i += `<img src="${t(a)}">`);
             const l = Object.keys(o);
             if (l.length > 0) {
                 i += "<table>";
                 for (const u of l) {
                     let c = o[u];
-                    c !== void 0 && (se(c) && (c = $5(c, n)), i += `<tr><td class="key">${t(u)}:</td><td class="value">${t(c)}</td></tr>`)
+                    c !== void 0 && (ae(c) && (c = W3(c, n)), i += `<tr><td class="key">${t(u)}:</td><td class="value">${t(c)}</td></tr>`)
                 }
                 i += "</table>"
             }
             return i || "{}"
         }
         return t(e)
     }
 
-    function Pve(e) {
+    function Oye(e) {
         const t = [];
         return function(n, i) {
             if (typeof i != "object" || i === null) return i;
             const r = t.indexOf(this) + 1;
             return t.length = r, t.length > e ? "[Object]" : t.indexOf(i) >= 0 ? "[Circular]" : (t.push(i), i)
         }
     }
 
-    function $5(e, t) {
-        return JSON.stringify(e, Pve(t))
+    function W3(e, t) {
+        return JSON.stringify(e, Oye(t))
     }
-    var Nve = `#vg-tooltip-element {
+    var Fye = `#vg-tooltip-element {
   visibility: hidden;
   padding: 8px;
   position: fixed;
   z-index: 1000;
   font-family: sans-serif;
   font-size: 11px;
   border-radius: 3px;
@@ -52036,18 +52552,14 @@
   visibility: visible;
 }
 #vg-tooltip-element h2 {
   margin-top: 0;
   margin-bottom: 10px;
   font-size: 13px;
 }
-#vg-tooltip-element img {
-  max-width: 200px;
-  max-height: 200px;
-}
 #vg-tooltip-element table {
   border-spacing: 0;
 }
 #vg-tooltip-element table tr {
   border: none;
 }
 #vg-tooltip-element table tr td {
@@ -52073,1348 +52585,926 @@
   border: 1px solid #f5f5f5;
   color: white;
 }
 #vg-tooltip-element.dark-theme td.key {
   color: #bfbfbf;
 }
 `;
-    const p8 = "vg-tooltip-element",
-        Lve = {
+    const M8 = "vg-tooltip-element",
+        Rye = {
             offsetX: 10,
             offsetY: 10,
-            id: p8,
+            id: M8,
             styleId: "vega-tooltip-style",
             theme: "light",
             disableDefaultStyle: !1,
-            sanitize: Ive,
+            sanitize: Dye,
             maxDepth: 2,
-            formatTooltip: Rve
+            formatTooltip: Mye
         };
 
-    function Ive(e) {
+    function Dye(e) {
         return String(e).replace(/&/g, "&amp;").replace(/</g, "&lt;")
     }
 
-    function jve(e) {
+    function Nye(e) {
         if (!/^[A-Za-z]+[-:.\w]*$/.test(e)) throw new Error("Invalid HTML ID");
-        return Nve.toString().replace(p8, e)
+        return Fye.toString().replace(M8, e)
     }
 
-    function zve(e, t, n, i) {
+    function Pye(e, t, n, i) {
         let r = e.clientX + n;
         r + t.width > window.innerWidth && (r = +e.clientX - n - t.width);
-        let a = e.clientY + i;
-        return a + t.height > window.innerHeight && (a = +e.clientY - i - t.height), {
+        let s = e.clientY + i;
+        return s + t.height > window.innerHeight && (s = +e.clientY - i - t.height), {
             x: r,
-            y: a
+            y: s
+        }
+    }
+
+    function q3(e, t) {
+        var n = Object.keys(e);
+        if (Object.getOwnPropertySymbols) {
+            var i = Object.getOwnPropertySymbols(e);
+            t && (i = i.filter(function(r) {
+                return Object.getOwnPropertyDescriptor(e, r).enumerable
+            })), n.push.apply(n, i)
         }
+        return n
     }
-    class Bve {
+
+    function H3(e) {
+        for (var t = 1; t < arguments.length; t++) {
+            var n = arguments[t] != null ? arguments[t] : {};
+            t % 2 ? q3(Object(n), !0).forEach(function(i) {
+                kye(e, i, n[i])
+            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : q3(Object(n)).forEach(function(i) {
+                Object.defineProperty(e, i, Object.getOwnPropertyDescriptor(n, i))
+            })
+        }
+        return e
+    }
+    class Lye {
         constructor(t) {
-            this.options = Object.assign(Object.assign({}, Lve), t);
+            this.options = H3(H3({}, Rye), t);
             const n = this.options.id;
             if (this.el = null, this.call = this.tooltipHandler.bind(this), !this.options.disableDefaultStyle && !document.getElementById(this.options.styleId)) {
                 const i = document.createElement("style");
-                i.setAttribute("id", this.options.styleId), i.innerHTML = jve(n);
+                i.setAttribute("id", this.options.styleId), i.innerHTML = Nye(n);
                 const r = document.head;
                 r.childNodes.length > 0 ? r.insertBefore(i, r.childNodes[0]) : r.appendChild(i)
             }
         }
         tooltipHandler(t, n, i, r) {
-            var a;
-            if (this.el = document.getElementById(this.options.id), this.el || (this.el = document.createElement("div"), this.el.setAttribute("id", this.options.id), this.el.classList.add("vg-tooltip"), ((a = document.fullscreenElement) !== null && a !== void 0 ? a : document.body).appendChild(this.el)), r == null || r === "") {
+            if (this.el = document.getElementById(this.options.id), this.el || (this.el = document.createElement("div"), this.el.setAttribute("id", this.options.id), this.el.classList.add("vg-tooltip"), (document.fullscreenElement ?? document.body).appendChild(this.el)), r == null || r === "") {
                 this.el.classList.remove("visible", `${this.options.theme}-theme`);
                 return
             }
             this.el.innerHTML = this.options.formatTooltip(r, this.options.sanitize, this.options.maxDepth), this.el.classList.add("visible", `${this.options.theme}-theme`);
             const {
                 x: s,
-                y: o
-            } = zve(n, this.el.getBoundingClientRect(), this.options.offsetX, this.options.offsetY);
-            this.el.style.top = `${o}px`, this.el.style.left = `${s}px`
+                y: a
+            } = Pye(n, this.el.getBoundingClientRect(), this.options.offsetX, this.options.offsetY);
+            this.el.style.top = `${a}px`, this.el.style.left = `${s}px`
         }
     }
 
-    function rd(e) {
-        return rd = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
+    function Hh(e) {
+        "@babel/helpers - typeof";
+        return Hh = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
             return typeof t
         } : function(t) {
             return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
-        }, rd(e)
+        }, Hh(e)
     }
 
-    function Gve(e, t) {
-        if (rd(e) !== "object" || e === null) return e;
+    function Iye(e, t) {
+        if (Hh(e) !== "object" || e === null) return e;
         var n = e[Symbol.toPrimitive];
         if (n !== void 0) {
             var i = n.call(e, t || "default");
-            if (rd(i) !== "object") return i;
+            if (Hh(i) !== "object") return i;
             throw new TypeError("@@toPrimitive must return a primitive value.")
         }
         return (t === "string" ? String : Number)(e)
     }
 
-    function Uve(e) {
-        var t = Gve(e, "string");
-        return rd(t) === "symbol" ? t : String(t)
+    function zye(e) {
+        var t = Iye(e, "string");
+        return Hh(t) === "symbol" ? t : String(t)
     }
 
-    function qve(e, t, n) {
-        return t = Uve(t), t in e ? Object.defineProperty(e, t, {
+    function Bye(e, t, n) {
+        return t = zye(t), t in e ? Object.defineProperty(e, t, {
             value: n,
             enumerable: !0,
             configurable: !0,
             writable: !0
         }) : e[t] = n, e
     }
 
-    function M5(e, t, n, i, r, a, s) {
-        try {
-            var o = e[a](s),
-                l = o.value
-        } catch (u) {
-            n(u);
-            return
-        }
-        o.done ? t(l) : Promise.resolve(l).then(i, r)
-    }
-
-    function pm(e) {
-        return function() {
-            var t = this,
-                n = arguments;
-            return new Promise(function(i, r) {
-                var a = e.apply(t, n);
-
-                function s(l) {
-                    M5(a, i, r, s, o, "next", l)
-                }
-
-                function o(l) {
-                    M5(a, i, r, s, o, "throw", l)
-                }
-                s(void 0)
-            })
-        }
-    }
-    var m8 = Object.prototype,
-        Ko = m8.hasOwnProperty,
-        zr, EC = typeof Symbol == "function" ? Symbol : {},
-        Ey = EC.iterator || "@@iterator",
-        Wve = EC.asyncIterator || "@@asyncIterator",
-        mm = EC.toStringTag || "@@toStringTag";
-
-    function y8(e, t, n, i) {
-        var r = t && t.prototype instanceof Wx ? t : Wx,
-            a = Object.create(r.prototype),
-            s = new Hx(i || []);
-        return a._invoke = Kve(e, n, s), a
+    function jye(e) {
+        return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e
     }
+    var Iv, Y3;
 
-    function OC(e, t, n) {
-        try {
-            return {
-                type: "normal",
-                arg: e.call(t, n)
+    function Uye() {
+        return Y3 || (Y3 = 1, Iv = function(e) {
+            e.prototype[Symbol.iterator] = function*() {
+                for (let t = this.head; t; t = t.next) yield t.value
             }
-        } catch (i) {
-            return {
-                type: "throw",
-                arg: i
-            }
-        }
+        }), Iv
     }
-    var F5 = "suspendedStart",
-        Hve = "suspendedYield",
-        D5 = "executing",
-        Qg = "completed",
-        lr = {};
-
-    function Wx() {}
+    var Gye = qe;
+    qe.Node = vl;
+    qe.create = qe;
 
-    function Oy() {}
-
-    function wc() {}
-    var CC = {};
-    CC[Ey] = function() {
-        return this
-    };
-    var ob = Object.getPrototypeOf,
-        Zg = ob && ob(ob(kC([])));
-    Zg && Zg !== m8 && Ko.call(Zg, Ey) && (CC = Zg);
-    var Kc = wc.prototype = Wx.prototype = Object.create(CC);
-    Oy.prototype = Kc.constructor = wc;
-    wc.constructor = Oy;
-    wc[mm] = Oy.displayName = "GeneratorFunction";
-
-    function v8(e) {
-        ["next", "throw", "return"].forEach(function(t) {
-            e[t] = function(n) {
-                return this._invoke(t, n)
-            }
-        })
-    }
-
-    function b8(e) {
-        var t = typeof e == "function" && e.constructor;
-        return t ? t === Oy || (t.displayName || t.name) === "GeneratorFunction" : !1
-    }
-
-    function Yve(e) {
-        return Object.setPrototypeOf ? Object.setPrototypeOf(e, wc) : (e.__proto__ = wc, mm in e || (e[mm] = "GeneratorFunction")), e.prototype = Object.create(Kc), e
-    }
-
-    function Xve(e) {
-        return {
-            __await: e
-        }
-    }
-
-    function Cy(e, t) {
-        function n(a, s, o, l) {
-            var u = OC(e[a], e, s);
-            if (u.type === "throw") l(u.arg);
-            else {
-                var c = u.arg,
-                    f = c.value;
-                return f && typeof f == "object" && Ko.call(f, "__await") ? t.resolve(f.__await).then(function(h) {
-                    n("next", h, o, l)
-                }, function(h) {
-                    n("throw", h, o, l)
-                }) : t.resolve(f).then(function(h) {
-                    c.value = h, o(c)
-                }, function(h) {
-                    return n("throw", h, o, l)
-                })
-            }
-        }
-        var i;
-
-        function r(a, s) {
-            function o() {
-                return new t(function(l, u) {
-                    n(a, s, l, u)
-                })
-            }
-            return i = i ? i.then(o, o) : o()
-        }
-        this._invoke = r
-    }
-    v8(Cy.prototype);
-    Cy.prototype[Wve] = function() {
-        return this
-    };
-
-    function Vve(e, t, n, i, r) {
-        r === void 0 && (r = Promise);
-        var a = new Cy(y8(e, t, n, i), r);
-        return b8(t) ? a : a.next().then(function(s) {
-            return s.done ? s.value : a.next()
-        })
-    }
-
-    function Kve(e, t, n) {
-        var i = F5;
-        return function(a, s) {
-            if (i === D5) throw new Error("Generator is already running");
-            if (i === Qg) {
-                if (a === "throw") throw s;
-                return _8()
-            }
-            for (n.method = a, n.arg = s;;) {
-                var o = n.delegate;
-                if (o) {
-                    var l = x8(o, n);
-                    if (l) {
-                        if (l === lr) continue;
-                        return l
-                    }
-                }
-                if (n.method === "next") n.sent = n._sent = n.arg;
-                else if (n.method === "throw") {
-                    if (i === F5) throw i = Qg, n.arg;
-                    n.dispatchException(n.arg)
-                } else n.method === "return" && n.abrupt("return", n.arg);
-                i = D5;
-                var u = OC(e, t, n);
-                if (u.type === "normal") {
-                    if (i = n.done ? Qg : Hve, u.arg === lr) continue;
-                    return {
-                        value: u.arg,
-                        done: n.done
-                    }
-                } else u.type === "throw" && (i = Qg, n.method = "throw", n.arg = u.arg)
-            }
-        }
-    }
-
-    function x8(e, t) {
-        var n = e.iterator[t.method];
-        if (n === zr) {
-            if (t.delegate = null, t.method === "throw") {
-                if (e.iterator.return && (t.method = "return", t.arg = zr, x8(e, t), t.method === "throw")) return lr;
-                t.method = "throw", t.arg = new TypeError("The iterator does not provide a 'throw' method")
-            }
-            return lr
-        }
-        var i = OC(n, e.iterator, t.arg);
-        if (i.type === "throw") return t.method = "throw", t.arg = i.arg, t.delegate = null, lr;
-        var r = i.arg;
-        if (!r) return t.method = "throw", t.arg = new TypeError("iterator result is not an object"), t.delegate = null, lr;
-        if (r.done) t[e.resultName] = r.value, t.next = e.nextLoc, t.method !== "return" && (t.method = "next", t.arg = zr);
-        else return r;
-        return t.delegate = null, lr
-    }
-    v8(Kc);
-    Kc[mm] = "Generator";
-    Kc[Ey] = function() {
-        return this
-    };
-    Kc.toString = function() {
-        return "[object Generator]"
-    };
-
-    function Jve(e) {
-        var t = {
-            tryLoc: e[0]
-        };
-        1 in e && (t.catchLoc = e[1]), 2 in e && (t.finallyLoc = e[2], t.afterLoc = e[3]), this.tryEntries.push(t)
-    }
-
-    function lb(e) {
-        var t = e.completion || {};
-        t.type = "normal", delete t.arg, e.completion = t
-    }
-
-    function Hx(e) {
-        this.tryEntries = [{
-            tryLoc: "root"
-        }], e.forEach(Jve, this), this.reset(!0)
-    }
-
-    function Qve(e) {
-        var t = [];
-        for (var n in e) t.push(n);
-        return t.reverse(),
-            function i() {
-                for (; t.length;) {
-                    var r = t.pop();
-                    if (r in e) return i.value = r, i.done = !1, i
-                }
-                return i.done = !0, i
-            }
-    }
-
-    function kC(e) {
-        if (e) {
-            var t = e[Ey];
-            if (t) return t.call(e);
-            if (typeof e.next == "function") return e;
-            if (!isNaN(e.length)) {
-                var n = -1,
-                    i = function r() {
-                        for (; ++n < e.length;)
-                            if (Ko.call(e, n)) return r.value = e[n], r.done = !1, r;
-                        return r.value = zr, r.done = !0, r
-                    };
-                return i.next = i
-            }
-        }
-        return {
-            next: _8
-        }
-    }
-
-    function _8() {
-        return {
-            value: zr,
-            done: !0
-        }
-    }
-    Hx.prototype = {
-        constructor: Hx,
-        reset: function(t) {
-            if (this.prev = 0, this.next = 0, this.sent = this._sent = zr, this.done = !1, this.delegate = null, this.method = "next", this.arg = zr, this.tryEntries.forEach(lb), !t)
-                for (var n in this) n.charAt(0) === "t" && Ko.call(this, n) && !isNaN(+n.slice(1)) && (this[n] = zr)
-        },
-        stop: function() {
-            this.done = !0;
-            var t = this.tryEntries[0],
-                n = t.completion;
-            if (n.type === "throw") throw n.arg;
-            return this.rval
-        },
-        dispatchException: function(t) {
-            if (this.done) throw t;
-            var n = this;
-
-            function i(u, c) {
-                return s.type = "throw", s.arg = t, n.next = u, c && (n.method = "next", n.arg = zr), !!c
-            }
-            for (var r = this.tryEntries.length - 1; r >= 0; --r) {
-                var a = this.tryEntries[r],
-                    s = a.completion;
-                if (a.tryLoc === "root") return i("end");
-                if (a.tryLoc <= this.prev) {
-                    var o = Ko.call(a, "catchLoc"),
-                        l = Ko.call(a, "finallyLoc");
-                    if (o && l) {
-                        if (this.prev < a.catchLoc) return i(a.catchLoc, !0);
-                        if (this.prev < a.finallyLoc) return i(a.finallyLoc)
-                    } else if (o) {
-                        if (this.prev < a.catchLoc) return i(a.catchLoc, !0)
-                    } else if (l) {
-                        if (this.prev < a.finallyLoc) return i(a.finallyLoc)
-                    } else throw new Error("try statement without catch or finally")
-                }
-            }
-        },
-        abrupt: function(t, n) {
-            for (var i = this.tryEntries.length - 1; i >= 0; --i) {
-                var r = this.tryEntries[i];
-                if (r.tryLoc <= this.prev && Ko.call(r, "finallyLoc") && this.prev < r.finallyLoc) {
-                    var a = r;
-                    break
-                }
-            }
-            a && (t === "break" || t === "continue") && a.tryLoc <= n && n <= a.finallyLoc && (a = null);
-            var s = a ? a.completion : {};
-            return s.type = t, s.arg = n, a ? (this.method = "next", this.next = a.finallyLoc, lr) : this.complete(s)
-        },
-        complete: function(t, n) {
-            if (t.type === "throw") throw t.arg;
-            return t.type === "break" || t.type === "continue" ? this.next = t.arg : t.type === "return" ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : t.type === "normal" && n && (this.next = n), lr
-        },
-        finish: function(t) {
-            for (var n = this.tryEntries.length - 1; n >= 0; --n) {
-                var i = this.tryEntries[n];
-                if (i.finallyLoc === t) return this.complete(i.completion, i.afterLoc), lb(i), lr
-            }
-        },
-        catch: function(t) {
-            for (var n = this.tryEntries.length - 1; n >= 0; --n) {
-                var i = this.tryEntries[n];
-                if (i.tryLoc === t) {
-                    var r = i.completion;
-                    if (r.type === "throw") {
-                        var a = r.arg;
-                        lb(i)
-                    }
-                    return a
-                }
-            }
-            throw new Error("illegal catch attempt")
-        },
-        delegateYield: function(t, n, i) {
-            return this.delegate = {
-                iterator: kC(t),
-                resultName: n,
-                nextLoc: i
-            }, this.method === "next" && (this.arg = zr), lr
-        }
-    };
-    var Ai = {
-            wrap: y8,
-            isGeneratorFunction: b8,
-            AsyncIterator: Cy,
-            mark: Yve,
-            awrap: Xve,
-            async: Vve,
-            keys: Qve,
-            values: kC
-        },
-        ub, R5;
-
-    function Zve() {
-        return R5 || (R5 = 1, ub = function(t) {
-            t.prototype[Symbol.iterator] = Ai.mark(function n() {
-                var i;
-                return Ai.wrap(function(a) {
-                    for (;;) switch (a.prev = a.next) {
-                        case 0:
-                            i = this.head;
-                        case 1:
-                            if (!i) {
-                                a.next = 7;
-                                break
-                            }
-                            return a.next = 4, i.value;
-                        case 4:
-                            i = i.next, a.next = 1;
-                            break;
-                        case 7:
-                        case "end":
-                            return a.stop()
-                    }
-                }, n, this)
-            })
-        }), ub
-    }
-    var ebe = We;
-    We.Node = Tl;
-    We.create = We;
-
-    function We(e) {
+    function qe(e) {
         var t = this;
-        if (t instanceof We || (t = new We), t.tail = null, t.head = null, t.length = 0, e && typeof e.forEach == "function") e.forEach(function(r) {
+        if (t instanceof qe || (t = new qe), t.tail = null, t.head = null, t.length = 0, e && typeof e.forEach == "function") e.forEach(function(r) {
             t.push(r)
         });
         else if (arguments.length > 0)
             for (var n = 0, i = arguments.length; n < i; n++) t.push(arguments[n]);
         return t
     }
-    We.prototype.removeNode = function(e) {
+    qe.prototype.removeNode = function(e) {
         if (e.list !== this) throw new Error("removing node which does not belong to this list");
         var t = e.next,
             n = e.prev;
         return t && (t.prev = n), n && (n.next = t), e === this.head && (this.head = t), e === this.tail && (this.tail = n), e.list.length--, e.next = null, e.prev = null, e.list = null, t
     };
-    We.prototype.unshiftNode = function(e) {
+    qe.prototype.unshiftNode = function(e) {
         if (e !== this.head) {
             e.list && e.list.removeNode(e);
             var t = this.head;
             e.list = this, e.next = t, t && (t.prev = e), this.head = e, this.tail || (this.tail = e), this.length++
         }
     };
-    We.prototype.pushNode = function(e) {
+    qe.prototype.pushNode = function(e) {
         if (e !== this.tail) {
             e.list && e.list.removeNode(e);
             var t = this.tail;
             e.list = this, e.prev = t, t && (t.next = e), this.tail = e, this.head || (this.head = e), this.length++
         }
     };
-    We.prototype.push = function() {
-        for (var e = 0, t = arguments.length; e < t; e++) nbe(this, arguments[e]);
+    qe.prototype.push = function() {
+        for (var e = 0, t = arguments.length; e < t; e++) qye(this, arguments[e]);
         return this.length
     };
-    We.prototype.unshift = function() {
-        for (var e = 0, t = arguments.length; e < t; e++) ibe(this, arguments[e]);
+    qe.prototype.unshift = function() {
+        for (var e = 0, t = arguments.length; e < t; e++) Hye(this, arguments[e]);
         return this.length
     };
-    We.prototype.pop = function() {
+    qe.prototype.pop = function() {
         if (this.tail) {
             var e = this.tail.value;
             return this.tail = this.tail.prev, this.tail ? this.tail.next = null : this.head = null, this.length--, e
         }
     };
-    We.prototype.shift = function() {
+    qe.prototype.shift = function() {
         if (this.head) {
             var e = this.head.value;
             return this.head = this.head.next, this.head ? this.head.prev = null : this.tail = null, this.length--, e
         }
     };
-    We.prototype.forEach = function(e, t) {
+    qe.prototype.forEach = function(e, t) {
         t = t || this;
         for (var n = this.head, i = 0; n !== null; i++) e.call(t, n.value, i, this), n = n.next
     };
-    We.prototype.forEachReverse = function(e, t) {
+    qe.prototype.forEachReverse = function(e, t) {
         t = t || this;
         for (var n = this.tail, i = this.length - 1; n !== null; i--) e.call(t, n.value, i, this), n = n.prev
     };
-    We.prototype.get = function(e) {
+    qe.prototype.get = function(e) {
         for (var t = 0, n = this.head; n !== null && t < e; t++) n = n.next;
         if (t === e && n !== null) return n.value
     };
-    We.prototype.getReverse = function(e) {
+    qe.prototype.getReverse = function(e) {
         for (var t = 0, n = this.tail; n !== null && t < e; t++) n = n.prev;
         if (t === e && n !== null) return n.value
     };
-    We.prototype.map = function(e, t) {
+    qe.prototype.map = function(e, t) {
         t = t || this;
-        for (var n = new We, i = this.head; i !== null;) n.push(e.call(t, i.value, this)), i = i.next;
+        for (var n = new qe, i = this.head; i !== null;) n.push(e.call(t, i.value, this)), i = i.next;
         return n
     };
-    We.prototype.mapReverse = function(e, t) {
+    qe.prototype.mapReverse = function(e, t) {
         t = t || this;
-        for (var n = new We, i = this.tail; i !== null;) n.push(e.call(t, i.value, this)), i = i.prev;
+        for (var n = new qe, i = this.tail; i !== null;) n.push(e.call(t, i.value, this)), i = i.prev;
         return n
     };
-    We.prototype.reduce = function(e, t) {
+    qe.prototype.reduce = function(e, t) {
         var n, i = this.head;
         if (arguments.length > 1) n = t;
         else if (this.head) i = this.head.next, n = this.head.value;
         else throw new TypeError("Reduce of empty list with no initial value");
         for (var r = 0; i !== null; r++) n = e(n, i.value, r), i = i.next;
         return n
     };
-    We.prototype.reduceReverse = function(e, t) {
+    qe.prototype.reduceReverse = function(e, t) {
         var n, i = this.tail;
         if (arguments.length > 1) n = t;
         else if (this.tail) i = this.tail.prev, n = this.tail.value;
         else throw new TypeError("Reduce of empty list with no initial value");
         for (var r = this.length - 1; i !== null; r--) n = e(n, i.value, r), i = i.prev;
         return n
     };
-    We.prototype.toArray = function() {
+    qe.prototype.toArray = function() {
         for (var e = new Array(this.length), t = 0, n = this.head; n !== null; t++) e[t] = n.value, n = n.next;
         return e
     };
-    We.prototype.toArrayReverse = function() {
+    qe.prototype.toArrayReverse = function() {
         for (var e = new Array(this.length), t = 0, n = this.tail; n !== null; t++) e[t] = n.value, n = n.prev;
         return e
     };
-    We.prototype.slice = function(e, t) {
+    qe.prototype.slice = function(e, t) {
         t = t || this.length, t < 0 && (t += this.length), e = e || 0, e < 0 && (e += this.length);
-        var n = new We;
+        var n = new qe;
         if (t < e || t < 0) return n;
         e < 0 && (e = 0), t > this.length && (t = this.length);
         for (var i = 0, r = this.head; r !== null && i < e; i++) r = r.next;
         for (; r !== null && i < t; i++, r = r.next) n.push(r.value);
         return n
     };
-    We.prototype.sliceReverse = function(e, t) {
+    qe.prototype.sliceReverse = function(e, t) {
         t = t || this.length, t < 0 && (t += this.length), e = e || 0, e < 0 && (e += this.length);
-        var n = new We;
+        var n = new qe;
         if (t < e || t < 0) return n;
         e < 0 && (e = 0), t > this.length && (t = this.length);
         for (var i = this.length, r = this.tail; r !== null && i > t; i--) r = r.prev;
         for (; r !== null && i > e; i--, r = r.prev) n.push(r.value);
         return n
     };
-    We.prototype.splice = function(e, t) {
+    qe.prototype.splice = function(e, t, ...n) {
         e > this.length && (e = this.length - 1), e < 0 && (e = this.length + e);
-        for (var n = 0, i = this.head; i !== null && n < e; n++) i = i.next;
-        for (var r = [], n = 0; i && n < t; n++) r.push(i.value), i = this.removeNode(i);
-        i === null && (i = this.tail), i !== this.head && i !== this.tail && (i = i.prev);
-        for (var n = 0; n < (arguments.length <= 2 ? 0 : arguments.length - 2); n++) i = tbe(this, i, n + 2 < 2 || arguments.length <= n + 2 ? void 0 : arguments[n + 2]);
-        return r
+        for (var i = 0, r = this.head; r !== null && i < e; i++) r = r.next;
+        for (var s = [], i = 0; r && i < t; i++) s.push(r.value), r = this.removeNode(r);
+        r === null && (r = this.tail), r !== this.head && r !== this.tail && (r = r.prev);
+        for (var i = 0; i < n.length; i++) r = Wye(this, r, n[i]);
+        return s
     };
-    We.prototype.reverse = function() {
+    qe.prototype.reverse = function() {
         for (var e = this.head, t = this.tail, n = e; n !== null; n = n.prev) {
             var i = n.prev;
             n.prev = n.next, n.next = i
         }
         return this.head = t, this.tail = e, this
     };
 
-    function tbe(e, t, n) {
-        var i = t === e.head ? new Tl(n, null, t, e) : new Tl(n, t, t.next, e);
+    function Wye(e, t, n) {
+        var i = t === e.head ? new vl(n, null, t, e) : new vl(n, t, t.next, e);
         return i.next === null && (e.tail = i), i.prev === null && (e.head = i), e.length++, i
     }
 
-    function nbe(e, t) {
-        e.tail = new Tl(t, e.tail, null, e), e.head || (e.head = e.tail), e.length++
+    function qye(e, t) {
+        e.tail = new vl(t, e.tail, null, e), e.head || (e.head = e.tail), e.length++
     }
 
-    function ibe(e, t) {
-        e.head = new Tl(t, null, e.head, e), e.tail || (e.tail = e.head), e.length++
+    function Hye(e, t) {
+        e.head = new vl(t, null, e.head, e), e.tail || (e.tail = e.head), e.length++
     }
 
-    function Tl(e, t, n, i) {
-        if (!(this instanceof Tl)) return new Tl(e, t, n, i);
+    function vl(e, t, n, i) {
+        if (!(this instanceof vl)) return new vl(e, t, n, i);
         this.list = i, this.value = e, t ? (t.next = this, this.prev = t) : this.prev = null, n ? (n.prev = this, this.next = n) : this.next = null
     }
     try {
-        Zve()(We)
+        Uye()(qe)
     } catch {}
-    var rbe = ebe,
-        qo = Symbol("max"),
-        Ma = Symbol("length"),
-        gu = Symbol("lengthCalculator"),
-        wh = Symbol("allowStale"),
-        Jo = Symbol("maxAge"),
-        Aa = Symbol("dispose"),
-        P5 = Symbol("noDisposeOnSet"),
-        zt = Symbol("lruList"),
-        Qi = Symbol("cache"),
-        w8 = Symbol("updateAgeOnGet"),
-        cb = () => 1;
-    class abe {
+    const Yye = Gye,
+        Fo = Symbol("max"),
+        _s = Symbol("length"),
+        iu = Symbol("lengthCalculator"),
+        ch = Symbol("allowStale"),
+        Io = Symbol("maxAge"),
+        vs = Symbol("dispose"),
+        X3 = Symbol("noDisposeOnSet"),
+        Pt = Symbol("lruList"),
+        qi = Symbol("cache"),
+        O8 = Symbol("updateAgeOnGet"),
+        zv = () => 1;
+    class Xye {
         constructor(t) {
             if (typeof t == "number" && (t = {
                     max: t
                 }), t || (t = {}), t.max && (typeof t.max != "number" || t.max < 0)) throw new TypeError("max must be a non-negative number");
-            this[qo] = t.max || 1 / 0;
-            var n = t.length || cb;
-            if (this[gu] = typeof n != "function" ? cb : n, this[wh] = t.stale || !1, t.maxAge && typeof t.maxAge != "number") throw new TypeError("maxAge must be a number");
-            this[Jo] = t.maxAge || 0, this[Aa] = t.dispose, this[P5] = t.noDisposeOnSet || !1, this[w8] = t.updateAgeOnGet || !1, this.reset()
+            this[Fo] = t.max || 1 / 0;
+            const n = t.length || zv;
+            if (this[iu] = typeof n != "function" ? zv : n, this[ch] = t.stale || !1, t.maxAge && typeof t.maxAge != "number") throw new TypeError("maxAge must be a number");
+            this[Io] = t.maxAge || 0, this[vs] = t.dispose, this[X3] = t.noDisposeOnSet || !1, this[O8] = t.updateAgeOnGet || !1, this.reset()
         }
         set max(t) {
             if (typeof t != "number" || t < 0) throw new TypeError("max must be a non-negative number");
-            this[qo] = t || 1 / 0, Tf(this)
+            this[Fo] = t || 1 / 0, yf(this)
         }
         get max() {
-            return this[qo]
+            return this[Fo]
         }
         set allowStale(t) {
-            this[wh] = !!t
+            this[ch] = !!t
         }
         get allowStale() {
-            return this[wh]
+            return this[ch]
         }
         set maxAge(t) {
             if (typeof t != "number") throw new TypeError("maxAge must be a non-negative number");
-            this[Jo] = t, Tf(this)
+            this[Io] = t, yf(this)
         }
         get maxAge() {
-            return this[Jo]
+            return this[Io]
         }
         set lengthCalculator(t) {
-            typeof t != "function" && (t = cb), t !== this[gu] && (this[gu] = t, this[Ma] = 0, this[zt].forEach(n => {
-                n.length = this[gu](n.value, n.key), this[Ma] += n.length
-            })), Tf(this)
+            typeof t != "function" && (t = zv), t !== this[iu] && (this[iu] = t, this[_s] = 0, this[Pt].forEach(n => {
+                n.length = this[iu](n.value, n.key), this[_s] += n.length
+            })), yf(this)
         }
         get lengthCalculator() {
-            return this[gu]
+            return this[iu]
         }
         get length() {
-            return this[Ma]
+            return this[_s]
         }
         get itemCount() {
-            return this[zt].length
+            return this[Pt].length
         }
         rforEach(t, n) {
             n = n || this;
-            for (var i = this[zt].tail; i !== null;) {
-                var r = i.prev;
-                N5(this, t, i, n), i = r
+            for (let i = this[Pt].tail; i !== null;) {
+                const r = i.prev;
+                V3(this, t, i, n), i = r
             }
         }
         forEach(t, n) {
             n = n || this;
-            for (var i = this[zt].head; i !== null;) {
-                var r = i.next;
-                N5(this, t, i, n), i = r
+            for (let i = this[Pt].head; i !== null;) {
+                const r = i.next;
+                V3(this, t, i, n), i = r
             }
         }
         keys() {
-            return this[zt].toArray().map(t => t.key)
+            return this[Pt].toArray().map(t => t.key)
         }
         values() {
-            return this[zt].toArray().map(t => t.value)
+            return this[Pt].toArray().map(t => t.value)
         }
         reset() {
-            this[Aa] && this[zt] && this[zt].length && this[zt].forEach(t => this[Aa](t.key, t.value)), this[Qi] = new Map, this[zt] = new rbe, this[Ma] = 0
+            this[vs] && this[Pt] && this[Pt].length && this[Pt].forEach(t => this[vs](t.key, t.value)), this[qi] = new Map, this[Pt] = new Yye, this[_s] = 0
         }
         dump() {
-            return this[zt].map(t => ym(this, t) ? !1 : {
+            return this[Pt].map(t => J0(this, t) ? !1 : {
                 k: t.key,
                 v: t.value,
                 e: t.now + (t.maxAge || 0)
             }).toArray().filter(t => t)
         }
         dumpLru() {
-            return this[zt]
+            return this[Pt]
         }
         set(t, n, i) {
-            if (i = i || this[Jo], i && typeof i != "number") throw new TypeError("maxAge must be a number");
-            var r = i ? Date.now() : 0,
-                a = this[gu](n, t);
-            if (this[Qi].has(t)) {
-                if (a > this[qo]) return zu(this, this[Qi].get(t)), !1;
-                var s = this[Qi].get(t),
-                    o = s.value;
-                return this[Aa] && (this[P5] || this[Aa](t, o.value)), o.now = r, o.maxAge = i, o.value = n, this[Ma] += a - o.length, o.length = a, this.get(t), Tf(this), !0
+            if (i = i || this[Io], i && typeof i != "number") throw new TypeError("maxAge must be a number");
+            const r = i ? Date.now() : 0,
+                s = this[iu](n, t);
+            if (this[qi].has(t)) {
+                if (s > this[Fo]) return Tu(this, this[qi].get(t)), !1;
+                const l = this[qi].get(t).value;
+                return this[vs] && (this[X3] || this[vs](t, l.value)), l.now = r, l.maxAge = i, l.value = n, this[_s] += s - l.length, l.length = s, this.get(t), yf(this), !0
             }
-            var l = new sbe(t, n, a, r, i);
-            return l.length > this[qo] ? (this[Aa] && this[Aa](t, n), !1) : (this[Ma] += l.length, this[zt].unshift(l), this[Qi].set(t, this[zt].head), Tf(this), !0)
+            const a = new Vye(t, n, s, r, i);
+            return a.length > this[Fo] ? (this[vs] && this[vs](t, n), !1) : (this[_s] += a.length, this[Pt].unshift(a), this[qi].set(t, this[Pt].head), yf(this), !0)
         }
         has(t) {
-            if (!this[Qi].has(t)) return !1;
-            var n = this[Qi].get(t).value;
-            return !ym(this, n)
+            if (!this[qi].has(t)) return !1;
+            const n = this[qi].get(t).value;
+            return !J0(this, n)
         }
         get(t) {
-            return fb(this, t, !0)
+            return Bv(this, t, !0)
         }
         peek(t) {
-            return fb(this, t, !1)
+            return Bv(this, t, !1)
         }
         pop() {
-            var t = this[zt].tail;
-            return t ? (zu(this, t), t.value) : null
+            const t = this[Pt].tail;
+            return t ? (Tu(this, t), t.value) : null
         }
         del(t) {
-            zu(this, this[Qi].get(t))
+            Tu(this, this[qi].get(t))
         }
         load(t) {
             this.reset();
-            for (var n = Date.now(), i = t.length - 1; i >= 0; i--) {
-                var r = t[i],
-                    a = r.e || 0;
-                if (a === 0) this.set(r.k, r.v);
+            const n = Date.now();
+            for (let i = t.length - 1; i >= 0; i--) {
+                const r = t[i],
+                    s = r.e || 0;
+                if (s === 0) this.set(r.k, r.v);
                 else {
-                    var s = a - n;
-                    s > 0 && this.set(r.k, r.v, s)
+                    const a = s - n;
+                    a > 0 && this.set(r.k, r.v, a)
                 }
             }
         }
         prune() {
-            this[Qi].forEach((t, n) => fb(this, n, !1))
+            this[qi].forEach((t, n) => Bv(this, n, !1))
         }
     }
-    var fb = (e, t, n) => {
-            var i = e[Qi].get(t);
+    const Bv = (e, t, n) => {
+            const i = e[qi].get(t);
             if (i) {
-                var r = i.value;
-                if (ym(e, r)) {
-                    if (zu(e, i), !e[wh]) return
-                } else n && (e[w8] && (i.value.now = Date.now()), e[zt].unshiftNode(i));
+                const r = i.value;
+                if (J0(e, r)) {
+                    if (Tu(e, i), !e[ch]) return
+                } else n && (e[O8] && (i.value.now = Date.now()), e[Pt].unshiftNode(i));
                 return r.value
             }
         },
-        ym = (e, t) => {
-            if (!t || !t.maxAge && !e[Jo]) return !1;
-            var n = Date.now() - t.now;
-            return t.maxAge ? n > t.maxAge : e[Jo] && n > e[Jo]
-        },
-        Tf = e => {
-            if (e[Ma] > e[qo])
-                for (var t = e[zt].tail; e[Ma] > e[qo] && t !== null;) {
-                    var n = t.prev;
-                    zu(e, t), t = n
+        J0 = (e, t) => {
+            if (!t || !t.maxAge && !e[Io]) return !1;
+            const n = Date.now() - t.now;
+            return t.maxAge ? n > t.maxAge : e[Io] && n > e[Io]
+        },
+        yf = e => {
+            if (e[_s] > e[Fo])
+                for (let t = e[Pt].tail; e[_s] > e[Fo] && t !== null;) {
+                    const n = t.prev;
+                    Tu(e, t), t = n
                 }
         },
-        zu = (e, t) => {
+        Tu = (e, t) => {
             if (t) {
-                var n = t.value;
-                e[Aa] && e[Aa](n.key, n.value), e[Ma] -= n.length, e[Qi].delete(n.key), e[zt].removeNode(t)
+                const n = t.value;
+                e[vs] && e[vs](n.key, n.value), e[_s] -= n.length, e[qi].delete(n.key), e[Pt].removeNode(t)
             }
         };
-    class sbe {
-        constructor(t, n, i, r, a) {
-            this.key = t, this.value = n, this.length = i, this.now = r, this.maxAge = a || 0
+    class Vye {
+        constructor(t, n, i, r, s) {
+            this.key = t, this.value = n, this.length = i, this.now = r, this.maxAge = s || 0
         }
     }
-    var N5 = (e, t, n, i) => {
-            var r = n.value;
-            ym(e, r) && (zu(e, n), e[wh] || (r = void 0)), r && t.call(i, r.value, r.key, e)
-        },
-        obe = abe,
-        lbe = ["includePrerelease", "loose", "rtl"],
-        ube = e => e ? typeof e != "object" ? {
+    const V3 = (e, t, n, i) => {
+        let r = n.value;
+        J0(e, r) && (Tu(e, n), e[ch] || (r = void 0)), r && t.call(i, r.value, r.key, e)
+    };
+    var Kye = Xye;
+    const Jye = Object.freeze({
             loose: !0
-        } : lbe.filter(t => e[t]).reduce((t, n) => (t[n] = !0, t), {}) : {},
-        AC = ube,
-        $i = {},
-        cbe = {
-            get exports() {
-                return $i
-            },
-            set exports(e) {
-                $i = e
-            }
-        },
-        fbe = "2.0.0",
-        hbe = 256,
-        dbe = Number.MAX_SAFE_INTEGER || 9007199254740991,
-        gbe = 16,
-        TC = {
-            SEMVER_SPEC_VERSION: fbe,
-            MAX_LENGTH: hbe,
-            MAX_SAFE_INTEGER: dbe,
-            MAX_SAFE_COMPONENT_LENGTH: gbe
-        },
-        pbe = typeof process == "object" && process.env && {}.NODE_DEBUG && /\bsemver\b/i.test({}.NODE_DEBUG) ? function() {
-            for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];
-            return console.error("SEMVER", ...t)
-        } : () => {},
-        ky = pbe;
+        }),
+        Qye = Object.freeze({}),
+        Zye = e => e ? typeof e != "object" ? Jye : e : Qye;
+    var GC = Zye,
+        gx = {
+            exports: {}
+        };
+    const eve = "2.0.0",
+        tve = 256,
+        nve = Number.MAX_SAFE_INTEGER || 9007199254740991,
+        ive = 16,
+        rve = ["major", "premajor", "minor", "preminor", "patch", "prepatch", "prerelease"];
+    var WC = {
+        MAX_LENGTH: tve,
+        MAX_SAFE_COMPONENT_LENGTH: ive,
+        MAX_SAFE_INTEGER: nve,
+        RELEASE_TYPES: rve,
+        SEMVER_SPEC_VERSION: eve,
+        FLAG_INCLUDE_PRERELEASE: 1,
+        FLAG_LOOSE: 2
+    };
+    const sve = typeof process == "object" && process.env && {}.NODE_DEBUG && /\bsemver\b/i.test({}.NODE_DEBUG) ? (...e) => console.error("SEMVER", ...e) : () => {};
+    var ay = sve;
     (function(e, t) {
-        var n = TC.MAX_SAFE_COMPONENT_LENGTH,
-            i = ky;
+        const {
+            MAX_SAFE_COMPONENT_LENGTH: n
+        } = WC, i = ay;
         t = e.exports = {};
-        var r = t.re = [],
-            a = t.src = [],
-            s = t.t = {},
-            o = 0,
-            l = (u, c, f) => {
-                var h = o++;
-                i(u, h, c), s[u] = h, a[h] = c, r[h] = new RegExp(c, f ? "g" : void 0)
-            };
-        l("NUMERICIDENTIFIER", "0|[1-9]\\d*"), l("NUMERICIDENTIFIERLOOSE", "[0-9]+"), l("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*"), l("MAINVERSION", "(".concat(a[s.NUMERICIDENTIFIER], ")\\.") + "(".concat(a[s.NUMERICIDENTIFIER], ")\\.") + "(".concat(a[s.NUMERICIDENTIFIER], ")")), l("MAINVERSIONLOOSE", "(".concat(a[s.NUMERICIDENTIFIERLOOSE], ")\\.") + "(".concat(a[s.NUMERICIDENTIFIERLOOSE], ")\\.") + "(".concat(a[s.NUMERICIDENTIFIERLOOSE], ")")), l("PRERELEASEIDENTIFIER", "(?:".concat(a[s.NUMERICIDENTIFIER], "|").concat(a[s.NONNUMERICIDENTIFIER], ")")), l("PRERELEASEIDENTIFIERLOOSE", "(?:".concat(a[s.NUMERICIDENTIFIERLOOSE], "|").concat(a[s.NONNUMERICIDENTIFIER], ")")), l("PRERELEASE", "(?:-(".concat(a[s.PRERELEASEIDENTIFIER], "(?:\\.").concat(a[s.PRERELEASEIDENTIFIER], ")*))")), l("PRERELEASELOOSE", "(?:-?(".concat(a[s.PRERELEASEIDENTIFIERLOOSE], "(?:\\.").concat(a[s.PRERELEASEIDENTIFIERLOOSE], ")*))")), l("BUILDIDENTIFIER", "[0-9A-Za-z-]+"), l("BUILD", "(?:\\+(".concat(a[s.BUILDIDENTIFIER], "(?:\\.").concat(a[s.BUILDIDENTIFIER], ")*))")), l("FULLPLAIN", "v?".concat(a[s.MAINVERSION]).concat(a[s.PRERELEASE], "?").concat(a[s.BUILD], "?")), l("FULL", "^".concat(a[s.FULLPLAIN], "$")), l("LOOSEPLAIN", "[v=\\s]*".concat(a[s.MAINVERSIONLOOSE]).concat(a[s.PRERELEASELOOSE], "?").concat(a[s.BUILD], "?")), l("LOOSE", "^".concat(a[s.LOOSEPLAIN], "$")), l("GTLT", "((?:<|>)?=?)"), l("XRANGEIDENTIFIERLOOSE", "".concat(a[s.NUMERICIDENTIFIERLOOSE], "|x|X|\\*")), l("XRANGEIDENTIFIER", "".concat(a[s.NUMERICIDENTIFIER], "|x|X|\\*")), l("XRANGEPLAIN", "[v=\\s]*(".concat(a[s.XRANGEIDENTIFIER], ")") + "(?:\\.(".concat(a[s.XRANGEIDENTIFIER], ")") + "(?:\\.(".concat(a[s.XRANGEIDENTIFIER], ")") + "(?:".concat(a[s.PRERELEASE], ")?").concat(a[s.BUILD], "?") + ")?)?"), l("XRANGEPLAINLOOSE", "[v=\\s]*(".concat(a[s.XRANGEIDENTIFIERLOOSE], ")") + "(?:\\.(".concat(a[s.XRANGEIDENTIFIERLOOSE], ")") + "(?:\\.(".concat(a[s.XRANGEIDENTIFIERLOOSE], ")") + "(?:".concat(a[s.PRERELEASELOOSE], ")?").concat(a[s.BUILD], "?") + ")?)?"), l("XRANGE", "^".concat(a[s.GTLT], "\\s*").concat(a[s.XRANGEPLAIN], "$")), l("XRANGELOOSE", "^".concat(a[s.GTLT], "\\s*").concat(a[s.XRANGEPLAINLOOSE], "$")), l("COERCE", "".concat("(^|[^\\d])(\\d{1,").concat(n, "})") + "(?:\\.(\\d{1,".concat(n, "}))?") + "(?:\\.(\\d{1,".concat(n, "}))?") + "(?:$|[^\\d])"), l("COERCERTL", a[s.COERCE], !0), l("LONETILDE", "(?:~>?)"), l("TILDETRIM", "(\\s*)".concat(a[s.LONETILDE], "\\s+"), !0), t.tildeTrimReplace = "$1~", l("TILDE", "^".concat(a[s.LONETILDE]).concat(a[s.XRANGEPLAIN], "$")), l("TILDELOOSE", "^".concat(a[s.LONETILDE]).concat(a[s.XRANGEPLAINLOOSE], "$")), l("LONECARET", "(?:\\^)"), l("CARETTRIM", "(\\s*)".concat(a[s.LONECARET], "\\s+"), !0), t.caretTrimReplace = "$1^", l("CARET", "^".concat(a[s.LONECARET]).concat(a[s.XRANGEPLAIN], "$")), l("CARETLOOSE", "^".concat(a[s.LONECARET]).concat(a[s.XRANGEPLAINLOOSE], "$")), l("COMPARATORLOOSE", "^".concat(a[s.GTLT], "\\s*(").concat(a[s.LOOSEPLAIN], ")$|^$")), l("COMPARATOR", "^".concat(a[s.GTLT], "\\s*(").concat(a[s.FULLPLAIN], ")$|^$")), l("COMPARATORTRIM", "(\\s*)".concat(a[s.GTLT], "\\s*(").concat(a[s.LOOSEPLAIN], "|").concat(a[s.XRANGEPLAIN], ")"), !0), t.comparatorTrimReplace = "$1$2$3", l("HYPHENRANGE", "^\\s*(".concat(a[s.XRANGEPLAIN], ")") + "\\s+-\\s+" + "(".concat(a[s.XRANGEPLAIN], ")") + "\\s*$"), l("HYPHENRANGELOOSE", "^\\s*(".concat(a[s.XRANGEPLAINLOOSE], ")") + "\\s+-\\s+" + "(".concat(a[s.XRANGEPLAINLOOSE], ")") + "\\s*$"), l("STAR", "(<|>)?=?\\s*\\*"), l("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$"), l("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$")
-    })(cbe, $i);
-    var L5 = /^[0-9]+$/,
-        S8 = (e, t) => {
-            var n = L5.test(e),
-                i = L5.test(t);
+        const r = t.re = [],
+            s = t.src = [],
+            a = t.t = {};
+        let o = 0;
+        const l = (u, c, f) => {
+            const h = o++;
+            i(u, h, c), a[u] = h, s[h] = c, r[h] = new RegExp(c, f ? "g" : void 0)
+        };
+        l("NUMERICIDENTIFIER", "0|[1-9]\\d*"), l("NUMERICIDENTIFIERLOOSE", "[0-9]+"), l("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*"), l("MAINVERSION", `(${s[a.NUMERICIDENTIFIER]})\\.(${s[a.NUMERICIDENTIFIER]})\\.(${s[a.NUMERICIDENTIFIER]})`), l("MAINVERSIONLOOSE", `(${s[a.NUMERICIDENTIFIERLOOSE]})\\.(${s[a.NUMERICIDENTIFIERLOOSE]})\\.(${s[a.NUMERICIDENTIFIERLOOSE]})`), l("PRERELEASEIDENTIFIER", `(?:${s[a.NUMERICIDENTIFIER]}|${s[a.NONNUMERICIDENTIFIER]})`), l("PRERELEASEIDENTIFIERLOOSE", `(?:${s[a.NUMERICIDENTIFIERLOOSE]}|${s[a.NONNUMERICIDENTIFIER]})`), l("PRERELEASE", `(?:-(${s[a.PRERELEASEIDENTIFIER]}(?:\\.${s[a.PRERELEASEIDENTIFIER]})*))`), l("PRERELEASELOOSE", `(?:-?(${s[a.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${s[a.PRERELEASEIDENTIFIERLOOSE]})*))`), l("BUILDIDENTIFIER", "[0-9A-Za-z-]+"), l("BUILD", `(?:\\+(${s[a.BUILDIDENTIFIER]}(?:\\.${s[a.BUILDIDENTIFIER]})*))`), l("FULLPLAIN", `v?${s[a.MAINVERSION]}${s[a.PRERELEASE]}?${s[a.BUILD]}?`), l("FULL", `^${s[a.FULLPLAIN]}$`), l("LOOSEPLAIN", `[v=\\s]*${s[a.MAINVERSIONLOOSE]}${s[a.PRERELEASELOOSE]}?${s[a.BUILD]}?`), l("LOOSE", `^${s[a.LOOSEPLAIN]}$`), l("GTLT", "((?:<|>)?=?)"), l("XRANGEIDENTIFIERLOOSE", `${s[a.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`), l("XRANGEIDENTIFIER", `${s[a.NUMERICIDENTIFIER]}|x|X|\\*`), l("XRANGEPLAIN", `[v=\\s]*(${s[a.XRANGEIDENTIFIER]})(?:\\.(${s[a.XRANGEIDENTIFIER]})(?:\\.(${s[a.XRANGEIDENTIFIER]})(?:${s[a.PRERELEASE]})?${s[a.BUILD]}?)?)?`), l("XRANGEPLAINLOOSE", `[v=\\s]*(${s[a.XRANGEIDENTIFIERLOOSE]})(?:\\.(${s[a.XRANGEIDENTIFIERLOOSE]})(?:\\.(${s[a.XRANGEIDENTIFIERLOOSE]})(?:${s[a.PRERELEASELOOSE]})?${s[a.BUILD]}?)?)?`), l("XRANGE", `^${s[a.GTLT]}\\s*${s[a.XRANGEPLAIN]}$`), l("XRANGELOOSE", `^${s[a.GTLT]}\\s*${s[a.XRANGEPLAINLOOSE]}$`), l("COERCE", `(^|[^\\d])(\\d{1,${n}})(?:\\.(\\d{1,${n}}))?(?:\\.(\\d{1,${n}}))?(?:$|[^\\d])`), l("COERCERTL", s[a.COERCE], !0), l("LONETILDE", "(?:~>?)"), l("TILDETRIM", `(\\s*)${s[a.LONETILDE]}\\s+`, !0), t.tildeTrimReplace = "$1~", l("TILDE", `^${s[a.LONETILDE]}${s[a.XRANGEPLAIN]}$`), l("TILDELOOSE", `^${s[a.LONETILDE]}${s[a.XRANGEPLAINLOOSE]}$`), l("LONECARET", "(?:\\^)"), l("CARETTRIM", `(\\s*)${s[a.LONECARET]}\\s+`, !0), t.caretTrimReplace = "$1^", l("CARET", `^${s[a.LONECARET]}${s[a.XRANGEPLAIN]}$`), l("CARETLOOSE", `^${s[a.LONECARET]}${s[a.XRANGEPLAINLOOSE]}$`), l("COMPARATORLOOSE", `^${s[a.GTLT]}\\s*(${s[a.LOOSEPLAIN]})$|^$`), l("COMPARATOR", `^${s[a.GTLT]}\\s*(${s[a.FULLPLAIN]})$|^$`), l("COMPARATORTRIM", `(\\s*)${s[a.GTLT]}\\s*(${s[a.LOOSEPLAIN]}|${s[a.XRANGEPLAIN]})`, !0), t.comparatorTrimReplace = "$1$2$3", l("HYPHENRANGE", `^\\s*(${s[a.XRANGEPLAIN]})\\s+-\\s+(${s[a.XRANGEPLAIN]})\\s*$`), l("HYPHENRANGELOOSE", `^\\s*(${s[a.XRANGEPLAINLOOSE]})\\s+-\\s+(${s[a.XRANGEPLAINLOOSE]})\\s*$`), l("STAR", "(<|>)?=?\\s*\\*"), l("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$"), l("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$")
+    })(gx, gx.exports);
+    var qC = gx.exports;
+    const K3 = /^[0-9]+$/,
+        F8 = (e, t) => {
+            const n = K3.test(e),
+                i = K3.test(t);
             return n && i && (e = +e, t = +t), e === t ? 0 : n && !i ? -1 : i && !n ? 1 : e < t ? -1 : 1
         },
-        mbe = (e, t) => S8(t, e),
-        ybe = {
-            compareIdentifiers: S8,
-            rcompareIdentifiers: mbe
-        },
-        ep = ky,
-        I5 = TC.MAX_LENGTH,
-        tp = TC.MAX_SAFE_INTEGER,
-        j5 = $i.re,
-        z5 = $i.t,
-        vbe = AC,
-        pu = ybe.compareIdentifiers;
-    let bbe = class Dr {
+        ave = (e, t) => F8(t, e);
+    var ove = {
+        compareIdentifiers: F8,
+        rcompareIdentifiers: ave
+    };
+    const Pg = ay,
+        {
+            MAX_LENGTH: J3,
+            MAX_SAFE_INTEGER: Lg
+        } = WC,
+        {
+            re: Q3,
+            t: Z3
+        } = qC,
+        lve = GC,
+        {
+            compareIdentifiers: ru
+        } = ove;
+    let uve = class $r {
         constructor(t, n) {
-            if (n = vbe(n), t instanceof Dr) {
+            if (n = lve(n), t instanceof $r) {
                 if (t.loose === !!n.loose && t.includePrerelease === !!n.includePrerelease) return t;
                 t = t.version
-            } else if (typeof t != "string") throw new TypeError("Invalid Version: ".concat(t));
-            if (t.length > I5) throw new TypeError("version is longer than ".concat(I5, " characters"));
-            ep("SemVer", t, n), this.options = n, this.loose = !!n.loose, this.includePrerelease = !!n.includePrerelease;
-            var i = t.trim().match(n.loose ? j5[z5.LOOSE] : j5[z5.FULL]);
-            if (!i) throw new TypeError("Invalid Version: ".concat(t));
-            if (this.raw = t, this.major = +i[1], this.minor = +i[2], this.patch = +i[3], this.major > tp || this.major < 0) throw new TypeError("Invalid major version");
-            if (this.minor > tp || this.minor < 0) throw new TypeError("Invalid minor version");
-            if (this.patch > tp || this.patch < 0) throw new TypeError("Invalid patch version");
+            } else if (typeof t != "string") throw new TypeError(`Invalid Version: ${t}`);
+            if (t.length > J3) throw new TypeError(`version is longer than ${J3} characters`);
+            Pg("SemVer", t, n), this.options = n, this.loose = !!n.loose, this.includePrerelease = !!n.includePrerelease;
+            const i = t.trim().match(n.loose ? Q3[Z3.LOOSE] : Q3[Z3.FULL]);
+            if (!i) throw new TypeError(`Invalid Version: ${t}`);
+            if (this.raw = t, this.major = +i[1], this.minor = +i[2], this.patch = +i[3], this.major > Lg || this.major < 0) throw new TypeError("Invalid major version");
+            if (this.minor > Lg || this.minor < 0) throw new TypeError("Invalid minor version");
+            if (this.patch > Lg || this.patch < 0) throw new TypeError("Invalid patch version");
             i[4] ? this.prerelease = i[4].split(".").map(r => {
                 if (/^[0-9]+$/.test(r)) {
-                    var a = +r;
-                    if (a >= 0 && a < tp) return a
+                    const s = +r;
+                    if (s >= 0 && s < Lg) return s
                 }
                 return r
             }) : this.prerelease = [], this.build = i[5] ? i[5].split(".") : [], this.format()
         }
         format() {
-            return this.version = "".concat(this.major, ".").concat(this.minor, ".").concat(this.patch), this.prerelease.length && (this.version += "-".concat(this.prerelease.join("."))), this.version
+            return this.version = `${this.major}.${this.minor}.${this.patch}`, this.prerelease.length && (this.version += `-${this.prerelease.join(".")}`), this.version
         }
         toString() {
             return this.version
         }
         compare(t) {
-            if (ep("SemVer.compare", this.version, this.options, t), !(t instanceof Dr)) {
+            if (Pg("SemVer.compare", this.version, this.options, t), !(t instanceof $r)) {
                 if (typeof t == "string" && t === this.version) return 0;
-                t = new Dr(t, this.options)
+                t = new $r(t, this.options)
             }
             return t.version === this.version ? 0 : this.compareMain(t) || this.comparePre(t)
         }
         compareMain(t) {
-            return t instanceof Dr || (t = new Dr(t, this.options)), pu(this.major, t.major) || pu(this.minor, t.minor) || pu(this.patch, t.patch)
+            return t instanceof $r || (t = new $r(t, this.options)), ru(this.major, t.major) || ru(this.minor, t.minor) || ru(this.patch, t.patch)
         }
         comparePre(t) {
-            if (t instanceof Dr || (t = new Dr(t, this.options)), this.prerelease.length && !t.prerelease.length) return -1;
+            if (t instanceof $r || (t = new $r(t, this.options)), this.prerelease.length && !t.prerelease.length) return -1;
             if (!this.prerelease.length && t.prerelease.length) return 1;
             if (!this.prerelease.length && !t.prerelease.length) return 0;
-            var n = 0;
+            let n = 0;
             do {
-                var i = this.prerelease[n],
+                const i = this.prerelease[n],
                     r = t.prerelease[n];
-                if (ep("prerelease compare", n, i, r), i === void 0 && r === void 0) return 0;
+                if (Pg("prerelease compare", n, i, r), i === void 0 && r === void 0) return 0;
                 if (r === void 0) return 1;
                 if (i === void 0) return -1;
                 if (i === r) continue;
-                return pu(i, r)
+                return ru(i, r)
             } while (++n)
         }
         compareBuild(t) {
-            t instanceof Dr || (t = new Dr(t, this.options));
-            var n = 0;
+            t instanceof $r || (t = new $r(t, this.options));
+            let n = 0;
             do {
-                var i = this.build[n],
+                const i = this.build[n],
                     r = t.build[n];
-                if (ep("prerelease compare", n, i, r), i === void 0 && r === void 0) return 0;
+                if (Pg("prerelease compare", n, i, r), i === void 0 && r === void 0) return 0;
                 if (r === void 0) return 1;
                 if (i === void 0) return -1;
                 if (i === r) continue;
-                return pu(i, r)
+                return ru(i, r)
             } while (++n)
         }
-        inc(t, n) {
+        inc(t, n, i) {
             switch (t) {
                 case "premajor":
-                    this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", n);
+                    this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", n, i);
                     break;
                 case "preminor":
-                    this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", n);
+                    this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", n, i);
                     break;
                 case "prepatch":
-                    this.prerelease.length = 0, this.inc("patch", n), this.inc("pre", n);
+                    this.prerelease.length = 0, this.inc("patch", n, i), this.inc("pre", n, i);
                     break;
                 case "prerelease":
-                    this.prerelease.length === 0 && this.inc("patch", n), this.inc("pre", n);
+                    this.prerelease.length === 0 && this.inc("patch", n, i), this.inc("pre", n, i);
                     break;
                 case "major":
                     (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) && this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
                     break;
                 case "minor":
                     (this.patch !== 0 || this.prerelease.length === 0) && this.minor++, this.patch = 0, this.prerelease = [];
                     break;
                 case "patch":
                     this.prerelease.length === 0 && this.patch++, this.prerelease = [];
                     break;
                 case "pre":
                     if (this.prerelease.length === 0) this.prerelease = [0];
                     else {
-                        for (var i = this.prerelease.length; --i >= 0;) typeof this.prerelease[i] == "number" && (this.prerelease[i]++, i = -2);
-                        i === -1 && this.prerelease.push(0)
+                        let r = this.prerelease.length;
+                        for (; --r >= 0;) typeof this.prerelease[r] == "number" && (this.prerelease[r]++, r = -2);
+                        r === -1 && this.prerelease.push(0)
+                    }
+                    if (n) {
+                        const r = Number(i) ? 1 : 0;
+                        ru(this.prerelease[0], n) === 0 ? isNaN(this.prerelease[1]) && (this.prerelease = [n, r]) : this.prerelease = [n, r]
                     }
-                    n && (pu(this.prerelease[0], n) === 0 ? isNaN(this.prerelease[1]) && (this.prerelease = [n, 0]) : this.prerelease = [n, 0]);
                     break;
                 default:
-                    throw new Error("invalid increment argument: ".concat(t))
+                    throw new Error(`invalid increment argument: ${t}`)
             }
             return this.format(), this.raw = this.version, this
         }
     };
-    var $C = bbe,
-        B5 = $C,
-        xbe = (e, t, n) => new B5(e, n).compare(new B5(t, n)),
-        Jc = xbe,
-        _be = Jc,
-        wbe = (e, t, n) => _be(e, t, n) === 0,
-        Sbe = wbe,
-        Ebe = Jc,
-        Obe = (e, t, n) => Ebe(e, t, n) !== 0,
-        Cbe = Obe,
-        kbe = Jc,
-        Abe = (e, t, n) => kbe(e, t, n) > 0,
-        Tbe = Abe,
-        $be = Jc,
-        Mbe = (e, t, n) => $be(e, t, n) >= 0,
-        Fbe = Mbe,
-        Dbe = Jc,
-        Rbe = (e, t, n) => Dbe(e, t, n) < 0,
-        Pbe = Rbe,
-        Nbe = Jc,
-        Lbe = (e, t, n) => Nbe(e, t, n) <= 0,
-        Ibe = Lbe,
-        jbe = Sbe,
-        zbe = Cbe,
-        Bbe = Tbe,
-        Gbe = Fbe,
-        Ube = Pbe,
-        qbe = Ibe,
-        Wbe = (e, t, n, i) => {
+    var HC = uve;
+    const eM = HC,
+        cve = (e, t, n) => new eM(e, n).compare(new eM(t, n));
+    var zc = cve;
+    const fve = zc,
+        hve = (e, t, n) => fve(e, t, n) === 0;
+    var dve = hve;
+    const gve = zc,
+        pve = (e, t, n) => gve(e, t, n) !== 0;
+    var mve = pve;
+    const yve = zc,
+        vve = (e, t, n) => yve(e, t, n) > 0;
+    var bve = vve;
+    const xve = zc,
+        _ve = (e, t, n) => xve(e, t, n) >= 0;
+    var wve = _ve;
+    const Sve = zc,
+        Eve = (e, t, n) => Sve(e, t, n) < 0;
+    var Cve = Eve;
+    const kve = zc,
+        Ave = (e, t, n) => kve(e, t, n) <= 0;
+    var $ve = Ave;
+    const Tve = dve,
+        Mve = mve,
+        Ove = bve,
+        Fve = wve,
+        Rve = Cve,
+        Dve = $ve,
+        Nve = (e, t, n, i) => {
             switch (t) {
                 case "===":
                     return typeof e == "object" && (e = e.version), typeof n == "object" && (n = n.version), e === n;
                 case "!==":
                     return typeof e == "object" && (e = e.version), typeof n == "object" && (n = n.version), e !== n;
                 case "":
                 case "=":
                 case "==":
-                    return jbe(e, n, i);
+                    return Tve(e, n, i);
                 case "!=":
-                    return zbe(e, n, i);
+                    return Mve(e, n, i);
                 case ">":
-                    return Bbe(e, n, i);
+                    return Ove(e, n, i);
                 case ">=":
-                    return Gbe(e, n, i);
+                    return Fve(e, n, i);
                 case "<":
-                    return Ube(e, n, i);
+                    return Rve(e, n, i);
                 case "<=":
-                    return qbe(e, n, i);
+                    return Dve(e, n, i);
                 default:
-                    throw new TypeError("Invalid operator: ".concat(t))
+                    throw new TypeError(`Invalid operator: ${t}`)
             }
-        },
-        Hbe = Wbe,
-        hb, G5;
+        };
+    var Pve = Nve,
+        jv, tM;
 
-    function Ybe() {
-        if (G5) return hb;
-        G5 = 1;
-        var e = Symbol("SemVer ANY");
+    function Lve() {
+        if (tM) return jv;
+        tM = 1;
+        const e = Symbol("SemVer ANY");
         class t {
             static get ANY() {
                 return e
             }
             constructor(c, f) {
                 if (f = n(f), c instanceof t) {
                     if (c.loose === !!f.loose) return c;
                     c = c.value
                 }
-                s("comparator", c, f), this.options = f, this.loose = !!f.loose, this.parse(c), this.semver === e ? this.value = "" : this.value = this.operator + this.semver.version, s("comp", this)
+                a("comparator", c, f), this.options = f, this.loose = !!f.loose, this.parse(c), this.semver === e ? this.value = "" : this.value = this.operator + this.semver.version, a("comp", this)
             }
             parse(c) {
-                var f = this.options.loose ? i[r.COMPARATORLOOSE] : i[r.COMPARATOR],
+                const f = this.options.loose ? i[r.COMPARATORLOOSE] : i[r.COMPARATOR],
                     h = c.match(f);
-                if (!h) throw new TypeError("Invalid comparator: ".concat(c));
+                if (!h) throw new TypeError(`Invalid comparator: ${c}`);
                 this.operator = h[1] !== void 0 ? h[1] : "", this.operator === "=" && (this.operator = ""), h[2] ? this.semver = new o(h[2], this.options.loose) : this.semver = e
             }
             toString() {
                 return this.value
             }
             test(c) {
-                if (s("Comparator.test", c, this.options.loose), this.semver === e || c === e) return !0;
+                if (a("Comparator.test", c, this.options.loose), this.semver === e || c === e) return !0;
                 if (typeof c == "string") try {
                     c = new o(c, this.options)
                 } catch {
                     return !1
                 }
-                return a(c, this.operator, this.semver, this.options)
+                return s(c, this.operator, this.semver, this.options)
             }
             intersects(c, f) {
                 if (!(c instanceof t)) throw new TypeError("a Comparator is required");
-                if ((!f || typeof f != "object") && (f = {
-                        loose: !!f,
-                        includePrerelease: !1
-                    }), this.operator === "") return this.value === "" ? !0 : new l(c.value, f).test(this.value);
-                if (c.operator === "") return c.value === "" ? !0 : new l(this.value, f).test(c.semver);
-                var h = (this.operator === ">=" || this.operator === ">") && (c.operator === ">=" || c.operator === ">"),
-                    d = (this.operator === "<=" || this.operator === "<") && (c.operator === "<=" || c.operator === "<"),
-                    g = this.semver.version === c.semver.version,
-                    p = (this.operator === ">=" || this.operator === "<=") && (c.operator === ">=" || c.operator === "<="),
-                    m = a(this.semver, "<", c.semver, f) && (this.operator === ">=" || this.operator === ">") && (c.operator === "<=" || c.operator === "<"),
-                    y = a(this.semver, ">", c.semver, f) && (this.operator === "<=" || this.operator === "<") && (c.operator === ">=" || c.operator === ">");
-                return h || d || g && p || m || y
-            }
-        }
-        hb = t;
-        var n = AC,
-            i = $i.re,
-            r = $i.t,
-            a = Hbe,
-            s = ky,
-            o = $C,
-            l = E8();
-        return hb
-    }
-
-    function U5(e, t) {
-        var n = typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
-        if (!n) {
-            if (Array.isArray(e) || (n = Xbe(e)) || t && e && typeof e.length == "number") {
-                n && (e = n);
-                var i = 0,
-                    r = function() {};
-                return {
-                    s: r,
-                    n: function() {
-                        return i >= e.length ? {
-                            done: !0
-                        } : {
-                            done: !1,
-                            value: e[i++]
-                        }
-                    },
-                    e: function(u) {
-                        throw u
-                    },
-                    f: r
-                }
-            }
-            throw new TypeError(`Invalid attempt to iterate non-iterable instance.
-In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
-        }
-        var a = !0,
-            s = !1,
-            o;
-        return {
-            s: function() {
-                n = n.call(e)
-            },
-            n: function() {
-                var u = n.next();
-                return a = u.done, u
-            },
-            e: function(u) {
-                s = !0, o = u
-            },
-            f: function() {
-                try {
-                    !a && n.return != null && n.return()
-                } finally {
-                    if (s) throw o
-                }
+                return this.operator === "" ? this.value === "" ? !0 : new l(c.value, f).test(this.value) : c.operator === "" ? c.value === "" ? !0 : new l(this.value, f).test(c.semver) : (f = n(f), f.includePrerelease && (this.value === "<0.0.0-0" || c.value === "<0.0.0-0") || !f.includePrerelease && (this.value.startsWith("<0.0.0") || c.value.startsWith("<0.0.0")) ? !1 : !!(this.operator.startsWith(">") && c.operator.startsWith(">") || this.operator.startsWith("<") && c.operator.startsWith("<") || this.semver.version === c.semver.version && this.operator.includes("=") && c.operator.includes("=") || s(this.semver, "<", c.semver, f) && this.operator.startsWith(">") && c.operator.startsWith("<") || s(this.semver, ">", c.semver, f) && this.operator.startsWith("<") && c.operator.startsWith(">")))
             }
         }
-    }
-
-    function Xbe(e, t) {
-        if (e) {
-            if (typeof e == "string") return q5(e, t);
-            var n = Object.prototype.toString.call(e).slice(8, -1);
-            if (n === "Object" && e.constructor && (n = e.constructor.name), n === "Map" || n === "Set") return Array.from(e);
-            if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return q5(e, t)
-        }
-    }
-
-    function q5(e, t) {
-        (t == null || t > e.length) && (t = e.length);
-        for (var n = 0, i = new Array(t); n < t; n++) i[n] = e[n];
-        return i
-    }
-    var db, W5;
-
-    function E8() {
-        if (W5) return db;
-        W5 = 1;
+        jv = t;
+        const n = GC,
+            {
+                re: i,
+                t: r
+            } = qC,
+            s = Pve,
+            a = ay,
+            o = HC,
+            l = R8();
+        return jv
+    }
+    var Uv, nM;
+
+    function R8() {
+        if (nM) return Uv;
+        nM = 1;
         class e {
-            constructor(T, A) {
-                if (A = i(A), T instanceof e) return T.loose === !!A.loose && T.includePrerelease === !!A.includePrerelease ? T : new e(T.raw, A);
+            constructor(T, M) {
+                if (M = i(M), T instanceof e) return T.loose === !!M.loose && T.includePrerelease === !!M.includePrerelease ? T : new e(T.raw, M);
                 if (T instanceof r) return this.raw = T.value, this.set = [
                     [T]
                 ], this.format(), this;
-                if (this.options = A, this.loose = !!A.loose, this.includePrerelease = !!A.includePrerelease, this.raw = T, this.set = T.split("||").map(N => this.parseRange(N.trim())).filter(N => N.length), !this.set.length) throw new TypeError("Invalid SemVer Range: ".concat(T));
+                if (this.options = M, this.loose = !!M.loose, this.includePrerelease = !!M.includePrerelease, this.raw = T, this.set = T.split("||").map(F => this.parseRange(F.trim())).filter(F => F.length), !this.set.length) throw new TypeError(`Invalid SemVer Range: ${T}`);
                 if (this.set.length > 1) {
-                    var F = this.set[0];
-                    if (this.set = this.set.filter(N => !h(N[0])), this.set.length === 0) this.set = [F];
+                    const F = this.set[0];
+                    if (this.set = this.set.filter(N => !g(N[0])), this.set.length === 0) this.set = [F];
                     else if (this.set.length > 1) {
-                        var $ = U5(this.set),
-                            D;
-                        try {
-                            for ($.s(); !(D = $.n()).done;) {
-                                var P = D.value;
-                                if (P.length === 1 && d(P[0])) {
-                                    this.set = [P];
-                                    break
-                                }
+                        for (const N of this.set)
+                            if (N.length === 1 && p(N[0])) {
+                                this.set = [N];
+                                break
                             }
-                        } catch (N) {
-                            $.e(N)
-                        } finally {
-                            $.f()
-                        }
                     }
                 }
                 this.format()
             }
             format() {
                 return this.range = this.set.map(T => T.join(" ").trim()).join("||").trim(), this.range
             }
             toString() {
                 return this.range
             }
             parseRange(T) {
                 T = T.trim();
-                var A = Object.keys(this.options).join(","),
-                    F = "parseRange:".concat(A, ":").concat(T),
-                    $ = n.get(F);
-                if ($) return $;
-                var D = this.options.loose,
-                    P = D ? o[l.HYPHENRANGELOOSE] : o[l.HYPHENRANGE];
-                T = T.replace(P, k(this.options.includePrerelease)), a("hyphen replace", T), T = T.replace(o[l.COMPARATORTRIM], u), a("comparator trim", T), T = T.replace(o[l.TILDETRIM], c), T = T.replace(o[l.CARETTRIM], f), T = T.split(/\s+/).join(" ");
-                var N = T.split(" ").map(Oe => p(Oe, this.options)).join(" ").split(/\s+/).map(Oe => O(Oe, this.options));
-                D && (N = N.filter(Oe => (a("loose invalid filter", Oe, this.options), !!Oe.match(o[l.COMPARATORLOOSE])))), a("range list", N);
-                var z = new Map,
-                    I = N.map(Oe => new r(Oe, this.options)),
-                    ae = U5(I),
-                    ye;
-                try {
-                    for (ae.s(); !(ye = ae.n()).done;) {
-                        var we = ye.value;
-                        if (h(we)) return [we];
-                        z.set(we.value, we)
-                    }
-                } catch (Oe) {
-                    ae.e(Oe)
-                } finally {
-                    ae.f()
-                }
-                z.size > 1 && z.has("") && z.delete("");
-                var $e = [...z.values()];
-                return n.set(F, $e), $e
+                const F = ((this.options.includePrerelease && h) | (this.options.loose && d)) + ":" + T,
+                    N = n.get(F);
+                if (N) return N;
+                const P = this.options.loose,
+                    z = P ? o[l.HYPHENRANGELOOSE] : o[l.HYPHENRANGE];
+                T = T.replace(z, k(this.options.includePrerelease)), s("hyphen replace", T), T = T.replace(o[l.COMPARATORTRIM], u), s("comparator trim", T), T = T.replace(o[l.TILDETRIM], c), T = T.replace(o[l.CARETTRIM], f), T = T.split(/\s+/).join(" ");
+                let I = T.split(" ").map(ye => y(ye, this.options)).join(" ").split(/\s+/).map(ye => C(ye, this.options));
+                P && (I = I.filter(ye => (s("loose invalid filter", ye, this.options), !!ye.match(o[l.COMPARATORLOOSE])))), s("range list", I);
+                const Q = new Map,
+                    oe = I.map(ye => new r(ye, this.options));
+                for (const ye of oe) {
+                    if (g(ye)) return [ye];
+                    Q.set(ye.value, ye)
+                }
+                Q.size > 1 && Q.has("") && Q.delete("");
+                const Se = [...Q.values()];
+                return n.set(F, Se), Se
             }
-            intersects(T, A) {
+            intersects(T, M) {
                 if (!(T instanceof e)) throw new TypeError("a Range is required");
-                return this.set.some(F => g(F, A) && T.set.some($ => g($, A) && F.every(D => $.every(P => D.intersects(P, A)))))
+                return this.set.some(F => m(F, M) && T.set.some(N => m(N, M) && F.every(P => N.every(z => P.intersects(z, M)))))
             }
             test(T) {
                 if (!T) return !1;
                 if (typeof T == "string") try {
-                    T = new s(T, this.options)
+                    T = new a(T, this.options)
                 } catch {
                     return !1
                 }
-                for (var A = 0; A < this.set.length; A++)
-                    if (C(this.set[A], T, this.options)) return !0;
+                for (let M = 0; M < this.set.length; M++)
+                    if (R(this.set[M], T, this.options)) return !0;
                 return !1
             }
         }
-        db = e;
-        var t = obe,
+        Uv = e;
+        const t = Kye,
             n = new t({
                 max: 1e3
             }),
-            i = AC,
-            r = Ybe(),
-            a = ky,
-            s = $C,
-            o = $i.re,
-            l = $i.t,
-            u = $i.comparatorTrimReplace,
-            c = $i.tildeTrimReplace,
-            f = $i.caretTrimReplace,
-            h = E => E.value === "<0.0.0-0",
-            d = E => E.value === "",
-            g = (E, T) => {
-                for (var A = !0, F = E.slice(), $ = F.pop(); A && F.length;) A = F.every(D => $.intersects(D, T)), $ = F.pop();
-                return A
-            },
-            p = (E, T) => (a("comp", E, T), E = b(E, T), a("caret", E), E = y(E, T), a("tildes", E), E = _(E, T), a("xrange", E), E = w(E, T), a("stars", E), E),
-            m = E => !E || E.toLowerCase() === "x" || E === "*",
-            y = (E, T) => E.trim().split(/\s+/).map(A => v(A, T)).join(" "),
-            v = (E, T) => {
-                var A = T.loose ? o[l.TILDELOOSE] : o[l.TILDE];
-                return E.replace(A, (F, $, D, P, N) => {
-                    a("tilde", E, F, $, D, P, N);
-                    var z;
-                    return m($) ? z = "" : m(D) ? z = ">=".concat($, ".0.0 <").concat(+$ + 1, ".0.0-0") : m(P) ? z = ">=".concat($, ".").concat(D, ".0 <").concat($, ".").concat(+D + 1, ".0-0") : N ? (a("replaceTilde pr", N), z = ">=".concat($, ".").concat(D, ".").concat(P, "-").concat(N, " <").concat($, ".").concat(+D + 1, ".0-0")) : z = ">=".concat($, ".").concat(D, ".").concat(P, " <").concat($, ".").concat(+D + 1, ".0-0"), a("tilde return", z), z
+            i = GC,
+            r = Lve(),
+            s = ay,
+            a = HC,
+            {
+                re: o,
+                t: l,
+                comparatorTrimReplace: u,
+                tildeTrimReplace: c,
+                caretTrimReplace: f
+            } = qC,
+            {
+                FLAG_INCLUDE_PRERELEASE: h,
+                FLAG_LOOSE: d
+            } = WC,
+            g = $ => $.value === "<0.0.0-0",
+            p = $ => $.value === "",
+            m = ($, T) => {
+                let M = !0;
+                const F = $.slice();
+                let N = F.pop();
+                for (; M && F.length;) M = F.every(P => N.intersects(P, T)), N = F.pop();
+                return M
+            },
+            y = ($, T) => (s("comp", $, T), $ = _($, T), s("caret", $), $ = b($, T), s("tildes", $), $ = w($, T), s("xrange", $), $ = A($, T), s("stars", $), $),
+            v = $ => !$ || $.toLowerCase() === "x" || $ === "*",
+            b = ($, T) => $.trim().split(/\s+/).map(M => x(M, T)).join(" "),
+            x = ($, T) => {
+                const M = T.loose ? o[l.TILDELOOSE] : o[l.TILDE];
+                return $.replace(M, (F, N, P, z, I) => {
+                    s("tilde", $, F, N, P, z, I);
+                    let Q;
+                    return v(N) ? Q = "" : v(P) ? Q = `>=${N}.0.0 <${+N+1}.0.0-0` : v(z) ? Q = `>=${N}.${P}.0 <${N}.${+P+1}.0-0` : I ? (s("replaceTilde pr", I), Q = `>=${N}.${P}.${z}-${I} <${N}.${+P+1}.0-0`) : Q = `>=${N}.${P}.${z} <${N}.${+P+1}.0-0`, s("tilde return", Q), Q
                 })
             },
-            b = (E, T) => E.trim().split(/\s+/).map(A => x(A, T)).join(" "),
-            x = (E, T) => {
-                a("caret", E, T);
-                var A = T.loose ? o[l.CARETLOOSE] : o[l.CARET],
+            _ = ($, T) => $.trim().split(/\s+/).map(M => S(M, T)).join(" "),
+            S = ($, T) => {
+                s("caret", $, T);
+                const M = T.loose ? o[l.CARETLOOSE] : o[l.CARET],
                     F = T.includePrerelease ? "-0" : "";
-                return E.replace(A, ($, D, P, N, z) => {
-                    a("caret", E, $, D, P, N, z);
-                    var I;
-                    return m(D) ? I = "" : m(P) ? I = ">=".concat(D, ".0.0").concat(F, " <").concat(+D + 1, ".0.0-0") : m(N) ? D === "0" ? I = ">=".concat(D, ".").concat(P, ".0").concat(F, " <").concat(D, ".").concat(+P + 1, ".0-0") : I = ">=".concat(D, ".").concat(P, ".0").concat(F, " <").concat(+D + 1, ".0.0-0") : z ? (a("replaceCaret pr", z), D === "0" ? P === "0" ? I = ">=".concat(D, ".").concat(P, ".").concat(N, "-").concat(z, " <").concat(D, ".").concat(P, ".").concat(+N + 1, "-0") : I = ">=".concat(D, ".").concat(P, ".").concat(N, "-").concat(z, " <").concat(D, ".").concat(+P + 1, ".0-0") : I = ">=".concat(D, ".").concat(P, ".").concat(N, "-").concat(z, " <").concat(+D + 1, ".0.0-0")) : (a("no pr"), D === "0" ? P === "0" ? I = ">=".concat(D, ".").concat(P, ".").concat(N).concat(F, " <").concat(D, ".").concat(P, ".").concat(+N + 1, "-0") : I = ">=".concat(D, ".").concat(P, ".").concat(N).concat(F, " <").concat(D, ".").concat(+P + 1, ".0-0") : I = ">=".concat(D, ".").concat(P, ".").concat(N, " <").concat(+D + 1, ".0.0-0")), a("caret return", I), I
+                return $.replace(M, (N, P, z, I, Q) => {
+                    s("caret", $, N, P, z, I, Q);
+                    let oe;
+                    return v(P) ? oe = "" : v(z) ? oe = `>=${P}.0.0${F} <${+P+1}.0.0-0` : v(I) ? P === "0" ? oe = `>=${P}.${z}.0${F} <${P}.${+z+1}.0-0` : oe = `>=${P}.${z}.0${F} <${+P+1}.0.0-0` : Q ? (s("replaceCaret pr", Q), P === "0" ? z === "0" ? oe = `>=${P}.${z}.${I}-${Q} <${P}.${z}.${+I+1}-0` : oe = `>=${P}.${z}.${I}-${Q} <${P}.${+z+1}.0-0` : oe = `>=${P}.${z}.${I}-${Q} <${+P+1}.0.0-0`) : (s("no pr"), P === "0" ? z === "0" ? oe = `>=${P}.${z}.${I}${F} <${P}.${z}.${+I+1}-0` : oe = `>=${P}.${z}.${I}${F} <${P}.${+z+1}.0-0` : oe = `>=${P}.${z}.${I} <${+P+1}.0.0-0`), s("caret return", oe), oe
                 })
             },
-            _ = (E, T) => (a("replaceXRanges", E, T), E.split(/\s+/).map(A => S(A, T)).join(" ")),
-            S = (E, T) => {
-                E = E.trim();
-                var A = T.loose ? o[l.XRANGELOOSE] : o[l.XRANGE];
-                return E.replace(A, (F, $, D, P, N, z) => {
-                    a("xRange", E, F, $, D, P, N, z);
-                    var I = m(D),
-                        ae = I || m(P),
-                        ye = ae || m(N),
-                        we = ye;
-                    return $ === "=" && we && ($ = ""), z = T.includePrerelease ? "-0" : "", I ? $ === ">" || $ === "<" ? F = "<0.0.0-0" : F = "*" : $ && we ? (ae && (P = 0), N = 0, $ === ">" ? ($ = ">=", ae ? (D = +D + 1, P = 0, N = 0) : (P = +P + 1, N = 0)) : $ === "<=" && ($ = "<", ae ? D = +D + 1 : P = +P + 1), $ === "<" && (z = "-0"), F = "".concat($ + D, ".").concat(P, ".").concat(N).concat(z)) : ae ? F = ">=".concat(D, ".0.0").concat(z, " <").concat(+D + 1, ".0.0-0") : ye && (F = ">=".concat(D, ".").concat(P, ".0").concat(z, " <").concat(D, ".").concat(+P + 1, ".0-0")), a("xRange return", F), F
+            w = ($, T) => (s("replaceXRanges", $, T), $.split(/\s+/).map(M => E(M, T)).join(" ")),
+            E = ($, T) => {
+                $ = $.trim();
+                const M = T.loose ? o[l.XRANGELOOSE] : o[l.XRANGE];
+                return $.replace(M, (F, N, P, z, I, Q) => {
+                    s("xRange", $, F, N, P, z, I, Q);
+                    const oe = v(P),
+                        Se = oe || v(z),
+                        ye = Se || v(I),
+                        Pe = ye;
+                    return N === "=" && Pe && (N = ""), Q = T.includePrerelease ? "-0" : "", oe ? N === ">" || N === "<" ? F = "<0.0.0-0" : F = "*" : N && Pe ? (Se && (z = 0), I = 0, N === ">" ? (N = ">=", Se ? (P = +P + 1, z = 0, I = 0) : (z = +z + 1, I = 0)) : N === "<=" && (N = "<", Se ? P = +P + 1 : z = +z + 1), N === "<" && (Q = "-0"), F = `${N+P}.${z}.${I}${Q}`) : Se ? F = `>=${P}.0.0${Q} <${+P+1}.0.0-0` : ye && (F = `>=${P}.${z}.0${Q} <${P}.${+z+1}.0-0`), s("xRange return", F), F
                 })
             },
-            w = (E, T) => (a("replaceStars", E, T), E.trim().replace(o[l.STAR], "")),
-            O = (E, T) => (a("replaceGTE0", E, T), E.trim().replace(o[T.includePrerelease ? l.GTE0PRE : l.GTE0], "")),
-            k = E => (T, A, F, $, D, P, N, z, I, ae, ye, we, $e) => (m(F) ? A = "" : m($) ? A = ">=".concat(F, ".0.0").concat(E ? "-0" : "") : m(D) ? A = ">=".concat(F, ".").concat($, ".0").concat(E ? "-0" : "") : P ? A = ">=".concat(A) : A = ">=".concat(A).concat(E ? "-0" : ""), m(I) ? z = "" : m(ae) ? z = "<".concat(+I + 1, ".0.0-0") : m(ye) ? z = "<".concat(I, ".").concat(+ae + 1, ".0-0") : we ? z = "<=".concat(I, ".").concat(ae, ".").concat(ye, "-").concat(we) : E ? z = "<".concat(I, ".").concat(ae, ".").concat(+ye + 1, "-0") : z = "<=".concat(z), "".concat(A, " ").concat(z).trim()),
-            C = (E, T, A) => {
-                for (var F = 0; F < E.length; F++)
-                    if (!E[F].test(T)) return !1;
-                if (T.prerelease.length && !A.includePrerelease) {
-                    for (var $ = 0; $ < E.length; $++)
-                        if (a(E[$].semver), E[$].semver !== r.ANY && E[$].semver.prerelease.length > 0) {
-                            var D = E[$].semver;
-                            if (D.major === T.major && D.minor === T.minor && D.patch === T.patch) return !0
+            A = ($, T) => (s("replaceStars", $, T), $.trim().replace(o[l.STAR], "")),
+            C = ($, T) => (s("replaceGTE0", $, T), $.trim().replace(o[T.includePrerelease ? l.GTE0PRE : l.GTE0], "")),
+            k = $ => (T, M, F, N, P, z, I, Q, oe, Se, ye, Pe, xt) => (v(F) ? M = "" : v(N) ? M = `>=${F}.0.0${$?"-0":""}` : v(P) ? M = `>=${F}.${N}.0${$?"-0":""}` : z ? M = `>=${M}` : M = `>=${M}${$?"-0":""}`, v(oe) ? Q = "" : v(Se) ? Q = `<${+oe+1}.0.0-0` : v(ye) ? Q = `<${oe}.${+Se+1}.0-0` : Pe ? Q = `<=${oe}.${Se}.${ye}-${Pe}` : $ ? Q = `<${oe}.${Se}.${+ye+1}-0` : Q = `<=${Q}`, `${M} ${Q}`.trim()),
+            R = ($, T, M) => {
+                for (let F = 0; F < $.length; F++)
+                    if (!$[F].test(T)) return !1;
+                if (T.prerelease.length && !M.includePrerelease) {
+                    for (let F = 0; F < $.length; F++)
+                        if (s($[F].semver), $[F].semver !== r.ANY && $[F].semver.prerelease.length > 0) {
+                            const N = $[F].semver;
+                            if (N.major === T.major && N.minor === T.minor && N.patch === T.patch) return !0
                         } return !1
                 }
                 return !0
             };
-        return db
+        return Uv
     }
-    var Vbe = E8(),
-        Kbe = (e, t, n) => {
+    const Ive = R8(),
+        zve = (e, t, n) => {
             try {
-                t = new Vbe(t, n)
+                t = new Ive(t, n)
             } catch {
                 return !1
             }
             return t.test(e)
-        },
-        O8 = Kbe;
+        };
+    var Bve = zve,
+        D8 = jye(Bve);
 
-    function Jbe(e, t, n) {
-        var i = e.open(t),
+    function jve(e, t, n) {
+        const i = e.open(t),
             r = 1e4,
-            a = 250,
-            s = new URL(t),
-            o = s.origin,
-            l = ~~(r / a);
+            s = 250,
+            {
+                origin: a
+            } = new URL(t);
+        let o = ~~(r / s);
 
-        function u(f) {
-            f.source === i && (l = 0, e.removeEventListener("message", u, !1))
+        function l(c) {
+            c.source === i && (o = 0, e.removeEventListener("message", l, !1))
         }
-        e.addEventListener("message", u, !1);
+        e.addEventListener("message", l, !1);
 
-        function c() {
-            l <= 0 || (i.postMessage(n, o), setTimeout(c, a), l -= 1)
+        function u() {
+            o <= 0 || (i.postMessage(n, a), setTimeout(u, s), o -= 1)
         }
-        setTimeout(c, a)
+        setTimeout(u, s)
     }
-    var Qbe = `.vega-embed {
+    var Uve = `.vega-embed {
   position: relative;
   display: inline-block;
   box-sizing: border-box;
 }
 .vega-embed.has-actions {
   padding-right: 38px;
 }
@@ -53525,466 +53615,337 @@
   }
   to {
     opacity: 1;
     transform: scale(1);
   }
 }
 `;
-    String.prototype.startsWith || (String.prototype.startsWith = function(e, t) {
-        return this.substr(!t || t < 0 ? 0 : +t, e.length) === e
-    });
 
-    function C8(e) {
-        for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++) n[i - 1] = arguments[i];
-        for (var r = 0, a = n; r < a.length; r++) {
-            var s = a[r];
-            Zbe(e, s)
-        }
+    function N8(e, ...t) {
+        for (const n of t) Gve(e, n);
         return e
     }
 
-    function Zbe(e, t) {
-        for (var n = 0, i = Object.keys(t); n < i.length; n++) {
-            var r = i[n];
-            Fc(e, r, t[r], !0)
-        }
-    }
-    var gb;
-
-    function e2e(e, t) {
-        var n = typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
-        if (!n) {
-            if (Array.isArray(e) || (n = t2e(e)) || t && e && typeof e.length == "number") {
-                n && (e = n);
-                var i = 0,
-                    r = function() {};
-                return {
-                    s: r,
-                    n: function() {
-                        return i >= e.length ? {
-                            done: !0
-                        } : {
-                            done: !1,
-                            value: e[i++]
-                        }
-                    },
-                    e: function(u) {
-                        throw u
-                    },
-                    f: r
-                }
-            }
-            throw new TypeError(`Invalid attempt to iterate non-iterable instance.
-In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
-        }
-        var a = !0,
-            s = !1,
-            o;
-        return {
-            s: function() {
-                n = n.call(e)
-            },
-            n: function() {
-                var u = n.next();
-                return a = u.done, u
-            },
-            e: function(u) {
-                s = !0, o = u
-            },
-            f: function() {
-                try {
-                    !a && n.return != null && n.return()
-                } finally {
-                    if (s) throw o
-                }
-            }
-        }
-    }
-
-    function t2e(e, t) {
-        if (e) {
-            if (typeof e == "string") return H5(e, t);
-            var n = Object.prototype.toString.call(e).slice(8, -1);
-            if (n === "Object" && e.constructor && (n = e.constructor.name), n === "Map" || n === "Set") return Array.from(e);
-            if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return H5(e, t)
-        }
-    }
-
-    function H5(e, t) {
-        (t == null || t > e.length) && (t = e.length);
-        for (var n = 0, i = new Array(t); n < t; n++) i[n] = e[n];
-        return i
+    function Gve(e, t) {
+        for (const n of Object.keys(t)) xc(e, n, t[n], !0)
     }
 
-    function Y5(e, t) {
+    function iM(e, t) {
         var n = Object.keys(e);
         if (Object.getOwnPropertySymbols) {
             var i = Object.getOwnPropertySymbols(e);
             t && (i = i.filter(function(r) {
                 return Object.getOwnPropertyDescriptor(e, r).enumerable
             })), n.push.apply(n, i)
         }
         return n
     }
 
-    function js(e) {
+    function Ta(e) {
         for (var t = 1; t < arguments.length; t++) {
             var n = arguments[t] != null ? arguments[t] : {};
-            t % 2 ? Y5(Object(n), !0).forEach(function(i) {
-                qve(e, i, n[i])
-            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Y5(Object(n)).forEach(function(i) {
+            t % 2 ? iM(Object(n), !0).forEach(function(i) {
+                Bye(e, i, n[i])
+            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : iM(Object(n)).forEach(function(i) {
                 Object.defineProperty(e, i, Object.getOwnPropertyDescriptor(n, i))
             })
         }
         return e
     }
-    var Zi = pce,
-        ad = Iye,
-        np = typeof window < "u" ? window : void 0;
-    ad === void 0 && np !== null && np !== void 0 && (gb = np.vl) !== null && gb !== void 0 && gb.compile && (ad = np.vl);
-    var n2e = {
+    const Hi = Sue;
+    let Yh = T1e;
+    const Ig = typeof window < "u" ? window : void 0;
+    var wM;
+    Yh === void 0 && ((wM = Ig == null ? void 0 : Ig.vl) != null && wM.compile) && (Yh = Ig.vl);
+    const Wve = {
             export: {
                 svg: !0,
                 png: !0
             },
             source: !0,
             compiled: !0,
             editor: !0
         },
-        i2e = {
+        qve = {
             CLICK_TO_VIEW_ACTIONS: "Click to view actions",
             COMPILED_ACTION: "View Compiled Vega",
             EDITOR_ACTION: "Open in Vega Editor",
             PNG_ACTION: "Save as PNG",
             SOURCE_ACTION: "View Source",
             SVG_ACTION: "Save as SVG"
         },
-        ih = {
+        qf = {
             vega: "Vega",
             "vega-lite": "Vega-Lite"
         },
-        vm = {
-            vega: Zi.version,
-            "vega-lite": ad ? ad.version : "not available"
+        Q0 = {
+            vega: Hi.version,
+            "vega-lite": Yh ? Yh.version : "not available"
         },
-        r2e = {
+        Hve = {
             vega: e => e,
-            "vega-lite": (e, t) => ad.compile(e, {
+            "vega-lite": (e, t) => Yh.compile(e, {
                 config: t
             }).spec
         },
-        a2e = `
+        Yve = `
 <svg viewBox="0 0 16 16" fill="currentColor" stroke="none" stroke-width="1" stroke-linecap="round" stroke-linejoin="round">
   <circle r="2" cy="8" cx="2"></circle>
   <circle r="2" cy="8" cx="8"></circle>
   <circle r="2" cy="8" cx="14"></circle>
 </svg>`,
-        s2e = "chart-wrapper";
+        Xve = "chart-wrapper";
 
-    function o2e(e) {
+    function Vve(e) {
         return typeof e == "function"
     }
 
-    function X5(e, t, n, i) {
-        var r = "<html><head>".concat(t, '</head><body><pre><code class="json">'),
-            a = "</code></pre>".concat(n, "</body></html>"),
-            s = window.open("");
-        s.document.write(r + e + a), s.document.title = "".concat(ih[i], " JSON Source")
+    function rM(e, t, n, i) {
+        const r = `<html><head>${t}</head><body><pre><code class="json">`,
+            s = `</code></pre>${n}</body></html>`,
+            a = window.open("");
+        a.document.write(r + e + s), a.document.title = `${qf[i]} JSON Source`
     }
 
-    function l2e(e, t) {
+    function Kve(e, t) {
         if (e.$schema) {
-            var n = h8(e.$schema);
-            if (t && t !== n.library) {
-                var i;
-                console.warn("The given visualization spec is written in ".concat(ih[n.library], ", but mode argument sets ").concat((i = ih[t]) !== null && i !== void 0 ? i : t, "."))
-            }
-            var r = n.library;
-            return O8(vm[r], "^".concat(n.version.slice(1))) || console.warn("The input spec uses ".concat(ih[r], " ").concat(n.version, ", but the current version of ").concat(ih[r], " is v").concat(vm[r], ".")), r
+            const n = A8(e.$schema);
+            t && t !== n.library && console.warn(`The given visualization spec is written in ${qf[n.library]}, but mode argument sets ${qf[t]??t}.`);
+            const i = n.library;
+            return D8(Q0[i], `^${n.version.slice(1)}`) || console.warn(`The input spec uses ${qf[i]} ${n.version}, but the current version of ${qf[i]} is v${Q0[i]}.`), i
         }
         return "mark" in e || "encoding" in e || "layer" in e || "hconcat" in e || "vconcat" in e || "facet" in e || "repeat" in e ? "vega-lite" : "marks" in e || "signals" in e || "scales" in e || "axes" in e ? "vega" : t ?? "vega"
     }
 
-    function u2e(e) {
+    function Jve(e) {
         return !!(e && "load" in e)
     }
 
-    function V5(e) {
-        return u2e(e) ? e : Zi.loader(e)
-    }
-
-    function c2e(e) {
-        var t, n, i = (t = (n = e.usermeta) === null || n === void 0 ? void 0 : n.embedOptions) !== null && t !== void 0 ? t : {};
-        return re(i.defaultStyle) && (i.defaultStyle = !1), i
+    function sM(e) {
+        return Jve(e) ? e : Hi.loader(e)
     }
 
-    function f2e(e, t) {
-        return Yx.apply(this, arguments)
+    function Qve(e) {
+        var n;
+        const t = ((n = e.usermeta) == null ? void 0 : n.embedOptions) ?? {};
+        return re(t.defaultStyle) && (t.defaultStyle = !1), t
     }
-
-    function Yx() {
-        return Yx = pm(Ai.mark(function e(t, n) {
-            var i, r, a, s, o, l, u, c, f, h, d, g = arguments;
-            return Ai.wrap(function(m) {
-                for (;;) switch (m.prev = m.next) {
-                    case 0:
-                        if (a = g.length > 2 && g[2] !== void 0 ? g[2] : {}, !re(n)) {
-                            m.next = 10;
-                            break
-                        }
-                        return o = V5(a.loader), m.t0 = JSON, m.next = 6, o.load(n);
-                    case 6:
-                        m.t1 = m.sent, s = m.t0.parse.call(m.t0, m.t1), m.next = 11;
-                        break;
-                    case 10:
-                        s = n;
-                    case 11:
-                        return l = c2e(s), u = l.loader, (!o || u) && (o = V5((c = a.loader) !== null && c !== void 0 ? c : u)), m.next = 16, K5(l, o);
-                    case 16:
-                        return f = m.sent, m.next = 19, K5(a, o);
-                    case 19:
-                        return h = m.sent, d = js(js({}, C8(h, f)), {}, {
-                            config: Mc((i = h.config) !== null && i !== void 0 ? i : {}, (r = f.config) !== null && r !== void 0 ? r : {})
-                        }), m.next = 23, d2e(t, s, d, o);
-                    case 23:
-                        return m.abrupt("return", m.sent);
-                    case 24:
-                    case "end":
-                        return m.stop()
-                }
-            }, e)
-        })), Yx.apply(this, arguments)
+    async function Zve(e, t, n = {}) {
+        let i, r;
+        re(t) ? (r = sM(n.loader), i = JSON.parse(await r.load(t))) : i = t;
+        const s = Qve(i),
+            a = s.loader;
+        (!r || a) && (r = sM(n.loader ?? a));
+        const o = await aM(s, r),
+            l = await aM(n, r),
+            u = Ta(Ta({}, N8(l, o)), {}, {
+                config: bc(l.config ?? {}, o.config ?? {})
+            });
+        return await tbe(e, i, u, r)
     }
-
-    function K5(e, t) {
-        return Xx.apply(this, arguments)
+    async function aM(e, t) {
+        const n = re(e.config) ? JSON.parse(await t.load(e.config)) : e.config ?? {},
+            i = re(e.patch) ? JSON.parse(await t.load(e.patch)) : e.patch;
+        return Ta(Ta(Ta({}, e), i ? {
+            patch: i
+        } : {}), n ? {
+            config: n
+        } : {})
     }
 
-    function Xx() {
-        return Xx = pm(Ai.mark(function e(t, n) {
-            var i, r, a;
-            return Ai.wrap(function(o) {
-                for (;;) switch (o.prev = o.next) {
-                    case 0:
-                        if (!re(t.config)) {
-                            o.next = 8;
-                            break
-                        }
-                        return o.t1 = JSON, o.next = 4, n.load(t.config);
-                    case 4:
-                        o.t2 = o.sent, o.t0 = o.t1.parse.call(o.t1, o.t2), o.next = 9;
-                        break;
-                    case 8:
-                        o.t0 = (i = t.config) !== null && i !== void 0 ? i : {};
-                    case 9:
-                        if (r = o.t0, !re(t.patch)) {
-                            o.next = 18;
-                            break
-                        }
-                        return o.t4 = JSON, o.next = 14, n.load(t.patch);
-                    case 14:
-                        o.t5 = o.sent, o.t3 = o.t4.parse.call(o.t4, o.t5), o.next = 19;
-                        break;
-                    case 18:
-                        o.t3 = t.patch;
-                    case 19:
-                        return a = o.t3, o.abrupt("return", js(js(js({}, t), a ? {
-                            patch: a
-                        } : {}), r ? {
-                            config: r
-                        } : {}));
-                    case 21:
-                    case "end":
-                        return o.stop()
-                }
-            }, e)
-        })), Xx.apply(this, arguments)
-    }
-
-    function h2e(e) {
-        var t, n = e.getRootNode ? e.getRootNode() : document;
-        return n instanceof ShadowRoot ? {
-            root: n,
-            rootContainer: n
+    function ebe(e) {
+        const t = e.getRootNode ? e.getRootNode() : document;
+        return t instanceof ShadowRoot ? {
+            root: t,
+            rootContainer: t
         } : {
             root: document,
-            rootContainer: (t = document.head) !== null && t !== void 0 ? t : document.body
+            rootContainer: document.head ?? document.body
         }
     }
+    async function tbe(e, t, n = {}, i) {
+        const r = n.theme ? bc(Sye[n.theme], n.config ?? {}) : n.config,
+            s = Za(n.actions) ? n.actions : N8({}, Wve, n.actions ?? {}),
+            a = Ta(Ta({}, qve), n.i18n),
+            o = n.renderer ?? "canvas",
+            l = n.logLevel ?? Hi.Warn,
+            u = n.downloadFileName ?? "visualization",
+            c = typeof e == "string" ? document.querySelector(e) : e;
+        if (!c) throw new Error(`${e} does not exist`);
+        if (n.defaultStyle !== !1) {
+            const _ = "vega-embed-style",
+                {
+                    root: S,
+                    rootContainer: w
+                } = ebe(c);
+            if (!S.getElementById(_)) {
+                const E = document.createElement("style");
+                E.id = _, E.innerHTML = n.defaultStyle === void 0 || n.defaultStyle === !0 ? Uve.toString() : n.defaultStyle, w.appendChild(E)
+            }
+        }
+        const f = Kve(t, n.mode);
+        let h = Hve[f](t, r);
+        if (f === "vega-lite" && h.$schema) {
+            const _ = A8(h.$schema);
+            D8(Q0.vega, `^${_.version.slice(1)}`) || console.warn(`The compiled spec uses Vega ${_.version}, but current version is v${Q0.vega}.`)
+        }
+        c.classList.add("vega-embed"), s && c.classList.add("has-actions"), c.innerHTML = "";
+        let d = c;
+        if (s) {
+            const _ = document.createElement("div");
+            _.classList.add(Xve), c.appendChild(_), d = _
+        }
+        const g = n.patch;
+        if (g && (h = g instanceof Function ? g(h) : Em(h, g, !0, !1).newDocument), n.formatLocale && Hi.formatLocale(n.formatLocale), n.timeFormatLocale && Hi.timeFormatLocale(n.timeFormatLocale), n.expressionFunctions)
+            for (const _ in n.expressionFunctions) {
+                const S = n.expressionFunctions[_];
+                "fn" in S ? Hi.expressionFunction(_, S.fn, S.visitor) : S instanceof Function && Hi.expressionFunction(_, S)
+            }
+        const {
+            ast: p
+        } = n, m = Hi.parse(h, f === "vega-lite" ? {} : r, {
+            ast: p
+        }), y = new(n.viewClass || Hi.View)(m, Ta({
+            loader: i,
+            logLevel: l,
+            renderer: o
+        }, p ? {
+            expr: Hi.expressionInterpreter ?? n.expr ?? Rue
+        } : {}));
+        if (y.addSignalListener("autosize", (_, S) => {
+                const {
+                    type: w
+                } = S;
+                w == "fit-x" ? (d.classList.add("fit-x"), d.classList.remove("fit-y")) : w == "fit-y" ? (d.classList.remove("fit-x"), d.classList.add("fit-y")) : w == "fit" ? d.classList.add("fit-x", "fit-y") : d.classList.remove("fit-x", "fit-y")
+            }), n.tooltip !== !1) {
+            const _ = Vve(n.tooltip) ? n.tooltip : new Lye(n.tooltip === !0 ? {} : n.tooltip).call;
+            y.tooltip(_)
+        }
+        let {
+            hover: v
+        } = n;
+        if (v === void 0 && (v = f === "vega"), v) {
+            const {
+                hoverSet: _,
+                updateSet: S
+            } = typeof v == "boolean" ? {} : v;
+            y.hover(_, S)
+        }
+        n && (n.width != null && y.width(n.width), n.height != null && y.height(n.height), n.padding != null && y.padding(n.padding)), await y.initialize(d, n.bind).runAsync();
+        let b;
+        if (s !== !1) {
+            let _ = c;
+            if (n.defaultStyle !== !1) {
+                const w = document.createElement("details");
+                w.title = a.CLICK_TO_VIEW_ACTIONS, c.append(w), _ = w;
+                const E = document.createElement("summary");
+                E.innerHTML = Yve, w.append(E), b = A => {
+                    w.contains(A.target) || w.removeAttribute("open")
+                }, document.addEventListener("click", b)
+            }
+            const S = document.createElement("div");
+            if (_.append(S), S.classList.add("vega-actions"), s === !0 || s.export !== !1) {
+                for (const w of ["svg", "png"])
+                    if (s === !0 || s.export === !0 || s.export[w]) {
+                        const E = a[`${w.toUpperCase()}_ACTION`],
+                            A = document.createElement("a"),
+                            C = ae(n.scaleFactor) ? n.scaleFactor[w] : n.scaleFactor;
+                        A.text = E, A.href = "#", A.target = "_blank", A.download = `${u}.${w}`, A.addEventListener("mousedown", async function(k) {
+                            k.preventDefault();
+                            const R = await y.toImageURL(w, C);
+                            this.href = R
+                        }), S.append(A)
+                    }
+            }
+            if (s === !0 || s.source !== !1) {
+                const w = document.createElement("a");
+                w.text = a.SOURCE_ACTION, w.href = "#", w.addEventListener("click", function(E) {
+                    rM(Hy(t), n.sourceHeader ?? "", n.sourceFooter ?? "", f), E.preventDefault()
+                }), S.append(w)
+            }
+            if (f === "vega-lite" && (s === !0 || s.compiled !== !1)) {
+                const w = document.createElement("a");
+                w.text = a.COMPILED_ACTION, w.href = "#", w.addEventListener("click", function(E) {
+                    rM(Hy(h), n.sourceHeader ?? "", n.sourceFooter ?? "", "vega"), E.preventDefault()
+                }), S.append(w)
+            }
+            if (s === !0 || s.editor !== !1) {
+                const w = n.editorUrl ?? "https://vega.github.io/editor/",
+                    E = document.createElement("a");
+                E.text = a.EDITOR_ACTION, E.href = "#", E.addEventListener("click", function(A) {
+                    jve(window, w, {
+                        config: r,
+                        mode: f,
+                        renderer: o,
+                        spec: Hy(t)
+                    }), A.preventDefault()
+                }), S.append(E)
+            }
+        }
 
-    function d2e(e, t) {
-        return Vx.apply(this, arguments)
-    }
-
-    function Vx() {
-        return Vx = pm(Ai.mark(function e(t, n) {
-            var i, r, a, s, o, l, u, c, f, h, d, g, p, m, y, v, b, x, _, S, w, O, k, C, E, T, A, F, $, D, P, N, z, I, ae, ye, we, $e, Oe, Ye, St, dt, H, oe, me, W, Fe, ue, Re, vt, Oi, us = arguments;
-            return Ai.wrap(function(Mt) {
-                for (;;) switch (Mt.prev = Mt.next) {
-                    case 0:
-                        if (Oi = function() {
-                                $e && document.removeEventListener("click", $e), N.finalize()
-                            }, c = us.length > 2 && us[2] !== void 0 ? us[2] : {}, f = us.length > 3 ? us[3] : void 0, h = c.theme ? Mc(Fve[c.theme], (i = c.config) !== null && i !== void 0 ? i : {}) : c.config, d = co(c.actions) ? c.actions : C8({}, n2e, (r = c.actions) !== null && r !== void 0 ? r : {}), g = js(js({}, i2e), c.i18n), p = (a = c.renderer) !== null && a !== void 0 ? a : "canvas", m = (s = c.logLevel) !== null && s !== void 0 ? s : Zi.Warn, y = (o = c.downloadFileName) !== null && o !== void 0 ? o : "visualization", v = typeof t == "string" ? document.querySelector(t) : t, v) {
-                            Mt.next = 12;
-                            break
-                        }
-                        throw new Error("".concat(t, " does not exist"));
-                    case 12:
-                        if (c.defaultStyle !== !1 && (b = "vega-embed-style", x = h2e(v), _ = x.root, S = x.rootContainer, _.getElementById(b) || (w = document.createElement("style"), w.id = b, w.innerHTML = c.defaultStyle === void 0 || c.defaultStyle === !0 ? Qbe.toString() : c.defaultStyle, S.appendChild(w))), O = l2e(n, c.mode), k = r2e[O](n, h), O === "vega-lite" && k.$schema && (C = h8(k.$schema), O8(vm.vega, "^".concat(C.version.slice(1))) || console.warn("The compiled spec uses Vega ".concat(C.version, ", but current version is v").concat(vm.vega, "."))), v.classList.add("vega-embed"), d && v.classList.add("has-actions"), v.innerHTML = "", E = v, d && (T = document.createElement("div"), T.classList.add(s2e), v.appendChild(T), E = T), A = c.patch, A && (k = A instanceof Function ? A(k) : qm(k, A, !0, !1).newDocument), c.formatLocale && Zi.formatLocale(c.formatLocale), c.timeFormatLocale && Zi.timeFormatLocale(c.timeFormatLocale), c.expressionFunctions)
-                            for (F in c.expressionFunctions) $ = c.expressionFunctions[F], "fn" in $ ? Zi.expressionFunction(F, $.fn, $.visitor) : $ instanceof Function && Zi.expressionFunction(F, $);
-                        return D = c.ast, P = Zi.parse(k, O === "vega-lite" ? {} : h, {
-                            ast: D
-                        }), N = new(c.viewClass || Zi.View)(P, js({
-                            loader: f,
-                            logLevel: m,
-                            renderer: p
-                        }, D ? {
-                            expr: (l = (u = Zi.expressionInterpreter) !== null && u !== void 0 ? u : c.expr) !== null && l !== void 0 ? l : Oce
-                        } : {})), N.addSignalListener("autosize", (Yi, sn) => {
-                            var qn = sn.type;
-                            qn == "fit-x" ? (E.classList.add("fit-x"), E.classList.remove("fit-y")) : qn == "fit-y" ? (E.classList.remove("fit-x"), E.classList.add("fit-y")) : qn == "fit" ? E.classList.add("fit-x", "fit-y") : E.classList.remove("fit-x", "fit-y")
-                        }), c.tooltip !== !1 && (z = o2e(c.tooltip) ? c.tooltip : new Bve(c.tooltip === !0 ? {} : c.tooltip).call, N.tooltip(z)), I = c.hover, I === void 0 && (I = O === "vega"), I && (ae = typeof I == "boolean" ? {} : I, ye = ae.hoverSet, we = ae.updateSet, N.hover(ye, we)), c && (c.width != null && N.width(c.width), c.height != null && N.height(c.height), c.padding != null && N.padding(c.padding)), Mt.next = 37, N.initialize(E, c.bind).runAsync();
-                    case 37:
-                        if (d === !1) {
-                            Mt.next = 63;
-                            break
-                        }
-                        if (Oe = v, c.defaultStyle !== !1 && (Ye = document.createElement("details"), Ye.title = g.CLICK_TO_VIEW_ACTIONS, v.append(Ye), Oe = Ye, St = document.createElement("summary"), St.innerHTML = a2e, Ye.append(St), $e = Yi => {
-                                Ye.contains(Yi.target) || Ye.removeAttribute("open")
-                            }, document.addEventListener("click", $e)), dt = document.createElement("div"), Oe.append(dt), dt.classList.add("vega-actions"), !(d === !0 || d.export !== !1)) {
-                            Mt.next = 60;
-                            break
-                        }
-                        H = e2e(["svg", "png"]), Mt.prev = 45, me = Ai.mark(function Yi() {
-                            var sn, qn, So, MC;
-                            return Ai.wrap(function(Ay) {
-                                for (;;) switch (Ay.prev = Ay.next) {
-                                    case 0:
-                                        sn = oe.value, (d === !0 || d.export === !0 || d.export[sn]) && (qn = g["".concat(sn.toUpperCase(), "_ACTION")], So = document.createElement("a"), MC = se(c.scaleFactor) ? c.scaleFactor[sn] : c.scaleFactor, So.text = qn, So.href = "#", So.target = "_blank", So.download = "".concat(y, ".").concat(sn), So.addEventListener("mousedown", function() {
-                                            var A8 = pm(Ai.mark(function FC(T8) {
-                                                var DC;
-                                                return Ai.wrap(function(Qc) {
-                                                    for (;;) switch (Qc.prev = Qc.next) {
-                                                        case 0:
-                                                            return T8.preventDefault(), Qc.next = 3, N.toImageURL(sn, MC);
-                                                        case 3:
-                                                            DC = Qc.sent, this.href = DC;
-                                                        case 5:
-                                                        case "end":
-                                                            return Qc.stop()
-                                                    }
-                                                }, FC, this)
-                                            }));
-                                            return function(FC) {
-                                                return A8.apply(this, arguments)
-                                            }
-                                        }()), dt.append(So));
-                                    case 2:
-                                    case "end":
-                                        return Ay.stop()
-                                }
-                            }, Yi)
-                        }), H.s();
-                    case 48:
-                        if ((oe = H.n()).done) {
-                            Mt.next = 52;
-                            break
-                        }
-                        return Mt.delegateYield(me(), "t0", 50);
-                    case 50:
-                        Mt.next = 48;
-                        break;
-                    case 52:
-                        Mt.next = 57;
-                        break;
-                    case 54:
-                        Mt.prev = 54, Mt.t1 = Mt.catch(45), H.e(Mt.t1);
-                    case 57:
-                        return Mt.prev = 57, H.f(), Mt.finish(57);
-                    case 60:
-                        (d === !0 || d.source !== !1) && (W = document.createElement("a"), W.text = g.SOURCE_ACTION, W.href = "#", W.addEventListener("click", function(Yi) {
-                            var sn, qn;
-                            X5(gv(n), (sn = c.sourceHeader) !== null && sn !== void 0 ? sn : "", (qn = c.sourceFooter) !== null && qn !== void 0 ? qn : "", O), Yi.preventDefault()
-                        }), dt.append(W)), O === "vega-lite" && (d === !0 || d.compiled !== !1) && (Fe = document.createElement("a"), Fe.text = g.COMPILED_ACTION, Fe.href = "#", Fe.addEventListener("click", function(Yi) {
-                            var sn, qn;
-                            X5(gv(k), (sn = c.sourceHeader) !== null && sn !== void 0 ? sn : "", (qn = c.sourceFooter) !== null && qn !== void 0 ? qn : "", "vega"), Yi.preventDefault()
-                        }), dt.append(Fe)), (d === !0 || d.editor !== !1) && (Re = (ue = c.editorUrl) !== null && ue !== void 0 ? ue : "https://vega.github.io/editor/", vt = document.createElement("a"), vt.text = g.EDITOR_ACTION, vt.href = "#", vt.addEventListener("click", function(Yi) {
-                            Jbe(window, Re, {
-                                config: h,
-                                mode: O,
-                                renderer: p,
-                                spec: gv(n)
-                            }), Yi.preventDefault()
-                        }), dt.append(vt));
-                    case 63:
-                        return Mt.abrupt("return", {
-                            view: N,
-                            spec: n,
-                            vgSpec: k,
-                            finalize: Oi,
-                            embedOptions: c
-                        });
-                    case 64:
-                    case "end":
-                        return Mt.stop()
-                }
-            }, e, null, [
-                [45, 54, 57, 60]
-            ])
-        })), Vx.apply(this, arguments)
+        function x() {
+            b && document.removeEventListener("click", b), y.finalize()
+        }
+        return {
+            view: y,
+            spec: t,
+            vgSpec: h,
+            finalize: x,
+            embedOptions: n
+        }
     }
-    const g2e = new Set(["width", "height"]);
+    const nbe = new Set(["width", "height"]);
 
-    function p2e(e, t) {
-        for (const [n, i] of Object.entries(t)) i && (i && {}.toString.call(i) === "[object Function]" ? i(e.data(n)) : e.change(n, Zi.changeset().remove(() => !0).insert(i)))
+    function ibe(e, t) {
+        for (const [n, i] of Object.entries(t)) i && (i && {}.toString.call(i) === "[object Function]" ? i(e.data(n)) : e.change(n, Hi.changeset().remove(() => !0).insert(i)))
     }
 
-    function ip(e = {}, t = {}, n = new Set) {
+    function zg(e = {}, t = {}, n = new Set) {
         const i = Object.keys(e),
             r = Object.keys(t);
-        return e === t || i.length === r.length && i.filter(a => !n.has(a)).every(a => e[a] === t[a])
+        return e === t || i.length === r.length && i.filter(s => !n.has(s)).every(s => e[s] === t[s])
     }
 
-    function J5(e, t) {
+    function oM(e, t) {
         const n = Object.keys(t);
         for (const i of n) try {
             e.removeSignalListener(i, t[i])
         } catch (r) {
             console.warn("Cannot remove invalid signal listener.", r)
         }
         return n.length > 0
     }
 
-    function pb(e, t) {
+    function Gv(e, t) {
         const n = Object.keys(t);
         for (const i of n) try {
             e.addSignalListener(i, t[i])
         } catch (r) {
             console.warn("Cannot add invalid signal listener.", r)
         }
         return n.length > 0
     }
 
-    function m2e(e) {
+    function rbe(e) {
         return new Set(e.flatMap(t => Object.keys(t)))
     }
 
-    function y2e(e, t) {
+    function sbe(e, t) {
         if (e === t) return !1;
         const n = {
                 width: !1,
                 height: !1,
                 isExpensive: !1
             },
             i = "width" in e || "width" in t,
             r = "height" in e || "height" in t;
-        return i && (!("width" in e) || !("width" in t) || e.width !== t.width) && ("width" in e && typeof e.width == "number" ? n.width = e.width : n.isExpensive = !0), r && (!("height" in e) || !("height" in t) || e.height !== t.height) && ("height" in e && typeof e.height == "number" ? n.height = e.height : n.isExpensive = !0), [...m2e([e, t])].filter(s => s !== "width" && s !== "height").some(s => !(s in e) || !(s in t) || !ZI(e[s], t[s])) && (n.isExpensive = !0), n.width !== !1 || n.height !== !1 || n.isExpensive ? n : !1
+        return i && (!("width" in e) || !("width" in t) || e.width !== t.width) && ("width" in e && typeof e.width == "number" ? n.width = e.width : n.isExpensive = !0), r && (!("height" in e) || !("height" in t) || e.height !== t.height) && ("height" in e && typeof e.height == "number" ? n.height = e.height : n.isExpensive = !0), [...rbe([e, t])].filter(a => a !== "width" && a !== "height").some(a => !(a in e) || !(a in t) || !fI(e[a], t[a])) && (n.isExpensive = !0), n.width !== !1 || n.height !== !1 || n.isExpensive ? n : !1
     }
 
-    function Q5(e, t) {
+    function lM(e, t) {
         const {
             width: n,
             height: i
         } = t;
         return typeof n < "u" && typeof i < "u" ? {
             ...e,
             width: n,
@@ -53994,244 +53955,244 @@
             width: n
         } : typeof i < "u" ? {
             ...e,
             height: i
         } : e
     }
 
-    function v2e(e) {
+    function abe(e) {
         let t;
         return {
             c() {
-                t = K("div")
+                t = J("div")
             },
             m(n, i) {
-                _e(n, t, i), e[11](t)
+                we(n, t, i), e[11](t)
             },
-            p: Ke,
-            i: Ke,
-            o: Ke,
+            p: Ve,
+            i: Ve,
+            o: Ve,
             d(n) {
-                n && xe(t), e[11](null)
+                n && _e(t), e[11](null)
             }
         }
     }
 
-    function b2e(e, t, n) {
+    function obe(e, t, n) {
         let {
             options: i
         } = t, {
             spec: r
         } = t, {
-            view: a
+            view: s
         } = t, {
-            signalListeners: s = {}
+            signalListeners: a = {}
         } = t, {
             data: o = {}
         } = t;
-        const l = Sc();
+        const l = fc();
         let u, c = {},
             f = {},
             h = {},
             d = {},
             g;
-        N8(() => {
+        G8(() => {
             m()
         });
         async function p() {
             m();
             try {
-                n(6, u = await f2e(g, r, i)), n(1, a = u.view), pb(a, s) && a.runAsync(), v(a)
+                n(6, u = await Zve(g, r, i)), n(1, s = u.view), Gv(s, a) && s.runAsync(), v(s)
             } catch (_) {
                 y(_)
             }
         }
 
         function m() {
-            u && (u.finalize(), n(6, u = void 0), n(1, a = void 0))
+            u && (u.finalize(), n(6, u = void 0), n(1, s = void 0))
         }
 
         function y(_) {
             l("onError", {
                 error: _
             }), console.warn(_)
         }
 
         function v(_) {
             b(), l("onNewView", {
                 view: _
             })
         }
         async function b() {
-            o && Object.keys(o).length > 0 && u !== void 0 && (n(1, a = u.view), p2e(a, o), await a.resize().runAsync())
+            o && Object.keys(o).length > 0 && u !== void 0 && (n(1, s = u.view), ibe(s, o), await s.resize().runAsync())
         }
 
         function x(_) {
-            Rp[_ ? "unshift" : "push"](() => {
+            pp[_ ? "unshift" : "push"](() => {
                 g = _, n(0, g)
             })
         }
         return e.$$set = _ => {
-            "options" in _ && n(2, i = _.options), "spec" in _ && n(3, r = _.spec), "view" in _ && n(1, a = _.view), "signalListeners" in _ && n(4, s = _.signalListeners), "data" in _ && n(5, o = _.data)
+            "options" in _ && n(2, i = _.options), "spec" in _ && n(3, r = _.spec), "view" in _ && n(1, s = _.view), "signalListeners" in _ && n(4, a = _.signalListeners), "data" in _ && n(5, o = _.data)
         }, e.$$.update = () => {
-            if (e.$$.dirty & 1056 && (ip(o, d) || b(), n(10, d = o)), e.$$.dirty & 991 && g !== void 0) {
-                if (!ip(i, c, g2e)) p();
+            if (e.$$.dirty & 1056 && (zg(o, d) || b(), n(10, d = o)), e.$$.dirty & 991 && g !== void 0) {
+                if (!zg(i, c, nbe)) p();
                 else {
-                    const _ = y2e(Q5(r, i), Q5(h, c)),
-                        S = s,
+                    const _ = sbe(lM(r, i), lM(h, c)),
+                        S = a,
                         w = f;
                     if (_) {
                         if (_.isExpensive) p();
                         else if (u !== void 0) {
-                            const O = !ip(S, w);
-                            n(1, a = u.view), _.width !== !1 && a.width(_.width), _.height !== !1 && a.height(_.height), O && (w && J5(a, w), S && pb(a, S)), a.runAsync()
+                            const E = !zg(S, w);
+                            n(1, s = u.view), _.width !== !1 && s.width(_.width), _.height !== !1 && s.height(_.height), E && (w && oM(s, w), S && Gv(s, S)), s.runAsync()
                         }
-                    } else !ip(S, w) && u !== void 0 && (n(1, a = u.view), w && J5(a, w), S && pb(a, S), a.runAsync())
+                    } else !zg(S, w) && u !== void 0 && (n(1, s = u.view), w && oM(s, w), S && Gv(s, S), s.runAsync())
                 }
-                n(7, c = i), n(8, f = s), n(9, h = r)
+                n(7, c = i), n(8, f = a), n(9, h = r)
             }
-        }, [g, a, i, r, s, o, u, c, f, h, d, x]
+        }, [g, s, i, r, a, o, u, c, f, h, d, x]
     }
-    class x2e extends Cn {
+    class lbe extends wn {
         constructor(t) {
-            super(), On(this, t, b2e, v2e, rn, {
+            super(), _n(this, t, obe, abe, tn, {
                 options: 2,
                 spec: 3,
                 view: 1,
                 signalListeners: 4,
                 data: 5
             })
         }
     }
 
-    function _2e(e) {
+    function ube(e) {
         let t, n, i;
 
-        function r(s) {
-            e[6](s)
+        function r(a) {
+            e[6](a)
         }
-        let a = {
+        let s = {
             spec: e[1],
             data: e[2],
             signalListeners: e[3],
             options: e[4]
         };
-        return e[0] !== void 0 && (a.view = e[0]), t = new x2e({
-            props: a
-        }), Rp.push(() => G8(t, "view", r)), t.$on("onNewView", e[7]), t.$on("onError", e[8]), {
+        return e[0] !== void 0 && (s.view = e[0]), t = new lbe({
+            props: s
+        }), pp.push(() => V8(t, "view", r)), t.$on("onNewView", e[7]), t.$on("onError", e[8]), {
             c() {
-                ni(t.$$.fragment)
+                ei(t.$$.fragment)
             },
-            m(s, o) {
-                In(t, s, o), i = !0
+            m(a, o) {
+                Nn(t, a, o), i = !0
             },
-            p(s, [o]) {
+            p(a, [o]) {
                 const l = {};
-                o & 2 && (l.spec = s[1]), o & 4 && (l.data = s[2]), o & 8 && (l.signalListeners = s[3]), o & 16 && (l.options = s[4]), !n && o & 1 && (n = !0, l.view = s[0], j8(() => n = !1)), t.$set(l)
+                o & 2 && (l.spec = a[1]), o & 4 && (l.data = a[2]), o & 8 && (l.signalListeners = a[3]), o & 16 && (l.options = a[4]), !n && o & 1 && (n = !0, l.view = a[0], H8(() => n = !1)), t.$set(l)
             },
-            i(s) {
-                i || (Te(t.$$.fragment, s), i = !0)
+            i(a) {
+                i || (Te(t.$$.fragment, a), i = !0)
             },
-            o(s) {
-                ze(t.$$.fragment, s), i = !1
+            o(a) {
+                Ie(t.$$.fragment, a), i = !1
             },
-            d(s) {
-                jn(t, s)
+            d(a) {
+                Pn(t, a)
             }
         }
     }
-    const w2e = "vega-lite";
+    const cbe = "vega-lite";
 
-    function S2e(e, t, n) {
+    function fbe(e, t, n) {
         let i, {
                 spec: r
             } = t,
             {
-                options: a = {}
+                options: s = {}
             } = t,
             {
-                data: s = {}
+                data: a = {}
             } = t,
             {
                 signalListeners: o = {}
             } = t,
             {
                 view: l = void 0
             } = t;
 
         function u(h) {
             l = h, n(0, l)
         }
 
         function c(h) {
-            IC.call(this, e, h)
+            QC.call(this, e, h)
         }
 
         function f(h) {
-            IC.call(this, e, h)
+            QC.call(this, e, h)
         }
         return e.$$set = h => {
-            "spec" in h && n(1, r = h.spec), "options" in h && n(5, a = h.options), "data" in h && n(2, s = h.data), "signalListeners" in h && n(3, o = h.signalListeners), "view" in h && n(0, l = h.view)
+            "spec" in h && n(1, r = h.spec), "options" in h && n(5, s = h.options), "data" in h && n(2, a = h.data), "signalListeners" in h && n(3, o = h.signalListeners), "view" in h && n(0, l = h.view)
         }, e.$$.update = () => {
             e.$$.dirty & 32 && n(4, i = {
-                ...a,
-                mode: w2e
+                ...s,
+                mode: cbe
             })
-        }, [l, r, s, o, i, a, u, c, f]
+        }, [l, r, a, o, i, s, u, c, f]
     }
-    class E2e extends Cn {
+    class hbe extends wn {
         constructor(t) {
-            super(), On(this, t, S2e, _2e, rn, {
+            super(), _n(this, t, fbe, ube, tn, {
                 spec: 1,
                 options: 5,
                 data: 2,
                 signalListeners: 3,
                 view: 0
             })
         }
     }
 
-    function O2e(e) {
+    function dbe(e) {
         let t, n, i = e[0].name + "",
-            r, a, s, o, l;
-        return o = new E2e({
+            r, s, a, o, l;
+        return o = new hbe({
             props: {
                 spec: e[1],
                 options: e[2]
             }
         }), {
             c() {
-                t = K("div"), n = K("span"), r = Qe(i), a = Se(), s = K("div"), ni(o.$$.fragment), B(n, "class", "py-1 text-sm font-bold text-zinc-900"), B(s, "class", "max-h-48 overflow-y-scroll"), B(t, "class", "h-56 w-72 flex flex-col justify-center items-center border rounded-lg bg-zinc-100")
+                t = J("div"), n = J("span"), r = Je(i), s = Ee(), a = J("div"), ei(o.$$.fragment), j(n, "class", "py-1 text-sm font-bold text-zinc-900"), j(a, "class", "max-h-48 overflow-y-scroll"), j(t, "class", "h-56 w-72 flex flex-col justify-center items-center border rounded-lg bg-zinc-100")
             },
             m(u, c) {
-                _e(u, t, c), U(t, n), U(n, r), U(t, a), U(t, s), In(o, s, null), l = !0
+                we(u, t, c), G(t, n), G(n, r), G(t, s), G(t, a), Nn(o, a, null), l = !0
             },
             p(u, [c]) {
-                (!l || c & 1) && i !== (i = u[0].name + "") && Pt(r, i);
+                (!l || c & 1) && i !== (i = u[0].name + "") && Ot(r, i);
                 const f = {};
                 c & 2 && (f.spec = u[1]), o.$set(f)
             },
             i(u) {
                 l || (Te(o.$$.fragment, u), l = !0)
             },
             o(u) {
-                ze(o.$$.fragment, u), l = !1
+                Ie(o.$$.fragment, u), l = !1
             },
             d(u) {
-                u && xe(t), jn(o)
+                u && _e(t), Pn(o)
             }
         }
     }
 
-    function C2e(e, t, n) {
+    function gbe(e, t, n) {
         let {
             hist: i
         } = t, r = 10 * i.histogram.length;
         r = r < 175 ? 175 : r;
-        let a = {
+        let s = {
             $schema: "https://vega.github.io/schema/vega-lite/v5.json",
             config: {
                 style: {
                     cell: {
                         stroke: "transparent"
                     }
                 }
@@ -54289,949 +54250,949 @@
             }
         };
         if (i.type == "numerical") {
             for (let o = 0; o < i.histogram.length; ++o) {
                 let l = i.histogram[o];
                 l.bin_range = l.bin_start + "-" + l.bin_end
             }
-            a.encoding.y.field = "bin_range", a.encoding.y.sort = null
+            s.encoding.y.field = "bin_range", s.encoding.y.sort = null
         }
-        const s = {
+        const a = {
             actions: !1
         };
         return e.$$set = o => {
             "hist" in o && n(0, i = o.hist)
-        }, [i, a, s]
+        }, [i, s, a]
     }
-    class k8 extends Cn {
+    class P8 extends wn {
         constructor(t) {
-            super(), On(this, t, C2e, O2e, rn, {
+            super(), _n(this, t, gbe, dbe, tn, {
                 hist: 0
             })
         }
     }
 
-    function k2e(e) {
+    function pbe(e) {
         let t, n;
-        return t = new k8({
+        return t = new P8({
             props: {
                 hist: e[0]
             }
         }), {
             c() {
-                ni(t.$$.fragment)
+                ei(t.$$.fragment)
             },
             m(i, r) {
-                In(t, i, r), n = !0
+                Nn(t, i, r), n = !0
             },
             p(i, [r]) {
-                const a = {};
-                r & 1 && (a.hist = i[0]), t.$set(a)
+                const s = {};
+                r & 1 && (s.hist = i[0]), t.$set(s)
             },
             i(i) {
                 n || (Te(t.$$.fragment, i), n = !0)
             },
             o(i) {
-                ze(t.$$.fragment, i), n = !1
+                Ie(t.$$.fragment, i), n = !1
             },
             d(i) {
-                jn(t, i)
+                Pn(t, i)
             }
         }
     }
 
-    function A2e(e, t, n) {
+    function mbe(e, t, n) {
         let {
             value: i
         } = t;
         return e.$$set = r => {
             "value" in r && n(0, i = r.value)
         }, [i]
     }
-    class T2e extends Cn {
+    class ybe extends wn {
         constructor(t) {
-            super(), On(this, t, A2e, k2e, rn, {
+            super(), _n(this, t, mbe, pbe, tn, {
                 value: 0
             })
         }
     }
 
-    function $2e(e) {
+    function vbe(e) {
         let t, n, i;
         var r = e[1][e[0].dtype];
 
-        function a(s) {
+        function s(a) {
             return {
                 props: {
-                    value: s[0].value
+                    value: a[0].value
                 }
             }
         }
-        return r && (t = LC(r, a(e))), {
+        return r && (t = JC(r, s(e))), {
             c() {
-                t && ni(t.$$.fragment), n = $l()
+                t && ei(t.$$.fragment), n = bl()
             },
-            m(s, o) {
-                t && In(t, s, o), _e(s, n, o), i = !0
+            m(a, o) {
+                t && Nn(t, a, o), we(a, n, o), i = !0
             },
-            p(s, [o]) {
+            p(a, [o]) {
                 const l = {};
-                if (o & 1 && (l.value = s[0].value), o & 1 && r !== (r = s[1][s[0].dtype])) {
+                if (o & 1 && (l.value = a[0].value), o & 1 && r !== (r = a[1][a[0].dtype])) {
                     if (t) {
-                        yr();
+                        ur();
                         const u = t;
-                        ze(u.$$.fragment, 1, 0, () => {
-                            jn(u, 1)
-                        }), vr()
+                        Ie(u.$$.fragment, 1, 0, () => {
+                            Pn(u, 1)
+                        }), cr()
                     }
-                    r ? (t = LC(r, a(s)), ni(t.$$.fragment), Te(t.$$.fragment, 1), In(t, n.parentNode, n)) : t = null
+                    r ? (t = JC(r, s(a)), ei(t.$$.fragment), Te(t.$$.fragment, 1), Nn(t, n.parentNode, n)) : t = null
                 } else r && t.$set(l)
             },
-            i(s) {
-                i || (t && Te(t.$$.fragment, s), i = !0)
+            i(a) {
+                i || (t && Te(t.$$.fragment, a), i = !0)
             },
-            o(s) {
-                t && ze(t.$$.fragment, s), i = !1
+            o(a) {
+                t && Ie(t.$$.fragment, a), i = !1
             },
-            d(s) {
-                s && xe(n), t && jn(t, s)
+            d(a) {
+                a && _e(n), t && Pn(t, a)
             }
         }
     }
 
-    function M2e(e, t, n) {
+    function bbe(e, t, n) {
         let {
             data: i
         } = t;
         const r = {
-            number: lX,
-            text: fX,
-            image: gX,
-            histogram: T2e
+            number: pY,
+            text: vY,
+            image: _Y,
+            histogram: ybe
         };
-        return e.$$set = a => {
-            "data" in a && n(0, i = a.data)
+        return e.$$set = s => {
+            "data" in s && n(0, i = s.data)
         }, [i, r]
     }
-    class F2e extends Cn {
+    class xbe extends wn {
         constructor(t) {
-            super(), On(this, t, M2e, $2e, rn, {
+            super(), _n(this, t, bbe, vbe, tn, {
                 data: 0
             })
         }
     }
 
-    function Z5(e, t, n) {
+    function uM(e, t, n) {
         const i = e.slice();
         return i[5] = t[n], i
     }
 
-    function eM(e, t, n) {
+    function cM(e, t, n) {
         const i = e.slice();
         return i[8] = t[n], i
     }
 
-    function tM(e, t, n) {
+    function fM(e, t, n) {
         const i = e.slice();
         return i[11] = t[n].name, i[12] = t[n].type, i
     }
 
-    function nM(e) {
+    function hM(e) {
         let t, n = e[11] + "",
             i;
         return {
             c() {
-                t = K("th"), i = Qe(n), B(t, "class", "pl-2 py-1")
+                t = J("th"), i = Je(n), j(t, "class", "pl-2 py-1")
             },
-            m(r, a) {
-                _e(r, t, a), U(t, i)
+            m(r, s) {
+                we(r, t, s), G(t, i)
             },
-            p(r, a) {
-                a & 1 && n !== (n = r[11] + "") && Pt(i, n)
+            p(r, s) {
+                s & 1 && n !== (n = r[11] + "") && Ot(i, n)
             },
             d(r) {
-                r && xe(t)
+                r && _e(t)
             }
         }
     }
 
-    function iM(e) {
-        let t, n = e[12] != "hidden" && nM(e);
+    function dM(e) {
+        let t, n = e[12] != "hidden" && hM(e);
         return {
             c() {
-                n && n.c(), t = $l()
+                n && n.c(), t = bl()
             },
             m(i, r) {
-                n && n.m(i, r), _e(i, t, r)
+                n && n.m(i, r), we(i, t, r)
             },
             p(i, r) {
-                i[12] != "hidden" ? n ? n.p(i, r) : (n = nM(i), n.c(), n.m(t.parentNode, t)) : n && (n.d(1), n = null)
+                i[12] != "hidden" ? n ? n.p(i, r) : (n = hM(i), n.c(), n.m(t.parentNode, t)) : n && (n.d(1), n = null)
             },
             d(i) {
-                n && n.d(i), i && xe(t)
+                n && n.d(i), i && _e(t)
             }
         }
     }
 
-    function rM(e) {
+    function gM(e) {
         let t, n, i;
-        return n = new F2e({
+        return n = new xbe({
             props: {
                 data: e[8]
             }
         }), {
             c() {
-                t = K("td"), ni(n.$$.fragment), B(t, "class", "border-b dark:border-zinc-700 py-2")
+                t = J("td"), ei(n.$$.fragment), j(t, "class", "border-b dark:border-zinc-700 py-2")
             },
-            m(r, a) {
-                _e(r, t, a), In(n, t, null), i = !0
+            m(r, s) {
+                we(r, t, s), Nn(n, t, null), i = !0
             },
-            p(r, a) {
-                const s = {};
-                a & 2 && (s.data = r[8]), n.$set(s)
+            p(r, s) {
+                const a = {};
+                s & 2 && (a.data = r[8]), n.$set(a)
             },
             i(r) {
                 i || (Te(n.$$.fragment, r), i = !0)
             },
             o(r) {
-                ze(n.$$.fragment, r), i = !1
+                Ie(n.$$.fragment, r), i = !1
             },
             d(r) {
-                r && xe(t), jn(n)
+                r && _e(t), Pn(n)
             }
         }
     }
 
-    function aM(e) {
-        let t, n, i = e[8].dtype != "hidden" && rM(e);
+    function pM(e) {
+        let t, n, i = e[8].dtype != "hidden" && gM(e);
         return {
             c() {
-                i && i.c(), t = $l()
+                i && i.c(), t = bl()
             },
-            m(r, a) {
-                i && i.m(r, a), _e(r, t, a), n = !0
+            m(r, s) {
+                i && i.m(r, s), we(r, t, s), n = !0
             },
-            p(r, a) {
-                r[8].dtype != "hidden" ? i ? (i.p(r, a), a & 2 && Te(i, 1)) : (i = rM(r), i.c(), Te(i, 1), i.m(t.parentNode, t)) : i && (yr(), ze(i, 1, 1, () => {
+            p(r, s) {
+                r[8].dtype != "hidden" ? i ? (i.p(r, s), s & 2 && Te(i, 1)) : (i = gM(r), i.c(), Te(i, 1), i.m(t.parentNode, t)) : i && (ur(), Ie(i, 1, 1, () => {
                     i = null
-                }), vr())
+                }), cr())
             },
             i(r) {
                 n || (Te(i), n = !0)
             },
             o(r) {
-                ze(i), n = !1
+                Ie(i), n = !1
             },
             d(r) {
-                i && i.d(r), r && xe(t)
+                i && i.d(r), r && _e(t)
             }
         }
     }
 
-    function sM(e) {
-        let t, n, i, r, a, s = e[5],
+    function mM(e) {
+        let t, n, i, r, s, a = e[5],
             o = [];
-        for (let c = 0; c < s.length; c += 1) o[c] = aM(eM(e, s, c));
-        const l = c => ze(o[c], 1, 1, () => {
+        for (let c = 0; c < a.length; c += 1) o[c] = pM(cM(e, a, c));
+        const l = c => Ie(o[c], 1, 1, () => {
             o[c] = null
         });
 
         function u() {
             return e[3](e[5])
         }
         return {
             c() {
-                t = K("tr");
+                t = J("tr");
                 for (let c = 0; c < o.length; c += 1) o[c].c();
-                n = Se(), B(t, "class", "cursor-pointer hover:bg-zinc-100 dark:hover:bg-zinc-700")
+                n = Ee(), j(t, "class", "cursor-pointer hover:bg-zinc-100 dark:hover:bg-zinc-700")
             },
             m(c, f) {
-                _e(c, t, f);
+                we(c, t, f);
                 for (let h = 0; h < o.length; h += 1) o[h] && o[h].m(t, null);
-                U(t, n), i = !0, r || (a = Ot(t, "click", u), r = !0)
+                G(t, n), i = !0, r || (s = wt(t, "click", u), r = !0)
             },
             p(c, f) {
                 if (e = c, f & 2) {
-                    s = e[5];
+                    a = e[5];
                     let h;
-                    for (h = 0; h < s.length; h += 1) {
-                        const d = eM(e, s, h);
-                        o[h] ? (o[h].p(d, f), Te(o[h], 1)) : (o[h] = aM(d), o[h].c(), Te(o[h], 1), o[h].m(t, n))
+                    for (h = 0; h < a.length; h += 1) {
+                        const d = cM(e, a, h);
+                        o[h] ? (o[h].p(d, f), Te(o[h], 1)) : (o[h] = pM(d), o[h].c(), Te(o[h], 1), o[h].m(t, n))
                     }
-                    for (yr(), h = s.length; h < o.length; h += 1) l(h);
-                    vr()
+                    for (ur(), h = a.length; h < o.length; h += 1) l(h);
+                    cr()
                 }
             },
             i(c) {
                 if (!i) {
-                    for (let f = 0; f < s.length; f += 1) Te(o[f]);
+                    for (let f = 0; f < a.length; f += 1) Te(o[f]);
                     i = !0
                 }
             },
             o(c) {
                 o = o.filter(Boolean);
-                for (let f = 0; f < o.length; f += 1) ze(o[f]);
+                for (let f = 0; f < o.length; f += 1) Ie(o[f]);
                 i = !1
             },
             d(c) {
-                c && xe(t), ol(o, c), r = !1, a()
+                c && _e(t), Vo(o, c), r = !1, s()
             }
         }
     }
 
-    function D2e(e) {
-        let t, n, i, r, a, s, o, l = e[0],
+    function _be(e) {
+        let t, n, i, r, s, a, o, l = e[0],
             u = [];
-        for (let d = 0; d < l.length; d += 1) u[d] = iM(tM(e, l, d));
+        for (let d = 0; d < l.length; d += 1) u[d] = dM(fM(e, l, d));
         let c = e[1],
             f = [];
-        for (let d = 0; d < c.length; d += 1) f[d] = sM(Z5(e, c, d));
-        const h = d => ze(f[d], 1, 1, () => {
+        for (let d = 0; d < c.length; d += 1) f[d] = mM(uM(e, c, d));
+        const h = d => Ie(f[d], 1, 1, () => {
             f[d] = null
         });
         return {
             c() {
-                t = K("div"), n = K("table"), i = K("thead"), r = K("tr");
+                t = J("div"), n = J("table"), i = J("thead"), r = J("tr");
                 for (let d = 0; d < u.length; d += 1) u[d].c();
-                a = Se(), s = K("tbody");
+                s = Ee(), a = J("tbody");
                 for (let d = 0; d < f.length; d += 1) f[d].c();
-                B(r, "class", "sticky p-2 top-0 bg-zinc-100 border-b-2 dark:bg-zinc-900 dark:border-zinc-700 "), B(i, "class", "text-xs text-zinc-700 uppercase dark:text-zinc-400"), B(n, "class", "table-auto w-full text-sm text-left"), B(t, "class", "h-full bg-white overflow-y-auto overflow-x-auto border rounded-lg dark:bg-zinc-800 dark:border-zinc-700")
+                j(r, "class", "sticky p-2 top-0 bg-zinc-100 border-b-2 dark:bg-zinc-900 dark:border-zinc-700 "), j(i, "class", "text-xs text-zinc-700 uppercase dark:text-zinc-400"), j(n, "class", "table-auto w-full text-sm text-left"), j(t, "class", "h-full bg-white overflow-y-auto overflow-x-auto border rounded-lg dark:bg-zinc-800 dark:border-zinc-700")
             },
             m(d, g) {
-                _e(d, t, g), U(t, n), U(n, i), U(i, r);
+                we(d, t, g), G(t, n), G(n, i), G(i, r);
                 for (let p = 0; p < u.length; p += 1) u[p] && u[p].m(r, null);
-                U(n, a), U(n, s);
-                for (let p = 0; p < f.length; p += 1) f[p] && f[p].m(s, null);
+                G(n, s), G(n, a);
+                for (let p = 0; p < f.length; p += 1) f[p] && f[p].m(a, null);
                 o = !0
             },
             p(d, [g]) {
                 if (g & 1) {
                     l = d[0];
                     let p;
                     for (p = 0; p < l.length; p += 1) {
-                        const m = tM(d, l, p);
-                        u[p] ? u[p].p(m, g) : (u[p] = iM(m), u[p].c(), u[p].m(r, null))
+                        const m = fM(d, l, p);
+                        u[p] ? u[p].p(m, g) : (u[p] = dM(m), u[p].c(), u[p].m(r, null))
                     }
                     for (; p < u.length; p += 1) u[p].d(1);
                     u.length = l.length
                 }
                 if (g & 6) {
                     c = d[1];
                     let p;
                     for (p = 0; p < c.length; p += 1) {
-                        const m = Z5(d, c, p);
-                        f[p] ? (f[p].p(m, g), Te(f[p], 1)) : (f[p] = sM(m), f[p].c(), Te(f[p], 1), f[p].m(s, null))
+                        const m = uM(d, c, p);
+                        f[p] ? (f[p].p(m, g), Te(f[p], 1)) : (f[p] = mM(m), f[p].c(), Te(f[p], 1), f[p].m(a, null))
                     }
-                    for (yr(), p = c.length; p < f.length; p += 1) h(p);
-                    vr()
+                    for (ur(), p = c.length; p < f.length; p += 1) h(p);
+                    cr()
                 }
             },
             i(d) {
                 if (!o) {
                     for (let g = 0; g < c.length; g += 1) Te(f[g]);
                     o = !0
                 }
             },
             o(d) {
                 f = f.filter(Boolean);
-                for (let g = 0; g < f.length; g += 1) ze(f[g]);
+                for (let g = 0; g < f.length; g += 1) Ie(f[g]);
                 o = !1
             },
             d(d) {
-                d && xe(t), ol(u, d), ol(f, d)
+                d && _e(t), Vo(u, d), Vo(f, d)
             }
         }
     }
 
-    function R2e(e, t, n) {
+    function wbe(e, t, n) {
         let {
             featureNames: i
         } = t, {
             features: r
         } = t;
-        const a = Sc();
+        const s = fc();
 
-        function s(l) {
+        function a(l) {
             const u = l.find(c => c.name === "id");
-            a("itemclick", {
+            s("itemclick", {
                 id: u.value
             })
         }
         const o = l => {
-            s(l)
+            a(l)
         };
         return e.$$set = l => {
             "featureNames" in l && n(0, i = l.featureNames), "features" in l && n(1, r = l.features)
-        }, [i, r, s, o]
+        }, [i, r, a, o]
     }
-    class P2e extends Cn {
+    class Sbe extends wn {
         constructor(t) {
-            super(), On(this, t, R2e, D2e, rn, {
+            super(), _n(this, t, wbe, _be, tn, {
                 featureNames: 0,
                 features: 1
             })
         }
     }
 
-    function oM(e, t, n) {
+    function yM(e, t, n) {
         const i = e.slice();
         return i[9] = t[n], i
     }
 
-    function N2e(e) {
+    function Ebe(e) {
         let t;
         return {
             c() {
-                t = K("span"), t.textContent = "No stats available.", B(t, "class", "mt-80 italic text-zinc-500")
+                t = J("span"), t.textContent = "No stats available.", j(t, "class", "mt-80 italic text-zinc-500")
             },
             m(n, i) {
-                _e(n, t, i)
+                we(n, t, i)
             },
-            p: Ke,
-            i: Ke,
-            o: Ke,
+            p: Ve,
+            i: Ve,
+            o: Ve,
             d(n) {
-                n && xe(t)
+                n && _e(t)
             }
         }
     }
 
-    function L2e(e) {
+    function Cbe(e) {
         let t, n, i = e[0],
             r = [];
-        for (let s = 0; s < i.length; s += 1) r[s] = lM(oM(e, i, s));
-        const a = s => ze(r[s], 1, 1, () => {
-            r[s] = null
+        for (let a = 0; a < i.length; a += 1) r[a] = vM(yM(e, i, a));
+        const s = a => Ie(r[a], 1, 1, () => {
+            r[a] = null
         });
         return {
             c() {
-                t = K("div");
-                for (let s = 0; s < r.length; s += 1) r[s].c();
-                B(t, "class", "grid grid-cols-3 my-2")
+                t = J("div");
+                for (let a = 0; a < r.length; a += 1) r[a].c();
+                j(t, "class", "grid grid-cols-3 my-2")
             },
-            m(s, o) {
-                _e(s, t, o);
+            m(a, o) {
+                we(a, t, o);
                 for (let l = 0; l < r.length; l += 1) r[l] && r[l].m(t, null);
                 n = !0
             },
-            p(s, o) {
+            p(a, o) {
                 if (o & 1) {
-                    i = s[0];
+                    i = a[0];
                     let l;
                     for (l = 0; l < i.length; l += 1) {
-                        const u = oM(s, i, l);
-                        r[l] ? (r[l].p(u, o), Te(r[l], 1)) : (r[l] = lM(u), r[l].c(), Te(r[l], 1), r[l].m(t, null))
+                        const u = yM(a, i, l);
+                        r[l] ? (r[l].p(u, o), Te(r[l], 1)) : (r[l] = vM(u), r[l].c(), Te(r[l], 1), r[l].m(t, null))
                     }
-                    for (yr(), l = i.length; l < r.length; l += 1) a(l);
-                    vr()
+                    for (ur(), l = i.length; l < r.length; l += 1) s(l);
+                    cr()
                 }
             },
-            i(s) {
+            i(a) {
                 if (!n) {
                     for (let o = 0; o < i.length; o += 1) Te(r[o]);
                     n = !0
                 }
             },
-            o(s) {
+            o(a) {
                 r = r.filter(Boolean);
-                for (let o = 0; o < r.length; o += 1) ze(r[o]);
+                for (let o = 0; o < r.length; o += 1) Ie(r[o]);
                 n = !1
             },
-            d(s) {
-                s && xe(t), ol(r, s)
+            d(a) {
+                a && _e(t), Vo(r, a)
             }
         }
     }
 
-    function lM(e) {
+    function vM(e) {
         let t, n, i, r;
-        return n = new k8({
+        return n = new P8({
             props: {
                 hist: e[9]
             }
         }), {
             c() {
-                t = K("div"), ni(n.$$.fragment), i = Se(), B(t, "class", "ml-2 mb-2")
+                t = J("div"), ei(n.$$.fragment), i = Ee(), j(t, "class", "ml-2 mb-2")
             },
-            m(a, s) {
-                _e(a, t, s), In(n, t, null), U(t, i), r = !0
+            m(s, a) {
+                we(s, t, a), Nn(n, t, null), G(t, i), r = !0
             },
-            p(a, s) {
+            p(s, a) {
                 const o = {};
-                s & 1 && (o.hist = a[9]), n.$set(o)
+                a & 1 && (o.hist = s[9]), n.$set(o)
             },
-            i(a) {
-                r || (Te(n.$$.fragment, a), r = !0)
+            i(s) {
+                r || (Te(n.$$.fragment, s), r = !0)
             },
-            o(a) {
-                ze(n.$$.fragment, a), r = !1
+            o(s) {
+                Ie(n.$$.fragment, s), r = !1
             },
-            d(a) {
-                a && xe(t), jn(n)
+            d(s) {
+                s && _e(t), Pn(n)
             }
         }
     }
 
-    function I2e(e) {
+    function kbe(e) {
         let t;
         return {
             c() {
-                t = K("div"), t.innerHTML = '<span class="text-zinc-500 italic">Loading items ...</span>', B(t, "class", "h-full flex justify-center items-center")
+                t = J("div"), t.innerHTML = '<span class="text-zinc-500 italic">Loading items ...</span>', j(t, "class", "h-full flex justify-center items-center")
             },
             m(n, i) {
-                _e(n, t, i)
+                we(n, t, i)
             },
-            p: Ke,
-            i: Ke,
-            o: Ke,
+            p: Ve,
+            i: Ve,
+            o: Ve,
             d(n) {
-                n && xe(t)
+                n && _e(t)
             }
         }
     }
 
-    function j2e(e) {
-        let t, n, i, r, a, s = 1 + Ms * (e[3] - 1) + "",
-            o, l, u = Ms * e[3] + "",
+    function Abe(e) {
+        let t, n, i, r, s, a = 1 + wa * (e[3] - 1) + "",
+            o, l, u = wa * e[3] + "",
             c, f, h = e[1].total + "",
             d, g, p, m, y, v, b, x;
-        return n = new P2e({
+        return n = new Sbe({
             props: {
                 features: e[1].items,
                 featureNames: e[2]
             }
         }), n.$on("itemclick", e[4]), {
             c() {
-                t = K("div"), ni(n.$$.fragment), i = Se(), r = K("div"), a = K("span"), o = Qe(s), l = Qe(" - "), c = Qe(u), f = Qe(" of "), d = Qe(h), g = Se(), p = K("button"), p.textContent = "PREV", m = Se(), y = K("button"), y.textContent = "NEXT", B(t, "class", "h-[85vh] w-full mb-1"), B(a, "class", "mr-2"), B(p, "class", "py-1 px-2 bg-white border-2 rounded-lg text-zinc-500 text-sm font-medium hover:bg-zinc-100 dark:bg-zinc-900 dark:border-zinc-800 dark:text-zinc-300 dark:hover:bg-zinc-700"), B(y, "class", "py-1 px-2 bg-white border-2 rounded-lg text-zinc-500 text-sm font-medium hover:bg-zinc-100 dark:bg-zinc-900 dark:border-zinc-800 dark:text-zinc-300 dark:hover:bg-zinc-700"), B(r, "class", "flex justify-end items-center w-full space-x-2")
+                t = J("div"), ei(n.$$.fragment), i = Ee(), r = J("div"), s = J("span"), o = Je(a), l = Je(" - "), c = Je(u), f = Je(" of "), d = Je(h), g = Ee(), p = J("button"), p.textContent = "PREV", m = Ee(), y = J("button"), y.textContent = "NEXT", j(t, "class", "h-[85vh] w-full mb-1"), j(s, "class", "mr-2"), j(p, "class", "py-1 px-2 bg-white border-2 rounded-lg text-zinc-500 text-sm font-medium hover:bg-zinc-100 dark:bg-zinc-900 dark:border-zinc-800 dark:text-zinc-300 dark:hover:bg-zinc-700"), j(y, "class", "py-1 px-2 bg-white border-2 rounded-lg text-zinc-500 text-sm font-medium hover:bg-zinc-100 dark:bg-zinc-900 dark:border-zinc-800 dark:text-zinc-300 dark:hover:bg-zinc-700"), j(r, "class", "flex justify-end items-center w-full space-x-2")
             },
             m(_, S) {
-                _e(_, t, S), In(n, t, null), _e(_, i, S), _e(_, r, S), U(r, a), U(a, o), U(a, l), U(a, c), U(a, f), U(a, d), U(r, g), U(r, p), U(r, m), U(r, y), v = !0, b || (x = [Ot(p, "click", e[5]), Ot(y, "click", e[6])], b = !0)
+                we(_, t, S), Nn(n, t, null), we(_, i, S), we(_, r, S), G(r, s), G(s, o), G(s, l), G(s, c), G(s, f), G(s, d), G(r, g), G(r, p), G(r, m), G(r, y), v = !0, b || (x = [wt(p, "click", e[5]), wt(y, "click", e[6])], b = !0)
             },
             p(_, S) {
                 const w = {};
-                S & 2 && (w.features = _[1].items), S & 4 && (w.featureNames = _[2]), n.$set(w), (!v || S & 8) && s !== (s = 1 + Ms * (_[3] - 1) + "") && Pt(o, s), (!v || S & 8) && u !== (u = Ms * _[3] + "") && Pt(c, u), (!v || S & 2) && h !== (h = _[1].total + "") && Pt(d, h)
+                S & 2 && (w.features = _[1].items), S & 4 && (w.featureNames = _[2]), n.$set(w), (!v || S & 8) && a !== (a = 1 + wa * (_[3] - 1) + "") && Ot(o, a), (!v || S & 8) && u !== (u = wa * _[3] + "") && Ot(c, u), (!v || S & 2) && h !== (h = _[1].total + "") && Ot(d, h)
             },
             i(_) {
                 v || (Te(n.$$.fragment, _), v = !0)
             },
             o(_) {
-                ze(n.$$.fragment, _), v = !1
+                Ie(n.$$.fragment, _), v = !1
             },
             d(_) {
-                _ && xe(t), jn(n), _ && xe(i), _ && xe(r), b = !1, Ka(x)
+                _ && _e(t), Pn(n), _ && _e(i), _ && _e(r), b = !1, js(x)
             }
         }
     }
 
-    function z2e(e) {
-        let t, n, i, r, a, s, o, l, u, c, f, h;
-        const d = [L2e, N2e],
+    function $be(e) {
+        let t, n, i, r, s, a, o, l, u, c, f, h;
+        const d = [Cbe, Ebe],
             g = [];
 
         function p(b, x) {
             return b[0] != null && b[0].length != 0 ? 0 : 1
         }
-        s = p(e), o = g[s] = d[s](e);
-        const m = [j2e, I2e],
+        a = p(e), o = g[a] = d[a](e);
+        const m = [Abe, kbe],
             y = [];
 
         function v(b, x) {
             return b[1] ? 0 : 1
         }
         return c = v(e), f = y[c] = m[c](e), {
             c() {
-                t = K("div"), n = K("div"), i = K("div"), r = K("span"), r.textContent = "Stats", a = Se(), o.c(), l = Se(), u = K("div"), f.c(), B(r, "class", "font-bold text-xl mt-3"), B(i, "class", "w-1/2 h-[85vh] pr-4 flex flex-col items-center border rounded-lg overflow-y-scroll dark:border-zinc-700 dark:bg-zinc-800"), B(u, "class", "w-1/2 ml-4"), B(n, "class", "flex"), B(t, "class", "mt-4 px-2")
+                t = J("div"), n = J("div"), i = J("div"), r = J("span"), r.textContent = "Stats", s = Ee(), o.c(), l = Ee(), u = J("div"), f.c(), j(r, "class", "font-bold text-xl mt-3"), j(i, "class", "w-1/2 h-[85vh] pr-4 flex flex-col items-center border rounded-lg overflow-y-scroll dark:border-zinc-700 dark:bg-zinc-800"), j(u, "class", "w-1/2 ml-4"), j(n, "class", "flex"), j(t, "class", "mt-4 px-2")
             },
             m(b, x) {
-                _e(b, t, x), U(t, n), U(n, i), U(i, r), U(i, a), g[s].m(i, null), U(n, l), U(n, u), y[c].m(u, null), h = !0
+                we(b, t, x), G(t, n), G(n, i), G(i, r), G(i, s), g[a].m(i, null), G(n, l), G(n, u), y[c].m(u, null), h = !0
             },
             p(b, [x]) {
-                let _ = s;
-                s = p(b), s === _ ? g[s].p(b, x) : (yr(), ze(g[_], 1, 1, () => {
+                let _ = a;
+                a = p(b), a === _ ? g[a].p(b, x) : (ur(), Ie(g[_], 1, 1, () => {
                     g[_] = null
-                }), vr(), o = g[s], o ? o.p(b, x) : (o = g[s] = d[s](b), o.c()), Te(o, 1), o.m(i, null));
+                }), cr(), o = g[a], o ? o.p(b, x) : (o = g[a] = d[a](b), o.c()), Te(o, 1), o.m(i, null));
                 let S = c;
-                c = v(b), c === S ? y[c].p(b, x) : (yr(), ze(y[S], 1, 1, () => {
+                c = v(b), c === S ? y[c].p(b, x) : (ur(), Ie(y[S], 1, 1, () => {
                     y[S] = null
-                }), vr(), f = y[c], f ? f.p(b, x) : (f = y[c] = m[c](b), f.c()), Te(f, 1), f.m(u, null))
+                }), cr(), f = y[c], f ? f.p(b, x) : (f = y[c] = m[c](b), f.c()), Te(f, 1), f.m(u, null))
             },
             i(b) {
                 h || (Te(o), Te(f), h = !0)
             },
             o(b) {
-                ze(o), ze(f), h = !1
+                Ie(o), Ie(f), h = !1
             },
             d(b) {
-                b && xe(t), g[s].d(), y[c].d()
+                b && _e(t), g[a].d(), y[c].d()
             }
         }
     }
-    let Ms = 100;
+    let wa = 100;
 
-    function B2e(e, t, n) {
+    function Tbe(e, t, n) {
         let {
             dataset: i = null
-        } = t, r = null, a = null, s, o;
-        ap.subscribe(h => {
+        } = t, r = null, s = null, a, o;
+        jg.subscribe(h => {
             n(3, o = h)
         });
-        const l = Sc();
+        const l = fc();
 
         function u(h) {
             l("itemclick", {
                 id: h.detail.id
             })
         }
         async function c() {
-            o > 1 ? (ap.update(h => h - 1), n(1, a = null), n(1, a = await $y(i.id, o, Ms))) : alert("There is no previous page.")
+            o > 1 ? (jg.update(h => h - 1), n(1, s = null), n(1, s = await ly(i.id, o, wa))) : alert("There is no previous page.")
         }
         async function f() {
-            a.total > o * Ms ? (ap.update(h => h + 1), n(1, a = null), n(1, a = await $y(i.id, o, Ms))) : alert("Last page reached.")
+            s.total > o * wa ? (jg.update(h => h + 1), n(1, s = null), n(1, s = await ly(i.id, o, wa))) : alert("Last page reached.")
         }
-        return bm(async () => {
-            n(1, a = await $y(i.id, o, Ms)), n(2, s = a.items[0].map(h => ({
+        return Z0(async () => {
+            n(1, s = await ly(i.id, o, wa)), n(2, a = s.items[0].map(h => ({
                 name: h.name,
                 type: h.dtype
-            }))), n(0, r = await t9(i.id))
+            }))), n(0, r = await l9(i.id))
         }), e.$$set = h => {
             "dataset" in h && n(7, i = h.dataset)
-        }, [r, a, s, o, u, c, f, i]
+        }, [r, s, a, o, u, c, f, i]
     }
-    class G2e extends Cn {
+    class Mbe extends wn {
         constructor(t) {
-            super(), On(this, t, B2e, z2e, rn, {
+            super(), _n(this, t, Tbe, $be, tn, {
                 dataset: 7
             })
         }
     }
 
-    function uM(e) {
+    function bM(e) {
         let t, n;
-        return t = new aX({
+        return t = new hY({
             props: {
                 features: e[0]
             }
         }), {
             c() {
-                ni(t.$$.fragment)
+                ei(t.$$.fragment)
             },
             m(i, r) {
-                In(t, i, r), n = !0
+                Nn(t, i, r), n = !0
             },
             p(i, r) {
-                const a = {};
-                r & 1 && (a.features = i[0]), t.$set(a)
+                const s = {};
+                r & 1 && (s.features = i[0]), t.$set(s)
             },
             i(i) {
                 n || (Te(t.$$.fragment, i), n = !0)
             },
             o(i) {
-                ze(t.$$.fragment, i), n = !1
+                Ie(t.$$.fragment, i), n = !1
             },
             d(i) {
-                jn(t, i)
+                Pn(t, i)
             }
         }
     }
 
-    function U2e(e) {
-        let t, n, i, r, a, s, o, l, u = e[0] && uM(e);
+    function Obe(e) {
+        let t, n, i, r, s, a, o, l, u = e[0] && bM(e);
         return {
             c() {
-                t = K("div"), u && u.c(), n = Se(), i = K("button"), i.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 28 28" class="fill-rose-600 hover:fill-rose-400"><path class="transition-colors" d="M12 10.59l4.95-4.95c0.39-0.39 1.02-0.39 1.41 0l1.41 1.41c0.39 0.39 0.39 1.02 0 1.41l-4.95 4.95l4.95 4.95c0.39 0.39 0.39 1.02 0 1.41l-1.41 1.41c-0.39 0.39-1.02 0.39-1.41 0l-4.95-4.95l-4.95 4.95c-0.39 0.39-1.02 0.39-1.41 0l-1.41-1.41c-0.39-0.39-0.39-1.02 0-1.41l4.95-4.95l-4.95-4.95c-0.39-0.39-0.39-1.02 0-1.41l1.41-1.41c0.39-0.39 1.02-0.39 1.41 0l4.95 4.95z"></path></svg>', r = Se(), a = K("div"), a.textContent = "Pixano Explorer", B(i, "class", "absolute top-0 right-0 p-2 z-10"), B(t, "class", "absolute top-0 bg-white w-screen h-screen dark:bg-zinc-900"), B(a, "class", "absolute bottom-0 right-0 px-2 py-1 bg-zinc-50 text-zinc-500 text-sm border-t border-l rounded-tl-lg dark:bg-zinc-900 dark:text-zinc-300 dark:border-zinc-500")
+                t = J("div"), u && u.c(), n = Ee(), i = J("button"), i.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 28 28" class="fill-rose-600 hover:fill-rose-400"><path class="transition-colors" d="M12 10.59l4.95-4.95c0.39-0.39 1.02-0.39 1.41 0l1.41 1.41c0.39 0.39 0.39 1.02 0 1.41l-4.95 4.95l4.95 4.95c0.39 0.39 0.39 1.02 0 1.41l-1.41 1.41c-0.39 0.39-1.02 0.39-1.41 0l-4.95-4.95l-4.95 4.95c-0.39 0.39-1.02 0.39-1.41 0l-1.41-1.41c-0.39-0.39-0.39-1.02 0-1.41l4.95-4.95l-4.95-4.95c-0.39-0.39-0.39-1.02 0-1.41l1.41-1.41c0.39-0.39 1.02-0.39 1.41 0l4.95 4.95z"></path></svg>', r = Ee(), s = J("div"), s.textContent = "Pixano Explorer", j(i, "class", "absolute top-0 right-0 p-2 z-10"), j(t, "class", "absolute top-0 bg-white w-screen h-screen dark:bg-zinc-900"), j(s, "class", "absolute bottom-0 right-0 px-2 py-1 bg-zinc-50 text-zinc-500 text-sm border-t border-l rounded-tl-lg dark:bg-zinc-900 dark:text-zinc-300 dark:border-zinc-500")
             },
             m(c, f) {
-                _e(c, t, f), u && u.m(t, null), U(t, n), U(t, i), _e(c, r, f), _e(c, a, f), s = !0, o || (l = [Ot(window, "keydown", e[2]), Ot(i, "click", e[1])], o = !0)
+                we(c, t, f), u && u.m(t, null), G(t, n), G(t, i), we(c, r, f), we(c, s, f), a = !0, o || (l = [wt(window, "keydown", e[2]), wt(i, "click", e[1])], o = !0)
             },
             p(c, [f]) {
-                c[0] ? u ? (u.p(c, f), f & 1 && Te(u, 1)) : (u = uM(c), u.c(), Te(u, 1), u.m(t, n)) : u && (yr(), ze(u, 1, 1, () => {
+                c[0] ? u ? (u.p(c, f), f & 1 && Te(u, 1)) : (u = bM(c), u.c(), Te(u, 1), u.m(t, n)) : u && (ur(), Ie(u, 1, 1, () => {
                     u = null
-                }), vr())
+                }), cr())
             },
             i(c) {
-                s || (Te(u), s = !0)
+                a || (Te(u), a = !0)
             },
             o(c) {
-                ze(u), s = !1
+                Ie(u), a = !1
             },
             d(c) {
-                c && xe(t), u && u.d(), c && xe(r), c && xe(a), o = !1, Ka(l)
+                c && _e(t), u && u.d(), c && _e(r), c && _e(s), o = !1, js(l)
             }
         }
     }
 
-    function q2e(e, t, n) {
+    function Fbe(e, t, n) {
         let {
             datasetId: i
         } = t, {
             rowIndex: r
-        } = t, a = null;
-        const s = Sc();
+        } = t, s = null;
+        const a = fc();
 
         function o() {
-            s("closeclick")
+            a("closeclick")
         }
         async function l(u) {
             u.keyCode == 27 && o()
         }
-        return bm(async () => {
-            n(0, a = await n9(i, r))
+        return Z0(async () => {
+            n(0, s = await u9(i, r))
         }), e.$$set = u => {
             "datasetId" in u && n(3, i = u.datasetId), "rowIndex" in u && n(4, r = u.rowIndex)
-        }, [a, o, l, i, r]
+        }, [s, o, l, i, r]
     }
-    class W2e extends Cn {
+    class Rbe extends wn {
         constructor(t) {
-            super(), On(this, t, q2e, U2e, rn, {
+            super(), _n(this, t, Fbe, Obe, tn, {
                 datasetId: 3,
                 rowIndex: 4
             })
         }
     }
 
-    function cM(e) {
+    function xM(e) {
         let t, n = e[1].name + "",
             i;
         return {
             c() {
-                t = K("span"), i = Qe(n), B(t, "class", "ml-8 px-2 py-1 flex items-center justify-center bg-zinc-100 text-zinc-600 border rounded-md border-zinc-300 dark:bg-zinc-700 dark:text-zinc-300 dark:border-zinc-600")
+                t = J("span"), i = Je(n), j(t, "class", "ml-8 px-2 py-1 flex items-center justify-center bg-zinc-100 text-zinc-600 border rounded-md border-zinc-300 dark:bg-zinc-700 dark:text-zinc-300 dark:border-zinc-600")
             },
-            m(r, a) {
-                _e(r, t, a), U(t, i)
+            m(r, s) {
+                we(r, t, s), G(t, i)
             },
-            p(r, a) {
-                a & 2 && n !== (n = r[1].name + "") && Pt(i, n)
+            p(r, s) {
+                s & 2 && n !== (n = r[1].name + "") && Ot(i, n)
             },
             d(r) {
-                r && xe(t)
+                r && _e(t)
             }
         }
     }
 
-    function fM(e) {
+    function _M(e) {
         let t, n, i;
         return {
             c() {
-                t = K("button"), t.textContent = "Back to Library", B(t, "class", "p-2 transition-colors hover:text-rose-800 dark:hover:text-rose-300")
+                t = J("button"), t.textContent = "Back to Library", j(t, "class", "p-2 transition-colors hover:text-rose-800 dark:hover:text-rose-300")
             },
-            m(r, a) {
-                _e(r, t, a), n || (i = Ot(t, "click", e[6]), n = !0)
+            m(r, s) {
+                we(r, t, s), n || (i = wt(t, "click", e[6]), n = !0)
             },
-            p: Ke,
+            p: Ve,
             d(r) {
-                r && xe(t), n = !1, i()
+                r && _e(t), n = !1, i()
             }
         }
     }
 
-    function H2e(e) {
+    function Dbe(e) {
         let t, n;
-        return t = new J8({
+        return t = new r9({
             props: {
                 datasets: e[0]
             }
         }), t.$on("datasetclick", e[4]), {
             c() {
-                ni(t.$$.fragment)
+                ei(t.$$.fragment)
             },
             m(i, r) {
-                In(t, i, r), n = !0
+                Nn(t, i, r), n = !0
             },
             p(i, r) {
-                const a = {};
-                r & 1 && (a.datasets = i[0]), t.$set(a)
+                const s = {};
+                r & 1 && (s.datasets = i[0]), t.$set(s)
             },
             i(i) {
                 n || (Te(t.$$.fragment, i), n = !0)
             },
             o(i) {
-                ze(t.$$.fragment, i), n = !1
+                Ie(t.$$.fragment, i), n = !1
             },
             d(i) {
-                jn(t, i)
+                Pn(t, i)
             }
         }
     }
 
-    function Y2e(e) {
+    function Nbe(e) {
         let t, n, i, r;
-        const a = [K2e, V2e],
-            s = [];
+        const s = [Ibe, Lbe],
+            a = [];
 
         function o(l, u) {
             return l[3] ? 1 : 0
         }
-        return t = o(e), n = s[t] = a[t](e), {
+        return t = o(e), n = a[t] = s[t](e), {
             c() {
-                n.c(), i = $l()
+                n.c(), i = bl()
             },
             m(l, u) {
-                s[t].m(l, u), _e(l, i, u), r = !0
+                a[t].m(l, u), we(l, i, u), r = !0
             },
             p(l, u) {
                 let c = t;
-                t = o(l), t === c ? s[t].p(l, u) : (yr(), ze(s[c], 1, 1, () => {
-                    s[c] = null
-                }), vr(), n = s[t], n ? n.p(l, u) : (n = s[t] = a[t](l), n.c()), Te(n, 1), n.m(i.parentNode, i))
+                t = o(l), t === c ? a[t].p(l, u) : (ur(), Ie(a[c], 1, 1, () => {
+                    a[c] = null
+                }), cr(), n = a[t], n ? n.p(l, u) : (n = a[t] = s[t](l), n.c()), Te(n, 1), n.m(i.parentNode, i))
             },
             i(l) {
                 r || (Te(n), r = !0)
             },
             o(l) {
-                ze(n), r = !1
+                Ie(n), r = !1
             },
             d(l) {
-                s[t].d(l), l && xe(i)
+                a[t].d(l), l && _e(i)
             }
         }
     }
 
-    function X2e(e) {
+    function Pbe(e) {
         let t, n;
-        return t = new Z8({}), {
+        return t = new a9({}), {
             c() {
-                ni(t.$$.fragment)
+                ei(t.$$.fragment)
             },
             m(i, r) {
-                In(t, i, r), n = !0
+                Nn(t, i, r), n = !0
             },
-            p: Ke,
+            p: Ve,
             i(i) {
                 n || (Te(t.$$.fragment, i), n = !0)
             },
             o(i) {
-                ze(t.$$.fragment, i), n = !1
+                Ie(t.$$.fragment, i), n = !1
             },
             d(i) {
-                jn(t, i)
+                Pn(t, i)
             }
         }
     }
 
-    function V2e(e) {
+    function Lbe(e) {
         let t, n;
-        return t = new W2e({
+        return t = new Rbe({
             props: {
                 datasetId: e[1].id,
                 rowIndex: e[2]
             }
         }), t.$on("closeclick", e[7]), {
             c() {
-                ni(t.$$.fragment)
+                ei(t.$$.fragment)
             },
             m(i, r) {
-                In(t, i, r), n = !0
+                Nn(t, i, r), n = !0
             },
             p(i, r) {
-                const a = {};
-                r & 2 && (a.datasetId = i[1].id), r & 4 && (a.rowIndex = i[2]), t.$set(a)
+                const s = {};
+                r & 2 && (s.datasetId = i[1].id), r & 4 && (s.rowIndex = i[2]), t.$set(s)
             },
             i(i) {
                 n || (Te(t.$$.fragment, i), n = !0)
             },
             o(i) {
-                ze(t.$$.fragment, i), n = !1
+                Ie(t.$$.fragment, i), n = !1
             },
             d(i) {
-                jn(t, i)
+                Pn(t, i)
             }
         }
     }
 
-    function K2e(e) {
+    function Ibe(e) {
         let t, n;
-        return t = new G2e({
+        return t = new Mbe({
             props: {
                 dataset: e[1]
             }
         }), t.$on("itemclick", e[5]), {
             c() {
-                ni(t.$$.fragment)
+                ei(t.$$.fragment)
             },
             m(i, r) {
-                In(t, i, r), n = !0
+                Nn(t, i, r), n = !0
             },
             p(i, r) {
-                const a = {};
-                r & 2 && (a.dataset = i[1]), t.$set(a)
+                const s = {};
+                r & 2 && (s.dataset = i[1]), t.$set(s)
             },
             i(i) {
                 n || (Te(t.$$.fragment, i), n = !0)
             },
             o(i) {
-                ze(t.$$.fragment, i), n = !1
+                Ie(t.$$.fragment, i), n = !1
             },
             d(i) {
-                jn(t, i)
+                Pn(t, i)
             }
         }
     }
 
-    function J2e(e) {
-        let t, n, i, r, a, s, o, l, u, c, f, h, d, g, p, m, y, v, b, x = e[1] && cM(e),
-            _ = e[1] && fM(e);
-        const S = [X2e, Y2e, H2e],
+    function zbe(e) {
+        let t, n, i, r, s, a, o, l, u, c, f, h, d, g, p, m, y, v, b, x = e[1] && xM(e),
+            _ = e[1] && _M(e);
+        const S = [Pbe, Nbe, Dbe],
             w = [];
 
-        function O(k, C) {
-            return k[0] ? k[1] ? 1 : 2 : 0
+        function E(A, C) {
+            return A[0] ? A[1] ? 1 : 2 : 0
         }
-        return g = O(e), p = w[g] = S[g](e), {
+        return g = E(e), p = w[g] = S[g](e), {
             c() {
-                t = K("header"), n = K("div"), i = K("div"), r = K("img"), s = Se(), o = K("span"), o.textContent = "Pixano Explorer", l = Se(), x && x.c(), u = Se(), c = K("div"), _ && _.c(), f = Se(), h = K("div"), d = Se(), p.c(), m = $l(), Sh(r.src, a = W8) || B(r, "src", a), B(r, "alt", "Logo Pixano"), B(r, "class", "w-10"), B(o, "class", "text-3xl font-bold transition-colors"), B(i, "class", "flex space-x-4 cursor-pointer hover:text-rose-800 dark:hover:text-rose-300"), B(c, "class", "mr-4 flex-grow text-right"), B(n, "class", "h-20 py-4 px-4 flex justify-start items-center bg-white border-b-2 dark:bg-zinc-800 dark:border-zinc-700"), B(t, "class", "w-full fixed"), B(h, "class", "pt-20")
+                t = J("header"), n = J("div"), i = J("div"), r = J("img"), a = Ee(), o = J("span"), o.textContent = "Pixano Explorer", l = Ee(), x && x.c(), u = Ee(), c = J("div"), _ && _.c(), f = Ee(), h = J("div"), d = Ee(), p.c(), m = bl(), fh(r.src, s = Q8) || j(r, "src", s), j(r, "alt", "Logo Pixano"), j(r, "class", "w-10"), j(o, "class", "text-3xl font-bold transition-colors"), j(i, "class", "flex space-x-4 cursor-pointer hover:text-rose-800 dark:hover:text-rose-300"), j(c, "class", "mr-4 flex-grow text-right"), j(n, "class", "h-20 py-4 px-4 flex justify-start items-center bg-white border-b-2 dark:bg-zinc-800 dark:border-zinc-700"), j(t, "class", "w-full fixed"), j(h, "class", "pt-20")
             },
-            m(k, C) {
-                _e(k, t, C), U(t, n), U(n, i), U(i, r), U(i, s), U(i, o), U(n, l), x && x.m(n, null), U(n, u), U(n, c), _ && _.m(c, null), _e(k, f, C), _e(k, h, C), _e(k, d, C), w[g].m(k, C), _e(k, m, C), y = !0, v || (b = Ot(i, "click", e[6]), v = !0)
+            m(A, C) {
+                we(A, t, C), G(t, n), G(n, i), G(i, r), G(i, a), G(i, o), G(n, l), x && x.m(n, null), G(n, u), G(n, c), _ && _.m(c, null), we(A, f, C), we(A, h, C), we(A, d, C), w[g].m(A, C), we(A, m, C), y = !0, v || (b = wt(i, "click", e[6]), v = !0)
             },
-            p(k, [C]) {
-                k[1] ? x ? x.p(k, C) : (x = cM(k), x.c(), x.m(n, u)) : x && (x.d(1), x = null), k[1] ? _ ? _.p(k, C) : (_ = fM(k), _.c(), _.m(c, null)) : _ && (_.d(1), _ = null);
-                let E = g;
-                g = O(k), g === E ? w[g].p(k, C) : (yr(), ze(w[E], 1, 1, () => {
-                    w[E] = null
-                }), vr(), p = w[g], p ? p.p(k, C) : (p = w[g] = S[g](k), p.c()), Te(p, 1), p.m(m.parentNode, m))
+            p(A, [C]) {
+                A[1] ? x ? x.p(A, C) : (x = xM(A), x.c(), x.m(n, u)) : x && (x.d(1), x = null), A[1] ? _ ? _.p(A, C) : (_ = _M(A), _.c(), _.m(c, null)) : _ && (_.d(1), _ = null);
+                let k = g;
+                g = E(A), g === k ? w[g].p(A, C) : (ur(), Ie(w[k], 1, 1, () => {
+                    w[k] = null
+                }), cr(), p = w[g], p ? p.p(A, C) : (p = w[g] = S[g](A), p.c()), Te(p, 1), p.m(m.parentNode, m))
             },
-            i(k) {
+            i(A) {
                 y || (Te(p), y = !0)
             },
-            o(k) {
-                ze(p), y = !1
+            o(A) {
+                Ie(p), y = !1
             },
-            d(k) {
-                k && xe(t), x && x.d(), _ && _.d(), k && xe(f), k && xe(h), k && xe(d), w[g].d(k), k && xe(m), v = !1, b()
+            d(A) {
+                A && _e(t), x && x.d(), _ && _.d(), A && _e(f), A && _e(h), A && _e(d), w[g].d(A), A && _e(m), v = !1, b()
             }
         }
     }
 
-    function Q2e(e, t, n) {
+    function Bbe(e, t, n) {
         let i = null,
             r = null,
-            a = null,
-            s = !1;
+            s = null,
+            a = !1;
         async function o(f) {
             n(1, r = f.detail.dataset)
         }
 
         function l(f) {
-            n(3, s = !0), n(2, a = f.detail.id)
+            n(3, a = !0), n(2, s = f.detail.id)
         }
 
         function u() {
-            n(1, r = null), n(2, a = null), ap.update(f => 1)
+            n(1, r = null), n(2, s = null), jg.update(f => 1)
         }
 
         function c() {
-            n(3, s = !1)
+            n(3, a = !1)
         }
-        return bm(async () => {
-            n(0, i = await e9())
-        }), [i, r, a, s, o, l, u, c]
+        return Z0(async () => {
+            n(0, i = await o9())
+        }), [i, r, s, a, o, l, u, c]
     }
-    class Z2e extends Cn {
+    class jbe extends wn {
         constructor(t) {
-            super(), On(this, t, Q2e, J2e, rn, {})
+            super(), _n(this, t, Bbe, zbe, tn, {})
         }
     }
     /**
     @copyright CEA-LIST/DIASI/SIALV/LVA (2023)
     @author CEA-LIST/DIASI/SIALV/LVA <pixano@cea.fr>
     @license CECILL-C
 
@@ -55240,12 +55201,12 @@
     This software is governed by the CeCILL-C license under French law and
     abiding by the rules of distribution of free software. You can use, 
     modify and/ or redistribute the software under the terms of the CeCILL-C
     license as circulated by CEA, CNRS and INRIA at the following URL
 
     http://www.cecill.info
     */
-    new Z2e({
+    new jbe({
         target: document.getElementById("app")
     })
 });
-export default exe();
+export default Ube();
```

### Comparing `pixano-0.1.1/pixano/apps/explorer/dist/assets/index-ab1a97a8.css` & `pixano-0.2.0/pixano/apps/explorer/dist/assets/index-f2b8d192.css`

 * *Files 3% similar despite different names*

```diff
@@ -1 +1 @@
-*,:before,:after{box-sizing:border-box;border-width:0;border-style:solid;border-color:#e5e7eb}:before,:after{--tw-content: ""}html{line-height:1.5;-webkit-text-size-adjust:100%;-moz-tab-size:4;-o-tab-size:4;tab-size:4;font-family:ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,Noto Sans,sans-serif,"Apple Color Emoji","Segoe UI Emoji",Segoe UI Symbol,"Noto Color Emoji";font-feature-settings:normal;font-variation-settings:normal}body{margin:0;line-height:inherit}hr{height:0;color:inherit;border-top-width:1px}abbr:where([title]){-webkit-text-decoration:underline dotted;text-decoration:underline dotted}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit}a{color:inherit;text-decoration:inherit}b,strong{font-weight:bolder}code,kbd,samp,pre{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,Liberation Mono,Courier New,monospace;font-size:1em}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}table{text-indent:0;border-color:inherit;border-collapse:collapse}button,input,optgroup,select,textarea{font-family:inherit;font-size:100%;font-weight:inherit;line-height:inherit;color:inherit;margin:0;padding:0}button,select{text-transform:none}button,[type=button],[type=reset],[type=submit]{-webkit-appearance:button;background-color:transparent;background-image:none}:-moz-focusring{outline:auto}:-moz-ui-invalid{box-shadow:none}progress{vertical-align:baseline}::-webkit-inner-spin-button,::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}summary{display:list-item}blockquote,dl,dd,h1,h2,h3,h4,h5,h6,hr,figure,p,pre{margin:0}fieldset{margin:0;padding:0}legend{padding:0}ol,ul,menu{list-style:none;margin:0;padding:0}textarea{resize:vertical}input::-moz-placeholder,textarea::-moz-placeholder{opacity:1;color:#9ca3af}input::placeholder,textarea::placeholder{opacity:1;color:#9ca3af}button,[role=button]{cursor:pointer}:disabled{cursor:default}img,svg,video,canvas,audio,iframe,embed,object{display:block;vertical-align:middle}img,video{max-width:100%;height:auto}[hidden]{display:none}*,:before,:after{--tw-border-spacing-x: 0;--tw-border-spacing-y: 0;--tw-translate-x: 0;--tw-translate-y: 0;--tw-rotate: 0;--tw-skew-x: 0;--tw-skew-y: 0;--tw-scale-x: 1;--tw-scale-y: 1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness: proximity;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width: 0px;--tw-ring-offset-color: #fff;--tw-ring-color: rgb(59 130 246 / .5);--tw-ring-offset-shadow: 0 0 #0000;--tw-ring-shadow: 0 0 #0000;--tw-shadow: 0 0 #0000;--tw-shadow-colored: 0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: }::backdrop{--tw-border-spacing-x: 0;--tw-border-spacing-y: 0;--tw-translate-x: 0;--tw-translate-y: 0;--tw-rotate: 0;--tw-skew-x: 0;--tw-skew-y: 0;--tw-scale-x: 1;--tw-scale-y: 1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness: proximity;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width: 0px;--tw-ring-offset-color: #fff;--tw-ring-color: rgb(59 130 246 / .5);--tw-ring-offset-shadow: 0 0 #0000;--tw-ring-shadow: 0 0 #0000;--tw-shadow: 0 0 #0000;--tw-shadow-colored: 0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: }.container{width:100%}@media (min-width: 640px){.container{max-width:640px}}@media (min-width: 768px){.container{max-width:768px}}@media (min-width: 1024px){.container{max-width:1024px}}@media (min-width: 1280px){.container{max-width:1280px}}@media (min-width: 1536px){.container{max-width:1536px}}.visible{visibility:visible}.fixed{position:fixed}.absolute{position:absolute}.relative{position:relative}.sticky{position:sticky}.-right-3{right:-.75rem}.-top-2{top:-.5rem}.bottom-0{bottom:0px}.left-0{left:0px}.right-0{right:0px}.right-6{right:1.5rem}.top-0{top:0px}.top-1\/2{top:50%}.z-10{z-index:10}.col-span-1{grid-column:span 1 / span 1}.col-span-2{grid-column:span 2 / span 2}.m-4{margin:1rem}.mx-auto{margin-left:auto;margin-right:auto}.my-2{margin-top:.5rem;margin-bottom:.5rem}.mb-1{margin-bottom:.25rem}.mb-2{margin-bottom:.5rem}.ml-1{margin-left:.25rem}.ml-2{margin-left:.5rem}.ml-4{margin-left:1rem}.ml-8{margin-left:2rem}.mr-2{margin-right:.5rem}.mr-4{margin-right:1rem}.mt-2{margin-top:.5rem}.mt-3{margin-top:.75rem}.mt-4{margin-top:1rem}.mt-8{margin-top:2rem}.mt-80{margin-top:20rem}.block{display:block}.flex{display:flex}.table{display:table}.grid{display:grid}.hidden{display:none}.h-1\/5{height:20%}.h-10{height:2.5rem}.h-2{height:.5rem}.h-20{height:5rem}.h-3\/5{height:60%}.h-56{height:14rem}.h-80{height:20rem}.h-\[85vh\]{height:85vh}.h-fit{height:-moz-fit-content;height:fit-content}.h-full{height:100%}.h-screen{height:100vh}.max-h-48{max-height:12rem}.min-h-screen{min-height:100vh}.w-1\/2{width:50%}.w-10{width:2.5rem}.w-56{width:14rem}.w-64{width:16rem}.w-72{width:18rem}.w-full{width:100%}.w-screen{width:100vw}.min-w-\[14rem\]{min-width:14rem}.max-w-sm{max-width:24rem}.flex-1{flex:1 1 0%}.flex-grow{flex-grow:1}.table-auto{table-layout:auto}.-translate-y-1\/2{--tw-translate-y: -50%;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}@keyframes pulse{50%{opacity:.5}}.animate-pulse{animation:pulse 2s cubic-bezier(.4,0,.6,1) infinite}.cursor-pointer{cursor:pointer}.grid-cols-3{grid-template-columns:repeat(3,minmax(0,1fr))}.grid-cols-6{grid-template-columns:repeat(6,minmax(0,1fr))}.flex-col{flex-direction:column}.flex-wrap{flex-wrap:wrap}.items-end{align-items:flex-end}.items-center{align-items:center}.justify-start{justify-content:flex-start}.justify-end{justify-content:flex-end}.justify-center{justify-content:center}.gap-4{gap:1rem}.space-x-2>:not([hidden])~:not([hidden]){--tw-space-x-reverse: 0;margin-right:calc(.5rem * var(--tw-space-x-reverse));margin-left:calc(.5rem * calc(1 - var(--tw-space-x-reverse)))}.space-x-4>:not([hidden])~:not([hidden]){--tw-space-x-reverse: 0;margin-right:calc(1rem * var(--tw-space-x-reverse));margin-left:calc(1rem * calc(1 - var(--tw-space-x-reverse)))}.space-y-3>:not([hidden])~:not([hidden]){--tw-space-y-reverse: 0;margin-top:calc(.75rem * calc(1 - var(--tw-space-y-reverse)));margin-bottom:calc(.75rem * var(--tw-space-y-reverse))}.space-y-6>:not([hidden])~:not([hidden]){--tw-space-y-reverse: 0;margin-top:calc(1.5rem * calc(1 - var(--tw-space-y-reverse)));margin-bottom:calc(1.5rem * var(--tw-space-y-reverse))}.self-center{align-self:center}.overflow-x-auto{overflow-x:auto}.overflow-y-auto{overflow-y:auto}.overflow-y-scroll{overflow-y:scroll}.rounded{border-radius:.25rem}.rounded-full{border-radius:9999px}.rounded-lg{border-radius:.5rem}.rounded-md{border-radius:.375rem}.rounded-tl-lg{border-top-left-radius:.5rem}.border{border-width:1px}.border-2{border-width:2px}.border-b{border-bottom-width:1px}.border-b-2{border-bottom-width:2px}.border-l{border-left-width:1px}.border-t{border-top-width:1px}.border-rose-500{--tw-border-opacity: 1;border-color:rgb(244 63 94 / var(--tw-border-opacity))}.border-transparent{border-color:transparent}.border-zinc-100{--tw-border-opacity: 1;border-color:rgb(244 244 245 / var(--tw-border-opacity))}.border-zinc-200{--tw-border-opacity: 1;border-color:rgb(228 228 231 / var(--tw-border-opacity))}.border-zinc-300{--tw-border-opacity: 1;border-color:rgb(212 212 216 / var(--tw-border-opacity))}.bg-rose-500{--tw-bg-opacity: 1;background-color:rgb(244 63 94 / var(--tw-bg-opacity))}.bg-slate-200{--tw-bg-opacity: 1;background-color:rgb(226 232 240 / var(--tw-bg-opacity))}.bg-white{--tw-bg-opacity: 1;background-color:rgb(255 255 255 / var(--tw-bg-opacity))}.bg-zinc-100{--tw-bg-opacity: 1;background-color:rgb(244 244 245 / var(--tw-bg-opacity))}.bg-zinc-50{--tw-bg-opacity: 1;background-color:rgb(250 250 250 / var(--tw-bg-opacity))}.fill-rose-600{fill:#e11d48}.object-cover{-o-object-fit:cover;object-fit:cover}.object-center{-o-object-position:center;object-position:center}.p-2{padding:.5rem}.p-4{padding:1rem}.px-1{padding-left:.25rem;padding-right:.25rem}.px-2{padding-left:.5rem;padding-right:.5rem}.px-3{padding-left:.75rem;padding-right:.75rem}.px-4{padding-left:1rem;padding-right:1rem}.px-8{padding-left:2rem;padding-right:2rem}.py-1{padding-top:.25rem;padding-bottom:.25rem}.py-2{padding-top:.5rem;padding-bottom:.5rem}.py-4{padding-top:1rem;padding-bottom:1rem}.pl-2{padding-left:.5rem}.pr-4{padding-right:1rem}.pt-2{padding-top:.5rem}.pt-20{padding-top:5rem}.text-left{text-align:left}.text-center{text-align:center}.text-right{text-align:right}.text-3xl{font-size:1.875rem;line-height:2.25rem}.text-lg{font-size:1.125rem;line-height:1.75rem}.text-sm{font-size:.875rem;line-height:1.25rem}.text-xl{font-size:1.25rem;line-height:1.75rem}.text-xs{font-size:.75rem;line-height:1rem}.font-bold{font-weight:700}.font-medium{font-weight:500}.uppercase{text-transform:uppercase}.italic{font-style:italic}.text-white{--tw-text-opacity: 1;color:rgb(255 255 255 / var(--tw-text-opacity))}.text-zinc-50{--tw-text-opacity: 1;color:rgb(250 250 250 / var(--tw-text-opacity))}.text-zinc-500{--tw-text-opacity: 1;color:rgb(113 113 122 / var(--tw-text-opacity))}.text-zinc-600{--tw-text-opacity: 1;color:rgb(82 82 91 / var(--tw-text-opacity))}.text-zinc-700{--tw-text-opacity: 1;color:rgb(63 63 70 / var(--tw-text-opacity))}.text-zinc-900{--tw-text-opacity: 1;color:rgb(24 24 27 / var(--tw-text-opacity))}.shadow{--tw-shadow: 0 1px 3px 0 rgb(0 0 0 / .1), 0 1px 2px -1px rgb(0 0 0 / .1);--tw-shadow-colored: 0 1px 3px 0 var(--tw-shadow-color), 0 1px 2px -1px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow)}.outline{outline-style:solid}.grayscale{--tw-grayscale: grayscale(100%);filter:var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow)}.filter{filter:var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow)}.transition-all{transition-property:all;transition-timing-function:cubic-bezier(.4,0,.2,1);transition-duration:.15s}.transition-colors{transition-property:color,background-color,border-color,text-decoration-color,fill,stroke;transition-timing-function:cubic-bezier(.4,0,.2,1);transition-duration:.15s}.checked\:accent-rose-500:checked{accent-color:#f43f5e}.hover\:scale-\[102\.5\%\]:hover{--tw-scale-x: 102.5%;--tw-scale-y: 102.5%;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.hover\:border-rose-500:hover{--tw-border-opacity: 1;border-color:rgb(244 63 94 / var(--tw-border-opacity))}.hover\:bg-zinc-100:hover{--tw-bg-opacity: 1;background-color:rgb(244 244 245 / var(--tw-bg-opacity))}.hover\:bg-zinc-50:hover{--tw-bg-opacity: 1;background-color:rgb(250 250 250 / var(--tw-bg-opacity))}.hover\:fill-rose-400:hover{fill:#fb7185}.hover\:text-rose-600:hover{--tw-text-opacity: 1;color:rgb(225 29 72 / var(--tw-text-opacity))}.hover\:text-rose-800:hover{--tw-text-opacity: 1;color:rgb(159 18 57 / var(--tw-text-opacity))}@media (prefers-color-scheme: dark){.dark\:border-rose-800{--tw-border-opacity: 1;border-color:rgb(159 18 57 / var(--tw-border-opacity))}.dark\:border-zinc-500{--tw-border-opacity: 1;border-color:rgb(113 113 122 / var(--tw-border-opacity))}.dark\:border-zinc-600{--tw-border-opacity: 1;border-color:rgb(82 82 91 / var(--tw-border-opacity))}.dark\:border-zinc-700{--tw-border-opacity: 1;border-color:rgb(63 63 70 / var(--tw-border-opacity))}.dark\:border-zinc-800{--tw-border-opacity: 1;border-color:rgb(39 39 42 / var(--tw-border-opacity))}.dark\:bg-rose-800{--tw-bg-opacity: 1;background-color:rgb(159 18 57 / var(--tw-bg-opacity))}.dark\:bg-zinc-700{--tw-bg-opacity: 1;background-color:rgb(63 63 70 / var(--tw-bg-opacity))}.dark\:bg-zinc-800{--tw-bg-opacity: 1;background-color:rgb(39 39 42 / var(--tw-bg-opacity))}.dark\:bg-zinc-900{--tw-bg-opacity: 1;background-color:rgb(24 24 27 / var(--tw-bg-opacity))}.dark\:text-zinc-300{--tw-text-opacity: 1;color:rgb(212 212 216 / var(--tw-text-opacity))}.dark\:text-zinc-400{--tw-text-opacity: 1;color:rgb(161 161 170 / var(--tw-text-opacity))}.dark\:text-zinc-50{--tw-text-opacity: 1;color:rgb(250 250 250 / var(--tw-text-opacity))}.dark\:hover\:bg-zinc-700:hover{--tw-bg-opacity: 1;background-color:rgb(63 63 70 / var(--tw-bg-opacity))}.dark\:hover\:bg-zinc-800:hover{--tw-bg-opacity: 1;background-color:rgb(39 39 42 / var(--tw-bg-opacity))}.dark\:hover\:text-rose-300:hover{--tw-text-opacity: 1;color:rgb(253 164 175 / var(--tw-text-opacity))}.dark\:hover\:text-rose-700:hover{--tw-text-opacity: 1;color:rgb(190 18 60 / var(--tw-text-opacity))}}
+*,:before,:after{box-sizing:border-box;border-width:0;border-style:solid;border-color:#e5e7eb}:before,:after{--tw-content: ""}html{line-height:1.5;-webkit-text-size-adjust:100%;-moz-tab-size:4;-o-tab-size:4;tab-size:4;font-family:ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,Noto Sans,sans-serif,"Apple Color Emoji","Segoe UI Emoji",Segoe UI Symbol,"Noto Color Emoji";font-feature-settings:normal;font-variation-settings:normal}body{margin:0;line-height:inherit}hr{height:0;color:inherit;border-top-width:1px}abbr:where([title]){-webkit-text-decoration:underline dotted;text-decoration:underline dotted}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit}a{color:inherit;text-decoration:inherit}b,strong{font-weight:bolder}code,kbd,samp,pre{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,Liberation Mono,Courier New,monospace;font-size:1em}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}table{text-indent:0;border-color:inherit;border-collapse:collapse}button,input,optgroup,select,textarea{font-family:inherit;font-size:100%;font-weight:inherit;line-height:inherit;color:inherit;margin:0;padding:0}button,select{text-transform:none}button,[type=button],[type=reset],[type=submit]{-webkit-appearance:button;background-color:transparent;background-image:none}:-moz-focusring{outline:auto}:-moz-ui-invalid{box-shadow:none}progress{vertical-align:baseline}::-webkit-inner-spin-button,::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}summary{display:list-item}blockquote,dl,dd,h1,h2,h3,h4,h5,h6,hr,figure,p,pre{margin:0}fieldset{margin:0;padding:0}legend{padding:0}ol,ul,menu{list-style:none;margin:0;padding:0}textarea{resize:vertical}input::-moz-placeholder,textarea::-moz-placeholder{opacity:1;color:#9ca3af}input::placeholder,textarea::placeholder{opacity:1;color:#9ca3af}button,[role=button]{cursor:pointer}:disabled{cursor:default}img,svg,video,canvas,audio,iframe,embed,object{display:block;vertical-align:middle}img,video{max-width:100%;height:auto}[hidden]{display:none}*,:before,:after{--tw-border-spacing-x: 0;--tw-border-spacing-y: 0;--tw-translate-x: 0;--tw-translate-y: 0;--tw-rotate: 0;--tw-skew-x: 0;--tw-skew-y: 0;--tw-scale-x: 1;--tw-scale-y: 1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness: proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width: 0px;--tw-ring-offset-color: #fff;--tw-ring-color: rgb(59 130 246 / .5);--tw-ring-offset-shadow: 0 0 #0000;--tw-ring-shadow: 0 0 #0000;--tw-shadow: 0 0 #0000;--tw-shadow-colored: 0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: }::backdrop{--tw-border-spacing-x: 0;--tw-border-spacing-y: 0;--tw-translate-x: 0;--tw-translate-y: 0;--tw-rotate: 0;--tw-skew-x: 0;--tw-skew-y: 0;--tw-scale-x: 1;--tw-scale-y: 1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness: proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width: 0px;--tw-ring-offset-color: #fff;--tw-ring-color: rgb(59 130 246 / .5);--tw-ring-offset-shadow: 0 0 #0000;--tw-ring-shadow: 0 0 #0000;--tw-shadow: 0 0 #0000;--tw-shadow-colored: 0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: }.container{width:100%}@media (min-width: 640px){.container{max-width:640px}}@media (min-width: 768px){.container{max-width:768px}}@media (min-width: 1024px){.container{max-width:1024px}}@media (min-width: 1280px){.container{max-width:1280px}}@media (min-width: 1536px){.container{max-width:1536px}}.visible{visibility:visible}.fixed{position:fixed}.absolute{position:absolute}.relative{position:relative}.sticky{position:sticky}.-right-3{right:-.75rem}.-top-2{top:-.5rem}.bottom-0{bottom:0px}.left-0{left:0px}.right-0{right:0px}.right-6{right:1.5rem}.top-0{top:0px}.top-1\/2{top:50%}.z-10{z-index:10}.col-span-1{grid-column:span 1 / span 1}.col-span-2{grid-column:span 2 / span 2}.m-4{margin:1rem}.mx-auto{margin-left:auto;margin-right:auto}.my-2{margin-top:.5rem;margin-bottom:.5rem}.mb-1{margin-bottom:.25rem}.mb-2{margin-bottom:.5rem}.ml-1{margin-left:.25rem}.ml-2{margin-left:.5rem}.ml-4{margin-left:1rem}.ml-8{margin-left:2rem}.mr-2{margin-right:.5rem}.mr-4{margin-right:1rem}.mt-2{margin-top:.5rem}.mt-3{margin-top:.75rem}.mt-4{margin-top:1rem}.mt-8{margin-top:2rem}.mt-80{margin-top:20rem}.block{display:block}.flex{display:flex}.table{display:table}.grid{display:grid}.hidden{display:none}.h-1\/5{height:20%}.h-10{height:2.5rem}.h-2{height:.5rem}.h-20{height:5rem}.h-3\/5{height:60%}.h-56{height:14rem}.h-80{height:20rem}.h-\[85vh\]{height:85vh}.h-fit{height:-moz-fit-content;height:fit-content}.h-full{height:100%}.h-screen{height:100vh}.max-h-48{max-height:12rem}.min-h-screen{min-height:100vh}.w-1\/2{width:50%}.w-10{width:2.5rem}.w-56{width:14rem}.w-64{width:16rem}.w-72{width:18rem}.w-full{width:100%}.w-screen{width:100vw}.min-w-\[14rem\]{min-width:14rem}.max-w-sm{max-width:24rem}.flex-1{flex:1 1 0%}.flex-grow{flex-grow:1}.table-auto{table-layout:auto}.-translate-y-1\/2{--tw-translate-y: -50%;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}@keyframes pulse{50%{opacity:.5}}.animate-pulse{animation:pulse 2s cubic-bezier(.4,0,.6,1) infinite}.cursor-pointer{cursor:pointer}.grid-cols-3{grid-template-columns:repeat(3,minmax(0,1fr))}.grid-cols-6{grid-template-columns:repeat(6,minmax(0,1fr))}.flex-col{flex-direction:column}.flex-wrap{flex-wrap:wrap}.items-end{align-items:flex-end}.items-center{align-items:center}.justify-start{justify-content:flex-start}.justify-end{justify-content:flex-end}.justify-center{justify-content:center}.gap-4{gap:1rem}.space-x-2>:not([hidden])~:not([hidden]){--tw-space-x-reverse: 0;margin-right:calc(.5rem * var(--tw-space-x-reverse));margin-left:calc(.5rem * calc(1 - var(--tw-space-x-reverse)))}.space-x-4>:not([hidden])~:not([hidden]){--tw-space-x-reverse: 0;margin-right:calc(1rem * var(--tw-space-x-reverse));margin-left:calc(1rem * calc(1 - var(--tw-space-x-reverse)))}.space-y-3>:not([hidden])~:not([hidden]){--tw-space-y-reverse: 0;margin-top:calc(.75rem * calc(1 - var(--tw-space-y-reverse)));margin-bottom:calc(.75rem * var(--tw-space-y-reverse))}.space-y-6>:not([hidden])~:not([hidden]){--tw-space-y-reverse: 0;margin-top:calc(1.5rem * calc(1 - var(--tw-space-y-reverse)));margin-bottom:calc(1.5rem * var(--tw-space-y-reverse))}.self-center{align-self:center}.overflow-x-auto{overflow-x:auto}.overflow-y-auto{overflow-y:auto}.overflow-y-scroll{overflow-y:scroll}.rounded{border-radius:.25rem}.rounded-full{border-radius:9999px}.rounded-lg{border-radius:.5rem}.rounded-md{border-radius:.375rem}.rounded-tl-lg{border-top-left-radius:.5rem}.border{border-width:1px}.border-2{border-width:2px}.border-b{border-bottom-width:1px}.border-b-2{border-bottom-width:2px}.border-l{border-left-width:1px}.border-t{border-top-width:1px}.border-rose-500{--tw-border-opacity: 1;border-color:rgb(244 63 94 / var(--tw-border-opacity))}.border-transparent{border-color:transparent}.border-zinc-100{--tw-border-opacity: 1;border-color:rgb(244 244 245 / var(--tw-border-opacity))}.border-zinc-200{--tw-border-opacity: 1;border-color:rgb(228 228 231 / var(--tw-border-opacity))}.border-zinc-300{--tw-border-opacity: 1;border-color:rgb(212 212 216 / var(--tw-border-opacity))}.bg-rose-500{--tw-bg-opacity: 1;background-color:rgb(244 63 94 / var(--tw-bg-opacity))}.bg-slate-200{--tw-bg-opacity: 1;background-color:rgb(226 232 240 / var(--tw-bg-opacity))}.bg-white{--tw-bg-opacity: 1;background-color:rgb(255 255 255 / var(--tw-bg-opacity))}.bg-zinc-100{--tw-bg-opacity: 1;background-color:rgb(244 244 245 / var(--tw-bg-opacity))}.bg-zinc-50{--tw-bg-opacity: 1;background-color:rgb(250 250 250 / var(--tw-bg-opacity))}.fill-rose-600{fill:#e11d48}.object-cover{-o-object-fit:cover;object-fit:cover}.object-center{-o-object-position:center;object-position:center}.p-2{padding:.5rem}.p-4{padding:1rem}.px-1{padding-left:.25rem;padding-right:.25rem}.px-2{padding-left:.5rem;padding-right:.5rem}.px-3{padding-left:.75rem;padding-right:.75rem}.px-4{padding-left:1rem;padding-right:1rem}.px-8{padding-left:2rem;padding-right:2rem}.py-1{padding-top:.25rem;padding-bottom:.25rem}.py-2{padding-top:.5rem;padding-bottom:.5rem}.py-4{padding-top:1rem;padding-bottom:1rem}.pl-2{padding-left:.5rem}.pr-4{padding-right:1rem}.pt-2{padding-top:.5rem}.pt-20{padding-top:5rem}.text-left{text-align:left}.text-center{text-align:center}.text-right{text-align:right}.text-3xl{font-size:1.875rem;line-height:2.25rem}.text-lg{font-size:1.125rem;line-height:1.75rem}.text-sm{font-size:.875rem;line-height:1.25rem}.text-xl{font-size:1.25rem;line-height:1.75rem}.text-xs{font-size:.75rem;line-height:1rem}.font-bold{font-weight:700}.font-medium{font-weight:500}.uppercase{text-transform:uppercase}.italic{font-style:italic}.text-white{--tw-text-opacity: 1;color:rgb(255 255 255 / var(--tw-text-opacity))}.text-zinc-50{--tw-text-opacity: 1;color:rgb(250 250 250 / var(--tw-text-opacity))}.text-zinc-500{--tw-text-opacity: 1;color:rgb(113 113 122 / var(--tw-text-opacity))}.text-zinc-600{--tw-text-opacity: 1;color:rgb(82 82 91 / var(--tw-text-opacity))}.text-zinc-700{--tw-text-opacity: 1;color:rgb(63 63 70 / var(--tw-text-opacity))}.text-zinc-900{--tw-text-opacity: 1;color:rgb(24 24 27 / var(--tw-text-opacity))}.shadow{--tw-shadow: 0 1px 3px 0 rgb(0 0 0 / .1), 0 1px 2px -1px rgb(0 0 0 / .1);--tw-shadow-colored: 0 1px 3px 0 var(--tw-shadow-color), 0 1px 2px -1px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow)}.outline{outline-style:solid}.grayscale{--tw-grayscale: grayscale(100%);filter:var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow)}.filter{filter:var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow)}.transition-all{transition-property:all;transition-timing-function:cubic-bezier(.4,0,.2,1);transition-duration:.15s}.transition-colors{transition-property:color,background-color,border-color,text-decoration-color,fill,stroke;transition-timing-function:cubic-bezier(.4,0,.2,1);transition-duration:.15s}.checked\:accent-rose-500:checked{accent-color:#f43f5e}.hover\:scale-\[102\.5\%\]:hover{--tw-scale-x: 102.5%;--tw-scale-y: 102.5%;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.hover\:border-rose-500:hover{--tw-border-opacity: 1;border-color:rgb(244 63 94 / var(--tw-border-opacity))}.hover\:bg-zinc-100:hover{--tw-bg-opacity: 1;background-color:rgb(244 244 245 / var(--tw-bg-opacity))}.hover\:bg-zinc-50:hover{--tw-bg-opacity: 1;background-color:rgb(250 250 250 / var(--tw-bg-opacity))}.hover\:fill-rose-400:hover{fill:#fb7185}.hover\:text-rose-600:hover{--tw-text-opacity: 1;color:rgb(225 29 72 / var(--tw-text-opacity))}.hover\:text-rose-800:hover{--tw-text-opacity: 1;color:rgb(159 18 57 / var(--tw-text-opacity))}@media (prefers-color-scheme: dark){.dark\:border-rose-800{--tw-border-opacity: 1;border-color:rgb(159 18 57 / var(--tw-border-opacity))}.dark\:border-zinc-500{--tw-border-opacity: 1;border-color:rgb(113 113 122 / var(--tw-border-opacity))}.dark\:border-zinc-600{--tw-border-opacity: 1;border-color:rgb(82 82 91 / var(--tw-border-opacity))}.dark\:border-zinc-700{--tw-border-opacity: 1;border-color:rgb(63 63 70 / var(--tw-border-opacity))}.dark\:border-zinc-800{--tw-border-opacity: 1;border-color:rgb(39 39 42 / var(--tw-border-opacity))}.dark\:bg-rose-800{--tw-bg-opacity: 1;background-color:rgb(159 18 57 / var(--tw-bg-opacity))}.dark\:bg-zinc-700{--tw-bg-opacity: 1;background-color:rgb(63 63 70 / var(--tw-bg-opacity))}.dark\:bg-zinc-800{--tw-bg-opacity: 1;background-color:rgb(39 39 42 / var(--tw-bg-opacity))}.dark\:bg-zinc-900{--tw-bg-opacity: 1;background-color:rgb(24 24 27 / var(--tw-bg-opacity))}.dark\:text-zinc-300{--tw-text-opacity: 1;color:rgb(212 212 216 / var(--tw-text-opacity))}.dark\:text-zinc-400{--tw-text-opacity: 1;color:rgb(161 161 170 / var(--tw-text-opacity))}.dark\:text-zinc-50{--tw-text-opacity: 1;color:rgb(250 250 250 / var(--tw-text-opacity))}.dark\:hover\:bg-zinc-700:hover{--tw-bg-opacity: 1;background-color:rgb(63 63 70 / var(--tw-bg-opacity))}.dark\:hover\:bg-zinc-800:hover{--tw-bg-opacity: 1;background-color:rgb(39 39 42 / var(--tw-bg-opacity))}.dark\:hover\:text-rose-300:hover{--tw-text-opacity: 1;color:rgb(253 164 175 / var(--tw-text-opacity))}.dark\:hover\:text-rose-700:hover{--tw-text-opacity: 1;color:rgb(190 18 60 / var(--tw-text-opacity))}}
```

### Comparing `pixano-0.1.1/pixano/apps/explorer/dist/assets/pixano-354ac9df.png` & `pixano-0.2.0/pixano/apps/explorer/dist/assets/pixano-354ac9df.png`

 * *Files identical despite different names*

### Comparing `pixano-0.1.1/pixano/core/__init__.py` & `pixano-0.2.0/pixano/core/__init__.py`

 * *Files identical despite different names*

### Comparing `pixano-0.1.1/pixano/core/dataset.py` & `pixano-0.2.0/pixano/core/dataset.py`

 * *Files 16% similar despite different names*

```diff
@@ -9,39 +9,56 @@
 # modify and/ or redistribute the software under the terms of the CeCILL-C
 # license as circulated by CEA, CNRS and INRIA at the following URL
 #
 # http://www.cecill.info
 
 import time
 from pathlib import Path
+from typing import Optional
 
 import pyarrow as pa
-import pyarrow.dataset as arrow_ds
+import pyarrow.dataset as ds
 import pyarrow.parquet as pq
 import pydantic
 
 
 class DatasetInfo(pydantic.BaseModel):
+    """DatasetInfo
+
+    Attributes:
+        id (str): Dataset ID
+        name (str): Dataset name
+        description (str): Dataset description
+        num_elements (int): Number of elements in dataset
+        preview (str, optional): Dataset preview
+    """
+
     id: str
     name: str
     description: str
     num_elements: int
-    preview: str | None
+    preview: Optional[str]
 
 
 class Dataset:
     """Dataset class
 
-    Args:
+    Attributes:
         _path (Path): Dataset path
         _info (DatasetInfo): Dataset info
         _table (pa.Table): Dataset table
     """
 
     def __init__(self, path: Path):
+        """Initialize dataset
+
+        Args:
+            path (Path): Dataset path
+        """
+
         self._path = path
         self._info = DatasetInfo.parse_file(self._path / "spec.json")
         self._table = None
 
     @property
     def info(self):
         return self._info
@@ -58,37 +75,61 @@
             et = time.process_time()
             res = et - st
             print("CPU Execution time:", res, "seconds")
 
         return self._table
 
     def load(self):
-        partitioning = arrow_ds.partitioning(
+        partitioning = ds.partitioning(
             pa.schema([("split", pa.string())]), flavor="hive"
         )
-        return arrow_ds.dataset(self._path / "db", partitioning=partitioning)
+        return ds.dataset(self._path / "db", partitioning=partitioning)
 
 
 class InferenceDataset(Dataset):
     """Inference Dataset
 
-    Args:
+    Attributes:
         _path (Path): Dataset path
         _info (DatasetInfo): Dataset info
         _table (pa.Table): Dataset table
     """
 
     def __init__(self, path: Path):
         self._path = path
         self._info = DatasetInfo.parse_file(self._path / "infer.json")
         self._table = None
 
     def load(self):
-        partitioning = arrow_ds.partitioning(
+        partitioning = ds.partitioning(
+            pa.schema([("split", pa.string())]), flavor="hive"
+        )
+        return ds.dataset(
+            self._path,
+            partitioning=partitioning,
+            ignore_prefixes=["info", "infer.json"],
+        )
+
+
+class EmbeddingDataset(Dataset):
+    """Embedding Dataset
+
+    Attributes:
+        _path (Path): Dataset path
+        _info (DatasetInfo): Dataset info
+        _table (pa.Table): Dataset table
+    """
+
+    def __init__(self, path: Path):
+        self._path = path
+        self._info = DatasetInfo.parse_file(self._path / "embed.json")
+        self._table = None
+
+    def load(self):
+        partitioning = ds.partitioning(
             pa.schema([("split", pa.string())]), flavor="hive"
         )
-        return arrow_ds.dataset(
+        return ds.dataset(
             self._path,
             partitioning=partitioning,
-            ignore_prefixes=["info"],
-            exclude_invalid_files=True,
+            ignore_prefixes=["info", "embed.json"],
         )
```

### Comparing `pixano-0.1.1/pixano/core/dataset_test.py` & `pixano-0.2.0/pixano/core/dataset_test.py`

 * *Files identical despite different names*

### Comparing `pixano-0.1.1/pixano/core/arrow_types/__init__.py` & `pixano-0.2.0/pixano/core/arrow_types/features.py`

 * *Files 26% similar despite different names*

```diff
@@ -7,108 +7,113 @@
 # This software is governed by the CeCILL-C license under French law and
 # abiding by the rules of distribution of free software. You can use,
 # modify and/ or redistribute the software under the terms of the CeCILL-C
 # license as circulated by CEA, CNRS and INRIA at the following URL
 #
 # http://www.cecill.info
 
+from typing import Optional
+
 import pyarrow as pa
-from pyarrow import ArrowKeyError
+from pydantic import BaseModel
+
+from .image import CompressedRLEType
 
-from .features import BBoxType
-from .image import CompressedRLEType, Image, ImageType, is_image_type
 
-__all__ = [
-    "ImageType",
-    "Image",
-    "CompressedRLEType",
-    "BBoxType",
-    "ObjectAnnotationType",
-    "is_image_type",
-]
+class BBoxType(pa.ExtensionType):
+    """Bounding box type as PyArrow list of PyArrow float32"""
 
+    def __init__(self):
+        super(BBoxType, self).__init__(pa.list_(pa.float32(), list_size=4), "bbox")
+
+    @classmethod
+    def __arrow_ext_deserialize__(cls, storage_type, serialized):
+        return BBoxType()
+
+    def __arrow_ext_serialize__(self):
+        return b""
+
+
+class ObjectAnnotation(BaseModel):
+    """ObjectAnnotation class to contain all annotation data
+
+    Attributes:
+        id (str): Annotation unique ID
+        view_id (str, optional): View ID (e.g. 'image', 'cam_2')
+        bbox (list[float], optional): Bounding box coordinates in xywh format (using top left point as reference)
+        bbox_source (str, optional): Bounding box source
+        bbox_confidence (float, optional): Bounding box confidence
+        is_group_of (bool, optional): is_group_of
+        is_difficult (bool, optional): is_difficult
+        is_truncated (bool, optional): is_truncated
+        mask (dict[str, bytes], optional): Mask
+        mask_source (str, optional): Mask source
+        area (float, optional): area
+        pose (dict[str, list[float]], optional): Pose
+        category_id (int, optional): Category ID
+        category_name (str, optional): Category name
+        identity (str, optional): Identity
+    """
+
+    # Object ID and View ID
+    id: str
+    view_id: Optional[str] = None
+    # Bounding Box
+    bbox: Optional[list[float]] = None
+    bbox_source: Optional[str] = None
+    bbox_confidence: Optional[float] = None
+    is_group_of: Optional[bool] = None
+    is_difficult: Optional[bool] = None
+    is_truncated: Optional[bool] = None
+    # Mask
+    mask: Optional[dict[str, bytes]] = None
+    mask_source: Optional[str] = None
+    area: Optional[float] = None
+    # 6D Poses
+    pose: Optional[dict[str, list[float]]] = {
+        "cam_R_m2c": [0] * 9,
+        "cam_t_m2c": [0] * 3,
+    }
+    # Category
+    category_id: Optional[int] = None
+    category_name: Optional[str] = None
+    identity: Optional[str] = None
+
+
+def ObjectAnnotationType() -> pa.StructType:
+    """ObjectAnnotation type as PyArrow StructType
+
+    Returns:
+        pa.StructType: ObjectAnnotation StructType
+    """
 
-def ObjectAnnotationType():
-    # Have to be consistent with class ObjectAnnotation (pixano>core>models.py)
     pose_schema = pa.struct(
         [
             pa.field("cam_R_m2c", pa.list_(pa.float64(), list_size=9)),
             pa.field("cam_t_m2c", pa.list_(pa.float64(), list_size=3)),
         ]
     )
 
     return pa.struct(
         [
+            # Object ID and View ID
             pa.field("id", pa.string()),
             pa.field("view_id", pa.string(), nullable=True),
-            # bounding box
+            # Bounding Box
             pa.field("bbox", BBoxType(), nullable=True),
             pa.field("bbox_source", pa.string(), nullable=True),
             pa.field("bbox_confidence", pa.float32(), nullable=True),
             pa.field("is_group_of", pa.bool_(), nullable=True),
             pa.field("is_difficult", pa.bool_(), nullable=True),
             pa.field("is_truncated", pa.bool_(), nullable=True),
-            # mask
+            # Mask
             pa.field("mask", CompressedRLEType(), nullable=True),
             pa.field("mask_source", pa.string(), nullable=True),
             pa.field("area", pa.float32(), nullable=True),
-            # 6d poses
+            # 6D Poses
             pa.field("pose", pose_schema, nullable=True),
             # Category
             pa.field("category_id", pa.int32(), nullable=True),
             pa.field("category_name", pa.string(), nullable=True),
             pa.field("identity", pa.string(), nullable=True),
         ]
     )
-
-
-def convert_field(name, typ, col):
-    """pyarrow is unable to convert ExtensionTypes properly in pa.Table.from_pandas"""
-    if isinstance(typ, pa.ExtensionType):
-        storage = pa.array(col, type=typ.storage_type)
-        return pa.ExtensionArray.from_storage(typ, storage)
-    elif pa.types.is_list(typ):
-        native_arr = pa.array(col)
-        if isinstance(native_arr, pa.NullArray):
-            return pa.nulls(len(native_arr), typ)
-        offsets = native_arr.offsets
-        values = native_arr.values.to_numpy(zero_copy_only=False)
-        return pa.ListArray.from_arrays(
-            offsets, convert_field(f"{name}.elements", typ.value_type, values)
-        )
-    elif pa.types.is_struct(typ):
-        native_arr = pa.array(col)
-        if isinstance(native_arr, pa.NullArray):
-            return pa.nulls(len(native_arr), typ)
-        arrays = []
-        for subfield in typ:
-            sub_arr = native_arr.field(subfield.name)
-            converted = convert_field(
-                f"{name}.{subfield.name}",
-                subfield.type,
-                sub_arr.to_numpy(zero_copy_only=False),
-            )
-            arrays.append(converted)
-        return pa.StructArray.from_arrays(arrays, fields=typ)
-    else:
-        return pa.array(col, type=typ)
-
-
-def register_extension_types():
-    types = [
-        BBoxType(),
-        CompressedRLEType(),
-        ImageType(),
-    ]
-    for t in types:
-        try:
-            pa.register_extension_type(t)
-        except ArrowKeyError:
-            # already registered
-            pass
-
-
-def is_number(t: pa.DataType) -> bool:
-    return pa.types.is_integer(t) or pa.types.is_floating(t)
-
-
-register_extension_types()
```

### Comparing `pixano-0.1.1/pixano/core/arrow_types/image.py` & `pixano-0.2.0/pixano/core/arrow_types/image.py`

 * *Files 18% similar despite different names*

```diff
@@ -8,46 +8,46 @@
 # abiding by the rules of distribution of free software. You can use,
 # modify and/ or redistribute the software under the terms of the CeCILL-C
 # license as circulated by CEA, CNRS and INRIA at the following URL
 #
 # http://www.cecill.info
 
 import base64
-from typing import IO, Optional
+from typing import IO
 
 import pyarrow as pa
 from etils import epath
 
 
 class Image:
     """Image type using URI string or bytes"""
 
     def __init__(
         self,
         uri: str,
         bytes: bytes,
         preview_bytes: bytes,
-        uri_prefix: Optional[epath.PathLike] = None,
+        uri_prefix: epath.PathLike = None,
     ):
         """Creates image from UIR, bytes and preview
 
-        Args:
-            uri (str): _description_
-            bytes (bytes): _description_
-            preview_bytes (bytes): _description_
-            uri_prefix (Optional[epath.PathLike], optional): _description_. Defaults to None.
+        Attributes:
+            uri (str): Image URI
+            bytes (bytes): Image bytes
+            preview_bytes (bytes): Image preview bytes
+            uri_prefix (epath.PathLike, optional): Image URI prefix. Defaults to None.
         """
         self._uri = uri
         self._bytes = bytes
         self._preview_bytes = preview_bytes
 
         self.uri_prefix = uri_prefix
 
     @property
-    def bytes(self) -> Optional[bytes]:
+    def bytes(self) -> bytes:
         if self._bytes is not None:
             return self._bytes
         elif self._uri is not None:
             print(f"loading {self._uri}")
             with self.open() as f:
                 return f.read()
         else:
@@ -124,15 +124,15 @@
             self.value["uri"].as_py(),
             self.value["bytes"].as_py(),
             self.value["preview_bytes"].as_py(),
         )
 
 
 class CompressedRLEType(pa.ExtensionType):
-    """Segmentation mask type as compressed RLE"""
+    """Segmentation mask type as PyArrow StructType"""
 
     def __init__(self):
         super(CompressedRLEType, self).__init__(
             pa.struct(
                 [
                     pa.field("size", pa.list_(pa.int32())),
                     pa.field("counts", pa.binary()),
```

### Comparing `pixano-0.1.1/pixano/data/__init__.py` & `pixano-0.2.0/pixano/data/__init__.py`

 * *Ordering differences only*

 * *Files 0% similar despite different names*

```diff
@@ -7,16 +7,16 @@
 # This software is governed by the CeCILL-C license under French law and
 # abiding by the rules of distribution of free software. You can use,
 # modify and/ or redistribute the software under the terms of the CeCILL-C
 # license as circulated by CEA, CNRS and INRIA at the following URL
 #
 # http://www.cecill.info
 
+from .coco_loader import CocoLoader
 from .data_loader import DataLoader
 from .pixano_loader import PixanoLoader
-from .coco_loader import CocoLoader
 
 __all__ = [
     "DataLoader",
     "PixanoLoader",
     "CocoLoader",
 ]
```

### Comparing `pixano-0.1.1/pixano/data/coco_loader.py` & `pixano-0.2.0/pixano/data/coco_loader.py`

 * *Files 17% similar despite different names*

```diff
@@ -12,23 +12,40 @@
 # http://www.cecill.info
 
 import os
 
 from PIL import Image
 from pycocotools.coco import COCO
 
-import pixano.core.models as ann_models
 from pixano import transforms
+from pixano.core import arrow_types
 
 from .data_loader import DataLoader
 
 
-# COCO Loader
 class CocoLoader(DataLoader):
-    def __init__(self, workspace, ann_file, img_path):
+    """COCO Data Loader
+
+    Attributes:
+        coco (COCO): COCO dataset
+        info (dict): Dataset info
+        img_ids (list[int]): Image IDs
+        iter_img_ids (iter): Image IDs iterable
+        idx (int): Index
+    """
+
+    def __init__(self, workspace: str, ann_file: str, img_path: str):
+        """Initialize COCO Data Loader
+
+        Args:
+            workspace (str): Data path
+            ann_file (str): Annotations path
+            img_path (str): Images path
+        """
+
         annf = os.path.join(workspace, ann_file)
 
         # initialize COCO api for instance annotations
         self.coco = COCO(annf)
 
         self.img_ids = self.coco.getImgIds()
         self.img_ids.sort()
@@ -37,25 +54,26 @@
         self.info["images_path"] = os.path.join(workspace, img_path)
         self.info["nb_images"] = len(self.img_ids)
 
         # make img_ids iterable
         self.iter_img_ids = iter(self.img_ids)
         self.idx = 0
 
-    def load_ann(self, id, width, height):
+    def load_ann(self, id: int, width: int, height: int) -> list[dict]:
         """Load COCO annotations
 
         Args:
-            id: image id
-            width: image width, for normalization
-            height: image height, for normalization
+            id (int): image id
+            width (int): image width, for normalization
+            height (int): image height, for normalization
 
         Returns:
-            dict containing this annotation data
+            list[dict]: Annotation data
         """
+
         ann_ids = self.coco.getAnnIds(id)
         anns = self.coco.loadAnns(ids=ann_ids)
         objects = []
         for ann in anns:
             bbox = None
             if ann["bbox"]:
                 bbox = transforms.normalize(ann["bbox"], width, height)
@@ -64,18 +82,18 @@
                 rle = self.coco.annToRLE(ann)
 
             # TMP to check
             if isinstance(rle, list) and len(rle) > 1:
                 print("WARNING - MULTI RLE SPOTTED !!", len(rle), rle)
 
             objects.append(
-                ann_models.ObjectAnnotation(
-                    id=ann["id"],
+                arrow_types.ObjectAnnotation(
+                    id=str(ann["id"]),
                     view_id="image",
-                    is_group_of=ann["iscrowd"],
+                    is_group_of=bool(ann["iscrowd"]),
                     category_id=ann["category_id"],
                     category_name=self.coco.loadCats(ann["category_id"])[0]["name"],
                     bbox=bbox,
                     mask=rle,
                 ).dict()
             )
```

### Comparing `pixano-0.1.1/pixano/data/data_loader.py` & `pixano-0.2.0/pixano/data/data_loader.py`

 * *Files 10% similar despite different names*

```diff
@@ -7,19 +7,20 @@
 # This software is governed by the CeCILL-C license under French law and
 # abiding by the rules of distribution of free software. You can use,
 # modify and/ or redistribute the software under the terms of the CeCILL-C
 # license as circulated by CEA, CNRS and INRIA at the following URL
 #
 # http://www.cecill.info
 
-# Generic Loader
 from abc import ABC, abstractmethod
 
 
 class DataLoader(ABC):
+    """Generic Data Loader"""
+
     @property
     def data_info(self):
         return self.info
 
     @data_info.setter
     def data_info(self, newinfo):
         self.info = newinfo
```

### Comparing `pixano-0.1.1/pixano/data/pixano_loader.py` & `pixano-0.2.0/pixano/data/pixano_loader.py`

 * *Files 6% similar despite different names*

```diff
@@ -16,23 +16,41 @@
 from math import isnan
 from pathlib import Path
 
 from PIL import Image
 from pycocotools import mask as mask_api
 from tqdm import tqdm
 
-import pixano.core.models as ann_models
 from pixano import transforms
+from pixano.core import arrow_types
 
 from .data_loader import DataLoader
 
 
-# Pixano Loader
 class PixanoLoader(DataLoader):
-    def __init__(self, workspace, ann_file, img_path=None, view="image"):
+    """Pixano Data Loader
+
+    Attributes:
+        dataset (dict): Dataset
+        info (dict): Dataset info
+        iter_data (iter): Data iterable
+    """
+
+    def __init__(
+        self, workspace: str, ann_file: str, img_path: Path = None, view: str = "image"
+    ):
+        """Initalize COCO Data Loader
+
+        Args:
+            workspace (str): Data path
+            ann_file (str): Annotation file name
+            img_path (Path, optional): Image path. Defaults to None.
+            view (str, optional): Image view name. Defaults to "image".
+        """
+
         if ann_file is None:
             print(
                 "PixanoLoader: Please provide an annotation file, or use another Loader if no annotations"
             )
             return
         self.info = {}
 
@@ -90,29 +108,32 @@
             "path": "images/cylindric/test/20170320_163113/cam_0",
             "type": "sequence_image"
         },
         "task_name": "object2d"
     }
     """
 
-    def getFeaturesFromJSON(self, data, workspace: Path, img_path: Path, view):
-        """get all features from Pixano annotation file
+    def getFeaturesFromJSON(
+        self, data, workspace: Path, img_path: Path, view: str
+    ) -> list[dict]:
+        """Get features from Pixano annotation file
 
         Args:
             data (str): raw json
-            workspace (Path): _description_
-            img_path (Path): _description_
-            view (_type_): _description_
+            workspace (Path): Data path
+            img_path (Path): Image path
+            view (str): Image view name
 
         Raises:
-            Exception: _description_
+            Exception: Image not found
 
         Returns:
-            _type_: _description_
+            list[dict]: List of features
         """
+
         img_list = None
         if img_path is not None:
             self.info["images_path"] = str(workspace / img_path)
             img_list = sorted(list((workspace / img_path / view).glob("*.jpg")))
             if len(img_list) != len(data["data"]["children"]):
                 print(
                     f"WARNING: Number ({len(img_list)}) of files in {img_path / view} differ \
@@ -218,15 +239,15 @@
                 print("No geometry?")  # Ca peut etre un mask, ou 3d, trackink... etc.
 
             # TMP to check
             if isinstance(rle, list) and len(rle) > 1:
                 print("WARNING - MULTI RLE SPOTTED !!", len(rle), rle)
 
             feats["objects"].append(
-                ann_models.ObjectAnnotation(
+                arrow_types.ObjectAnnotation(
                     id=str(ann["id"]),
                     view_id=view,
                     is_group_of=False,
                     # category_id=  # pas de categoryId, on le crée ensuite
                     category_name=ann["category"],
                     bbox=bbox,
                     mask=rle,
```

### Comparing `pixano-0.1.1/pixano/inference/__init__.py` & `pixano-0.2.0/pixano/notebook/__init__.py`

 * *Files 17% similar despite different names*

```diff
@@ -7,12 +7,12 @@
 # This software is governed by the CeCILL-C license under French law and
 # abiding by the rules of distribution of free software. You can use,
 # modify and/ or redistribute the software under the terms of the CeCILL-C
 # license as circulated by CEA, CNRS and INRIA at the following URL
 #
 # http://www.cecill.info
 
-from .inference_model import InferenceModel
+from .display import display
 
 __all__ = [
-    "InferenceModel",
+    "display",
 ]
```

### Comparing `pixano-0.1.1/pixano/tools/converter/__init__.py` & `pixano-0.2.0/pixano/tools/converter/__init__.py`

 * *Files identical despite different names*

### Comparing `pixano-0.1.1/pixano/tools/converter/convert2parquet.py` & `pixano-0.2.0/pixano/tools/converter/convert2parquet.py`

 * *Files 17% similar despite different names*

```diff
@@ -21,105 +21,128 @@
 import pyarrow.dataset as ds
 from PIL import Image
 from tqdm import tqdm
 
 from pixano.core import arrow_types
 
 
-def media_copy(images_path, fname, dest, view, multiview):
-    """Copy file from given source to "media" directory
+def media_copy(
+    images_path: Path, filename: str, path: Path, view: str, multiview: bool
+):
+    """Copy file from source to media directory
 
     Args:
-        images_path (str | Path): images source path
-        fname (str): image file name
-        dest (Path): path to dataset
-        view (str): view name
-        multiview (boolean): true if multiview
+        images_path (Path): Image path
+        filename (str): Image filename
+        path (Path): Dataset path
+        view (str): View name
+        multiview (bool): True if multiview
+
+    Raises:
+        Exception: Empty filename
+        Exception: File not found
+        Exception: File copy error
     """
-    # copy file "view_feat['<view>_path']" in dest/media/<view>
-    if fname is None or len(fname) == 0:
-        print("No uri !")
-        return
-    fsrc = Path(images_path) / Path(fname)
-    # checks needed because of inconsistent old Pixano format...
-    if not fsrc.is_file():
-        fsrc = Path(images_path) / Path(fname).name
-        if not fsrc.is_file():
-            raise f"Unable to find image.\nimage path: {images_path}\nfile: {fsrc}"
 
+    # Check provided filename
+    if filename is None or len(filename) == 0:
+        raise Exception("No uri given")
+
+    # Get file
+    file = Path(images_path) / Path(filename)
+
+    # Check if file exists
+    if not file.is_file():
+        # Because of inconsistent old Pixano format, try this first
+        file = Path(images_path) / Path(filename).name
+        if not file.is_file():
+            raise Exception(f"File not found (path: {images_path}, filename: {file})")
+
+    # Media path
+    media_path = path / "media"
     if multiview:
-        fdest_path = dest / "media" / view
-    else:
-        fdest_path = dest / "media"
-    if not fdest_path.exists():
-        fdest_path.mkdir(parents=True)
+        media_path = media_path / view
+    media_path.mkdir(parents=True, exist_ok=True)
+
+    # Copy
     try:
-        shutil.copy(fsrc, fdest_path / fsrc.name)
+        shutil.copy(file, media_path / file.name)
     except Exception as e:
-        print("Image copy error", e)
-        print("    src", fsrc)
-        print("    dst", str(fdest_path / fsrc.name))
+        raise Exception(
+            f"Image copy error: {e} (src: {file}, dst: {str(media_path / file.name)})"
+        )
 
 
-def generate_spec(split_info, dest: Path, name, description=None, stop=None):
-    """genarate spec.json specification file
+def generate_spec(
+    split_info: dict,
+    path: Path,
+    name: str,
+    description: str = "",
+    limits: list[int] = [],
+):
+    """Generate spec.json
 
     Args:
-        split_info (dict): dict which contain genrator for each split and views
-        dest (Path): path to dataset
-        name (str): dataset name
-        description(str, optionnal): description of dataset
-        stop (list[int], optional): array of limit to number of image, per split
+        split_info (dict): Generator for each split and views
+        path (Path): Dataset path
+        name (str): Dataset name
+        description (str, optional): Dataset description. Defaults to "".
+        limits (list[int], optional): Image limits per split. Defaults to [].
+
+    Raises:
+        Exception: File creation error
     """
+
     spec = {}
     spec["id"] = uuid.uuid4().hex
     spec["name"] = str(name)
     spec["description"] = description if description else str(name)
 
-    if stop:
-        spec["num_elements"] = sum(stop)
+    if limits:
+        spec["num_elements"] = sum(limits)
     else:
-        nb_images = 0
+        num_elements = 0
         for split in split_info:
             if hasattr(split_info[split], "info"):
-                nb_images += split_info[split].info["nb_images"]
+                num_elements += split_info[split].info["nb_images"]
             else:
                 counts = [d.info["nb_images"] for d in split_info[split].values()]
                 if counts.count(counts[0]) != len(counts):
                     raise Exception(
                         "Images counts are not consistent across views:"
                         + ", ".join(str(k) for k in split_info[split])
                     )
-                nb_images += counts[0]
-        spec["num_elements"] = nb_images
+                num_elements += counts[0]
+        spec["num_elements"] = num_elements
 
     try:
-        with open(dest / "spec.json", "w") as f:
+        with open(path / "spec.json", "w") as f:
             json.dump(spec, f)
-            print("File " + str(dest) + "/spec.json written")
+            print("File " + str(path) + "/spec.json written")
     except IOError as err:
-        print("Error creating spec.json file:" + err)
+        raise Exception(f"Error creating spec.json file: {err}")
 
 
-def generate_parquet(split_info, dest, schema=None, stop=None):
+def generate_parquet(
+    split_info: dict, path: Path, schema: pa.schema = None, limits: list[int] = []
+):
     """Generate parquet file
 
     Args:
-        split_info (dict): dict which contain genrator for each split and views
-        dest (Path): path to dataset
-        schema (pyarrow.schema, optionnal): pyarrow schema if custom schema needed
-        stop (list[int], optional): array of limit to number of image, per split
+        split_info (dict): Generators for each split and view
+        path (Path): Dataset path
+        schema (pa.schema, optional): Dataset PyArrow schema. Defaults to None.
+        limits (list[int], optional): Image limits per split. Defaults to None.
     """
 
-    parquet_path = dest / "db"
-    if not parquet_path.exists():
-        parquet_path.mkdir(parents=True)
+    db_path = path / "db"
+    db_path.mkdir(parents=True, exist_ok=True)
 
     for i, split in enumerate(split_info):
-        split_stop = stop[i] if stop else None
+        split_limit = limits[i] if limits else 0
         lfeat = []
         if hasattr(split_info[split], "info"):
             # SingleView
             multiview = False
             datas = [split_info[split]]
             views = [
                 "image"
@@ -136,32 +159,32 @@
                     "Images counts are not consistent across views:"
                     + ", ".join(str(v) for v in views)
                 )
             nb_images = counts[0]
 
         try:
             if nb_images:
-                if split_stop is None or split_stop > nb_images:
-                    split_stop = nb_images
+                if split_limit is 0 or split_limit > nb_images:
+                    split_limit = nb_images
                     print(
-                        f"Reading data for whole dataset (split:{split}) of {split_stop} items."
+                        f"Reading data for whole dataset (split:{split}) of {split_limit} items."
                     )
                 else:
                     print(
-                        f"Reading data for subset dataset (split:{split}) of first {split_stop}/{nb_images} items."
+                        f"Reading data for subset dataset (split:{split}) of first {split_limit}/{nb_images} items."
                     )
-                for i in tqdm(range(split_stop)):
+                for i in tqdm(range(split_limit)):
                     feat = {}
                     for i, data in enumerate(datas):
                         view_feat = next(data)
                         if "uri" in view_feat[views[i]]:
                             media_copy(
                                 data.info["images_path"],
                                 view_feat[views[i]]["uri"],
-                                dest,
+                                path,
                                 views[i],
                                 multiview,
                             )
 
                         if "objects" in feat:
                             # extend annotations
                             view_feat["objects"].extend(feat["objects"])
@@ -171,40 +194,40 @@
             else:
                 # TODO not consistent anymore with if case...
                 print(
                     "Generating parquet file. Number of image unknown. Prints ./* every 10/100 items."
                 )
                 i = 0
                 # TODO multiview
-                while (feat := next(data)) and (split_stop < 0 or i < split_stop):
+                while (feat := next(data)) and (split_limit < 0 or i < split_limit):
                     feat["split"] = split
                     lfeat.append(feat)
                     i = 1 + i
                     if i % 100 == 0:
                         print("*", end="", flush=True)
                     else:
                         if i % 10 == 0:
                             print(".", end="", flush=True)
-                    if i == split_stop:
+                    if i == split_limit:
                         raise StopIteration
         except StopIteration:
             print("Done!")
 
-        if not schema:
-            sch = [
+        if schema is None:
+            fields = [
                 pa.field("id", pa.string()),
                 pa.field("objects", pa.list_(arrow_types.ObjectAnnotationType())),
                 pa.field("split", pa.string()),
             ]
             for view in views:
-                sch.append(pa.field(view + ".width", pa.int32(), nullable=True))
-                sch.append(pa.field(view + ".height", pa.int32(), nullable=True))
-                sch.append(pa.field(view, arrow_types.ImageType()))
+                fields.append(pa.field(view + ".width", pa.int32(), nullable=True))
+                fields.append(pa.field(view + ".height", pa.int32(), nullable=True))
+                fields.append(pa.field(view, arrow_types.ImageType()))
 
-            schema = pa.schema(sch)
+            schema = pa.schema(fields)
 
         # Transpose lfeats (list of rows to cols (list of col))
         cols = {k: [dic[k] for dic in lfeat] for k in lfeat[0]}
 
         arrays = []
         for field in schema:
             if field.name in cols:
@@ -214,23 +237,23 @@
             else:
                 print("Incorrect field:", field.name)
 
         table = pa.Table.from_arrays(arrays=arrays, schema=schema)
 
         ds.write_dataset(
             data=table,
-            base_dir=parquet_path / split,
+            base_dir=db_path / split,
             basename_template=f"part-{{i}}.parquet",
             format="parquet",
             max_rows_per_file=2048,
             max_rows_per_group=2048,
             existing_data_behavior="overwrite_or_ignore",
         )
 
-        print("Parquet written in " + str(parquet_path / split))
+        print("Parquet written in " + str(db_path / split))
 
     # PREVIEW - create file "preview.png"
     # get 6 first (todo? random) images
     # get image field names for preview
     image_fields = []
     for f in schema:
         if arrow_types.is_image_type(f.type):
@@ -240,25 +263,32 @@
         tile_w = 64
         tile_h = 64
         preview = Image.new("RGB", (3 * tile_w, 2 * tile_h))
         for i, f in enumerate(lfeat[:6]):
             im = f[image_fields[i % len(image_fields)]]
             image = Image.open(io.BytesIO(im["preview_bytes"]))
             preview.paste(image, ((i % 3) * tile_w, (int(i / 3) % 2) * tile_h))
-        preview.save(dest / "preview.png")
+        preview.save(path / "preview.png")
 
 
-def convert(split_info, outpath, name, schema=None, stop=None, description=None):
+def convert(
+    split_info: dict,
+    library_path: str,
+    name: str,
+    schema: pa.schema = None,
+    limits: list[int] = [],
+    description: str = "",
+):
     """Create Pixano parquet dataset from generator(s)
 
     Args:
-        split_info (dict): dict which contain genrator for each split and views
-        outpath (str): destination path, should be path to library
-        name (str): dataset name
-        schema (pyarrow.schema, optionnal): _description_
-        stop (list[int], optional): array of limit to number of image, per split
-        description (str, optional): Description of dataset. Defaults to None.
+        split_info (dict): Generators for each split and view
+        library_path (str): Dataset library path
+        name (str): Dataset name
+        schema (pa.schema, optional): Dataset PyArrow schema. Defaults to None.
+        limits (list[int], optional): Image limits per split. Defaults to [].
+        description (str, optional): Dataset description. Defaults to "".
     """
-    dataset_path = Path(outpath) / name
 
-    generate_parquet(split_info, dataset_path, schema, stop)
-    generate_spec(split_info, dataset_path, name, description, stop)
+    path = Path(library_path) / name
+    generate_parquet(split_info, path, schema, limits)
+    generate_spec(split_info, path, name, description, limits)
```

### Comparing `pixano-0.1.1/pixano/transforms/__init__.py` & `pixano-0.2.0/pixano/transforms/__init__.py`

 * *Files 8% similar despite different names*

```diff
@@ -7,29 +7,28 @@
 # This software is governed by the CeCILL-C license under French law and
 # abiding by the rules of distribution of free software. You can use,
 # modify and/ or redistribute the software under the terms of the CeCILL-C
 # license as circulated by CEA, CNRS and INRIA at the following URL
 #
 # http://www.cecill.info
 
-from .boxes import normalize, denormalize, mask_to_bbox, xywh_to_xyxy, xyxy_to_xywh
+from .boxes import denormalize, mask_to_bbox, normalize, xywh_to_xyxy, xyxy_to_xywh
 from .image import (
-    image_to_binary,
     binary_to_base64,
-    depth_file_to_binary,
     depth_array_to_gray,
+    depth_file_to_binary,
+    image_to_binary,
+    mask_to_polygons,
     mask_to_rle,
     rle_to_mask,
     rle_to_polygons,
-    mask_to_polygons,
     rle_to_urle,
 )
 from .labels import coco_names_80, coco_names_91, voc_names
 
-
 __all__ = [
     "normalize",
     "denormalize",
     "mask_to_bbox",
     "xywh_to_xyxy",
     "xyxy_to_xywh",
     "image_to_binary",
```

### Comparing `pixano-0.1.1/pixano/transforms/boxes.py` & `pixano-0.2.0/pixano/transforms/boxes.py`

 * *Files identical despite different names*

### Comparing `pixano-0.1.1/pixano/transforms/image.py` & `pixano-0.2.0/pixano/transforms/image.py`

 * *Files 0% similar despite different names*

```diff
@@ -120,15 +120,15 @@
     return mask_api.encode(mask_array)
 
 
 def rle_to_mask(rle: dict) -> np.ndarray:
     """Decode mask from RLE to NumPy array
 
     Args:
-        rle_mask (dict): Mask as RLE
+        rle (dict): Mask as RLE
 
     Returns:
         np.ndarray: Mask as NumPy array
     """
 
     return mask_api.decode(rle)
```

### Comparing `pixano-0.1.1/pixano/transforms/labels.py` & `pixano-0.2.0/pixano/transforms/labels.py`

 * *Files identical despite different names*

### Comparing `pixano-0.1.1/LICENSE.txt` & `pixano-0.2.0/LICENSE`

 * *Files identical despite different names*

### Comparing `pixano-0.1.1/pyproject.toml` & `pixano-0.2.0/pyproject.toml`

 * *Files 16% similar despite different names*

```diff
@@ -3,59 +3,55 @@
 build-backend = "hatchling.build"
 
 [project]
 name = "pixano"
 dynamic = ["version"]
 description = 'Data-centric AI building blocks for computer vision applications' 
 readme = "README.md"
-requires-python = ">=3.8"
-license = "CeCILL-C"
+requires-python = ">=3.10"
+license = { file = "LICENSE" }
 authors = [{name = "Pixano Developers", email = "pixano@cea.fr"}]
 keywords = [
   "machine learning",
   "computer vision",
   "data",
   "visualization"
 ]
 classifiers = [
   "Development Status :: 4 - Beta",
-  "Programming Language :: Python",
-  "Programming Language :: Python :: 3.8", 
-  "Programming Language :: Python :: 3.9",
   "Programming Language :: Python :: 3.10",
-  "Programming Language :: Python :: 3.11",
-  "Programming Language :: Python :: Implementation :: CPython",
-  "Programming Language :: Python :: Implementation :: PyPy",
+  "License :: CeCILL-C Free Software License Agreement (CECILL-C)",
 ]
 dependencies = [
   "duckdb ~= 0.7.0",
   "etils ~= 1.1.0",
   "fastapi-pagination ~= 0.11.4",
   "imageio ~= 2.25.0",
   "importlib-resources ~= 5.12.0",
+  "ipywidgets ~= 8.0.0",
+  "jinja2 ~= 3.1.2",
   "numpy ~= 1.23.0",
+  "onnx ~= 1.13.0",
+  "onnxruntime ~= 1.14.0",
   "opencv-python ~= 4.7.0",
   "pandas ~= 1.5.0",
   "Pillow ~= 9.4.0",
   "pyarrow ~= 11.0.0",
   "pycocotools ~= 2.0.0",
   "setuptools ~= 65.6.0",
   "shortuuid ~= 1.0.0",
   "tqdm ~= 4.64.0",
-  "uvicorn ~= 0.20.0"
+  "uvicorn ~= 0.20.0",
 ]
 
 [project.optional-dependencies]
 documentation = [
   "mkdocs-material ~= 9.1.0",
   "mkdocstrings-python ~= 0.9.0"
 ]
-notebooks = [
-  "ipywidgets ~= 8.0.0"
-]
 
 [project.urls]
 Documentation = "https://github.com/pixano/pixano#readme"
 Issues = "https://github.com/pixano/pixano/issues"
 Source = "https://github.com/pixano/pixano"
 
 [project.scripts]
```

