# Comparing `tmp/DUELink-1.0.1-py3-none-any.whl.zip` & `tmp/DUELink-1.0.2-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,27 +1,29 @@
-Zip file size: 15109 bytes, number of entries: 25
--rw-rw-rw-  2.0 fat     1149 b- defN 23-May-01 19:02 DUE/Analog.py
--rw-rw-rw-  2.0 fat     1464 b- defN 23-May-01 18:08 DUE/Button.py
--rw-rw-rw-  2.0 fat     4362 b- defN 23-May-01 18:54 DUE/DUEController.py
--rw-rw-rw-  2.0 fat      230 b- defN 23-Apr-11 13:02 DUE/DeviceConfiguration.py
--rw-rw-rw-  2.0 fat     1253 b- defN 23-May-01 18:54 DUE/Digital.py
--rw-rw-rw-  2.0 fat     3361 b- defN 23-May-15 18:43 DUE/Display.py
--rw-rw-rw-  2.0 fat      813 b- defN 23-Apr-11 13:51 DUE/DistanceSensor.py
--rw-rw-rw-  2.0 fat      811 b- defN 23-Mar-29 18:00 DUE/Frequency.py
--rw-rw-rw-  2.0 fat     1995 b- defN 23-Apr-24 12:27 DUE/I2C.py
--rw-rw-rw-  2.0 fat      641 b- defN 23-Mar-29 18:00 DUE/Infrared.py
--rw-rw-rw-  2.0 fat      346 b- defN 23-Mar-29 18:00 DUE/Led.py
--rw-rw-rw-  2.0 fat     1890 b- defN 23-May-17 16:40 DUE/Neo.py
--rw-rw-rw-  2.0 fat     2973 b- defN 23-May-01 16:37 DUE/Script.py
--rw-rw-rw-  2.0 fat    10457 b- defN 23-Apr-24 14:13 DUE/SerialInterface.py
--rw-rw-rw-  2.0 fat      623 b- defN 23-Apr-11 13:21 DUE/ServoMoto.py
--rw-rw-rw-  2.0 fat     1077 b- defN 23-Mar-29 18:00 DUE/Sound.py
--rw-rw-rw-  2.0 fat     3985 b- defN 23-Apr-18 17:42 DUE/Spi.py
--rw-rw-rw-  2.0 fat     2261 b- defN 23-May-15 19:00 DUE/System.py
--rw-rw-rw-  2.0 fat      468 b- defN 23-Mar-29 18:00 DUE/Touch.py
--rw-rw-rw-  2.0 fat     1204 b- defN 23-Apr-11 13:24 DUE/Uart.py
--rw-rw-rw-  2.0 fat        0 b- defN 23-Mar-28 15:42 DUE/__init__.py
--rw-rw-rw-  2.0 fat      318 b- defN 23-May-19 17:29 DUELink-1.0.1.dist-info/METADATA
--rw-rw-rw-  2.0 fat       92 b- defN 23-May-19 17:29 DUELink-1.0.1.dist-info/WHEEL
--rw-rw-rw-  2.0 fat        4 b- defN 23-May-19 17:29 DUELink-1.0.1.dist-info/top_level.txt
-?rw-rw-r--  2.0 fat     1790 b- defN 23-May-19 17:29 DUELink-1.0.1.dist-info/RECORD
-25 files, 43567 bytes uncompressed, 12319 bytes compressed:  71.7%
+Zip file size: 17347 bytes, number of entries: 27
+-rw-rw-rw-  2.0 fat     1239 b- defN 23-May-23 18:21 DUELink/Analog.py
+-rw-rw-rw-  2.0 fat     1688 b- defN 23-May-23 18:21 DUELink/Button.py
+-rw-rw-rw-  2.0 fat     4896 b- defN 23-May-24 16:12 DUELink/DUELinkController.py
+-rw-rw-rw-  2.0 fat      230 b- defN 23-May-23 18:21 DUELink/DeviceConfiguration.py
+-rw-rw-rw-  2.0 fat     1434 b- defN 23-May-24 18:26 DUELink/Digital.py
+-rw-rw-rw-  2.0 fat     6593 b- defN 23-May-24 16:10 DUELink/Display.py
+-rw-rw-rw-  2.0 fat      811 b- defN 23-May-23 18:31 DUELink/DistanceSensor.py
+-rw-rw-rw-  2.0 fat      888 b- defN 23-May-24 17:08 DUELink/Frequency.py
+-rw-rw-rw-  2.0 fat      779 b- defN 23-May-23 18:21 DUELink/Humidity.py
+-rw-rw-rw-  2.0 fat     1995 b- defN 23-May-23 18:21 DUELink/I2C.py
+-rw-rw-rw-  2.0 fat      711 b- defN 23-May-23 18:21 DUELink/Infrared.py
+-rw-rw-rw-  2.0 fat      346 b- defN 23-May-23 18:21 DUELink/Led.py
+-rw-rw-rw-  2.0 fat     1932 b- defN 23-May-23 18:21 DUELink/Neo.py
+-rw-rw-rw-  2.0 fat      887 b- defN 23-May-23 18:21 DUELink/Pin.py
+-rw-rw-rw-  2.0 fat     2977 b- defN 23-May-23 18:21 DUELink/Script.py
+-rw-rw-rw-  2.0 fat    10461 b- defN 23-May-23 18:21 DUELink/SerialInterface.py
+-rw-rw-rw-  2.0 fat      623 b- defN 23-May-23 18:21 DUELink/Servo.py
+-rw-rw-rw-  2.0 fat     3989 b- defN 23-May-23 18:21 DUELink/Spi.py
+-rw-rw-rw-  2.0 fat     3635 b- defN 23-May-23 18:21 DUELink/System.py
+-rw-rw-rw-  2.0 fat      778 b- defN 23-May-23 18:21 DUELink/Temperature.py
+-rw-rw-rw-  2.0 fat      468 b- defN 23-May-23 18:21 DUELink/Touch.py
+-rw-rw-rw-  2.0 fat     1204 b- defN 23-May-23 18:21 DUELink/Uart.py
+-rw-rw-rw-  2.0 fat        0 b- defN 23-May-23 18:21 DUELink/__init__.py
+-rw-rw-rw-  2.0 fat      318 b- defN 23-May-24 18:53 DUELink-1.0.2.dist-info/METADATA
+-rw-rw-rw-  2.0 fat       92 b- defN 23-May-24 18:53 DUELink-1.0.2.dist-info/WHEEL
+-rw-rw-rw-  2.0 fat        8 b- defN 23-May-24 18:53 DUELink-1.0.2.dist-info/top_level.txt
+?rw-rw-r--  2.0 fat     2024 b- defN 23-May-24 18:53 DUELink-1.0.2.dist-info/RECORD
+27 files, 51006 bytes uncompressed, 14159 bytes compressed:  72.2%
```

## zipnote {}

```diff
@@ -1,76 +1,82 @@
-Filename: DUE/Analog.py
+Filename: DUELink/Analog.py
 Comment: 
 
-Filename: DUE/Button.py
+Filename: DUELink/Button.py
 Comment: 
 
-Filename: DUE/DUEController.py
+Filename: DUELink/DUELinkController.py
 Comment: 
 
-Filename: DUE/DeviceConfiguration.py
+Filename: DUELink/DeviceConfiguration.py
 Comment: 
 
-Filename: DUE/Digital.py
+Filename: DUELink/Digital.py
 Comment: 
 
-Filename: DUE/Display.py
+Filename: DUELink/Display.py
 Comment: 
 
-Filename: DUE/DistanceSensor.py
+Filename: DUELink/DistanceSensor.py
 Comment: 
 
-Filename: DUE/Frequency.py
+Filename: DUELink/Frequency.py
 Comment: 
 
-Filename: DUE/I2C.py
+Filename: DUELink/Humidity.py
 Comment: 
 
-Filename: DUE/Infrared.py
+Filename: DUELink/I2C.py
 Comment: 
 
-Filename: DUE/Led.py
+Filename: DUELink/Infrared.py
 Comment: 
 
-Filename: DUE/Neo.py
+Filename: DUELink/Led.py
 Comment: 
 
-Filename: DUE/Script.py
+Filename: DUELink/Neo.py
 Comment: 
 
-Filename: DUE/SerialInterface.py
+Filename: DUELink/Pin.py
 Comment: 
 
-Filename: DUE/ServoMoto.py
+Filename: DUELink/Script.py
 Comment: 
 
-Filename: DUE/Sound.py
+Filename: DUELink/SerialInterface.py
 Comment: 
 
-Filename: DUE/Spi.py
+Filename: DUELink/Servo.py
 Comment: 
 
-Filename: DUE/System.py
+Filename: DUELink/Spi.py
 Comment: 
 
-Filename: DUE/Touch.py
+Filename: DUELink/System.py
 Comment: 
 
-Filename: DUE/Uart.py
+Filename: DUELink/Temperature.py
 Comment: 
 
-Filename: DUE/__init__.py
+Filename: DUELink/Touch.py
 Comment: 
 
-Filename: DUELink-1.0.1.dist-info/METADATA
+Filename: DUELink/Uart.py
 Comment: 
 
-Filename: DUELink-1.0.1.dist-info/WHEEL
+Filename: DUELink/__init__.py
 Comment: 
 
-Filename: DUELink-1.0.1.dist-info/top_level.txt
+Filename: DUELink-1.0.2.dist-info/METADATA
 Comment: 
 
-Filename: DUELink-1.0.1.dist-info/RECORD
+Filename: DUELink-1.0.2.dist-info/WHEEL
+Comment: 
+
+Filename: DUELink-1.0.2.dist-info/top_level.txt
+Comment: 
+
+Filename: DUELink-1.0.2.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## Comparing `DUE/Analog.py` & `DUELink/Analog.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-from DUE.SerialInterface import SerialInterface
+from DUELink.SerialInterface import SerialInterface
 
 class AnalogController:
     def __init__(self, serialPort:SerialInterface):
         self.serialPort = serialPort
         self.Fixed_Frequency = 50
 
     def Read(self, pin):
@@ -21,15 +21,18 @@
                 return int(res.respone)
             except:
                 pass
 
         return -1
     
     def Write(self, pin, duty_cycle):
-        if pin < 0 or (pin >= self.serialPort.DeviceConfig.MaxPinIO): # Led
+        if pin == 'l' or pin == 'L':
+            pin = 108
+        
+        if pin < 0 or (pin >= self.serialPort.DeviceConfig.MaxPinIO and pin != 108): # Led
             raise ValueError('Invalid pin')
 
         if duty_cycle < 0 or duty_cycle > 1000:
             raise ValueError('Duty cycle must be in the range 0..1000')
 
         cmd = f'awrite({pin}, {duty_cycle})'
         self.serialPort.WriteCommand(cmd)
```

## Comparing `DUE/DUEController.py` & `DUELink/DUELinkController.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,29 +1,31 @@
-from DUE.Analog import AnalogController
-from DUE.Button import ButtonController
-from DUE.Digital import DigitalController
-from DUE.Display import DisplayController
-from DUE.DistanceSensor import DistanceSensorController
-from DUE.Frequency import FrequencyController
-from DUE.I2C import I2cController
-from DUE.Infrared import InfraredController
-from DUE.Neo import NeoController
-from DUE.System import SystemController
-from DUE.SerialInterface import SerialInterface
-from DUE.ServoMoto import ServoMotoController
-from DUE.Sound import SoundController
-from DUE.Spi import SpiController
-from DUE.Touch import TouchController
-from DUE.Uart import UartController
-from DUE.Led import LedController
-from DUE.Script import ScriptController
-from DUE.DeviceConfiguration import DeviceConfiguration
+from DUELink.Analog import AnalogController
+from DUELink.Button import ButtonController
+from DUELink.Digital import DigitalController
+from DUELink.Display import DisplayController
+from DUELink.DistanceSensor import DistanceSensorController
+from DUELink.Frequency import FrequencyController
+from DUELink.I2C import I2cController
+from DUELink.Infrared import InfraredController
+from DUELink.Neo import NeoController
+from DUELink.System import SystemController
+from DUELink.SerialInterface import SerialInterface
+from DUELink.Servo import ServoController
+from DUELink.Spi import SpiController
+from DUELink.Touch import TouchController
+from DUELink.Uart import UartController
+from DUELink.Led import LedController
+from DUELink.Script import ScriptController
+from DUELink.DeviceConfiguration import DeviceConfiguration
+from DUELink.Pin import PinController
+from DUELink.Temperature import TemperatureController
+from DUELink.Humidity import HudimityController
 from enum import Enum
 import platform
-class DUEController:
+class DUELinkController:
 
     def __init__(self, comPort: str):
         if comPort is None:
             raise ValueError(f"Invalid comport: {comPort}")
         try:
             self.__Connect(comPort)
         except:
@@ -31,28 +33,30 @@
         
         if self.serialPort is None:
             raise Exception(f"serialPort is null")
 
         self.Analog = AnalogController(self.serialPort)
         self.Digital = DigitalController(self.serialPort)
         self.I2c = I2cController(self.serialPort)
-        self.ServoMoto = ServoMotoController(self.serialPort)
+        self.Servo = ServoController(self.serialPort)
         self.Frequency = FrequencyController(self.serialPort)
         self.Spi = SpiController(self.serialPort)
         self.Infrared = InfraredController(self.serialPort)
         self.Neo = NeoController(self.serialPort)
         self.System = SystemController(self.serialPort)
         self.Uart = UartController(self.serialPort)
         self.Button = ButtonController(self.serialPort)
-        self.Distance = DistanceSensorController(self.serialPort)
-        self.Sound = SoundController(self.serialPort)
+        self.Distance = DistanceSensorController(self.serialPort)        
         self.Display = DisplayController(self.serialPort)
         self.Touch = TouchController(self.serialPort)
         self.Led = LedController(self.serialPort)
         self.Script = ScriptController(self.serialPort)
+        self.Pin = PinController()
+        self.Temperature = TemperatureController(self.serialPort)
+        self.Humidity = HudimityController(self.serialPort)
     
     def __Connect(self, comPort: str):
         self.serialPort = SerialInterface(comPort)
         self.serialPort.Connect()
 
         self.Version = self.serialPort.GetVersion().split("\n")[0]
 
@@ -96,24 +100,30 @@
             for port in com_ports_list:               
                 if port.vid ==0x1B9F and port.pid==0xF300:
                     if (platform.system() == 'Windows'):
                         return port.name                    
                     else:
                         return port.device
 
-        return ""
-    
-    class Pin:
-        ButtonA = 97
-        ButtonB = 98 
-        Led = 108
-
-    class Input:
-        PullNone = 0
-        PullUp = 1
-        PullDown = 2
+        return "" 
+
+    def Image(self, data, width: int, height: int):
+        if width <=0 or height <=0 or len(data) < width*height:
+            raise Exception("Invalid arguments")
+        
+        self.DataImg = [0] * (width * height + 2)
+
+        self.DataImg[0] = width
+        self.DataImg[1] = height
+
+        for i in range (width * height):
+            self.DataImg[2 + i] = data[i]
+
+        return self.DataImg
+
+
```

## Comparing `DUE/Digital.py` & `DUELink/Digital.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,16 +1,22 @@
 
-from DUE.SerialInterface import SerialInterface
+from DUELink.SerialInterface import SerialInterface
 
 class DigitalController:    
 
     def __init__(self, serialPort:SerialInterface):
         self.serialPort = serialPort
 
-    def Read(self, pin: int, inputType: 0) -> bool:
+    def Read(self, pin, inputType: 0) -> bool:
+        if pin == 'a' or pin == 'A':
+            pin = 97
+
+        if pin == 'b' or pin == 'B':
+            pin = 98
+
         if pin < 0 or (pin >= self.serialPort.DeviceConfig.MaxPinIO and pin != 97 and pin != 98 and pin != 108): #A, B, Led
             raise ValueError("Invalid pin")
 
         pull = "0"
         if inputType == 1:
             pull = "1"
         elif inputType == 2:
@@ -26,15 +32,18 @@
                 value = int(respone.respone)
                 return value == 1
             except:
                 pass
 
         return False
 
-    def Write(self, pin: int, value: bool) -> bool:
+    def Write(self, pin, value: bool) -> bool:
+        if pin == 'l' or pin == 'L':
+            pin = 108
+
         if pin < 0 or (pin >= self.serialPort.DeviceConfig.MaxPinIO and pin != 108): # Led
             raise ValueError("Invalid pin")
 
         cmd = f"dwrite({pin},{1 if value else 0})"
         self.serialPort.WriteCommand(cmd)
 
         respone = self.serialPort.ReadRespone()
```

## Comparing `DUE/Display.py` & `DUELink/Script.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,102 +1,118 @@
-class DisplayController:
-    def __init__(self, serialPort):
+import time
+from DUELink.SerialInterface import SerialInterface
+
+class ScriptController:
+    def __init__(self, serialPort : SerialInterface):
         self.serialPort = serialPort
 
-    def Show(self):
-        cmd = "lcdshow()"
+    def Run(self):
+        cmd = "run"
         self.serialPort.WriteCommand(cmd)
-        res = self.serialPort.ReadRespone()
-        return res.success
+        time.sleep(0.001)
 
-    def Clear(self, color):
-        cmd = f"lcdclear({color})"
+    def New(self) -> bool:
+        cmd = "new"
         self.serialPort.WriteCommand(cmd)
-        res = self.serialPort.ReadRespone()
-        return res.success
 
-    def SetPixel(self, color, x, y):
-        cmd = f"lcdpixel({color},{x},{y})"
-        self.serialPort.WriteCommand(cmd)
         res = self.serialPort.ReadRespone()
+
         return res.success
+    
+    def Load(self, script : str) -> bool:
+        cmd = "pgmstream()"
+
+        raw = script.encode('ASCII')
+
+        data = bytearray(len(raw) + 1)
+
+        data[len(raw)] = 0
+
+        data[0:len(raw)] = raw        
 
-    def DrawCircle(self, color, x, y, radius):
-        cmd = f"lcdcircle({color},{x},{y},{radius})"
         self.serialPort.WriteCommand(cmd)
+
         res = self.serialPort.ReadRespone()
-        return res.success
 
-    def DrawRectangle(self, color, x, y, width, height):
-        cmd = f"lcdrect({color},{x},{y},{width},{height})"
-        self.serialPort.WriteCommand(cmd)
+        if (res.success == False) :
+            return False
+        
+        self.serialPort.WriteRawData(data, 0, len(data))
+
         res = self.serialPort.ReadRespone()
         return res.success
+            
     
-    def FillRectangle(self, color, x, y, width, height):
-        cmd = f"lcdfill({color},{x},{y},{width},{height})"
+    def __Load2(self, script : str) -> bool:
+        ret = True
+        cmd = "$"
         self.serialPort.WriteCommand(cmd)
-        res = self.serialPort.ReadRespone()
-        return res.success
+        time.sleep(0.001)
+        script = script.replace("\r", "")
 
-    def DrawLine(self, color, x1, y1, x2, y2):
-        cmd = f"lcdline({color},{x1},{y1},{x2},{y2})"
-        self.serialPort.WriteCommand(cmd)
-        res = self.serialPort.ReadRespone()
-        return res.success
+        startIdx = 0
 
-    def DrawText(self, text, color, x, y):
-        cmd = f"lcdtext(\"{text}\",{color},{x},{y})"
+        for i in range(0, len(script)):
+            subscript = ""
+
+            if (script[i] == '\n'):
+                subscript = script[startIdx:i-startIdx]
+                startIdx = i + 1
+            elif i == len(script) - 1:
+                 subscript = script[startIdx:i-startIdx + 1]
+
+            self.serialPort.WriteCommand(subscript)
+
+            res = self.serialPort.ReadRespone()
+
+            if (res.success == False):
+                ret = False
+                break
+        
+        cmd = ">"
         self.serialPort.WriteCommand(cmd)
+    
         res = self.serialPort.ReadRespone()
-        return res.success
+        
+        return ret and res.success
+    
+    def Read(self) -> str:
+        cmd = "list"
 
-    def DrawTextScale(self, text, color, x, y, scalewidth, scaleheight):
-        cmd = f"lcdtexts(\"{text}\",{color},{x},{y},{scalewidth},{scaleheight})"
         self.serialPort.WriteCommand(cmd)
-        res = self.serialPort.ReadRespone()
-        return res.success
+        res = self.serialPort.ReadRespone2()
 
-    def __Stream(self, data):
-        cmd = "lcdstream()"
+        return res.respone
+    
+    def Execute(self, script : str) -> bool:
+        cmd = script
         self.serialPort.WriteCommand(cmd)
-        res = self.serialPort.ReadRespone()
 
-        if res.success:
-            self.serialPort.WriteRawData(data, 0, len(data))
-            # time.sleep(10)
-            res = self.serialPort.ReadRespone()
+        res = self.serialPort.ReadRespone()
 
-        return res.success
+        return res.respone
     
-    def DrawBuffer(self, color, offset: int, length: int):
-        WIDTH = 128
-        HEIGHT = 64
+    def IsRunning(self) -> bool:
+        self.serialPort.DiscardInBuffer()
 
-        if (length > WIDTH * HEIGHT) :
-            raise Exception("Only 64*128 supported.")
+        dataWrite = bytearray(1)
+        dataRead = bytearray(1)
 
-        data = bytearray(int(WIDTH*HEIGHT/8))
-        i = 0
+        dataWrite[0] = 0xFF
+        dataRead[0] = 0x00
 
-        for y in range(0, HEIGHT):
-            for x in range(0, WIDTH):
+        self.serialPort.WriteRawData(dataWrite, 0, 1)
+        time.sleep(0.001)
+      
+        count = self.serialPort.ReadRawData(dataRead, 0, 1)
 
-                index = (y >> 3) * WIDTH + x
+        if count == 0:
+            # if running, should received 0xff
+            # it not, need to send '\n' to clear 0xff that was sent.
+            dataWrite[0] = 10
+            self.serialPort.WriteRawData(dataWrite, 0, 1)
 
-                if ((color[i] & 0x00FFFFFF) != 0): # no alpha
-                    data[index] |= (1 << (y & 7)) & 0xFF
-                
-                else:
-                    data[index] &= (~(1 << (y & 7))) & 0xFF
-                
-                i += 1                
+            self.serialPort.ReadRespone()
 
-        return self.__Stream(data)
-    
-    def Config(self, target: int, slaveAddress: int)-> bool:
-        cmd = f"lcdconfig({target},{slaveAddress})"
-
-        self.serialPort.WriteCommand(cmd)
-        res = self.serialPort.ReadRespone()
-        return res.success
+        return dataRead[0] == 0xFF
 
+
```

## Comparing `DUE/DistanceSensor.py` & `DUELink/Infrared.py`

 * *Files 27% similar despite different names*

```diff
@@ -1,27 +1,30 @@
-from DUE.SerialInterface import SerialInterface
-
-class DistanceSensorController:
-    def __init__(self, serialPort:SerialInterface):
+class InfraredController:
+    def __init__(self, serialPort):
         self.serialPort = serialPort
 
-    def Read(self, pulsePin, echoPin):
+    def Read(self):
+        cmd = "print(irread())"
+        self.serialPort.WriteCommand(cmd)
+        res = self.serialPort.ReadRespone()
+        if res.success:
+            try:
+                return int(res.respone)
+            except:
+                pass
+        return -1
 
-        if pulsePin < 0 or pulsePin >= self.serialPort.DeviceConfig.MaxPinIO:
-            raise ValueError('Invalid pin')
+    def Enable(self, enable: bool):
+        en = 0
 
-        if echoPin < 0 or echoPin >= self.serialPort.DeviceConfig.MaxPinIO:
-            raise ValueError('Invalid pin')
+        if enable == True:
+            en = 1
 
-        cmd = f'print(distance({pulsePin},{echoPin}))'
+        cmd = "irenable({})".format(int(en))
         self.serialPort.WriteCommand(cmd)
 
         res = self.serialPort.ReadRespone()
 
         if res.success:
-            try:
-                distance = int(res.respone)
-                return distance
-            except ValueError:
-                pass
+            return True
 
-        return -1
+        return False
```

## Comparing `DUE/Frequency.py` & `DUELink/Frequency.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,22 +1,25 @@
 class FrequencyController:
     def __init__(self, serialPort):
         self.serialPort = serialPort
         self.MaxFrequency = 1000000
         self.MinFrequency = 16
 
-    def Write(self, frequency, duration_ms=0, dutycyle=500):
+    def Write(self, pin, frequency, duration_ms=0, dutycyle=500):
         if frequency < self.MinFrequency or frequency > self.MaxFrequency:
             raise ValueError("Frequency must be in range 16Hz..1000000Hz")
 
         if duration_ms > 99999999:
             raise ValueError("duration_ms must be in range 0..99999999")
 
         if dutycyle < 0 or dutycyle > 1000:
             raise ValueError("dutycyle must be in range 0..1000")
 
-        cmd = "freq({}, {}, {})".format(frequency, duration_ms, dutycyle)
+        if pin == 'p' or pin == 'P':
+            pin = 112
+
+        cmd = "freq({}, {}, {}, {})".format(pin, frequency, duration_ms, dutycyle)
         self.serialPort.WriteCommand(cmd)
 
         res = self.serialPort.ReadRespone()
 
         return res.success
```

## Comparing `DUE/I2C.py` & `DUELink/I2C.py`

 * *Files identical despite different names*

## Comparing `DUE/Infrared.py` & `DUELink/Servo.py`

 * *Files 27% similar despite different names*

```diff
@@ -1,25 +1,18 @@
-class InfraredController:
-    def __init__(self, serialPort):
+from DUELink.SerialInterface import SerialInterface
+
+class ServoController:
+    def __init__(self, serialPort:SerialInterface):
         self.serialPort = serialPort
 
-    def Read(self):
-        cmd = "print(irread())"
-        self.serialPort.WriteCommand(cmd)
-        res = self.serialPort.ReadRespone()
-        if res.success:
-            try:
-                return int(res.respone)
-            except:
-                pass
-        return -1
+    def Set(self, pin, position):
+        if pin < 0 or pin >= self.serialPort.DeviceConfig.MaxPinIO:
+            raise ValueError('Invalid pin')
+        if position < 0 or position > 180:
+            raise ValueError('Position must be in the range 0..180')
 
-    def Enable(self, enable):
-        cmd = "irenable({})".format(int(enable))
+        cmd = 'servoset({}, {})'.format(pin, position)
         self.serialPort.WriteCommand(cmd)
 
-        res = self.serialPort.ReadRespone()
-
-        if res.success:
-            return True
+        response = self.serialPort.ReadRespone()
 
-        return False
+        return response.success
```

## Comparing `DUE/Neo.py` & `DUELink/Neo.py`

 * *Files 2% similar despite different names*

```diff
@@ -38,18 +38,21 @@
         cmd = "neoset({0},{1},{2},{3})".format(id, red, green, blue)
         self.serialPort.WriteCommand(cmd)
 
         res = self.serialPort.ReadRespone()
 
         return res.success
 
-    def SetMultiple(self, pin: int, color, offset: int, length: int):
+    def SetMultiple(self, pin: int, color):
         if len(color) > self.MAX_LED_NUM:
             return False
-
+        
+        length = len(color) 
+        offset = 0
+        
         data = bytearray(length*3)
 
         for i in range(offset, length + offset):
             data[(i - offset) * 3 + 0] = (color[i] >> 16) & 0xff
             data[(i - offset) * 3 + 1] = (color[i] >> 8) & 0xff
             data[(i - offset) * 3 + 2] = (color[i] >> 0) & 0xff
```

## Comparing `DUE/SerialInterface.py` & `DUELink/SerialInterface.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 import time
 import serial
 from datetime import datetime, timedelta
-from DUE.DeviceConfiguration import DeviceConfiguration
+from DUELink.DeviceConfiguration import DeviceConfiguration
 
 class SerialInterface:
     CommandCompleteText = ">"
     DefaultBaudRate = 115200
 
     DeviceConfig : DeviceConfiguration
```

## Comparing `DUE/Sound.py` & `DUELink/Uart.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,36 +1,39 @@
-class SoundController:
-    def __init__(self, serialPort):
-        self.serialPort = serialPort
-        self.MaxFrequency = 1000000
-        self.MinFrequency = 16
-
-    def Play(self, frequency, duration_ms, volume):
-        if frequency < self.MinFrequency or frequency > self.MaxFrequency:
-            raise Exception("Frequency must be in range 16Hz..1000000Hz")
-
-        if duration_ms > 99999999:
-            raise Exception("duration_ms must be in range 0..99999999")
-
-        if volume < 0 or volume > 100:
-            raise Exception("volume must be in range 0..100")
-
-        cmd = "sound({}, {}, {})".format(frequency, duration_ms, volume)
-
-        self.serialPort.WriteCommand(cmd)
-
-        res = self.serialPort.ReadRespone()
-
+class UartController:
+    def __init__(self, serialport):
+        self.serialport = serialport
+
+    def Enable(self, baudrate):
+        cmd = "uartinit({})".format(baudrate)
+        self.serialport.WriteCommand(cmd)
+        res = self.serialport.ReadRespone()
         return res.success
 
-    def Stop(self):
-        frequency = 0
-        duration_ms = 0
-        volume = 0
-
-        cmd = "sound({}, {}, {})".format(frequency, duration_ms, volume)
-
-        self.serialPort.WriteCommand(cmd)
-
-        res = self.serialPort.ReadRespone()
-
+    def Write(self, data):
+        cmd = "uartwrite({})".format(data)
+        self.serialport.WriteCommand(cmd)
+        res = self.serialport.ReadRespone()
         return res.success
+
+    def BytesToRead(self):
+        cmd = "x=uartcount():print(x)"
+        self.serialport.WriteCommand(cmd)
+        res = self.serialport.ReadRespone()
+        if res.success:
+            try:
+                ready = int(res.respone)
+                return ready
+            except:
+                pass
+        raise Exception("BytesToRead error!")
+
+    def Read(self):
+        cmd = "x=uartread():print(x)"
+        self.serialport.WriteCommand(cmd)
+        res = self.serialport.ReadRespone()
+        if res.success:
+            try:
+                data = int(res.respone)
+                return data
+            except:
+                pass
+        raise Exception("Uart receving error!")
```

## Comparing `DUE/Spi.py` & `DUELink/Spi.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 from typing import Optional
 
 import time
-from DUE.SerialInterface import SerialInterface
+from DUELink.SerialInterface import SerialInterface
 
 class SpiController:
     def __init__(self, serialPort:SerialInterface):
         self.serialPort = serialPort
 
     def Write(self, dataWrite: bytes, offset: int, length: int, chipselect: int = -1) -> bool:
         return self.WriteRead(dataWrite, offset, length, None, 0, 0, chipselect)
```

